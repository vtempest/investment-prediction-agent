{
  "https://www.tradingview.com/script/R7DRiW77-Fair-Value-Gap-Signals-Kodexius/": {
    "id": 20081210,
    "url": "https://www.tradingview.com/script/R7DRiW77-Fair-Value-Gap-Signals-Kodexius/",
    "name": "Fair Value Gap Signals [Kodexius]",
    "description": "Fair Value Gap Signals is an advanced market structure tool that automatically detects and tracks Fair Value Gaps (FVGs), evaluates the quality of each gap, and highlights high value reaction zones with visual metrics and signal markers.\n\nThe script is designed for traders who focus on liquidity concepts, order flow and mean reversion. It goes beyond basic FVG plotting by continuously monitoring how price interacts with each gap and by quantifying three key aspects of each zone:\n\n -Entry velocity inside the gap\n-Volume absorption during tests\n-Structural integrity and depth of penetration \n\nThe result is a dynamic, information rich visualization of which gaps are being respected, which are being absorbed, and where potential reversals or continuations are most likely to occur.\n\nAll visual elements are configurable, including the maximum number of visible gaps per direction, mitigation method (close or wick) and an ATR based filter to ignore insignificant gaps in low volatility environments.\n\n  \n\n üîπ Features \n\n üî∏  Automated Fair Value Gap Detection \n\nThe script detects both bullish and bearish FVGs based on classic three candle logic:\n\n Bullish FVG:  current low is strictly above the high from two bars ago\n\n Bearish FVG:  current high is strictly below the low from two bars ago\n\n üî∏ ATR Based Gap Filter \n\nTo avoid clutter and low quality signals, the script can ignore very small gaps using an ATR based filter. \n\n üî∏Per Gap State Machine and Lifecycle \n\nEach gap is tracked with an internal status:\n\n Fresh:  gap has just formed and has not been tested\n\n Testing:  price is currently trading inside the gap\n\n Tested:  gap was tested and left, waiting for a potential new test\n\n Rejected:  price entered the gap and then rejected away from it\n\n Filled:  gap is considered fully mitigated and no longer active\n\nThis state machine allows the script to distinguish between simple touches, multiple tests and meaningful reversals, and to trigger different alerts accordingly.\n\n üî∏ Visual Ranking of Gaps by Metrics \n\nFor each active gap, three additional horizontal rank bars are drawn on top of the gap area:\n\nRank 1 (Vel): maximum entry velocity inside the gap\n\nRank 2 (Vol): relative test volume compared to average volume\n\nRank 3 (Dpt): remaining safety of the gap based on maximum penetration depth\n\nThese rank bars extend horizontally from the creation bar, and their length is a visual score between 0 and 1, scaled to the age of the gap. Longer bars represent stronger or more favorable conditions.\n\n  \n\n üî∏Signals and Rejection Markers \n\nWhen a gap shows signs of rejection (price enters the gap and then closes away from it with sufficient activity), the script can print a signal label at the reaction point. These markers summarize the internal metrics of the gap using a tooltip:\n\n -Velocity percentage\n-Volume percentage\n-Safety score\n-Number of tests \n\n  \n\n  \n\n üî∏ Flexible Mitigation Logic (Close or Wick) \n\nYou can choose how mitigation is defined via the Mitigation Method input:\n\n Close:  the gap is considered filled only when the closing price crosses the gap boundary\n\n Wick:  a full fill is detected as soon as any wick crosses the gap boundary\n\n üî∏ Alert Conditions \n\n -New FVG formed\n-Price entering a gap (testing)\n-Gap fully filled and invalidated\n-Rejection signal generated \n\n üîπCalculations \n\nThis section summarizes the main calculations used under the hood. Only the core logic is covered.\n\n 1. ATR Filter and Gap Size \n\nThe script uses a configurable ATR length to filter out small gaps. First the ATR is computed:\n\n float atrVal = ta.atr(atrLength) \n\nGap size for both directions is then measured:\n\n float gapSizeBull = low - high \nfloat gapSizeBear = low  - high \n\nIf useAtrFilter is enabled, gaps smaller than atrVal are ignored. This ties the minimum gap size to the current volatility regime.\n\n 2. Fair Value Gap Detection \n\nThe basic FVG conditions use a three bar structure:\n\n bool fvgBull = low > high \nbool fvgBear = high < low \n\nFor bullish gaps the script stores:\n\n-top as low of the current bar\n-bottom as high \n\nFor bearish gaps:\n\n-top as high of the current bar\n-bottom as low \n\nThis defines the price range that is considered the imbalance area.\n\n 3. Depth and Safety Score \n\nDepth measures how far price has penetrated into the gap since its creation. For each bar, the script computes a currentDepth and updates the maximum depth:\n\n float currentDepth = 0.0\nif g.isBullish\n    if l < g.top\n        currentDepth := g.top - l\nelse\n    if h > g.bottom\n        currentDepth := h - g.bottom\n\nif currentDepth > g.maxDepth\n    g.maxDepth := currentDepth \n\nThe safety score expresses how much of the gap remains intact:\n\n float depthRatio = g.maxDepth / gapSize\nfloat safetyScore = math.max(0.0, 1.0 - depthRatio) \n\nsafetyScore near 1: gap is mostly untouched\n\nsafetyScore near 0: gap is mostly or fully filled\n\n 4. Velocity Metric \n\nVelocity captures how aggressively price moves inside the gap. It is based on the body to range ratio of each bar that trades within the gap and rewards bars that move in the same direction as the gap:\n\n float barRange = h - l\nfloat bodyRatio = math.abs(close - open) / barRange\n\nfloat directionBonus = 0.0\nif g.isBullish and close > open\n    directionBonus := 0.2\nelse if not g.isBullish and close < open\n    directionBonus := 0.2\n\nfloat currentVelocity = math.min(bodyRatio + directionBonus, 1.0) \n\nThe gap keeps track of the strongest observed value:\n\n if currentVelocity > g.maxVelocity\n    g.maxVelocity := currentVelocity \n\nThis maximum is later used as velScore when building the velocity rank bar.\n\n 5. Volume Accumulation and Volume Score \n\nWhile price is trading inside a gap, the script accumulates the traded volume:\n\n if isInside\n    g.testVolume += volume \n\nIt also keeps track of the number of tests and the volume at the start of the first test:\n\n if g.status == \"Fresh\"\n    g.status := \"Testing\"\n    g.testCount := 1\n    g.testStartVolume := volume \n\nAn average volume is computed using a 20 period SMA:\n\n float volAvg = ta.sma(volume, 20) \n\nThe expected volume is approximated as:\n\n float expectedVol = volAvg * math.max(1, (bar_index - g.index) / 2) \n\nThe volume score is then:\n\n float volScore = math.min(g.testVolume / expectedVol, 1.0) \n\nThis produces a normalized 0 to 1 metric that shows whether the gap has attracted more or less volume than expected over its lifetime.\n\n 6. Rank Bar Scaling \n\nAll three scores are projected visually along the time axis as horizontal bars. The script uses the age of the gap in bars as the maximum width:\n\n float maxWidth = math.max(bar_index - g.index, 1) \n\nThen each metric is mapped to a bar length:\n\n int len1 = int(math.max(1, maxWidth * velScore))\ng.rankBox1.set_right(g.index + len1)\n\nint len2 = int(math.max(1, maxWidth * volScore))\ng.rankBox2.set_right(g.index + len2)\n\nint len3 = int(math.max(1, maxWidth * safetyScore))\ng.rankBox3.set_right(g.index + len3) \n\nThis creates an intuitive visual representation where stronger metrics produce longer rank bars, making it easy to quickly compare the relative quality of multiple FVGs on the chart.",
    "author_name": "Kodexius",
    "likes_count": 117,
    "comments_count": 0,
    "views_count": 0,
    "created_at": "2025-12-10T21:52:38+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "BINANCE:BTCUSDT",
      "full_name": "BINANCE:BTCUSDT",
      "short_name": "BTCUSDT",
      "exchange": "BINANCE",
      "type": "spot",
      "logo_id": null,
      "currency_logo_id": "crypto/XTVCUSDT",
      "base_currency_logo_id": "crypto/XTVCBTC",
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/crypto/XTVCBTC.svg",
        "https://s3-symbol-logo.tradingview.com/crypto/XTVCUSDT.svg"
      ],
      "interval": "1D",
      "direction": 0,
      "badge": {
        "label": "BINANCE:BTCUSDT",
        "url": "/symbols/BTCUSDT/"
      }
    },
    "created": "2025-12-10",
    "updated": "2025-12-10",
    "source": "// This work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International  \r\n// https://creativecommons.org/licenses/by-nc-sa/4.0/\r\n// ¬© Kodexius\r\n\r\n//@version=6\r\nindicator(\"Fair Value Gap Signals [Kodexius]\", overlay = true, max_boxes_count = 500, max_labels_count = 500)\r\n\r\n// -----------------------------------------------------------------------------\r\n// CONSTANTS & INPUTS\r\n// -----------------------------------------------------------------------------\r\nbool showSignals = input.bool(true, \"Show Signals / Absorption\", group = \"General\")\r\nbool showMetrics = input.bool(true, \"Show Velocity / Volume / Depth\", group = \"General\") \r\nint maxVisible = input.int(2, \"Show Last X FVG\", group = \"General\", minval = 1)\r\nstring mitigationType = input.string(\"Close\", \"Mitigation Method\", options = [\"Close\", \"Wick\"], group = \"General\")\r\n\r\nbool useAtrFilter = input.bool(true, \"ATR Filter\", \"Ignore small gaps smaller than ATR\", group = \"Filters\")\r\nint atrLength = input.int(14, \"ATR Length\", group = \"Filters\")\r\n\r\ncolor BULL_COLOR = color.new(#089981, 90) \r\ncolor BEAR_COLOR = color.new(#f23645, 90)\r\ncolor RANK_1_COLOR = color.new(#2962ff, 40) \r\ncolor RANK_2_COLOR = color.new(#ffeb3b, 40) \r\ncolor RANK_3_COLOR = color.new(#9c27b0, 40) \r\ncolor TEXT_COLOR = color.new(color.white, 40)\r\nint GAP_LIMIT = 50 \r\n\r\n// -----------------------------------------------------------------------------\r\n// TYPES\r\n// -----------------------------------------------------------------------------\r\ntype Gap\r\n    float top           \r\n    float bottom        \r\n    bool isBullish      \r\n    int index           \r\n    \r\n    // State Tracking\r\n    string status = \"Fresh\" \r\n    bool isActive = true\r\n    \r\n    // --- METRIC TRACKING (FIXED) ---\r\n    // Velocity: En agresif giri≈ü momentumunu takip eder (0-1 arasƒ±)\r\n    float maxVelocity = 0.0\r\n    \r\n    // Volume: Test sƒ±rasƒ±nda biriken toplam hacim\r\n    float testVolume = 0.0\r\n    float testStartVolume = 0.0  // Her yeni test seansƒ± i√ßin ba≈ülangƒ±√ß\r\n    int testCount = 0            // Ka√ß kez test edildi\r\n    \r\n    // Depth: Gap'e maximum ne kadar girildi (absolute deƒüer)\r\n    float maxDepth = 0.0\r\n    \r\n    // Visuals\r\n    box paramBox\r\n    box rankBox1 \r\n    box rankBox2 \r\n    box rankBox3 \r\n    label infoLabel\r\n\r\n// -----------------------------------------------------------------------------\r\n// METHODS\r\n// -----------------------------------------------------------------------------\r\n\r\n// Constructor\r\nmethod setup(Gap g, float top, float bottom, bool isBullish, int idx) =>\r\n    g.top := top\r\n    g.bottom := bottom\r\n    g.isBullish := isBullish\r\n    g.index := idx\r\n    g.status := \"Fresh\"\r\n    \r\n    // Initialize metrics\r\n    g.maxVelocity := 0.0\r\n    g.testVolume := 0.0\r\n    g.testStartVolume := 0.0\r\n    g.testCount := 0\r\n    g.maxDepth := 0.0\r\n    \r\n    // Draw initial box\r\n    g.paramBox := box.new(\r\n         left = idx, \r\n         top = top, \r\n         right = bar_index + 5, \r\n         bottom = bottom, \r\n         border_color = na, \r\n         bgcolor = isBullish ? BULL_COLOR : BEAR_COLOR,\r\n         text = \"\",\r\n         text_color = TEXT_COLOR,\r\n         text_size = size.tiny\r\n     )\r\n     \r\n    // Initialize Rank Boxes \r\n    float height = math.abs(top - bottom)\r\n    float h3 = height / 3\r\n    float y1 = top\r\n    float y2 = top - h3\r\n    float y3 = top - 2*h3\r\n\r\n    // Create boxes \r\n    g.rankBox1 := box.new(idx, y1, idx, y1 - h3, border_color = na, bgcolor = RANK_1_COLOR, text = \"Vel\", text_color = color.new(color.white, 20), text_size = size.tiny, text_halign = text.align_center, text_valign = text.align_center)\r\n    g.rankBox2 := box.new(idx, y2, idx, y2 - h3, border_color = na, bgcolor = RANK_2_COLOR, text = \"Vol\", text_color = color.new(color.white, 20), text_size = size.tiny, text_halign = text.align_center, text_valign = text.align_center)\r\n    g.rankBox3 := box.new(idx, y3, idx, y3 - h3, border_color = na, bgcolor = RANK_3_COLOR, text = \"Dpt\", text_color = color.new(color.white, 20), text_size = size.tiny, text_halign = text.align_center, text_valign = text.align_center)\r\n\r\n// Update logic called on every bar\r\n// Returns Event Code: 0=None, 1=Testing, 2=Filled, 3=Rejected\r\nmethod update(Gap g, float volAvg, bool showSig, bool showMet, bool isVisible, string mitType) =>\r\n    int eventCode = 0\r\n    if g.isActive\r\n        g.paramBox.set_right(bar_index + 1)\r\n        \r\n        // VISIBILITY LOGIC\r\n        if not isVisible\r\n            // Hide gap box and metrics only - KEEP SIGNALS VISIBLE\r\n            g.paramBox.set_bgcolor(na)\r\n            g.rankBox1.set_bgcolor(na)\r\n            g.rankBox2.set_bgcolor(na)\r\n            g.rankBox3.set_bgcolor(na)\r\n            g.rankBox1.set_text_color(na)\r\n            g.rankBox2.set_text_color(na)\r\n            g.rankBox3.set_text_color(na)\r\n            // infoLabel (signal) is NOT hidden - stays visible forever\r\n            int(na)\r\n        else\r\n            // Restore visuals\r\n            g.paramBox.set_bgcolor(g.isBullish ? BULL_COLOR : BEAR_COLOR)\r\n            \r\n            // === METRIC CALCULATIONS ===\r\n            float gapSize = math.abs(g.top - g.bottom)\r\n            float h = high\r\n            float l = low\r\n            \r\n            // Check if price is INSIDE the gap\r\n            bool isInside = (h >= g.bottom and l <= g.top)\r\n            \r\n            // --- DEPTH CALCULATION (Fixed) ---\r\n            // Gap'e ne kadar girildi - HER BARDA g√ºncellenir\r\n            float currentDepth = 0.0\r\n            if g.isBullish\r\n                // Bullish FVG: Fiyat yukarƒ±dan a≈üaƒüƒ± test eder\r\n                // Derinlik = gap'in √ºst√ºnden (top) ne kadar a≈üaƒüƒ± inildi\r\n                if l < g.top\r\n                    currentDepth := g.top - l\r\n            else\r\n                // Bearish FVG: Fiyat a≈üaƒüƒ±dan yukarƒ± test eder\r\n                // Derinlik = gap'in altƒ±ndan (bottom) ne kadar yukarƒ± √ßƒ±kƒ±ldƒ±\r\n                if h > g.bottom\r\n                    currentDepth := h - g.bottom\r\n            \r\n            // Maximum derinliƒüi g√ºncelle (tarihsel max)\r\n            if currentDepth > g.maxDepth\r\n                g.maxDepth := currentDepth\r\n            \r\n            // --- VELOCITY CALCULATION (Fixed) ---\r\n            // Her test barƒ±nda momentum hesapla, en g√º√ßl√ºs√ºn√º sakla\r\n            if isInside\r\n                float barRange = h - l\r\n                if barRange > 0\r\n                    // Body/Range oranƒ± - mumun ne kadar \"kararlƒ±\" olduƒüu\r\n                    float bodyRatio = math.abs(close - open) / barRange\r\n                    \r\n                    // Trend y√∂n√º ile uyum bonusu\r\n                    float directionBonus = 0.0\r\n                    if g.isBullish and close > open  // Bullish gap + bullish bar\r\n                        directionBonus := 0.2\r\n                    else if not g.isBullish and close < open  // Bearish gap + bearish bar\r\n                        directionBonus := 0.2\r\n                    \r\n                    float currentVelocity = math.min(bodyRatio + directionBonus, 1.0)\r\n                    \r\n                    // En y√ºksek velocity'yi sakla\r\n                    if currentVelocity > g.maxVelocity\r\n                        g.maxVelocity := currentVelocity\r\n            \r\n            // --- VOLUME CALCULATION (Fixed) ---\r\n            // Test sƒ±rasƒ±nda hacmi topla\r\n            if isInside\r\n                g.testVolume += volume\r\n                \r\n                // ƒ∞lk kez test ediliyorsa\r\n                if g.status == \"Fresh\"\r\n                    g.status := \"Testing\"\r\n                    g.testCount := 1\r\n                    g.testStartVolume := volume\r\n                    if showMet\r\n                        g.paramBox.set_text(\"T: 1\")\r\n                    eventCode := 1\r\n            else\r\n                // Gap dƒ±≈üƒ±na √ßƒ±kƒ±ldƒ± - yeni test i√ßin hazƒ±rlan\r\n                if g.status == \"Testing\"\r\n                    // Hala aktif, ama test bitti\r\n                    // Bir sonraki giri≈ü yeni bir test sayƒ±lacak\r\n                    g.status := \"Tested\"\r\n                else if g.status == \"Tested\" and (h >= g.bottom and l <= g.top)\r\n                    // Yeni bir test ba≈ülƒ±yor\r\n                    g.testCount += 1\r\n                    g.status := \"Testing\"\r\n                    if showMet\r\n                        g.paramBox.set_text(\"T: \" + str.tostring(g.testCount))\r\n            \r\n            // === VISUAL SCORE CALCULATIONS ===\r\n            float maxWidth = math.max(bar_index - g.index, 1)\r\n            \r\n            // Velocity Score (0-1): En agresif giri≈ü momentumu\r\n            float velScore = g.maxVelocity\r\n            int len1 = int(math.max(1, maxWidth * velScore))\r\n            g.rankBox1.set_right(g.index + len1)\r\n            \r\n            // Volume Score (0-1): Toplam test hacmi / Beklenen hacim\r\n            // Beklenen hacim = ortalama hacim * ge√ßen bar sayƒ±sƒ± / 2\r\n            float expectedVol = volAvg * math.max(1, (bar_index - g.index) / 2)\r\n            float volScore = math.min(g.testVolume / expectedVol, 1.0)\r\n            int len2 = int(math.max(1, maxWidth * volScore))\r\n            g.rankBox2.set_right(g.index + len2)\r\n            \r\n            // Depth Score (0-1): Gap'in ne kadarƒ± KORUNUYOR\r\n            // 1.0 = Hi√ß girilmedi (√ßok g√ºvenli), 0.0 = Tamamen dolduruldu\r\n            float depthRatio = g.maxDepth / gapSize\r\n            float safetyScore = math.max(0.0, 1.0 - depthRatio)\r\n            int len3 = int(math.max(1, maxWidth * safetyScore))\r\n            g.rankBox3.set_right(g.index + len3)\r\n            \r\n            // Metric visibility\r\n            if showMet\r\n                g.rankBox1.set_bgcolor(RANK_1_COLOR)\r\n                g.rankBox2.set_bgcolor(RANK_2_COLOR)\r\n                g.rankBox3.set_bgcolor(RANK_3_COLOR)\r\n                g.rankBox1.set_text_color(color.new(color.white, 20))\r\n                g.rankBox2.set_text_color(color.new(color.white, 20))\r\n                g.rankBox3.set_text_color(color.new(color.white, 20))\r\n            else\r\n                g.rankBox1.set_bgcolor(na)\r\n                g.rankBox2.set_bgcolor(na)\r\n                g.rankBox3.set_bgcolor(na)\r\n                g.rankBox1.set_text_color(na)\r\n                g.rankBox2.set_text_color(na)\r\n                g.rankBox3.set_text_color(na)\r\n\r\n            // === STATE CHECKS ===\r\n            \r\n            // 1. Check FILL condition (Mitigation)\r\n            bool filledInverse = false\r\n            if mitType == \"Close\"\r\n                filledInverse := g.isBullish ? (close < g.bottom) : (close > g.top)\r\n            else // Wick\r\n                filledInverse := g.isBullish ? (l < g.bottom) : (h > g.top)\r\n            \r\n            if filledInverse\r\n                g.status := \"Filled\"\r\n                g.isActive := false\r\n                // Delete gap visuals only - KEEP SIGNAL (infoLabel) FOREVER\r\n                g.paramBox.delete()\r\n                g.rankBox1.delete()\r\n                g.rankBox2.delete()\r\n                g.rankBox3.delete()\r\n                // infoLabel is NOT deleted - stays visible forever\r\n                eventCode := 2\r\n                eventCode\r\n            else\r\n                // 2. Check REJECTION signal\r\n                if isInside and g.testVolume > volAvg * 0.5\r\n                    // Rejection: Fiyat gap'e girdi ama ters y√∂nde kapandƒ±\r\n                    bool rejected = g.isBullish ? (l < g.top and close > g.top) : (h > g.bottom and close < g.bottom)\r\n                    \r\n                    if rejected\r\n                        g.status := \"Rejected\"\r\n                        g.paramBox.set_bgcolor(g.isBullish ? color.new(color.green, 60) : color.new(color.red, 60))\r\n                        \r\n                        if showSig and na(g.infoLabel)\r\n                            // ƒ∞kon se√ßimi: Velocity'ye g√∂re\r\n                            string icon = \"\"\r\n                            if g.maxVelocity > 0.6\r\n                                icon := \"‚ö°\"  // G√º√ßl√º momentum\r\n                            else\r\n                                icon := g.isBullish ? \"‚ñ≤\" : \"‚ñº\"\r\n                            \r\n                            // Tooltip ile detaylƒ± bilgi\r\n                            string tipText = \"Velocity: \" + str.tostring(velScore * 100, \"#.#\") + \"%\\n\"\r\n                            tipText += \"Volume: \" + str.tostring(volScore * 100, \"#.#\") + \"%\\n\"\r\n                            tipText += \"Safety: \" + str.tostring(safetyScore * 100, \"#.#\") + \"%\\n\"\r\n                            tipText += \"Tests: \" + str.tostring(g.testCount)\r\n                                \r\n                            g.infoLabel := label.new(\r\n                                 x = bar_index, \r\n                                 y = g.isBullish ? l : h, \r\n                                 text = icon,\r\n                                 style = g.isBullish ? label.style_label_up : label.style_label_down,\r\n                                 color = g.isBullish ? color.new(color.green, 30) : color.new(color.red, 30),\r\n                                 textcolor = color.white,\r\n                                 size = size.tiny,\r\n                                 tooltip = tipText\r\n                             )\r\n                        \r\n                        eventCode := 3\r\n                        eventCode\r\n                    else\r\n                        eventCode\r\n                else\r\n                    eventCode\r\n    else\r\n        eventCode\r\n\r\n// Garbage collection for old gaps\r\nmethod cleanup(array<Gap> gaps) =>\r\n    if gaps.size() > GAP_LIMIT\r\n        Gap g = gaps.shift()\r\n        g.paramBox.delete()\r\n        g.rankBox1.delete()\r\n        g.rankBox2.delete()\r\n        g.rankBox3.delete()\r\n        // infoLabel is NOT deleted - stays visible forever\r\n\r\n// -----------------------------------------------------------------------------\r\n// MAIN LOGIC\r\n// -----------------------------------------------------------------------------\r\nvar array<Gap> gaps = array.new<Gap>()\r\n\r\n// ATR Calculation for Filter\r\nfloat atrVal = ta.atr(atrLength)\r\n\r\n// FVG Detection\r\nbool fvgBull = low > high[2]\r\nbool fvgBear = high < low[2]\r\n\r\n// Apply ATR Filter\r\nif useAtrFilter\r\n    float gapSizeBull = low - high[2]\r\n    float gapSizeBear = low[2] - high\r\n    if fvgBull and gapSizeBull < atrVal\r\n        fvgBull := false\r\n    if fvgBear and gapSizeBear < atrVal\r\n        fvgBear := false\r\n\r\nif fvgBull\r\n    Gap newGap = Gap.new()\r\n    newGap.setup(low, high[2], true, bar_index - 1) \r\n    gaps.push(newGap)\r\n\r\nif fvgBear\r\n    Gap newGap = Gap.new()\r\n    newGap.setup(low[2], high, false, bar_index - 1)\r\n    gaps.push(newGap)\r\n\r\n// Pre-calculate averages\r\nfloat volAvg = ta.sma(volume, 20)\r\n\r\n// Update all existing gaps with Last X limitation\r\nint bullSeen = 0\r\nint bearSeen = 0\r\n\r\n// Global Event Flags for AlertCondition\r\nbool anyTesting = false\r\nbool anyFilled = false\r\nbool anySignal = false\r\n\r\n// Iterate BACKWARDS to find the most recent ones first\r\nif gaps.size() > 0\r\n    for i = gaps.size() - 1 to 0\r\n        Gap g = gaps.get(i)\r\n        \r\n        bool visible = false\r\n        // Only count valid (not filled) gaps\r\n        if g.status != \"Filled\"\r\n            if g.isBullish\r\n                if bullSeen < maxVisible\r\n                    visible := true\r\n                    bullSeen += 1\r\n            else\r\n                if bearSeen < maxVisible\r\n                    visible := true\r\n                    bearSeen += 1\r\n                    \r\n        int code = g.update(volAvg, showSignals, showMetrics, visible, mitigationType)\r\n        if code == 1\r\n            anyTesting := true\r\n        if code == 2\r\n            anyFilled := true\r\n        if code == 3\r\n            anySignal := true\r\n\r\n// Limit array size strictly\r\nif gaps.size() > GAP_LIMIT\r\n    Gap g = gaps.shift()\r\n    g.paramBox.delete()\r\n    g.rankBox1.delete()\r\n    g.rankBox2.delete()\r\n    g.rankBox3.delete()\r\n    // infoLabel is NOT deleted - stays visible forever\r\n\r\n// -----------------------------------------------------------------------------\r\n// ALERT CONDITIONS\r\n// -----------------------------------------------------------------------------\r\nalertcondition(fvgBull or fvgBear, \"New FVG Formed\", \"New Fair Value Gap Detected\")\r\nalertcondition(anyTesting, \"FVG Testing\", \"Price has entered a Gap (Test)\")\r\nalertcondition(anyFilled, \"FVG Filled\", \"Gap has been filled/invalidated\")\r\nalertcondition(anySignal, \"FVG Rejection Signal\", \"Price rejected from FVG (Potential Reversal)\")\r\n"
  },
  "https://www.tradingview.com/script/kWpZ5xNm-Dragon-Flow-Arrows-Smoothed-LITE/": {
    "id": 20088224,
    "url": "https://www.tradingview.com/script/kWpZ5xNm-Dragon-Flow-Arrows-Smoothed-LITE/",
    "name": "Dragon Flow Arrows (Smoothed LITE)",
    "description": "üöÄ DRAGON FLOW ARROWS ‚Äî LITE | Smart Trend Engine + Clean Reversal Arrows\n\nA lightweight but highly-optimized trend system designed for clean charts, powerful visual signals, and no-noise directional flow.\nBuilt for traders who want simplicity, clarity, and professional-level momentum-filtered signals without over-complication.\n\nüî• Dragon Channel (Clean 3-Line Ribbon)\nA smooth adaptive channel formed from ATR + EMA, giving you structural trend zones without clutter. No double bands, no messy overlaps just a clear upper/lower boundary.\n\n‚úÖ Dragon Flow Gradient\nA horizontal, color-shifted flow:\nüü¢ Bull flow ‚Üí green glow\nüî¥ Bear flow ‚Üí red glow\nAutomatic blend based on trend direction\nSmooth visual transitions (no vertical stripes)\n\n‚úÖ Momentum-Filtered Arrows (No Spam)\n \n BUY/SELL arrows only print when:\n Price breaks outside the Dragon Channel\n Momentum confirms (RSI + MACD filters)\n Trend flips ‚Üí one clean arrow per direction\n Text labels sit outside the channel for better readability.\n \n‚úÖ Smart Header Panel\nAt the top of your chart:\n \n üìå Trend: Uptrend / Downtrend / Neutral\n ‚ö° Impulse Strength: Weak / Normal / Strong\n  ¬© FxShareRobots.com brand bar\n \nEverything compact. Everything professional.\nüìä How to Use\n \n BUY Setup\n Price moving above baseline\n Dragon Flow turns bullish (cyan side)\n Arrow appears below channel\n SELL Setup\n Price breaks below baseline\n Dragon Flow turns bearish (magenta side)\n Arrow pops above channel\n \nExit / Filter\n \n Opposite arrow\n Flow color shift\n Trend panel flips\n Works on Forex, Crypto, Stocks, Indices ‚Äî all timeframes.\n \nüÜö LITE vs PRO\nFeature‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé LITE‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé PRO\nDragon Channel‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚úî‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚úî +Enhanced\nTrend Panel‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚úî‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚úî +Multi-TF\nReversal Arrows‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚úî‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚úî + Confirmation\nMomentum Filter‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚úî‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚úî +Expanded\nAlerts‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé‚úñ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé‚úî +Full Suite\nReversal Zones‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé‚Äé  ‚Äé‚Äé‚Äé ‚úñ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚úî +Predictive Map\nTrade Strategy‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé‚Äé ‚Äé ‚Äé ‚Äé ‚úñ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé ‚Äé‚úî +Included + PDF\n\nüîì Upgrade to DRAGON FLOW ‚Äî PRO\nUnlock alerts, HTF confirmation, advanced momentum engine, and predictive reversal zones:\nüëâ  fxsharerobots.com/itp/ \n‚ù§Ô∏è If this helped your trading ‚Äî please Like & Follow!\nThis supports future updates and keeps the LITE version source code free for the community.\n\nHappy trading,\nFxShareRobots Team",
    "author_name": "FxShareRobots",
    "likes_count": 42,
    "comments_count": 0,
    "views_count": 0,
    "created_at": "2025-12-12T03:18:32+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "BITSTAMP:BTCUSD",
      "full_name": "BITSTAMP:BTCUSD",
      "short_name": "BTCUSD",
      "exchange": "BITSTAMP",
      "type": "spot",
      "logo_id": null,
      "currency_logo_id": "country/US",
      "base_currency_logo_id": "crypto/XTVCBTC",
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/crypto/XTVCBTC.svg"
      ],
      "interval": "1D",
      "direction": 0,
      "badge": {
        "label": "BITSTAMP:BTCUSD",
        "url": "/symbols/BTCUSD/"
      }
    },
    "created": "2025-12-12",
    "updated": "2025-12-12",
    "source": "// This Pine Script¬Æ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// ¬© FxShareRobots\n\n//@version=6\nindicator(\"Dragon Flow Arrows (LITE)\", shorttitle=\"Dragon Flow (LITE)\", overlay=true)\n\n//--------------------------------------------------------\n//  Inputs \n//--------------------------------------------------------\nbasisLen    = input.int(50, \"Baseline Length\")\nshowBands   = input.bool(true,  \"Show Dragon Channel\")\nshowArrows  = input.bool(true,  \"Show Entry Arrows\")\nsmoothLen   = input.int(3,  \"Channel Smoothing\", minval=1, maxval=50)\nblendSmooth = input.int(5,  \"Color Blend Smoothing\", minval=1, maxval=50)\n\n//--------------------------------------------------------\n//  Settings\n//--------------------------------------------------------\natrLen   = 14\natrMult  = 2.0\nrsiLen   = 14\nmacdFast = 12\nmacdSlow = 26\nmacdSig  = 9\n\n//--------------------------------------------------------\n// Core Logic\n//--------------------------------------------------------\nbasis   = ta.ema(close, basisLen)\natr     = ta.atr(atrLen)\n\nupBand = basis + atrMult * atr\ndnBand = basis - atrMult * atr\n\nimpulseUp = close > basis and close > upBand\nimpulseDn = close < basis and close < dnBand\n\nrsi       = ta.rsi(close, rsiLen)\nmacdLine  = ta.ema(close, macdFast) - ta.ema(close, macdSlow)\nmacdSigLn = ta.ema(macdLine, macdSig)\nmacdHist  = macdLine - macdSigLn\n\nmomUp = rsi > 50 and macdHist > 0\nmomDn = rsi < 50 and macdHist < 0\n\nlongCond  = impulseUp and momUp\nshortCond = impulseDn and momDn\n\nvar string lastSignal = \"NONE\"\nnewBuy  = longCond  and lastSignal != \"BUY\"\nnewSell = shortCond and lastSignal != \"SELL\"\n\nif newBuy\n    lastSignal := \"BUY\"\nelse if newSell\n    lastSignal := \"SELL\"\n\n//--------------------------------------------------------\n// Smoothed Dragon Channel \n//--------------------------------------------------------\nbasisSmoothed = ta.ema(basis,  smoothLen)\nupBandSm      = ta.ema(upBand, smoothLen)\ndnBandSm      = ta.ema(dnBand, smoothLen)\n\nbaseColor = color.new(#f4f4f4, 0)\nedgeColor = color.new(#000000, 0)\n\nplot(basisSmoothed, \"Baseline\", baseColor, 3)\npUp = plot(showBands ? upBandSm : na, \"Dragon Upper\", edgeColor)\npDn = plot(showBands ? dnBandSm : na, \"Dragon Lower\", edgeColor)\n\n//--------------------------------------------------------\n// Dragon Cloud \n//--------------------------------------------------------\n\n// Strength only for panel (not used for cloud opacity)\nstrengthRaw = math.abs(macdHist) + math.abs(rsi - 50.0) / 50.0\nstrength    = math.min(strengthRaw * 0.6, 1.0)\n\n// Trend value: -1 SELL, 0 NEUTRAL, +1 BUY, smoothed over time\ntrendVal    = lastSignal == \"BUY\" ? 1.0 : lastSignal == \"SELL\" ? -1.0 : 0.0\ntrendSmooth = ta.ema(trendVal, blendSmooth)\n\n// Neon core colors for blend (bear -> bull)\nbearCore = color.rgb(255, 0, 0)    // magenta\nbullCore = color.rgb(0, 255, 64)    // cyan\n\n// horizontal blend from bearCore -> bullCore over time\ncoreCloudColor = color.from_gradient(trendSmooth, -1.0, 1.0, bearCore, bullCore)\n\n// CONSTANT opacity\nalphaCloud = 72\ndragonColor = lastSignal == \"NONE\"\n     ? color.new(color.gray, 88)\n     : color.new(coreCloudColor, alphaCloud)\n\n// single cloud\nfill(pUp, pDn, showBands ? dragonColor : na, title=\"Dragon Cloud\")\n\n//--------------------------------------------------------\n// Arrows outside channel\n//--------------------------------------------------------\narrowOffsetFactor = 2.0   // distance from channel\ntextOffsetFactor  = 0.8   // distance between arrow and text\n\nbuyArrowY  = dnBandSm - atr * arrowOffsetFactor\nbuyTextY   = buyArrowY - atr * textOffsetFactor\n\nsellArrowY = upBandSm + atr * arrowOffsetFactor\nsellTextY  = sellArrowY + atr * textOffsetFactor\n\nif showArrows and newBuy\n    label.new(\n         bar_index, buyArrowY,\n         text      = \"\",\n         style     = label.style_triangleup,\n         color     = color.new(color.green, 0),\n         textcolor = color.white,\n         size      = size.large)\n    label.new(\n         bar_index, buyTextY,\n         text      = \"BUY\",\n         style     = label.style_label_center,\n         color     = color.new(color.green, 85),\n         textcolor = color.new(#6186ff, 0),\n         size      = size.small)\n\nif showArrows and newSell\n    label.new(\n         bar_index, sellArrowY,\n         text      = \"\",\n         style     = label.style_triangledown,\n         color     = color.new(color.red, 0),\n         textcolor = color.white,\n         size      = size.large)\n    label.new(\n         bar_index, sellTextY,\n         text      = \"SELL\",\n         style     = label.style_label_center,\n         color     = color.new(color.red, 85),\n         textcolor = color.new(#6186ff, 0),\n         size      = size.small)\n\n//--------------------------------------------------------\n// Dragon Header Panel\n//--------------------------------------------------------\nvar table panel = table.new(position.top_center, 1, 3, border_width=0)\n\n// trend text & color\ntrend = lastSignal == \"BUY\" ? 1 : lastSignal == \"SELL\" ? -1 : 0\ntrendText  = trend == 1 ? \"UPTREND\" : trend == -1 ? \"DOWNTREND\" : \"NEUTRAL\"\ntrendColor = trend == 1 ? color.rgb(0, 200, 83) : trend == -1 ? color.rgb(229, 57, 53) : color.rgb(120, 120, 120)\n\n// impulse text & color\nstrengthText =\n     strength < 0.33 ? \"WEAK\"   :\n     strength < 0.66 ? \"NORMAL\" :\n                       \"STRONG\"\n\nstrengthColor =\n     strength < 0.33 ? color.rgb(120, 144, 156) :\n     strength < 0.66 ? color.rgb(255, 193, 7)   :\n                       color.rgb(0, 230, 118)\n\nif barstate.islast\n    table.cell(panel, 0, 0,\n        \"DRAGON FLOW ARROWS ‚Äî LITE   |   ¬© FxShareRobots.com\",\n        text_color  = color.white,\n        bgcolor     = color.rgb(5, 5, 10),\n        text_halign = text.align_center,\n        width       = 40)\n    table.cell(panel, 0, 1,\n        \"TREND: \" + trendText,\n        text_color  = color.white,\n        bgcolor     = trendColor,\n        text_halign = text.align_center,\n        width       = 40)\n    table.cell(panel, 0, 2,\n        \"IMPULSE: \" + strengthText,\n        text_color  = color.white,\n        bgcolor     = strengthColor,\n        text_halign = text.align_center,\n        width       = 40)\n"
  },
  "https://www.tradingview.com/script/9Xc02kcZ/": {
    "id": 20087667,
    "url": "https://www.tradingview.com/script/9Xc02kcZ/",
    "name": "RSI Multi-Timeframe Table",
    "description": "How the RSI Multi-Timeframe Table Indicator Works\n\nThis indicator displays a table showing the RSI (14) from multiple timeframes at the same time.\nIt helps you quickly see whether the RSI is in overbought or oversold zones across different periods (1m, 5m, 15m, 30m, 1h, 4h, and 1D).\n\nBelow is a clear explanation of how each part works:\n\n1) Timeframes Used\n\nThe indicator analyzes the RSI from the following timeframes:\n\n1 minute (1m)\n\n5 minutes (5m)\n\n15 minutes (15m)\n\n30 minutes (30m)\n\n1 hour (1h)\n\n4 hours (4h)\n\n1 day (1D)\n\nEach row of the table represents one of these timeframes.\n\n2) How the RSI Is Retrieved\n\nFor each timeframe, the script uses the request.security() function to fetch the RSI(14) value from that specific timeframe, even if your current chart is set to a different one.\n\nExample: On a 1h chart, you can still see the RSI from 1m, 5m, 30m, etc.\n\n3) Table Structure\n\nThe table appears in the top-right corner and contains 8 columns:\n\nTF ‚Äì shows the timeframe name\n\nRSI ‚Äì shows the RSI value with two decimal places\n\n10 ‚Äì marks if RSI is ‚â§ 10\n\n20 ‚Äì marks if RSI is ‚â§ 20\n\n30 ‚Äì marks if RSI is ‚â§ 30\n\n70 ‚Äì marks if RSI is ‚â• 70\n\n80 ‚Äì marks if RSI is ‚â• 80\n\n90 ‚Äì marks if RSI is ‚â• 90\n\nThe extreme levels (10, 20, 80, 90) help identify possible reversal zones.\n\n4) Markings in the Table\n\nWhen a condition is true, a ‚óè circle appears in the corresponding cell.\n\nExamples:\n\nIf the 5m RSI is ‚â§ 20, a circle appears in the 20 column for the 5m row.\n\nIf the 1H RSI is ‚â• 80, a circle appears in the 80 column for the 1H row.\n\nColors also help interpretation:\n\nRed for strong oversold levels (‚â§10)\n\nOrange and yellow for intermediate levels\n\nGreen, teal, and blue for overbought levels\n\n5) Alerts\n\nThe indicator includes four built-in alerts:\n\nRSI ‚â§ 10\n\nRSI ‚â§ 20\n\nRSI ‚â• 80\n\nRSI ‚â• 90\n\nThese alerts use the RSI from the current chart timeframe.\n\nTo enable them:\n\nOpen Alerts in TradingView\n\nClick Create Alert\n\nSelect the indicator\n\nChoose the alert you want\n\nConfirm\n\n6) Purpose of This Indicator\n\nIt is useful for:\n\nQuickly checking market strength across multiple timeframes\n\nIdentifying when several periods are overbought or oversold\n\nAvoiding trades against market momentum\n\nHelping confirm potential reversal points\n\nSummary\n\nThis indicator creates a table that shows RSI values from multiple timeframes and visually highlights overbought or oversold conditions in each one.\nIt also includes ready-to-use alerts for the most extreme RSI levels.",
    "author_name": "PortugaBR",
    "likes_count": 7,
    "comments_count": 1,
    "views_count": 0,
    "created_at": "2025-12-11T23:47:51+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "BINANCE:BTCUSDT.P",
      "full_name": "BINANCE:BTCUSDT.P",
      "short_name": "BTCUSDT.P",
      "exchange": "BINANCE",
      "type": "swap",
      "logo_id": null,
      "currency_logo_id": "crypto/XTVCUSDT",
      "base_currency_logo_id": "crypto/XTVCBTC",
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/crypto/XTVCBTC.svg",
        "https://s3-symbol-logo.tradingview.com/crypto/XTVCUSDT.svg"
      ],
      "interval": "60",
      "direction": 0,
      "badge": {
        "label": "BINANCE:BTCUSDT.P",
        "url": "/symbols/BTCUSDT.P/"
      }
    },
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=6\r\nindicator(\"RSI Multi-Timeframe Table\", overlay=true)\r\n\r\n// --- Timeframes desejados ---\r\ntfs   = array.from(\"1\", \"5\", \"15\", \"30\", \"60\", \"240\", \"D\")\r\ntfLbl = array.from(\"1m\", \"5m\", \"15m\", \"30m\", \"1h\", \"4h\", \"1D\")\r\n\r\n// Fun√ß√£o para pegar RSI de cada timeframe\r\nf_rsi(tf) =>\r\n    request.security(syminfo.tickerid, tf, ta.rsi(close, 14))\r\n\r\n// Cria tabela (8 colunas: 0 a 7)\r\nvar t = table.new(position.top_right, 8, 8, border_width=1)\r\n\r\n// Cabe√ßalho\r\nif barstate.isfirst\r\n    table.cell(t, 0, 0, \"TF\",  text_color=color.white, bgcolor=color.blue)\r\n    table.cell(t, 1, 0, \"RSI\", text_color=color.white, bgcolor=color.blue)\r\n    table.cell(t, 2, 0, \"10\",  text_color=color.white, bgcolor=color.blue)\r\n    table.cell(t, 3, 0, \"20\",  text_color=color.white, bgcolor=color.blue)\r\n    table.cell(t, 4, 0, \"30\",  text_color=color.white, bgcolor=color.blue)\r\n    table.cell(t, 5, 0, \"70\",  text_color=color.white, bgcolor=color.blue)\r\n    table.cell(t, 6, 0, \"80\",  text_color=color.white, bgcolor=color.blue)\r\n    table.cell(t, 7, 0, \"90\",  text_color=color.white, bgcolor=color.blue)\r\n\r\n// Preenche linhas\r\nfor i = 0 to array.size(tfs) - 1\r\n    rsiVal = f_rsi(array.get(tfs, i))\r\n    lbl    = array.get(tfLbl, i)\r\n\r\n    // Linha da timeframe\r\n    table.cell(t, 0, i+1, lbl, text_color=color.white, bgcolor=color.new(color.gray, 70))\r\n    table.cell(t, 1, i+1, str.tostring(rsiVal, \"#.##\"), text_color=color.yellow)\r\n\r\n    // C√©lulas dos n√≠veis\r\n    table.cell(t, 2, i+1, rsiVal <= 10 ? \"‚óè\" : \"\", text_color=color.red)\r\n    table.cell(t, 3, i+1, rsiVal <= 20 ? \"‚óè\" : \"\", text_color=color.orange)\r\n    table.cell(t, 4, i+1, rsiVal <= 30 ? \"‚óè\" : \"\", text_color=color.yellow)\r\n\r\n    table.cell(t, 5, i+1, rsiVal >= 70 ? \"‚óè\" : \"\", text_color=color.green)\r\n    table.cell(t, 6, i+1, rsiVal >= 80 ? \"‚óè\" : \"\", text_color=color.teal)\r\n    table.cell(t, 7, i+1, rsiVal >= 90 ? \"‚óè\" : \"\", text_color=color.blue)\r\n\r\n\r\n// ---------------------------------------------------\r\n//                  ALERTAS\r\n// ---------------------------------------------------\r\nrsi_current = ta.rsi(close, 14)\r\n\r\n// Alertas de sobrevenda\r\nalertcondition(rsi_current <= 10, \"RSI <= 10\",  \"RSI atual menor ou igual a 10\")\r\nalertcondition(rsi_current <= 20, \"RSI <= 20\",  \"RSI atual menor ou igual a 20\")\r\n\r\n// Alertas de sobrecompra\r\nalertcondition(rsi_current >= 80, \"RSI >= 80\",  \"RSI atual maior ou igual a 80\")\r\nalertcondition(rsi_current >= 90, \"RSI >= 90\",  \"RSI atual maior ou igual a 90\")\r\n"
  },
  "https://www.tradingview.com/script/YbYXPAXk-JSP-NEW-Supertrend/": {
    "id": 20083248,
    "url": "https://www.tradingview.com/script/YbYXPAXk-JSP-NEW-Supertrend/",
    "name": " JSP NEW Supertrend",
    "description": "for consitanously profit use 3 min 5 min option trading ",
    "author_name": "jeevanpatil7588",
    "likes_count": 46,
    "comments_count": 0,
    "views_count": 0,
    "created_at": "2025-12-11T07:33:17+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "BSE:BSX251211C84400",
      "full_name": "BSE:BSX251211C84400",
      "short_name": "BSX251211C84400",
      "exchange": "BSE",
      "type": null,
      "logo_id": null,
      "currency_logo_id": null,
      "base_currency_logo_id": null,
      "logo_urls": null,
      "interval": "3",
      "direction": 0,
      "badge": {
        "label": "BSE:BSX251211C84400",
        "url": null
      }
    },
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=6\r\nindicator(' JSP NEW Supertrend', overlay = true, format = format.price, precision = 2, timeframe = '')\r\n\r\nPeriods = input(title = 'ATR Period', defval = 10)\r\nsrc = input(hl2, title = 'Source')\r\nMultiplier = input.float(title = 'ATR Multiplier', step = 0.1, defval = 1.0)\r\nchangeATR = input(title = 'Change ATR Calculation Method ?', defval = true)\r\nshowsignals = input(title = 'Show Buy/Sell Signals ?', defval = true)\r\nhighlighting = input(title = 'Highlighter On/Off ?', defval = true)\r\natr2 = ta.sma(ta.tr, Periods)\r\natr = changeATR ? ta.atr(Periods) : atr2\r\nup = src - Multiplier * atr\r\nup1 = nz(up[1], up)\r\nup := close[1] > up1 ? math.max(up, up1) : up\r\ndn = src + Multiplier * atr\r\ndn1 = nz(dn[1], dn)\r\ndn := close[1] < dn1 ? math.min(dn, dn1) : dn\r\ntrend = 1\r\ntrend := nz(trend[1], trend)\r\ntrend := trend == -1 and close > dn1 ? 1 : trend == 1 and close < up1 ? -1 : trend\r\nupPlot = plot(trend == 1 ? up : na, title = 'Up Trend', style = plot.style_linebr, linewidth = 2, color = color.rgb(10, 253, 18))\r\nbuySignal = trend == 1 and trend[1] == -1\r\nplotshape(buySignal ? up : na, title = 'UpTrend Begins', location = location.absolute, style = shape.circle, size = size.tiny, color = color.new(color.green, 0))\r\nplotshape(buySignal and showsignals ? up : na, title = 'B', text = 'B', location = location.absolute, style = shape.labelup, size = size.tiny, color = color.new(color.green, 0), textcolor = color.new(color.white, 0))\r\ndnPlot = plot(trend == 1 ? na : dn, title = 'Down Trend', style = plot.style_linebr, linewidth = 2, color = color.rgb(240, 9, 9))\r\nsellSignal = trend == -1 and trend[1] == 1\r\nplotshape(sellSignal ? dn : na, title = 'DownTrend Begins', location = location.absolute, style = shape.circle, size = size.tiny, color = color.new(color.red, 0))\r\nplotshape(sellSignal and showsignals ? dn : na, title = 'S', text = 'S', location = location.absolute, style = shape.labeldown, size = size.tiny, color = color.new(color.red, 0), textcolor = color.new(color.white, 0))\r\nmPlot = plot(ohlc4, title = '', style = plot.style_circles, linewidth = math.max(1, 0))\r\n\r\n\r\nalertcondition(buySignal, title = 'SuperTrend B', message = 'SuperTrend Buy!')\r\nalertcondition(sellSignal, title = 'SuperTrend S', message = 'SuperTrend Sell!')\r\nchangeCond = trend != trend[1]\r\nalertcondition(changeCond, title = 'SuperTrend Direction Change', message = 'SuperTrend has changed direction!')\r\n\r\n//indicator('JSP Hull 2x@', overlay=true)\r\n\r\n// ShowHulls    = input(true,            title=\"Show Hull MA's\")\r\nShowHulls = true\r\n\r\nHull1Len = input.int(defval=10, title='Fast Length - Hull 1', minval=1)\r\n\r\nHull2Len = input.int(defval=12, title='Slow Length - Hull 2', minval=1)\r\n\r\nPaintBars = input(false, title='Paint Bars According to Hull 1 Direction')\r\n\r\n\r\nHull1 = ta.wma(2 * ta.wma(close, Hull1Len / 2) - ta.wma(close, Hull1Len), math.round(math.sqrt(Hull1Len)))\r\nHull2 = ta.wma(2 * ta.wma(close, Hull2Len / 2) - ta.wma(close, Hull2Len), math.round(math.sqrt(Hull2Len)))\r\n\r\n\r\nHull1Color = Hull1 > Hull1[1] ? #00ff80 : #ff0080  // #00ff80 that funny green lime\r\nHull2Color = Hull2 > Hull2[1] ? #00ff00 : #ff0000  // #00ff80 that funny green lime\r\n\r\nHullTrendColor = Hull1 > Hull2 ? color.lime : color.red\r\n\r\nHullBuySignal = ta.crossover(Hull1, Hull2)\r\nHullSellSignal = ta.crossunder(Hull1, Hull2)\r\n\r\nplot(ShowHulls ? Hull1 : na, title='Hull 1', color=Hull1Color, linewidth=2)\r\nplot(ShowHulls ? Hull2 : na, title='Hull 2', color=Hull2Color, linewidth=2)\r\n\r\n"
  },
  "https://www.tradingview.com/script/OXGwjd4z-DR-IDR-fractals-break-EMA-Clouds-VWAP/": {
    "id": 20086689,
    "url": "https://www.tradingview.com/script/OXGwjd4z-DR-IDR-fractals-break-EMA-Clouds-VWAP/",
    "name": "DR/IDR, fractals, break + EMA Clouds + VWAP",
    "description": "This indicator is a powerful, multi-layered trading tool that combines three distinct forms of market analysis‚Äîvolume, trend, and opening volatility‚Äîonto a single chart.\n\n1. Opening Range Breakout (ORB) System\nThis is the foundation of the indicator, designed to capture the initial volatility and set key price boundaries for the trading day.\n\nTime Focus: The indicator's primary analysis is centered on a specific, user-defined time period (default is 9:30 AM to 10:30 AM New York Time). Nothing related to the ORB drawing will appear on the chart before this session starts.\n\nWick High/Low (The Trigger): These lines track the absolute highest and lowest prices reached during the time window. They define the full extent of the initial range and are used to determine when a genuine breakout occurs.\n\nBody High/Low (The Range & Targets): These lines track the highest and lowest open/close prices of the candles within the session. This area forms the central, shaded zone, representing the core consolidation area.\n\nRange Shading: The background between the Body High and Body Low is shaded, but this visual feature only appears during the active forming time window (e.g., 9:30 AM to 10:30 AM) to maintain chart clarity.\n\nFractals: While the range is forming, the indicator detects 5-bar Williams Fractal patterns that occur inside the range. These small triangles (‚ñ≤ or ‚ñº) highlight minor reversal points established by the early trading action.\n\nBreakout Signal: After the user-defined time window closes, the indicator waits. If a subsequent candle's price moves above the Wick High or below the Wick Low, a \"BREAK\" label is displayed on that candle. It is programmed to label only the first decisive break in each direction per day.\n\nExtension Targets: When a breakout occurs, target lines are automatically projected above the Body High (for a bullish break) or below the Body Low (for a bearish break). The distance between these targets is calculated based on a user-defined fraction (e.g., 0.5 steps) of the total height of the Body Range.\n\nLine Cutoff: For tidiness, you can set a \"Stop Time\" (e.g., 4:00 PM) after which the ORB lines will automatically disappear.\n\n2. EMA Clouds (Trend and Momentum)\nFour distinct Exponential Moving Average (EMA) clouds are plotted to provide a dynamic, multi-speed view of the market's trend and momentum.\n\nStructure: Each \"Cloud\" is the shaded area between two EMAs (one shorter length and one longer length). The indicator includes four customizable pairs (defaulting to common settings like 8/9, 8/14, 34/50, and 14/21).\n\nTrend Coloring: The clouds are color-coded:\n\nBullish (Greenish): The shorter EMA is trading above the longer EMA, signaling upward momentum.\n\nBearish (Reddish): The shorter EMA is trading below the longer EMA, signaling downward momentum.\n\nApplication: These clouds are used to confirm the overall market direction or identify potential zones of support and resistance.\n\n3. Volume-Weighted Average Price (VWAP)\nThe VWAP is a crucial anchor for measuring the market's efficiency throughout the trading day.\n\nFunction: It calculates the average price of the asset, giving more weight to prices where higher volume was traded.\n\nContext: It helps traders quickly determine if the current price is trading at a premium (above VWAP) or a discount (below VWAP) relative to the day's volume.\n\nReset: The VWAP line automatically resets at the beginning of each trading day.\n\nCustomization: The VWAP line can be toggled on or off, and its color and width are fully adjustable.",
    "author_name": "ChadAnt",
    "likes_count": 23,
    "comments_count": 0,
    "views_count": 0,
    "created_at": "2025-12-11T18:31:33+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "CME_MINI:ES1!",
      "full_name": "CME_MINI:ES1!",
      "short_name": "ES1!",
      "exchange": "CME_MINI",
      "type": "futures",
      "logo_id": "indices/s-and-p-500",
      "currency_logo_id": "country/US",
      "base_currency_logo_id": null,
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/indices/s-and-p-500.svg"
      ],
      "interval": "5",
      "direction": 0,
      "badge": {
        "label": "CME_MINI:ES1!",
        "url": "/symbols/CME_MINI-ES1!/"
      }
    },
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=5\r\nindicator(\"DR/IDR, fractals, break + EMA Clouds + VWAP\", overlay=true, shorttitle=\"DR/IDR Clouds VWAP\")\r\n\r\n// ==========================================\r\n// 1. USER INPUTS\r\n// ==========================================\r\n\r\n// --- ORB Time Settings ---\r\ngrp_time = \"ORB Time Settings\"\r\nsessionInput = input.session(\"0930-1030\", \"Opening Range Session (NY Time)\", group=grp_time)\r\nendTimeInput = input.int(1600, \"ORB Lines Stop Time (HHMM)\", group=grp_time)\r\ntimezone     = \"America/New_York\" \r\n\r\n// --- ORB Visual Settings ---\r\ngrp_style = \"ORB Visual Styles\"\r\nwickColor = input.color(color.new(color.gray, 0), \"Wick Line Color\", group=grp_style)\r\nbodyColor = input.color(color.new(#90cafa, 0), \"Body Line Color\", group=grp_style)\r\nfillColor = input.color(color.new(color.blue, 90), \"Body Range Fill Color\", group=grp_style)\r\nlineWidth = input.int(1, \"Line Width\", minval=1, group=grp_style)\r\n\r\n// --- ORB Extension Settings ---\r\ngrp_ext = \"ORB Extensions (Body Range Based)\"\r\nstdDevSteps  = input.float(0.5, \"Step Size (e.g. 0.5 = 50% of range)\", step=0.1, group=grp_ext)\r\nstdDevQty    = input.int(3, \"Number of Extension Lines\", minval=1, maxval=10, group=grp_ext)\r\nextLineStyle = input.string(\"Dotted\", \"Extension Line Style\", options=[\"Solid\", \"Dotted\", \"Dashed\"], group=grp_ext)\r\n\r\n// --- ORB Fractals ---\r\ngrp_frac = \"ORB Fractals\"\r\nshowFractals = input.bool(true, \"Show Fractals Inside Range\", group=grp_frac)\r\nfracUpColor  = input.color(color.rgb(11, 219, 46), \"Fractal Up Color\", group=grp_frac)\r\nfracDnColor  = input.color(color.rgb(230, 20, 20), \"Fractal Down Color\", group=grp_frac)\r\n\r\n// --- EMA CLOUDS SETTINGS ---\r\ngrp_cloud = \"EMA Clouds\"\r\nshowClouds = input.bool(false, \"Show EMA Clouds\", group=grp_cloud)\r\nmaSource   = input.source(close, \"MA Source\", group=grp_cloud)\r\nc1_short = input.int(8, \"Cloud 1 Short Length\", group=grp_cloud)\r\nc1_long  = input.int(9, \"Cloud 1 Long Length\", group=grp_cloud)\r\nc2_short = input.int(8, \"Cloud 2 Short Length\", group=grp_cloud)\r\nc2_long  = input.int(14, \"Cloud 2 Long Length\", group=grp_cloud)\r\nc3_short = input.int(34, \"Cloud 3 Short Length\", group=grp_cloud)\r\nc3_long  = input.int(50, \"Cloud 3 Long Length\", group=grp_cloud)\r\nc4_short = input.int(14, \"Cloud 4 Short Length\", group=grp_cloud)\r\nc4_long  = input.int(21, \"Cloud 4 Long Length\", group=grp_cloud)\r\ncloudBullColor = input.color(color.new(color.green, 80), \"Cloud Bullish Color\", group=grp_cloud)\r\ncloudBearColor = input.color(color.new(color.red, 80), \"Cloud Bearish Color\", group=grp_cloud)\r\n\r\n\r\n// --- VWAP SETTINGS ---\r\ngrp_vwap = \"VWAP Settings\"\r\nshowVWAP   = input.bool(true, \"Show VWAP\", group=grp_vwap)\r\nvwapColor  = input.color(color.rgb(220, 137, 235), \"VWAP Color\", group=grp_vwap)\r\nvwapWidth  = input.int(1, \"VWAP Line Width\", minval=1, group=grp_vwap)\r\n\r\n\r\n// ==========================================\r\n// 2. ORB LOGIC\r\n// ==========================================\r\n\r\n// Detect New Day to reset drawings\r\nisNewDay = ta.change(time(\"D\"))\r\n\r\n// Check Time Session\r\ninFormingSession = not na(time(timeframe.period, sessionInput + \":1234567\", timezone))\r\n\r\n// Check Stop Time\r\nnyHour   = hour(time, timezone)\r\nnyMinute = minute(time, timezone)\r\ncurrNyTime = nyHour * 100 + nyMinute\r\npastCutoff = currNyTime >= endTimeInput\r\n\r\n// Variables\r\nvar float rHigh = na\r\nvar float rLow = na\r\nvar float rBodyHigh = na\r\nvar float rBodyLow = na\r\nvar bool bullBreakHappened = false\r\nvar bool bearBreakHappened = false\r\n\r\n// --- RESET LOGIC ---\r\nif isNewDay\r\n    rHigh := na\r\n    rLow := na\r\n    rBodyHigh := na\r\n    rBodyLow := na\r\n    bullBreakHappened := false\r\n    bearBreakHappened := false\r\n\r\n// If we are starting the session fresh\r\nif inFormingSession and not inFormingSession[1]\r\n    rHigh := high\r\n    rLow := low\r\n    rBodyHigh := math.max(open, close)\r\n    rBodyLow := math.min(open, close)\r\n    bullBreakHappened := false \r\n    bearBreakHappened := false\r\n\r\n// --- UPDATE LOGIC ---\r\nif inFormingSession\r\n    rHigh := math.max(rHigh, high)\r\n    rLow := math.min(rLow, low)\r\n    rBodyHigh := math.max(rBodyHigh, math.max(open, close))\r\n    rBodyLow := math.min(rBodyLow, math.min(open, close))\r\n\r\n// ==========================================\r\n// 3. FRACTAL LOGIC\r\n// ==========================================\r\nisHighFrac = high[2] > high[0] and high[2] > high[1] and high[2] > high[3] and high[2] > high[4]\r\nisLowFrac  = low[2] < low[0] and low[2] < low[1] and low[2] < low[3] and low[2] < low[4]\r\nfracInSession = not na(time(timeframe.period, sessionInput + \":1234567\", timezone)[2])\r\n\r\n// FIX: We set the color to 'na' if showFractals is false, which prevents plotting the shape.\r\nhighFracColor = isHighFrac and fracInSession and showFractals ? fracDnColor : na\r\nlowFracColor  = isLowFrac and fracInSession and showFractals ? fracUpColor : na\r\n\r\nplotshape(isHighFrac and fracInSession, \r\n     title=\"Fractal High\", \r\n     style=shape.triangledown, \r\n     location=location.abovebar, \r\n     color=highFracColor, // Use the conditional color\r\n     offset=-2, \r\n     size=size.tiny)\r\n\r\nplotshape(isLowFrac and fracInSession, \r\n     title=\"Fractal Low\", \r\n     style=shape.triangleup, \r\n     location=location.belowbar, \r\n     color=lowFracColor, // Use the conditional color\r\n     offset=-2, \r\n     size=size.tiny)\r\n// ==========================================\r\n// 4. ORB DRAWING\r\n// ==========================================\r\ncanDraw = not na(rHigh) and not pastCutoff\r\n\r\nplot(canDraw ? rHigh : na, color=wickColor, linewidth=1, title=\"Wick High\", style=plot.style_linebr)\r\nplot(canDraw ? rLow : na, color=wickColor, linewidth=1, title=\"Wick Low\", style=plot.style_linebr)\r\np_bh = plot(canDraw ? rBodyHigh : na, color=bodyColor, linewidth=lineWidth, title=\"Body High\", style=plot.style_linebr)\r\np_bl = plot(canDraw ? rBodyLow : na, color=bodyColor, linewidth=lineWidth, title=\"Body Low\", style=plot.style_linebr)\r\nfill(p_bh, p_bl, color = inFormingSession ? fillColor : color.new(color.white, 100))\r\n\r\n// ==========================================\r\n// 5. ORB BREAKOUTS & EXTENSIONS\r\n// ==========================================\r\nsessionEnded = not inFormingSession and not na(rHigh)\r\nbullBreak = sessionEnded and not bullBreakHappened and high > rHigh and not pastCutoff\r\nbearBreak = sessionEnded and not bearBreakHappened and low < rLow and not pastCutoff\r\n\r\ngetLineStyle(s) =>\r\n    s == \"Dotted\" ? line.style_dotted : s == \"Dashed\" ? line.style_dashed : line.style_solid\r\nbodyRangeHeight = rBodyHigh - rBodyLow\r\n\r\nif bullBreak\r\n    bullBreakHappened := true\r\n    if stdDevQty > 0\r\n        for i = 1 to stdDevQty\r\n            level = rBodyHigh + (bodyRangeHeight * (stdDevSteps * i))\r\n            line.new(bar_index, level, bar_index + 10, level, color=color.green, style=getLineStyle(extLineStyle))\r\n            label.new(bar_index + 10, level, text=\"+\" + str.tostring(stdDevSteps * i), style=label.style_none, textcolor=color.green, size=size.small)\r\n\r\nif bearBreak\r\n    bearBreakHappened := true\r\n    if stdDevQty > 0\r\n        for i = 1 to stdDevQty\r\n            level = rBodyLow - (bodyRangeHeight * (stdDevSteps * i))\r\n            line.new(bar_index, level, bar_index + 10, level, color=color.red, style=getLineStyle(extLineStyle))\r\n            label.new(bar_index + 10, level, text=\"-\" + str.tostring(stdDevSteps * i), style=label.style_none, textcolor=color.red, size=size.small)\r\n\r\nplotshape(bullBreak, style=shape.labelup, location=location.belowbar, color=color.green, text=\"BREAK\", textcolor=color.white, size=size.small)\r\nplotshape(bearBreak, style=shape.labeldown, location=location.abovebar, color=color.red, text=\"BREAK\", textcolor=color.white, size=size.small)\r\n\r\n// ==========================================\r\n// 6. EMA CLOUDS LOGIC\r\n// ==========================================\r\n\r\nplotCloud(len1, len2, _source) =>\r\n    e1 = ta.ema(_source, len1)\r\n    e2 = ta.ema(_source, len2)\r\n    [e1, e2]\r\n\r\n[c1s, c1l] = plotCloud(c1_short, c1_long, maSource)\r\n[c2s, c2l] = plotCloud(c2_short, c2_long, maSource)\r\n[c3s, c3l] = plotCloud(c3_short, c3_long, maSource)\r\n[c4s, c4l] = plotCloud(c4_short, c4_long, maSource)\r\n\r\np_c1s = plot(showClouds ? c1s : na, title=\"C1 Short\", color=color.new(color.gray, 100))\r\np_c1l = plot(showClouds ? c1l : na, title=\"C1 Long\",  color=color.new(color.gray, 100))\r\np_c2s = plot(showClouds ? c2s : na, title=\"C2 Short\", color=color.new(color.gray, 100))\r\np_c2l = plot(showClouds ? c2l : na, title=\"C2 Long\",  color=color.new(color.gray, 100))\r\np_c3s = plot(showClouds ? c3s : na, title=\"C3 Short\", color=color.new(color.gray, 100))\r\np_c3l = plot(showClouds ? c3l : na, title=\"C3 Long\",  color=color.new(color.gray, 100))\r\np_c4s = plot(showClouds ? c4s : na, title=\"C4 Short\", color=color.new(color.gray, 100))\r\np_c4l = plot(showClouds ? c4l : na, title=\"C4 Long\",  color=color.new(color.gray, 100))\r\n\r\ncloudColor(s, l) => s > l ? cloudBullColor : cloudBearColor\r\n\r\nfill(p_c1s, p_c1l, color = cloudColor(c1s, c1l), title=\"Cloud 1 Fill\")\r\nfill(p_c2s, p_c2l, color = cloudColor(c2s, c2l), title=\"Cloud 2 Fill\")\r\nfill(p_c3s, p_c3l, color = cloudColor(c3s, c3l), title=\"Cloud 3 Fill\")\r\nfill(p_c4s, p_c4l, color = cloudColor(c4s, c4l), title=\"Cloud 4 Fill\")\r\n\r\n\r\n// ==========================================\r\n// 7. VWAP LOGIC\r\n// ==========================================\r\n\r\n// Calculate VWAP (built-in function in Pine Script)\r\nvwapLine = ta.vwap(close)\r\n\r\n// Plot VWAP only if the user enables it\r\nplot(showVWAP ? vwapLine : na, title=\"VWAP\", color=vwapColor, linewidth=vwapWidth, style=plot.style_line)"
  },
  "https://www.tradingview.com/script/bew0ncKZ/": {
    "id": 20085295,
    "url": "https://www.tradingview.com/script/bew0ncKZ/",
    "name": "Fanfans-Supertrend 10in1",
    "description": "\n## English Summary\n\nThis indicator, named \"Multi-Indicator Trend Grid (Weighted Version)\", is a comprehensive technical analysis tool. It integrates 10 classic technical indicators, categorized into three tiers based on trading weight: Tier 1 (GWMA, EMA, MACD) are core trend judgment indicators; Tier 2 (RSI, CCI, Bollinger Bands) are trend confirmation indicators; Tier 3 (VWAP, KDJ, ADX, Supertrend) are auxiliary filtering indicators. Using MACD histogram coloring logic, it visually displays the strength changes of bullish/bearish trends through dark/light green and dark/light red colors. This tool helps traders quickly identify market trend directions, confirm signal validity, and filter out false signals. It is particularly suitable for multi-timeframe analysis and trend reversal warnings, providing a visual \"trend consensus\" judgment method.\n## ‰∏≠ÊñáÊÄªÁªì\n\nÊ≠§ÊåáÊ†áÂêç‰∏∫\"Â§öÊåáÊ†áË∂ãÂäøÁΩëÊ†ºÔºàÊùÉÈáçÊéíÂ∫èÁâàÔºâ\"ÔºåÊòØ‰∏Ä‰∏™ÁªºÂêàÊÄßÁöÑÊäÄÊúØÂàÜÊûêÂ∑•ÂÖ∑„ÄÇÂÆÉÊï¥Âêà‰∫Ü10‰∏™ÁªèÂÖ∏ÊäÄÊúØÊåáÊ†áÔºåÊåâÁÖß‰∫§ÊòìÊùÉÈáçÂàÜ‰∏∫‰∏â‰∏™Ê¢ØÈòüÔºöÁ¨¨‰∏ÄÊ¢ØÈòü(GWMA„ÄÅEMA„ÄÅMACD)‰∏∫Ê†∏ÂøÉË∂ãÂäøÂà§Êñ≠ÊåáÊ†áÔºõÁ¨¨‰∫åÊ¢ØÈòü(RSI„ÄÅCCI„ÄÅÂ∏ÉÊûóÂ∏¶)‰∏∫Ë∂ãÂäøÁ°ÆËÆ§ÊåáÊ†áÔºõÁ¨¨‰∏âÊ¢ØÈòü(VWAP„ÄÅKDJ„ÄÅADX„ÄÅSupertrend)‰∏∫ËæÖÂä©ËøáÊª§ÊåáÊ†á„ÄÇÊåáÊ†áÈááÁî®MACDÊü±Áä∂ÂõæÈÖçËâ≤ÈÄªËæëÔºåÈÄöËøáÊ∑±Áªø/ÊµÖÁªøÂíåÊ∑±Á∫¢/ÊµÖÁ∫¢Áõ¥ËßÇÊòæÁ§∫Â§öÂ§¥/Á©∫Â§¥Ë∂ãÂäøÁöÑÂº∫Âº±ÂèòÂåñ„ÄÇËØ•Â∑•ÂÖ∑ËÉΩÂ∏ÆÂä©‰∫§ÊòìËÄÖÂø´ÈÄüËØÜÂà´Â∏ÇÂú∫Ë∂ãÂäøÊñπÂêë„ÄÅÁ°ÆËÆ§‰ø°Âè∑ÊúâÊïàÊÄßÂπ∂ËøáÊª§ËôöÂÅá‰ø°Âè∑ÔºåÁâπÂà´ÈÄÇÁî®‰∫éÂ§öÊó∂Èó¥Ê°ÜÊû∂ÂàÜÊûêÂíåË∂ãÂäøËΩ¨Êç¢È¢ÑË≠¶ÔºåÊèê‰æõ‰∫Ü‰∏ÄÁßçÂèØËßÜÂåñÁöÑ\"Ë∂ãÂäøÂÖ±ËØÜ\"Âà§Êñ≠ÊñπÊ≥ï„ÄÇ\n",
    "author_name": "ms023999",
    "likes_count": 19,
    "comments_count": 0,
    "views_count": 0,
    "created_at": "2025-12-11T14:02:28+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "BINANCE:ETHUSDT.P",
      "full_name": "BINANCE:ETHUSDT.P",
      "short_name": "ETHUSDT.P",
      "exchange": "BINANCE",
      "type": "swap",
      "logo_id": null,
      "currency_logo_id": "crypto/XTVCUSDT",
      "base_currency_logo_id": "crypto/XTVCETH",
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/crypto/XTVCETH.svg",
        "https://s3-symbol-logo.tradingview.com/crypto/XTVCUSDT.svg"
      ],
      "interval": "15",
      "direction": 0,
      "badge": {
        "label": "BINANCE:ETHUSDT.P",
        "url": "/symbols/ETHUSDT.P/"
      }
    },
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=6\r\nindicator(\"FanfansË∂ÖÁ∫ßË∂ãÂäø\", overlay=false, precision=5)\r\n\r\n// ========== 1. ÊåáÊ†áÂèÇÊï∞ÔºàV6Ê†áÂáÜÔºâ ==========\r\n// Á¨¨‰∏ÄÊ¢ØÈòüÔºöÊ†∏ÂøÉË∂ãÂäøÊåáÊ†á\r\nh = input.float(5.0, \"GWMAÂ∏¶ÂÆΩ\", minval=0.1, maxval=20, step=0.1)\r\nwindow_size = input.int(100, \"GWMAÁ™óÂè£\", minval=10, maxval=500, step=10)\r\nema_length = input.int(20, \"EMAÂë®Êúü\", minval=5, maxval=200)\r\nmacd_fast = input.int(12, \"MACDÂø´Á∫ø\")\r\nmacd_slow = input.int(26, \"MACDÊÖ¢Á∫ø\")\r\nmacd_signal = input.int(9, \"MACD‰ø°Âè∑Á∫ø\")\r\n\r\n// Á¨¨‰∫åÊ¢ØÈòüÔºöÁ°ÆËÆ§‰ø°Âè∑ÊåáÊ†á\r\nrsi_length = input.int(14, \"RSIÂë®Êúü\")\r\ncci_length = input.int(20, \"CCIÂë®Êúü\")\r\nbb_length = input.int(20, \"Â∏ÉÊûóÂ∏¶Âë®Êúü\", minval=5, maxval=200)\r\nbb_mult = input.float(2.0, \"Â∏ÉÊûóÂ∏¶Ê†áÂáÜÂ∑ÆÂÄçÊï∞\", minval=1.0, maxval=3.0)\r\n\r\n// Á¨¨‰∏âÊ¢ØÈòüÔºöËæÖÂä©ËøáÊª§ÊåáÊ†á\r\nvwap_show = input.bool(true, \"ÊòæÁ§∫VWAP\")\r\nkdj_k = input.int(14, \"KDJ-KÂë®Êúü\", minval=1, maxval=50)\r\nkdj_d = input.int(3, \"KDJ-DÂë®Êúü\", minval=1, maxval=20)\r\nadx_length = input.int(14, \"ADXÂë®Êúü\", minval=5, maxval=50)\r\nsupertrend_factor = input.float(3.0, \"SupertrendÁ≥ªÊï∞\", minval=1.0, maxval=10.0)\r\nsupertrend_atr = input.int(10, \"Supertrend ATRÂë®Êúü\", minval=1, maxval=50)\r\n\r\n// ========== 2. Ê†∏ÂøÉÂ∑•ÂÖ∑ÂáΩÊï∞ ==========\r\nget_strength(val, upper=100, lower=0) =>\r\n    norm_val = math.abs(val - (upper + lower)/2) / ((upper - lower)/2)\r\n    math.min(math.max(norm_val, 0), 1)\r\n\r\nget_macd_color(trend, strength, strength_prev) =>\r\n    if trend == 1\r\n        if strength > strength_prev\r\n            color.new(color.green, 0)\r\n        else\r\n            color.new(color.green, 50)\r\n    else if trend == -1\r\n        if strength > strength_prev\r\n            color.new(color.red, 0)\r\n        else\r\n            color.new(color.red, 50)\r\n    else\r\n        color.gray\r\n\r\n// ========== 3. ÊåáÊ†áËÆ°ÁÆóÔºàÊåâÊùÉÈáçÈ°∫Â∫èÔºâ ==========\r\n// ===== Á¨¨‰∏ÄÊ¢ØÈòüÔºöÊ†∏ÂøÉË∂ãÂäøÊåáÊ†á =====\r\n// 3.1 GWMA\r\nvar float[] gauss_coeffs = array.new_float(0)\r\nif barstate.isfirst\r\n    for i = 0 to window_size - 1\r\n        array.push(gauss_coeffs, math.exp(-(math.pow(i, 2) / (h * h * 2))))\r\nfloat sum1 = 0.0, sumw1 = 0.0\r\nint vb1 = math.min(window_size, bar_index + 1)\r\nfor i = 0 to vb1 - 1\r\n    w = array.get(gauss_coeffs, i)\r\n    sum1 += close[i] * w\r\n    sumw1 += w\r\ngwma = sum1 / sumw1\r\ngwma_trend = gwma > gwma[1] ? 1 : gwma < gwma[1] ? -1 : 0\r\ngwma_strength = get_strength(gwma, gwma[1]+1, gwma[1]-1)\r\ngwma_strength_prev = nz(gwma_strength[1], gwma_strength)\r\n\r\n// 3.2 EMA\r\nema_val = ta.ema(close, ema_length)\r\nema_trend = close > ema_val ? 1 : close < ema_val ? -1 : 0\r\nema_strength = get_strength(close, ema_val+ta.atr(10), ema_val-ta.atr(10))\r\nema_strength_prev = nz(ema_strength[1], ema_strength)\r\n\r\n// 3.3 MACD\r\n[macd_line, signal_line, macd_hist] = ta.macd(close, macd_fast, macd_slow, macd_signal)\r\nmacd_trend = macd_line > signal_line ? 1 : macd_line < signal_line ? -1 : 0\r\nmacd_strength = get_strength(macd_hist, 5, -5)\r\nmacd_strength_prev = nz(macd_strength[1], macd_strength)\r\n\r\n// ===== Á¨¨‰∫åÊ¢ØÈòüÔºöÁ°ÆËÆ§‰ø°Âè∑ÊåáÊ†á =====\r\n// 3.4 RSI\r\nrsi_val = ta.rsi(close, rsi_length)\r\nrsi_trend = rsi_val > 50 ? 1 : rsi_val < 50 ? -1 : 0\r\nrsi_strength = get_strength(rsi_val, 100, 0)\r\nrsi_strength_prev = nz(rsi_strength[1], rsi_strength)\r\n\r\n// 3.5 CCI\r\ncci_val = ta.cci(close, cci_length)\r\ncci_trend = cci_val > 0 ? 1 : cci_val < 0 ? -1 : 0\r\ncci_strength = get_strength(cci_val, 100, -100)\r\ncci_strength_prev = nz(cci_strength[1], cci_strength)\r\n\r\n// 3.6 Â∏ÉÊûóÂ∏¶\r\nbb_mid = ta.sma(close, bb_length)\r\nbb_upper = bb_mid + (bb_mult * ta.stdev(close, bb_length))\r\nbb_lower = bb_mid - (bb_mult * ta.stdev(close, bb_length))\r\nbb_trend = close > bb_mid ? 1 : close < bb_mid ? -1 : 0\r\nbb_strength = get_strength(close, bb_upper, bb_lower)\r\nbb_strength_prev = nz(bb_strength[1], bb_strength)\r\n\r\n// ===== Á¨¨‰∏âÊ¢ØÈòüÔºöËæÖÂä©ËøáÊª§ÊåáÊ†á =====\r\n// 3.7 VWAP\r\nvwap_val = ta.vwap\r\nvwap_trend = close > vwap_val ? 1 : close < vwap_val ? -1 : 0\r\nvwap_strength = get_strength(close, vwap_val+ta.atr(10), vwap_val-ta.atr(10))\r\nvwap_strength_prev = nz(vwap_strength[1], vwap_strength)\r\n\r\n// 3.8 KDJ\r\nk = ta.stoch(high, low, close, kdj_k)\r\nd = ta.sma(k, kdj_d)\r\nkdj_trend = k > d ? 1 : k < d ? -1 : 0\r\nkdj_strength = get_strength(k, 100, 0)\r\nkdj_strength_prev = nz(kdj_strength[1], kdj_strength)\r\n\r\n// 3.9 ADX\r\n[dip, din, adx_val] = ta.dmi(adx_length, adx_length)\r\nadx_trend = adx_val > 20 ? (dip > din ? 1 : -1) : 0\r\nadx_strength = get_strength(adx_val, 50, 0)\r\nadx_strength_prev = nz(adx_strength[1], adx_strength)\r\n\r\n// 3.10 Supertrend\r\natr_val = ta.atr(supertrend_atr)\r\nhl2_val = (high + low) / 2\r\nupper_band = hl2_val + (supertrend_factor * atr_val)\r\nlower_band = hl2_val - (supertrend_factor * atr_val)\r\nvar float supertrend = na\r\nsupertrend := close > nz(supertrend[1], close) ? math.max(lower_band, nz(supertrend[1], lower_band)) : math.min(upper_band, nz(supertrend[1], upper_band))\r\nsupertrend_trend = close > supertrend ? 1 : close < supertrend ? -1 : 0\r\nsupertrend_strength = get_strength(close, supertrend+atr_val, supertrend-atr_val)\r\nsupertrend_strength_prev = nz(supertrend_strength[1], supertrend_strength)\r\n\r\n// ========== 4. MACDÂºèÈÖçËâ≤ËµãÂÄº ==========\r\n// Á¨¨‰∏ÄÊ¢ØÈòüÈ¢úËâ≤\r\ncolor_gwma = get_macd_color(gwma_trend, gwma_strength, gwma_strength_prev)\r\ncolor_ema = get_macd_color(ema_trend, ema_strength, ema_strength_prev)\r\ncolor_macd = get_macd_color(macd_trend, macd_strength, macd_strength_prev)\r\n\r\n// Á¨¨‰∫åÊ¢ØÈòüÈ¢úËâ≤\r\ncolor_rsi = get_macd_color(rsi_trend, rsi_strength, rsi_strength_prev)\r\ncolor_cci = get_macd_color(cci_trend, cci_strength, cci_strength_prev)\r\ncolor_bb = get_macd_color(bb_trend, bb_strength, bb_strength_prev)\r\n\r\n// Á¨¨‰∏âÊ¢ØÈòüÈ¢úËâ≤\r\ncolor_vwap = get_macd_color(vwap_trend, vwap_strength, vwap_strength_prev)\r\ncolor_kdj = get_macd_color(kdj_trend, kdj_strength, kdj_strength_prev)\r\ncolor_adx = get_macd_color(adx_trend, adx_strength, adx_strength_prev)\r\ncolor_supertrend = get_macd_color(supertrend_trend, supertrend_strength, supertrend_strength_prev)\r\n\r\n// ========== 5. Â§öË°åÊü±Áä∂Êù°ÊòæÁ§∫ÔºàÊåâÊùÉÈáçÊéíÂ∫èÔºâ ==========\r\n// Á¨¨‰∏ÄÊ¢ØÈòüÊòæÁ§∫Âú®ÊúÄ‰∏äÊñπÔºà‰ΩçÁΩÆ11-9Ôºâ\r\nplot(title='GWMA', series=11, style=plot.style_columns, color=color_gwma, histbase=10, linewidth=8)\r\nplot(title='EMA', series=10, style=plot.style_columns, color=color_ema, histbase=9, linewidth=8)\r\nplot(title='MACD', series=9, style=plot.style_columns, color=color_macd, histbase=8, linewidth=8)\r\n\r\n// Á¨¨‰∫åÊ¢ØÈòüÊòæÁ§∫Âú®‰∏≠Èó¥Ôºà‰ΩçÁΩÆ8-6Ôºâ\r\nplot(title='RSI', series=8, style=plot.style_columns, color=color_rsi, histbase=7, linewidth=8)\r\nplot(title='CCI', series=7, style=plot.style_columns, color=color_cci, histbase=6, linewidth=8)\r\nplot(title='Bollinger', series=6, style=plot.style_columns, color=color_bb, histbase=5, linewidth=8)\r\n\r\n// Á¨¨‰∏âÊ¢ØÈòüÊòæÁ§∫Âú®‰∏ãÊñπÔºà‰ΩçÁΩÆ5-2Ôºâ\r\nplot(title='VWAP', series=5, style=plot.style_columns, color=color_vwap, histbase=4, linewidth=8)\r\nplot(title='KDJ', series=4, style=plot.style_columns, color=color_kdj, histbase=3, linewidth=8)\r\nplot(title='ADX', series=3, style=plot.style_columns, color=color_adx, histbase=2, linewidth=8)\r\nplot(title='Supertrend', series=2, style=plot.style_columns, color=color_supertrend, histbase=1, linewidth=8)\r\n\r\n// ========== 6. Âè≥‰æßÊ†áÁ≠æÔºàÊåâÊùÉÈáçÊéíÂ∫èÔºâ ==========\r\noffset_label = 2\r\npos_X = timenow + math.round(ta.change(time) * offset_label)\r\n\r\n// Á¨¨‰∏ÄÊ¢ØÈòüÊ†áÁ≠æ\r\nlabel1 = label.new(pos_X, 10.5, text=\"GWMA\", style=label.style_label_left, \r\n     color=color.new(color.white, 100), textcolor=color.gray, xloc=xloc.bar_time, size=size.small)\r\nlabel.delete(label1[1])\r\n\r\nlabel2 = label.new(pos_X, 9.5, text=\"EMA\", style=label.style_label_left, \r\n     color=color.new(color.white, 100), textcolor=color.gray, xloc=xloc.bar_time, size=size.small)\r\nlabel.delete(label2[1])\r\n\r\nlabel3 = label.new(pos_X, 8.5, text=\"MACD\", style=label.style_label_left, \r\n     color=color.new(color.white, 100), textcolor=color.gray, xloc=xloc.bar_time, size=size.small)\r\nlabel.delete(label3[1])\r\n\r\n// Á¨¨‰∫åÊ¢ØÈòüÊ†áÁ≠æ\r\nlabel4 = label.new(pos_X, 7.5, text=\"RSI\", style=label.style_label_left, \r\n     color=color.new(color.white, 100), textcolor=color.gray, xloc=xloc.bar_time, size=size.small)\r\nlabel.delete(label4[1])\r\n\r\nlabel5 = label.new(pos_X, 6.5, text=\"CCI\", style=label.style_label_left, \r\n     color=color.new(color.white, 100), textcolor=color.gray, xloc=xloc.bar_time, size=size.small)\r\nlabel.delete(label5[1])\r\n\r\nlabel6 = label.new(pos_X, 5.5, text=\"BB\", style=label.style_label_left, \r\n     color=color.new(color.white, 100), textcolor=color.gray, xloc=xloc.bar_time, size=size.small)\r\nlabel.delete(label6[1])\r\n\r\n// Á¨¨‰∏âÊ¢ØÈòüÊ†áÁ≠æ\r\nlabel7 = label.new(pos_X, 4.5, text=\"VWAP\", style=label.style_label_left, \r\n     color=color.new(color.white, 100), textcolor=color.gray, xloc=xloc.bar_time, size=size.small)\r\nlabel.delete(label7[1])\r\n\r\nlabel8 = label.new(pos_X, 3.5, text=\"KDJ\", style=label.style_label_left, \r\n     color=color.new(color.white, 100), textcolor=color.gray, xloc=xloc.bar_time, size=size.small)\r\nlabel.delete(label8[1])\r\n\r\nlabel9 = label.new(pos_X, 2.5, text=\"ADX\", style=label.style_label_left, \r\n     color=color.new(color.white, 100), textcolor=color.gray, xloc=xloc.bar_time, size=size.small)\r\nlabel.delete(label9[1])\r\n\r\nlabel10 = label.new(pos_X, 1.5, text=\"Supertrend\", style=label.style_label_left, \r\n     color=color.new(color.white, 100), textcolor=color.gray, xloc=xloc.bar_time, size=size.small)\r\nlabel.delete(label10[1])\r\n"
  },
  "https://www.tradingview.com/script/9fryFta6-JSP-NEW-Supertrend/": {
    "id": 20083089,
    "url": "https://www.tradingview.com/script/9fryFta6-JSP-NEW-Supertrend/",
    "name": " JSP NEW Supertrend",
    "description": "scalping 3 min 5 min  NIFTY SENSEX TRADING IS GOOD ",
    "author_name": "jeevanpatil7588",
    "likes_count": 44,
    "comments_count": 0,
    "views_count": 0,
    "created_at": "2025-12-11T07:07:09+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "BSE:BSX251211C84400",
      "full_name": "BSE:BSX251211C84400",
      "short_name": "BSX251211C84400",
      "exchange": "BSE",
      "type": null,
      "logo_id": null,
      "currency_logo_id": null,
      "base_currency_logo_id": null,
      "logo_urls": null,
      "interval": "3",
      "direction": 0,
      "badge": {
        "label": "BSE:BSX251211C84400",
        "url": null
      }
    },
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=6\r\nindicator(' JSP NEW Supertrend', overlay = true, format = format.price, precision = 2, timeframe = '')\r\n\r\nPeriods = input(title = 'ATR Period', defval = 10)\r\nsrc = input(hl2, title = 'Source')\r\nMultiplier = input.float(title = 'ATR Multiplier', step = 0.1, defval = 1.0)\r\nchangeATR = input(title = 'Change ATR Calculation Method ?', defval = true)\r\nshowsignals = input(title = 'Show Buy/Sell Signals ?', defval = true)\r\nhighlighting = input(title = 'Highlighter On/Off ?', defval = true)\r\natr2 = ta.sma(ta.tr, Periods)\r\natr = changeATR ? ta.atr(Periods) : atr2\r\nup = src - Multiplier * atr\r\nup1 = nz(up[1], up)\r\nup := close[1] > up1 ? math.max(up, up1) : up\r\ndn = src + Multiplier * atr\r\ndn1 = nz(dn[1], dn)\r\ndn := close[1] < dn1 ? math.min(dn, dn1) : dn\r\ntrend = 1\r\ntrend := nz(trend[1], trend)\r\ntrend := trend == -1 and close > dn1 ? 1 : trend == 1 and close < up1 ? -1 : trend\r\nupPlot = plot(trend == 1 ? up : na, title = 'Up Trend', style = plot.style_linebr, linewidth = 2, color = color.rgb(10, 253, 18))\r\nbuySignal = trend == 1 and trend[1] == -1\r\nplotshape(buySignal ? up : na, title = 'UpTrend Begins', location = location.absolute, style = shape.circle, size = size.tiny, color = color.new(color.green, 0))\r\nplotshape(buySignal and showsignals ? up : na, title = 'B', text = 'B', location = location.absolute, style = shape.labelup, size = size.tiny, color = color.new(color.green, 0), textcolor = color.new(color.white, 0))\r\ndnPlot = plot(trend == 1 ? na : dn, title = 'Down Trend', style = plot.style_linebr, linewidth = 2, color = color.rgb(240, 9, 9))\r\nsellSignal = trend == -1 and trend[1] == 1\r\nplotshape(sellSignal ? dn : na, title = 'DownTrend Begins', location = location.absolute, style = shape.circle, size = size.tiny, color = color.new(color.red, 0))\r\nplotshape(sellSignal and showsignals ? dn : na, title = 'S', text = 'S', location = location.absolute, style = shape.labeldown, size = size.tiny, color = color.new(color.red, 0), textcolor = color.new(color.white, 0))\r\nmPlot = plot(ohlc4, title = '', style = plot.style_circles, linewidth = math.max(1, 0))\r\n\r\n\r\nalertcondition(buySignal, title = 'SuperTrend B', message = 'SuperTrend Buy!')\r\nalertcondition(sellSignal, title = 'SuperTrend S', message = 'SuperTrend Sell!')\r\nchangeCond = trend != trend[1]\r\nalertcondition(changeCond, title = 'SuperTrend Direction Change', message = 'SuperTrend has changed direction!')\r\n\r\n//indicator('JSP Hull 2x@', overlay=true)\r\n\r\n// ShowHulls    = input(true,            title=\"Show Hull MA's\")\r\nShowHulls = true\r\n\r\nHull1Len = input.int(defval=10, title='Fast Length - Hull 1', minval=1)\r\n\r\nHull2Len = input.int(defval=12, title='Slow Length - Hull 2', minval=1)\r\n\r\nPaintBars = input(false, title='Paint Bars According to Hull 1 Direction')\r\n\r\n\r\nHull1 = ta.wma(2 * ta.wma(close, Hull1Len / 2) - ta.wma(close, Hull1Len), math.round(math.sqrt(Hull1Len)))\r\nHull2 = ta.wma(2 * ta.wma(close, Hull2Len / 2) - ta.wma(close, Hull2Len), math.round(math.sqrt(Hull2Len)))\r\n\r\n\r\nHull1Color = Hull1 > Hull1[1] ? #00ff80 : #ff0080  // #00ff80 that funny green lime\r\nHull2Color = Hull2 > Hull2[1] ? #00ff00 : #ff0000  // #00ff80 that funny green lime\r\n\r\nHullTrendColor = Hull1 > Hull2 ? color.lime : color.red\r\n\r\nHullBuySignal = ta.crossover(Hull1, Hull2)\r\nHullSellSignal = ta.crossunder(Hull1, Hull2)\r\n\r\nplot(ShowHulls ? Hull1 : na, title='Hull 1', color=Hull1Color, linewidth=2)\r\nplot(ShowHulls ? Hull2 : na, title='Hull 2', color=Hull2Color, linewidth=2)\r\n\r\n"
  },
  "https://www.tradingview.com/script/QUbAOUj6-CODEX-OB-BBMA-V1/": {
    "id": 20087810,
    "url": "https://www.tradingview.com/script/QUbAOUj6-CODEX-OB-BBMA-V1/",
    "name": "CODEX OB + BBMA V1",
    "description": "CODEX OB + BBMA is a multi-purpose Smart Money Concepts (SMC) indicator that automatically detects and visualizes key institutional trading elements such as Order Blocks, Fair Value Gaps, Rejection Blocks, Break of Structure, Pivots, High Volume Bars, and several qualitative SMC signals.\n\nIn addition to SMC tools, this indicator also incorporates multi-timeframe BBMA logic, allowing traders to view higher-timeframe momentum, trend direction, and volatility envelopes directly from the current chart. This makes it easier to align SMC setups‚Äîlike OB, FVG, and BOS‚Äîwith BBMA structure such as MA touches, re-entry zones, extreme candles, and volatility expansions.\n\nThis combination helps traders identify institutional footprints, multi-timeframe confluence, and displacement-based setups with high clarity.",
    "author_name": "padencodex",
    "likes_count": 23,
    "comments_count": 0,
    "views_count": 0,
    "created_at": "2025-12-12T00:52:28+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "FOREXCOM:XAUUSD",
      "full_name": "FOREXCOM:XAUUSD",
      "short_name": "XAUUSD",
      "exchange": "FOREXCOM",
      "type": "commodity",
      "logo_id": "metal/gold",
      "currency_logo_id": "country/US",
      "base_currency_logo_id": null,
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/metal/gold.svg"
      ],
      "interval": "60",
      "direction": 0,
      "badge": {
        "label": "FOREXCOM:XAUUSD",
        "url": "/symbols/XAUUSD/"
      }
    },
    "created": "2025-12-12",
    "updated": "2025-12-12",
    "source": "//@version=5\r\n//This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\nindicator('CODEX OB V1', overlay=true, max_boxes_count=500, max_lines_count=500)\r\n\r\nplotOB = input.bool(defval=true, title='Plot OB', group='Order Blocks')\r\nobBullColor = input.color(defval=color.new(color.blue, 80), title='Bullish OB Color', inline='Set Custom Color', group='Order Blocks')\r\nobBearColor = input.color(defval=color.new(color.red, 80), title='Bearish OB Color', inline='Set Custom Color', group='Order Blocks')\r\nobBoxBorder = input.string(defval=line.style_solid, title='OB Box Border Style', options=[line.style_dashed, line.style_dotted, line.style_solid], group='Order Blocks', tooltip='To disable border, set Border Width below to 0')\r\nobBorderTransparency = input.int(defval=80, title='OB Border Box Transparency', minval=0, maxval=100, group='Order Blocks')\r\nobMaxBoxSet = input.int(defval=10, title='Maximum OB Box Displayed', minval=1, maxval=100, group='Order Blocks', tooltip='Minimum = 1, Maximum = 100')\r\nfilterMitOB = input.bool(defval=false, title='Custom Color Mitigated OB', group='Order Blocks')\r\nmitOBColor = input.color(defval=color.new(color.gray, 90), title='Mitigated OB Color', group='Order Blocks', inline='Set Custom Color Mit OB', tooltip='Set Transparency to 0 to make mitigated OB disappear')\r\n\r\nplotFVG = input.bool(defval=true, title='Plot FVG', group='Fair Value Gaps', inline='FVG sets')\r\nplotStructureBreakingFVG = input.bool(defval=true, title='Plot Structure Breaking FVG', group='Fair Value Gaps', inline='FVG sets')\r\nfvgBullColor = input.color(defval=color.new(color.black, 90), title='Bullish FVG Color', inline='Set Custom Color', group='Fair Value Gaps')\r\nfvgBearColor = input.color(defval=color.new(color.black, 90), title='Bearish FVG Color', inline='Set Custom Color', group='Fair Value Gaps')\r\nfvgStructBreakingColor = input.color(defval=color.new(color.blue, 90), title='Structure Breaking FVG Color', inline='Set Custom Color', group='Fair Value Gaps')\r\nfvgBoxBorder = input.string(defval=line.style_solid, title='FVG Box Border Style', options=[line.style_dashed, line.style_dotted, line.style_solid], group='Fair Value Gaps', tooltip='To disable border, set Border Width below to 0')\r\nfvgBorderTransparency = input.int(defval=80, title='FVG Border Box Transparency', minval=0, maxval=100, group='Fair Value Gaps')\r\nfvgMaxBoxSet = input.int(defval=10, title='Maximum FVG Box Displayed', minval=1, maxval=100, group='Fair Value Gaps', tooltip='Minimum = 1, Maximum = 100')\r\nfilterMitFVG = input.bool(defval=false, title='Custom Color Mitigated FVG', group='Fair Value Gaps')\r\nmitFVGColor = input.color(defval=color.new(color.gray, 90), title='Mitigated FVG Color', group='Fair Value Gaps', inline='Set Custom Color Mit FVG', tooltip='Set Transparency to 0 to make mitigated FVG disappear')\r\n\r\nplotRJB = input.bool(defval=false, title='Plot RJB', group='Rejection Blocks', inline='RJB sets')\r\nrjbBullColor = input.color(defval=color.new(color.green, 90), title='Bullish RJB Color', inline='Set Custom Color', group='Rejection Blocks')\r\nrjbBearColor = input.color(defval=color.new(color.red, 90), title='Bearish RJB Color', inline='Set Custom Color', group='Rejection Blocks')\r\nrjbBoxBorder = input.string(defval=line.style_solid, title='RJB Box Border Style', options=[line.style_dashed, line.style_dotted, line.style_solid], group='Rejection Blocks', tooltip='To disable border, set Border Width below to 0')\r\nrjbBorderTransparency = input.int(defval=80, title='RJB Border Box Transparency', minval=0, maxval=100, group='Rejection Blocks')\r\nrjbMaxBoxSet = input.int(defval=10, title='Maximum RJB Box Displayed', minval=1, maxval=100, group='Rejection Blocks', tooltip='Minimum = 1, Maximum = 100')\r\nfilterMitRJB = input.bool(defval=false, title='Custom Color Mitigated RJB', group='Rejection Blocks')\r\nmitRJBColor = input.color(defval=color.new(color.gray, 90), title='Mitigated RJB Color', group='Rejection Blocks', inline='Set Custom Color Mit RJB', tooltip='Set to 100 to make mitigated RJB disappear')\r\n\r\nplotPVT = input.bool(defval=true, title='Plot Pivots', group='Pivots')\r\npivotLookup  = input.int(defval=1, minval=1, maxval=5,title='Pivot Lookup', group='Pivots', tooltip='Minimum = 1, Maximum = 5')\r\npvtTopColor = input.color(defval=color.new(color.silver, 0), title='Pivot Top Color', group='Pivots', inline='PVT Color')\r\npvtBottomColor = input.color(defval=color.new(color.silver, 0), title='Pivot Bottom Color', group='Pivots', inline='PVT Color')\r\n\r\nplotBOS = input.bool(defval=false, title='Plot BoS', group='Crossovers', inline='BOS sets')\r\nuseHighLowForBullishBoS = input.bool(defval=false, title='Use High/Low for Bullish BoS (for Bearish setup)', group='Crossovers')\r\nuseHighLowForBearishBoS = input.bool(defval=false, title='Use High/Low for Bearish BoS (for Bullish setup)', group='Crossovers')\r\nbosBoxFlag  = input.bool(title='BoS Box Length Manually', defval=false, group='Crossovers', tooltip='If activated the BoS Boxes will not extend unitl crossed by price. Instead will extend by the amount of bars choosen in the \"Set BoS Box Length Manually\" option')\r\nbosBoxLength  = input.int(title='BoS Box Length Manually', defval=3, minval=1, maxval=5, group='Crossovers', inline='BoS Boxes', tooltip='If \"Set BoS Box Length Manually\" is marked, choose by how many bars. Minimum = 1, Maximum = 5')\r\nbosBullColor = input.color(defval=color.new(color.green, 90), title='Bullish BoS Color', inline='Set Custom Color', group='Crossovers')\r\nbosBearColor = input.color(defval=color.new(color.red, 90), title='Bearish BoS Color', inline='Set Custom Color', group='Crossovers')\r\nbosBoxBorder = input.string(defval=line.style_solid, title='BoS Box Border Style', options=[line.style_dashed, line.style_dotted, line.style_solid], group='Crossovers', tooltip='To disable border, set Border Width below to 0')\r\nbosBorderTransparency = input.int(defval=80, title='BoS Border Box Transparency', minval=0, maxval=100, group='Crossovers')\r\nbosMaxBoxSet = input.int(defval=10, title='Maximum BoS Box Displayed', minval=1, maxval=100, group='Crossovers', tooltip='Minimum = 1, Maximum = 100')\r\n\r\nplotHVB = input.bool(defval=true, title='Plot HVB', group='High Volume Bar', tooltip='A candle where the average volume is higher than last few bars.')\r\nhvbBullColor = input.color(defval=color.green, title='Bullish HVB Color', inline='Set Custom Color', group='High Volume Bar')\r\nhvbBearColor = input.color(defval=color.red, title='Bearish HVB Color', inline='Set Custom Color', group='High Volume Bar')\r\nhvbEMAPeriod = input.int(defval=12, minval=1, title='Volume EMA Period', group='High Volume Bar')\r\nhvbMultiplier = input.float(defval=1.5, title='Volume Multiplier', minval=1, maxval=100, group='High Volume Bar')\r\n\r\nplotPPDD = input.bool(defval=true, title=\"Plot PPDD OB's\", group='Qualitative indicators', tooltip='Premium Premium Discount Discount (PPDD) is an OB formed after liquidity sweep. It will show up by default as a triangle (Bull ‚ñ≤ / Bear ‚ñº). Also PPDD1 (by deafult maked with a x-cross ‚®Ø) which is a weak OB formed after liquidity sweep, that fails to completely engulf the high/low, but closes beyond the trapped candles open price.')\r\nppddBullColor = input.color(defval=color.new(color.green, 0), title=\"Bullish PPDD OB's Color\", group='Qualitative indicators', inline='PPDD Color')\r\nppddBearColor = input.color(defval=color.new(color.red, 0), title=\"Bearish PPDD OB's Color\", group='Qualitative indicators', inline='PPDD Color')\r\n\r\nplotOBFVG = input.bool(defval=true, title='Plot Stacked OB+FVG', group='Qualitative indicators', tooltip='Marks the candle (default with a diamond ‚óÜ) when an OB & FVG are stacked, showing momentum')\r\nobfvgBullColor = input.color(defval=#0400f8, title='Bullish Stacked OB+FVG Color', group='Qualitative indicators', inline='OBFVG Color')\r\nobfvgBearColor = input.color(defval=#ff0000, title='Bearish Stacked OB+FVG Color', group='Qualitative indicators', inline='OBFVG Color')\r\n\r\nplotLabelOB = input.bool(defval=true, title='Plot OB Label', inline='OB label', group='Label Options')\r\nobLabelColor = input.color(defval=color.gray, title='Color', inline='OB label', group='Label Options')\r\nobLabelSize = input.string(defval=size.tiny, title=\"Size\", options=[size.huge, size.large, size.small, size.tiny, size.auto, size.normal], inline='OB label', group='Label Options')\r\nplotLabelFVG = input.bool(defval=true, title='Plot FVG Label', inline='FVG label', group='Label Options')\r\nfvgLabelColor = input.color(defval=color.gray, title='Color', inline='FVG label', group='Label Options')\r\nfvgLabelSize = input.string(defval=size.tiny, title=\"Size\", options=[size.huge, size.large, size.small, size.tiny, size.auto, size.normal], inline='FVG label', group='Label Options')\r\nplotLabelRJB = input.bool(defval=true, title='Plot RJB Label', inline='RJB label', group='Label Options')\r\nrjbLabelColor = input.color(defval=color.gray, title='Color', inline='RJB label', group='Label Options')\r\nrjbLabelSize = input.string(defval=size.tiny, title=\"Size\", options=[size.huge, size.large, size.small, size.tiny, size.auto, size.normal], inline='RJB label', group='Label Options')\r\nplotLabelBOS = input.bool(defval=true, title='Plot BoS Label', inline='BOS label', group='Label Options')\r\nbosLabelColor = input.color(defval=color.gray, title='Color', inline='BOS label', group='Label Options')\r\nbosLabelSize = input.string(defval=size.tiny, title=\"Size\", options=[size.huge, size.large, size.small, size.tiny, size.auto, size.normal], inline='BOS label', group='Label Options')\r\n\r\n//Box Types\r\nvar int _ob  = 1\r\nvar int _fvg = 2\r\nvar int _rjb = 3\r\nvar int _bos = 4\r\n\r\n//Box Labels\r\nvar string _obLabel  = \"OB\"\r\nvar string _fvgLabel = \"FVG\"\r\nvar string _rjbLabel = \"RJB\"\r\nvar string _bosLabel = \"BoS\"\r\nvar string _plus     = \"+\"\r\nvar string _minus    = \"-\"\r\nvar string _empty    = \"\"\r\n\r\n//Box Arrays\r\nvar box[] _bearBoxesOB  = array.new_box()\r\nvar box[] _bullBoxesOB  = array.new_box()\r\nvar box[] _bearBoxesFVG = array.new_box()\r\nvar box[] _bullBoxesFVG = array.new_box()\r\nvar box[] _bearBoxesRJB = array.new_box()\r\nvar box[] _bullBoxesRJB = array.new_box()\r\nvar box[] _bearBoxesBOS = array.new_box()\r\nvar box[] _bullBoxesBOS = array.new_box()\r\n\r\n//Functions\r\nisUp(index) =>\r\n    close[index] > open[index]\r\n\r\nisDown(index) =>\r\n    close[index] < open[index]\r\n\r\nisObUp(index) =>\r\n    isDown(index + 1) and isUp(index) and close[index] > high[index + 1]\r\n\r\nisObDown(index) =>\r\n    isUp(index + 1) and isDown(index) and close[index] < low[index + 1]\r\n\r\nisFvgUp(index) =>\r\n    (low[index] > high[index + 2])\r\n\r\nisFvgDown(index) =>\r\n    (high[index] < low[index + 2])\r\n\r\n//Function to Calculte Box Length\r\n_controlBox(_boxes, _high, _low, _type) =>\r\n    if array.size(_boxes) > 0\r\n        for i = array.size(_boxes) - 1 to 0 by 1\r\n            _box = array.get(_boxes, i)\r\n            _boxLow = box.get_bottom(_box)\r\n            _boxHigh = box.get_top(_box)\r\n            _boxRight = box.get_right(_box)\r\n            if bosBoxFlag and _type == _bos\r\n                if na or (bar_index + bosBoxLength - 1 == _boxRight and not((_high > _boxLow and _low < _boxLow) or (_high > _boxHigh and _low < _boxHigh)))\r\n                    box.set_right(_box, bar_index + bosBoxLength - 1)\r\n            else if (filterMitOB and _type == _ob) or (filterMitFVG and _type == _fvg) or (filterMitRJB and _type == _rjb)\r\n                if na or (bar_index == _boxRight and not((_high > _boxLow and _low < _boxLow) or (_high > _boxHigh and _low < _boxHigh)))\r\n                    box.set_right(_box, bar_index + 1)\r\n                else\r\n                    if _type == _ob\r\n                        box.set_bgcolor(_box, mitOBColor)\r\n                        box.set_border_color(_box, mitOBColor)\r\n                    else if _type == _fvg\r\n                        box.set_bgcolor(_box, mitFVGColor)\r\n                        box.set_border_color(_box, mitFVGColor)\r\n                    else if _type == _rjb\r\n                        box.set_bgcolor(_box, mitRJBColor)\r\n                        box.set_border_color(_box, mitRJBColor)\r\n            else\r\n                if na or (bar_index == _boxRight and not((_high > _boxLow and _low < _boxLow) or (_high > _boxHigh and _low < _boxHigh)))\r\n                    box.set_right(_box, bar_index + 1)\r\n\r\n//////////////////// Pivots //////////////////// \r\nhih = ta.pivothigh(high, pivotLookup, pivotLookup)\r\nlol = ta.pivotlow(low , pivotLookup, pivotLookup)\r\ntop = ta.valuewhen(hih, high[pivotLookup], 0)\r\nbottom = ta.valuewhen(lol, low [pivotLookup], 0)\r\nplot(top, offset=-pivotLookup, linewidth=1, color=(top != top[1] ? na : (plotPVT ? pvtTopColor : na)), title=\"Pivot Top\")\r\nplot(bottom, offset=-pivotLookup, linewidth=1, color=(bottom != bottom[1] ? na : (plotPVT ? pvtBottomColor : na)), title=\"Pivot Bottom\")\r\n\r\n//////////////////// Order Block //////////////////\r\n//Bullish OB Box Plotting\r\nif isObUp(1) and plotOB\r\n    _bullboxOB = box.new(left=bar_index - 2, top=high[2], right=bar_index, bottom=math.min(low[2], low[1]), border_color=color.new(obBullColor, obBorderTransparency), border_style=obBoxBorder, border_width=1, bgcolor=obBullColor, \r\n     text=plotLabelOB ? _obLabel  + _plus : _empty, text_halign=text.align_right, text_valign=text.align_bottom, text_size=obLabelSize, text_color=obLabelColor)\r\n    if array.size(_bullBoxesOB) > obMaxBoxSet\r\n        box.delete(array.shift(_bullBoxesOB))\r\n    array.push(_bullBoxesOB, _bullboxOB)\r\n\r\n//Bearish OB Box Plotting\r\nif isObDown(1) and plotOB\r\n    _bearboxOB = box.new(left=bar_index - 2, top=math.max(high[2], high[1]), right=bar_index, bottom=low[2], border_color=color.new(obBearColor, obBorderTransparency), border_style=obBoxBorder, border_width=1, bgcolor=obBearColor, \r\n     text=plotLabelOB ? _obLabel  + _minus : _empty, text_halign=text.align_right, text_valign=text.align_bottom, text_size=obLabelSize, text_color=obLabelColor)\r\n    if array.size(_bearBoxesOB) > obMaxBoxSet\r\n        box.delete(array.shift(_bearBoxesOB))\r\n    array.push(_bearBoxesOB, _bearboxOB)\r\n    \r\nif plotOB\r\n    _controlBox(_bearBoxesOB, high, low, _ob)\r\n    _controlBox(_bullBoxesOB, high, low, _ob)\r\n\r\n//////////////////// Fair Value Gap //////////////////\r\n//Bullish FVG Box Plotting\r\nif isFvgUp(0)\r\n    box _bullboxFVG = na\r\n    if plotStructureBreakingFVG and (close[1] > top) and (low[1] < top) and (high[2] < top) and (low > top)\r\n        _bullboxFVG := box.new(left=bar_index-2, top=low[0], right=bar_index, bottom=high[2], bgcolor=fvgStructBreakingColor, border_color=color.new(fvgStructBreakingColor, fvgBorderTransparency), border_style=fvgBoxBorder, border_width=1,\r\n         text=plotLabelFVG ? _fvgLabel  + _plus : _empty, text_halign=text.align_right, text_valign=text.align_bottom, text_size=fvgLabelSize, text_color=fvgLabelColor)        \r\n    else if plotFVG   \r\n        _bullboxFVG := box.new(left=bar_index-2, top=low[0], right=bar_index, bottom=high[2], bgcolor=fvgBullColor, border_color=color.new(fvgBullColor, fvgBorderTransparency), border_style=fvgBoxBorder, border_width=1,\r\n         text=plotLabelFVG ? _fvgLabel  + _plus : _empty, text_halign=text.align_right, text_valign=text.align_bottom, text_size=fvgLabelSize, text_color=fvgLabelColor)    \r\n    if array.size(_bullBoxesFVG) > fvgMaxBoxSet\r\n        box.delete(array.shift(_bullBoxesFVG))\r\n    array.push(_bullBoxesFVG, _bullboxFVG)\r\n\r\n//Bearish FVG Box Plotting    \r\nif isFvgDown(0)\r\n    box _bearboxFVG = na\r\n    if plotStructureBreakingFVG and (close[1] < bottom) and (high[1] > bottom) and (low[2] > bottom) and (high < bottom)\r\n        _bearboxFVG := box.new(left=bar_index-2, top=low[2], right=bar_index, bottom=high[0], bgcolor=fvgStructBreakingColor, border_color=color.new(fvgStructBreakingColor, fvgBorderTransparency), border_style=fvgBoxBorder, border_width=1,\r\n         text=plotLabelFVG ? _fvgLabel  + _minus : _empty, text_halign=text.align_right, text_valign=text.align_bottom, text_size=fvgLabelSize, text_color=fvgLabelColor)    \r\n    else if plotFVG\r\n        _bearboxFVG := box.new(left=bar_index-2, top=low[2], right=bar_index, bottom=high[0], bgcolor=fvgBearColor, border_color=color.new(fvgBearColor, fvgBorderTransparency), border_style=fvgBoxBorder, border_width=1,\r\n         text=plotLabelFVG ? _fvgLabel  + _minus : _empty, text_halign=text.align_right, text_valign=text.align_bottom, text_size=fvgLabelSize, text_color=fvgLabelColor)    \r\n    if array.size(_bearBoxesFVG) > fvgMaxBoxSet\r\n        box.delete(array.shift(_bearBoxesFVG))\r\n    array.push(_bearBoxesFVG, _bearboxFVG)\r\n    \r\nif plotFVG or plotStructureBreakingFVG\r\n    _controlBox(_bearBoxesFVG, high, low, _fvg)\r\n    _controlBox(_bullBoxesFVG, high, low, _fvg)\r\n\r\n//////////////////// Rejection Block //////////////////\r\nif plotRJB\r\n    isDownRjbObCondition = isObDown(1)\r\n    isDownRjb1 = isDownRjbObCondition and  (high[1] < (close[2] + 0.2*(high[2]-close[2]))) // RJB is on trapped's wick and <50% of the wick was covered by signal\r\n    isDownRjb2 = isDownRjbObCondition and (high[1] > high[2]) // RJB is on signal's wick\r\n    if isDownRjb1 and plotRJB\r\n        _bearboxRJB = box.new(left=bar_index-2, top=high[2], right=bar_index, bottom=close[2], bgcolor=rjbBearColor, border_color=color.new(rjbBearColor, rjbBorderTransparency), border_style=rjbBoxBorder, border_width=1,\r\n         text=plotLabelRJB ? _rjbLabel  + _minus : _empty, text_halign=text.align_right, text_valign=text.align_bottom, text_size=rjbLabelSize, text_color=rjbLabelColor)\r\n        if array.size(_bearBoxesRJB) > rjbMaxBoxSet\r\n            box.delete(array.shift(_bearBoxesRJB))\r\n        array.push(_bearBoxesRJB, _bearboxRJB)\r\n        \r\n    if isDownRjb2 and plotRJB\r\n        _bearboxRJB = box.new(left=bar_index-1, top=high[1], right=bar_index, bottom=open[1], bgcolor=rjbBearColor, border_color=color.new(rjbBearColor, rjbBorderTransparency), border_style=rjbBoxBorder, border_width=1,\r\n         text=plotLabelRJB ? _rjbLabel  + _minus : _empty, text_halign=text.align_right, text_valign=text.align_bottom, text_size=rjbLabelSize, text_color=rjbLabelColor)\r\n        if array.size(_bearBoxesRJB) > rjbMaxBoxSet\r\n            box.delete(array.shift(_bearBoxesRJB))\r\n        array.push(_bearBoxesRJB, _bearboxRJB)\r\n\r\n//Bullish RJB Box Plotting\r\nif plotRJB\r\n    isUpRjbObCondition = isObUp(1)\r\n    isUpRjb1 = isUpRjbObCondition and (low[1] > (close[2] - 0.2*(close[2]-low[2]))) // RJB is on trapped's wick and <50% of the wick was covered by signal\r\n    isUpRjb2 = isUpRjbObCondition and (low[1] < low[2]) // RJB is on signal's wick\r\n    if isUpRjb1 and plotRJB\r\n        _bullboxRJB = box.new(left=bar_index-2, top=close[2], right=bar_index, bottom=low[2], bgcolor=rjbBullColor, border_color=color.new(rjbBullColor, rjbBorderTransparency), border_style=rjbBoxBorder, border_width=1,\r\n         text=plotLabelRJB ? _rjbLabel  + _plus : _empty, text_halign=text.align_right, text_valign=text.align_bottom, text_size=rjbLabelSize, text_color=rjbLabelColor)\r\n        if array.size(_bullBoxesRJB) > rjbMaxBoxSet\r\n            box.delete(array.shift(_bullBoxesRJB))\r\n        array.push(_bullBoxesRJB, _bullboxRJB)\r\n    \r\n    if isUpRjb2 and plotRJB\r\n        _bullboxRJB = box.new(left=bar_index-1, top=open[1], right=bar_index, bottom=low[1], bgcolor=rjbBullColor, border_color=color.new(rjbBullColor, rjbBorderTransparency), border_style=rjbBoxBorder, border_width=1, \r\n         text=plotLabelRJB ? _rjbLabel  + _plus : _empty, text_halign=text.align_right, text_valign=text.align_bottom, text_size=rjbLabelSize, text_color=rjbLabelColor)\r\n        if array.size(_bullBoxesRJB) > rjbMaxBoxSet\r\n            box.delete(array.shift(_bullBoxesRJB))\r\n        array.push(_bullBoxesRJB, _bullboxRJB)\r\n\r\nif plotRJB\r\n    _controlBox(_bearBoxesRJB, high, low, _rjb)\r\n    _controlBox(_bullBoxesRJB, high, low, _rjb)\r\n\r\n//////////////////// Crossovers a.k.a. Break of Structure ////////////////////\r\n//Bullish BOS Box Plotting\r\nif plotBOS\r\n    if ta.crossover(useHighLowForBullishBoS ? high : close, top)\r\n        _bullboxBOS = box.new(left=bar_index, top=top, right=bosBoxFlag ? bar_index+bosBoxLength : bar_index+1, bottom=bottom, bgcolor=bosBullColor, border_color=color.new(bosBullColor, bosBorderTransparency), border_style=bosBoxBorder, border_width=1, \r\n         text=plotLabelBOS ? _bosLabel + _plus : _empty, text_halign=text.align_right, text_valign=text.align_bottom, text_size=bosLabelSize, text_color=bosLabelColor)\r\n        if array.size(_bullBoxesBOS) > bosMaxBoxSet\r\n            box.delete(array.shift(_bullBoxesBOS))\r\n        array.push(_bullBoxesBOS, _bullboxBOS)\r\n\r\n//Bearish BOS Box Plotting        \r\nif plotBOS \r\n    if ta.crossunder(useHighLowForBearishBoS ? low : close, bottom)\r\n        _bearboxBOS = box.new(left=bar_index, top=top, right=bosBoxFlag ? bar_index+bosBoxLength : bar_index+1, bottom=bottom, bgcolor=bosBearColor, border_color=color.new(bosBearColor, bosBorderTransparency), border_style=bosBoxBorder, border_width=1, \r\n         text=plotLabelBOS ? _bosLabel  + _minus : _empty, text_halign=text.align_right, text_valign=text.align_bottom, text_size=bosLabelSize, text_color=bosLabelColor)\r\n        if array.size(_bearBoxesBOS) > bosMaxBoxSet\r\n            box.delete(array.shift(_bearBoxesBOS))\r\n        array.push(_bearBoxesBOS, _bearboxBOS)\r\n\r\nif plotBOS\r\n    _controlBox(_bearBoxesBOS, high, low, _bos)\r\n    _controlBox(_bullBoxesBOS, high, low, _bos)\r\n\r\n//////////////////// Premium Premium & Discount Discount //////////////////\r\npremiumPremium = plotPPDD and isObDown(0) and ((math.max(high, high[1]) > top and close < top) or (math.max(high, high[1]) > top[1] and close < top[1]))\r\ndiscountDiscount = plotPPDD and isObUp(0) and ((math.min(low, low[1]) < bottom and close > bottom) or (math.min(low, low[1]) < bottom[1] and close > bottom[1]))\r\nplotshape(premiumPremium, \"Bearish PPDD OB\", style=shape.triangledown , location=location.abovebar, color=ppddBearColor, size=size.tiny)\r\nplotshape(discountDiscount, \"Bullish PPDD OB\", style=shape.triangleup , location=location.belowbar, color=ppddBullColor, size=size.tiny)\r\n\r\npremiumPremium1 = plotPPDD and (isUp(1) and isDown(0) and close[0] < open[1]) and ((math.max(high, high[1]) > top and close < top) or (math.max(high, high[1]) > top[1] and close < top[1])) and not premiumPremium\r\ndiscountDiscount1 = plotPPDD and (isDown(1) and isUp(0) and close[0] > open[1]) and ((math.min(low, low[1]) < bottom and close > bottom) or (math.min(low, low[1]) < bottom[1] and close > bottom[1])) and not discountDiscount\r\nplotshape(premiumPremium1, \"Bearish PPDD Weak OB\", style=shape.xcross, location=location.abovebar, color=ppddBearColor, size=size.tiny)\r\nplotshape(discountDiscount1, \"Bullish PPDD Weak OB\", style=shape.xcross, location=location.belowbar, color=ppddBullColor, size=size.tiny)\r\n\r\n////////////////// High Volume Bars //////////////////\r\nvolEma = ta.ema(volume, hvbEMAPeriod)\r\nisHighVolume = volume > (hvbMultiplier * volEma)\r\nbarcolor(plotHVB and isUp(0) and isHighVolume ? hvbBullColor : na, title=\"Bullish HVB\")\r\nbarcolor(plotHVB and isDown(0) and isHighVolume ? hvbBearColor : na, title=\"Bearish HVB\")\r\n\r\n///////////////// Stacked OB + FVG //////////////////\r\nplotshape(plotOBFVG and isFvgDown(0) and isObDown(1), \"Bearish OB+FVG Stack\", style=shape.labeldown, location=location.abovebar, color=obfvgBearColor, size=size.tiny)\r\nplotshape(plotOBFVG and isFvgUp(0) and isObUp(1), \"Bullish OB+FVG Stack\", style=shape.labelup, location=location.belowbar, color=obfvgBullColor, size=size.tiny)\r\n\r\nalertcondition(plotOBFVG and isFvgDown(0) and isObDown(1), title = \"FGV+OB SELL\", message = \"FGV+OB SELL\" )\r\n\r\nalertcondition(plotOBFVG and isFvgUp(0) and isObUp(1), title = \"FGV+OB BUY\", message = \"FGV+OB BUY\" )"
  },
  "https://www.tradingview.com/script/G2hPOlrI-TRI-Layered-Multi-Timeframe-Support-Resistance/": {
    "id": 20090621,
    "url": "https://www.tradingview.com/script/G2hPOlrI-TRI-Layered-Multi-Timeframe-Support-Resistance/",
    "name": "TRI - Layered Multi-Timeframe Support & Resistance",
    "description": "TRI - LAYERED MULTI-TIMEFRAME SUPPORT & RESISTANCE v1.0.0 \n\n DESCRIPTION: \nAdvanced multi-timeframe Support & Resistance indicator using ta.pivothigh/ta.pivotlow\nto display pivot-based S/R levels from MULTIPLE timeframes simultaneously on your chart.\nEach timeframe has its own configurable color and line width for easy visual distinction.\nFeatures smart pivot positioning, dynamic level merging, retest detection, and comprehensive alert system.\n\n KEY FEATURES: \n \n Display S/R from multiple timeframes at once (15m, 1h, 4h, D, W, M)\n Each timeframe has independent toggle, color, and line width\n Smart timeframe filtering - never shows TFs lower than current chart\n Current chart TF is always visible (cannot be disabled)\n Configurable max number of higher timeframes to display\n Multi-timeframe pivot detection using ta.pivothigh/ta.pivotlow on candle body\n Smart pivot positioning - pivots placed on correct candle type (bullish for highs, bearish for lows)\n Dynamic level merging - nearby levels merged based on ATR tolerance (newer wins)\n Mitigated level tracking - broken levels shown with dashed style and configurable transparency\n Price scale display - levels shown on price scale with their colors\n Retest detection - identifies bounces off S/R levels (current TF only)\n Comprehensive alert system with 12 alert types (current TF only)\n Significant breakout detection with configurable parameters\n Memory efficient - automatic cleanup of expired levels\n \n\n HOW IT WORKS: \nThe indicator uses ta.pivothigh() and ta.pivotlow() on each enabled timeframe.\nPivot highs are positioned on bullish candles (using close price).\nPivot lows are positioned on bearish candles (using close price).\nIf the pivot candle is not the correct type, it searches back up to 5 candles.\nOnly unbreached levels are displayed as active support/resistance.\nWhen a level is breached, it becomes a \"mitigated level\" with dashed styling and transparency.\nMitigation is checked only after the first candle following the pivot (to avoid false triggers).\n\n TIMEFRAME FILTERING: \n \n Timeframes LOWER than current chart are NEVER shown\n Current chart timeframe is ALWAYS shown (cannot be disabled)\n Higher timeframes respect user toggle settings\n Max higher TFs setting limits how many higher TFs are displayed (default 3)\n \nExample on 1h chart: 15m hidden, 1h always shown, 4h/D/W/M per user settings (max 3)\n\n LEVEL MERGING: \nNearby levels of the same type AND same timeframe are automatically merged.\nThe newer pivot always wins, replacing older levels within the tolerance range.\nTolerance = TF ATR √ó Merge Tolerance setting (default 0.5 ATR).\n\n VISUALIZATION: \nEach timeframe has its own color and line width for easy distinction:\n \n 15m - Cyan, width 1\n 1h - Blue, width 1\n 4h - Orange/Gold, width 2\n Daily - Green, width 2\n Weekly - Purple, width 3\n Monthly - Red, width 4\n \nActive levels show as solid lines, mitigated levels as dashed lines with transparency.\nPrice scale shows level prices with their respective colors.\n\n RETEST DETECTION (Current TF Only): \nDetects when price tests a S/R level and bounces back. Two patterns are recognized:\n \n Pattern 1: Single candle with long wick touching level and body moving away\n Pattern 2: Previous candle touches level, current candle is reaction candle\n \nParameters:\n \n ATR Tolerance - How close price must be to level (default 0.15 ATR)\n Min Wick % - Minimum wick size to confirm rejection (default 30%)\n \n\n ALERT SYSTEM (Current TF Only): \nAll alerts trigger only for levels of the current chart timeframe:\n \n New Pivot (any/Support/Resistance) - when new pivot is detected\n Breakout (any/Support/Resistance) - when level is broken with coherent candle\n Significant Breakout (any/Support/Resistance) - high-quality breakouts\n Retest (any/Support/Resistance) - when level is retested with bounce\n \n\n SIGNIFICANT BREAKOUT CRITERIA: \nA breakout is considered \"significant\" when:\n \n Candle direction is coherent (bearish for support, bullish for resistance)\n At least X% of the candle body crosses the level (configurable, default 50%)\n Opposite wick is limited to Y% of candle range (configurable, default 30%)\n \n\n SETTINGS OVERVIEW: \n \n Global Settings - Max levels per TF, max higher TFs, pivot bars, merge tolerance\n Mitigation Settings - Visibility duration, transparency\n Visual Settings - Circles, labels, price scale\n Timeframe Configuration - Enable/disable, color, line width for each TF\n Significant Breakout - Min body cross %, max opposite wick %\n Retest Detection - ATR tolerance, min wick %\n Debug - Show pivot detection markers\n",
    "author_name": "riccardo_tempesta",
    "likes_count": 28,
    "comments_count": 0,
    "views_count": 0,
    "created_at": "2025-12-12T11:48:04+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "PEPPERSTONE:AUDUSD",
      "full_name": "PEPPERSTONE:AUDUSD",
      "short_name": "AUDUSD",
      "exchange": "PEPPERSTONE",
      "type": "forex",
      "logo_id": null,
      "currency_logo_id": "country/US",
      "base_currency_logo_id": "country/AU",
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/country/AU.svg",
        "https://s3-symbol-logo.tradingview.com/country/US.svg"
      ],
      "interval": "240",
      "direction": 0,
      "badge": {
        "label": "PEPPERSTONE:AUDUSD",
        "url": "/symbols/AUDUSD/"
      }
    },
    "created": "2025-12-12",
    "updated": "2025-12-12",
    "source": "//@version=6\r\n// [b]TRI - LAYERED MULTI-TIMEFRAME SUPPORT & RESISTANCE v1.0.0[/b]\r\n\r\n// [b]DESCRIPTION:[/b]\r\n// Advanced multi-timeframe Support & Resistance indicator using ta.pivothigh/ta.pivotlow\r\n// to display pivot-based S/R levels from MULTIPLE timeframes simultaneously on your chart.\r\n// Each timeframe has its own configurable color and line width for easy visual distinction.\r\n// Features smart pivot positioning, dynamic level merging, retest detection, and comprehensive alert system.\r\n\r\n// [b]KEY FEATURES:[/b]\r\n// [list]\r\n// [*]Display S/R from multiple timeframes at once (15m, 1h, 4h, D, W, M)\r\n// [*]Each timeframe has independent toggle, color, and line width\r\n// [*]Smart timeframe filtering - never shows TFs lower than current chart\r\n// [*]Current chart TF is always visible (cannot be disabled)\r\n// [*]Configurable max number of higher timeframes to display\r\n// [*]Multi-timeframe pivot detection using ta.pivothigh/ta.pivotlow on candle body\r\n// [*]Smart pivot positioning - pivots placed on correct candle type (bullish for highs, bearish for lows)\r\n// [*]Dynamic level merging - nearby levels merged based on ATR tolerance (newer wins)\r\n// [*]Mitigated level tracking - broken levels shown with dashed style and configurable transparency\r\n// [*]Price scale display - levels shown on price scale with their colors\r\n// [*]Retest detection - identifies bounces off S/R levels (current TF only)\r\n// [*]Comprehensive alert system with 12 alert types (current TF only)\r\n// [*]Significant breakout detection with configurable parameters\r\n// [*]Memory efficient - automatic cleanup of expired levels\r\n// [/list]\r\n\r\n// [b]HOW IT WORKS:[/b]\r\n// The indicator uses ta.pivothigh() and ta.pivotlow() on each enabled timeframe.\r\n// Pivot highs are positioned on bullish candles (using close price).\r\n// Pivot lows are positioned on bearish candles (using close price).\r\n// If the pivot candle is not the correct type, it searches back up to 5 candles.\r\n// Only unbreached levels are displayed as active support/resistance.\r\n// When a level is breached, it becomes a \"mitigated level\" with dashed styling and transparency.\r\n// Mitigation is checked only after the first candle following the pivot (to avoid false triggers).\r\n\r\n// [b]TIMEFRAME FILTERING:[/b]\r\n// [list]\r\n// [*]Timeframes LOWER than current chart are NEVER shown\r\n// [*]Current chart timeframe is ALWAYS shown (cannot be disabled)\r\n// [*]Higher timeframes respect user toggle settings\r\n// [*]Max higher TFs setting limits how many higher TFs are displayed (default 3)\r\n// [/list]\r\n// Example on 1h chart: 15m hidden, 1h always shown, 4h/D/W/M per user settings (max 3)\r\n\r\n// [b]LEVEL MERGING:[/b]\r\n// Nearby levels of the same type AND same timeframe are automatically merged.\r\n// The newer pivot always wins, replacing older levels within the tolerance range.\r\n// Tolerance = TF ATR √ó Merge Tolerance setting (default 0.5 ATR).\r\n\r\n// [b]VISUALIZATION:[/b]\r\n// Each timeframe has its own color and line width for easy distinction:\r\n// [list]\r\n// [*]15m - Cyan, width 1\r\n// [*]1h - Blue, width 1\r\n// [*]4h - Orange/Gold, width 2\r\n// [*]Daily - Green, width 2\r\n// [*]Weekly - Purple, width 3\r\n// [*]Monthly - Red, width 4\r\n// [/list]\r\n// Active levels show as solid lines, mitigated levels as dashed lines with transparency.\r\n// Price scale shows level prices with their respective colors.\r\n\r\n// [b]RETEST DETECTION (Current TF Only):[/b]\r\n// Detects when price tests a S/R level and bounces back. Two patterns are recognized:\r\n// [list]\r\n// [*]Pattern 1: Single candle with long wick touching level and body moving away\r\n// [*]Pattern 2: Previous candle touches level, current candle is reaction candle\r\n// [/list]\r\n// Parameters:\r\n// [list]\r\n// [*]ATR Tolerance - How close price must be to level (default 0.15 ATR)\r\n// [*]Min Wick % - Minimum wick size to confirm rejection (default 30%)\r\n// [/list]\r\n\r\n// [b]ALERT SYSTEM (Current TF Only):[/b]\r\n// All alerts trigger only for levels of the current chart timeframe:\r\n// [list]\r\n// [*]New Pivot (any/Support/Resistance) - when new pivot is detected\r\n// [*]Breakout (any/Support/Resistance) - when level is broken with coherent candle\r\n// [*]Significant Breakout (any/Support/Resistance) - high-quality breakouts\r\n// [*]Retest (any/Support/Resistance) - when level is retested with bounce\r\n// [/list]\r\n\r\n// [b]SIGNIFICANT BREAKOUT CRITERIA:[/b]\r\n// A breakout is considered \"significant\" when:\r\n// [list]\r\n// [*]Candle direction is coherent (bearish for support, bullish for resistance)\r\n// [*]At least X% of the candle body crosses the level (configurable, default 50%)\r\n// [*]Opposite wick is limited to Y% of candle range (configurable, default 30%)\r\n// [/list]\r\n\r\n// [b]SETTINGS OVERVIEW:[/b]\r\n// [list]\r\n// [*]Global Settings - Max levels per TF, max higher TFs, pivot bars, merge tolerance\r\n// [*]Mitigation Settings - Visibility duration, transparency\r\n// [*]Visual Settings - Circles, labels, price scale\r\n// [*]Timeframe Configuration - Enable/disable, color, line width for each TF\r\n// [*]Significant Breakout - Min body cross %, max opposite wick %\r\n// [*]Retest Detection - ATR tolerance, min wick %\r\n// [*]Debug - Show pivot detection markers\r\n// [/list]\r\n\r\nindicator(\"TRI - Layered Multi-Timeframe Support & Resistance\", shorttitle=\"TRI - Layered S/R\", overlay=true, max_lines_count=500, max_labels_count=500, max_bars_back=5000)\r\n\r\n// ============================================================================\r\n// INPUTS - GLOBAL SETTINGS\r\n// ============================================================================\r\nvar G_GLOBAL = \"‚öôÔ∏è Global Settings\"\r\nmaxLevelsPerTF = input.int(3, \"Max Levels per TF\", minval=1, maxval=10, group=G_GLOBAL)\r\nmaxHigherTFs = input.int(2, \"Max Higher Timeframes\", minval=1, maxval=5, group=G_GLOBAL, \r\n  tooltip=\"Maximum number of higher timeframes to show (current TF is always shown)\")\r\npivotLeftBars = input.int(3, \"Pivot Left Bars\", minval=2, maxval=20, group=G_GLOBAL)\r\npivotRightBars = input.int(3, \"Pivot Right Bars\", minval=2, maxval=20, group=G_GLOBAL)\r\nmergeTolerance = input.float(0.5, \"Merge Tolerance (ATR)\", minval=0.0, maxval=2.0, step=0.1, group=G_GLOBAL)\r\nmaxLevelHistory = input.int(100, \"Max Level History\", minval=20, maxval=300, group=G_GLOBAL)\r\n\r\n// Mitigation Settings\r\nvar G_MITIGATION = \"üî∂ Mitigation Settings\"\r\nshowMitigated = input.bool(true, \"Show Mitigated Levels\", group=G_MITIGATION)\r\nmitigatedBars = input.int(10, \"Mitigated Level Bars\", minval=1, maxval=50, group=G_MITIGATION)\r\nmitigatedTransparency = input.int(60, \"Mitigated Transparency %\", minval=0, maxval=90, step=5, group=G_MITIGATION)\r\n\r\n// Visual Settings\r\nvar G_VISUAL = \"üé® Visual Settings\"\r\nshowCircles = input.bool(true, \"Show Pivot Circles\", group=G_VISUAL)\r\nshowRightLabels = input.bool(true, \"Show Right Labels\", group=G_VISUAL)\r\nrightLabelSize = input.string(\"small\", \"Right Label Size\", options=[\"tiny\", \"small\", \"normal\", \"large\"], group=G_VISUAL)\r\nshowPriceScale = input.bool(true, \"Show on Price Scale\", group=G_VISUAL, \r\n  tooltip=\"Show S/R levels as colored labels on the price scale\")\r\n\r\n// Significant Breakout Settings (for current TF alerts)\r\nvar G_SIG_BREAKOUT = \"üìä Significant Breakout\"\r\nminBodyCrossPercent = input.float(50.0, \"Min Body Cross %\", minval=10.0, maxval=100.0, step=5.0, group=G_SIG_BREAKOUT,\r\n  tooltip=\"Minimum % of candle body that must cross the level\")\r\nmaxOppositeWickPercent = input.float(30.0, \"Max Opposite Wick %\", minval=0.0, maxval=100.0, step=5.0, group=G_SIG_BREAKOUT,\r\n  tooltip=\"Maximum % of opposite wick relative to candle range\")\r\n\r\n// Retest Settings (for current TF alerts)\r\nvar G_RETEST = \"üîÑ Retest Detection\"\r\nretestATRTolerance = input.float(0.15, \"Retest ATR Tolerance\", minval=0.05, maxval=0.5, step=0.05, group=G_RETEST,\r\n  tooltip=\"How close price must be to level (in ATR) to count as a touch\")\r\nretestMinWickPercent = input.float(30.0, \"Min Wick %\", minval=10.0, maxval=80.0, step=5.0, group=G_RETEST,\r\n  tooltip=\"Minimum wick size as % of candle range to confirm rejection\")\r\n\r\n// ============================================================================\r\n// INPUTS - TIMEFRAME CONFIGURATION\r\n// ============================================================================\r\n\r\n// 15 Minutes\r\nvar G_15M = \"üìä 15 Minutes\"\r\nshow15m = input.bool(false, \"Enable 15m Levels\", group=G_15M)\r\ncolor15m = input.color(color.new(color.aqua, 0), \"15m Color\", group=G_15M)\r\nwidth15m = input.int(1, \"15m Line Width\", minval=1, maxval=5, group=G_15M)\r\n\r\n// 1 Hour\r\nvar G_1H = \"üìä 1 Hour\"\r\nshow1h = input.bool(false, \"Enable 1h Levels\", group=G_1H)\r\ncolor1h = input.color(color.new(color.blue, 0), \"1h Color\", group=G_1H)\r\nwidth1h = input.int(1, \"1h Line Width\", minval=1, maxval=5, group=G_1H)\r\n\r\n// 4 Hours\r\nvar G_4H = \"üìä 4 Hours\"\r\nshow4h = input.bool(true, \"Enable 4h Levels\", group=G_4H)\r\ncolor4h = input.color(color.new(color.orange, 0), \"4h Color\", group=G_4H)\r\nwidth4h = input.int(2, \"4h Line Width\", minval=1, maxval=5, group=G_4H)\r\n\r\n// Daily\r\nvar G_DAILY = \"üìä Daily\"\r\nshowDaily = input.bool(true, \"Enable Daily Levels\", group=G_DAILY)\r\ncolorDaily = input.color(color.new(color.green, 0), \"Daily Color\", group=G_DAILY)\r\nwidthDaily = input.int(2, \"Daily Line Width\", minval=1, maxval=5, group=G_DAILY)\r\n\r\n// Weekly\r\nvar G_WEEKLY = \"üìä Weekly\"\r\nshowWeekly = input.bool(true, \"Enable Weekly Levels\", group=G_WEEKLY)\r\ncolorWeekly = input.color(color.new(color.purple, 0), \"Weekly Color\", group=G_WEEKLY)\r\nwidthWeekly = input.int(3, \"Weekly Line Width\", minval=1, maxval=5, group=G_WEEKLY)\r\n\r\n// Monthly\r\nvar G_MONTHLY = \"üìä Monthly\"\r\nshowMonthly = input.bool(false, \"Enable Monthly Levels\", group=G_MONTHLY)\r\ncolorMonthly = input.color(color.new(color.red, 0), \"Monthly Color\", group=G_MONTHLY)\r\nwidthMonthly = input.int(4, \"Monthly Line Width\", minval=1, maxval=5, group=G_MONTHLY)\r\n\r\n// Debug Settings\r\nvar G_DEBUG = \"üîß Debug\"\r\nshowDebugPivots = input.bool(false, \"Show Pivot Detection\", group=G_DEBUG)\r\n\r\n// ============================================================================\r\n// TYPE DEFINITIONS\r\n// ============================================================================\r\ntype SRLevel\r\n    float price\r\n    int barTime\r\n    int barTimeExpiry\r\n    int mitigationAllowedTime\r\n    bool isResistance\r\n    bool isMitigated\r\n    int mitigationTime\r\n    int visibleUntilTime\r\n    string timeframe\r\n    color levelColor\r\n    int levelWidth\r\n    line levelLine\r\n    label circleLabel\r\n    label rightLabel\r\n\r\n// ============================================================================\r\n// ARRAYS FOR LEVEL MANAGEMENT\r\n// ============================================================================\r\nvar array<SRLevel> srLevels = array.new<SRLevel>()\r\n\r\n// ============================================================================\r\n// HELPER FUNCTIONS\r\n// ============================================================================\r\n\r\n// Convert current chart TF to minutes\r\ngetCurrentTFMinutes() =>\r\n    int minutes = 1\r\n    if timeframe.isdaily\r\n        minutes := 1440\r\n    else if timeframe.isweekly\r\n        minutes := 10080\r\n    else if timeframe.ismonthly\r\n        minutes := 43200\r\n    else\r\n        minutes := timeframe.in_seconds() / 60\r\n    minutes\r\n\r\n// Convert TF string to minutes for comparison\r\ntfToMinutes(string tf) =>\r\n    int minutes = 1\r\n    switch tf\r\n        \"1\" => minutes := 1\r\n        \"5\" => minutes := 5\r\n        \"15\" => minutes := 15\r\n        \"30\" => minutes := 30\r\n        \"60\" => minutes := 60\r\n        \"240\" => minutes := 240\r\n        \"D\" => minutes := 1440\r\n        \"W\" => minutes := 10080\r\n        \"M\" => minutes := 43200\r\n    minutes\r\n\r\n// Get current chart TF minutes (calculated once)\r\ncurrentChartTFMinutes = getCurrentTFMinutes()\r\n\r\n// Check if a TF should be shown (>= current chart TF)\r\nisTFAllowed(string tf) =>\r\n    tfToMinutes(tf) >= currentChartTFMinutes\r\n\r\n// Check if a TF is the current chart TF\r\nisCurrentTF(string tf) =>\r\n    tfToMinutes(tf) == currentChartTFMinutes\r\n\r\n// Get the closest matching TF string for current chart\r\ngetCurrentTFString() =>\r\n    string result = \"D\"\r\n    if currentChartTFMinutes <= 15\r\n        result := \"15\"\r\n    else if currentChartTFMinutes <= 60\r\n        result := \"60\"\r\n    else if currentChartTFMinutes <= 240\r\n        result := \"240\"\r\n    else if currentChartTFMinutes <= 1440\r\n        result := \"D\"\r\n    else if currentChartTFMinutes <= 10080\r\n        result := \"W\"\r\n    else\r\n        result := \"M\"\r\n    result\r\n\r\ncurrentTFString = getCurrentTFString()\r\n\r\n// Get timeframe label\r\ngetTFLabel(string tf) =>\r\n    switch tf\r\n        \"15\" => \"15m\"\r\n        \"60\" => \"1h\"\r\n        \"240\" => \"4h\"\r\n        \"D\" => \"D\"\r\n        \"W\" => \"W\"\r\n        \"M\" => \"M\"\r\n        => tf\r\n\r\n// Get timeframe config (considers TF filtering)\r\ngetTFConfig(string tf) =>\r\n    bool enabled = false\r\n    color tfColor = color.gray\r\n    int tfWidth = 1\r\n    \r\n    // First check if TF is allowed (>= current chart TF)\r\n    bool tfAllowed = isTFAllowed(tf)\r\n    bool isCurrent = isCurrentTF(tf)\r\n    \r\n    switch tf\r\n        \"15\" =>\r\n            // If current TF, always show. Otherwise respect user setting\r\n            enabled := tfAllowed and (isCurrent or show15m)\r\n            tfColor := color15m\r\n            tfWidth := width15m\r\n        \"60\" =>\r\n            enabled := tfAllowed and (isCurrent or show1h)\r\n            tfColor := color1h\r\n            tfWidth := width1h\r\n        \"240\" =>\r\n            enabled := tfAllowed and (isCurrent or show4h)\r\n            tfColor := color4h\r\n            tfWidth := width4h\r\n        \"D\" =>\r\n            enabled := tfAllowed and (isCurrent or showDaily)\r\n            tfColor := colorDaily\r\n            tfWidth := widthDaily\r\n        \"W\" =>\r\n            enabled := tfAllowed and (isCurrent or showWeekly)\r\n            tfColor := colorWeekly\r\n            tfWidth := widthWeekly\r\n        \"M\" =>\r\n            enabled := tfAllowed and (isCurrent or showMonthly)\r\n            tfColor := colorMonthly\r\n            tfWidth := widthMonthly\r\n    \r\n    [enabled, tfColor, tfWidth]\r\n\r\n// Delete level visuals\r\nmethod delete(SRLevel level) =>\r\n    if not na(level.levelLine)\r\n        level.levelLine.delete()\r\n    if not na(level.circleLabel)\r\n        level.circleLabel.delete()\r\n    if not na(level.rightLabel)\r\n        level.rightLabel.delete()\r\n\r\n// Check if level was breached\r\nmethod isBreach(SRLevel level, float htfClose) =>\r\n    if level.isResistance\r\n        htfClose > level.price\r\n    else\r\n        htfClose < level.price\r\n\r\n// Check if breakout is significant (coherent candle direction + body cross + limited opposite wick)\r\ncheckSignificantBreakout(float levelPrice, bool isResistance, float candleOpen, float candleClose, float candleHigh, float candleLow) =>\r\n    bool isSignificant = false\r\n    bool isCoherent = false\r\n    \r\n    float candleRange = candleHigh - candleLow\r\n    float bodyHigh = math.max(candleOpen, candleClose)\r\n    float bodyLow = math.min(candleOpen, candleClose)\r\n    float bodySize = bodyHigh - bodyLow\r\n    \r\n    bool isBullish = candleClose > candleOpen\r\n    bool isBearish = candleClose < candleOpen\r\n    \r\n    if candleRange > 0 and bodySize > 0\r\n        if isResistance\r\n            isCoherent := isBullish\r\n            if isCoherent\r\n                float bodyCrossed = bodyHigh - levelPrice\r\n                float bodyCrossPercent = (bodyCrossed / bodySize) * 100\r\n                float lowerWick = bodyLow - candleLow\r\n                float lowerWickPercent = (lowerWick / candleRange) * 100\r\n                isSignificant := bodyCrossPercent >= minBodyCrossPercent and lowerWickPercent <= maxOppositeWickPercent\r\n        else\r\n            isCoherent := isBearish\r\n            if isCoherent\r\n                float bodyCrossed = levelPrice - bodyLow\r\n                float bodyCrossPercent = (bodyCrossed / bodySize) * 100\r\n                float upperWick = candleHigh - bodyHigh\r\n                float upperWickPercent = (upperWick / candleRange) * 100\r\n                isSignificant := bodyCrossPercent >= minBodyCrossPercent and upperWickPercent <= maxOppositeWickPercent\r\n    \r\n    [isSignificant, isCoherent]\r\n\r\n// Check if current candle is a retest of a level\r\ncheckRetest(float levelPrice, bool isResistance, float candleOpen, float candleClose, float candleHigh, float candleLow, float atrValue, float prevOpen, float prevLow, float prevHigh, float prevClose) =>\r\n    bool isRetest = false\r\n    \r\n    float tolerance = atrValue * retestATRTolerance\r\n    float candleRange = candleHigh - candleLow\r\n    bool isBullish = candleClose > candleOpen\r\n    bool isBearish = candleClose < candleOpen\r\n    bool prevWasBearish = prevClose < prevOpen\r\n    bool prevWasBullish = prevClose > prevOpen\r\n    \r\n    if candleRange > 0 and not na(atrValue) and atrValue > 0\r\n        if not isResistance\r\n            bool touchedNow = candleLow <= levelPrice + tolerance and candleLow >= levelPrice - tolerance\r\n            bool touchedPrev = prevLow <= levelPrice + tolerance and prevLow >= levelPrice - tolerance\r\n            \r\n            if touchedNow and isBullish\r\n                float lowerWick = math.min(candleOpen, candleClose) - candleLow\r\n                float lowerWickPercent = (lowerWick / candleRange) * 100\r\n                if lowerWickPercent >= retestMinWickPercent\r\n                    isRetest := true\r\n            \r\n            if touchedPrev and prevWasBearish and isBullish and candleClose > prevClose\r\n                isRetest := true\r\n        else\r\n            bool touchedNow = candleHigh >= levelPrice - tolerance and candleHigh <= levelPrice + tolerance\r\n            bool touchedPrev = prevHigh >= levelPrice - tolerance and prevHigh <= levelPrice + tolerance\r\n            \r\n            if touchedNow and isBearish\r\n                float upperWick = candleHigh - math.max(candleOpen, candleClose)\r\n                float upperWickPercent = (upperWick / candleRange) * 100\r\n                if upperWickPercent >= retestMinWickPercent\r\n                    isRetest := true\r\n            \r\n            if touchedPrev and prevWasBullish and isBearish and candleClose < prevClose\r\n                isRetest := true\r\n    \r\n    isRetest\r\n\r\n// Mark level as mitigated\r\nmethod markMitigated(SRLevel level, int htfMitigationTime, int htfBarDuration) =>\r\n    level.isMitigated := true\r\n    level.mitigationTime := htfMitigationTime\r\n    level.visibleUntilTime := level.mitigationTime + (htfBarDuration * mitigatedBars)\r\n    \r\n    // Update visual with transparency\r\n    color mitigatedCol = color.new(level.levelColor, mitigatedTransparency)\r\n    if not na(level.levelLine)\r\n        line.set_color(level.levelLine, mitigatedCol)\r\n        line.set_style(level.levelLine, line.style_dashed)\r\n    if not na(level.circleLabel)\r\n        label.set_color(level.circleLabel, color.new(level.levelColor, mitigatedTransparency + 20))\r\n\r\n// Apply active visual\r\nmethod applyActiveVisual(SRLevel level, int endTime) =>\r\n    if not na(level.levelLine)\r\n        line.set_x2(level.levelLine, endTime)\r\n        line.set_color(level.levelLine, level.levelColor)\r\n\r\n// Apply mitigated visual\r\nmethod applyMitigatedVisual(SRLevel level, int endTime) =>\r\n    color mitigatedCol = color.new(level.levelColor, mitigatedTransparency)\r\n    if not na(level.levelLine)\r\n        line.set_x2(level.levelLine, endTime)\r\n        line.set_color(level.levelLine, mitigatedCol)\r\n        line.set_style(level.levelLine, line.style_dashed)\r\n\r\n// Check if level expired\r\nmethod hasExpired(SRLevel level, int htfCurrentTime) =>\r\n    bool expired = false\r\n    if level.isMitigated\r\n        expired := htfCurrentTime >= level.visibleUntilTime\r\n    else\r\n        expired := htfCurrentTime > level.barTimeExpiry\r\n    expired\r\n\r\n// Check if two levels are nearby\r\nmethod isNearby(SRLevel levelA, SRLevel levelB, float tolerance) =>\r\n    bool result = false\r\n    // Only merge levels of same type AND same timeframe\r\n    if levelA.isResistance == levelB.isResistance and levelA.timeframe == levelB.timeframe\r\n        result := math.abs(levelA.price - levelB.price) <= tolerance\r\n    result\r\n\r\n// Remove nearby levels (newer wins)\r\nremoveNearbyLevels(array<SRLevel> levels, float tolerance) =>\r\n    if tolerance > 0\r\n        int levelsSize = array.size(levels)\r\n        if levelsSize > 1\r\n            array<bool> toRemove = array.new<bool>()\r\n            for i = 0 to levelsSize - 1\r\n                array.push(toRemove, false)\r\n            \r\n            for i = 0 to levelsSize - 2\r\n                if array.get(toRemove, i)\r\n                    continue\r\n                levelA = array.get(levels, i)\r\n                \r\n                for j = i + 1 to levelsSize - 1\r\n                    if array.get(toRemove, j)\r\n                        continue\r\n                    levelB = array.get(levels, j)\r\n                    \r\n                    if levelA.isNearby(levelB, tolerance)\r\n                        array.set(toRemove, j, true)\r\n            \r\n            for i = levelsSize - 1 to 0\r\n                if array.get(toRemove, i)\r\n                    level = array.get(levels, i)\r\n                    level.delete()\r\n                    array.remove(levels, i)\r\n\r\n// ============================================================================\r\n// LEVEL CREATION\r\n// ============================================================================\r\ncreateSRLevel(float price, int barTime, int htfBarDuration, bool isResistance, string tf, color tfColor, int tfWidth, int levelExtend) =>\r\n    level = SRLevel.new(\r\n      price = price,\r\n      barTime = barTime,\r\n      barTimeExpiry = barTime + (htfBarDuration * levelExtend),\r\n      mitigationAllowedTime = barTime + htfBarDuration,\r\n      isResistance = isResistance,\r\n      isMitigated = false,\r\n      mitigationTime = na,\r\n      visibleUntilTime = na,\r\n      timeframe = tf,\r\n      levelColor = tfColor,\r\n      levelWidth = tfWidth,\r\n      levelLine = line(na),\r\n      circleLabel = label(na),\r\n      rightLabel = label(na))\r\n    \r\n    // Create line\r\n    level.levelLine := line.new(\r\n      x1 = barTime,\r\n      y1 = price,\r\n      x2 = barTime + htfBarDuration,\r\n      y2 = price,\r\n      xloc = xloc.bar_time,\r\n      extend = extend.right,\r\n      color = tfColor,\r\n      width = tfWidth,\r\n      style = line.style_solid)\r\n    \r\n    // Create circle at pivot point\r\n    if showCircles\r\n        level.circleLabel := label.new(\r\n          x = barTime,\r\n          y = price,\r\n          text = \"\",\r\n          xloc = xloc.bar_time,\r\n          yloc = yloc.price,\r\n          color = color.new(tfColor, 50),\r\n          style = label.style_circle,\r\n          size = size.tiny)\r\n    \r\n    level\r\n\r\n// ============================================================================\r\n// TIMEFRAME DATA STRUCTURE\r\n// ============================================================================\r\ntype TFData\r\n    string tf\r\n    float pivotHigh\r\n    float pivotLow\r\n    int pivotHighTime\r\n    int pivotLowTime\r\n    float pivotHighPrice\r\n    float pivotLowPrice\r\n    float htfClose\r\n    int htfTime\r\n    int htfCurrentTime\r\n    float htfATR\r\n    int htfBarDuration\r\n    float lastPivotHigh\r\n    float lastPivotLow\r\n\r\n// ============================================================================\r\n// REQUEST DATA FOR EACH TIMEFRAME\r\n// ============================================================================\r\n\r\n// Function to find pivot high data\r\nfindPivotHighData(int leftBars, int rightBars) =>\r\n    int resultTime = na\r\n    float resultPrice = na\r\n    if not na(ta.pivothigh(math.max(open, close), leftBars, rightBars))\r\n        int offset = rightBars\r\n        if close[offset] < open[offset]\r\n            for i = offset + 1 to offset + 5\r\n                if close[i] > open[i]\r\n                    offset := i\r\n                    break\r\n        resultTime := time[offset]\r\n        resultPrice := close[offset]\r\n    [resultTime, resultPrice]\r\n\r\n// Function to find pivot low data\r\nfindPivotLowData(int leftBars, int rightBars) =>\r\n    int resultTime = na\r\n    float resultPrice = na\r\n    if not na(ta.pivotlow(math.min(open, close), leftBars, rightBars))\r\n        int offset = rightBars\r\n        if close[offset] > open[offset]\r\n            for i = offset + 1 to offset + 5\r\n                if close[i] < open[i]\r\n                    offset := i\r\n                    break\r\n        resultTime := time[offset]\r\n        resultPrice := close[offset]\r\n    [resultTime, resultPrice]\r\n\r\n// ============================================================================\r\n// 15M DATA\r\n// ============================================================================\r\n[ph15m, pl15m] = request.security(syminfo.tickerid, \"15\", \r\n    [ta.pivothigh(math.max(open, close), pivotLeftBars, pivotRightBars),\r\n     ta.pivotlow(math.min(open, close), pivotLeftBars, pivotRightBars)], lookahead=barmerge.lookahead_off)\r\n[phTime15m, phPrice15m] = request.security(syminfo.tickerid, \"15\", findPivotHighData(pivotLeftBars, pivotRightBars), lookahead=barmerge.lookahead_off)\r\n[plTime15m, plPrice15m] = request.security(syminfo.tickerid, \"15\", findPivotLowData(pivotLeftBars, pivotRightBars), lookahead=barmerge.lookahead_off)\r\n[htfClose15m, htfTime15m, htfCurrentTime15m] = request.security(syminfo.tickerid, \"15\", [close, time[1], time], lookahead=barmerge.lookahead_off)\r\nhtfATR15m = request.security(syminfo.tickerid, \"15\", ta.atr(14), lookahead=barmerge.lookahead_off)\r\n\r\n// ============================================================================\r\n// 1H DATA\r\n// ============================================================================\r\n[ph1h, pl1h] = request.security(syminfo.tickerid, \"60\", \r\n    [ta.pivothigh(math.max(open, close), pivotLeftBars, pivotRightBars),\r\n     ta.pivotlow(math.min(open, close), pivotLeftBars, pivotRightBars)], lookahead=barmerge.lookahead_off)\r\n[phTime1h, phPrice1h] = request.security(syminfo.tickerid, \"60\", findPivotHighData(pivotLeftBars, pivotRightBars), lookahead=barmerge.lookahead_off)\r\n[plTime1h, plPrice1h] = request.security(syminfo.tickerid, \"60\", findPivotLowData(pivotLeftBars, pivotRightBars), lookahead=barmerge.lookahead_off)\r\n[htfClose1h, htfTime1h, htfCurrentTime1h] = request.security(syminfo.tickerid, \"60\", [close, time[1], time], lookahead=barmerge.lookahead_off)\r\nhtfATR1h = request.security(syminfo.tickerid, \"60\", ta.atr(14), lookahead=barmerge.lookahead_off)\r\n\r\n// ============================================================================\r\n// 4H DATA\r\n// ============================================================================\r\n[ph4h, pl4h] = request.security(syminfo.tickerid, \"240\", \r\n    [ta.pivothigh(math.max(open, close), pivotLeftBars, pivotRightBars),\r\n     ta.pivotlow(math.min(open, close), pivotLeftBars, pivotRightBars)], lookahead=barmerge.lookahead_off)\r\n[phTime4h, phPrice4h] = request.security(syminfo.tickerid, \"240\", findPivotHighData(pivotLeftBars, pivotRightBars), lookahead=barmerge.lookahead_off)\r\n[plTime4h, plPrice4h] = request.security(syminfo.tickerid, \"240\", findPivotLowData(pivotLeftBars, pivotRightBars), lookahead=barmerge.lookahead_off)\r\n[htfClose4h, htfTime4h, htfCurrentTime4h] = request.security(syminfo.tickerid, \"240\", [close, time[1], time], lookahead=barmerge.lookahead_off)\r\nhtfATR4h = request.security(syminfo.tickerid, \"240\", ta.atr(14), lookahead=barmerge.lookahead_off)\r\n\r\n// ============================================================================\r\n// DAILY DATA\r\n// ============================================================================\r\n[phD, plD] = request.security(syminfo.tickerid, \"D\", \r\n    [ta.pivothigh(math.max(open, close), pivotLeftBars, pivotRightBars),\r\n     ta.pivotlow(math.min(open, close), pivotLeftBars, pivotRightBars)], lookahead=barmerge.lookahead_off)\r\n[phTimeD, phPriceD] = request.security(syminfo.tickerid, \"D\", findPivotHighData(pivotLeftBars, pivotRightBars), lookahead=barmerge.lookahead_off)\r\n[plTimeD, plPriceD] = request.security(syminfo.tickerid, \"D\", findPivotLowData(pivotLeftBars, pivotRightBars), lookahead=barmerge.lookahead_off)\r\n[htfCloseD, htfTimeD, htfCurrentTimeD] = request.security(syminfo.tickerid, \"D\", [close, time[1], time], lookahead=barmerge.lookahead_off)\r\nhtfATRD = request.security(syminfo.tickerid, \"D\", ta.atr(14), lookahead=barmerge.lookahead_off)\r\n\r\n// ============================================================================\r\n// WEEKLY DATA\r\n// ============================================================================\r\n[phW, plW] = request.security(syminfo.tickerid, \"W\", \r\n    [ta.pivothigh(math.max(open, close), pivotLeftBars, pivotRightBars),\r\n     ta.pivotlow(math.min(open, close), pivotLeftBars, pivotRightBars)], lookahead=barmerge.lookahead_off)\r\n[phTimeW, phPriceW] = request.security(syminfo.tickerid, \"W\", findPivotHighData(pivotLeftBars, pivotRightBars), lookahead=barmerge.lookahead_off)\r\n[plTimeW, plPriceW] = request.security(syminfo.tickerid, \"W\", findPivotLowData(pivotLeftBars, pivotRightBars), lookahead=barmerge.lookahead_off)\r\n[htfCloseW, htfTimeW, htfCurrentTimeW] = request.security(syminfo.tickerid, \"W\", [close, time[1], time], lookahead=barmerge.lookahead_off)\r\nhtfATRW = request.security(syminfo.tickerid, \"W\", ta.atr(14), lookahead=barmerge.lookahead_off)\r\n\r\n// ============================================================================\r\n// MONTHLY DATA\r\n// ============================================================================\r\n[phM, plM] = request.security(syminfo.tickerid, \"M\", \r\n    [ta.pivothigh(math.max(open, close), pivotLeftBars, pivotRightBars),\r\n     ta.pivotlow(math.min(open, close), pivotLeftBars, pivotRightBars)], lookahead=barmerge.lookahead_off)\r\n[phTimeM, phPriceM] = request.security(syminfo.tickerid, \"M\", findPivotHighData(pivotLeftBars, pivotRightBars), lookahead=barmerge.lookahead_off)\r\n[plTimeM, plPriceM] = request.security(syminfo.tickerid, \"M\", findPivotLowData(pivotLeftBars, pivotRightBars), lookahead=barmerge.lookahead_off)\r\n[htfCloseM, htfTimeM, htfCurrentTimeM] = request.security(syminfo.tickerid, \"M\", [close, time[1], time], lookahead=barmerge.lookahead_off)\r\nhtfATRM = request.security(syminfo.tickerid, \"M\", ta.atr(14), lookahead=barmerge.lookahead_off)\r\n\r\n// ============================================================================\r\n// TRACKING VARIABLES\r\n// ============================================================================\r\nvar float lastPH15m = na\r\nvar float lastPL15m = na\r\nvar float lastPH1h = na\r\nvar float lastPL1h = na\r\nvar float lastPH4h = na\r\nvar float lastPL4h = na\r\nvar float lastPHD = na\r\nvar float lastPLD = na\r\nvar float lastPHW = na\r\nvar float lastPLW = na\r\nvar float lastPHM = na\r\nvar float lastPLM = na\r\n\r\n// Level extension in bars\r\nlevelExtendBars = input.int(100, \"Level Extension Bars\", minval=10, maxval=500, group=G_GLOBAL)\r\n\r\n// Current bar duration\r\nvar int currentBarDuration = na\r\nif na(currentBarDuration)\r\n    currentBarDuration := timeframe.in_seconds() * 1000\r\n\r\n// ============================================================================\r\n// PROCESS PIVOTS FUNCTION\r\n// ============================================================================\r\nprocessPivots(string tf, bool enabled, float pivotHigh, float pivotLow, int phTime, float phPrice, int plTime, float plPrice, float htfClose, int htfCurrentTime, float htfATR, float lastPH, float lastPL, color tfColor, int tfWidth) =>\r\n    float newLastPH = lastPH\r\n    float newLastPL = lastPL\r\n    bool newPivotR = false\r\n    bool newPivotS = false\r\n    \r\n    if enabled and not na(htfClose)\r\n        // Calculate bar duration for this TF\r\n        int htfBarDuration = timeframe.in_seconds(tf) * 1000\r\n        \r\n        // Detect pivot high\r\n        if not na(pivotHigh) and (na(lastPH) or pivotHigh != lastPH)\r\n            if not na(phTime) and not na(phPrice)\r\n                newLevel = createSRLevel(phPrice, phTime, htfBarDuration, true, tf, tfColor, tfWidth, levelExtendBars)\r\n                array.unshift(srLevels, newLevel)\r\n                newPivotR := true\r\n                \r\n                if showDebugPivots\r\n                    label.new(phTime, phPrice, \"‚ñº \" + getTFLabel(tf), xloc=xloc.bar_time, \r\n                      color=color.new(tfColor, 20), textcolor=color.white, \r\n                      style=label.style_label_down, size=size.tiny)\r\n        \r\n        // Detect pivot low\r\n        if not na(pivotLow) and (na(lastPL) or pivotLow != lastPL)\r\n            if not na(plTime) and not na(plPrice)\r\n                newLevel = createSRLevel(plPrice, plTime, htfBarDuration, false, tf, tfColor, tfWidth, levelExtendBars)\r\n                array.unshift(srLevels, newLevel)\r\n                newPivotS := true\r\n                \r\n                if showDebugPivots\r\n                    label.new(plTime, plPrice, \"‚ñ≤ \" + getTFLabel(tf), xloc=xloc.bar_time, \r\n                      color=color.new(tfColor, 20), textcolor=color.white, \r\n                      style=label.style_label_up, size=size.tiny)\r\n        \r\n        newLastPH := pivotHigh\r\n        newLastPL := pivotLow\r\n        \r\n        // Merge nearby levels for this TF\r\n        if mergeTolerance > 0 and not na(htfATR) and htfATR > 0\r\n            float mergeVal = htfATR * mergeTolerance\r\n            removeNearbyLevels(srLevels, mergeVal)\r\n    \r\n    [newLastPH, newLastPL, newPivotR, newPivotS]\r\n\r\n// ============================================================================\r\n// PROCESS ALL TIMEFRAMES\r\n// ============================================================================\r\n\r\n// Calculate effective enabled state considering:\r\n// 1. TF must be >= current chart TF (no lower TFs)\r\n// 2. Current TF is always shown\r\n// 3. Max N higher TFs allowed (in ascending order)\r\n\r\n// Check which TFs are higher than current and user-enabled\r\nbool is15mHigher = tfToMinutes(\"15\") > currentChartTFMinutes and show15m\r\nbool is1hHigher = tfToMinutes(\"60\") > currentChartTFMinutes and show1h\r\nbool is4hHigher = tfToMinutes(\"240\") > currentChartTFMinutes and show4h\r\nbool isDailyHigher = tfToMinutes(\"D\") > currentChartTFMinutes and showDaily\r\nbool isWeeklyHigher = tfToMinutes(\"W\") > currentChartTFMinutes and showWeekly\r\nbool isMonthlyHigher = tfToMinutes(\"M\") > currentChartTFMinutes and showMonthly\r\n\r\n// Count higher TFs in ascending order and limit to maxHigherTFs\r\nint higherCount = 0\r\n\r\n// 15m - check if it's higher and within limit\r\nbool enabled15m = isCurrentTF(\"15\") or (is15mHigher and higherCount < maxHigherTFs)\r\nif is15mHigher and enabled15m\r\n    higherCount += 1\r\n\r\n// 1h - check if it's higher and within limit\r\nbool enabled1h = isCurrentTF(\"60\") or (is1hHigher and higherCount < maxHigherTFs)\r\nif is1hHigher and enabled1h\r\n    higherCount += 1\r\n\r\n// 4h - check if it's higher and within limit\r\nbool enabled4h = isCurrentTF(\"240\") or (is4hHigher and higherCount < maxHigherTFs)\r\nif is4hHigher and enabled4h\r\n    higherCount += 1\r\n\r\n// Daily - check if it's higher and within limit\r\nbool enabledDaily = isCurrentTF(\"D\") or (isDailyHigher and higherCount < maxHigherTFs)\r\nif isDailyHigher and enabledDaily\r\n    higherCount += 1\r\n\r\n// Weekly - check if it's higher and within limit\r\nbool enabledWeekly = isCurrentTF(\"W\") or (isWeeklyHigher and higherCount < maxHigherTFs)\r\nif isWeeklyHigher and enabledWeekly\r\n    higherCount += 1\r\n\r\n// Monthly - check if it's higher and within limit  \r\nbool enabledMonthly = isCurrentTF(\"M\") or (isMonthlyHigher and higherCount < maxHigherTFs)\r\nif isMonthlyHigher and enabledMonthly\r\n    higherCount += 1\r\n\r\n// Also disable if TF is lower than current\r\nenabled15m := enabled15m and isTFAllowed(\"15\")\r\nenabled1h := enabled1h and isTFAllowed(\"60\")\r\nenabled4h := enabled4h and isTFAllowed(\"240\")\r\nenabledDaily := enabledDaily and isTFAllowed(\"D\")\r\nenabledWeekly := enabledWeekly and isTFAllowed(\"W\")\r\nenabledMonthly := enabledMonthly and isTFAllowed(\"M\")\r\n\r\n// Process 15m (only if >= current TF)\r\n[newLastPH15m, newLastPL15m, newPR15m, newPS15m] = processPivots(\"15\", enabled15m, ph15m, pl15m, phTime15m, phPrice15m, plTime15m, plPrice15m, htfClose15m, htfCurrentTime15m, htfATR15m, lastPH15m, lastPL15m, color15m, width15m)\r\nlastPH15m := newLastPH15m\r\nlastPL15m := newLastPL15m\r\n\r\n// Process 1h (only if >= current TF)\r\n[newLastPH1h, newLastPL1h, newPR1h, newPS1h] = processPivots(\"60\", enabled1h, ph1h, pl1h, phTime1h, phPrice1h, plTime1h, plPrice1h, htfClose1h, htfCurrentTime1h, htfATR1h, lastPH1h, lastPL1h, color1h, width1h)\r\nlastPH1h := newLastPH1h\r\nlastPL1h := newLastPL1h\r\n\r\n// Process 4h (only if >= current TF)\r\n[newLastPH4h, newLastPL4h, newPR4h, newPS4h] = processPivots(\"240\", enabled4h, ph4h, pl4h, phTime4h, phPrice4h, plTime4h, plPrice4h, htfClose4h, htfCurrentTime4h, htfATR4h, lastPH4h, lastPL4h, color4h, width4h)\r\nlastPH4h := newLastPH4h\r\nlastPL4h := newLastPL4h\r\n\r\n// Process Daily (only if >= current TF)\r\n[newLastPHD, newLastPLD, newPRD, newPSD] = processPivots(\"D\", enabledDaily, phD, plD, phTimeD, phPriceD, plTimeD, plPriceD, htfCloseD, htfCurrentTimeD, htfATRD, lastPHD, lastPLD, colorDaily, widthDaily)\r\nlastPHD := newLastPHD\r\nlastPLD := newLastPLD\r\n\r\n// Process Weekly (only if >= current TF)\r\n[newLastPHW, newLastPLW, newPRW, newPSW] = processPivots(\"W\", enabledWeekly, phW, plW, phTimeW, phPriceW, plTimeW, plPriceW, htfCloseW, htfCurrentTimeW, htfATRW, lastPHW, lastPLW, colorWeekly, widthWeekly)\r\nlastPHW := newLastPHW\r\nlastPLW := newLastPLW\r\n\r\n// Process Monthly (only if >= current TF)\r\n[newLastPHM, newLastPLM, newPRM, newPSM] = processPivots(\"M\", enabledMonthly, phM, plM, phTimeM, phPriceM, plTimeM, plPriceM, htfCloseM, htfCurrentTimeM, htfATRM, lastPHM, lastPLM, colorMonthly, widthMonthly)\r\nlastPHM := newLastPHM\r\nlastPLM := newLastPLM\r\n\r\n// Limit array size\r\nif array.size(srLevels) > maxLevelHistory\r\n    for i = array.size(srLevels) - 1 to maxLevelHistory\r\n        oldLevel = array.pop(srLevels)\r\n        oldLevel.delete()\r\n\r\n// ============================================================================\r\n// ALERT TRACKING (only for current TF levels)\r\n// ============================================================================\r\n\r\n// Current TF ATR for retest detection\r\ncurrentTFATR = ta.atr(14)\r\n\r\n// Alert condition tracking variables\r\nvar bool breakoutSupport = false\r\nvar bool breakoutResistance = false\r\nvar bool significantBreakoutSupport = false\r\nvar bool significantBreakoutResistance = false\r\nvar bool retestSupport = false\r\nvar bool retestResistance = false\r\n\r\n// Reset alert conditions every bar\r\nbreakoutSupport := false\r\nbreakoutResistance := false\r\nsignificantBreakoutSupport := false\r\nsignificantBreakoutResistance := false\r\nretestSupport := false\r\nretestResistance := false\r\n\r\n// ============================================================================\r\n// UPDATE LEVELS - MITIGATION CHECK\r\n// ============================================================================\r\n\r\n// Get HTF close for each level's timeframe\r\ngetHTFClose(string tf) =>\r\n    float result = na\r\n    switch tf\r\n        \"15\" => result := htfClose15m\r\n        \"60\" => result := htfClose1h\r\n        \"240\" => result := htfClose4h\r\n        \"D\" => result := htfCloseD\r\n        \"W\" => result := htfCloseW\r\n        \"M\" => result := htfCloseM\r\n    result\r\n\r\ngetHTFCurrentTime(string tf) =>\r\n    int result = na\r\n    switch tf\r\n        \"15\" => result := htfCurrentTime15m\r\n        \"60\" => result := htfCurrentTime1h\r\n        \"240\" => result := htfCurrentTime4h\r\n        \"D\" => result := htfCurrentTimeD\r\n        \"W\" => result := htfCurrentTimeW\r\n        \"M\" => result := htfCurrentTimeM\r\n    result\r\n\r\ngetHTFBarDuration(string tf) =>\r\n    timeframe.in_seconds(tf) * 1000\r\n\r\ngetTFIndex(string tf) =>\r\n    int idx = 0\r\n    switch tf\r\n        \"15\" => idx := 0\r\n        \"60\" => idx := 1\r\n        \"240\" => idx := 2\r\n        \"D\" => idx := 3\r\n        \"W\" => idx := 4\r\n        \"M\" => idx := 5\r\n    idx\r\n\r\n// Update all levels\r\nif array.size(srLevels) > 0\r\n    int extensionTime = time + (currentBarDuration * 5)\r\n    \r\n    // Count levels per timeframe for limiting\r\n    var array<int> tfCounts = array.new<int>(6, 0)  // 15m, 1h, 4h, D, W, M\r\n    \r\n    // Reset counts\r\n    for i = 0 to 5\r\n        array.set(tfCounts, i, 0)\r\n    \r\n    // First pass: check mitigation, breakout, retest and count\r\n    for i = array.size(srLevels) - 1 to 0\r\n        level = array.get(srLevels, i)\r\n        float htfClose = getHTFClose(level.timeframe)\r\n        int htfCurrentTime = getHTFCurrentTime(level.timeframe)\r\n        int htfBarDuration = getHTFBarDuration(level.timeframe)\r\n        \r\n        // Check if this is a current TF level (for alerts)\r\n        bool isCurrentTFLevel = level.timeframe == currentTFString\r\n        \r\n        if not level.isMitigated and not na(htfClose) and not na(htfCurrentTime)\r\n            // Check mitigation only after first candle\r\n            if htfCurrentTime >= level.mitigationAllowedTime\r\n                if level.isBreach(htfClose)\r\n                    level.markMitigated(htfCurrentTime, htfBarDuration)\r\n                    \r\n                    // Check breakout alerts only for current TF levels\r\n                    if isCurrentTFLevel\r\n                        [isSignificant, isCoherent] = checkSignificantBreakout(level.price, level.isResistance, open, close, high, low)\r\n                        \r\n                        if isCoherent\r\n                            if level.isResistance\r\n                                breakoutResistance := true\r\n                            else\r\n                                breakoutSupport := true\r\n                            \r\n                            if isSignificant\r\n                                if level.isResistance\r\n                                    significantBreakoutResistance := true\r\n                                else\r\n                                    significantBreakoutSupport := true\r\n                else\r\n                    // Level not breached - check for retest (only for current TF levels)\r\n                    if isCurrentTFLevel and not na(currentTFATR) and currentTFATR > 0\r\n                        bool isRetest = checkRetest(level.price, level.isResistance, open, close, high, low, currentTFATR, open[1], low[1], high[1], close[1])\r\n                        \r\n                        if isRetest\r\n                            if level.isResistance\r\n                                retestResistance := true\r\n                            else\r\n                                retestSupport := true\r\n    \r\n    // Build sorted lists per TF (by distance to current price)\r\n    for i = 0 to array.size(srLevels) - 1\r\n        level = array.get(srLevels, i)\r\n        if not level.isMitigated\r\n            int tfIdx = getTFIndex(level.timeframe)\r\n            int currentCount = array.get(tfCounts, tfIdx)\r\n            array.set(tfCounts, tfIdx, currentCount + 1)\r\n    \r\n    // Second pass: update visuals and remove expired/excess\r\n    for i = array.size(srLevels) - 1 to 0\r\n        level = array.get(srLevels, i)\r\n        bool shouldRemove = false\r\n        \r\n        int htfCurrentTime = getHTFCurrentTime(level.timeframe)\r\n        int htfBarDuration = getHTFBarDuration(level.timeframe)\r\n        \r\n        if level.isMitigated\r\n            if showMitigated and not na(htfCurrentTime)\r\n                level.applyMitigatedVisual(extensionTime)\r\n                if level.hasExpired(htfCurrentTime)\r\n                    shouldRemove := true\r\n            else\r\n                shouldRemove := true\r\n        else\r\n            // Check if TF is enabled\r\n            [enabled, _, _] = getTFConfig(level.timeframe)\r\n            if not enabled\r\n                shouldRemove := true\r\n            else\r\n                level.applyActiveVisual(extensionTime)\r\n                if not na(htfCurrentTime) and level.hasExpired(htfCurrentTime)\r\n                    shouldRemove := true\r\n        \r\n        if shouldRemove\r\n            level.delete()\r\n            array.remove(srLevels, i)\r\n    \r\n    // Update right labels on last bar\r\n    if barstate.islast and showRightLabels\r\n        for i = 0 to array.size(srLevels) - 1\r\n            level = array.get(srLevels, i)\r\n            \r\n            bool isVisible = level.isMitigated ? showMitigated : true\r\n            if isVisible\r\n                string levelType = level.isResistance ? \"Resistance\" : \"Support\"\r\n                string statusStr = level.isMitigated ? \" ‚úó\" : \"\"\r\n                string tfLabel = getTFLabel(level.timeframe)\r\n                string labelText = \" \" + tfLabel + \" \" + levelType + statusStr + \" \"\r\n                \r\n                color textColor = level.isMitigated ? color.new(level.levelColor, mitigatedTransparency) : level.levelColor\r\n                \r\n                if not na(level.rightLabel)\r\n                    level.rightLabel.delete()\r\n                \r\n                if rightLabelSize == \"tiny\"\r\n                    level.rightLabel := label.new(bar_index + 3, level.price, labelText, xloc.bar_index, yloc.price, color.white, label.style_label_left, textColor, size.tiny)\r\n                else if rightLabelSize == \"small\"\r\n                    level.rightLabel := label.new(bar_index + 3, level.price, labelText, xloc.bar_index, yloc.price, color.white, label.style_label_left, textColor, size.small)\r\n                else if rightLabelSize == \"normal\"\r\n                    level.rightLabel := label.new(bar_index + 3, level.price, labelText, xloc.bar_index, yloc.price, color.white, label.style_label_left, textColor, size.normal)\r\n                else if rightLabelSize == \"large\"\r\n                    level.rightLabel := label.new(bar_index + 3, level.price, labelText, xloc.bar_index, yloc.price, color.white, label.style_label_left, textColor, size.large)\r\n                else\r\n                    level.rightLabel := label.new(bar_index + 3, level.price, labelText, xloc.bar_index, yloc.price, color.white, label.style_label_left, textColor, size.small)\r\n\r\n// ============================================================================\r\n// PRICE SCALE LABELS (trackprice)\r\n// ============================================================================\r\n\r\n// Get level price and color by index\r\ngetLevelPriceAndColor(int index, bool isMitigated) =>\r\n    float resultPrice = na\r\n    color resultColor = na\r\n    if showPriceScale and barstate.islast\r\n        int count = 0\r\n        if array.size(srLevels) > 0\r\n            for i = 0 to array.size(srLevels) - 1\r\n                level = array.get(srLevels, i)\r\n                if level.isMitigated == isMitigated and not na(level.levelLine)\r\n                    if count == index\r\n                        resultPrice := level.price\r\n                        resultColor := isMitigated ? color.new(level.levelColor, mitigatedTransparency) : level.levelColor\r\n                        break\r\n                    count += 1\r\n    [resultPrice, resultColor]\r\n\r\ngetLevelPrice(int index, bool isMitigated) =>\r\n    [price, _color] = getLevelPriceAndColor(index, isMitigated)\r\n    price\r\n\r\ngetLevelColor(int index, bool isMitigated) =>\r\n    [_price, col] = getLevelPriceAndColor(index, isMitigated)\r\n    col\r\n\r\n// Plot active levels on price scale (up to 15)\r\nplot(getLevelPrice(0, false), \"Active 1\", color=getLevelColor(0, false), style=plot.style_linebr, trackprice=true, display=display.price_scale)\r\nplot(getLevelPrice(1, false), \"Active 2\", color=getLevelColor(1, false), style=plot.style_linebr, trackprice=true, display=display.price_scale)\r\nplot(getLevelPrice(2, false), \"Active 3\", color=getLevelColor(2, false), style=plot.style_linebr, trackprice=true, display=display.price_scale)\r\nplot(getLevelPrice(3, false), \"Active 4\", color=getLevelColor(3, false), style=plot.style_linebr, trackprice=true, display=display.price_scale)\r\nplot(getLevelPrice(4, false), \"Active 5\", color=getLevelColor(4, false), style=plot.style_linebr, trackprice=true, display=display.price_scale)\r\nplot(getLevelPrice(5, false), \"Active 6\", color=getLevelColor(5, false), style=plot.style_linebr, trackprice=true, display=display.price_scale)\r\nplot(getLevelPrice(6, false), \"Active 7\", color=getLevelColor(6, false), style=plot.style_linebr, trackprice=true, display=display.price_scale)\r\nplot(getLevelPrice(7, false), \"Active 8\", color=getLevelColor(7, false), style=plot.style_linebr, trackprice=true, display=display.price_scale)\r\nplot(getLevelPrice(8, false), \"Active 9\", color=getLevelColor(8, false), style=plot.style_linebr, trackprice=true, display=display.price_scale)\r\nplot(getLevelPrice(9, false), \"Active 10\", color=getLevelColor(9, false), style=plot.style_linebr, trackprice=true, display=display.price_scale)\r\nplot(getLevelPrice(10, false), \"Active 11\", color=getLevelColor(10, false), style=plot.style_linebr, trackprice=true, display=display.price_scale)\r\nplot(getLevelPrice(11, false), \"Active 12\", color=getLevelColor(11, false), style=plot.style_linebr, trackprice=true, display=display.price_scale)\r\nplot(getLevelPrice(12, false), \"Active 13\", color=getLevelColor(12, false), style=plot.style_linebr, trackprice=true, display=display.price_scale)\r\nplot(getLevelPrice(13, false), \"Active 14\", color=getLevelColor(13, false), style=plot.style_linebr, trackprice=true, display=display.price_scale)\r\nplot(getLevelPrice(14, false), \"Active 15\", color=getLevelColor(14, false), style=plot.style_linebr, trackprice=true, display=display.price_scale)\r\n\r\n// Plot mitigated levels on price scale (up to 5)\r\nplot(getLevelPrice(0, true), \"Mitigated 1\", color=getLevelColor(0, true), style=plot.style_linebr, trackprice=true, display=display.price_scale)\r\nplot(getLevelPrice(1, true), \"Mitigated 2\", color=getLevelColor(1, true), style=plot.style_linebr, trackprice=true, display=display.price_scale)\r\nplot(getLevelPrice(2, true), \"Mitigated 3\", color=getLevelColor(2, true), style=plot.style_linebr, trackprice=true, display=display.price_scale)\r\nplot(getLevelPrice(3, true), \"Mitigated 4\", color=getLevelColor(3, true), style=plot.style_linebr, trackprice=true, display=display.price_scale)\r\nplot(getLevelPrice(4, true), \"Mitigated 5\", color=getLevelColor(4, true), style=plot.style_linebr, trackprice=true, display=display.price_scale)\r\n\r\n// ============================================================================\r\n// ALERT CONDITIONS (Current TF only)\r\n// ============================================================================\r\n\r\n// New Pivot Alerts (current TF only)\r\nbool newPivotCurrentTFR = (currentTFString == \"15\" and newPR15m) or (currentTFString == \"60\" and newPR1h) or (currentTFString == \"240\" and newPR4h) or (currentTFString == \"D\" and newPRD) or (currentTFString == \"W\" and newPRW) or (currentTFString == \"M\" and newPRM)\r\nbool newPivotCurrentTFS = (currentTFString == \"15\" and newPS15m) or (currentTFString == \"60\" and newPS1h) or (currentTFString == \"240\" and newPS4h) or (currentTFString == \"D\" and newPSD) or (currentTFString == \"W\" and newPSW) or (currentTFString == \"M\" and newPSM)\r\n\r\nalertcondition(newPivotCurrentTFR or newPivotCurrentTFS, title=\"New Pivot (current TF)\", message=\"New Pivot detected on current timeframe\")\r\nalertcondition(newPivotCurrentTFS, title=\"New Pivot Support (current TF)\", message=\"New Support Pivot detected on current timeframe\")\r\nalertcondition(newPivotCurrentTFR, title=\"New Pivot Resistance (current TF)\", message=\"New Resistance Pivot detected on current timeframe\")\r\n\r\n// Breakout Alerts (current TF only)\r\nalertcondition(breakoutResistance or breakoutSupport, title=\"Breakout (current TF)\", message=\"Breakout detected on current timeframe\")\r\nalertcondition(breakoutSupport, title=\"Breakout Support (current TF)\", message=\"Support Breakout detected on current timeframe\")\r\nalertcondition(breakoutResistance, title=\"Breakout Resistance (current TF)\", message=\"Resistance Breakout detected on current timeframe\")\r\n\r\n// Significant Breakout Alerts (current TF only)\r\nalertcondition(significantBreakoutResistance or significantBreakoutSupport, title=\"Significant Breakout (current TF)\", message=\"Significant Breakout detected on current timeframe\")\r\nalertcondition(significantBreakoutSupport, title=\"Significant Breakout Support (current TF)\", message=\"Significant Support Breakout detected on current timeframe\")\r\nalertcondition(significantBreakoutResistance, title=\"Significant Breakout Resistance (current TF)\", message=\"Significant Resistance Breakout detected on current timeframe\")\r\n\r\n// Retest Alerts (current TF only)\r\nalertcondition(retestResistance or retestSupport, title=\"Retest Level (current TF)\", message=\"Level Retest detected on current timeframe\")\r\nalertcondition(retestSupport, title=\"Retest Support (current TF)\", message=\"Support Retest detected - bullish bounce\")\r\nalertcondition(retestResistance, title=\"Retest Resistance (current TF)\", message=\"Resistance Retest detected - bearish rejection\")\r\n"
  },
  "https://www.tradingview.com/script/xv0Auyi4-3LL-Baby-3HH-Baby-Pattern/": {
    "id": 20090048,
    "url": "https://www.tradingview.com/script/xv0Auyi4-3LL-Baby-3HH-Baby-Pattern/",
    "name": "3LL+Baby & 3HH+Baby Pattern",
    "description": "3LL+Baby & 3HH+Baby Pattern Indicator \n\n Overview \n\nThis indicator identifies powerful reversal patterns based on momentum exhaustion and inside bar formations. It detects two specific candlestick patterns that signal potential trend reversals: the bullish 3LL+Baby and the bearish 3HH+Baby.\n\n Pattern Descriptions \n\n üìà 3LL+Baby Pattern (Bullish Reversal) \n\n Conditions: \n\nThree consecutive candles form lower lows (each low is lower than the previous)\nThe fourth candle is bullish/green (closes higher than it opens)\nThe fourth candle is completely contained within the third candle's range (both high and low)\n\n Interpretation:  After a downward momentum with three lower lows, a bullish inside bar (baby candle) suggests sellers are exhausted and buyers may be taking control. This pattern often precedes upward reversals.\n\n üìâ 3HH+Baby Pattern (Bearish Reversal) \n\n Conditions: \n\n \n \n Three consecutive candles form higher highs (each high is higher than the previous)\n \n \n The fourth candle is bearish/red (closes lower than it opens)\n \n \n The fourth candle is completely contained within the third candle's range (both high and low)\n\n Interpretation:  After upward momentum with three higher highs, a bearish inside bar indicates buyers are losing strength and sellers may be gaining control. This pattern often signals potential downward reversals.\n\n Features \n\n Visual Signals \n\nGreen Triangle (‚Üë): Appears below bars when 3LL+Baby pattern is detected\nRed Triangle (‚Üì): Appears above bars when 3HH+Baby pattern is detected\nLabels: Clear text labels identifying each pattern type\nBackground Highlighting: Subtle background colors (green for bullish, red for bearish)\n\n Customization Options \n\nToggle labels on/off\nToggle arrow signals on/off\nEnable/disable bullish patterns independently\nEnable/disable bearish patterns independently\n\n How to Use \n\n Add to Chart:  Apply the indicator to any timeframe and instrument\n Configure Settings:  Adjust visibility options based on your preference\n Set Alerts:  Create alerts for immediate pattern notifications\n\n Trading Strategy: \n\n 3LL+Baby : Consider long positions or closing shorts\n 3HH+Baby:  Consider short positions or closing longs\nAlways confirm with additional analysis and risk management\n\n\n\n Best Practices \n\nUse in conjunction with support/resistance levels\nCombine with volume analysis for confirmation\nWorks on all timeframes (higher timeframes generally more reliable)\nApply proper risk management and stop-loss orders\nConsider the broader market context and trend",
    "author_name": "JPRockzzz",
    "likes_count": 27,
    "comments_count": 0,
    "views_count": 0,
    "created_at": "2025-12-12T09:39:50+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "NSE:NIFTY",
      "full_name": "NSE:NIFTY",
      "short_name": "NIFTY",
      "exchange": "NSE",
      "type": "index",
      "logo_id": "indices/nifty-50",
      "currency_logo_id": "country/IN",
      "base_currency_logo_id": null,
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/indices/nifty-50.svg"
      ],
      "interval": "15",
      "direction": 0,
      "badge": {
        "label": "NSE:NIFTY",
        "url": "/symbols/NSE-NIFTY/"
      }
    },
    "created": "2025-12-12",
    "updated": "2025-12-12",
    "source": "//@version=5\nindicator(\"3LL+Baby & 3HH+Baby Pattern\", overlay=true, max_labels_count=500)\n\n// Input settings\nshowLabels = input.bool(true, \"Show Labels\")\nshowArrows = input.bool(true, \"Show Arrows\")\nshowBullish = input.bool(true, \"Show 3LL+Baby (Bullish)\")\nshowBearish = input.bool(true, \"Show 3HH+Baby (Bearish)\")\n\n// === 3LL+Baby Pattern (Bullish) ===\n// Check for three consecutive lower lows\ncandle1_low = low[3]\ncandle2_low = low[2]\ncandle3_low = low[1]\n\nthreeLowerLows = candle2_low < candle1_low and candle3_low < candle2_low\n\n// Check if 4th candle (current) is green/bullish\nfourthCandleGreen = close > open\n\n// Check if 4th candle is completely inside 3rd candle\nfourthInsideThirdLL = high <= high[1] and low >= low[1]\n\n// Complete 3LL+Baby pattern\nbullishPattern = threeLowerLows and fourthCandleGreen and fourthInsideThirdLL and showBullish\n\n// === 3HH+Baby Pattern (Bearish) ===\n// Check for three consecutive higher highs\ncandle1_high = high[3]\ncandle2_high = high[2]\ncandle3_high = high[1]\n\nthreeHigherHighs = candle2_high > candle1_high and candle3_high > candle2_high\n\n// Check if 4th candle (current) is red/bearish\nfourthCandleRed = close < open\n\n// Check if 4th candle is completely inside 3rd candle\nfourthInsideThirdHH = high <= high[1] and low >= low[1]\n\n// Complete 3HH+Baby pattern\nbearishPattern = threeHigherHighs and fourthCandleRed and fourthInsideThirdHH and showBearish\n\n// Plot bullish arrows\nplotshape(bullishPattern and showArrows, style=shape.triangleup, location=location.belowbar, color=color.new(color.green, 0), size=size.small,title=\"3LL+Baby Signal\")\n\n// Plot bearish arrows\nplotshape(bearishPattern and showArrows, style=shape.triangledown, location=location.abovebar, color=color.new(color.red, 0), size=size.small,title=\"3HH+Baby Signal\")\n\n// Add labels for bullish pattern\nif bullishPattern and showLabels\n    label.new(bar_index, low - (high - low) * 0.5, text=\"3LL+Baby\", style=label.style_label_up, color=color.new(color.green, 20), textcolor=color.white,size=size.small)\n\n// Add labels for bearish pattern\nif bearishPattern and showLabels\n    label.new(bar_index, high + (high - low) * 0.5, text=\"3HH+Baby\", style=label.style_label_down, color=color.new(color.red, 20), textcolor=color.white,size=size.small)\n\n// Background highlight\nbgcolor(bullishPattern ? color.new(color.green, 90) : na, title=\"Bullish Pattern Background\")\nbgcolor(bearishPattern ? color.new(color.red, 90) : na, title=\"Bearish Pattern Background\")\n\n// Alert conditions\nalertcondition(bullishPattern, title=\"3LL+Baby Pattern Detected\", message=\"3LL+Baby bullish pattern formed!\")\nalertcondition(bearishPattern, title=\"3HH+Baby Pattern Detected\", message=\"3HH+Baby bearish pattern formed!\")"
  },
  "https://www.tradingview.com/script/ZkZBYPrK/": {
    "id": 20085612,
    "url": "https://www.tradingview.com/script/ZkZBYPrK/",
    "name": "Trend Following $ZEC - Multi-Timeframe Structure Filter + Revers",
    "description": "# Trend Following  CRYPTOCAP:ZEC  - Strategy Guide\n\n## üìä Strategy Overview\n\nTrend Following  CRYPTOCAP:ZEC  is an enhanced Turtle Trading system designed for cryptocurrency spot trading, combining Donchian Channel breakouts, multi-timeframe structure filtering, and ATR-based dynamic risk management for both long and short positions.\n\n---\n\n## üéØ Core Features\n\n1. Multi-Timeframe Structure Filtering\n   - Uses Swing High/Low to identify market structure\n   - Customizable structure timeframe (default: 1 minute)\n   - Only enters trades in the direction of the trend, avoiding counter-trend positions\n\n2. Reverse Signal Exit\n   - No fixed stop-loss or fixed-period exits\n   - Exits only when a reverse entry signal triggers\n   - Maximizes trend profits, reduces premature exits\n\n3. ATR Dynamic Pyramiding\n   - Adds positions when price moves 0.5 ATR in favorable direction\n   - Supports up to 2 units maximum (adjustable)\n   - Pyramid scaling to enhance profitability\n\n4. Complete Risk Management\n   - Fixed position size (5000 USD per unit)\n   - Commission fee 0.06% (Binance spot rate)\n   - Initial capital 10,000 USD\n\n---\n\n## üìà Trading Logic\n\nEntry Conditions\n\n‚úÖ Long Entry: \n- Close price breaks above 20-period high\n- Structure trend is bullish (price breaks above Swing High)\n\n‚úÖ Short Entry: \n- Close price breaks below 20-period low\n- Structure trend is bearish (price breaks below Swing Low)\n\nAdd Position Conditions\n- Long: Price rises ‚â• 0.5 ATR\n- Short: Price falls ‚â• 0.5 ATR\n- Maximum 2 units including initial entry\n\nExit Conditions\n- Long Exit: When short entry signal triggers (price breaks 20-period low + structure turns bearish)\n- Short Exit: When long entry signal triggers (price breaks 20-period high + structure turns bullish)\n\n---\n\n## ‚öôÔ∏è Parameter Settings\n\nChannel Settings\n- Entry Channel Period: 20 (Donchian Channel breakout period)\n- Exit Channel Period: 10 (reserved parameter, actually uses reverse signal exit)\n\nATR Settings\n- ATR Period: 20\n- Stop Loss ATR Multiplier: 2.0 (reserved parameter)\n- Add Position ATR Multiplier: 0.5\n\nStructure Filter\n- Swing Length: 160 (Swing High/Low calculation period)\n- Structure Timeframe: 1 minute (can change to 5/15/60, etc.)\n\nPosition Management\n- Maximum Units: 2 (including initial entry)\n- Capital Per Unit: 5000 USD\n\n---\n\n## üé® Visualization Features\n\nBackground Colors\n- Light Green: Bullish structure\n- Light Red: Bearish structure\n- Dark Green: Long entry\n- Dark Red: Short entry\n\nOptional Display (Default: OFF)\n- Entry/exit channel lines\n- Structure high/low lines\n- ATR stop-loss line\n- Next add position indicator\n- Entry/exit labels\n\n---\n\n## üì± Alert Message Format\n\nStrategy sends notifications on entry/exit with the following format:\n\n- Entry: `1m Long EP:428.26`\n- Add Position: `15m Add Long 2/2 EP:429.50`\n- Exit: `1m Close Long Reverse Signal`\n\nWhere:\n- `1m`/`15m` = Current chart timeframe\n- `EP` = Entry Price\n\n---\n\n## üí∞ Backtest Settings\n\nCapital Allocation\n- Initial Capital: 10,000 USD\n- Per Entry: 5,000 USD (split into 2 entries)\n- Leverage: 0x (spot trading)\n\nTrading Costs\n- Commission: 0.06% (Binance spot VIP0)\n- Slippage: 0\n\n---\n\n## üéØ Use Cases\n\n‚úÖ Best Scenarios\n- Trending markets\n- Moderate volatility assets\n- 1-minute to 4-hour timeframes\n\n‚ö†Ô∏è Not Suitable For\n- Highly volatile choppy markets\n- Low liquidity small-cap coins\n- Extreme market conditions (black swan events)\n\n---\n\n## üìä Usage Recommendations\n\nTimeframe Suggestions\n\n| Timeframe | Trading Style | Suggested Parameter Adjustment |\n|-----------|--------------|-------------------------------|\n| 1-5 min | Scalping | Swing Length 100-160 |\n| 15-30 min | Short-term | Swing Length 50-100 |\n| 1-4 hour | Swing Trading | Swing Length 20-50 |\n\nOptimization Tips\n1. Adjust swing length based on backtest results\n2. Different coins may require different parameters\n3. Recommend backtesting on 1-minute chart first before live trading\n4. Enable labels to observe entry/exit points\n\n---\n\n## ‚ö†Ô∏è Risk Disclaimer\n\n1. Past Performance Does Not Guarantee Future Results\n   - Backtest data is for reference only\n   - Live trading may be affected by slippage, delays, etc.\n\n2. Market Condition Changes\n   - Strategy performs better in trending markets\n   - May experience frequent stops in ranging markets\n\n3. Capital Management\n   - Do not invest more than you can afford to lose\n   - Recommend setting total capital stop-loss threshold\n\n4. Commission Impact\n   - Frequent trading accumulates commission fees\n   - Recommend using exchange discounts (BNB fee reduction, etc.)\n\n---\n\n## üîß Troubleshooting\n\nQ: No entry signals?\nA: Check if structure filter is too strict, adjust swing length or timeframe\n\nQ: Too many labels displayed?\nA: Turn off \"Show Labels\" option in settings\n\nQ: Poor backtest performance?\nA: \n1. Check if the coin is suitable for trend-following strategies\n2. Adjust parameters (swing length, channel period)\n3. Try different timeframes\n\nQ: How to set alerts?\nA: \n1. Click \"Alert\" in top-right corner of chart\n2. Condition: Select \"Strategy - Trend Following  CRYPTOCAP:ZEC \"\n3. Choose \"Order filled\"\n4. Set notification method (Webhook/Email/App)\n\n---\n\n## üìû Contact Information\n\nStrategy Name: Trend Following  CRYPTOCAP:ZEC \nVersion: v1.0\nPine Script Version: v6\nLast Updated: December 2025\n\n---\n\n## üìÑ Copyright Notice\n\nThis strategy is for educational and research purposes only.\nAll risks of using this strategy for live trading are borne by the user.\nCommercial use without authorization is prohibited.\n\n---\n\n## üéì Learning Resources\n\nTo understand the strategy principles in depth, recommended reading:\n- \"The Complete TurtleTrader\" - Curtis Faith\n- \"Trend Following\" - Michael Covel\n- TradingView Pine Script Official Documentation\n\n---\n\nHappy Trading! Remember to manage your risk üìà",
    "author_name": "ssun_6",
    "likes_count": 16,
    "comments_count": 0,
    "views_count": 0,
    "created_at": "2025-12-11T14:55:56+00:00",
    "updated_at": "2025-12-12T14:21:12+00:00",
    "script_type": "strategy",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "BINANCE:ZECUSDT",
      "full_name": "BINANCE:ZECUSDT",
      "short_name": "ZECUSDT",
      "exchange": "BINANCE",
      "type": "spot",
      "logo_id": null,
      "currency_logo_id": "crypto/XTVCUSDT",
      "base_currency_logo_id": "crypto/XTVCZEC",
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/crypto/XTVCZEC.svg",
        "https://s3-symbol-logo.tradingview.com/crypto/XTVCUSDT.svg"
      ],
      "interval": "15",
      "direction": 0,
      "badge": {
        "label": "BINANCE:ZECUSDT",
        "url": "/symbols/ZECUSDT/"
      }
    },
    "created": "2025-12-12",
    "updated": "2025-12-12",
    "source": "//@version=6\r\nstrategy(\"Trend $ZEC/AXL\", shorttitle=\"$ZEC/AXL 1/15m\", overlay=true, \r\n         initial_capital=10000, \r\n         default_qty_type=strategy.cash, \r\n         default_qty_value=5000, \r\n         commission_type=strategy.commission.percent, \r\n         commission_value=0.06,\r\n         slippage=0,\r\n         max_lines_count=500,\r\n         max_labels_count=500)\r\n\r\n// ========== ÂèÉÊï∏Ë®≠ÂÆö ==========\r\n// ÂîêÂ•áÂÆâÈÄöÈÅìÂèÉÊï∏\r\nentry_period = input.int(20, \"ÈÄ≤Â†¥ÈÄöÈÅìÈÄ±Êúü\", minval=1, group=\"ÈÄöÈÅìË®≠ÂÆö\")\r\nexit_period = input.int(10, \"Âá∫Â†¥ÈÄöÈÅìÈÄ±Êúü\", minval=1, group=\"ÈÄöÈÅìË®≠ÂÆö\")\r\n\r\n// ATR ÂèÉÊï∏\r\natr_period = input.int(20, \"ATR ÈÄ±Êúü\", minval=1, group=\"ATR Ë®≠ÂÆö\")\r\natr_stop_mult = input.float(2.0, \"Ê≠¢Êêç ATR ÂÄçÊï∏\", minval=0.1, step=0.1, group=\"ATR Ë®≠ÂÆö\")\r\natr_add_mult = input.float(0.5, \"Âä†ÂÄâ ATR ÂÄçÊï∏\", minval=0.1, step=0.1, group=\"ATR Ë®≠ÂÆö\")\r\n\r\n// Â§öÁ©∫ÁµêÊßãÂèÉÊï∏ - Âä†ÂÖ•Â§öÊôÇÈñìÊ°ÜÊû∂\r\nswing_length = input.int(160, \"ÁµêÊßãÊì∫ÂãïÈï∑Â∫¶\", minval=1, group=\"üìä Â§öÁ©∫ÁµêÊßãÈÅéÊøæ\")\r\nstructure_timeframe = input.timeframe(\"1\", \"ÁµêÊßãÊôÇÈñìÊ°ÜÊû∂\", group=\"üìä Â§öÁ©∫ÁµêÊßãÈÅéÊøæ\", tooltip=\"ÈÅ∏ÊìáÁµêÊßãÂà§Êñ∑ÁöÑÊôÇÈñìÈÄ±Êúü,Á©∫ÁôΩ=Áï∂ÂâçÂúñË°®,D=Êó•Á∑ö,W=ÈÄ±Á∑ö\")\r\nshow_structure_lines = input.bool(false, \"È°ØÁ§∫ÁµêÊßãÁ∑ö\", group=\"üìä Â§öÁ©∫ÁµêÊßãÈÅéÊøæ\")\r\nshow_structure_labels = input.bool(false, \"È°ØÁ§∫ÁµêÊßãÊ®ôÁ±§\", group=\"üìä Â§öÁ©∫ÁµêÊßãÈÅéÊøæ\")\r\n\r\n// Âä†ÂÄâË®≠ÂÆö\r\nmax_units = input.int(2, \"ÊúÄÂ§ßÂñÆ‰ΩçÊï∏(Âê´È¶ñÊ¨°)\", minval=1, maxval=10, group=\"ÂÄâ‰ΩçÁÆ°ÁêÜ\")\r\nposition_size = input.int(5000, \"ÊØèÂñÆ‰ΩçË≥áÈáë(USD)\", minval=100, group=\"ÂÄâ‰ΩçÁÆ°ÁêÜ\", tooltip=\"10000UÊú¨ÈáëÂàÜ2Ê¨°ÈÄ≤Â†¥ÔºåÊØèÊ¨°5000U\")\r\n\r\n// È°ØÁ§∫Ë®≠ÂÆö\r\nshow_channels = input.bool(false, \"È°ØÁ§∫ÈÄöÈÅì\", group=\"È°ØÁ§∫Ë®≠ÂÆö\")\r\nshow_atr_lines = input.bool(false, \"È°ØÁ§∫ ATR Á∑ö\", group=\"È°ØÁ§∫Ë®≠ÂÆö\")\r\nshow_labels = input.bool(true, \"È°ØÁ§∫Ê®ôÁ±§\", group=\"È°ØÁ§∫Ë®≠ÂÆö\")\r\nshow_table = input.bool(false, \"È°ØÁ§∫Ë≥áË®äÈù¢Êùø\", group=\"È°ØÁ§∫Ë®≠ÂÆö\")\r\nlabel_distance = input.float(2.5, \"Ê®ôÁ±§Ë∑ùÈõ¢ K Ê£íÂÄçÊï∏\", minval=0.1, step=0.1, group=\"È°ØÁ§∫Ë®≠ÂÆö\", tooltip=\"Ê®ôÁ±§Ë∑ùÈõ¢KÊ£íÁöÑATRÂÄçÊï∏\")\r\nshow_label_lines = input.bool(false, \"È°ØÁ§∫Ê®ôÁ±§ÈÄ£Á∑ö\", group=\"È°ØÁ§∫Ë®≠ÂÆö\")\r\n\r\n// ========== Ë®àÁÆóÂîêÂ•áÂÆâÈÄöÈÅì ==========\r\nentry_upper = ta.highest(high, entry_period)\r\nentry_lower = ta.lowest(low, entry_period)\r\nexit_upper = ta.highest(high, exit_period)\r\nexit_lower = ta.lowest(low, exit_period)\r\n\r\n// ========== Ë®àÁÆó ATR (NÂÄº) ==========\r\nN = ta.atr(atr_period)\r\n\r\n// ========== Â§öÊôÇÈñìÊ°ÜÊû∂Â§öÁ©∫ÁµêÊßãÂà§Êñ∑ ==========\r\n// Ë®àÁÆóÁµêÊßãÁöÑÂáΩÊï∏\r\nf_calculate_structure() =>\r\n    var int trend = 0\r\n    var float lastHigh = na\r\n    var float lastLow = na\r\n    \r\n    swingHigh = ta.pivothigh(high, swing_length, swing_length)\r\n    swingLow = ta.pivotlow(low, swing_length, swing_length)\r\n    \r\n    if not na(swingHigh)\r\n        lastHigh := swingHigh\r\n    \r\n    if not na(swingLow)\r\n        lastLow := swingLow\r\n    \r\n    if not na(lastHigh) and close > lastHigh and trend != 1\r\n        trend := 1\r\n    \r\n    if not na(lastLow) and close < lastLow and trend != -1\r\n        trend := -1\r\n    \r\n    [trend, lastHigh, lastLow]\r\n\r\n// Áç≤ÂèñÊåáÂÆöÊôÇÈñìÊ°ÜÊû∂ÁöÑÁµêÊßã\r\n[structure_trend_mtf, last_structure_high_mtf, last_structure_low_mtf] = request.security(syminfo.tickerid, structure_timeframe, f_calculate_structure(), lookahead=barmerge.lookahead_off)\r\n\r\n// ‰ΩøÁî®Â§öÊôÇÈñìÊ°ÜÊû∂ÁöÑÁµêÊßãË∂®Âã¢\r\nstructure_trend = structure_trend_mtf\r\nlast_structure_high = last_structure_high_mtf\r\nlast_structure_low = last_structure_low_mtf\r\n\r\n// Ê™¢Ê∏¨ÁµêÊßãËÆäÂåñÔºàÁî®ÊñºÁπ™Ë£ΩÊ®ôÁ±§Ôºâ\r\nvar int prev_structure_trend = 0\r\nbool bull_break = structure_trend == 1 and prev_structure_trend != 1\r\nbool bear_break = structure_trend == -1 and prev_structure_trend != -1\r\nprev_structure_trend := structure_trend\r\n\r\n// Áπ™Ë£ΩÁµêÊßãÁ™ÅÁ†¥Ê®ôÁ±§\r\nif show_structure_labels\r\n    if bull_break\r\n        label.new(bar_index, low, \"Â§öÊñπÁµêÊßã\", style=label.style_label_up, color=color.new(color.green, 0), textcolor=color.white, size=size.small)\r\n    \r\n    if bear_break\r\n        label.new(bar_index, high, \"Á©∫ÊñπÁµêÊßã\", style=label.style_label_down, color=color.new(color.red, 0), textcolor=color.white, size=size.small)\r\n\r\n// ========== ÊåÅÂÄâÁãÄÊÖãËøΩËπ§ ==========\r\nvar float entry_price = na\r\nvar float[] add_prices = array.new_float(0)\r\nvar int position = 0\r\nvar int units = 0\r\nvar float stop_loss = na\r\n\r\n// ========== ÈÄ≤Â†¥Ë®äËôü (Âä†ÂÖ•ÁµêÊßãÈÅéÊøæ) ==========\r\nlong_entry_signal = close > entry_upper[1] and structure_trend == 1\r\nshort_entry_signal = close < entry_lower[1] and structure_trend == -1\r\n\r\nlong_entry = long_entry_signal and position != 1\r\nshort_entry = short_entry_signal and position != -1\r\n\r\n// ========== Âä†ÂÄâË®äËôü ==========\r\nlong_add = false\r\nshort_add = false\r\n\r\nif position == 1 and units < max_units\r\n    if array.size(add_prices) > 0\r\n        last_add_price = array.get(add_prices, array.size(add_prices) - 1)\r\n        long_add := close >= last_add_price + (atr_add_mult * N)\r\n    else\r\n        long_add := close >= entry_price + (atr_add_mult * N)\r\n\r\nif position == -1 and units < max_units\r\n    if array.size(add_prices) > 0\r\n        last_add_price = array.get(add_prices, array.size(add_prices) - 1)\r\n        short_add := close <= last_add_price - (atr_add_mult * N)\r\n    else\r\n        short_add := close <= entry_price - (atr_add_mult * N)\r\n\r\n// ========== Âá∫Â†¥Ë®äËôü (ÊîπÁÇ∫ÂèçÂêëË®äËôüÂá∫Â†¥) ==========\r\n// Â§öÂñÆÂá∫Â†¥ÔºöÁï∂Á©∫ÂñÆÈÄ≤Â†¥Ë®äËôüËß∏ÁôºÊôÇ\r\nlong_exit = (position == 1) and short_entry_signal\r\n\r\n// Á©∫ÂñÆÂá∫Â†¥ÔºöÁï∂Â§öÂñÆÈÄ≤Â†¥Ë®äËôüËß∏ÁôºÊôÇ\r\nshort_exit = (position == -1) and long_entry_signal\r\n\r\n// ========== Êõ¥Êñ∞ÊåÅÂÄâÁãÄÊÖã ==========\r\nif long_entry\r\n    position := 1\r\n    units := 1\r\n    entry_price := close\r\n    array.clear(add_prices)\r\n    array.push(add_prices, close)\r\n    stop_loss := close - (atr_stop_mult * N)\r\n    alert_msg = timeframe.period + \" ÂÅöÂ§ö EP:\" + str.tostring(close, \"#.##\")\r\n    strategy.entry(\"Â§öÂñÆ1\", strategy.long, qty=position_size/close, comment=alert_msg, alert_message=alert_msg)\r\n    \r\nelse if short_entry\r\n    position := -1\r\n    units := 1\r\n    entry_price := close\r\n    array.clear(add_prices)\r\n    array.push(add_prices, close)\r\n    stop_loss := close + (atr_stop_mult * N)\r\n    alert_msg = timeframe.period + \" ÂÅöÁ©∫ EP:\" + str.tostring(close, \"#.##\")\r\n    strategy.entry(\"Á©∫ÂñÆ1\", strategy.short, qty=position_size/close, comment=alert_msg, alert_message=alert_msg)\r\n    \r\nelse if long_add\r\n    units := units + 1\r\n    array.push(add_prices, close)\r\n    stop_loss := close - (atr_stop_mult * N)\r\n    alert_msg = timeframe.period + \" Âä†ÂÄâÂ§ö \" + str.tostring(units) + \"/\" + str.tostring(max_units) + \" EP:\" + str.tostring(close, \"#.##\")\r\n    strategy.entry(\"Â§öÂñÆ\" + str.tostring(units), strategy.long, qty=position_size/close, comment=alert_msg, alert_message=alert_msg)\r\n    \r\nelse if short_add\r\n    units := units + 1\r\n    array.push(add_prices, close)\r\n    stop_loss := close + (atr_stop_mult * N)\r\n    alert_msg = timeframe.period + \" Âä†ÂÄâÁ©∫ \" + str.tostring(units) + \"/\" + str.tostring(max_units) + \" EP:\" + str.tostring(close, \"#.##\")\r\n    strategy.entry(\"Á©∫ÂñÆ\" + str.tostring(units), strategy.short, qty=position_size/close, comment=alert_msg, alert_message=alert_msg)\r\n    \r\nelse if long_exit or short_exit\r\n    if long_exit\r\n        alert_msg = timeframe.period + \" Âπ≥Â§ö ÂèçÂêëË®äËôü\"\r\n        strategy.close_all(comment=alert_msg, alert_message=alert_msg)\r\n    if short_exit\r\n        alert_msg = timeframe.period + \" Âπ≥Á©∫ ÂèçÂêëË®äËôü\"\r\n        strategy.close_all(comment=alert_msg, alert_message=alert_msg)\r\n    \r\n    position := 0\r\n    units := 0\r\n    entry_price := na\r\n    array.clear(add_prices)\r\n    stop_loss := na\r\n\r\n// ========== Áπ™Ë£ΩÈÄöÈÅì ==========\r\nplot(show_channels ? entry_upper : na, \"ÈÄ≤Â†¥‰∏äËªå\", color=color.new(color.red, 0), linewidth=2)\r\nplot(show_channels ? entry_lower : na, \"ÈÄ≤Â†¥‰∏ãËªå\", color=color.new(color.green, 0), linewidth=2)\r\nplot(show_channels ? exit_upper : na, \"Âá∫Â†¥‰∏äËªå\", color=color.new(color.orange, 50), linewidth=1, style=plot.style_circles)\r\nplot(show_channels ? exit_lower : na, \"Âá∫Â†¥‰∏ãËªå\", color=color.new(color.blue, 50), linewidth=1, style=plot.style_circles)\r\n\r\n// Áπ™Ë£ΩÁµêÊßãÈ´ò‰ΩéÈªû\r\nplot(show_structure_lines ? last_structure_high : na, \"ÁµêÊßãÈ´òÈªû\", color=color.new(color.red, 85), linewidth=2, style=plot.style_stepline)\r\nplot(show_structure_lines ? last_structure_low : na, \"ÁµêÊßã‰ΩéÈªû\", color=color.new(color.green, 85), linewidth=2, style=plot.style_stepline)\r\n\r\n// ========== Áπ™Ë£Ω ATR Á∑ö ==========\r\nplot(show_atr_lines and position != 0 ? stop_loss : na, \"Ê≠¢ÊêçÁ∑ö\", color=color.new(color.red, 0), linewidth=2, style=plot.style_cross)\r\n\r\nvar float next_add_long = na\r\nif position == 1 and units < max_units\r\n    next_add_long := array.size(add_prices) > 0 ? array.get(add_prices, array.size(add_prices) - 1) + (atr_add_mult * N) : entry_price + (atr_add_mult * N)\r\nelse\r\n    next_add_long := na\r\n\r\nplot(show_atr_lines and position == 1 and units < max_units ? next_add_long : na, \"‰∏ãÊ¨°Âä†ÂÄâ(Â§ö)\", color=color.new(color.yellow, 30), linewidth=1, style=plot.style_stepline)\r\n\r\nvar float next_add_short = na\r\nif position == -1 and units < max_units\r\n    next_add_short := array.size(add_prices) > 0 ? array.get(add_prices, array.size(add_prices) - 1) - (atr_add_mult * N) : entry_price - (atr_add_mult * N)\r\nelse\r\n    next_add_short := na\r\n\r\nplot(show_atr_lines and position == -1 and units < max_units ? next_add_short : na, \"‰∏ãÊ¨°Âä†ÂÄâ(Á©∫)\", color=color.new(color.yellow, 30), linewidth=1, style=plot.style_stepline)\r\n\r\n// ========== Áπ™Ë£ΩË®äËôüÊ®ôÁ±§ ==========\r\nif show_labels\r\n    label_offset = N * label_distance\r\n    long_label_style = show_label_lines ? label.style_label_up : label.style_none\r\n    short_label_style = show_label_lines ? label.style_label_down : label.style_none\r\n    \r\n    if long_entry\r\n        label.new(bar_index, low - label_offset, \"ÂÅöÂ§öZEC\\nÂñÆ‰Ωç1/\" + str.tostring(max_units), color=color.new(color.green, 0), style=long_label_style, textcolor=color.white, size=size.normal, textalign=text.align_center)\r\n    \r\n    if short_entry\r\n        label.new(bar_index, high + label_offset, \"ÂÅöÁ©∫ZEC\\nÂñÆ‰Ωç1/\" + str.tostring(max_units), color=color.new(color.red, 0), style=short_label_style, textcolor=color.white, size=size.normal, textalign=text.align_center)\r\n    \r\n    if long_add\r\n        label.new(bar_index, low - label_offset, \"Âä†ÂÄâÂ§öÂñÆZEC\\nÂñÆ‰Ωç\" + str.tostring(units) + \"/\" + str.tostring(max_units), color=color.new(color.lime, 0), style=long_label_style, textcolor=color.black, size=size.small, textalign=text.align_center)\r\n    \r\n    if short_add\r\n        label.new(bar_index, high + label_offset, \"Âä†ÂÄâÁ©∫ÂñÆZEC\\nÂñÆ‰Ωç\" + str.tostring(units) + \"/\" + str.tostring(max_units), color=color.new(color.maroon, 0), style=short_label_style, textcolor=color.white, size=size.small, textalign=text.align_center)\r\n    \r\n    if long_exit\r\n        label.new(bar_index, low - label_offset, \"Âπ≥Â§öZEC\\nÂèçÂêëË®äËôü\", color=color.new(color.orange, 0), style=long_label_style, textcolor=color.white, size=size.normal, textalign=text.align_center)\r\n    \r\n    if short_exit\r\n        label.new(bar_index, high + label_offset, \"Âπ≥Á©∫ZEC\\nÂèçÂêëË®äËôü\", color=color.new(color.blue, 0), style=short_label_style, textcolor=color.white, size=size.normal, textalign=text.align_center)\r\n\r\n// ========== ËÉåÊôØÈ°èËâ≤ ==========\r\nbgcolor(structure_trend == 1 ? color.new(color.green, 70) : structure_trend == -1 ? color.new(color.red, 70) : na, title=\"ÁµêÊßãË∂®Âã¢\")\r\nbgcolor(long_entry ? color.new(color.green, 85) : na, title=\"Â§öÂñÆÈÄ≤Â†¥\")\r\nbgcolor(short_entry ? color.new(color.red, 85) : na, title=\"Á©∫ÂñÆÈÄ≤Â†¥\")\r\nbgcolor(long_add ? color.new(color.lime, 90) : na, title=\"Â§öÂñÆÂä†ÂÄâ\")\r\nbgcolor(short_add ? color.new(color.maroon, 90) : na, title=\"Á©∫ÂñÆÂä†ÂÄâ\")"
  },
  "https://www.tradingview.com/script/RsPtnKaQ/": {
    "id": 20086913,
    "url": "https://www.tradingview.com/script/RsPtnKaQ/",
    "name": "Kernel Envelope",
    "description": "Kernel Envelope is a non-repainting dynamic band system designed to identify price overextension, trend exhaustion, volatility expansion, and high-probability reversal points.\nUsing a kernel-based smoothing technique, the indicator builds adaptive upper and lower envelopes that respond fluidly to market structure while maintaining exceptional stability for systematic trading.\n\nThese envelopes form the core of the system and allow traders to:\n\nDetect bullish rebounds from the lower band\n\nDetect bearish rejections from the upper band\n\nFilter trend-following entries using volatility context\n\nIdentify zones where price is statistically stretched\n\nHighlight exhaustion points during impulsive moves\n\nThe indicator also includes an integrated pivot-based trendline engine, which draws dynamic support and resistance levels derived from structural highs and lows.\nThese lines auto-extend forward and include breakout alerts, making them ideal for breakout traders, liquidity hunters, and structure-based strategies.\n\nKey Features\n\nFully non-repainting envelope calculation\n\nAdaptive smoothing responsive to market volatility\n\nClean gold/silver visual theme for maximum clarity\n\nGlow-style rendering for enhanced band visibility\n\nAutomatic trendline generation using pivot points\n\nBreakout alerts for upper and lower trendlines\n\nRebound and rejection alerts on envelope interaction\n\nWorks on all markets and timeframes\n\nWhether you trade reversals, breakouts, or trend continuation setups, Kernel Envelope provides a reliable, low-noise framework for identifying high-quality trade signals.\n\nAcknowledgment\n\nThis indicator is inspired by the original Nadaraya-Watson Envelope by LuxAlgo, whose work served as the foundation for further research and development.\n\nFollow Me on X\n\nFor more indicators, updates, automated strategies, and educational content, you can follow me here:\nX (Twitter): x.com\n",
    "author_name": "LionLabs",
    "likes_count": 15,
    "comments_count": 0,
    "views_count": 0,
    "created_at": "2025-12-11T19:32:34+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "BINGX:CAKEUSDT.P",
      "full_name": "BINGX:CAKEUSDT.P",
      "short_name": "CAKEUSDT.P",
      "exchange": "BINGX",
      "type": "swap",
      "logo_id": null,
      "currency_logo_id": "crypto/XTVCUSDT",
      "base_currency_logo_id": "crypto/XTVCCAKE",
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/crypto/XTVCCAKE.svg",
        "https://s3-symbol-logo.tradingview.com/crypto/XTVCUSDT.svg"
      ],
      "interval": "1",
      "direction": 0,
      "badge": {
        "label": "BINGX:CAKEUSDT.P",
        "url": "/symbols/CAKEUSDT.P/"
      }
    },
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=6\r\nindicator(\r\n    title           = \"Kernel Envelope\",\r\n    shorttitle      = \"Kernel Envelope\",\r\n    overlay         = true,\r\n    max_lines_count = 500,\r\n    max_labels_count = 500,\r\n    max_bars_back   = 500,\r\n    precision       = 6\r\n)\r\n\r\n//------------------------------------------------------------------------------\r\n// Ajustes principales\r\n//------------------------------------------------------------------------------\r\nfloat kernelWidth    = input.float(8.0,  \"Kernel Width\",         minval = 0.0, group = \"Settings\")\r\nfloat bandMultiplier = input.float(2.0,  \"Deviation Multiplier\", minval = 0.0, group = \"Settings\")\r\nfloat basisSource    = input.source(close, \"Source\",             group = \"Settings\")\r\n\r\n// Colores oro/plata\r\ncolor bullColor = input.color(color.new(#C0C0C0, 0), \"Bullish Color (Silver)\", group = \"Style\")\r\ncolor bearColor = input.color(color.new(#FFD700, 0), \"Bearish Color (Gold)\",   group = \"Style\")\r\ncolor bandFill  = input.color(color.new(color.gray, 85), \"Band Fill Color\", group = \"Style\")\r\n\r\nint maxWindow = 499\r\n\r\n//------------------------------------------------------------------------------\r\n// Funciones internas\r\n//------------------------------------------------------------------------------\r\ngauss(float x, float h) =>\r\n    math.exp(-(math.pow(x, 2) / (2 * h * h)))\r\n\r\n//------------------------------------------------------------------------------\r\n// Preparar pesos una sola vez\r\n//------------------------------------------------------------------------------\r\nvar float[] kernelWeights = array.new_float(0)\r\nvar bool    weightsReady  = false\r\n\r\nif barstate.isfirst\r\n    for i = 0 to maxWindow\r\n        array.push(kernelWeights, gauss(i, kernelWidth))\r\n    weightsReady := true\r\n\r\n//------------------------------------------------------------------------------\r\n// Suavizado tipo kernel (no repaint)\r\n//------------------------------------------------------------------------------\r\nfloat smooth = na\r\n\r\nif weightsReady\r\n    float num = 0.0\r\n    float den = 0.0\r\n    int limit = math.min(maxWindow, bar_index)\r\n\r\n    for i = 0 to limit\r\n        float w = array.get(kernelWeights, i)\r\n        num += basisSource[i] * w\r\n        den += w\r\n\r\n    smooth := den != 0 ? num / den : na\r\n\r\n//------------------------------------------------------------------------------\r\n// Bandas\r\n//------------------------------------------------------------------------------\r\nfloat avgAbsDev = ta.sma(math.abs(basisSource - smooth), maxWindow) * bandMultiplier\r\n\r\nfloat bandHigh = smooth + avgAbsDev\r\nfloat bandLow  = smooth - avgAbsDev\r\n\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n// Bandas con efecto Glow\r\n//------------------------------------------------------------------------------\r\nplot(bandHigh, \"Upper Halo\", color=color.new(bearColor,70), linewidth=6)\r\nplot(bandLow,  \"Lower Halo\", color=color.new(bullColor,70), linewidth=6)\r\n\r\npHigh = plot(bandHigh, \"Upper Band\", color=bearColor, linewidth=2)\r\npLow  = plot(bandLow,  \"Lower Band\", color=bullColor, linewidth=2)\r\n\r\nfill(pHigh, pLow, color=bandFill)\r\n\r\n//------------------------------------------------------------------------------\r\n// Se√±ales (esferas peque√±as)\r\n//------------------------------------------------------------------------------\r\nbool longSignal  = ta.crossunder(close, bandLow)\r\nbool shortSignal = ta.crossover(close,  bandHigh)\r\n\r\nplotshape(\r\n     longSignal ? low : na,\r\n     title = \"Long Signal\",\r\n     style = shape.circle,\r\n     location = location.belowbar,\r\n     size = size.tiny,\r\n     color = bullColor\r\n)\r\n\r\nplotshape(\r\n     shortSignal ? high : na,\r\n     title = \"Short Signal\",\r\n     style = shape.circle,\r\n     location = location.abovebar,\r\n     size = size.tiny,\r\n     color = bearColor\r\n)\r\n\r\n//------------------------------------------------------------------------------\r\n// Alertas principales\r\n//------------------------------------------------------------------------------\r\nalertcondition(\r\n    longSignal,\r\n    title   = \"Kernel Envelope - Bullish Rebound\",\r\n    message = \"Kernel Envelope - Bullish Rebound\"\r\n)\r\n\r\nalertcondition(\r\n    shortSignal,\r\n    title   = \"Kernel Envelope - Bearish Rejection\",\r\n    message = \"Kernel Envelope - Bearish Rejection\"\r\n)\r\n\r\n// ============================================================================\r\n//                     TRENDLINES BASADAS EN PIVOTS (No Repaint)\r\n// ============================================================================\r\n\r\npivotLen = input.int(10, \"Pivot Length\", group=\"Trendlines\")\r\nleftBars = pivotLen\r\nrightBars = pivotLen\r\nonlyLastLine = input.bool(true, \"Only show last trendline\", group=\"Trendlines\")\r\n\r\ntype pivotPoint\r\n    int barIndex\r\n    float price\r\n\r\nvar pivotPoint[] highPivots = array.new<pivotPoint>()\r\nvar pivotPoint[] lowPivots  = array.new<pivotPoint>()\r\n\r\n// Pivot High\r\nfloat ph = ta.pivothigh(leftBars, rightBars)\r\nif not na(ph)\r\n    array.push(highPivots, pivotPoint.new(bar_index - rightBars, ph))\r\n\r\n// Pivot Low\r\nfloat pl = ta.pivotlow(leftBars, rightBars)\r\nif not na(pl)\r\n    array.push(lowPivots, pivotPoint.new(bar_index - rightBars, pl))\r\n\r\n// ---------------- L√çNEA DE M√ÅXIMOS ----------------\r\nvar line lineHigh = na\r\n\r\nif array.size(highPivots) > 1\r\n    pivotPoint a = array.get(highPivots, array.size(highPivots) - 2)\r\n    pivotPoint b = array.get(highPivots, array.size(highPivots) - 1)\r\n\r\n    if a.barIndex != b.barIndex\r\n        if onlyLastLine and not na(lineHigh)\r\n            line.delete(lineHigh)\r\n\r\n        lineHigh := line.new(\r\n            a.barIndex, a.price,\r\n            b.barIndex, b.price,\r\n            extend = extend.right,\r\n            color  = color.new(bearColor, 40)\r\n        )\r\n\r\n// ---------------- L√çNEA DE M√çNIMOS ----------------\r\nvar line lineLow = na\r\n\r\nif array.size(lowPivots) > 1\r\n    pivotPoint c = array.get(lowPivots, array.size(lowPivots) - 2)\r\n    pivotPoint d = array.get(lowPivots, array.size(lowPivots) - 1)\r\n\r\n    if c.barIndex != d.barIndex\r\n        if onlyLastLine and not na(lineLow)\r\n            line.delete(lineLow)\r\n\r\n        lineLow := line.new(\r\n            c.barIndex, c.price,\r\n            d.barIndex, d.price,\r\n            extend = extend.right,\r\n            color  = color.new(bullColor, 40)\r\n        )\r\n\r\n// ============================================================================\r\n//                            ALERTAS DE RUPTURA\r\n// ============================================================================\r\n\r\nlineValueAt(line ln, int idx) =>\r\n    if na(ln)\r\n        na\r\n    else\r\n        float x1 = line.get_x1(ln)\r\n        float y1 = line.get_y1(ln)\r\n        float x2 = line.get_x2(ln)\r\n        float y2 = line.get_y2(ln)\r\n        x2 != x1 ? y1 + (idx - x1) * (y2 - y1) / (x2 - x1) : na\r\n\r\nhighTL = lineValueAt(lineHigh, bar_index)\r\nlowTL  = lineValueAt(lineLow,  bar_index)\r\nhighTLPrev = highTL[1]\r\nlowTLPrev  = lowTL[1]\r\n\r\nbreakHigh = not na(highTL) and not na(highTLPrev) and close > highTL and close[1] <= highTLPrev\r\nbreakLow  = not na(lowTL)  and not na(lowTLPrev)  and close < lowTL  and close[1] >= lowTLPrev\r\n\r\nalertcondition(\r\n    breakHigh,\r\n    title   = \"Kernel Envelope - Trendline Break (High)\",\r\n    message = \"Kernel Envelope - Trendline Break (High)\"\r\n)\r\n\r\nalertcondition(\r\n    breakLow,\r\n    title   = \"Kernel Envelope - Trendline Break (Low)\",\r\n    message = \"Kernel Envelope - Trendline Break (Low)\"\r\n)\r\n"
  },
  "https://www.tradingview.com/script/ZWOqYiQq-ORB-Strategy-Extensions-Custom-SL-EOD-Live-Lines/": {
    "id": 20087106,
    "url": "https://www.tradingview.com/script/ZWOqYiQq-ORB-Strategy-Extensions-Custom-SL-EOD-Live-Lines/",
    "name": "ORB Strategy: Extensions & Custom SL (EOD & Live Lines)",
    "description": "That's a great request. Since you've now built a complex Pine Script Strategy with several user-configurable risk management, targeting, and exit options, the description should focus on the systematic rules used for entering, managing, and exiting trades.\n\nHere is a clear, written description of the trading strategy you have built:\n\nTrading Strategy Description: ORB Extension Breakout with Custom Stop, Live Tracking, and EOD Exit\nThis strategy is a systematic, momentum-based system designed for intraday trading. It operates on the principle of an Opening Range Breakout (ORB), utilizing the initial market consolidation to project high-probability targets, while offering multiple methods for managing risk and enforcing a mandatory end-of-day closure.\n\n1. Market Identification (The Opening Range)\nThe strategy first defines the market's initial boundaries and volatility:\n\nSession Window: The strategy calculates the Opening Range (OR) over a user-defined time period (default: 9:30 AM to 10:30 AM New York Time).\n\nORB Levels: Two key price levels are established and locked once the time window closes:\n\nWick High/Low: The absolute highest and lowest prices of the session. These serve as the entry trigger lines.\n\nBody High/Low (Shaded Range): The highest and lowest open/close prices of the session. The height of this range is used as the basis for calculating all targets and stops.\n\n2. Entry Rule (The Breakout)\nThe strategy waits passively for a breakout that confirms direction and ensures the move has not yet reached its immediate target.\n\nTrigger Condition: A trade is signaled when a candle closes either:\n\nAbove the Wick High (for a Long entry).\n\nBelow the Wick Low (for a Short entry).\n\nConstraint (Fresh Breakout): The entry is invalidated if the breakout candle's price action (High for Long, Low for Short) has already touched or surpassed the projected Take Profit (0.5 Extension) level before the candle closes.\n\nExecution: The entry is a Market Order executed on the candle that meets the trigger conditions, subject to a user-defined Entry Delay (default 0 bars).\n\nDirection Control: The user can select to trade Long Only, Short Only, or Both.\n\n3. Exit and Risk Management\nAll trades are placed with simultaneous Take Profit and Stop Loss orders (a bracket order) upon entry.\n\nA. Take Profit (TP)\nThe Take Profit is set at the 0.5 Extension of the Shaded Range (Body Range).\n\nCalculation: The distance from the Body High/Low to the TP level is exactly 50% of the total height of the Shaded Range.\n\nB. Stop Loss (SL)\nThe Stop Loss is dynamically calculated based on a user-selected method for risk control:\n\nRange 0.5 (Body Range): The SL is placed an equal distance (0.5 times the Body Range height) outside the opposite side of the Body Range.\n\nATR Multiple: The Stop Loss distance is calculated as a user-defined Multiplier times the Average True Range (ATR).\n\nRecent Swing Low/High: The Stop Loss is placed based on a structural low (for Long) or high (for Short) within a user-defined lookback period.\n\nC. End-of-Day (EOD) Exit\nAny open position is forced closed at the market price if it is still open when the user-defined closing time (default: 16:00 HHMM) is reached. This prevents carrying intraday risk overnight.\n\n4. Visualization\nThe strategy includes comprehensive visual cues for analysis:\n\nORB Drawing: Displays the Wick High/Low and the shaded Body Range.\n\nBreakout Signals: Highlights the specific bar where the validated entry signal occurs.\n\nClosed Trades: Draws persistent lines for the Entry and Exit prices of the last few closed trades.\n\nLive Open Trades: Draws persistent lines for the current Entry Price, active Take Profit Level, and active Stop Loss Level for any open position.",
    "author_name": "ChadAnt",
    "likes_count": 20,
    "comments_count": 0,
    "views_count": 0,
    "created_at": "2025-12-11T20:34:18+00:00",
    "updated_at": null,
    "script_type": "strategy",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "CME_MINI:NQ1!",
      "full_name": "CME_MINI:NQ1!",
      "short_name": "NQ1!",
      "exchange": "CME_MINI",
      "type": "futures",
      "logo_id": "indices/nasdaq-100",
      "currency_logo_id": "country/US",
      "base_currency_logo_id": null,
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/indices/nasdaq-100.svg"
      ],
      "interval": "5",
      "direction": 0,
      "badge": {
        "label": "CME_MINI:NQ1!",
        "url": "/symbols/CME_MINI-NQ1!/"
      }
    },
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=5\nstrategy(\"ORB Strategy: Extensions & Custom SL (EOD & Live Lines)\", overlay=true, shorttitle=\"ORB Str\")\n\n// ==========================================\n// 1. USER INPUTS\n// ==========================================\n\n// --- STRATEGY SETTINGS ---\ngrp_strategy = \"Strategy Execution\"\nentryDelay = input.int(0, \"Entry Delay (Bars after Break)\", minval=0, maxval=5, group=grp_strategy)\ntradeDirection = input.string(\"Both\", \"Trade Direction\", options=[\"Long Only\", \"Short Only\", \"Both\"], group=grp_strategy)\n\n// --- END-OF-DAY SETTINGS ---\ngrp_eod = \"End-of-Day Exit\"\ncloseTimeInput = input.int(1600, \"Forced Close Time (HHMM)\", minval=0000, maxval=2359, group=grp_eod, tooltip=\"Closes all open trades at this time in the defined timezone.\")\n\n\n// --- VISUALIZATION SETTINGS ---\ngrp_vis = \"Trade Visualization\"\nnumTradesToDisplay = input.int(3, \"Closed Trades to Display (0 to disable)\", minval=0, maxval=50, group=grp_vis)\nnumOpenTradesToDisplay = input.int(1, \"Open Trades (Live Levels) to Display\", minval=0, maxval=10, group=grp_vis)\nlineLength = input.int(15, \"Trade Line Length (Bars)\", minval=5, group=grp_vis)\n\n\n// Stop Loss Management\ngrp_sl = \"Stop Loss Settings\"\nslType = input.string(\"Range 0.5 (Body Range)\", \"Stop Loss Type\", \n     options=[\"Range 0.5 (Body Range)\", \"ATR Multiple\", \"Recent Swing Low/High\"], \n     group=grp_sl) \natrLength = input.int(14, \"ATR Lookback\", minval=1, group=grp_sl)\natrMultiplier = input.float(2.0, \"ATR Multiplier\", minval=0.1, group=grp_sl)\nswingLookback = input.int(10, \"Swing Lookback Bars\", minval=5, group=grp_sl)\n\n\n// --- ORB Time Settings ---\ngrp_time = \"ORB Time Settings\"\nsessionInput = input.session(\"0930-1030\", \"Opening Range Session (NY Time)\", group=grp_time)\nendTimeInput = input.int(1600, \"ORB Lines Stop Time (HHMM)\", group=grp_time)\ntimezone     = \"America/New_York\" \n\n// --- ORB Extension Settings ---\ngrp_ext = \"ORB Extensions (Body Range Based)\"\ntpStep = 0.5 // Fixed Take Profit at 0.5 extension as per request\nstdDevSteps  = input.float(0.5, \"Step Size (e.g. 0.5 = 50% of range)\", step=0.1, group=grp_ext, tooltip=\"This input controls the SL/TP step size.\")\nstdDevQty    = input.int(3, \"Number of Extension Lines\", minval=1, maxval=10, group=grp_ext) \nextLineStyle = input.string(\"Dotted\", \"Extension Line Style\", options=[\"Solid\", \"Dotted\", \"Dashed\"], group=grp_ext)\n\n// --- ORB Visuals (kept for compatibility and analysis) ---\ngrp_style = \"ORB Visuals (Non-Trading)\"\nwickColor = input.color(color.new(color.gray, 0), \"Wick Line Color\", group=grp_style)\nbodyColor = input.color(color.new(color.blue, 0), \"Body Line Color\", group=grp_style)\nfillColor = input.color(color.new(color.blue, 90), \"Body Range Fill Color\", group=grp_style)\nlineWidth = input.int(2, \"Line Width\", minval=1, group=grp_style)\n\n// ==========================================\n// 2. ORB LOGIC\n// ==========================================\n\n// Detect New Day & Time Checks\nisNewDay = ta.change(time(\"D\"))\nnyHour = hour(time, timezone)\nnyMinute = minute(time, timezone)\ncurrNyTime = nyHour * 100 + nyMinute\npastCutoff = currNyTime >= endTimeInput\ninFormingSession = not na(time(timeframe.period, sessionInput + \":1234567\", timezone))\n\n// State Variables\nvar float rHigh = na\nvar float rLow = na\nvar float rBodyHigh = na\nvar float rBodyLow = na\nvar bool bullBreakHappened = false\nvar bool bearBreakHappened = false\nvar float breakOutPrice = na \n// Variables to store TP/SL for live visualization (if strategy.position_size is not zero)\nvar float longStopLossLevel = na\nvar float longTakeProfitLevel = na\nvar float shortStopLossLevel = na\nvar float shortTakeProfitLevel = na\n\n\n// Reset on New Day\nif isNewDay\n    rHigh := na\n    rLow := na\n    rBodyHigh := na\n    rBodyLow := na\n    bullBreakHappened := false\n    bearBreakHappened := false\n    breakOutPrice := na\n\n// Update Logic during session\nif inFormingSession and not inFormingSession[1]\n    rHigh := high\n    rLow := low\n    rBodyHigh := math.max(open, close)\n    rBodyLow := math.min(open, close)\n    bullBreakHappened := false \n    bearBreakHappened := false\nelse if inFormingSession\n    rHigh := math.max(rHigh, high)\n    rLow := math.min(rLow, low)\n    rBodyHigh := math.max(rBodyHigh, math.max(open, close))\n    rBodyLow := math.min(rBodyLow, math.min(open, close))\n\n// ORB Boundary Check\nsessionEnded = not inFormingSession and not na(rHigh)\n\n// Global calculation for range height and TP/SL levels\nbodyRangeHeight = rBodyHigh - rBodyLow \ntpLongLevel = rBodyHigh + (bodyRangeHeight * tpStep)\ntpShortLevel = rBodyLow - (bodyRangeHeight * tpStep)\n\n// New Constraint: Check if the candle high/low hits the TP level before close.\npreTargetHitBullish = high >= tpLongLevel \npreTargetHitBearish = low <= tpShortLevel\n\n// Check for close outside the wick (trigger condition) AND apply the constraint\nbullBreakCondition = sessionEnded and not bullBreakHappened and close > rHigh and not preTargetHitBullish\nbearBreakCondition = sessionEnded and not bearBreakHappened and close < rLow and not preTargetHitBearish\n\n// Update Breakout Status and save price for delayed entry\nif bullBreakCondition\n    bullBreakHappened := true\n    breakOutPrice := close\nif bearBreakCondition\n    bearBreakHappened := true\n    breakOutPrice := close\n\n// ==========================================\n// 3. TARGET & STOP LOSS CALCULATION\n// ==========================================\n\nvar float entryPrice = na\nvar float takeProfit = na\nvar float stopLoss = na\n\n// --- ATR Calculation for SL Option ---\natrValue = ta.atr(atrLength)\n\n// --- Swing High/Low Calculation for SL Option ---\nswingLowPrice = ta.lowest(low, swingLookback)\nswingHighPrice = ta.highest(high, swingLookback)\n\n\n// Function to calculate SL based on user choice\ncalcStopLoss(isLong, currentEntryPrice, rangeHeight, currentATR) =>\n    sl = float(na)\n    if slType == \"Range 0.5 (Body Range)\"\n        sl := isLong ? rBodyLow - (rangeHeight * stdDevSteps) : rBodyHigh + (rangeHeight * stdDevSteps)\n    else if slType == \"ATR Multiple\"\n        sl := isLong ? currentEntryPrice - (currentATR * atrMultiplier) : currentEntryPrice + (currentATR * atrMultiplier)\n    else if slType == \"Recent Swing Low/High\"\n        sl := isLong ? swingLowPrice : swingHighPrice\n    sl\n\n// Function to calculate TP (always 0.5 extension of shaded range)\ncalcTakeProfit(isLong, rangeHeight) =>\n    tp = float(na)\n    tp := isLong ? tpLongLevel : tpShortLevel\n    tp\n\n// ==========================================\n// 4. STRATEGY ENTRY & EXIT LOGIC\n// ==========================================\n\n// Entry Logic: Use `ta.barssince()` to count bars since the breakout condition was met\nbarsSinceBullBreak = ta.barssince(bullBreakCondition)\nbarsSinceBearBreak = ta.barssince(bearBreakCondition)\n\n// --- LONG TRADE ENTRY ---\nif barsSinceBullBreak == entryDelay and (tradeDirection == \"Long Only\" or tradeDirection == \"Both\") and strategy.position_size == 0\n    entryPrice := breakOutPrice[entryDelay]\n    takeProfit := calcTakeProfit(true, bodyRangeHeight)\n    stopLoss := calcStopLoss(true, entryPrice, bodyRangeHeight, atrValue)\n    \n    strategy.entry(\"Long ORB\", strategy.long, comment=\"L-ORB\") \n    \n    strategy.exit(\"TP/SL Long\", \"Long ORB\", limit=takeProfit, stop=stopLoss)\n    breakOutPrice := na // Clear breakout price so it doesn't trigger again\n    \n    // Store levels for live visualization\n    longTakeProfitLevel := takeProfit\n    longStopLossLevel := stopLoss\n\n\n// --- SHORT TRADE ENTRY ---\nif barsSinceBearBreak == entryDelay and (tradeDirection == \"Short Only\" or tradeDirection == \"Both\") and strategy.position_size == 0\n    entryPrice := breakOutPrice[entryDelay]\n    takeProfit := calcTakeProfit(false, bodyRangeHeight)\n    stopLoss := calcStopLoss(false, entryPrice, bodyRangeHeight, atrValue)\n    \n    strategy.entry(\"Short ORB\", strategy.short, comment=\"S-ORB\") \n    \n    strategy.exit(\"TP/SL Short\", \"Short ORB\", limit=takeProfit, stop=stopLoss)\n    breakOutPrice := na // Clear breakout price so it doesn't trigger again\n    \n    // Store levels for live visualization\n    shortTakeProfitLevel := takeProfit\n    shortStopLossLevel := stopLoss\n\n// --- END-OF-DAY CLOSURE LOGIC ---\n// Check if current time has passed the forced close time\ncloseTimeReached = currNyTime >= closeTimeInput\n\nif closeTimeReached and strategy.position_size != 0\n    // Close the entire position at market price\n    strategy.close_all(comment=\"EOD Close\")\n\n\n// ==========================================\n// 5. ORB VISUALS (Existing)\n// ==========================================\n\n// Plotting the ORB Levels\ncanDraw = not na(rHigh) and not pastCutoff\nplot(canDraw ? rHigh : na, color=wickColor, linewidth=1, title=\"Wick High\", style=plot.style_linebr)\nplot(canDraw ? rLow : na, color=wickColor, linewidth=1, title=\"Wick Low\", style=plot.style_linebr)\np_bh = plot(canDraw ? rBodyHigh : na, color=bodyColor, linewidth=lineWidth, title=\"Body High\", style=plot.style_linebr)\np_bl = plot(canDraw ? rBodyLow : na, color=bodyColor, linewidth=lineWidth, title=\"Body Low\", style=plot.style_linebr)\nfill(p_bh, p_bl, color = inFormingSession ? fillColor : color.new(color.white, 100))\n\n// Draw Breakout and Extension Visuals\ngetLineStyle(s) => s == \"Dotted\" ? line.style_dotted : s == \"Dashed\" ? line.style_dashed : line.style_solid\n\n// Visuals for Breakout Candle (Only draw if the conditions were met, including the TP constraint)\nplotshape(bullBreakCondition, style=shape.labelup, location=location.belowbar, color=color.green, text=\"BREAK\", textcolor=color.white, size=size.small)\nplotshape(bearBreakCondition, style=shape.labeldown, location=location.abovebar, color=color.red, text=\"BREAK\", textcolor=color.white, size=size.small)\n\n// Visuals for Extension Lines (Redrawn only on the break candle for neatness)\nif bullBreakCondition or bearBreakCondition\n    // Draw only for the successful break direction\n    if bullBreakCondition\n        line.new(bar_index, tpLongLevel, bar_index + 10, tpLongLevel, color=color.green, style=getLineStyle(extLineStyle), width=2)\n    if bearBreakCondition\n        line.new(bar_index, tpShortLevel, bar_index + 10, tpShortLevel, color=color.red, style=getLineStyle(extLineStyle), width=2)\n\n\n// ==========================================\n// 6. TRADE VISUALIZATION\n// ==========================================\n\n// --- CLOSED TRADES (Existing Logic) ---\ndrawTradeClosed(idx, entry, exit, isLong, tradeNum) => \n    exitColor = exit > entry and isLong or exit < entry and not isLong ? color.green : color.red\n    \n    // Draw lines for Entry, Exit, and Exit Line\n    line.new(idx, entry, idx + lineLength, entry, color=color.new(color.yellow, 0), width=2, style=line.style_solid)\n    line.new(idx, exit, idx + lineLength, exit, color=color.new(exitColor, 0), width=2, style=line.style_dotted)\n    line.new(idx, exit, idx + lineLength, exit, color=color.new(exitColor, 40), width=1, style=line.style_dashed)\n\n    label.new(idx + lineLength, entry, text=\"C-Entry #\" + str.tostring(tradeNum), style=label.style_label_right, color=color.yellow, textcolor=color.black, size=size.small)\n\nif strategy.closedtrades > 0 and numTradesToDisplay > 0\n    maxTrades = math.min(strategy.closedtrades, numTradesToDisplay)\n    for i = 1 to maxTrades\n        tradeIndex = strategy.closedtrades - i \n        entryPriceTrade = strategy.closedtrades.entry_price(tradeIndex)\n        exitPriceTrade = strategy.closedtrades.exit_price(tradeIndex)\n        entryBarIndex = strategy.closedtrades.entry_bar_index(tradeIndex)\n        entryComment = strategy.closedtrades.entry_comment(tradeIndex)\n        isLongTrade = entryComment == \"L-ORB\"\n        \n        drawTradeClosed(entryBarIndex, entryPriceTrade, exitPriceTrade, isLongTrade, i)\n\n\n// --- OPEN TRADES (NEW LIVE LOGIC) ---\n// This draws the lines persistently for the CURRENT open trade(s)\n\nif strategy.position_size != 0 and numOpenTradesToDisplay > 0\n    // Get details of the current trade\n    currentEntryPrice = strategy.position_avg_price\n    isLong = strategy.position_size > 0\n    \n    // Since only one position is active at a time in this strategy, we use \n    // the stored TP/SL variables from the entry logic.\n    tpLevel = isLong ? longTakeProfitLevel : shortTakeProfitLevel\n    slLevel = isLong ? longStopLossLevel : shortStopLossLevel\n    \n    entryBarIndex = strategy.opentrades.entry_bar_index(0) // Get bar index of the current entry\n\n    // Draw lines for Entry, TP, and SL\n    // Entry Price (Solid Yellow)\n    line.new(entryBarIndex, currentEntryPrice, bar_index + lineLength, currentEntryPrice, color=color.new(color.yellow, 0), width=2, style=line.style_solid)\n    // TP Level (Dotted Green)\n    line.new(entryBarIndex, tpLevel, bar_index + lineLength, tpLevel, color=color.new(color.green, 0), width=2, style=line.style_dotted)\n    // SL Level (Dashed Red)\n    line.new(entryBarIndex, slLevel, bar_index + lineLength, slLevel, color=color.new(color.red, 0), width=1, style=line.style_dashed)\n    \n    // Label the entry line\n    label.new(bar_index + lineLength, currentEntryPrice, text=\"Live Entry\", style=label.style_label_right, color=color.yellow, textcolor=color.black, size=size.small)"
  },
  "https://www.tradingview.com/script/bBK0ukaM-Scalping-EMA9-15/": {
    "id": 20084203,
    "url": "https://www.tradingview.com/script/bBK0ukaM-Scalping-EMA9-15/",
    "name": "Scalping EMA9/15 ",
    "description": "This indicator is designed for high-accuracy intraday scalping based on a refined version of the popular EMA9‚ÄìEMA15 trend-following technique.\nIt filters weak or premature entries by requiring a retest of the EMA zone before generating a Buy/Sell signal ‚Äî drastically reducing false breakouts.",
    "author_name": "rajpandya18477",
    "likes_count": 26,
    "comments_count": 0,
    "views_count": 0,
    "created_at": "2025-12-11T10:20:22+00:00",
    "updated_at": "2025-12-11T10:26:56+00:00",
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "CRYPTO:BTCUSD",
      "full_name": "CRYPTO:BTCUSD",
      "short_name": "BTCUSD",
      "exchange": "CRYPTO",
      "type": "spot",
      "logo_id": null,
      "currency_logo_id": "country/US",
      "base_currency_logo_id": "crypto/XTVCBTC",
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/crypto/XTVCBTC.svg"
      ],
      "interval": "5",
      "direction": 0,
      "badge": {
        "label": "CRYPTO:BTCUSD",
        "url": "/symbols/BTCUSD/"
      }
    },
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=6\r\nindicator(\"Scalping EMA9/15 ‚Äî Signals + SL/TP (1:2) ‚Äî Retest Fixed v2\", overlay=true, max_labels_count=500)\r\n\r\n// --------------------\r\n// INPUTS\r\n// --------------------\r\nemaFastLen = input.int(9, \"EMA Fast (9)\")\r\nemaSlowLen = input.int(15, \"EMA Slow (15)\")\r\nlookbackForSlope = input.int(3, \"Slope lookback (bars)\")\r\nslopeThresholdPct = input.float(0.20, \"Min slope (% of price) approx 30¬∞\", step=0.01)\r\n\r\nuse_entry_breakout = input.bool(true, \"Enter above/below entry candle (breakout)\")\r\nenter_offset_pts = input.float(0.0, \"Breakout offset (points)\")\r\n\r\nuse_external_confirmation = input.bool(false, \"Require external symbol confirmation\")\r\nconfirm_symbol = input.string(\"\", \"Confirmation symbol (ex: NSE:NIFTYBANK)\")\r\nconfirm_tf = input.timeframe(\"5\", \"Confirmation timeframe (ex: 1, 5, 15, D)\")\r\n\r\nsl_mode = input.string(\"candle_low_high\", \"Stoploss mode\", options=[\"candle_low_high\", \"fixed_ticks\"])\r\nfixed_sl_pts = input.float(20.0, \"Fixed SL (points) if fixed_ticks\")\r\n\r\nrr = input.float(2.0, \"Reward : Risk (TP = RR * SL)\")\r\n\r\ndebug_mode = input.bool(false, \"Debug mode (relax rules to show signals)\")\r\n\r\n// Retest filter: require price touched EMA area within this many bars before entry\r\nretest_bars = input.int(3, \"Retest lookback (bars) - require price touched EMA region before entry\")\r\n\r\n// cooldown to avoid repeated signals\r\nsignal_cooldown = input.int(3, \"Signal cooldown (bars) after a signal\")\r\n\r\n// Visual inputs\r\nshow_lines = input.bool(true, \"Show Entry / SL / TP lines\")\r\nlabel_size = input.string(\"normal\", \"Label size\", options=[\"tiny\",\"small\",\"normal\",\"large\"])\r\n\r\n// --------------------\r\n// CALCULATIONS\r\n// --------------------\r\nemaFast = ta.ema(close, emaFastLen)\r\nemaSlow = ta.ema(close, emaSlowLen)\r\nplot(emaFast, title=\"EMA9\", linewidth=2, color=color.new(color.green, 0))\r\nplot(emaSlow, title=\"EMA15\", linewidth=2, color=color.new(color.red, 0))\r\n\r\n// EMA region bounds (per-bar series, usable with indexing)\r\nemaHigh = math.max(emaFast, emaSlow)\r\nemaLow = math.min(emaFast, emaSlow)\r\n\r\n// slope pct\r\nemaFast_ref = emaFast[lookbackForSlope]\r\nemaSlow_ref = emaSlow[lookbackForSlope]\r\nemaFastSlopePct = 100.0 * (emaFast - emaFast_ref) / math.max(math.abs(emaFast_ref), 0.000001)\r\nemaSlowSlopePct = 100.0 * (emaSlow - emaSlow_ref) / math.max(math.abs(emaSlow_ref), 0.000001)\r\nisTrending = (math.abs(emaFastSlopePct) >= slopeThresholdPct) or (math.abs(emaSlowSlopePct) >= slopeThresholdPct)\r\n\r\n// candle patterns\r\nbody = math.abs(close - open)\r\nprevBody = math.abs(close[1] - open[1])\r\nupperWick = high - math.max(open, close)\r\nlowerWick = math.min(open, close) - low\r\natrv = ta.atr(14)\r\navgBody = ta.sma(math.abs(close - open), 8)\r\n\r\nbullPin = (close > open) and (lowerWick >= body * 2.0) and (upperWick <= body * 0.6)\r\nbearPin = (close < open) and (upperWick >= body * 2.0) and (lowerWick <= body * 0.6)\r\n\r\nbullBig = (close > open) and (body > avgBody * 1.2) and (body > 0.2 * atrv)\r\nbearBig = (close < open) and (body > avgBody * 1.2) and (body > 0.2 * atrv)\r\n\r\nbullEngulf = (close > open) and (open <= close[1]) and (close >= open[1])\r\nbearEngulf = (close < open) and (open >= close[1]) and (close <= open[1])\r\n\r\nbullEntryCandle = bullPin or bullBig or bullEngulf\r\nbearEntryCandle = bearPin or bearBig or bearEngulf\r\n\r\n// external confirmation (optional)\r\nconfirm_ok = true\r\nif use_external_confirmation and str.length(confirm_symbol) > 0\r\n    sym_emaFast = request.security(confirm_symbol, confirm_tf, ta.ema(close, emaFastLen), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)\r\n    sym_emaSlow = request.security(confirm_symbol, confirm_tf, ta.ema(close, emaSlowLen), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)\r\n    confirm_ok := ((sym_emaFast > sym_emaSlow and emaFast > emaSlow) or (sym_emaFast < sym_emaSlow and emaFast < emaSlow))\r\nelse\r\n    confirm_ok := true\r\n\r\n// --------------------\r\n// RETEST CHECK (fixed & robust)\r\n// For buys: require at least one prior bar i in [1..retest_bars] where low[i] <= emaHigh[i]\r\n// For sells: require at least one prior bar i in [1..retest_bars] where high[i] >= emaLow[i]\r\n// --------------------\r\nf_retested_buy(_bars) =>\r\n    bool touched = false\r\n    for i = 1 to _bars\r\n        // use historical series values: emaHigh[i] and low[i]\r\n        if low[i] <= emaHigh[i]\r\n            touched := true\r\n    touched\r\n\r\nf_retested_sell(_bars) =>\r\n    bool touched = false\r\n    for i = 1 to _bars\r\n        if high[i] >= emaLow[i]\r\n            touched := true\r\n    touched\r\n\r\n// --------------------\r\n// ENTRY logic with retest filter\r\n// --------------------\r\nlongCandleOk = bullEntryCandle and close > emaFast and close > emaSlow\r\nshortCandleOk = bearEntryCandle and close < emaFast and close < emaSlow\r\n\r\n// require retest (unless debug_mode on)\r\nretestedBuy = debug_mode ? true : f_retested_buy(retest_bars)\r\nretestedSell = debug_mode ? true : f_retested_sell(retest_bars)\r\n\r\n// final conditions\r\nlongCond_real = longCandleOk and (emaFast > emaSlow) and isTrending and confirm_ok and retestedBuy\r\nshortCond_real = shortCandleOk and (emaFast < emaSlow) and isTrending and confirm_ok and retestedSell\r\n\r\n// debug relaxed\r\nlongCond_debug = (close > open) and (emaFast > emaSlow)\r\nshortCond_debug = (close < open) and (emaFast < emaSlow)\r\n\r\nlongCond = debug_mode ? longCond_debug : longCond_real\r\nshortCond = debug_mode ? shortCond_debug : shortCond_real\r\n\r\n// cooldown guard: avoid immediate repeat signals\r\nvar int lastSignalBar = na\r\ncanSignalNow = na(lastSignalBar) ? true : (bar_index - lastSignalBar) > signal_cooldown\r\n\r\n// --------------------\r\n// SIGNAL / ENTRY / SL / TP bookkeeping\r\n// --------------------\r\nvar float entryPrice = na\r\nvar float slPrice = na\r\nvar float tpPrice = na\r\nvar int entryBarIndex = na\r\nvar string entrySide = \"\"\r\n\r\n// track plot objects\r\nvar line entryLine = na\r\nvar line slLine = na\r\nvar line tpLine = na\r\nvar label entryLabel = na\r\n\r\nif longCond and canSignalNow\r\n    // ensure the entry candle is after the touch (already enforced by using previous bars)\r\n    entryPrice := use_entry_breakout ? (high + enter_offset_pts) : close\r\n    slPrice := (sl_mode == \"fixed_ticks\") ? (entryPrice - fixed_sl_pts) : low\r\n    tpPrice := entryPrice + rr * math.abs(entryPrice - slPrice)\r\n    entryBarIndex := bar_index\r\n    entrySide := \"LONG\"\r\n    lastSignalBar := bar_index\r\n\r\nif shortCond and canSignalNow\r\n    entryPrice := use_entry_breakout ? (low - enter_offset_pts) : close\r\n    slPrice := (sl_mode == \"fixed_ticks\") ? (entryPrice + fixed_sl_pts) : high\r\n    tpPrice := entryPrice - rr * math.abs(entryPrice - slPrice)\r\n    entryBarIndex := bar_index\r\n    entrySide := \"SHORT\"\r\n    lastSignalBar := bar_index\r\n\r\n// clear entries when price crosses TP or SL (so lines don't persist forever)\r\nhitTP = false\r\nhitSL = false\r\nif not na(entryPrice)\r\n    if entrySide == \"LONG\"\r\n        hitTP := high >= tpPrice\r\n        hitSL := low <= slPrice\r\n    else if entrySide == \"SHORT\"\r\n        hitTP := low <= tpPrice\r\n        hitSL := high >= slPrice\r\n    if hitTP or hitSL\r\n        entryPrice := na\r\n        slPrice := na\r\n        tpPrice := na\r\n        entryBarIndex := na\r\n        entrySide := \"\"\r\n\r\n// --------------------\r\n// PLOT shapes / lines\r\n// --------------------\r\nplotshape(longCond and canSignalNow, title=\"BUY signal\", location=location.belowbar, style=shape.labelup, text=\"BUY\", textcolor=color.white, size=size.small, color=color.new(color.green, 0))\r\nplotshape(shortCond and canSignalNow, title=\"SELL signal\", location=location.abovebar, style=shape.labeldown, text=\"SELL\", textcolor=color.white, size=size.small, color=color.new(color.red, 0))\r\n\r\n// remove previous shapes/lines if a new entry is planned\r\nif not na(entryBarIndex)\r\n    if not na(entryLine)\r\n        line.delete(entryLine)\r\n    if not na(slLine)\r\n        line.delete(slLine)\r\n    if not na(tpLine)\r\n        line.delete(tpLine)\r\n    if not na(entryLabel)\r\n        label.delete(entryLabel)\r\n\r\n    if show_lines\r\n        entryLine := line.new(x1=entryBarIndex, y1=entryPrice, x2=bar_index, y2=entryPrice, xloc=xloc.bar_index, extend=extend.right, width=2, color=color.new(color.blue, 0))\r\n        slLine := line.new(x1=entryBarIndex, y1=slPrice, x2=bar_index, y2=slPrice, xloc=xloc.bar_index, extend=extend.right, width=1, color=color.new(color.red, 0), style=line.style_dashed)\r\n        tpLine := line.new(x1=entryBarIndex, y1=tpPrice, x2=bar_index, y2=tpPrice, xloc=xloc.bar_index, extend=extend.right, width=1, color=color.new(color.green, 0), style=line.style_dashed)\r\n\r\n        // compute label size enum\r\n        labSize = label_size == \"tiny\" ? size.tiny : label_size == \"small\" ? size.small : label_size == \"large\" ? size.large : size.normal\r\n\r\n        entryLabel := label.new(bar_index, entryPrice,\r\n          text=\"Entry\\n\" + str.tostring(entryPrice, format.price) + \"\\nSL: \" + str.tostring(slPrice, format.price) + \"\\nTP(1:2): \" + str.tostring(tpPrice, format.price),\r\n          xloc=xloc.bar_index, style=label.style_label_left, color=color.new(color.black, 0), textcolor=color.white, size=labSize)\r\n\r\n// --------------------\r\n// ALERTS\r\n// --------------------\r\nalertcondition(longCond and canSignalNow, title=\"BUY Signal\", message=\"BUY signal: check chart\")\r\nalertcondition(shortCond and canSignalNow, title=\"SELL Signal\", message=\"SELL signal: check chart\")\r\nalertcondition(hitTP, title=\"TP Hit\", message=\"TP hit for last signaled trade\")\r\nalertcondition(hitSL, title=\"SL Hit\", message=\"SL hit for last signaled trade\")\r\n\r\n// --------------------\r\n// INFO (table)\r\n// --------------------\r\nvar table info = table.new(position.top_right, 1, 6)\r\nif barstate.islast\r\n    table.cell(info, 0, 0, text=(\"EMA9>EMA15: \" + str.tostring(emaFast > emaSlow)))\r\n    table.cell(info, 0, 1, text=(\"Trending: \" + str.tostring(isTrending)))\r\n    table.cell(info, 0, 2, text=(\"Slope%: \" + str.tostring(emaFastSlopePct, format.percent)))\r\n    table.cell(info, 0, 3, text=(\"RetestBars: \" + str.tostring(retest_bars)))\r\n    table.cell(info, 0, 4, text=(\"Cooldown: \" + str.tostring(signal_cooldown)))\r\n    table.cell(info, 0, 5, text=(\"Debug: \" + str.tostring(debug_mode)))\r\n"
  },
  "https://www.tradingview.com/script/JKQBB4Mn-In-Range-Rolling-SL/": {
    "id": 20086343,
    "url": "https://www.tradingview.com/script/JKQBB4Mn-In-Range-Rolling-SL/",
    "name": "In-Range Rolling SL",
    "description": "\n\nIn-Range Rolling SL Indicator Guide\nThe In-Range Rolling SL indicator is a dynamic stop-loss system designed for intraday trading that identifies squeeze conditions and trade entry opportunities based on rolling price windows.\n\nCore Concept\nThe indicator analyzes the highest high and lowest low over a defined lookback period (default: 2 candles) to establish an \"in-range\" zone. When price stays within this range without breaking either boundary, it creates a squeeze condition‚Äîsignaling potential breakout opportunities.\n\nTrading Strategy\nWait for the Squeeze Setup\nThe most effective approach is to wait for the in-range stop-loss squeeze to form. This occurs when both the long SL (green line) and short SL (red line) are active simultaneously, indicated by the yellow status dot (üü°) in the indicator table. Analyze the wick high/close relationship against the in-range SL while price remains compressed‚Äîthis setup identifies which side is more likely to break first.\n\nEntry Timing and Risk Management\nLong Entry: Enter when a candle closes above the in-range short SL (red line) without any wick above it. This \"perfect breakout candle\" confirms bullish momentum. Your entry should be around the region, with your stop-loss placed just below the top of the breakout candle's high.\n\nShort Entry: Enter when a candle closes below the in-range long SL (green line). The stop-loss for short trades should be set 34.26 points above your entry for appropriate risk protection.\n\nRisk-Reward Considerations\nIf you enter at the low of a breakout candle, expect only 8.26 points of drawdown potential. However, if you accidentally go long and your stop gets hit, you'll experience the full in-range stop-loss distance as your loss.\n\nAdvanced Techniques\nFailed Breakout Trap: If a follow-up candle doesn't make a higher high after the initial breakout, consider adding a \"winner\" for compensation rather than holding for a trap. When your buy-stop sits on top of the breakout candle high, this isn't a valid long trade setup.\n\nFlip Trade Opportunity: In-range stop-loss attempts to flip often provide ideal entry points. If the up candle doesn't break the previous low, this validates the long continuation.\n\nLong Scalp Trading: A failed long scalp can be traded if you missed the initial market open down-up-down trend. With a stop-loss of 34 points and potential profit exceeding 50 points, this provides favorable risk-reward ratios.\n\nSustained Loss Management: Stop-loss for long positions should target 26 points maximum loss. The indicator automatically invalidates stop-losses when price violates them, keeping your chart clean for the next setup.\n\n-------------------------\n\n\nIn-Range Rolling SL Indicator Guide\nThe In-Range Rolling SL indicator is a dynamic stop-loss system designed for intraday trading that identifies squeeze conditions and breakout opportunities based on rolling price windows.\n\nHow the Indicator Works\nThe indicator tracks the highest high and lowest low over your selected lookback period (default: 2 candles) to establish dynamic support and resistance levels. These levels create an \"in-range\" zone that adapts as new price action develops.\n\nVisual Components\nGreen Line (Long SL): The rolling window's lowest low - your stop-loss level for long positions\n\nRed Line (Short SL): The rolling window's highest high - your stop-loss level for short positions\n\nStatus Indicators:\n\nüü° Yellow: Squeeze condition (both SLs active)\n\nüü¢ Green: Long-only setup\n\nüî¥ Red: Short-only setup\n\n‚ö™ White: Neutral (no active SLs)\n\nThe Squeeze Setup Strategy\nStep 1: Wait for the Squeeze\nThe most effective way to use the In-Range Rolling SL is to wait for the in-range stop-loss squeeze to form. During the squeeze, both the green and red lines are active, meaning price has stayed within the rolling window without breaking either boundary. This compression phase indicates that it's \"go time\" to prepare your trade.\n\nWhile in the squeeze, analyze the wick high/close relationship against the in-range SL levels. This analysis helps you determine which side is more likely to split when the breakout occurs.\n\nStep 2: Identify the Perfect Breakout\nLong Breakout: A perfect breakout candle should close above the in-range stop-loss high (red line) without any wick above it. This clean breakout demonstrates strong momentum and reduces the risk of a false breakout.\n\nShort Breakout: Look for a candle that closes below the in-range SL low (green line), indicating a short-side trade is coming up.\n\nStep 3: Entry Execution\nLong Entry: Your entry should be around the region of the breakout. Position your stop-loss just below the top of the breakout candle's high. This placement protects you from failed breakouts while giving the trade room to develop.\n\nShort Entry: Enter as the candle closes below the in-range SL low. The stop-loss for short-side trades is typically 34.26 points of potential loss based on the indicator's measurements.\n\nRisk-Reward Analysis\nEntry at Breakout Low\nIf you enter here at the low of the breakout candle, you're looking at only 8.26 points of drawdown potential. This represents your best-case entry scenario.\n\nAccidental Wrong-Side Entry\nHowever, if you accidentally go long here and your stop gets hit, you'll experience the full in-range stop-loss distance as your loss. This emphasizes the importance of waiting for clear breakout confirmation.\n\nLong Scalp Opportunity\nA failed long scalp can be traded here if you missed the market open down-up-down trend. With a stop-loss of 34 points and potential profit greater than 50 points, this setup offers a favorable risk-reward ratio of approximately 1:1.5.\n\nAdvanced Trade Management\nFailed Breakout Recognition\nFollow-Up Candle Validation: If a follow-up candle did not make a higher high than the breakout candle, this could be a trap. Your buy-stop on top of the breakout candle high is not a valid long trade setup in this scenario. Consider adding a \"winner\" for compensation rather than holding through the potential reversal.\n\nFlip Trade Opportunities\nIn-range stop-loss tries to flip to the other side often provide excellent entries. If the up candle did not break the previous low, this validates the long continuation and suggests the squeeze is resolving to the upside.\n\nSustained Position Management\nStop-Loss Guidelines: Stop-loss for long positions should be 26 points of maximum loss. The indicator table displays the delta (Œî) showing your real-time distance to the active stop-loss, helping you manage risk dynamically.\n\nEntry Timing: Your entry should be around the region where the breakout confirms, rather than chasing price after a large move. In order to prepare your trade, position your stop-loss on top of the breakout candle's high for long trades.\n\nPractical Example from the Chart\nLooking at the MNQ1! chart, you can see multiple squeeze formations throughout the session. The most notable sequence shows:\n\nAn initial downtrend creating a squeeze setup\n\nA perfect breakout candle closing above the red line without upper wick\n\nThe subsequent candle validating the move\n\nLater, a failed breakout attempt that created a short opportunity\n\nMultiple flip attempts that provided re-entry points for scalpers\n\nThe indicator's table in the top-right continuously updates with the current SL levels, gap size, candle size, and delta values - giving you all the information needed to assess each trade's risk-reward profile in real-time.",
    "author_name": "DeLeBlanc",
    "likes_count": 19,
    "comments_count": 0,
    "views_count": 0,
    "created_at": "2025-12-11T17:14:01+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "CME_MINI:MNQ1!",
      "full_name": "CME_MINI:MNQ1!",
      "short_name": "MNQ1!",
      "exchange": "CME_MINI",
      "type": "futures",
      "logo_id": "country/US",
      "currency_logo_id": "country/US",
      "base_currency_logo_id": null,
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/country/US.svg"
      ],
      "interval": "1",
      "direction": 0,
      "badge": {
        "label": "CME_MINI:MNQ1!",
        "url": "/symbols/CME_MINI-MNQ1!/"
      }
    },
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=6\r\nindicator(\"In-Range Rolling SL\", overlay=true)\r\n\r\n// --- Lookback Window Input ---\r\ni_lookback = input.int(2, \"Lookback Candles\", minval=1, tooltip=\"Number of previous candles to define the 'Higher Time Frame' range.\")\r\n\r\n// ------------------------\r\n// Get the High and Low of the rolling window\r\n// ------------------------\r\n// The highest high and lowest low over the past 'i_lookback' bars (including the bar immediately before the current one)\r\nph_rolling = ta.highest(high[1], i_lookback)\r\npl_rolling = ta.lowest(low[1], i_lookback)\r\n\r\n// ------------------------\r\n// Unmitigated conditions\r\n// ------------------------\r\n// Check current low/high against the range defined by the rolling window\r\nlongUM  = low  > pl_rolling\r\nshortUM = high < ph_rolling\r\n\r\nvar float longSL  = na\r\nvar float shortSL = na\r\n\r\n// ------------------------\r\n// Update SLs (step-line friendly) - uses Rolling Window levels\r\n// ------------------------\r\nif longUM\r\n    // Set SL to the lowest low of the rolling window\r\n    longSL := pl_rolling\r\nif shortUM\r\n    // Set SL to the highest high of the rolling window\r\n    shortSL := ph_rolling\r\n\r\n// ------------------------\r\n// Auto-flip invalidation\r\n// ------------------------\r\n// This part remains the same, checking current bar against the active SL\r\nif not na(longSL) and low <= longSL\r\n    longSL := na\r\nif not na(shortSL) and high >= shortSL\r\n    shortSL := na\r\n\r\n// ------------------------\r\n// Plot active SLs\r\n// ------------------------\r\nplot(longSL,  \"L SL\", color=color.green, style=plot.style_linebr)\r\nplot(shortSL, \"S SL\", color=color.red,   style=plot.style_linebr)\r\n\r\n// ------------------------\r\n// Squeeze detection\r\n// ------------------------\r\n// The squeeze logic now relies on the SLs set by the rolling window data\r\nunderSqueeze = not na(longSL) and not na(shortSL) and (low >= longSL) and (high <= shortSL)\r\nlongOnly     = not na(longSL)  and na(shortSL)\r\nshortOnly    = not na(shortSL) and na(longSL)\r\nneutral      = na(longSL) and na(shortSL)\r\n\r\n// Status dot + color\r\nstring status = \"\"\r\ncolor statColor = color.white\r\nif underSqueeze\r\n    status := \"üü°\"\r\n    statColor := color.yellow\r\nelse if longOnly\r\n    status := \"üü¢\"\r\n    statColor := color.green\r\nelse if shortOnly\r\n    status := \"üî¥\"\r\n    statColor := color.red\r\nelse\r\n    status := \"‚ö™\"\r\n    statColor := color.gray\r\n\r\n// ------------------------\r\n// Numeric info\r\n// ------------------------\r\ngap          = (not na(longSL) and not na(shortSL)) ? shortSL - longSL : na\r\ncandleHeight = high - low // Current candle height\r\n\r\n// Delta calculation (current price to active SL)\r\ndeltaL = not na(longSL) ? close - longSL  : na\r\ndeltaS = not na(shortSL) ? shortSL - close : na\r\n\r\n// ------------------------\r\n// Table: 3 rows, first row = header, second = SL, third = delta\r\n// ------------------------\r\nvar table t = table.new(position.top_right, 5, 3, border_width=1, frame_color=color.black)\r\n\r\n// Header row\r\ntable.cell(t, 0, 0, \"Status\", bgcolor=color.gray, text_color=color.white, text_size=size.small)\r\ntable.cell(t, 1, 0, \"Long\",  bgcolor=color.gray, text_color=color.white, text_size=size.small)\r\ntable.cell(t, 2, 0, \"Short\", bgcolor=color.gray, text_color=color.white, text_size=size.small)\r\ntable.cell(t, 3, 0, \"Gap\",   bgcolor=color.gray, text_color=color.white, text_size=size.small)\r\ntable.cell(t, 4, 0, \"Size\",  bgcolor=color.gray, text_color=color.white, text_size=size.small)\r\n\r\n// Values row (SL numbers / status)\r\ntable.cell(t, 0, 1, status, text_color=statColor, text_size=size.large, bgcolor=color.new(color.black,85))\r\ntable.cell(t, 1, 1, not na(longSL)  ? str.tostring(longSL, \"#.##\")  : \"-\", text_color=color.green, bgcolor=color.new(color.black,85))\r\ntable.cell(t, 2, 1, not na(shortSL) ? str.tostring(shortSL, \"#.##\") : \"-\", text_color=color.red,   bgcolor=color.new(color.black,85))\r\ntable.cell(t, 3, 1, not na(gap)     ? str.tostring(gap, \"#.##\")     : \"-\", text_color=color.white, bgcolor=color.new(color.black,85))\r\ntable.cell(t, 4, 1, str.tostring(candleHeight, \"#.##\"), text_color=color.white, bgcolor=color.new(color.black,85))\r\n\r\n// Delta row (show for all active SLs)\r\ntable.cell(t, 0, 2, \"Œî\", text_color=color.white, text_size=size.small, bgcolor=color.new(color.black,85))\r\ntable.cell(t, 1, 2, not na(deltaL)  ? str.tostring(deltaL, \"#.##\")  : \"-\", text_color=color.green, bgcolor=color.new(color.black,85))\r\ntable.cell(t, 2, 2, not na(deltaS)  ? str.tostring(deltaS, \"#.##\")  : \"-\", text_color=color.red,   bgcolor=color.new(color.black,85))\r\ntable.cell(t, 3, 2, \"-\", bgcolor=color.new(color.black,85), text_color=color.white)\r\ntable.cell(t, 4, 2, \"-\", bgcolor=color.new(color.black,85), text_color=color.white)"
  },
  "https://www.tradingview.com/script/2x1W1UbI/": {
    "id": 20088843,
    "url": "https://www.tradingview.com/script/2x1W1UbI/",
    "name": "Alpha Trading Signal _ Up side Down",
    "description": "Let me lead u to success. By Alpha trading team research",
    "author_name": "giaodichdsmart",
    "likes_count": 26,
    "comments_count": 0,
    "views_count": 0,
    "created_at": "2025-12-12T05:48:37+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "COMEX:SI1!",
      "full_name": "COMEX:SI1!",
      "short_name": "SI1!",
      "exchange": "COMEX",
      "type": "futures",
      "logo_id": "metal/silver",
      "currency_logo_id": "country/US",
      "base_currency_logo_id": null,
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/metal/silver.svg"
      ],
      "interval": "1D",
      "direction": 0,
      "badge": {
        "label": "COMEX:SI1!",
        "url": "/symbols/COMEX-SI1!/"
      }
    },
    "created": "2025-12-12",
    "updated": "2025-12-12",
    "source": "//@version=6\r\nindicator('Alpha Trading Signal _ Up side Down', overlay = true, format = format.price, precision = 2, timeframe = '')\r\n\r\nPeriods = input(title = 'ATR Period', defval = 10)\r\nsrc = input(hl2, title = 'Source')\r\nMultiplier = input.float(title = 'ATR Multiplier', step = 0.1, defval = 3.0)\r\nchangeATR = input(title = 'Change ATR Calculation Method ?', defval = true)\r\nshowsignals = input(title = 'Show Buy/Sell Signals ?', defval = true)\r\nhighlighting = input(title = 'Highlighter On/Off ?', defval = true)\r\natr2 = ta.sma(ta.tr, Periods)\r\natr = changeATR ? ta.atr(Periods) : atr2\r\nup = src - Multiplier * atr\r\nup1 = nz(up[1], up)\r\nup := close[1] > up1 ? math.max(up, up1) : up\r\ndn = src + Multiplier * atr\r\ndn1 = nz(dn[1], dn)\r\ndn := close[1] < dn1 ? math.min(dn, dn1) : dn\r\ntrend = 1\r\ntrend := nz(trend[1], trend)\r\ntrend := trend == -1 and close > dn1 ? 1 : trend == 1 and close < up1 ? -1 : trend\r\nupPlot = plot(trend == 1 ? up : na, title = 'Up Trend', style = plot.style_linebr, linewidth = 2, color = color.new(color.green, 0))\r\nbuySignal = trend == 1 and trend[1] == -1\r\nplotshape(buySignal ? up : na, title = 'UpTrend Begins', location = location.absolute, style = shape.circle, size = size.tiny, color = color.new(color.green, 0))\r\nplotshape(buySignal and showsignals ? up : na, title = 'Buy', text = 'Buy', location = location.absolute, style = shape.labelup, size = size.tiny, color = color.new(color.green, 0), textcolor = color.new(color.white, 0))\r\ndnPlot = plot(trend == 1 ? na : dn, title = 'Down Trend', style = plot.style_linebr, linewidth = 2, color = color.new(color.red, 0))\r\nsellSignal = trend == -1 and trend[1] == 1\r\nplotshape(sellSignal ? dn : na, title = 'DownTrend Begins', location = location.absolute, style = shape.circle, size = size.tiny, color = color.new(color.red, 0))\r\nplotshape(sellSignal and showsignals ? dn : na, title = 'Sell', text = 'Sell', location = location.absolute, style = shape.labeldown, size = size.tiny, color = color.new(color.red, 0), textcolor = color.new(color.white, 0))\r\nmPlot = plot(ohlc4, title = '', style = plot.style_circles, linewidth = math.max(1, 0))\r\nlongFillColor = highlighting ? trend == 1 ? color.green : color.white : color.white\r\nshortFillColor = highlighting ? trend == -1 ? color.red : color.white : color.white\r\nfill(mPlot, upPlot, title = 'UpTrend Highligter', color = longFillColor)\r\nfill(mPlot, dnPlot, title = 'DownTrend Highligter', color = shortFillColor)\r\nalertcondition(buySignal, title = 'SuperTrend Buy', message = 'SuperTrend Buy!')\r\nalertcondition(sellSignal, title = 'SuperTrend Sell', message = 'SuperTrend Sell!')\r\nchangeCond = trend != trend[1]\r\nalertcondition(changeCond, title = 'SuperTrend Direction Change', message = 'SuperTrend has changed direction!')\r\n"
  },
  "https://www.tradingview.com/script/N7hdkg5e-MoneyLine-Cipher/": {
    "id": 20087477,
    "url": "https://www.tradingview.com/script/N7hdkg5e-MoneyLine-Cipher/",
    "name": "MoneyLine Cipher",
    "description": "MoneyLine Cipher\nOverview\nMoneyLine Cipher is a trend-following indicator designed to identify high-probability entry and exit points by combining multiple technical analysis methods into a unified signal system. The indicator adapts its behavior based on current market conditions, becoming more aggressive in strong trends and more conservative in choppy or uncertain markets.\nCore Concept: The Money Line\nAt the heart of this indicator is the Money Line, a linear regression line that acts as a dynamic center of price action. Unlike a simple moving average, linear regression fits a straight line through recent prices using least-squares methodology, providing a smoother representation of the underlying trend direction. The slope of this line determines whether the market is in a bullish, bearish, or neutral state.\nDynamic Envelope Bands\nThe indicator plots upper and lower bands around the Money Line using Average True Range (ATR) as the volatility measure. What makes these bands unique is their adaptive multiplier system. When the ADX (Average Directional Index) indicates a strong trend, the bands automatically widen to accommodate larger price swings and avoid premature exits. In ranging or weak trend conditions, the bands contract to provide tighter entry and exit zones. This dynamic adjustment helps the indicator perform consistently across different market environments.\nTrend State Detection\nThe indicator classifies market conditions into five distinct states: Strong Uptrend, Uptrend, Neutral, Downtrend, and Strong Downtrend. This classification uses three complementary methods working together.\nFirst, the Directional Movement Index (DMI) measures the spread between positive and negative directional indicators. A large positive spread suggests bullish momentum, while a large negative spread indicates bearish pressure.\nSecond, On-Balance Volume (OBV) confirms whether volume supports the indicated trend direction. For a Strong Uptrend classification, OBV must be rising above its moving average, confirming that buying pressure backs the price movement.\nThird, ADX must exceed a minimum threshold for Strong trend classifications, ensuring that only genuinely trending markets receive the Strong designation.\nSignal Generation\nBuy and sell signals are generated using Fisher Transform and Aroon indicators, but with a crucial enhancement: the trigger thresholds adjust dynamically based on the current trend state.\nThe Fisher Transform converts price data into a Gaussian normal distribution, making turning points easier to identify. In a Strong Uptrend, the buy threshold relaxes (making buys easier to trigger) while the sell threshold tightens (making sells harder to trigger). This allows traders to stay in winning positions longer during favorable conditions. The opposite applies in downtrends, where the system becomes quick to exit and reluctant to enter long positions.\nThe Aroon indicator measures how recently price made a new high or low within the lookback period. Combined with Fisher Transform, this dual-confirmation approach reduces false signals that might occur when using either indicator alone.\nBand touches also generate signals. When price reaches the lower band, a potential buy zone is identified. When price reaches the upper band, a potential sell zone is flagged.\nCascade Protection System\nA key feature is the built-in protection against averaging down into a losing position. The system tracks consecutive buy signals and limits them to a configurable maximum (default: 3). After reaching this limit, no additional buy signals are generated until a sell signal resets the counter. This prevents the common mistake of repeatedly buying during a sustained decline.\nAdditionally, the indicator monitors Bollinger Band Width Percentile (BBWP), which measures current volatility relative to historical volatility. When BBWP exceeds a threshold (indicating a volatility spike often associated with sharp moves), buy signals are temporarily frozen. This protects against entering during panic selloffs or blow-off tops.\nExtreme Move Detection\nSometimes price moves so aggressively that it penetrates the bands by an unusual amount. The indicator detects these extreme moves and can generate signals even during normal cooldown periods. The logic is that an extreme band penetration represents a significant overextension that warrants attention regardless of recent signal history. These extreme signals are visually distinguished from regular signals.\nRSI Divergence\nThe indicator includes RSI divergence detection as an additional confirmation tool. When price makes a lower low but RSI makes a higher low (bullish divergence), it suggests weakening downside momentum and a potential reversal. Bearish divergence (price higher high, RSI lower high) warns of potential tops. Both regular and hidden divergences are detected and marked on the chart.\nSignal Cooldown\nTo prevent overtrading and signal clustering, a configurable cooldown period prevents new signals for a set number of bars after each signal. This spacing ensures that each signal represents a distinct trading opportunity rather than repeated triggers on the same price movement.\nVisual Display\nThe indicator provides a comprehensive information panel showing current trend state, BBWP status, consecutive buy count, ADX reading, Fisher and Aroon values, cooldown status, and current dynamic thresholds. An ADX bar at the bottom of the chart provides quick visual reference for trend strength and direction using color coding.\nSignal labels display the entry or exit price along with the current buy count (for buy signals), helping traders track their position sizing.\nHow to Use\nIn uptrending markets, look for buy signals near the lower band, particularly when the trend state shows Uptrend or Strong Uptrend. These represent pullback opportunities within an established trend.\nIn downtrending markets, the indicator naturally reduces buy signals and increases sell sensitivity, helping traders avoid catching falling knives.\nIn neutral or ranging conditions, signals from both directions are generated with moderate thresholds, suitable for mean-reversion trading within the bands.\nMonitor the BBWP and consecutive buy counter in the info panel. If BBWP shows \"FROZEN\" or the buy counter approaches the maximum, exercise additional caution with new long entries.\nSettings Guidance\nThe default settings are optimized for 5-minute cryptocurrency charts but can be adjusted for other timeframes and assets. Key parameters to consider adjusting include the Money Line length (shorter for more responsive, longer for smoother), ATR multiplier range (wider bands reduce signals but improve accuracy), and the various threshold values for trend classification.",
    "author_name": "ralis24",
    "likes_count": 21,
    "comments_count": 0,
    "views_count": 0,
    "created_at": "2025-12-11T22:36:19+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "PHEMEX:BTCUSDT",
      "full_name": "PHEMEX:BTCUSDT",
      "short_name": "BTCUSDT",
      "exchange": "PHEMEX",
      "type": "spot",
      "logo_id": null,
      "currency_logo_id": "crypto/XTVCUSDT",
      "base_currency_logo_id": "crypto/XTVCBTC",
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/crypto/XTVCBTC.svg",
        "https://s3-symbol-logo.tradingview.com/crypto/XTVCUSDT.svg"
      ],
      "interval": "5",
      "direction": 0,
      "badge": {
        "label": "PHEMEX:BTCUSDT",
        "url": "/symbols/BTCUSDT/"
      }
    },
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=6\r\nindicator(\"MoneyLine Cipher\",\r\n          shorttitle=\"ML Cipher\", overlay=true, max_labels_count=500, max_lines_count=500)\r\n\r\n// ‚îÄ‚îÄ INPUT GROUPS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\r\ngroupGeneral   = \"General Settings\"\r\ngroupGrok      = \"Grok Dynamic Bands\"\r\ngroupTrend     = \"Trend Detection (DI + OBV + ADX)\"\r\ngroupDynamic   = \"Dynamic Thresholds\"\r\ngroupCooldown  = \"Cooldown Settings\"\r\ngroupDisplay   = \"Display Settings\"\r\n\r\n// General\r\nlength            = input.int(16, \"Money Line Length\", group=groupGeneral)\r\natrPeriod         = input.int(12, \"ATR Period\", group=groupGeneral)\r\natrMultiplier     = input.float(1.8, \"Base ATR Multiplier\", step=0.1, group=groupGeneral)\r\nneutralTolerance  = input.float(0.08, \"Neutral Slope Tolerance (x ATR)\", group=groupGeneral)\r\nslopeLookback     = input.int(1, \"Slope Smoothing Lookback\", group=groupGeneral)\r\n\r\n// Grok Bands\r\nenableGrok        = input.bool(true, \"Enable Dynamic Enveloping Bands\", group=groupGrok)\r\nadxLen            = input.int(14, \"ADX Length\", group=groupGrok)\r\ndiSmoothing       = input.int(14, \"DI Smoothing\", group=groupGrok)\r\nadxThresh         = input.float(22, \"ADX Threshold\", group=groupGrok)\r\nmaxMult           = input.float(2.8, \"Max Multiplier (Strong Trend)\", group=groupGrok)\r\n\r\n// Trend Detection\r\ndiPeriod          = input.int(14, \"DI Period\", group=groupTrend)\r\ndiStrongThresh    = input.int(10, \"Strong Trend DI Spread\", group=groupTrend, tooltip=\"DI spread above this = strong trend\")\r\ndiWeakThresh      = input.int(5, \"Weak Trend DI Spread\", group=groupTrend, tooltip=\"DI spread above this = trend\")\r\nobvMAPeriod       = input.int(20, \"OBV MA Period\", group=groupTrend)\r\nuseOBVConfirm     = input.bool(true, \"Require OBV Confirmation for Strong Trends\", group=groupTrend)\r\nadxStrongMin      = input.int(20, \"Min ADX for Strong Trend\", group=groupTrend, tooltip=\"ADX must exceed this for STRONG UPTREND/DOWNTREND classification\")\r\n\r\n// Dynamic Thresholds - Base values (used in NEUTRAL)\r\nfisherLength      = input.int(10, \"Fisher Transform Period\", group=groupDynamic)\r\nbaseFisherBuy     = input.float(-1.8, \"Base Fisher Buy Level (Neutral)\", step=0.1, group=groupDynamic)\r\nbaseFisherSell    = input.float(1.8, \"Base Fisher Sell Level (Neutral)\", step=0.1, group=groupDynamic)\r\naroonLength       = input.int(12, \"Aroon Lookback Period\", minval=5, maxval=50, group=groupDynamic)\r\nbaseAroonUpBuy    = input.int(25, \"Base Aroon Up Buy < (Neutral)\", group=groupDynamic)\r\nbaseAroonDownBuy  = input.int(75, \"Base Aroon Down Buy > (Neutral)\", group=groupDynamic)\r\nbaseAroonUpSell   = input.int(75, \"Base Aroon Up Sell > (Neutral)\", group=groupDynamic)\r\nbaseAroonDownSell = input.int(25, \"Base Aroon Down Sell < (Neutral)\", group=groupDynamic)\r\n\r\n// Cooldown Settings\r\nuseCooldown       = input.bool(true, \"Enable Signal Cooldown\", group=groupCooldown)\r\ncooldownBars      = input.int(5, \"Cooldown Period (bars)\", minval=1, maxval=20, group=groupCooldown, tooltip=\"Minimum bars between signals\")\r\ncooldownAfterBuy  = input.bool(true, \"Cooldown After Buy Signal\", group=groupCooldown)\r\ncooldownAfterSell = input.bool(true, \"Cooldown After Sell Signal\", group=groupCooldown)\r\n\r\n// Cascade Protection Settings\r\ngroupProtect      = \"Cascade Protection\"\r\nuseCascadeProtect = input.bool(true, \"Enable Cascade Protection\", group=groupProtect)\r\nbbwpLength        = input.int(7, \"BBWP Length\", minval=5, maxval=20, group=groupProtect, tooltip=\"Bollinger Band Width Percentile period\")\r\nbbwpLookback      = input.int(100, \"BBWP Lookback\", minval=50, maxval=300, group=groupProtect)\r\nbbwpFreezeLevel   = input.float(92.0, \"BBWP Freeze Level (%)\", minval=80.0, maxval=98.0, step=1.0, group=groupProtect, tooltip=\"Freeze ALL buys when BBWP exceeds this level\")\r\nmaxConsecBuys     = input.int(3, \"Max Consecutive Buys\", minval=1, maxval=10, group=groupProtect, tooltip=\"Maximum buys allowed without an intervening sell\")\r\n\r\n// Extreme Move Settings\r\ngroupExtreme      = \"Extreme Move Detection\"\r\nuseExtreme        = input.bool(true, \"Enable Extreme Move Detection\", group=groupExtreme, tooltip=\"Bypass cooldown when price penetrates bands by extreme amount\")\r\nextremePenetration = input.float(0.6, \"Extreme Penetration (% of ATR)\", minval=0.1, maxval=2.0, step=0.1, group=groupExtreme, tooltip=\"Price must exceed band by this much (as % of ATR) to trigger extreme signal\")\r\nextremeBypassCooldown = input.bool(true, \"Extreme Bypasses Cooldown\", group=groupExtreme, tooltip=\"Allow extreme signals even during cooldown period\")\r\nextremeBypassBBWP = input.bool(true, \"Extreme Bypasses BBWP Freeze\", group=groupExtreme, tooltip=\"Allow extreme buys even during BBWP freeze - Buy Counter still protects (max 3)\")\r\nextremeIntraBar   = input.bool(true, \"Extreme Fires Intra-Bar\", group=groupExtreme, tooltip=\"Fire extreme signals immediately when threshold hit (not waiting for candle close)\")\r\n\r\n// Divergence Settings\r\ngroupDivergence   = \"RSI Divergence\"\r\nuseDivergence     = input.bool(true, \"Enable RSI Divergence Detection\", group=groupDivergence)\r\ndivLookbackLeft   = input.int(5, \"Pivot Lookback Left\", minval=1, maxval=20, group=groupDivergence)\r\ndivLookbackRight  = input.int(5, \"Pivot Lookback Right\", minval=1, maxval=20, group=groupDivergence)\r\nshowDivergenceLines = input.bool(true, \"Show Divergence Lines on Chart\", group=groupDivergence)\r\nshowDivergenceLabels = input.bool(true, \"Show Divergence Labels\", group=groupDivergence)\r\nbullDivColor      = input.color(color.new(#00D9FF, 0), \"Bullish Divergence Line Color\", group=groupDivergence)\r\nbearDivColor      = input.color(color.new(#00D9FF, 0), \"Bearish Divergence Line Color\", group=groupDivergence)\r\nhiddenDivColor    = input.color(color.new(#9D4EDD, 0), \"Hidden Divergence Line Color\", group=groupDivergence)\r\n\r\n// Display\r\nshowShades        = input.bool(true, \"Show Shaded Bands\", group=groupDisplay)\r\nshowBands         = input.bool(true, \"Show Band Lines\", group=groupDisplay)\r\nshowPriceLabels   = input.bool(true, \"Show Entry/Exit Labels\", group=groupDisplay)\r\nshowInfoPanel     = input.bool(true, \"Show Info Panel\", group=groupDisplay)\r\nshowADXBar        = input.bool(true, \"Show ADX Bar\", group=groupDisplay)\r\nshowDebugInfo     = input.bool(false, \"Show Debug Info on Chart\", group=groupDisplay)\r\n\r\n// Money Line & Band Colors (based on slope direction)\r\nbullColor         = input.color(color.new(color.green, 0), \"ML/Band Bull Color\", group=groupDisplay, tooltip=\"Money Line and band color when slope is bullish\")\r\nbearColor         = input.color(color.new(color.red, 0), \"ML/Band Bear Color\", group=groupDisplay, tooltip=\"Money Line and band color when slope is bearish\")\r\nneutralColor      = input.color(color.new(color.yellow, 0), \"ML/Band Neutral Color\", group=groupDisplay, tooltip=\"Money Line and band color when slope is flat\")\r\n\r\n// ADX Bar Colors (based on trend state)\r\nadxStrongUpColor  = input.color(color.new(color.lime, 0), \"ADX Bar: Strong Uptrend\", group=groupDisplay)\r\nadxUptrendColor   = input.color(color.new(color.blue, 0), \"ADX Bar: Uptrend\", group=groupDisplay)\r\nadxNeutralColor   = input.color(color.new(color.orange, 0), \"ADX Bar: Neutral\", group=groupDisplay)\r\nadxDowntrendColor = input.color(color.new(color.red, 0), \"ADX Bar: Downtrend\", group=groupDisplay)\r\nadxStrongDnColor  = input.color(color.new(color.maroon, 0), \"ADX Bar: Strong Downtrend\", group=groupDisplay)\r\nadxRangingColor   = input.color(color.new(color.white, 0), \"ADX Bar: Ranging (ADX<15)\", group=groupDisplay)\r\n\r\n// ‚îÄ‚îÄ CORE CALCULATIONS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\r\nmoneyLine = ta.linreg(close, length, 0)\r\natrValue  = ta.atr(atrPeriod)\r\n[_, _, adxRaw] = ta.dmi(adxLen, diSmoothing)\r\nsadx = ta.sma(adxRaw, 3)\r\n\r\nmult = enableGrok and sadx > adxThresh ?\r\n     math.min(maxMult, atrMultiplier + (sadx - adxThresh)/(100 - adxThresh) * (maxMult - atrMultiplier))\r\n     : atrMultiplier\r\n\r\nupperBand = moneyLine + atrValue * mult\r\nlowerBand = moneyLine - atrValue * mult\r\n\r\n// ‚îÄ‚îÄ EXTREME BAND PENETRATION DETECTION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\r\n// Calculate how far price exceeded the band\r\nextremeThreshold = atrValue * extremePenetration\r\nupperPenetrationDepth = high - upperBand\r\nlowerPenetrationDepth = lowerBand - low\r\n\r\n// Extreme = price exceeded band by more than threshold\r\nisExtremeUpper = useExtreme and upperPenetrationDepth > extremeThreshold\r\nisExtremeLower = useExtreme and lowerPenetrationDepth > extremeThreshold\r\n\r\n// Band touch detection (for regular signals)\r\ntouchedUpperBand = high >= upperBand\r\ntouchedLowerBand = low <= lowerBand\r\n\r\navgSlope = nz(ta.sma(moneyLine - moneyLine[1], slopeLookback), 0)\r\ntrend = math.abs(avgSlope) < atrValue * neutralTolerance ? 0 : avgSlope > 0 ? 1 : -1\r\nlineColor = trend == 1 ? bullColor : trend == -1 ? bearColor : neutralColor\r\n\r\n// Shading\r\np1 = plot(showBands ? upperBand : na, color=color.gray, title=\"Upper Band\")\r\np2 = plot(showBands ? lowerBand : na, color=color.gray, title=\"Lower Band\")\r\nfillColor = showShades ? (trend == 1 ? color.new(bullColor, 80) : trend == -1 ? color.new(bearColor, 80) : color.new(neutralColor, 80)) : na\r\nfill(p1, p2, color=fillColor)\r\n\r\n// ‚îÄ‚îÄ TREND STRENGTH DETECTION (DI + OBV + ADX) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\r\n[plus_di, minus_di, adx_dmi] = ta.dmi(diPeriod, diPeriod)\r\ndiSpread = plus_di - minus_di\r\n\r\n// OBV trend confirmation\r\nobv = ta.obv\r\nobvMA = ta.sma(obv, obvMAPeriod)\r\nobvSlope = ta.sma(obv - obv[3], 3)\r\nobvBullish = obv > obvMA and obvSlope > 0\r\nobvBearish = obv < obvMA and obvSlope < 0\r\n\r\n// Combined Trend State - NOW REQUIRES ADX > adxStrongMin FOR STRONG TRENDS\r\nvar string trendState = \"NEUTRAL\"\r\n\r\nif diSpread > diStrongThresh and adx_dmi > adxStrongMin and (not useOBVConfirm or obvBullish)\r\n    trendState := \"STRONG UPTREND\"\r\nelse if diSpread > diWeakThresh and diSpread <= diStrongThresh\r\n    trendState := \"UPTREND\"\r\nelse if diSpread < -diStrongThresh and adx_dmi > adxStrongMin and (not useOBVConfirm or obvBearish)\r\n    trendState := \"STRONG DOWNTREND\"\r\nelse if diSpread < -diWeakThresh and diSpread >= -diStrongThresh\r\n    trendState := \"DOWNTREND\"\r\nelse\r\n    trendState := \"NEUTRAL\"\r\n\r\n// ‚îÄ‚îÄ FISHER TRANSFORM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\r\nmid = (high + low) / 2\r\nvar float val = 0.0\r\nvar float fish = 0.0\r\nh = ta.highest(mid, fisherLength)\r\nl = ta.lowest(mid, fisherLength)\r\nval := 0.66 * ((mid - l) / math.max(h - l, 0.001) - 0.5) + 0.67 * nz(val[1])\r\nval := math.min(math.max(val, -0.999), 0.999)\r\nfish := 0.5 * math.log((1 + val) / (1 - val)) + 0.5 * nz(fish[1])\r\nfisher = fish\r\n\r\n// ‚îÄ‚îÄ AROON ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\r\nbarsSinceHigh = ta.highestbars(high, aroonLength)\r\nbarsSinceLow = ta.lowestbars(low, aroonLength)\r\naroonUp   = 100.0 * (aroonLength + barsSinceHigh) / aroonLength\r\naroonDown = 100.0 * (aroonLength + barsSinceLow) / aroonLength\r\n\r\n// ‚îÄ‚îÄ RSI (for display only) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\r\nrsi = ta.rsi(close, 14)\r\n\r\n// ‚îÄ‚îÄ RSI DIVERGENCE DETECTION (SIMPLIFIED) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\r\n// Pivot detection\r\nrsiPivotLow = ta.pivotlow(rsi, divLookbackLeft, divLookbackRight)\r\nrsiPivotHigh = ta.pivothigh(rsi, divLookbackLeft, divLookbackRight)\r\npricePivotLow = ta.pivotlow(low, divLookbackLeft, divLookbackRight)\r\npricePivotHigh = ta.pivothigh(high, divLookbackLeft, divLookbackRight)\r\n\r\n// Track previous pivot values using valuewhen\r\nprevRsiLow = ta.valuewhen(not na(rsiPivotLow), rsiPivotLow, 1)\r\nprevPriceLow = ta.valuewhen(not na(pricePivotLow), pricePivotLow, 1)\r\nprevRsiHigh = ta.valuewhen(not na(rsiPivotHigh), rsiPivotHigh, 1)\r\nprevPriceHigh = ta.valuewhen(not na(pricePivotHigh), pricePivotHigh, 1)\r\n\r\n// Current pivot values\r\ncurrRsiLow = ta.valuewhen(not na(rsiPivotLow), rsiPivotLow, 0)\r\ncurrPriceLow = ta.valuewhen(not na(pricePivotLow), pricePivotLow, 0)\r\ncurrRsiHigh = ta.valuewhen(not na(rsiPivotHigh), rsiPivotHigh, 0)\r\ncurrPriceHigh = ta.valuewhen(not na(pricePivotHigh), pricePivotHigh, 0)\r\n\r\n// Track bar indices for line drawing\r\nprevPriceLowBar = ta.valuewhen(not na(pricePivotLow), bar_index - divLookbackRight, 1)\r\ncurrPriceLowBar = ta.valuewhen(not na(pricePivotLow), bar_index - divLookbackRight, 0)\r\nprevPriceHighBar = ta.valuewhen(not na(pricePivotHigh), bar_index - divLookbackRight, 1)\r\ncurrPriceHighBar = ta.valuewhen(not na(pricePivotHigh), bar_index - divLookbackRight, 0)\r\n\r\n// Detect divergences\r\nvar string divergenceType = \"NONE\"\r\nvar int divergenceBar = 0\r\nvar bool bullishDiv = false\r\nvar bool bearishDiv = false\r\nvar bool hiddenBullDiv = false\r\nvar bool hiddenBearDiv = false\r\n\r\n// Reset divergence flags\r\nbullishDiv := false\r\nbearishDiv := false\r\nhiddenBullDiv := false\r\nhiddenBearDiv := false\r\n\r\nif useDivergence\r\n    // Check for bullish divergence (price lower low, RSI higher low)\r\n    if not na(rsiPivotLow) and not na(pricePivotLow)\r\n        if not na(prevRsiLow) and not na(prevPriceLow)\r\n            // Regular Bullish: Price lower low, RSI higher low\r\n            if currPriceLow < prevPriceLow and currRsiLow > prevRsiLow\r\n                bullishDiv := true\r\n                divergenceType := \"BULLISH\"\r\n                divergenceBar := bar_index\r\n                // Draw line on price\r\n                if showDivergenceLines\r\n                    line.new(prevPriceLowBar, prevPriceLow, currPriceLowBar, currPriceLow, color=bullDivColor, width=2, style=line.style_solid)\r\n            \r\n            // Hidden Bullish: Price higher low, RSI lower low\r\n            if currPriceLow > prevPriceLow and currRsiLow < prevRsiLow\r\n                hiddenBullDiv := true\r\n                divergenceType := \"HIDDEN BULL\"\r\n                divergenceBar := bar_index\r\n                // Draw line on price\r\n                if showDivergenceLines\r\n                    line.new(prevPriceLowBar, prevPriceLow, currPriceLowBar, currPriceLow, color=hiddenDivColor, width=2, style=line.style_dashed)\r\n    \r\n    // Check for bearish divergence (price higher high, RSI lower high)\r\n    if not na(rsiPivotHigh) and not na(pricePivotHigh)\r\n        if not na(prevRsiHigh) and not na(prevPriceHigh)\r\n            // Regular Bearish: Price higher high, RSI lower high\r\n            if currPriceHigh > prevPriceHigh and currRsiHigh < prevRsiHigh\r\n                bearishDiv := true\r\n                divergenceType := \"BEARISH\"\r\n                divergenceBar := bar_index\r\n                // Draw line on price\r\n                if showDivergenceLines\r\n                    line.new(prevPriceHighBar, prevPriceHigh, currPriceHighBar, currPriceHigh, color=bearDivColor, width=2, style=line.style_solid)\r\n            \r\n            // Hidden Bearish: Price lower high, RSI higher high\r\n            if currPriceHigh < prevPriceHigh and currRsiHigh > prevRsiHigh\r\n                hiddenBearDiv := true\r\n                divergenceType := \"HIDDEN BEAR\"\r\n                divergenceBar := bar_index\r\n                // Draw line on price\r\n                if showDivergenceLines\r\n                    line.new(prevPriceHighBar, prevPriceHigh, currPriceHighBar, currPriceHigh, color=hiddenDivColor, width=2, style=line.style_dashed)\r\n\r\n// Track recent divergence for display (within last 10 bars)\r\nrecentDivergence = bar_index - divergenceBar <= 10\r\ndisplayDivergence = recentDivergence ? divergenceType : \"NONE\"\r\n\r\n// Plot divergence markers (small, no text)\r\nplotshape(showDivergenceLabels and bullishDiv, title=\"Bullish Divergence\", location=location.belowbar, color=#00D9FF, style=shape.diamond, size=size.tiny)\r\nplotshape(showDivergenceLabels and hiddenBullDiv, title=\"Hidden Bullish Divergence\", location=location.belowbar, color=#9D4EDD, style=shape.diamond, size=size.tiny)\r\nplotshape(showDivergenceLabels and bearishDiv, title=\"Bearish Divergence\", location=location.abovebar, color=#00D9FF, style=shape.diamond, size=size.tiny)\r\nplotshape(showDivergenceLabels and hiddenBearDiv, title=\"Hidden Bearish Divergence\", location=location.abovebar, color=#9D4EDD, style=shape.diamond, size=size.tiny)\r\n\r\n// ‚îÄ‚îÄ ADX BAR (configurable colors based on trend state) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\r\n// Priority: trendState first, then ADX ranging check\r\nadxBarCol = switch trendState\r\n    \"STRONG UPTREND\" => adxStrongUpColor\r\n    \"UPTREND\" => adxUptrendColor\r\n    \"NEUTRAL\" => adx_dmi < 15 ? adxRangingColor : adxNeutralColor\r\n    \"DOWNTREND\" => adxDowntrendColor\r\n    \"STRONG DOWNTREND\" => adxStrongDnColor\r\n    => adxNeutralColor\r\n\r\n// ‚îÄ‚îÄ BBWP - CASCADE PROTECTION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\r\n// BBWP Calculation - Bollinger Band Width Percentile\r\nbbwpBasis = ta.sma(close, bbwpLength)\r\nbbwpDev = ta.stdev(close, bbwpLength)\r\nbbwpWidth = (bbwpBasis + 2 * bbwpDev - (bbwpBasis - 2 * bbwpDev)) / bbwpBasis\r\nbbwp = ta.percentrank(bbwpWidth, bbwpLookback)\r\n\r\n// Cascade Protection Status\r\nbbwpFrozen = useCascadeProtect and bbwp > bbwpFreezeLevel\r\n\r\n// ‚îÄ‚îÄ DYNAMIC FISHER THRESHOLDS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\r\nfloat dynFisherBuy = switch trendState\r\n    \"STRONG UPTREND\" => baseFisherBuy + 0.8      // -1.0 (easier to trigger)\r\n    \"UPTREND\" => baseFisherBuy + 0.4             // -1.4\r\n    \"NEUTRAL\" => baseFisherBuy                    // -1.8\r\n    \"DOWNTREND\" => baseFisherBuy - 0.4           // -2.2\r\n    \"STRONG DOWNTREND\" => baseFisherBuy - 0.7   // -2.5\r\n    => baseFisherBuy\r\n\r\nfloat dynFisherSell = switch trendState\r\n    \"STRONG UPTREND\" => baseFisherSell + 0.7     // 2.5 (hardest to trigger - let winners run)\r\n    \"UPTREND\" => baseFisherSell + 0.4            // 2.2 (harder to trigger)\r\n    \"NEUTRAL\" => baseFisherSell                   // 1.8\r\n    \"DOWNTREND\" => baseFisherSell - 0.4          // 1.4\r\n    \"STRONG DOWNTREND\" => baseFisherSell - 0.8  // 1.0 (easiest to trigger - exit fast)\r\n    => baseFisherSell\r\n\r\n// ‚îÄ‚îÄ DYNAMIC AROON THRESHOLDS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\r\n// Aroon Up threshold for BUY (must be BELOW this)\r\nfloat dynAroonUpBuy = switch trendState\r\n    \"STRONG UPTREND\" => 50\r\n    \"UPTREND\" => 40\r\n    \"NEUTRAL\" => baseAroonUpBuy\r\n    \"DOWNTREND\" => 20\r\n    \"STRONG DOWNTREND\" => 15\r\n    => baseAroonUpBuy\r\n\r\n// Aroon Down threshold for BUY (must be ABOVE this)\r\nfloat dynAroonDownBuy = switch trendState\r\n    \"STRONG UPTREND\" => 50\r\n    \"UPTREND\" => 60\r\n    \"NEUTRAL\" => baseAroonDownBuy\r\n    \"DOWNTREND\" => 80\r\n    \"STRONG DOWNTREND\" => 90\r\n    => baseAroonDownBuy\r\n\r\n// Aroon Up threshold for SELL (must be ABOVE this)\r\nfloat dynAroonUpSell = switch trendState\r\n    \"STRONG UPTREND\" => 90\r\n    \"UPTREND\" => 85\r\n    \"NEUTRAL\" => baseAroonUpSell\r\n    \"DOWNTREND\" => 60\r\n    \"STRONG DOWNTREND\" => 50\r\n    => baseAroonUpSell\r\n\r\n// Aroon Down threshold for SELL (must be BELOW this)\r\nfloat dynAroonDownSell = switch trendState\r\n    \"STRONG UPTREND\" => 15\r\n    \"UPTREND\" => 20\r\n    \"NEUTRAL\" => baseAroonDownSell\r\n    \"DOWNTREND\" => 40\r\n    \"STRONG DOWNTREND\" => 50\r\n    => baseAroonDownSell\r\n\r\n// ‚îÄ‚îÄ SIGNAL LOGIC WITH DYNAMIC THRESHOLDS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\r\nfisherBuyCondition  = fisher < dynFisherBuy\r\nfisherSellCondition = fisher > dynFisherSell\r\n\r\naroonBuyCondition  = aroonUp < dynAroonUpBuy and aroonDown > dynAroonDownBuy\r\naroonSellCondition = aroonUp > dynAroonUpSell and aroonDown < dynAroonDownSell\r\n\r\n// Raw signals (before cooldown) - includes band touch OR indicator conditions\r\nbuySignalRaw  = fisherBuyCondition and aroonBuyCondition or touchedLowerBand\r\nsellSignalRaw = fisherSellCondition and aroonSellCondition or touchedUpperBand\r\n\r\n// ‚îÄ‚îÄ COOLDOWN LOGIC + CASCADE PROTECTION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\r\nvar int lastBuyBar = -100\r\nvar int lastSellBar = -100\r\nvar int barsSinceBuy = 100\r\nvar int barsSinceSell = 100\r\nvar int consecutiveBuys = 0  // Track consecutive buys without a sell\r\nvar int lastExtremeBuyBar = -100   // Track extreme signals separately\r\nvar int lastExtremeSellBar = -100\r\n\r\nbarsSinceBuy := bar_index - lastBuyBar\r\nbarsSinceSell := bar_index - lastSellBar\r\n\r\n// Normal cooldown check\r\nnormalBuyCooldown = (not useCooldown) or (barsSinceBuy > cooldownBars and (not cooldownAfterSell or barsSinceSell > cooldownBars))\r\nnormalSellCooldown = (not useCooldown) or (barsSinceSell > cooldownBars and (not cooldownAfterBuy or barsSinceBuy > cooldownBars))\r\n\r\n// ‚îÄ‚îÄ CASCADE PROTECTION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\r\n// Protection 1: BBWP Freeze - Block ALL buys during extreme volatility spikes\r\n// Protection 2: Consecutive Buy Limit - Prevent averaging down into oblivion\r\nbuyCounterOK = (not useCascadeProtect) or (consecutiveBuys < maxConsecBuys)\r\n\r\n// ‚îÄ‚îÄ EXTREME INTRA-BAR SIGNALS (Independent Path) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\r\n// These fire purely on band penetration depth, bypassing Fisher/Aroon requirements\r\nextremeBuyAllowed = buyCounterOK and (not bbwpFrozen or extremeBypassBBWP) and (normalBuyCooldown or extremeBypassCooldown)\r\nextremeSellAllowed = normalSellCooldown or extremeBypassCooldown\r\n\r\n// Extreme signals - fire when penetration threshold hit (no Fisher/Aroon needed)\r\nisExtremeBuy = isExtremeLower and extremeBuyAllowed and (bar_index > lastExtremeBuyBar)\r\nisExtremeSell = isExtremeUpper and extremeSellAllowed and (bar_index > lastExtremeSellBar)\r\n\r\n// ‚îÄ‚îÄ REGULAR SIGNALS (Close-based) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\r\n// Extreme moves can bypass cooldown for regular signals too\r\nbuyCooldownOK = normalBuyCooldown or (extremeBypassCooldown and isExtremeLower)\r\nsellCooldownOK = normalSellCooldown or (extremeBypassCooldown and isExtremeUpper)\r\n\r\n// BBWP freeze - extreme can optionally bypass\r\nbbwpOK = not bbwpFrozen or (extremeBypassBBWP and isExtremeLower)\r\n\r\n// Combined buy protection for regular signals\r\nbuyAllowed = buyCooldownOK and bbwpOK and buyCounterOK\r\n\r\n// Final filtered signals (for close-based alerts)\r\n// Exclude if extreme intra-bar already fired this bar\r\nbuySignalFiltered = buySignalRaw and buyAllowed and not (isExtremeBuy and extremeIntraBar)\r\nsellSignalFiltered = sellSignalRaw and sellCooldownOK and not (isExtremeSell and extremeIntraBar)\r\n\r\n// Update tracking variables\r\nif isExtremeBuy and extremeIntraBar\r\n    lastExtremeBuyBar := bar_index\r\n    lastBuyBar := bar_index\r\n    consecutiveBuys := consecutiveBuys + 1\r\n\r\nif isExtremeSell and extremeIntraBar\r\n    lastExtremeSellBar := bar_index\r\n    lastSellBar := bar_index\r\n    consecutiveBuys := 0\r\n\r\nif buySignalFiltered\r\n    lastBuyBar := bar_index\r\n    consecutiveBuys := consecutiveBuys + 1  // Increment buy counter\r\n    \r\nif sellSignalFiltered\r\n    lastSellBar := bar_index\r\n    consecutiveBuys := 0  // Reset buy counter on any sell\r\n\r\n// Protection status for display\r\ncooldownActive = useCooldown and (barsSinceBuy <= cooldownBars or barsSinceSell <= cooldownBars) and not (isExtremeBuy or isExtremeSell)\r\nbarsRemaining = math.max(0, cooldownBars - math.min(barsSinceBuy, barsSinceSell))\r\ncascadeFrozen = bbwpFrozen or (useCascadeProtect and consecutiveBuys >= maxConsecBuys)\r\n\r\n// Bright Blue Candle on Signal\r\nbarcolor(buySignalFiltered or sellSignalFiltered or (isExtremeBuy and extremeIntraBar) or (isExtremeSell and extremeIntraBar) ? color.new(#0099FF, 0) : na, title=\"Signal Candle\")\r\n\r\n// ADX Bar at bottom\r\nplotshape(showADXBar, location=location.bottom, color=adxBarCol, style=shape.circle, size=size.tiny, title=\"ADX Bar\")\r\n\r\n// ‚îÄ‚îÄ PLOTTING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\r\nplot(moneyLine, color=lineColor, linewidth=2, title=\"Money Line\")\r\n\r\n// Labels with price and BUY COUNT\r\nif showPriceLabels\r\n    // Extreme intra-bar buy signals (separate path)\r\n    if isExtremeBuy and extremeIntraBar\r\n        labelOffset = low - (atrValue * 0.5)\r\n        buyNum = consecutiveBuys  // Already incremented above\r\n        label.new(bar_index, labelOffset, \"EXTREME BUY \" + str.tostring(buyNum) + \"/\" + str.tostring(maxConsecBuys) + \": \" + str.tostring(close, \"#.##\"), \r\n                  style=label.style_label_up, color=#00BFFF, textcolor=color.white, size=size.normal)\r\n    // Extreme intra-bar sell signals\r\n    if isExtremeSell and extremeIntraBar\r\n        labelOffset = high + (atrValue * 0.5)\r\n        label.new(bar_index, labelOffset, \"EXTREME SELL: \" + str.tostring(close, \"#.##\"), \r\n                  style=label.style_label_down, color=color.fuchsia, textcolor=color.white, size=size.normal)\r\n    // Regular buy signals (at close)\r\n    if buySignalFiltered\r\n        labelOffset = low - (atrValue * 0.5)\r\n        buyNum = consecutiveBuys  // Already incremented above\r\n        label.new(bar_index, labelOffset, \"BUY \" + str.tostring(buyNum) + \"/\" + str.tostring(maxConsecBuys) + \": \" + str.tostring(close, \"#.##\"), \r\n                  style=label.style_label_up, color=color.green, textcolor=color.white, size=size.normal)\r\n    // Regular sell signals (at close)\r\n    if sellSignalFiltered\r\n        labelOffset = high + (atrValue * 0.5)\r\n        label.new(bar_index, labelOffset, \"SELL: \" + str.tostring(close, \"#.##\"), \r\n                  style=label.style_label_down, color=color.red, textcolor=color.white, size=size.normal)\r\n\r\n// Debug info\r\nif showDebugInfo and barstate.islast\r\n    var table debugTable = table.new(position.bottom_left, 2, 16, border_width=1)\r\n    table.cell(debugTable, 0, 0, \"Trend State\", bgcolor=color.gray, text_color=color.white)\r\n    table.cell(debugTable, 1, 0, trendState, text_color=color.lime)\r\n    table.cell(debugTable, 0, 1, \"DI Spread\", bgcolor=color.gray, text_color=color.white)\r\n    table.cell(debugTable, 1, 1, str.tostring(diSpread, \"#.#\"))\r\n    table.cell(debugTable, 0, 2, \"ADX\", bgcolor=color.gray, text_color=color.white)\r\n    table.cell(debugTable, 1, 2, str.tostring(adx_dmi, \"#.#\") + \" (Strong req: >\" + str.tostring(adxStrongMin) + \")\")\r\n    table.cell(debugTable, 0, 3, \"OBV Trend\", bgcolor=color.gray, text_color=color.white)\r\n    table.cell(debugTable, 1, 3, obvBullish ? \"BULLISH\" : obvBearish ? \"BEARISH\" : \"NEUTRAL\")\r\n    table.cell(debugTable, 0, 4, \"Fisher\", bgcolor=color.gray, text_color=color.white)\r\n    table.cell(debugTable, 1, 4, str.tostring(fisher, \"#.##\") + \" (Buy<\" + str.tostring(dynFisherBuy, \"#.#\") + \", Sell>\" + str.tostring(dynFisherSell, \"#.#\") + \")\")\r\n    table.cell(debugTable, 0, 5, \"Aroon Up\", bgcolor=color.gray, text_color=color.white)\r\n    table.cell(debugTable, 1, 5, str.tostring(aroonUp, \"#.#\") + \" (Buy<\" + str.tostring(dynAroonUpBuy, \"#\") + \", Sell>\" + str.tostring(dynAroonUpSell, \"#\") + \")\")\r\n    table.cell(debugTable, 0, 6, \"Aroon Down\", bgcolor=color.gray, text_color=color.white)\r\n    table.cell(debugTable, 1, 6, str.tostring(aroonDown, \"#.#\") + \" (Buy>\" + str.tostring(dynAroonDownBuy, \"#\") + \", Sell<\" + str.tostring(dynAroonDownSell, \"#\") + \")\")\r\n    table.cell(debugTable, 0, 7, \"Fisher Cond\", bgcolor=color.gray, text_color=color.white)\r\n    table.cell(debugTable, 1, 7, \"Buy: \" + str.tostring(fisherBuyCondition) + \" | Sell: \" + str.tostring(fisherSellCondition))\r\n    table.cell(debugTable, 0, 8, \"Aroon Cond\", bgcolor=color.gray, text_color=color.white)\r\n    table.cell(debugTable, 1, 8, \"Buy: \" + str.tostring(aroonBuyCondition) + \" | Sell: \" + str.tostring(aroonSellCondition))\r\n    table.cell(debugTable, 0, 9, \"Cooldown\", bgcolor=color.gray, text_color=color.white)\r\n    table.cell(debugTable, 1, 9, cooldownActive ? str.tostring(barsRemaining) + \" bars left\" : \"Ready\", text_color=cooldownActive ? color.orange : color.lime)\r\n    table.cell(debugTable, 0, 10, \"EXTREME Lower\", bgcolor=color.fuchsia, text_color=color.white)\r\n    table.cell(debugTable, 1, 10, str.tostring(isExtremeLower) + \" (\" + str.tostring(lowerPenetrationDepth, \"#.##\") + \")\", bgcolor=isExtremeLower ? #00BFFF : color.black, text_color=color.white)\r\n    table.cell(debugTable, 0, 11, \"EXTREME Upper\", bgcolor=color.fuchsia, text_color=color.white)\r\n    table.cell(debugTable, 1, 11, str.tostring(isExtremeUpper) + \" (\" + str.tostring(upperPenetrationDepth, \"#.##\") + \")\", bgcolor=isExtremeUpper ? color.fuchsia : color.black, text_color=color.white)\r\n    table.cell(debugTable, 0, 12, \"Raw Signal\", bgcolor=color.gray, text_color=color.white)\r\n    table.cell(debugTable, 1, 12, (buySignalRaw ? \"BUY \" : \"\") + (sellSignalRaw ? \"SELL\" : \"\") + (not buySignalRaw and not sellSignalRaw ? \"NONE\" : \"\"))\r\n    table.cell(debugTable, 0, 13, \"Filtered Signal\", bgcolor=color.gray, text_color=color.white)\r\n    table.cell(debugTable, 1, 13, (buySignalFiltered ? \"BUY \" : \"\") + (sellSignalFiltered ? \"SELL\" : \"\") + (not buySignalFiltered and not sellSignalFiltered ? \"NONE\" : \"\"))\r\n    table.cell(debugTable, 0, 14, \"Trigger Type\", bgcolor=color.blue, text_color=color.white)\r\n    table.cell(debugTable, 1, 14, isExtremeBuy ? \"EXTREME BUY\" : isExtremeSell ? \"EXTREME SELL\" : \"NORMAL\", text_color=isExtremeBuy ? #00BFFF : isExtremeSell ? color.fuchsia : color.lime)\r\n\r\n// ‚îÄ‚îÄ INFO PANEL (Compact) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\r\nvar table infoTable = table.new(position.top_right, 2, 10, border_width=0, frame_width=1, bgcolor=color.new(color.black, 85))\r\n\r\n// Trend state colors\r\ntrendBg = switch trendState\r\n    \"STRONG UPTREND\" => color.green\r\n    \"UPTREND\" => color.lime\r\n    \"NEUTRAL\" => color.gray\r\n    \"DOWNTREND\" => color.orange\r\n    \"STRONG DOWNTREND\" => color.red\r\n    => color.gray\r\ntrendTextColor = trendState == \"UPTREND\" or trendState == \"NEUTRAL\" ? color.black : color.white\r\n\r\n// Abbreviated trend display\r\ntrendAbbrev = switch trendState\r\n    \"STRONG UPTREND\" => \"‚ñ≤‚ñ≤ STRONG UP\"\r\n    \"UPTREND\" => \"‚ñ≤ UPTREND\"\r\n    \"NEUTRAL\" => \"NEUTRAL\"\r\n    \"DOWNTREND\" => \"‚ñº DOWNTREND\"\r\n    \"STRONG DOWNTREND\" => \"‚ñº‚ñº STRONG DN\"\r\n    => \"NEUTRAL\"\r\n\r\n// ADX market state\r\nadxState = adx_dmi < 15 ? \"‚Üí RANGE\" : adx_dmi <= 24 ? \"‚Üí FLAT\" : \"‚Üí TREND\"\r\nadxBg = adx_dmi < 15 ? color.white : adx_dmi <= 24 ? color.yellow : color.blue\r\nadxTextColor = adx_dmi > 24 ? color.white : color.black\r\n\r\n// Divergence abbreviated\r\ndivAbbrev = switch displayDivergence\r\n    \"BULLISH\" => \"REG BULL\"\r\n    \"HIDDEN BULL\" => \"HID BULL\"\r\n    \"BEARISH\" => \"REG BEAR\"\r\n    \"HIDDEN BEAR\" => \"HID BEAR\"\r\n    => \"‚Äî\"\r\ndivColor = displayDivergence == \"BULLISH\" or displayDivergence == \"HIDDEN BULL\" ? color.lime : displayDivergence == \"BEARISH\" or displayDivergence == \"HIDDEN BEAR\" ? color.red : color.gray\r\ndivTextColor = divColor == color.gray ? color.white : color.black\r\n\r\n// BBWP status\r\nbbwpBg = bbwpFrozen ? color.red : color.green\r\nbbwpText = bbwpFrozen ? \"FROZEN\" : \"OK\"\r\n\r\n// Buy counter\r\nbuyCountBg = consecutiveBuys >= maxConsecBuys ? color.red : consecutiveBuys >= (maxConsecBuys - 1) ? color.orange : color.green\r\n\r\n// Fisher color\r\nfisherBg = fisher <= dynFisherBuy ? color.lime : fisher >= dynFisherSell ? color.red : color.gray\r\nfisherTextColor = fisherBg == color.gray ? color.white : color.black\r\n\r\n// Aroon display\r\naroonBg = aroonBuyCondition ? color.lime : aroonSellCondition ? color.red : color.gray\r\naroonTextColor = aroonBg == color.gray ? color.white : color.black\r\n\r\n// Cooldown\r\ncooldownBg = cooldownActive ? color.orange : color.green\r\ncooldownText = useCooldown ? (cooldownActive ? str.tostring(barsRemaining) + \"/\" + str.tostring(cooldownBars) : \"READY\") : \"OFF\"\r\n\r\nmoneyLineTextColor = trend == 0 ? color.black : color.white\r\n\r\nif barstate.islast and showInfoPanel\r\n    // Row 0: Header - ML Cipher | Trend State\r\n    table.cell(infoTable, 0, 0, \"ML Cipher\", text_color=color.white, bgcolor=color.new(color.gray, 50), text_size=size.small)\r\n    table.cell(infoTable, 1, 0, trendAbbrev, text_color=trendTextColor, bgcolor=trendBg, text_size=size.small)\r\n    \r\n    // Row 1: Divergence\r\n    table.cell(infoTable, 0, 1, \"Divergence\", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)\r\n    table.cell(infoTable, 1, 1, divAbbrev, text_color=divTextColor, bgcolor=divColor, text_size=size.small)\r\n    \r\n    // Row 2: BBWP\r\n    table.cell(infoTable, 0, 2, \"BBWP \" + str.tostring(bbwp, \"#\") + \"%\", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)\r\n    table.cell(infoTable, 1, 2, bbwpText, text_color=color.white, bgcolor=bbwpBg, text_size=size.small)\r\n    \r\n    // Row 3: Buy Counter\r\n    table.cell(infoTable, 0, 3, \"Buy Counter\", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)\r\n    table.cell(infoTable, 1, 3, str.tostring(consecutiveBuys) + \"/\" + str.tostring(maxConsecBuys), text_color=color.white, bgcolor=buyCountBg, text_size=size.small)\r\n    \r\n    // Row 4: ADX\r\n    table.cell(infoTable, 0, 4, \"ADX \" + str.tostring(adx_dmi, \"#\"), text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)\r\n    table.cell(infoTable, 1, 4, adxState, text_color=adxTextColor, bgcolor=adxBg, text_size=size.small)\r\n    \r\n    // Row 5: Aroon\r\n    table.cell(infoTable, 0, 5, \"Aroon\", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)\r\n    table.cell(infoTable, 1, 5, \"‚Üë\" + str.tostring(aroonUp, \"#\") + \" ‚Üì\" + str.tostring(aroonDown, \"#\"), text_color=aroonTextColor, bgcolor=aroonBg, text_size=size.small)\r\n    \r\n    // Row 6: Fisher\r\n    table.cell(infoTable, 0, 6, \"Fisher\", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)\r\n    table.cell(infoTable, 1, 6, str.tostring(fisher, \"#.##\"), text_color=fisherTextColor, bgcolor=fisherBg, text_size=size.small)\r\n    \r\n    // Row 7: Cooldown\r\n    table.cell(infoTable, 0, 7, \"Cooldown\", text_color=color.white, bgcolor=color.new(color.gray, 70), text_size=size.small)\r\n    table.cell(infoTable, 1, 7, cooldownText, text_color=color.white, bgcolor=cooldownBg, text_size=size.small)\r\n    \r\n    // Row 8: BUY thresholds\r\n    table.cell(infoTable, 0, 8, \"BUY @\", text_color=color.white, bgcolor=color.green, text_size=size.small)\r\n    table.cell(infoTable, 1, 8, \"F<\" + str.tostring(dynFisherBuy, \"#.#\") + \" A<\" + str.tostring(dynAroonUpBuy, \"#\"), text_color=color.white, bgcolor=color.green, text_size=size.small)\r\n    \r\n    // Row 9: SELL thresholds\r\n    table.cell(infoTable, 0, 9, \"SELL @\", text_color=color.white, bgcolor=color.red, text_size=size.small)\r\n    table.cell(infoTable, 1, 9, \"F>\" + str.tostring(dynFisherSell, \"#.#\") + \" A>\" + str.tostring(dynAroonUpSell, \"#\"), text_color=color.white, bgcolor=color.red, text_size=size.small)\r\n\r\n// ‚îÄ‚îÄ ALERTS (Simple text alerts only - TradingView compliant) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\r\nalertcondition(buySignalFiltered, title=\"ML Cipher BUY\", message=\"MoneyLine Cipher BUY Signal on {{ticker}} at {{close}}\")\r\nalertcondition(sellSignalFiltered, title=\"ML Cipher SELL\", message=\"MoneyLine Cipher SELL Signal on {{ticker}} at {{close}}\")\r\nalertcondition(isExtremeBuy and extremeIntraBar, title=\"ML Cipher EXTREME BUY\", message=\"MoneyLine Cipher EXTREME BUY on {{ticker}} at {{close}}\")\r\nalertcondition(isExtremeSell and extremeIntraBar, title=\"ML Cipher EXTREME SELL\", message=\"MoneyLine Cipher EXTREME SELL on {{ticker}} at {{close}}\")\r\nalertcondition(bbwpFrozen and not bbwpFrozen[1], title=\"BBWP Freeze Active\", message=\"BBWP exceeded freeze threshold on {{ticker}}\")\r\nalertcondition(consecutiveBuys >= maxConsecBuys and consecutiveBuys[1] < maxConsecBuys, title=\"Max Consecutive Buys\", message=\"Maximum consecutive buys reached on {{ticker}}\")\r\n"
  },
  "https://www.tradingview.com/script/C44vegyH-RSI-Divergence-bsTzd/": {
    "id": 20088378,
    "url": "https://www.tradingview.com/script/C44vegyH-RSI-Divergence-bsTzd/",
    "name": "RSI Divergence bsTzd",
    "description": "This indicator automatically detects bullish and bearish RSI divergences by comparing swing highs and lows in price against momentum shifts on the Relative Strength Index. It identifies both regular divergences, which signal potential trend reversals, and hidden divergences, which often confirm trend continuation.\nAll divergences are plotted directly on the chart using clean, non-repainting swing-point logic so signals only appear after pivots are confirmed.\n\nThe goal of the tool is to help traders quickly spot early momentum shifts that are otherwise difficult to see in real-time‚Äîespecially during fast intraday moves. By combining price structure with RSI behavior, the indicator offers high-quality signals designed to improve entry timing, stop placement, and overall trend analysis.\n\nKey Features\n\nAutomatic bullish & bearish regular divergences\n\nAutomatic bullish & bearish hidden divergences\n\nUses confirmed swing pivots to avoid repainting\n\nWorks on all assets and all timeframes\n\nClean visual markers for fast decision-making\n\nHelps identify momentum exhaustion, trend continuation, and potential reversals\n\nUseful for scalping, day trading, and swing trading setups",
    "author_name": "bsTzd-BG",
    "likes_count": 19,
    "comments_count": 0,
    "views_count": 0,
    "created_at": "2025-12-12T03:57:04+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "NASDAQ:RR",
      "full_name": "NASDAQ:RR",
      "short_name": "RR",
      "exchange": "NASDAQ",
      "type": "stock",
      "logo_id": "richtech-robotics",
      "currency_logo_id": "country/US",
      "base_currency_logo_id": null,
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/richtech-robotics.svg"
      ],
      "interval": "1D",
      "direction": 0,
      "badge": {
        "label": "NASDAQ:RR",
        "url": "/symbols/NASDAQ-RR/"
      }
    },
    "created": "2025-12-12",
    "updated": "2025-12-12",
    "source": "//@version=6\r\nindicator(\"RSI Divergence (Clean Pivots) ‚Äî v1.2\", \"RSIDiv+\", overlay=false, max_bars_back=2000, max_labels_count=300, max_lines_count=300)\r\n\r\n//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Input Groups ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ//\r\ngrp_rsi  = \"RSI Settings\"\r\ngrp_piv  = \"Pivot Settings\"\r\ngrp_div  = \"Divergence Logic\"\r\ngrp_vis  = \"Visuals\"\r\ngrp_ping = \"Pings & Alerts\"\r\n\r\n//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Inputs ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ//\r\n// RSI\r\nlen      = input.int(9, \"RSI Length\", minval=2, group=grp_rsi)\r\nsrc      = input.source(close, \"RSI Source\", group=grp_rsi)\r\n\r\n// Pivots\r\nlbL      = input.int(2, \"Pivot Left\", minval=1, group=grp_piv)\r\nlbR      = input.int(2, \"Pivot Right\", minval=1, group=grp_piv)\r\nminBars  = input.int(5, \"Min Bars Between Pivots\", minval=1, group=grp_piv)\r\nmaxBars  = input.int(60, \"Max Bars Between Pivots\", minval=2, group=grp_piv)\r\n\r\n// Divergence filters\r\nshowReg  = input.bool(true, \"Show Regular Divergences\", group=grp_div)\r\nshowHid  = input.bool(true, \"Show Hidden Divergences\", group=grp_div)\r\n\r\n// Visual options\r\nshowObOs     = input.bool(true, \"Show OB / OS Levels\", group=grp_vis)\r\nobLevel      = input.float(70.0, \"Overbought Level\", step=0.1, group=grp_vis)\r\nosLevel      = input.float(30.0, \"Oversold Level\", step=0.1, group=grp_vis)\r\nmidLevel     = input.float(50.0, \"Midline Level\", step=0.1, group=grp_vis)\r\nrsiLineWidth = input.int(2, \"RSI Line Width\", minval=1, maxval=4, group=grp_vis)\r\n\r\nshowLabels   = input.bool(true, \"Show Divergence Labels\", group=grp_vis)\r\nlabelSize    = input.string(\"tiny\", \"Label Size\", options=[\"tiny\",\"small\",\"normal\",\"large\",\"huge\"], group=grp_vis)\r\n\r\nshowDivLines = input.bool(true, \"Show Divergence Connector Lines\", group=grp_vis)\r\nlineWidth    = input.int(2, \"Divergence Line Width\", minval=1, maxval=5, group=grp_vis)\r\n\r\n// Ping / alert options\r\nshowPings    = input.bool(true, \"Show Tiny Ping Markers\", tooltip=\"Marks when alerts would fire (non-repainting)\", group=grp_ping)\r\n\r\n//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Core RSI ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ//\r\nr = ta.rsi(src, len)\r\n\r\n//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Confirmed pivots (RSI) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ//\r\npl_r = ta.pivotlow(r, lbL, lbR)      // RSI pivot low value (confirmed on current bar)\r\nph_r = ta.pivothigh(r, lbL, lbR)     // RSI pivot high value (confirmed on current bar)\r\n\r\nplFound = not na(pl_r)               // true on the bar the RSI low pivot is confirmed\r\nphFound = not na(ph_r)               // true on the bar the RSI high pivot is confirmed\r\n\r\n//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Align to TRUE pivot bars + measure distances ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ//\r\n// On the confirmation bar, the true pivot bar index is (bar_index - lbR).\r\n\r\n// LOW pivots\r\ncurrPl_bar   = plFound ? (bar_index - lbR) : na\r\nprevPl_bar   = ta.valuewhen(plFound, (bar_index - lbR), 1)\r\ndistPl       = currPl_bar - prevPl_bar\r\n\r\ncurrPl_price = plFound ? low[lbR] : na\r\nprevPl_price = ta.valuewhen(plFound, low[lbR], 1)\r\n\r\ncurrPl_r     = pl_r\r\nprevPl_r     = ta.valuewhen(plFound, pl_r, 1)\r\n\r\nokPl         = plFound and not na(prevPl_bar) and not na(prevPl_price) and not na(prevPl_r) and distPl >= minBars and distPl <= maxBars\r\n\r\n// HIGH pivots\r\ncurrPh_bar   = phFound ? (bar_index - lbR) : na\r\nprevPh_bar   = ta.valuewhen(phFound, (bar_index - lbR), 1)\r\ndistPh       = currPh_bar - prevPh_bar\r\n\r\ncurrPh_price = phFound ? high[lbR] : na\r\nprevPh_price = ta.valuewhen(phFound, high[lbR], 1)\r\n\r\ncurrPh_r     = ph_r\r\nprevPh_r     = ta.valuewhen(phFound, ph_r, 1)\r\n\r\nokPh         = phFound and not na(prevPh_bar) and not na(prevPh_price) and not na(prevPh_r) and distPh >= minBars and distPh <= maxBars\r\n\r\n//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Divergence Logic (aligned, non-repainting) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ//\r\n// Regular Bullish: price LL, RSI HL\r\nbullReg = showReg and okPl and (currPl_price < prevPl_price) and (currPl_r > prevPl_r)\r\n// Hidden Bullish: price HL, RSI LL\r\nbullHid = showHid and okPl and (currPl_price > prevPl_price) and (currPl_r < prevPl_r)\r\n// Regular Bearish: price HH, RSI LH\r\nbearReg = showReg and okPh and (currPh_price > prevPh_price) and (currPh_r < prevPh_r)\r\n// Hidden Bearish: price LH, RSI HH\r\nbearHid = showHid and okPh and (currPh_price < prevPh_price) and (currPh_r > prevPh_r)\r\n\r\n//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Signals & Alerts (confirmed bar only) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ//\r\nbool sig_bullReg = bullReg and barstate.isconfirmed\r\nbool sig_bullHid = bullHid and barstate.isconfirmed\r\nbool sig_bearReg = bearReg and barstate.isconfirmed\r\nbool sig_bearHid = bearHid and barstate.isconfirmed\r\nbool sig_anyDiv  = sig_bullReg or sig_bullHid or sig_bearReg or sig_bearHid\r\n\r\nalertcondition(sig_bullReg, title=\"RSI: Bullish Regular\", message=\"RSI Regular Bullish divergence confirmed on {{ticker}} {{interval}} at {{time}}.\")\r\nalertcondition(sig_bullHid, title=\"RSI: Bullish Hidden\",  message=\"RSI Hidden Bullish divergence confirmed on {{ticker}} {{interval}} at {{time}}.\")\r\nalertcondition(sig_bearReg, title=\"RSI: Bearish Regular\", message=\"RSI Regular Bearish divergence confirmed on {{ticker}} {{interval}} at {{time}}.\")\r\nalertcondition(sig_bearHid, title=\"RSI: Bearish Hidden\",  message=\"RSI Hidden Bearish divergence confirmed on {{ticker}} {{interval}} at {{time}}.\")\r\nalertcondition(sig_anyDiv,  title=\"RSI: Any Divergence\",  message=\"RSI divergence (any) confirmed on {{ticker}} {{interval}} at {{time}}.\")\r\n\r\n//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ RSI Plot & Levels ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ//\r\nrColor = r > obLevel ? color.new(color.red, 0) : r < osLevel ? color.new(color.lime, 0) : color.new(color.white, 0)\r\nplot(r, \"RSI\", color=rColor, linewidth=rsiLineWidth)\r\n\r\nob  = hline(obLevel, \"OB\",  color=color.new(color.red, 70))\r\nos  = hline(osLevel, \"OS\",  color=color.new(color.lime, 70))\r\nmid = hline(midLevel, \"Mid\", color=color.new(color.gray, 85))\r\n\r\n// fill() must be in global scope, so we control visibility via color\r\nfill(ob, os, showObOs ? color.new(color.purple, 95) : na)\r\n\r\n//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Labels (non-repainting; on confirmation bar) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ//\r\nlabel_size_enum = labelSize == \"tiny\" ? size.tiny : labelSize == \"small\" ? size.small : labelSize == \"normal\" ? size.normal : labelSize == \"large\" ? size.large : size.huge\r\n\r\nif showLabels\r\n    if sig_bullReg\r\n        label.new(currPl_bar, currPl_r, \"Bull\",   xloc=xloc.bar_index, yloc=yloc.price, style=label.style_label_up,   color=color.lime,                 textcolor=color.black, size=label_size_enum)\r\n    if sig_bullHid\r\n        label.new(currPl_bar, currPl_r, \"H Bull\", xloc=xloc.bar_index, yloc=yloc.price, style=label.style_label_up,   color=color.new(color.lime, 60),  textcolor=color.black, size=label_size_enum)\r\n    if sig_bearReg\r\n        label.new(currPh_bar, currPh_r, \"Bear\",   xloc=xloc.bar_index, yloc=yloc.price, style=label.style_label_down, color=color.fuchsia,              textcolor=color.white, size=label_size_enum)\r\n    if sig_bearHid\r\n        label.new(currPh_bar, currPh_r, \"H Bear\", xloc=xloc.bar_index, yloc=yloc.price, style=label.style_label_down, color=color.new(color.fuchsia,60),textcolor=color.white, size=label_size_enum)\r\n\r\n//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Divergence Connector Lines (non-repainting) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ//\r\nif showDivLines\r\n    if sig_bullReg\r\n        line.new(prevPl_bar, prevPl_r, currPl_bar, currPl_r, xloc=xloc.bar_index, extend=extend.none, color=color.lime,                 width=lineWidth)\r\n    if sig_bullHid\r\n        line.new(prevPl_bar, prevPl_r, currPl_bar, currPl_r, xloc=xloc.bar_index, extend=extend.none, color=color.new(color.lime, 60), width=lineWidth)\r\n    if sig_bearReg\r\n        line.new(prevPh_bar, prevPh_r, currPh_bar, currPh_r, xloc=xloc.bar_index, extend=extend.none, color=color.fuchsia,             width=lineWidth)\r\n    if sig_bearHid\r\n        line.new(prevPh_bar, prevPh_r, currPh_bar, currPh_r, xloc=xloc.bar_index, extend=extend.none, color=color.new(color.fuchsia,60), width=lineWidth)\r\n\r\n//‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Optional tiny ping markers (bottom/top of panel) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ//\r\ndispPings = showPings ? display.all : display.none\r\n\r\nplotshape(sig_bullReg, title=\"Bull Reg ping\",  style=shape.triangleup,   size=size.tiny, location=location.bottom, color=color.new(color.lime, 0),     offset=0, display=dispPings)\r\nplotshape(sig_bullHid, title=\"Bull Hid ping\",  style=shape.triangleup,   size=size.tiny, location=location.bottom, color=color.new(color.lime, 60),    offset=0, display=dispPings)\r\nplotshape(sig_bearReg, title=\"Bear Reg ping\",  style=shape.triangledown, size=size.tiny, location=location.top,    color=color.new(color.fuchsia, 0),  offset=0, display=dispPings)\r\nplotshape(sig_bearHid, title=\"Bear Hid ping\",  style=shape.triangledown, size=size.tiny, location=location.top,    color=color.new(color.fuchsia, 60), offset=0, display=dispPings)\r\n"
  },
  "https://www.tradingview.com/script/kM3NfCEx-Neural-Fusion-Pro/": {
    "id": 20087533,
    "url": "https://www.tradingview.com/script/kM3NfCEx-Neural-Fusion-Pro/",
    "name": "Neural Fusion Pro",
    "description": "Neural Fusion Pro\nOverview\nNeural Fusion Pro is a multi-factor scoring system that combines numerous technical analysis methods into a single unified score. Rather than requiring traders to monitor multiple indicators separately, this system synthesizes trend strength, momentum oscillators, volume confirmation, price structure, and price action quality into one composite reading that adapts to current market conditions.\nThe Scoring System\nAt the heart of this indicator is a weighted scoring algorithm that produces a value between -1.0 and +1.0. Positive scores indicate bullish conditions across the measured factors, while negative scores suggest bearish conditions. The magnitude of the score reflects the strength of conviction across indicators.\nThe score is calculated from five distinct components, each capturing a different aspect of market behavior. Users can adjust the weight given to each component based on their trading style and market preferences.\nComponent 1: Trend Strength and Direction\nThis component uses the Average Directional Index to measure trend strength and the Directional Movement indicators to determine trend direction. When ADX exceeds the trending threshold, indicating a directional market, the component contributes a positive score if the positive directional indicator leads, or a negative score if the negative directional indicator leads. In ranging markets where ADX is low, this component contributes minimally to avoid false trend signals.\nComponent 2: Multi-Factor Momentum\nRather than relying on a single oscillator, this component synthesizes readings from RSI, MACD histogram, Stochastic, CCI, and Rate of Change. Each oscillator is normalized to a common scale and weighted according to its reliability characteristics. RSI readings are compared against dynamic thresholds that adjust based on trend state, making the indicator more forgiving in uptrends and more demanding in downtrends.\nThe component also includes divergence detection. When price makes a higher high but RSI makes a lower high (bearish divergence), or when price makes a lower low but RSI makes a higher low (bullish divergence), the divergence score adjusts the momentum component accordingly.\nComponent 3: Volume Confirmation\nVolume provides crucial confirmation of price movements. This component analyzes On-Balance Volume relative to its moving average and measures the slope of OBV to determine whether volume is supporting the price trend. Additionally, it monitors relative volume by comparing current volume to its recent average, adding confirmation when volume spikes accompany price movements.\nComponent 4: Price Structure and Volatility\nThis component evaluates where price sits within the dynamic bands and considers the current volatility regime. When price is near the lower band, the component contributes a bullish score, suggesting potential support. When price is near the upper band, it contributes a bearish score, suggesting potential resistance.\nThe volatility regime assessment uses ATR percentile ranking. Low volatility periods often precede significant moves, while extremely high volatility may indicate unsustainable conditions.\nComponent 5: Price Action Quality\nThis component examines the character of recent candles by tracking the ratio of bullish to bearish candles over a lookback period. Consistent bullish price action contributes a positive score, while consistent bearish action contributes negatively. This helps filter signals by confirming that price behavior aligns with other factors.\nDynamic Bands\nThe indicator plots adaptive bands around a central basis line. The basis can be configured as either a simple or exponential moving average. Band width is determined by ATR multiplied by a dynamic factor that incorporates both ADX (expanding bands in trending markets) and the Chaikin Oscillator (expanding bands during strong accumulation or distribution).\nThese bands serve multiple purposes: they provide visual context for price position, they define signal trigger zones, and they help identify overextended conditions.\nTrend State Detection\nThe indicator classifies market conditions into three states that affect signal generation and threshold levels.\nStrong Uptrend is identified when ADX is rising, ADX exceeds the strong trend threshold, and the positive directional indicator exceeds the negative. This state triggers the most aggressive buy settings, allowing entries on shallow pullbacks.\nDowntrend is identified when the negative directional indicator exceeds positive DI and ADX confirms directional movement. This state applies the most conservative buy settings, requiring deep oversold conditions before generating buy signals.\nNeutral applies when neither trend condition is met, using moderate threshold settings appropriate for range-bound or transitional markets.\nDynamic RSI Thresholds\nA key innovation is the automatic adjustment of RSI thresholds based on trend state. In a strong uptrend, the buy RSI threshold might be set to 50, allowing entries when RSI merely pulls back to neutral rather than requiring oversold conditions. The sell threshold rises to 72, keeping traders in positions longer during favorable conditions.\nIn downtrends, the buy RSI threshold drops to 25, ensuring buys only trigger on genuine capitulation. The sell threshold drops to 64, making exits easier to trigger.\nIn neutral markets, traditional oversold and overbought levels apply, with buy triggers around RSI 30 and sell triggers around RSI 68.\nThis adaptive approach prevents the common problem of indicators that work well in one market environment but fail in others.\nDynamic Cooldown\nThe signal cooldown period adjusts based on trend strength. During normal conditions, a standard cooldown prevents signal clustering. When ADX exceeds the strong trend threshold and is rising, indicating a powerful trend, the cooldown period extends. This helps traders stay in winning positions longer by reducing the frequency of counter-trend signals.\nCascade Protection\nThe indicator includes protection mechanisms to prevent overtrading and averaging down into losing positions.\nThe BBWP (Bollinger Band Width Percentile) monitor tracks current volatility relative to historical levels. When BBWP exceeds a threshold, indicating a volatility spike often associated with sharp moves, all buy signals are frozen. This protects against entering during panic selloffs or blow-off tops.\nThe consecutive buy counter tracks how many buy signals have occurred without an intervening sell. After reaching the maximum (default 3), no additional buy signals are generated until a sell occurs. This prevents the destructive pattern of repeatedly buying a declining asset.\nBoth protection mechanisms are displayed in the information panel, allowing traders to understand why signals may or may not be firing.\nSignal Generation\nBuy signals require price to touch or penetrate the lower band, RSI to be below the dynamic threshold, and the market to be in a trending state (when that filter is enabled). Additionally, the cooldown period must have elapsed and cascade protection must not be blocking buys.\nSell signals require price to touch or penetrate the upper band, RSI to be above the dynamic threshold, and the cooldown to have elapsed.\nSignal labels display the entry price, signal type (shallow dip, capitulation, extended, bounce sell, or neutral), and the current position in the consecutive buy count.\nVisual Components\nThe indicator provides multiple layers of visual feedback.\nCloud shading between the bands changes based on whether the composite score is in a buy zone or sell zone. Green clouds indicate bullish score readings, while red clouds indicate bearish readings.\nBackground coloring reflects the overall market regime. Green background indicates a bullish regime (positive DI leadership with volume confirmation), red indicates bearish regime, and white indicates neutral conditions.\nAn ADX bar at the bottom of the chart uses color coding: white for ranging (very low ADX), orange for flat, and blue for trending conditions.\nThe information panel displays the composite score with color coding, current trend state, active RSI thresholds, divergence status, BBWP freeze status, buy counter, market regime, ADX value with trend indicator, current cooldown setting, and live RSI reading color-coded against the active thresholds.\nA debug panel can be enabled to show the individual component scores, helping users understand what is driving the composite reading.\nHow to Use\nMonitor the composite score in the information panel. Readings above the buy threshold combined with price near the lower band represent potential long entries. Readings below the sell threshold with price near the upper band suggest exit opportunities.\nPay attention to the trend state. In strong uptrends, be more willing to buy dips and more patient with holding positions. In downtrends, require stronger confirmation before entering and be quicker to take profits on bounces.\nWatch the cascade protection status. If BBWP shows frozen or the buy counter is approaching maximum, exercise additional caution regardless of other signals.\nUse the dynamic RSI thresholds as context. When the panel shows buy RSI threshold at 50 (strong uptrend), even a pullback to RSI 45 is a potential entry. When the threshold shows 25 (downtrend), wait for genuine capitulation conditions.\nComponent Weight Adjustment\nThe relative importance of each scoring component can be adjusted through the settings. The default weights emphasize trend strength (30%) and momentum (25%), with volume (20%), price structure (15%), and price action (10%) providing confirmation.\nFor trend-following strategies, consider increasing trend and momentum weights. For mean-reversion approaches, increase the price structure weight to emphasize band position. The weights should sum to approximately 1.0 for proper score scaling.\nSettings Guidance\nThe default settings are calibrated for cryptocurrency markets on lower timeframes. For traditional markets or longer timeframes, consider adjusting the ADX trending threshold (lower values for less volatile assets), the dynamic RSI levels for each trend state, and the cascade protection parameters.\nThe Heikin Ashi option for band calculation can provide smoother bands but may introduce slight lag. The default setting uses standard price data for better real-time accuracy.",
    "author_name": "ralis24",
    "likes_count": 16,
    "comments_count": 0,
    "views_count": 0,
    "created_at": "2025-12-11T22:55:31+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "BINANCE:BTCUSDT",
      "full_name": "BINANCE:BTCUSDT",
      "short_name": "BTCUSDT",
      "exchange": "BINANCE",
      "type": "spot",
      "logo_id": null,
      "currency_logo_id": "crypto/XTVCUSDT",
      "base_currency_logo_id": "crypto/XTVCBTC",
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/crypto/XTVCBTC.svg",
        "https://s3-symbol-logo.tradingview.com/crypto/XTVCUSDT.svg"
      ],
      "interval": "60",
      "direction": 0,
      "badge": {
        "label": "BINANCE:BTCUSDT",
        "url": "/symbols/BTCUSDT/"
      }
    },
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=6\r\nindicator(\"Neural Fusion Pro\", shorttitle=\"Neural Fus\", overlay=true, max_bars_back=500)\r\n\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\n// NEURAL FUSION PRO\r\n// Multi-Factor Scoring System with Adaptive Thresholds\r\n//\r\n// This indicator combines multiple technical analysis methods\r\n// into a unified scoring system (GXS Score) that adapts to\r\n// current market conditions. It features:\r\n//\r\n// ‚Ä¢ Dynamic RSI thresholds based on trend state\r\n// ‚Ä¢ Multi-factor momentum scoring\r\n// ‚Ä¢ Cascade protection to prevent overtrading\r\n// ‚Ä¢ Adaptive bands using ATR, ADX, and Chaikin\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\n\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\n// INPUT GROUPS\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\ngroupCore = \"Core Indicators\"\r\ngroupBands = \"Dynamic Bands\"\r\ngroupTrend = \"Trend State Detection\"\r\ngroupDynamicRSI = \"Dynamic RSI Thresholds\"\r\ngroupScore = \"Score Settings\"\r\ngroupWeights = \"Score Component Weights\"\r\ngroupProtect = \"Cascade Protection\"\r\ngroupDisplay = \"Display Settings\"\r\n\r\n// Core Technical Indicators\r\nrsiLen = input.int(14, \"RSI Length\", minval=1, group=groupCore)\r\nmacdFast = input.int(12, \"MACD Fast\", minval=1, group=groupCore)\r\nmacdSlow = input.int(26, \"MACD Slow\", minval=1, group=groupCore)\r\nmacdSig = input.int(9, \"MACD Signal\", minval=1, group=groupCore)\r\nstochLen = input.int(14, \"Stochastic Length\", minval=1, group=groupCore)\r\ncciLen = input.int(20, \"CCI Length\", minval=1, group=groupCore)\r\nrocLen = input.int(10, \"Rate of Change Length\", minval=1, group=groupCore)\r\nobvSmaLen = input.int(20, \"OBV SMA Length\", minval=1, group=groupCore)\r\n\r\n// Dynamic Bands\r\nmidType = input.string(\"SMA\", \"Midpoint MA Type\", options=[\"SMA\", \"EMA\"], group=groupBands)\r\nbbLen = input.int(20, \"Midpoint Length\", minval=1, group=groupBands)\r\natrLength = input.int(14, \"ATR Length\", minval=1, group=groupBands)\r\natrSmoothLength = input.int(5, \"ATR Smoothing Length\", minval=1, group=groupBands)\r\nbaseMult = input.float(2.5, \"Base Band Multiplier\", minval=0.1, step=0.1, group=groupBands)\r\nadxLen = input.int(14, \"ADX Length\", minval=1, group=groupBands)\r\nadxThresh = input.int(24, \"ADX Trending Threshold\", minval=0, group=groupBands)\r\nchaikinFast = input.int(3, \"Chaikin Fast Period\", minval=1, group=groupBands)\r\nchaikinSlow = input.int(10, \"Chaikin Slow Period\", minval=1, group=groupBands)\r\nchaikinWeight = input.float(0.5, \"Chaikin Band Weight\", minval=0, step=0.1, group=groupBands)\r\nadxBandWeight = input.float(0.5, \"ADX Band Weight\", minval=0, step=0.1, group=groupBands)\r\nuseHeikinAshi = input.bool(false, \"Use Heikin Ashi for Bands\", group=groupBands)\r\n\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\n// TREND STATE DETECTION\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\nadxTrendLevel = input.int(25, \"ADX Strong Trend Level\", minval=15, maxval=40, group=groupTrend)\r\nadxRisingBars = input.int(3, \"ADX Rising Lookback\", minval=1, maxval=10, group=groupTrend)\r\n\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\n// DYNAMIC RSI THRESHOLDS\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\n// Strong Uptrend - catch shallow dips\r\nbuyUpRSI = input.int(50, \"Strong Uptrend: Buy RSI <\", minval=30, maxval=60, group=groupDynamicRSI)\r\nsellUpRSI = input.int(72, \"Strong Uptrend: Sell RSI >\", minval=60, maxval=85, group=groupDynamicRSI)\r\n\r\n// Neutral - standard mean reversion\r\nbuyNeutRSI = input.int(30, \"Neutral: Buy RSI <\", minval=20, maxval=45, group=groupDynamicRSI)\r\nsellNeutRSI = input.int(68, \"Neutral: Sell RSI >\", minval=55, maxval=80, group=groupDynamicRSI)\r\n\r\n// Downtrend - only capitulation buys\r\nbuyDownRSI = input.int(25, \"Downtrend: Buy RSI <\", minval=15, maxval=40, group=groupDynamicRSI)\r\nsellDownRSI = input.int(64, \"Downtrend: Sell RSI >\", minval=50, maxval=75, group=groupDynamicRSI)\r\n\r\n// Score Settings\r\nscoreThreshBuy = input.float(0.12, \"Buy Threshold\", minval=-1.0, maxval=1.0, step=0.01, group=groupScore)\r\nscoreThreshSell = input.float(-0.12, \"Sell Threshold\", minval=-1.0, maxval=1.0, step=0.01, group=groupScore)\r\nuseAdxFilter = input.bool(true, \"Require Trending Market for Signals\", group=groupScore)\r\ncooldownPeriod = input.int(5, \"Signal Cooldown (Bars)\", minval=1, group=groupScore)\r\nenableDivergence = input.bool(true, \"Enable Divergence Detection\", group=groupScore)\r\n\r\n// Dynamic Cooldown Settings\r\nenableDynamicCooldown = input.bool(true, \"Enable Dynamic Cooldown\", group=groupScore, tooltip=\"Increase cooldown during strong trends to let profits run\")\r\nstrongTrendADX = input.int(50, \"Strong Trend ADX Threshold\", minval=30, maxval=70, group=groupScore, tooltip=\"ADX level considered a strong trend\")\r\nstrongTrendCooldown = input.int(10, \"Strong Trend Cooldown (Bars)\", minval=1, maxval=20, group=groupScore, tooltip=\"Cooldown period when ADX > threshold and rising\")\r\n\r\n// Component Weights (must sum to 1.0)\r\ntrendWeight = input.float(0.30, \"Trend Strength\", minval=0, maxval=1, step=0.05, group=groupWeights)\r\nmomentumWeight = input.float(0.25, \"Momentum\", minval=0, maxval=1, step=0.05, group=groupWeights)\r\nvolumeWeight = input.float(0.20, \"Volume\", minval=0, maxval=1, step=0.05, group=groupWeights)\r\npriceStructWeight = input.float(0.15, \"Price Structure\", minval=0, maxval=1, step=0.05, group=groupWeights)\r\npriceActionWeight = input.float(0.10, \"Price Action\", minval=0, maxval=1, step=0.05, group=groupWeights)\r\n\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\n// CASCADE PROTECTION\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\nenableCascadeProtection = input.bool(true, \"Enable Cascade Protection\", group=groupProtect, tooltip=\"Master toggle for all cascade protection features\")\r\nbbwpLength = input.int(7, \"BBWP Length\", minval=5, maxval=20, group=groupProtect)\r\nbbwpLookback = input.int(100, \"BBWP Lookback\", minval=50, maxval=300, group=groupProtect)\r\nbbwpFreezeLevel = input.float(92.0, \"BBWP Freeze Level (%)\", minval=80.0, maxval=98.0, step=1.0, group=groupProtect, tooltip=\"Freeze ALL buys when BBWP exceeds this level\")\r\nmaxConsecBuys = input.int(3, \"Max Consecutive Buys\", minval=1, maxval=10, group=groupProtect, tooltip=\"Maximum buys allowed without an intervening sell\")\r\nshowProtectStatus = input.bool(true, \"Show Protection Status in Panel\", group=groupProtect)\r\n\r\n// Display\r\nshowBands = input.bool(true, \"Show Band Lines\", group=groupDisplay)\r\nshowCloud = input.bool(true, \"Show Signal Clouds\", group=groupDisplay)\r\nshowBackground = input.bool(true, \"Show Regime Background\", group=groupDisplay)\r\nshowScore = input.bool(true, \"Show ADX Indicator\", group=groupDisplay)\r\nshowTable = input.bool(true, \"Show Score Table\", group=groupDisplay)\r\nshowDebug = input.bool(false, \"Show Debug Panel\", group=groupDisplay)\r\nshowPriceLabels = input.bool(true, \"Show Price Labels\", group=groupDisplay)\r\nshowSignals = input.bool(true, \"Show Signals\", group=groupDisplay)\r\narrowSize = input.string(\"normal\", \"Arrow Size\", options=[\"small\", \"normal\", \"large\"], group=groupDisplay)\r\ncloudOpacity = input.int(80, \"Cloud Opacity\", minval=50, maxval=95, group=groupDisplay)\r\nbgOpacity = input.int(85, \"Background Opacity\", minval=80, maxval=95, group=groupDisplay)\r\n\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\n// HEIKIN ASHI & DYNAMIC BANDS\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\nvar float haOpen = na\r\nhaClose = (open + high + low + close) / 4\r\nhaOpen := na(haOpen[1]) ? (open + close) / 2 : (haOpen[1] + haClose[1]) / 2\r\nhaHigh = math.max(high, haOpen, haClose)\r\nhaLow = math.min(low, haOpen, haClose)\r\n\r\n// Use regular candles by default for better anchoring\r\nmidpoint = useHeikinAshi ? (haHigh + haLow) / 2 : hl2\r\nbasis = midType == \"EMA\" ? ta.ema(midpoint, bbLen) : ta.sma(midpoint, bbLen)\r\n\r\n// ATR with smoothing\r\nrawAtr = ta.atr(atrLength)\r\natr = ta.ema(rawAtr, atrSmoothLength)\r\natrPercentile = ta.percentrank(atr, 100)\r\n\r\n// Chaikin Oscillator for band expansion\r\nchaikin = ta.ema(ta.accdist, chaikinFast) - ta.ema(ta.accdist, chaikinSlow)\r\nchaikinHigh = ta.highest(chaikin, 200)\r\nchaikinLow = ta.lowest(chaikin, 200)\r\nnormChaikin = chaikinHigh != chaikinLow ? (chaikin - chaikinLow) / (chaikinHigh - chaikinLow) * 2 - 1 : 0.0\r\n\r\n// ADX for trend strength\r\n[diplus, diminus, adx] = ta.dmi(adxLen, adxLen)\r\nadxSmoothed = ta.ema(adx, 3)\r\nnormAdx = adx / 100\r\n\r\n// Dynamic band multiplier\r\ndynamicMult = baseMult + chaikinWeight * math.abs(normChaikin) + adxBandWeight * normAdx\r\nupper = basis + dynamicMult * atr\r\nlower = basis - dynamicMult * atr\r\n\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\n// TREND STATE DETECTION\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\nadxRising = adx > adx[adxRisingBars]\r\n\r\n// Strong Uptrend: ADX rising, ADX > threshold, +DI > -DI\r\nisStrongUptrend = adxRising and adx > adxTrendLevel and diplus > diminus\r\n\r\n// Downtrend: -DI > +DI and ADX > 15\r\nisDowntrend = diminus > diplus and adx > 15\r\n\r\n// Neutral: Not uptrend or downtrend\r\nisNeutral = not isStrongUptrend and not isDowntrend\r\n\r\n// Trend state for display\r\ntrendState = isStrongUptrend ? \"STRONG UP\" : isDowntrend ? \"DOWNTREND\" : \"NEUTRAL\"\r\ntrendColor = isStrongUptrend ? color.green : isDowntrend ? color.red : color.gray\r\n\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\n// DYNAMIC RSI THRESHOLDS\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\ndynamicBuyRSI = isStrongUptrend ? buyUpRSI : isDowntrend ? buyDownRSI : buyNeutRSI\r\ndynamicSellRSI = isStrongUptrend ? sellUpRSI : isDowntrend ? sellDownRSI : sellNeutRSI\r\n\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\n// BBWP CALCULATION (for Cascade Protection)\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\nbbwpBasis = ta.sma(close, bbwpLength)\r\nbbwpDev = ta.stdev(close, bbwpLength)\r\nbbwpUpper = bbwpBasis + 2 * bbwpDev\r\nbbwpLower = bbwpBasis - 2 * bbwpDev\r\nbbwpWidth = bbwpBasis != 0 ? (bbwpUpper - bbwpLower) / bbwpBasis * 100 : 0\r\nbbwp = ta.percentrank(bbwpWidth, bbwpLookback)\r\n\r\n// BBWP Freeze Status\r\nbbwpFrozen = enableCascadeProtection and bbwp > bbwpFreezeLevel\r\n\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\n// TECHNICAL INDICATORS\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\nrsi = ta.rsi(close, rsiLen)\r\n[macdLine, signalLine, macdHist] = ta.macd(close, macdFast, macdSlow, macdSig)\r\nstochK = ta.stoch(close, high, low, stochLen)\r\ncci = ta.cci(close, cciLen)\r\nroc = ta.roc(close, rocLen)\r\nobv = ta.obv\r\nobvSma = ta.sma(obv, obvSmaLen)\r\n\r\n// Volume analysis\r\nvolumeSma = ta.sma(volume, 20)\r\nvolumeRoc = (volume - volumeSma) / volumeSma\r\n\r\n// Price action quality\r\nbullCandles = close > open ? 1.0 : 0.0\r\nbearCandles = close < open ? 1.0 : 0.0\r\nbullRatio = ta.sma(bullCandles, 10)\r\nbearRatio = ta.sma(bearCandles, 10)\r\n\r\n// Divergence detection\r\nlookbackDiv = 5\r\nhigherHigh = high > high[lookbackDiv] and high[lookbackDiv] > high[lookbackDiv * 2]\r\nlowerRSI = rsi < rsi[lookbackDiv] and rsi[lookbackDiv] < rsi[lookbackDiv * 2]\r\nbearishDivergence = enableDivergence and higherHigh and lowerRSI\r\n\r\nlowerLow = low < low[lookbackDiv] and low[lookbackDiv] < low[lookbackDiv * 2]\r\nhigherRSI = rsi > rsi[lookbackDiv] and rsi[lookbackDiv] > rsi[lookbackDiv * 2]\r\nbullishDivergence = enableDivergence and lowerLow and higherRSI\r\n\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\n// TREND STRENGTH METER CALCULATION\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\nadxStrength = math.min(adx / 50 * 100, 100)\r\n\r\npriceSlope = ta.sma(close - close[1], 10)\r\nslopeStdev = ta.stdev(close - close[1], 10)\r\nslopeConsistency = slopeStdev > 0 ? math.min((math.abs(priceSlope) / slopeStdev) * 25, 100) : 0\r\n\r\nvolumeStrength = obv > obvSma ? math.min(math.abs((obv - obvSma) / obvSma) * 200, 100) : 0\r\n\r\nmomentumAgreement = 0.0\r\nmomentumAgreement := momentumAgreement + (rsi > 50 ? 20 : 0)\r\nmomentumAgreement := momentumAgreement + (macdLine > signalLine ? 20 : 0)\r\nmomentumAgreement := momentumAgreement + (stochK > 50 ? 20 : 0)\r\nmomentumAgreement := momentumAgreement + (cci > 0 ? 20 : 0)\r\nmomentumAgreement := momentumAgreement + (roc > 0 ? 20 : 0)\r\n\r\ntrendStrengthVal = (adxStrength * 0.40) + (slopeConsistency * 0.30) + (volumeStrength * 0.20) + (momentumAgreement * 0.10)\r\ntrendStrengthVal := math.min(math.max(trendStrengthVal, 0), 100)\r\n\r\n// COMPONENT 1: Trend Strength & Direction (30%)\r\ntrendScore = 0.0\r\nisTrending = adxSmoothed > adxThresh\r\nif isTrending\r\n    trendScore := diplus > diminus ? (adxSmoothed / 100) : -(adxSmoothed / 100)\r\n\r\n// COMPONENT 2: Multi-Factor Momentum (25%)\r\nrsiNorm = (50 - rsi) / 50\r\nmacdStdev = ta.stdev(macdHist, 50)\r\nmacdNorm = macdStdev > 0 ? math.max(math.min(macdHist / macdStdev, 1.0), -1.0) : 0.0\r\nstochScore = stochK < 20 ? 0.5 : stochK > 80 ? -0.5 : 0.0\r\ncciScore = cci < -100 ? 0.5 : cci > 100 ? -0.5 : 0.0\r\nrocScore = roc > 5 ? 0.3 : roc < -5 ? -0.3 : 0.0\r\ndivergenceScore = bullishDivergence ? 0.4 : bearishDivergence ? -0.4 : 0.0\r\n\r\nmomentumScore = (rsiNorm * 0.25 + macdNorm * 0.25 + stochScore * 0.15 + cciScore * 0.15 + rocScore * 0.10 + divergenceScore * 0.10)\r\n\r\n// COMPONENT 3: Volume Confirmation (20%)\r\nobvSlope = (obv - obv[10]) / 10\r\nobvStdev = ta.stdev(obvSlope, 50)\r\nobvNorm = obvStdev > 0 ? math.max(math.min(obvSlope / obvStdev, 1.0), -1.0) : 0.0\r\nobvDirection = obv > obvSma ? 1 : -1\r\nobvScore = obvNorm * obvDirection * 0.7\r\n\r\nvolConfirm = volumeRoc > 0.2 ? 0.25 : volumeRoc < -0.2 ? -0.25 : 0.0\r\nvolumeScore = obvScore + volConfirm * 0.3\r\n\r\n// COMPONENT 4: Price Structure & Volatility (15%)\r\nbandPosition = (upper - lower) > 0 ? (close - lower) / (upper - lower) : 0.5\r\nbandScore = bandPosition > 0.8 ? -1.0 : bandPosition < 0.2 ? 1.0 : (0.5 - bandPosition) * 2\r\n\r\nvolRegimeScore = atrPercentile > 70 ? -0.3 : atrPercentile < 30 ? 0.3 : 0.0\r\npriceStructScore = bandScore * 0.7 + volRegimeScore * 0.3\r\n\r\n// COMPONENT 5: Price Action Quality (10%)\r\npriceActionScore = bullRatio > 0.7 ? 0.5 : bearRatio > 0.7 ? -0.5 : (bullRatio - bearRatio)\r\n\r\n// FINAL WEIGHTED SCORE\r\ntotalWeight = trendWeight + momentumWeight + volumeWeight + priceStructWeight + priceActionWeight\r\ntotalWeight := totalWeight == 0 ? 1 : totalWeight\r\n\r\ngxsScore = (trendScore * trendWeight + momentumScore * momentumWeight + volumeScore * volumeWeight + priceStructScore * priceStructWeight + priceActionScore * priceActionWeight) / totalWeight\r\n\r\ngxsScore := math.max(math.min(gxsScore, 1.0), -1.0)\r\n\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\n// SIGNAL GENERATION WITH CASCADE PROTECTION + DYNAMIC RSI\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\nvar int lastBuyBar = 0\r\nvar int lastSellBar = 0\r\nvar int consecutiveBuys = 0\r\n\r\n// Dynamic Cooldown: Increase cooldown during strong trends\r\nisStrongTrend = enableDynamicCooldown and adx > strongTrendADX and adxRising\r\nactiveCooldown = isStrongTrend ? strongTrendCooldown : cooldownPeriod\r\n\r\n// Step 1: Calculate base conditions WITH DYNAMIC RSI THRESHOLDS\r\nbuyConditionBase = low < lower and (not useAdxFilter or isTrending) and rsi < dynamicBuyRSI\r\nsellConditionBase = high > upper and (not useAdxFilter or isTrending) and rsi > dynamicSellRSI\r\n\r\n// Step 2: Check cooldown BEFORE determining final signal (using dynamic cooldown)\r\nbuyCooldownMet = bar_index - lastBuyBar >= activeCooldown\r\nsellCooldownMet = bar_index - lastSellBar >= activeCooldown\r\n\r\n// Step 3: Cascade Protection checks\r\nbuyCounterOK = not enableCascadeProtection or consecutiveBuys < maxConsecBuys\r\nbbwpOK = not enableCascadeProtection or not bbwpFrozen\r\n\r\n// Combined cascade protection - BOTH must pass\r\ncascadeAllowsBuy = bbwpOK and buyCounterOK\r\n\r\n// Step 4: Final signal determination\r\nbuySignal = showSignals and buyConditionBase and buyCooldownMet and cascadeAllowsBuy\r\nsellSignal = showSignals and sellConditionBase and sellCooldownMet\r\n\r\n// Step 5: Update cooldown trackers and consecutive buy counter\r\nif buySignal\r\n    lastBuyBar := bar_index\r\n    consecutiveBuys := consecutiveBuys + 1\r\nif sellSignal\r\n    lastSellBar := bar_index\r\n    consecutiveBuys := 0  // Reset counter on any sell\r\n\r\n// Score-based regime signals (for cloud display)\r\ninBuyZone = gxsScore > scoreThreshBuy and isTrending\r\ninSellZone = gxsScore < scoreThreshSell and isTrending\r\n\r\n// Regime classification\r\nisBull = diplus > diminus and obv > obvSma and isTrending\r\nisBear = diminus > diplus and obv < obvSma and isTrending\r\n\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\n// PLOTTING\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\n\r\n// Bands\r\nplot(showBands ? basis : basis, \"Basis\", color=showBands ? #0000FF : na, linewidth=3)\r\nplot(showBands ? upper : upper, \"Upper Band\", color=showBands ? #FF0000 : na, linewidth=2)\r\nplot(showBands ? lower : lower, \"Lower Band\", color=showBands ? #00FF00 : na, linewidth=2)\r\n\r\n// Clouds\r\np1 = plot(upper, color=na)\r\np2 = plot(lower, color=na)\r\nfill(p1, p2, color=showCloud and inBuyZone ? color.new(#00FF00, cloudOpacity) : na)\r\nfill(p1, p2, color=showCloud and inSellZone ? color.new(#FF0000, cloudOpacity) : na)\r\n\r\n// Background\r\nbgcolor(showBackground ? (isBull ? color.new(#00FF00, bgOpacity) : isBear ? color.new(#FF0000, bgOpacity) : color.new(color.white, bgOpacity)) : na)\r\n\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\n// SIGNAL VISUALIZATION\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\n\r\n// Determine arrow size\r\narrowSizeVal = arrowSize == \"small\" ? size.small : arrowSize == \"large\" ? size.large : size.normal\r\n\r\n// Determine signal type for labels\r\nbuyType = isStrongUptrend ? \"SHALLOW DIP\" : isDowntrend ? \"CAPITULATION\" : \"NEUTRAL\"\r\nsellType = isStrongUptrend ? \"EXTENDED\" : isDowntrend ? \"BOUNCE SELL\" : \"NEUTRAL\"\r\n\r\n// Price labels with cascade counter (when showPriceLabels is ON)\r\nif showPriceLabels and buySignal\r\n    labelOffset = low - (atr * 0.5)\r\n    counterText = enableCascadeProtection ? \"\\n[\" + str.tostring(consecutiveBuys) + \"/\" + str.tostring(maxConsecBuys) + \"]\" : \"\"\r\n    label.new(bar_index, labelOffset, \"BUY: \" + str.tostring(close, \"#.##\") + \"\\n\" + buyType + counterText, \r\n              style=label.style_label_up, color=#00FF00, size=arrowSizeVal, textcolor=color.white)\r\n\r\nif showPriceLabels and sellSignal\r\n    labelOffset = high + (atr * 0.5)\r\n    label.new(bar_index, labelOffset, \"SELL: \" + str.tostring(close, \"#.##\") + \"\\n\" + sellType, \r\n              style=label.style_label_down, color=#FF0000, size=arrowSizeVal, textcolor=color.white)\r\n\r\n// Simple arrows (when showPriceLabels is OFF)\r\nplotshape(not showPriceLabels and buySignal and arrowSize == \"small\", \r\n          location=location.belowbar, color=#00FF00, style=shape.triangleup, size=size.small)\r\nplotshape(not showPriceLabels and sellSignal and arrowSize == \"small\", \r\n          location=location.abovebar, color=#FF0000, style=shape.triangledown, size=size.small)\r\nplotshape(not showPriceLabels and buySignal and arrowSize == \"normal\", \r\n          location=location.belowbar, color=#00FF00, style=shape.triangleup, size=size.normal)\r\nplotshape(not showPriceLabels and sellSignal and arrowSize == \"normal\", \r\n          location=location.abovebar, color=#FF0000, style=shape.triangledown, size=size.normal)\r\nplotshape(not showPriceLabels and buySignal and arrowSize == \"large\", \r\n          location=location.belowbar, color=#00FF00, style=shape.triangleup, size=size.large)\r\nplotshape(not showPriceLabels and sellSignal and arrowSize == \"large\", \r\n          location=location.abovebar, color=#FF0000, style=shape.triangledown, size=size.large)\r\n\r\n// ADX indicator\r\nadxColor = adx < 15 ? color.white : adx <= 25 ? color.orange : #0000FF\r\nplotshape(showScore, location=location.bottom, color=adxColor, style=shape.circle, size=size.tiny)\r\n\r\n// Blue signal candles\r\nbarcolor(buySignal or sellSignal ? #0000FF : na)\r\n\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\n// INFO TABLE\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\nvar table scoreTable = table.new(position.top_right, 2, 10, bgcolor=color.new(color.black, 85), border_width=1)\r\nleftBg = color.new(color.gray, 70)\r\n\r\nif showTable and barstate.islast\r\n    // Row 0: Neural Score\r\n    scoreBg = gxsScore > scoreThreshBuy ? #00FF00 : gxsScore < scoreThreshSell ? #FF0000 : color.gray\r\n    table.cell(scoreTable, 0, 0, \"Score\", bgcolor=leftBg, text_color=color.white)\r\n    table.cell(scoreTable, 1, 0, str.tostring(gxsScore, \"#.###\"), bgcolor=scoreBg, text_color=color.white)\r\n    \r\n    // Row 1: Trend State\r\n    table.cell(scoreTable, 0, 1, \"Trend State\", bgcolor=leftBg, text_color=color.white)\r\n    table.cell(scoreTable, 1, 1, trendState, bgcolor=trendColor, text_color=color.white)\r\n    \r\n    // Row 2: Dynamic RSI Thresholds\r\n    rsiThreshText = \"B<\" + str.tostring(dynamicBuyRSI) + \" S>\" + str.tostring(dynamicSellRSI)\r\n    table.cell(scoreTable, 0, 2, \"RSI Thresh\", bgcolor=leftBg, text_color=color.white)\r\n    table.cell(scoreTable, 1, 2, rsiThreshText, bgcolor=color.new(#2962ff, 30), text_color=color.white)\r\n    \r\n    // Row 3: Divergence\r\n    divText = bullishDivergence ? \"BULL\" : bearishDivergence ? \"BEAR\" : \"NONE\"\r\n    divBg = bullishDivergence ? color.green : bearishDivergence ? color.red : color.gray\r\n    table.cell(scoreTable, 0, 3, \"Divergence\", bgcolor=leftBg, text_color=color.white)\r\n    table.cell(scoreTable, 1, 3, divText, bgcolor=color.new(divBg, 60), text_color=color.white)\r\n    \r\n    // Row 4: BBWP (Cascade Protection)\r\n    bbwpText = enableCascadeProtection ? str.tostring(bbwp, \"#.#\") + \"%\" : \"OFF\"\r\n    bbwpStatusText = not enableCascadeProtection ? \"OFF\" : bbwpFrozen ? \"FROZEN\" : \"OK\"\r\n    bbwpBg = not enableCascadeProtection ? color.gray : bbwpFrozen ? color.red : color.green\r\n    table.cell(scoreTable, 0, 4, \"BBWP \" + bbwpText, bgcolor=leftBg, text_color=color.white)\r\n    table.cell(scoreTable, 1, 4, bbwpStatusText, bgcolor=color.new(bbwpBg, 40), text_color=color.white)\r\n    \r\n    // Row 5: Buy Counter (Cascade Protection)\r\n    counterText = enableCascadeProtection ? str.tostring(consecutiveBuys) + \"/\" + str.tostring(maxConsecBuys) : \"OFF\"\r\n    counterBg = not enableCascadeProtection ? color.gray : consecutiveBuys >= maxConsecBuys ? color.red : consecutiveBuys >= maxConsecBuys - 1 ? color.orange : color.green\r\n    table.cell(scoreTable, 0, 5, \"Buy Counter\", bgcolor=leftBg, text_color=color.white)\r\n    table.cell(scoreTable, 1, 5, counterText, bgcolor=color.new(counterBg, 40), text_color=color.white)\r\n    \r\n    // Row 6: Market Regime\r\n    regimeText = isTrending ? \"TRENDING\" : \"RANGING\"\r\n    regimeColor = isTrending ? #4D88FF : color.orange\r\n    table.cell(scoreTable, 0, 6, \"Market\", bgcolor=leftBg, text_color=color.white)\r\n    table.cell(scoreTable, 1, 6, regimeText, bgcolor=regimeColor, text_color=color.white)\r\n    \r\n    // Row 7: ADX\r\n    adxBgColor = adx < 15 ? color.gray : adx <= 24 ? color.orange : adx > strongTrendADX ? color.blue : color.green\r\n    adxLabel = isStrongTrend ? \"ADX ‚Üë\" : \"ADX\"\r\n    table.cell(scoreTable, 0, 7, adxLabel, bgcolor=leftBg, text_color=color.white)\r\n    table.cell(scoreTable, 1, 7, str.tostring(adx, \"#.#\"), bgcolor=adxBgColor, text_color=color.white)\r\n    \r\n    // Row 8: Cooldown Status (Dynamic)\r\n    cooldownText = str.tostring(activeCooldown) + \" bars\"\r\n    cooldownBg = isStrongTrend ? color.blue : color.gray\r\n    cooldownLabel = isStrongTrend ? \"Cooldown ‚Üë\" : \"Cooldown\"\r\n    table.cell(scoreTable, 0, 8, cooldownLabel, bgcolor=leftBg, text_color=color.white)\r\n    table.cell(scoreTable, 1, 8, cooldownText, bgcolor=color.new(cooldownBg, 50), text_color=color.white)\r\n    \r\n    // Row 9: RSI (color coded against dynamic thresholds)\r\n    rsiBg = rsi < dynamicBuyRSI ? color.green : rsi > dynamicSellRSI ? color.red : color.orange\r\n    table.cell(scoreTable, 0, 9, \"RSI\", bgcolor=leftBg, text_color=color.white)\r\n    table.cell(scoreTable, 1, 9, str.tostring(rsi, \"#\"), bgcolor=rsiBg, text_color=color.white)\r\n\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\n// DEBUG TABLE\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\nvar table debugTable = table.new(position.bottom_left, 2, 10, bgcolor=color.new(color.black, 85), border_width=1)\r\n\r\nif showDebug and barstate.islast\r\n    table.cell(debugTable, 0, 0, \"Trend Score\", bgcolor=leftBg, text_color=color.white)\r\n    table.cell(debugTable, 1, 0, str.tostring(trendScore, \"#.###\"))\r\n    \r\n    table.cell(debugTable, 0, 1, \"Momentum\", bgcolor=leftBg, text_color=color.white)\r\n    table.cell(debugTable, 1, 1, str.tostring(momentumScore, \"#.###\"))\r\n    \r\n    table.cell(debugTable, 0, 2, \"Volume\", bgcolor=leftBg, text_color=color.white)\r\n    table.cell(debugTable, 1, 2, str.tostring(volumeScore, \"#.###\"))\r\n    \r\n    table.cell(debugTable, 0, 3, \"Price Struct\", bgcolor=leftBg, text_color=color.white)\r\n    table.cell(debugTable, 1, 3, str.tostring(priceStructScore, \"#.###\"))\r\n    \r\n    table.cell(debugTable, 0, 4, \"Price Action\", bgcolor=leftBg, text_color=color.white)\r\n    table.cell(debugTable, 1, 4, str.tostring(priceActionScore, \"#.###\"))\r\n    \r\n    table.cell(debugTable, 0, 5, \"Divergence\", bgcolor=leftBg, text_color=color.white)\r\n    divText = bullishDivergence ? \"BULL\" : bearishDivergence ? \"BEAR\" : \"None\"\r\n    table.cell(debugTable, 1, 5, divText)\r\n    \r\n    // Cascade Protection debug\r\n    table.cell(debugTable, 0, 6, \"Cascade Prot\", bgcolor=leftBg, text_color=color.white)\r\n    table.cell(debugTable, 1, 6, enableCascadeProtection ? \"ENABLED\" : \"DISABLED\")\r\n    \r\n    table.cell(debugTable, 0, 7, \"Buy Allowed\", bgcolor=leftBg, text_color=color.white)\r\n    table.cell(debugTable, 1, 7, cascadeAllowsBuy ? \"YES\" : \"BLOCKED\")\r\n    \r\n    // Dynamic RSI debug\r\n    table.cell(debugTable, 0, 8, \"Dynamic Buy RSI\", bgcolor=leftBg, text_color=color.white)\r\n    table.cell(debugTable, 1, 8, \"< \" + str.tostring(dynamicBuyRSI))\r\n    \r\n    table.cell(debugTable, 0, 9, \"Dynamic Sell RSI\", bgcolor=leftBg, text_color=color.white)\r\n    table.cell(debugTable, 1, 9, \"> \" + str.tostring(dynamicSellRSI))\r\n\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\n// ALERTS (Simple text alerts - TradingView compliant)\r\n// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\r\nalertcondition(buySignal, title=\"Neural Fusion BUY\", message=\"Neural Fusion Pro BUY Signal on {{ticker}} at {{close}}\")\r\nalertcondition(sellSignal, title=\"Neural Fusion SELL\", message=\"Neural Fusion Pro SELL Signal on {{ticker}} at {{close}}\")\r\nalertcondition(inBuyZone, title=\"Neural Fusion Buy Zone\", message=\"Neural Fusion Pro entering Buy Zone on {{ticker}}\")\r\nalertcondition(inSellZone, title=\"Neural Fusion Sell Zone\", message=\"Neural Fusion Pro entering Sell Zone on {{ticker}}\")\r\n\r\n// Cascade Protection alerts\r\nalertcondition(enableCascadeProtection and bbwpFrozen and not bbwpFrozen[1], title=\"BBWP Freeze Active\", message=\"BBWP exceeded freeze threshold on {{ticker}}\")\r\nalertcondition(enableCascadeProtection and not bbwpFrozen and bbwpFrozen[1], title=\"BBWP Freeze Released\", message=\"BBWP dropped below threshold on {{ticker}}\")\r\nalertcondition(enableCascadeProtection and consecutiveBuys >= maxConsecBuys and consecutiveBuys[1] < maxConsecBuys, title=\"Max Buys Reached\", message=\"Maximum consecutive buys reached on {{ticker}}\")\r\n\r\n// Dynamic Cooldown alerts\r\nalertcondition(enableDynamicCooldown and isStrongTrend and not isStrongTrend[1], title=\"Strong Trend Mode\", message=\"Strong trend detected on {{ticker}}\")\r\nalertcondition(enableDynamicCooldown and not isStrongTrend and isStrongTrend[1], title=\"Normal Cooldown Mode\", message=\"Strong trend ended on {{ticker}}\")\r\n"
  },
  "https://www.tradingview.com/script/5e6KTZwc-Continuation-Model-by-Xaus/": {
    "id": 20082080,
    "url": "https://www.tradingview.com/script/5e6KTZwc-Continuation-Model-by-Xaus/",
    "name": "Continuation Model by Xaus",
    "description": "This report summarizes the historical performance of the Institutional Daily Bias Probability Model on\nEURUSD daily data for the 2025 calendar year. The model combines three components: 1.\nContinuation bias around the previous day's high/low (PDH/PDL). 2. Reversal bias based on failed\ncontinuation, failed breakouts, and exhaustion. 3. Neutral bias to identify liquidity-building days when no\ndirectional trades should be taken. A fixed 25-pip stop loss (0.0025) is assumed for R-multiple\ncalculations. Trades are only taken when Neutral score < 50 and either Continuation or Reversal score\nis at least 70, with Neutral overriding, then Reversal, then Continuation.",
    "author_name": "CCRafael46",
    "likes_count": 45,
    "comments_count": 0,
    "views_count": 0,
    "created_at": "2025-12-11T03:14:07+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "FX:EURUSD",
      "full_name": "FX:EURUSD",
      "short_name": "EURUSD",
      "exchange": "FX",
      "type": "forex",
      "logo_id": null,
      "currency_logo_id": "country/US",
      "base_currency_logo_id": "country/EU",
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/country/EU.svg",
        "https://s3-symbol-logo.tradingview.com/country/US.svg"
      ],
      "interval": "1D",
      "direction": 0,
      "badge": {
        "label": "FX:EURUSD",
        "url": "/symbols/EURUSD/"
      }
    },
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=5\nindicator(\"Continuation Model ‚Äì Score System\", overlay=true, max_labels_count=500)\n\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// INPUTS\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nstopPips = input.float(25.0, \"Stop-Loss (pips)\", step=0.1)\nshowSignals = input.bool(true, \"Show Entry Signals\")\nshowLevels  = input.bool(true, \"Show SL/TP Levels\")\n\npip = syminfo.mintick     // automatically handles pip size\n\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// PREVIOUS DAY HIGH/LOW\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nPDH = high[1]\nPDL = low[1]\n\n// Today's candle values\nO = open\nH = high\nL = low\nC = close\n\n// Weekday: Monday = 1 ... Friday = 5\nweekday = dayofweek\n\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// 1) CONDITION: Full-body close beyond PDH/PDL (+30)\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\ncond1_bull = C > PDH\ncond1_bear = C < PDL\ncond1_score = cond1_bull or cond1_bear ? 30 : 0\n\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// 2) CONDITION: Breakout + candle color confirms (+30)\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nbullCandle = C > O\nbearCandle = C < O\n\ncond2_bull = (H > PDH) and bullCandle\ncond2_bear = (L < PDL) and bearCandle\ncond2_score = cond2_bull or cond2_bear ? 30 : 0\n\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// 3) CONDITION: Wick-only break (+20)\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nwickOnly_bull = (H > PDH) and not (C > PDH)\nwickOnly_bear = (L < PDL) and not (C < PDL)\ncond3_score = (wickOnly_bull or wickOnly_bear) ? 20 : 0\n\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// 4) CONDITION: Weekday continuation bonus (revised)\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// Monday = 1, Tuesday = 2, Wednesday = 3, Thursday = 4, Friday = 5\nweekday_bonus =\n     weekday == dayofweek.monday    ? 15 :\n     weekday == dayofweek.tuesday   ? 10 :\n     weekday == dayofweek.wednesday ? 5  :\n     weekday == dayofweek.thursday  ? 0  :\n     weekday == dayofweek.friday    ? -15 : 0\n\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// TOTAL SCORE\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\ntotalScore = cond1_score + cond2_score + cond3_score + weekday_bonus\n\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// DIRECTION LOGIC\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nvar direction = \"\"\ndirection := cond1_bull or cond2_bull or wickOnly_bull ? \"bull\" :\n             cond1_bear or cond2_bear or wickOnly_bear ? \"bear\" :\n             bullCandle ? \"bull\" :\n             bearCandle ? \"bear\" : \"none\"\n\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// TRADE SIGNALS BASED ON SCORE THRESHOLDS\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nsignal50 = totalScore >= 50\nsignal60 = totalScore >= 60\nsignal70 = totalScore >= 70\nsignal80 = totalScore >= 80\n\nenterLong  = signal70 and direction == \"bull\"\nenterShort = signal70 and direction == \"bear\"\n\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// STOP-LOSS & TAKE-PROFIT (25-pip stop default)\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nstopDistance = stopPips * pip\n\nlongSL  = O - stopDistance\nshortSL = O + stopDistance\n\nlongTP  = O + 2 * stopDistance      // 2R target\nshortTP = O - 2 * stopDistance\n\n// Optional: higher target for score ‚â• 80\nlongTP2  = signal80 ? O + 3 * stopDistance : na\nshortTP2 = signal80 ? O - 3 * stopDistance : na\n\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// PLOTTING SIGNALS\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nif showSignals\n    if enterLong\n        label.new(bar_index, low, \"BUY\\nScore: \" + str.tostring(totalScore),\n                 style=label.style_label_up, color=color.new(color.green, 0), textcolor=color.white)\n    if enterShort\n        label.new(bar_index, high, \"SELL\\nScore: \" + str.tostring(totalScore),\n                 style=label.style_label_down, color=color.new(color.red, 0), textcolor=color.white)\n\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n// PLOTTING LEVELS\n// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nif showLevels\n    if enterLong\n        line.new(bar_index, longSL, bar_index+1, longSL, color=color.red)\n        line.new(bar_index, longTP, bar_index+1, longTP, color=color.green)\n        if signal80\n            line.new(bar_index, longTP2, bar_index+1, longTP2, color=color.lime)\n\n    if enterShort\n        line.new(bar_index, shortSL, bar_index+1, shortSL, color=color.red)\n        line.new(bar_index, shortTP, bar_index+1, shortTP, color=color.green)\n        if signal80\n            line.new(bar_index, shortTP2, bar_index+1, shortTP2, color=color.lime)\n\n"
  },
  "https://www.tradingview.com/script/5d8DZG7q-Price-Action-Visualizer-EMA-SMA-Color-Bars/": {
    "id": 20087025,
    "url": "https://www.tradingview.com/script/5d8DZG7q-Price-Action-Visualizer-EMA-SMA-Color-Bars/",
    "name": "Price Action Visualizer (EMA/SMA Color Bars)",
    "description": "This custom Pine Script indicator,  \"EMA(21) vs SMA(30) Color Bars,\"  provides a unique and immediate visual representation of market bias by dynamically painting the candlesticks based on their position relative to two critical moving averages.\n\nüí° What It Does:\nThe indicator calculates and plots the 21-period Exponential Moving Average (EMA) and the 30-period Simple Moving Average (SMA). It then analyzes the closing price of each candle and colors the entire candlestick (body and border) according to pre-defined trend conditions.\n\nThis visualization allows traders to identify strong trend environments versus periods of consolidation or indecision at a glance, removing the need to constantly check the price relationship manually.\n\nüé® Color Conditions and Meaning:\nThe indicator uses three distinct color states to signal the market's current momentum:\nColor,Condition,Market Interpretation\nüü¢ GREEN,Closing Price is ABOVE both the 21 EMA AND the 30 SMA.,Strong Bullish Trend: Suggests high momentum and confirmation of an uptrend. Ideal for long bias.\nüî¥ RED,Closing Price is BELOW both the 21 EMA AND the 30 SMA.,Strong Bearish Trend: Suggests high downward pressure and confirmation of a downtrend. Ideal for short bias.\n‚ö´ GRAY,\"Closing Price is in any other state (e.g., between the two MAs, or under one and over the other).\",\"Neutral / Consolidation: Indicates uncertainty, low momentum, or potential trend exhaustion/reversal. Caution is advised.\"\n\nüîß Customization Options:The indicator is fully customizable, allowing users to fine-tune the periods to match their preferred trading style (e.g., scalping, swing trading).Dƒ∫≈æka EMA (Length EMA): Allows you to change the period for the Exponential Moving Average (default is 21).Dƒ∫≈æka SMA (Length SMA): Allows you to change the period for the Simple Moving Average (default is 30).",
    "author_name": "cryptoinvestsvk",
    "likes_count": 16,
    "comments_count": 0,
    "views_count": 0,
    "created_at": "2025-12-11T20:12:47+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "COINBASE:BTCUSD",
      "full_name": "COINBASE:BTCUSD",
      "short_name": "BTCUSD",
      "exchange": "COINBASE",
      "type": "spot",
      "logo_id": null,
      "currency_logo_id": "country/US",
      "base_currency_logo_id": "crypto/XTVCBTC",
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/crypto/XTVCBTC.svg"
      ],
      "interval": "720",
      "direction": 0,
      "badge": {
        "label": "COINBASE:BTCUSD",
        "url": "/symbols/BTCUSD/"
      }
    },
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=5\nindicator(\"EMA(21) vs SMA(30) Farba Grafu\", shorttitle=\"EMA/SMA Farba\", overlay=true)\n\n// 1. Defin√≠cia vstupov (peri√≥dy pre EMA a SMA)\nlenEMA = input.int(21, title=\"Dƒ∫≈æka EMA\")\nlenSMA = input.int(30, title=\"Dƒ∫≈æka SMA\")\n\n// 2. V√Ωpoƒçet kƒ∫zav√Ωch priemerov\nema21 = ta.ema(close, lenEMA)\nsma30 = ta.sma(close, lenSMA)\n\n// 3. Definovanie podmienok pre farbu\n// Vyu≈æ√≠vame zatv√°raciu cenu (close) pre porovnanie\nfarba = if close > ema21 and close > sma30\n    // Zelen√°: Cena je nad oboma (uptrend)\n    color.green\nelse if close < ema21 and close < sma30\n    // ƒåerven√°: Cena je pod oboma (downtrend)\n    color.red\nelse\n    // Siv√°: Cena je medzi EMA a SMA, alebo je len nad/pod jedn√Ωm z nich (neutr√°lna/konsolid√°cia)\n    color.rgb(128, 128, 128, 50) // Tmavo≈°ed√° s n√≠zkou priehƒæadnos≈•ou\n\n// 4. Aplik√°cia farby na svieƒçky\n// men√≠ farbu svieƒçok (bodies) a ich okrajov (borders)\nbarcolor(farba, title=\"Farba svieƒçok\")\n\n// Voliteƒæn√©: Zobrazenie EMA a SMA na grafe pre kontrolu\nplot(ema21, color=color.blue, title=\"EMA 21\")\nplot(sma30, color=color.orange, title=\"SMA 30\")"
  },
  "https://www.tradingview.com/script/mIEqLyjg-Tomb-Reversal-Signal-Engulfing-RSI-Momentum-Detector/": {
    "id": 20085786,
    "url": "https://www.tradingview.com/script/mIEqLyjg-Tomb-Reversal-Signal-Engulfing-RSI-Momentum-Detector/",
    "name": "Tomb Reversal Signal  Engulfing + RSI Momentum Detector",
    "description": "Tomb is a fast and minimalistic reversal-detection indicator built to capture high-probability turning points in the market.\nIt combines engulfing candlestick patterns, a strong candle body filter, and RSI momentum analysis to generate precise BUY and SELL signals with minimal noise.\n\nüîç How it Works\n\nThe indicator triggers:\n\n‚úÖ BUY Signal\n\nBullish engulfing pattern appears\n\nCandle body strength > 50% of total range (real momentum)\n\nRSI below 50 (bearish momentum weakening)\n\nPrice decreasing over the last 5 bars (down-trend exhaustion)\n\n‚úÖ SELL Signal\n\nBearish engulfing pattern\n\nCandle body shows strength\n\nRSI above 50 (bullish momentum weakening)\n\nPrice increasing over the last 5 bars (up-trend exhaustion)\n\n‚ö° Why Tomb Works\n\nFilters out weak signals using candle structure\n\nDetects momentum shifts early\n\nWorks on all markets: Crypto, Forex, Indices, Stocks\n\nIdeal for scalping, day trading, or swing trading\n\nüéØ Purpose\n\nTo highlight the exact moments where the market shows exhaustion and is ready to reverse‚Äîbefore most traders see it.\n\nüìå Recommended Use\n\nFor best performance:\n\nCombine with trend tools such as EMA 200 or market structure\n\nLook for signals at support/resistance or liquidity zones",
    "author_name": "tommybeaulieu7b",
    "likes_count": 588,
    "comments_count": 0,
    "views_count": 0,
    "created_at": "2025-12-11T15:23:49+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "CME_MINI:MNQ1!",
      "full_name": "CME_MINI:MNQ1!",
      "short_name": "MNQ1!",
      "exchange": "CME_MINI",
      "type": "futures",
      "logo_id": "country/US",
      "currency_logo_id": "country/US",
      "base_currency_logo_id": null,
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/country/US.svg"
      ],
      "interval": "5",
      "direction": 0,
      "badge": {
        "label": "CME_MINI:MNQ1!",
        "url": "/symbols/CME_MINI-MNQ1!/"
      }
    },
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "// ¬© Tomb\r\n\r\n//@version=5\r\nindicator('Tomb', overlay=true, max_labels_count=500)\r\n\r\nstable_candle = math.abs(close - open) / ta.tr > .5\r\nrsi = ta.rsi(close, 14)\r\n\r\nbullish_engulfing = close[1] < open[1] and close > open and close > open[1]\r\nrsi_below_50 = rsi < 50\r\ndecrease_over_5 = close < close[5]\r\n\r\nbull = bullish_engulfing and stable_candle and rsi_below_50 and decrease_over_5\r\n\r\nbearish_engulfing = close[1] > open[1] and close < open and close < open[1]\r\nrsi_above_50 = rsi > 50\r\nincrease_over_5 = close > close[5]\r\n\r\nbear = bearish_engulfing and stable_candle and rsi_above_50 and increase_over_5\r\n\r\nlabel.new(bull ? bar_index : na, low, 'BUY', color=color.rgb(0, 255, 8), style=label.style_label_up, textcolor=color.white, size=size.large)\r\nlabel.new(bear ? bar_index : na, high, 'SELL', color=color.rgb(255, 0, 0), style=label.style_label_down, textcolor=color.white, size=size.large)"
  },
  "https://www.tradingview.com/script/l4PKhR5s-LL-HL-Pivot/": {
    "id": 20086698,
    "url": "https://www.tradingview.com/script/l4PKhR5s-LL-HL-Pivot/",
    "name": "LL-HL Pivot",
    "description": "This indicator scans for the bullish structure known as a Higher Low (HL) across multiple lengths simultaneously, automatically selects the most suitable pattern, and plots it on the chart.\n\nBelow is a detailed explanation of how it works.\n\n 1. Basic Calculation Method (Definition of LL and HL) \n\nThis indicator is built on TradingView‚Äôs ta.pivotlow function.\n\nDetecting Pivot Lows\nFor a given length, a Pivot Low is identified as the lowest point among the candles within the specified range to the left and right.\n\nLL and HL Determination\nLL (Lowest Low): The most recent Pivot Low is treated as the previous low.\nHL (Higher Low): When a new Pivot Low forms above the previous LL, it is recognized as an HL, and the setup is considered ‚Äúcomplete.‚Äù\n\nIdentifying the Pivot Line\nDuring the LL‚ÄìHL structure, the highest high between them is identified and used as the breakout level (Pivot Line / resistance), where a horizontal line is drawn.\n\n 2. Multi-Length Scanning \n\nUnlike standard indicators that use only one length (e.g., Length = 5), this indicator evaluates a full range of lengths.\n\nMin Length to Max Length\nExample: Min = 2, Max = 10\nInternally, it functions as if nine separate indicators (Length 2, 3, 4 ‚Ä¶ 10) are running simultaneously.\n\nThis allows the indicator to capture:\nSmall waves (short-term pullbacks)\nLarger waves (broader structural moves)\n\n 3. Priority Mode System \n\nBecause multiple lengths are calculated at the same time, different LL‚ÄìHL patterns may appear simultaneously.Priority Mode determines which setup is selected and displayed.\n\n A. Lowest LH \n\nSelects the pattern with the lowest pivot line (intermediate high).\n\nAdvantages:\nProduces the lowest possible entry price\n\n B. Longest Length \n\nSelects the pattern with the longest length.\n\nAdvantages:\nFocuses on larger structures and broader waves\nFilters out noise\n\n C. Shortest Length \n\nSelects the pattern with the shortest length.\n\nAdvantages:\nReacts quickly to small moves\nUseful for scalping or fast trend-following\nCaptures very short-term pullbacks\n\n 4. Additional Behavior and Features \n\nReal-Time Invalidation\nIf price breaks below the confirmed HL, the structure is immediately considered invalid.\nAll previously drawn lines and labels are removed instantly, preventing outdated structures from remaining on the chart.\n\nPivot Line Extension\nAs long as the HL remains intact, the Pivot Line (breakout level) continues extending to the right.\n\nAlerts\nAn alert can be triggered the moment price breaks above the Pivot Line on a closing basis.",
    "author_name": "oratnek",
    "likes_count": 356,
    "comments_count": 1,
    "views_count": 0,
    "created_at": "2025-12-11T18:34:15+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "NASDAQ:WDC",
      "full_name": "NASDAQ:WDC",
      "short_name": "WDC",
      "exchange": "NASDAQ",
      "type": "stock",
      "logo_id": "webster-financial",
      "currency_logo_id": "country/US",
      "base_currency_logo_id": null,
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/webster-financial.svg"
      ],
      "interval": "1D",
      "direction": 0,
      "badge": {
        "label": "NASDAQ:WDC",
        "url": "/symbols/NASDAQ-WDC/"
      }
    },
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=6\r\nindicator('LL-HL Pivot', overlay = true, max_lines_count = 500, max_labels_count = 500)\r\n\r\n// --- Settings ---\r\ngrp_calc = 'Calculation'\r\nmin_len_input = input.int(2, 'Min Length', minval = 1, group = grp_calc)\r\nmax_len_input = input.int(10, 'Max Length', minval = 2, group = grp_calc)\r\npriority_mode = input.string(\"Lowest LH\", \"Priority Mode\", options=[\"Lowest LH\", \"Longest Length\", \"Shortest Length\"], group=grp_calc)\r\n\r\n// --- Visibility Settings ---\r\ngrp_vis = 'Visibility Settings'\r\nshow_LL     = input.bool(true, 'Show LL Label', group = grp_vis)\r\nshow_HL     = input.bool(true, 'Show HL Label', group = grp_vis)\r\nshow_Trend  = input.bool(true, 'Show Trendline', group = grp_vis)\r\nshow_PLine  = input.bool(true, 'Show Pivot Line', group = grp_vis)\r\nshow_PLabel = input.bool(true, 'Show Pivot Price', group = grp_vis)\r\n\r\ngrp_lbl = 'Label Settings'\r\nlblSize = input.string(size.normal, 'Text Size', options = [size.tiny, size.small, size.normal, size.large], group = grp_lbl)\r\ncol_LLHL = input.color(color.gray, 'LL / HL Text Color', group = grp_lbl)\r\ncol_PivText = input.color(color.gray, 'Pivot Price Color', group = grp_lbl)\r\n\r\ngrp_line = 'Line Settings'\r\ncol_Trend = input.color(color.gray, 'Trendline Color (LL-HL)', group = grp_line)\r\nwidth_Trend = input.int(1, 'Trendline Width', minval = 1, group = grp_line)\r\nstyle_Trend = input.string(line.style_dashed, 'Trendline Style', options = [line.style_solid, line.style_dashed, line.style_dotted], group = grp_line)\r\ncol_Pivot = input.color(color.gray, 'Pivot Line Color', group = grp_line)\r\nwidth_Pivot = input.int(2, 'Pivot Line Width', minval = 1, group = grp_line)\r\nstyle_Pivot = input.string(line.style_solid, 'Pivot Line Style', options = [line.style_solid, line.style_dashed, line.style_dotted], group = grp_line)\r\n\r\n// --- Struct Definition ---\r\ntype PivotState\r\n    int len          \r\n    float prev_pl    \r\n    int prev_idx     \r\n    float curr_pl    \r\n    int curr_idx     \r\n    bool is_setup    \r\n    float lh_val     \r\n    int lh_idx       \r\n\r\n// --- Variable Definition ---\r\nvar PivotState[] states = array.new<PivotState>()\r\n\r\nif bar_index == 0\r\n    for i = min_len_input to max_len_input\r\n        array.push(states, PivotState.new(i, na, na, na, na, false, na, na))\r\n\r\nvar line activeTrendLine = na\r\nvar line activePivotLine = na\r\nvar label activePriceLabel = na\r\nvar label activeLLLabel = na\r\nvar label activeHLLabel = na\r\nvar int last_drawn_signature = 0 \r\n\r\n// --- Method: Update State ---\r\nmethod update(PivotState st) =>\r\n    float p = ta.pivotlow(low, st.len, st.len)\r\n    if not na(p)\r\n        bool is_hl = false\r\n        if not na(st.curr_pl) and p > st.curr_pl\r\n            is_hl := true\r\n        \r\n        st.prev_pl := st.curr_pl\r\n        st.prev_idx := st.curr_idx\r\n        st.curr_pl := p\r\n        st.curr_idx := bar_index - st.len\r\n        st.is_setup := is_hl\r\n        st.lh_val := na\r\n        st.lh_idx := na\r\n        \r\n        if is_hl and not na(st.prev_idx)\r\n            float max_h = 0.0\r\n            int max_h_idx = -1\r\n            int start_scan = st.prev_idx + 1\r\n            int end_scan = st.curr_idx - 1\r\n            if end_scan >= start_scan\r\n                for i = start_scan to end_scan\r\n                    float val = high[bar_index - i]\r\n                    if val > max_h\r\n                        max_h := val\r\n                        max_h_idx := i\r\n            if max_h_idx != -1\r\n                st.lh_val := max_h\r\n                st.lh_idx := max_h_idx\r\n\r\n// --- Main Logic ---\r\n\r\n// 1. Update all lengths & Check failure\r\nfor st in states\r\n    st.update()\r\n    if st.is_setup and not na(st.curr_pl) and low < st.curr_pl\r\n        st.is_setup := false \r\n\r\n// 2. Winner selection logic\r\nPivotState winner = na\r\n\r\nfor st in states\r\n    if st.is_setup and not na(st.lh_val)\r\n        bool update_winner = false\r\n        if na(winner)\r\n            update_winner := true\r\n        else\r\n            if priority_mode == \"Lowest LH\"\r\n                if st.lh_val < winner.lh_val\r\n                    update_winner := true\r\n            else if priority_mode == \"Longest Length\"\r\n                update_winner := true\r\n            else if priority_mode == \"Shortest Length\"\r\n                update_winner := false\r\n        \r\n        if update_winner\r\n            winner := st\r\n\r\n// 3. Default\r\nif na(winner)\r\n    if array.size(states) > 0\r\n        winner := array.get(states, 0)\r\n\r\n// ‚òÖ LL Tracking\r\nif not winner.is_setup and not na(winner.curr_pl) and low < winner.curr_pl\r\n    winner.curr_pl := low\r\n    winner.curr_idx := bar_index\r\n\r\n// --- Drawing ---\r\nint current_signature = winner.curr_idx * 1000 + winner.len * 10 + (winner.is_setup ? 1 : 0)\r\n\r\nif current_signature != last_drawn_signature\r\n    // Delete existing drawings (refresh)\r\n    line.delete(activeTrendLine)\r\n    line.delete(activePivotLine)\r\n    label.delete(activePriceLabel)\r\n    label.delete(activeLLLabel)\r\n    label.delete(activeHLLabel)\r\n    \r\n    activeTrendLine := na\r\n    activePivotLine := na\r\n    \r\n    if not na(winner.curr_pl)\r\n        // Draw current Pivot Low (LL or HL)\r\n        string txt = winner.is_setup ? \"HL\" : \"LL\"\r\n        bool should_show_current = winner.is_setup ? show_HL : show_LL\r\n        \r\n        if should_show_current\r\n            activeHLLabel := label.new(winner.curr_idx, winner.curr_pl, text=txt, style=label.style_label_up, color=color.new(color.white, 100), textcolor=col_LLHL, size=lblSize)\r\n        \r\n        // Draw on Setup Completion (HL confirmed)\r\n        if winner.is_setup and not na(winner.prev_idx)\r\n            // Previous LL Label\r\n            if show_LL\r\n                activeLLLabel := label.new(winner.prev_idx, winner.prev_pl, text=\"LL\", style=label.style_label_up, color=color.new(color.white, 100), textcolor=col_LLHL, size=lblSize)\r\n            \r\n            // Trendline (connecting LL and HL)\r\n            if show_Trend\r\n                activeTrendLine := line.new(winner.prev_idx, winner.prev_pl, winner.curr_idx, winner.curr_pl, color=col_Trend, style=style_Trend, width=width_Trend)\r\n            \r\n            if not na(winner.lh_idx)\r\n                // Pivot Line (Horizontal)\r\n                if show_PLine\r\n                    activePivotLine := line.new(winner.lh_idx, winner.lh_val, bar_index + 10, winner.lh_val, color=col_Pivot, width=width_Pivot, style=style_Pivot)\r\n                \r\n                // Pivot Price Label\r\n                if show_PLabel\r\n                    activePriceLabel := label.new(bar_index + 10, winner.lh_val, text=\"Pivot = \" + str.tostring(winner.lh_val, format.mintick), style=label.style_label_left, color=color.new(color.white, 100), textcolor=col_PivText, size=lblSize)\r\n\r\n    last_drawn_signature := current_signature\r\n\r\n// --- Realtime Extension & Failure Monitoring ---\r\nif winner.is_setup\r\n    // Extend lines only if they exist\r\n    if not na(activePivotLine)\r\n        line.set_x2(activePivotLine, bar_index + 5)\r\n    \r\n    if not na(activePriceLabel)\r\n        label.set_x(activePriceLabel, bar_index + 5)\r\n    \r\n    // Handle Failure (Price broke below HL)\r\n    if low < winner.curr_pl\r\n        winner.is_setup := false\r\n        line.delete(activeTrendLine)\r\n        line.delete(activePivotLine)\r\n        label.delete(activePriceLabel) \r\n        label.delete(activeLLLabel)\r\n        label.delete(activeHLLabel)\r\n        activeTrendLine := na\r\n        activePivotLine := na\r\n        last_drawn_signature := -1 \r\n\r\n// ==========================================\r\n// ‚òÖ Alert Function (Pivot Breakout Alert) ‚òÖ\r\n// ==========================================\r\nbool alert_trigger = false\r\n\r\n// If setup is valid and close crosses over Pivot Line\r\nif winner.is_setup and not na(winner.lh_val)\r\n    if ta.crossover(close, winner.lh_val)\r\n        alert_trigger := true\r\n\r\nalertcondition(alert_trigger, title=\"Pivot Breakout\", message=\"Price broke above Pivot Line!\")"
  },
  "https://www.tradingview.com/script/vHodSZ11-Fractal-Fade-Pro-Indicator/": {
    "id": 20083305,
    "url": "https://www.tradingview.com/script/vHodSZ11-Fractal-Fade-Pro-Indicator/",
    "name": "Fractal Fade Pro Indicator",
    "description": "A revolutionary contrarian trading indicator that applies chaos theory, fractal mathematics, and market entropy to generate high-probability reverse signals. This indicator fades traditional technical signals, providing BUY signals when conventional indicators say SELL, and SELL signals when they say BUY.\n\nFull Description:\nMost traders follow the herd. QFCI does the opposite. It identifies when conventional technical analysis is about to fail by detecting mathematical patterns of exhaustion in market structure.\n\nHow It Works (Technical Overview):\nThe indicator combines three sophisticated mathematical approaches:\n\nFractal Dimension Analysis: Measures the \"roughness\" of price movements using fractal mathematics\nMarket Entropy Calculation: Quantifies the randomness and disorder in price returns using information theory\nPhase Space Reconstruction: Analyzes price evolution in multi-dimensional state space from chaos theory\n\nSignal Generation Process:\nStep 1: Market Regime Detection\nChaotic Regime: High fractal complexity + rising entropy (avoid trading)\nTrending Regime: Low fractal complexity + high phase space distance (fade breakouts)\nMean-Reverting Regime: Very low fractal complexity (fade extremes)\n\nStep 2: Reverse Signal Logic\nWhen traditional indicators would give:\nBUY signal (breakout, oversold bounce, volatility spike) ‚Üí QFCI shows SELL\nSELL signal (breakdown, overbought rejection, volatility crash) ‚Üí QFCI shows BUY\n\nStep 3: Smart Signal Filtering\nNo consecutive same-direction signals\nAdjustable minimum bars between signals\nMultiple confirmation layers required\n\nUnique Features:\n1. Mathematical Innovation:\nOriginal fractal dimension algorithm (not standard indicators)\nMarket entropy calculation from information theory\nPhase space reconstruction from chaos theory\nMulti-regime adaptive logic\n\n2. Trading Psychology Advantage:\nContrarian by design - profits from market overreactions\nFades retail trader mistakes - enters when others are exiting\nReduces overtrading - strict signal frequency controls\n\n3. Clean Visual Interface:\nOnly BUY/SELL labels - no chart clutter\nClear directional arrows - immediate signal recognition\nBuilt-in alerts - never miss a trade\n\nRecommended Settings:\nDefault (Balanced Approach):\nFractal Depth: 20\nEntropy Period: 200\nMin Bars Between Signals: 100\n\nAggressive Trading:\nFractal Depth: 10-15\nEntropy Period: 100-150\nMin Bars Between Signals: 50-75\n\nConservative Trading:\nFractal Depth: 30-40\nEntropy Period: 300-400\nMin Bars Between Signals: 150-200\n\nOptimal Timeframes:\nPrimary: Daily, Weekly (best performance)\nSecondary: 4-Hour, 12-Hour\nCan work on: 1-Hour (with adjusted parameters)\n\nHow to Use:\nFor Beginners:\nApply indicator to chart\nUse default settings\nWait for BUY/SELL labels\nEnter on next candle open\nUse 2:1 risk/reward ratio\nAlways use stop losses\n\nFor Advanced Traders:\nAdjust parameters for your trading style\nCombine with support/resistance levels\nUse volume confirmation\nScale in/out of positions\nTrack performance by regime\n\nRisk Management Guidelines:\nPosition Sizing:\nConservative: 1-2% risk per trade\nModerate: 2-3% risk per trade\nAggressive: 3-5% risk per trade (not recommended)\n\nStop Loss Placement:\nBUY signals: Below recent swing low or -2x ATR\nSELL signals: Above recent swing high or +2x ATR\n\nTake Profit Targets:\nPrimary: 2x risk (minimum)\nSecondary: Previous support/resistance\nTertiary: Trailing stops after 1.5x risk\n\nIMPORTANT RISK DISCLOSURE\nThis indicator is for educational and informational purposes only. It is not financial advice. Past performance does not guarantee future results. Trading involves substantial risk of loss and is not suitable for every investor. The risk of loss in trading can be substantial. You should therefore carefully consider whether such trading is suitable for you in light of your financial condition.",
    "author_name": "ChandraBose2002",
    "likes_count": 472,
    "comments_count": 0,
    "views_count": 0,
    "created_at": "2025-12-11T07:44:05+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "NSE:NIFTY",
      "full_name": "NSE:NIFTY",
      "short_name": "NIFTY",
      "exchange": "NSE",
      "type": "index",
      "logo_id": "indices/nifty-50",
      "currency_logo_id": "country/IN",
      "base_currency_logo_id": null,
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/indices/nifty-50.svg"
      ],
      "interval": "5",
      "direction": 0,
      "badge": {
        "label": "NSE:NIFTY",
        "url": "/symbols/NSE-NIFTY/"
      }
    },
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// ¬© chandrabose2002\n\n//@version=6\nindicator(\"Fractal Fade Pro Indicator\", overlay=true, shorttitle=\"Fractal Fade Pro Indicator\", max_labels_count=500)\n\n// Inputs - ALL RESTORED\nfractal_depth = input.int(20, \"Fractal Depth\", minval=3, maxval=100, group=\"Signal Settings\")\nentropy_period = input.int(200, \"Entropy Period\", minval=20, maxval=1000, group=\"Signal Settings\")\nmin_bars_between_signals = input.int(100, \"Min Bars Between Signals\", minval=1, maxval=300, group=\"Signal Settings\")\n\n// Pre-calculate all required indicators globally\nema50 = ta.ema(close, 50)\ncurrent_rsi = ta.rsi(close, 14)\nvolume_ma = ta.sma(volume, 20)\nvol_ratio = volume / volume_ma\natr = ta.atr(14)\n\n// Bollinger Bands calculations\nbb_length = 20\nbb_mult = 2.0\nbb_basis = ta.sma(close, bb_length)\nbb_dev = bb_mult * ta.stdev(close, bb_length)\nbb_upper = bb_basis + bb_dev\nbb_lower = bb_basis - bb_dev\n\n// Support/Resistance levels\nupper_band = ta.highest(high, 10) + atr * 0.5\nlower_band = ta.lowest(low, 10) - atr * 0.5\n\n// Unique: Fractal Dimension Calculation\nfractal_dimension(price, depth) =>\n    hh = ta.highest(high, depth)\n    ll = ta.lowest(low, depth)\n    range_sum = hh - ll\n    n = depth\n    fractal = math.log(range_sum / n) / math.log(n)\n    fractal\n\n// Calculate fractal dimensions for different scales\nfd1 = fractal_dimension(close, fractal_depth)\nfd2 = fractal_dimension(close, fractal_depth * 2)\nfd3 = fractal_dimension(close, fractal_depth * 3)\n\n// Fractal complexity\nfractal_complexity = (fd1 + fd2 + fd3) / 3\n\n// Unique: Market Entropy Calculation\nmarket_entropy(period) =>\n    returns = math.log(close / close[1])\n    mean_return = ta.sma(returns, period)\n    variance = 0.0\n    for i = 0 to period - 1\n        variance += math.pow(returns[i] - mean_return, 2)\n    variance := variance / period\n    entropy = math.log(math.sqrt(variance) + 1) * 100\n    entropy\n\nentropy = market_entropy(entropy_period)\nentropy_ma = ta.sma(entropy, 20)\n\n// Unique: Phase Space Reconstruction\nphase_space_distance(price, delay, dimension) =>\n    sum_dist = 0.0\n    for i = 0 to dimension - 1\n        for j = i + 1 to dimension - 1\n            dist = math.abs(price[i * delay] - price[j * delay])\n            sum_dist += dist\n    avg_dist = sum_dist / (dimension * (dimension - 1) / 2)\n    avg_dist\n\nps_distance = phase_space_distance(close, 3, 5)\nps_distance_norm = ps_distance / atr\n\n// Calculate regime classification\nvar int market_regime = 0 // 0: chaotic, 1: trending, 2: mean-reverting\n\n// Regime detection logic\nif fractal_complexity > 1.3 and entropy > entropy_ma * 1.1\n    market_regime := 0 // Chaotic\nelse if fractal_complexity < 1.4 and ps_distance_norm > 1.2\n    market_regime := 1 // Trending\nelse if fractal_complexity < 1.2\n    market_regime := 2 // Mean-reverting\nelse\n    market_regime := 0\n\n// ============================================\n// NO CONSECUTIVE SIGNALS LOGIC\n// ============================================\nvar int bars_since_last_signal = 999\nvar int last_signal_bar = 0\n\n// Track bars since last signal\nbars_since_last_signal := bars_since_last_signal + 1\n\n// Raw signal conditions\ntrend_buy_raw = market_regime == 1 and close > ema50 and close[1] <= ema50[1] and fractal_complexity < 1.3\ntrend_sell_raw = market_regime == 1 and close < ema50 and close[1] >= ema50[1] and fractal_complexity < 1.3\n\nmean_buy_raw = market_regime == 2 and current_rsi < 35 and close <= bb_lower * 1.01 and ps_distance_norm > 0.8\nmean_sell_raw = market_regime == 2 and current_rsi > 65 and close >= bb_upper * 0.99 and ps_distance_norm > 0.8\n\nchaotic_buy_raw = market_regime == 0 and close > upper_band and vol_ratio > 1.2\nchaotic_sell_raw = market_regime == 0 and close < lower_band and vol_ratio > 1.2\n\n// Combined raw signals\nbuy_signal_raw = trend_buy_raw or mean_buy_raw or chaotic_buy_raw\nsell_signal_raw = trend_sell_raw or mean_sell_raw or chaotic_sell_raw\n\n// REVERSE SIGNAL LOGIC (Hardcoded - Always Reverse)\n// When BUY condition triggers ‚Üí Show SELL signal\n// When SELL condition triggers ‚Üí Show BUY signal\nfinal_buy_condition = sell_signal_raw  // SELL conditions become BUY signals\nfinal_sell_condition = buy_signal_raw  // BUY conditions become SELL signals\n\n// No consecutive same-direction signals\nsignal_allowed = bars_since_last_signal >= min_bars_between_signals\n\n// Final signals with prevention\nqf_buy = final_buy_condition and signal_allowed  // This shows BUY label\nqf_sell = final_sell_condition and signal_allowed  // This shows SELL label\n\n// Update signal tracking\nif qf_buy or qf_sell\n    bars_since_last_signal := 0\n    last_signal_bar := bar_index\n\n// Set signal labels - ONLY REVERSE SIGNALS\nif qf_buy\n    // This is triggered by SELL conditions, so show REVERSE BUY\n    label.new(bar_index, low * 0.998, text=\"BUY\", \n             style=label.style_label_up, color=color.green, \n             textcolor=color.white, yloc=yloc.price, size=size.normal)\n    \nif qf_sell\n    // This is triggered by BUY conditions, so show REVERSE SELL  \n    label.new(bar_index, high * 1.002, text=\"SELL\", \n             style=label.style_label_down, color=color.red, \n             textcolor=color.white, yloc=yloc.price, size=size.normal)\n\n// Alerts\nif qf_buy\n    alert(\"BUY Signal\", alert.freq_once_per_bar)\n    \nif qf_sell\n    alert(\" SELL Signal\", alert.freq_once_per_bar)"
  },
  "https://www.tradingview.com/script/HgekvPEN-Orderblock-Footprints-AlgoAlpha/": {
    "id": 20090112,
    "url": "https://www.tradingview.com/script/HgekvPEN-Orderblock-Footprints-AlgoAlpha/",
    "name": "Orderblock Footprints [AlgoAlpha]",
    "description": "üü† OVERVIEW \nThis script highlights orderblocks and then drills into what actually trades inside them. Zones are created only after an abnormal directional impulse, measured with a z-score on consecutive candle bodies, so the orderblocks are tied to real expansion rather than simple pivots. Once a zone exists, the script overlays lower-timeframe volume footprints inside the candle when price trades back into that zone. The goal is to show not just where an orderblock sits, but whether price is being accepted or absorbed when it is revisited.\n\nüü† CONCEPTS \nOrderblocks are detected after extreme bullish or bearish impulses. The script tracks consecutive body movement up or down, normalizes that distance with a rolling z-score, and only triggers when the move is statistically large. The last opposite candle before that impulse defines the orderblock range. These zones then extend forward until they are either mitigated by price closing through them or they expire by age.\n\nInside an active zone, the script switches to a lower timeframe and builds a footprint-style profile for each bar. Each candle is split into price rows, counting time-at-price and volume delta. Positive and negative delta are colored separately. Absorption is flagged when opposing delta prints appear in the wick that rejects the zone. In practice: the impulse defines  context ; the footprint shows  interaction .\n\nüü† FEATURES \n \n  Separate bullish and bearish zones with automatic extension\n  \n  Volume split inside each zone candle (up vs down volume)\n  \n  Lower-timeframe footprint with TPO-style rows and delta gradient\n  \n  Absorption detection using opposing delta in rejection wicks\n  \n  Alerts for zone creation and absorption events\n \n\nüü† USAGE \n \n   Setup : Add the script to your chart. It works on any market and timeframe. The lower timeframe for footprints is fixed at 5 minutes, so higher chart timeframes show clearer structure. Use the  Z-Score Window  to control how strict impulse detection is and  Max Box Age  to limit how long old zones stay on the chart.\n   Read the chart : Bullish orderblocks are created after strong upward impulses and are invalidated when price closes below them. Bearish orderblocks are created after strong downward impulses and are invalidated when price closes above them. When price trades inside a zone, footprint rows appear. Green-tinted rows show positive delta; red-tinted rows show negative delta. Absorption labels appear when opposing delta prints into a rejecting wick.\n   Settings that matter : Increasing the  Z-Score Window  makes orderblocks rarer but more significant. Disabling  Prevent Overlap  allows stacked zones if you want to study clustering. Adjusting  Rows per bar  changes footprint resolution‚Äîlower values are cleaner, higher values show more detail but use more objects.\n \n",
    "author_name": "AlgoAlpha",
    "likes_count": 370,
    "comments_count": 2,
    "views_count": 0,
    "created_at": "2025-12-12T09:53:40+00:00",
    "updated_at": "2025-12-12T09:56:09+00:00",
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "BITSTAMP:ETHUSD",
      "full_name": "BITSTAMP:ETHUSD",
      "short_name": "ETHUSD",
      "exchange": "BITSTAMP",
      "type": "spot",
      "logo_id": null,
      "currency_logo_id": "country/US",
      "base_currency_logo_id": "crypto/XTVCETH",
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/crypto/XTVCETH.svg"
      ],
      "interval": "60",
      "direction": 0,
      "badge": {
        "label": "BITSTAMP:ETHUSD",
        "url": "/symbols/ETHUSD/"
      }
    },
    "created": "2025-12-12",
    "updated": "2025-12-12",
    "source": "//@version=6\r\nindicator(\"Orderblock Footprints [AlgoAlpha]\", shorttitle = \"AlgoAlpha - Orderblock Footprints\", overlay = true, behind_chart = false, max_boxes_count = 500, max_lines_count = 500, max_labels_count = 500)\r\nimport TradingView/ta/10\r\n\r\n// ============================================================================\r\n// INPUTS\r\n// ============================================================================\r\npreventOverlap = input.bool(true, title = \"Prevent Overlap\", group = \"Calculation\", tooltip = \"When enabled, new orderblocks will not be created if their price range overlaps any existing active orderblock.\\n\\nDisable this only if you intentionally want stacked/overlapping zones.\")\r\nzLen = input.int(100, title = \"Z-Score Window (bars)\", minval = 1, group = \"Calculation\", tooltip = \"Lookback window used to normalize the impulse distance into a z-score.\\n\\nHigher values = smoother/less reactive; lower values = faster/more signals.\")\r\nmaxAge = input.int(500, title = \"Max Box Age (bars)\", minval = 1, group = \"Calculation\", tooltip = \"Maximum lifetime (in bars) of an orderblock that has not been mitigated.\\n\\nAfter this many bars the zone is removed to reduce clutter and object usage.\")\r\n\r\n// ============================================================================\r\n// FOOTPRINT SETTINGS\r\n// ============================================================================\r\nmax_label_in_row  = input.int(7, \"Rows per bar\", group = \"Footprint Settings\", minval = 1, maxval = 100, tooltip = \"Controls the vertical resolution of the footprint inside each candle.\\n\\nThe script auto-selects the price step so the candle fits into approximately this many rows. Lower = chunkier/cleaner; higher = more detailed but heavier.\")\r\n\r\n// ============================================================================\r\n// APPEARANCE\r\n// ============================================================================\r\nbullCol = input.color(#00ffbb, title = \"Bullish Colour\", group = \"Appearance\", tooltip = \"Primary bullish color used for bullish UI elements.\\n\\nUsed by: bullish orderblock volume bar, positive delta footprint gradient, and bullish absorption labels.\")\r\nbearCol = input.color(#ff1100, title = \"Bearish Colour\", group = \"Appearance\", tooltip = \"Primary bearish color used for bearish UI elements.\\n\\nUsed by: bearish orderblock volume bar, negative delta footprint gradient, and bearish absorption labels.\")\r\n\r\nconst string ltf  = \"5\"\r\n[upv, downv, deltav] = ta.requestUpAndDownVolume(ltf)\r\n\r\n// ============================================================================\r\n// TYPES & METHODS\r\n// ============================================================================\r\ntype profile\r\n    float[] levels\r\n    float[] delta\r\n    int  [] tpo\r\n\r\nmethod step_level(profile p, float row_size, int i) =>\r\n    if i == 0\r\n        p.levels.unshift(low)\r\n        p.tpo.unshift(0)\r\n        p.delta.unshift(0)\r\n    else\r\n        p.levels.unshift(low + (row_size * i))\r\n        p.tpo.unshift(0)\r\n        p.delta.unshift(0)\r\n    p.levels.get(0)\r\n\r\nmethod add_print(profile p, float c, float o, int x, float v) =>\r\n    switch\r\n        c > o =>\r\n            p.tpo.set(x, p.tpo.get(x) + 1)\r\n            p.delta.set(x, p.delta.get(x) + v)\r\n        c < o =>\r\n            p.tpo.set(x, p.tpo.get(x) + 1)\r\n            p.delta.set(x, p.delta.get(x) - v)\r\n\r\nmethod stamp(float y, color css, string txt, string size) =>\r\n    label.new(\r\n          x                = bar_index\r\n        , y                = y\r\n        , style            = label.style_label_center\r\n        , color            = #ffffff00\r\n        , textcolor        = css\r\n        , text             = txt\r\n        , size             = size\r\n        , xloc             = xloc.bar_index\r\n        , text_font_family = font.family_monospace\r\n        )\r\n\r\nget_auto_tick_per_row() =>\r\n    int temp_tick_per_row = 1\r\n    float temp_row_size = temp_tick_per_row * syminfo.mintick\r\n    while low + max_label_in_row * temp_row_size <= high\r\n        temp_tick_per_row += 1\r\n        temp_row_size := temp_tick_per_row * syminfo.mintick\r\n    temp_row_size\r\n\r\n// ============================================================================\r\n// CALCULATIONS\r\n// ============================================================================\r\nvar updist = 0.0\r\nvar downdist = 0.0\r\n\r\nupdist   := close > open ? nz(updist[1]) + (close - open) : 0.0\r\ndowndist := close < open ? nz(downdist[1]) + (open - close) : 0.0\r\n\r\nupMean  = ta.sma(updist, zLen)\r\nupStdev = ta.stdev(updist, zLen)\r\ndnMean  = ta.sma(downdist, zLen)\r\ndnStdev = ta.stdev(downdist, zLen)\r\n\r\nzUp = (updist - upMean) / (upStdev == 0.0 ? na : upStdev)\r\nzDn = (downdist - dnMean) / (dnStdev == 0.0 ? na : dnStdev)\r\n\r\nbullish = ta.crossover(zUp, 4) and nz(zUp[1]) != 0\r\nbearish = ta.crossunder(-zDn, -4) and nz((-zDn)[1]) != 0\r\n\r\nvar box[] bullBoxes = array.new<box>()\r\nvar box[] bearBoxes = array.new<box>()\r\nvar int[] bullStarts = array.new_int()\r\nvar int[] bearStarts = array.new_int()\r\n\r\nvar box[] bullVolUpBoxes = array.new<box>()\r\nvar box[] bullVolDnBoxes = array.new<box>()\r\nvar float[] bullVolUpData = array.new<float>()\r\nvar float[] bullVolDnData = array.new<float>()\r\n\r\nvar box[] bearVolUpBoxes = array.new<box>()\r\nvar box[] bearVolDnBoxes = array.new<box>()\r\nvar float[] bearVolUpData = array.new<float>()\r\nvar float[] bearVolDnData = array.new<float>()\r\n\r\nbullCreate = false\r\nbearCreate = false\r\n\r\nf_can_create(float tNew, float bNew) =>\r\n    bool ok = true\r\n    if bullBoxes.size() > 0\r\n        for j = 0 to array.size(bullBoxes) - 1\r\n            exB = array.get(bullBoxes, j)\r\n            float exTop = box.get_top(exB)\r\n            float exBot = box.get_bottom(exB)\r\n            if (tNew > exBot) and (bNew < exTop)\r\n                ok := false\r\n                break\r\n    if ok and bearBoxes.size() > 0\r\n        for j = 0 to array.size(bearBoxes) - 1\r\n            exS = array.get(bearBoxes, j)\r\n            float exTop2 = box.get_top(exS)\r\n            float exBot2 = box.get_bottom(exS)\r\n            if (tNew > exBot2) and (bNew < exTop2)\r\n                ok := false\r\n                break\r\n    ok\r\n\r\nlastDownIdx = ta.valuewhen(close < open, bar_index, 0)\r\nlastDownHigh = ta.valuewhen(close < open, high, 0)\r\nlastDownLow = ta.valuewhen(close < open, low, 0)\r\nif bullish and not na(lastDownIdx) and not na(lastDownHigh) and not na(lastDownLow)\r\n    if not preventOverlap or f_can_create(lastDownHigh, lastDownLow)\r\n        int ago = bar_index - lastDownIdx\r\n        float upV = nz(upv[ago])\r\n        float dnV = math.abs(nz(downv[ago]))\r\n        float midYB = (lastDownHigh + lastDownLow) / 2.0\r\n\r\n        bx = box.new(\r\n             lastDownIdx, lastDownHigh, lastDownIdx + 1, lastDownLow,\r\n             border_color = color.new(chart.fg_color, 95),\r\n             bgcolor = color.new(chart.fg_color, 92),\r\n             text = \"‚ñ≤: \" + str.tostring(upV, format.volume) + \" | ‚ñº: \" + str.tostring(dnV, format.volume),\r\n             text_size = size.tiny, text_color = chart.fg_color,\r\n             text_halign = text.align_right, text_valign = text.align_bottom\r\n        )\r\n        array.unshift(bullBoxes, bx)\r\n        array.unshift(bullStarts, lastDownIdx)\r\n\r\n        box upBox = box.new(lastDownIdx, lastDownHigh, lastDownIdx + 1, midYB, border_color = color.new(bullCol, 90), bgcolor = color.new(bullCol, 70))\r\n        box dnBox = box.new(lastDownIdx, midYB, lastDownIdx + 1, lastDownLow, border_color = color.new(bearCol, 90), bgcolor = color.new(bearCol, 70))\r\n        array.unshift(bullVolUpBoxes, upBox)\r\n        array.unshift(bullVolDnBoxes, dnBox)\r\n        array.unshift(bullVolUpData, upV)\r\n        array.unshift(bullVolDnData, dnV)\r\n        bullCreate := true\r\n\r\nlastUpIdx = ta.valuewhen(close > open, bar_index, 0)\r\nlastUpHigh = ta.valuewhen(close > open, high, 0)\r\nlastUpLow = ta.valuewhen(close > open, low, 0)\r\nif bearish and not na(lastUpIdx) and not na(lastUpHigh) and not na(lastUpLow)\r\n    if not preventOverlap or f_can_create(lastUpHigh, lastUpLow)\r\n        int ago = bar_index - lastUpIdx\r\n        float upV = nz(upv[ago])\r\n        float dnV = math.abs(nz(downv[ago]))\r\n        float midYS = (lastUpHigh + lastUpLow) / 2.0\r\n\r\n        bx2 = box.new(\r\n             lastUpIdx, lastUpHigh, lastUpIdx + 1, lastUpLow,\r\n             border_color = color.new(chart.fg_color, 95),\r\n             bgcolor = color.new(chart.fg_color, 92),\r\n             text = \"‚ñ≤: \" + str.tostring(upV, format.volume) + \" | ‚ñº: \" + str.tostring(dnV, format.volume),\r\n             text_size = size.tiny, text_color = chart.fg_color,\r\n             text_halign = text.align_right, text_valign = text.align_bottom\r\n        )\r\n        array.unshift(bearBoxes, bx2)\r\n        array.unshift(bearStarts, lastUpIdx)\r\n\r\n        box upBox = box.new(lastUpIdx, lastUpHigh, lastUpIdx + 1, midYS, border_color = color.new(bullCol, 90), bgcolor = color.new(bullCol, 70))\r\n        box dnBox = box.new(lastUpIdx, midYS, lastUpIdx + 1, lastUpLow, border_color = color.new(bearCol, 90), bgcolor = color.new(bearCol, 70))\r\n        array.unshift(bearVolUpBoxes, upBox)\r\n        array.unshift(bearVolDnBoxes, dnBox)\r\n        array.unshift(bearVolUpData, upV)\r\n        array.unshift(bearVolDnData, dnV)\r\n        bearCreate := true\r\n\r\nif bullBoxes.size() > 0\r\n    for i = array.size(bullBoxes) - 1 to 0\r\n        if array.size(bullBoxes) <= i or array.size(bullStarts) <= i\r\n            continue\r\n        b = array.get(bullBoxes, i)\r\n        box.set_right(b, bar_index)\r\n\r\n        if array.size(bullVolUpBoxes) > i and array.size(bullVolDnBoxes) > i and array.size(bullVolUpData) > i and array.size(bullVolDnData) > i\r\n            int l = box.get_left(b)\r\n            float t = box.get_top(b)\r\n            float bt = box.get_bottom(b)\r\n            float midY = (t + bt) / 2.0\r\n            int midX = int(math.avg(l, bar_index))\r\n            float upV = array.get(bullVolUpData, i)\r\n            float dnV = math.max(array.get(bullVolDnData, i), 0.0000001)\r\n            float ratio = upV / dnV\r\n            box upBox = array.get(bullVolUpBoxes, i)\r\n            box dnBox = array.get(bullVolDnBoxes, i)\r\n            box.set_top(upBox, t), box.set_bottom(upBox, midY), box.set_left(upBox, l)\r\n            box.set_top(dnBox, midY), box.set_bottom(dnBox, bt), box.set_left(dnBox, l)\r\n            if ratio > 1\r\n                box.set_right(upBox, midX)\r\n                box.set_right(dnBox, int(l + (midX - l) / ratio))\r\n            else\r\n                box.set_right(upBox, int(l + (midX - l) * ratio))\r\n                box.set_right(dnBox, midX)\r\n        float topB = box.get_top(b)\r\n        float botB = box.get_bottom(b)\r\n        bool mitigatedB = close < botB and close[1] < botB\r\n        int startB = array.get(bullStarts, i)\r\n        bool expiredB = (bar_index - startB) >= maxAge\r\n        if mitigatedB or expiredB\r\n            array.remove(bullBoxes, i)\r\n            array.remove(bullStarts, i)\r\n            if array.size(bullVolUpBoxes) > i\r\n                array.remove(bullVolUpBoxes, i)\r\n            if array.size(bullVolDnBoxes) > i\r\n                array.remove(bullVolDnBoxes, i)\r\n            if array.size(bullVolUpData) > i\r\n                array.remove(bullVolUpData, i)\r\n            if array.size(bullVolDnData) > i\r\n                array.remove(bullVolDnData, i)\r\n\r\nif bearBoxes.size() > 0\r\n    for i = array.size(bearBoxes) - 1 to 0\r\n        if array.size(bearBoxes) <= i or array.size(bearStarts) <= i\r\n            continue\r\n        b = array.get(bearBoxes, i)\r\n        box.set_right(b, bar_index)\r\n\r\n        if array.size(bearVolUpBoxes) > i and array.size(bearVolDnBoxes) > i and array.size(bearVolUpData) > i and array.size(bearVolDnData) > i\r\n            int l = box.get_left(b)\r\n            float t = box.get_top(b)\r\n            float bt = box.get_bottom(b)\r\n            float midY = (t + bt) / 2.0\r\n            int midX = int(math.avg(l, bar_index))\r\n            float upV = array.get(bearVolUpData, i)\r\n            float dnV = math.max(array.get(bearVolDnData, i), 0.0000001)\r\n            float ratio = upV / dnV\r\n            box upBox = array.get(bearVolUpBoxes, i)\r\n            box dnBox = array.get(bearVolDnBoxes, i)\r\n            box.set_top(upBox, t), box.set_bottom(upBox, midY), box.set_left(upBox, l)\r\n            box.set_top(dnBox, midY), box.set_bottom(dnBox, bt), box.set_left(dnBox, l)\r\n            if ratio > 1\r\n                box.set_right(upBox, midX)\r\n                box.set_right(dnBox, int(l + (midX - l) / ratio))\r\n            else\r\n                box.set_right(upBox, int(l + (midX - l) * ratio))\r\n                box.set_right(dnBox, midX)\r\n        float topS = box.get_top(b)\r\n        float botS = box.get_bottom(b)\r\n        bool mitigatedS = close > topS and close[1] > topS\r\n        int startS = array.get(bearStarts, i)\r\n        bool expiredS = (bar_index - startS) >= maxAge\r\n        if mitigatedS or expiredS\r\n            array.remove(bearBoxes, i)\r\n            array.remove(bearStarts, i)\r\n            if array.size(bearVolUpBoxes) > i\r\n                array.remove(bearVolUpBoxes, i)\r\n            if array.size(bearVolDnBoxes) > i\r\n                array.remove(bearVolDnBoxes, i)\r\n            if array.size(bearVolUpData) > i\r\n                array.remove(bearVolUpData, i)\r\n            if array.size(bearVolDnData) > i\r\n                array.remove(bearVolDnData, i)\r\n\r\n// ============================================================================\r\n// FOOTPRINTS ON ZONE\r\n// ============================================================================\r\n[cL, oP, hI, lO, vO] = request.security_lower_tf(syminfo.tickerid, ltf, [close, open, high, low, volume])\r\n\r\nin_bull_zone = false\r\nin_bear_zone = false\r\n\r\nif bullBoxes.size() > 0\r\n    for i = 0 to array.size(bullBoxes) - 1\r\n        b_chk = array.get(bullBoxes, i)\r\n        if (high > box.get_bottom(b_chk) and low < box.get_top(b_chk))\r\n            in_bull_zone := true\r\n            break\r\n\r\nif bearBoxes.size() > 0\r\n    for i = 0 to array.size(bearBoxes) - 1\r\n        b_chk = array.get(bearBoxes, i)\r\n        if (high > box.get_bottom(b_chk) and low < box.get_top(b_chk))\r\n            in_bear_zone := true\r\n            break\r\n\r\nin_zone = in_bull_zone or in_bear_zone\r\nzone_side = in_bear_zone ? -1 : in_bull_zone ? 1 : 0\r\n\r\nbear_absorb = false\r\nbull_absorb = false\r\nbear_absorb_pct = float(na)\r\nbull_absorb_pct = float(na)\r\nbear_absorb_txt = \"\"\r\nbull_absorb_txt = \"\"\r\nbear_absorb_sig = false\r\nbull_absorb_sig = false\r\n\r\nif in_zone\r\n    float row_size = get_auto_tick_per_row()\r\n    float bodyTop = math.max(open, close)\r\n    float bodyBot = math.min(open, close)\r\n    bool hasUpperWick = high > bodyTop\r\n    bool hasLowerWick = low < bodyBot\r\n    float totalLotsBar = 0.0\r\n    float bearOppWickLots = 0.0\r\n    float bullOppWickLots = 0.0\r\n\r\n    profile p = profile.new(array.new<float>(), array.new<float>(), array.new<int>())\r\n    int steps = 0\r\n    while high > p.step_level(row_size, steps)\r\n        steps += 1\r\n\r\n    int lvlCount = array.size(p.levels)\r\n    int detailCount = array.size(cL)\r\n\r\n    if lvlCount > 1 and detailCount > 0\r\n        for id = 0 to detailCount - 1\r\n            float c_ltf = array.get(cL, id)\r\n            float o_ltf = array.get(oP, id)\r\n            float h_ltf = array.get(hI, id)\r\n            float l_ltf = array.get(lO, id)\r\n            float v_ltf = array.get(vO, id)\r\n            if not na(c_ltf)\r\n                for x = 0 to lvlCount - 1\r\n                    if x == 0\r\n                        if h_ltf > array.get(p.levels, x + 1)\r\n                            p.add_print(c_ltf, o_ltf, x, v_ltf)\r\n                    else if x == lvlCount - 1\r\n                        if l_ltf < array.get(p.levels, x - 1)\r\n                            p.add_print(c_ltf, o_ltf, x, v_ltf)\r\n                    else\r\n                        float hi = array.get(p.levels, x - 1)\r\n                        float lo = array.get(p.levels, x)\r\n                        if c_ltf < hi and c_ltf > lo\r\n                            p.add_print(c_ltf, o_ltf, x, v_ltf)\r\n\r\n    if lvlCount > 1\r\n        float minD = array.min(p.delta)\r\n        float maxD = array.max(p.delta)\r\n        int maxTpo = array.max(p.tpo)\r\n        for x = 0 to lvlCount - 1\r\n            float y = array.get(p.levels, x)\r\n            if y <= high\r\n                int tpo = array.get(p.tpo, x)\r\n                float d = array.get(p.delta, x)\r\n                color css = color.from_gradient(d, minD, maxD, bearCol, bullCol)\r\n\r\n                string tpoTxt = str.tostring(tpo)\r\n                string pad = str.length(tpoTxt) == 1 ? \"    \" : str.length(tpoTxt) == 2 ? \"     \" : \"      \"\r\n                y.stamp(chart.fg_color, tpoTxt + pad, size.small)\r\n\r\n                float r = maxTpo > 0 ? float(tpo) / float(maxTpo) : 0.0\r\n                if r > 0\r\n                    if r <= 0.2\r\n                        y.stamp(css, \"‚ñâ\", size.small)\r\n                    else if r <= 0.4\r\n                        y.stamp(css, \"‚ñâ\", size.small)\r\n                        y.stamp(css, \"¬†¬†¬†‚ñâ\", size.small)\r\n                    else if r <= 0.6\r\n                        y.stamp(css, \"‚ñâ\", size.small)\r\n                        y.stamp(css, \"¬†¬†¬†‚ñâ\", size.small)\r\n                        y.stamp(css, \"¬†¬†¬†¬†¬†¬†‚ñâ\", size.small)\r\n                    else if r <= 0.8\r\n                        y.stamp(css, \"‚ñâ\", size.small)\r\n                        y.stamp(css, \"¬†¬†¬†‚ñâ\", size.small)\r\n                        y.stamp(css, \"¬†¬†¬†¬†¬†¬†‚ñâ\", size.small)\r\n                        y.stamp(css, \"¬†¬†¬†¬†¬†¬†¬†¬†¬†‚ñâ\", size.small)\r\n                    else\r\n                        y.stamp(css, \"‚ñâ\", size.small)\r\n                        y.stamp(css, \"¬†¬†¬†‚ñâ\", size.small)\r\n                        y.stamp(css, \"¬†¬†¬†¬†¬†¬†‚ñâ\", size.small)\r\n                        y.stamp(css, \"¬†¬†¬†¬†¬†¬†¬†¬†¬†‚ñâ\", size.small)\r\n                        y.stamp(css, \"¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†¬†‚ñâ\", size.small)\r\n\r\n                if tpo > 0\r\n                    totalLotsBar += tpo\r\n                    float binHigh = x == 0 ? high : array.get(p.levels, x - 1)\r\n                    float binLow  = y\r\n                    bool inUpperWick = hasUpperWick and (binHigh > bodyTop)\r\n                    bool inLowerWick = hasLowerWick and (binLow < bodyBot)\r\n                    if zone_side == -1 and inUpperWick and d > 0\r\n                        bear_absorb := true\r\n                        bearOppWickLots += tpo\r\n                    if zone_side == 1 and inLowerWick and d < 0\r\n                        bull_absorb := true \r\n                        bullOppWickLots += tpo\r\n\r\n    if totalLotsBar > 0 \r\n        if bear_absorb and bearOppWickLots > 0\r\n            bear_absorb_pct := (bearOppWickLots / totalLotsBar) * 100.0\r\n            bear_absorb_txt := \"‚ñº \" + str.tostring(bear_absorb_pct, \"#.0\") + \"%\"\r\n        if bull_absorb and bullOppWickLots > 0\r\n            bull_absorb_pct := (bullOppWickLots / totalLotsBar) * 100.0\r\n            bull_absorb_txt := \"‚ñ≤ \" + str.tostring(bull_absorb_pct, \"#.0\") + \"%\"\r\n\r\n    bear_absorb_sig := barstate.isconfirmed and bear_absorb_txt != \"\"\r\n    bull_absorb_sig := barstate.isconfirmed and bull_absorb_txt != \"\"\r\n\r\nif bear_absorb_sig\r\n    label.new(x = bar_index, y = high, text = bear_absorb_txt, xloc = xloc.bar_index, style = label.style_label_down, color = bearCol, textcolor = chart.bg_color, size = size.small)\r\nif bull_absorb_sig\r\n    label.new(x = bar_index, y = low, text = bull_absorb_txt, xloc = xloc.bar_index, style = label.style_label_up, color = bullCol, textcolor = chart.bg_color, size = size.small)\r\n\r\n// ============================================================================\r\n// ALERTS\r\n// ============================================================================\r\nalertcondition(bullCreate, \"Bullish Zone Created\", \"Bullish OrderBlock Created\")\r\nalertcondition(bearCreate, \"Bearish Zone Created\", \"Bearish OrderBlock Created\")\r\nalertcondition(bear_absorb_sig, \"Bear OB Absorption\", \"Bearish orderblock absorption detected (positive delta prints in upper wick).\")\r\nalertcondition(bull_absorb_sig, \"Bull OB Absorption\", \"Bullish orderblock absorption detected (negative delta prints in lower wick).\")\r\n"
  },
  "https://www.tradingview.com/script/582Z0Qbz-Smart-Money-Alpha-Signals-Performance-Dashboard/": {
    "id": 20088253,
    "url": "https://www.tradingview.com/script/582Z0Qbz-Smart-Money-Alpha-Signals-Performance-Dashboard/",
    "name": "Smart Money Alpha Signals (Performance Dashboard)",
    "description": " Smart Money Alpha Signals: Identifying Market Leaders & Generating Alpha\n\nGMP Alpha Signals (Global Market Performance Alpha) is a specialized analysis tool designed not merely to find stocks that are rising, but to identify \"Alpha\" assets‚ÄîMarket Leaders that defend their price or rise even under adverse conditions where the market index falls or consolidates.\nThis indicator visualizes the concept of Comparative Relative Strength (RS) and Smart Money accumulation patterns, helping traders capture profit opportunities even during bearish market phases.\n\n\nKey Objectives (Purpose)\n \n Alpha Capture: Identifying assets generating 'excess returns' that outperform the market Beta.\n Smart Money Tracking: Detecting traces of 'institutional buying' and 'accumulation' that defend prices during index plunges.\n Decoupling Identification: Spotting assets moving on independent catalysts or momentum, regardless of the broader market direction.\n Stop Hunt Filtering: Distinguishing 'fake drops' where price dips temporarily, but Relative Strength remains intact.\n \n\nDashboard Guide\nInterpretation of the information panel (Table) displayed on the chart.\n \n Rel. Performance: Shows the excess return compared to the index over the set period. (Positive/Green = Stronger than the market).\n Decoupling Strength: The correlation coefficient with the index. Lower values (0 or negative) indicate movement independent of market risk.\n Bullish: The count/rate of rising or limiting losses when the index drops sharply (e.g., < -0.5%). (Gold = Market Crash Leader).\n Defended: The count/rate of holding support levels when the index shows mild weakness (e.g., < -0.05%). (Gold = Strong Accumulation).\n Bench. Defense: The defense rate of the comparison benchmark (e.g., TSLA, ETH). Your target asset must be higher to be considered the sector leader.\n \n\nInput Options & Settings Guide\nYou can optimize settings according to your trading style and asset class (Stocks/Crypto).\n\n(1) Main Settings\n \n Major Index: The baseline market index for comparison.\n(US Stocks: NASDAQ:NDX or TVC:SPX / Crypto: BINANCE:BTCUSDT)\n Benchmark Symbol: A competitor within the sector.\n(e.g., Set NVDA when analyzing Semiconductor stocks).\n Correlation Lookback: The lookback period for judging decoupling. (Default: 30)\n Performance Lookback: The number of bars to calculate cumulative returns and defense rates. (Default: 60)\n \n\n(2) Dashboard Thresholds\nThese settings define the criteria for what qualifies as \"Defended\" or \"Bullish\".\n \n Performance (Max %): Used to find assets that haven't pumped yet. Signals trigger only when Alpha is below this value.\n Defended Logic:\nIndex Drop Condition: The index must drop by at least this amount to start checking. (e.g., -0.05%)\n Asset Buffer: How much the asset must outperform the index drop.\n(Example: If Index drops -1.0% and Buffer is 0.2%, the asset must be at least -0.8% to count as 'Defended').\n Bullish Logic: Measures resilience during steeper market dumps (e.g., -0.5% drop) compared to the Defended Logic.\n Volume Settings: Decides whether to count Defended/Bullish instances only when accompanied by volume above the SMA.\n \n\n(3) Signal Logic Settings (Crucial)\nCustomize conditions to trigger alerts. The choice between AND / OR is crucial.\n \n AND: Condition must be met SIMULTANEOUSLY with other active conditions (Conservative/High Certainty).\n OR: Condition triggers the signal INDEPENDENTLY (Aggressive/Opportunity Capture).\n \n\n \n \n Performance: Is the relative performance within the threshold? (Basic Filter).\n Decoupling: Has the correlation dropped? (Start of independent move).\n Bullish Rate: Is the Bullish rate high during market dumps?\n Defended Rate (High): (Recommended) Is there continuous price defense occurring? (Accumulation detection).\n Defended Rate (Low): (Warning) Has the defense rate broken down? (For Stop Loss).\n Defended > Benchmark: Is it stronger than the Benchmark (2nd tier)?\n Volume Spike: Has volume surged compared to the average? (Institutional involvement).\n RSI Oversold: Is it in oversold territory? (Counter-trend trading).\n Decoupling Move: Does the current bar show the \"Index Down / Asset Up\" pattern?\n Min USD Volume: Transaction value filter (To exclude low liquidity assets).\n",
    "author_name": "BIGTAKER",
    "likes_count": 109,
    "comments_count": 9,
    "views_count": 0,
    "created_at": "2025-12-12T03:27:48+00:00",
    "updated_at": "2025-12-12T03:44:53+00:00",
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "NASDAQ:AAPL",
      "full_name": "NASDAQ:AAPL",
      "short_name": "AAPL",
      "exchange": "NASDAQ",
      "type": "stock",
      "logo_id": "apple",
      "currency_logo_id": "country/US",
      "base_currency_logo_id": null,
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/apple.svg"
      ],
      "interval": "15",
      "direction": 0,
      "badge": {
        "label": "NASDAQ:AAPL",
        "url": "/symbols/NASDAQ-AAPL/"
      }
    },
    "created": "2025-12-12",
    "updated": "2025-12-12",
    "source": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// ¬© Bigtaker\r\n\r\n//@version=5\r\nindicator(\"Smart Money Alpha Signals (Performance Dashboard)\", shorttitle=\"Smart Money Alpha Signals\", overlay=true, max_labels_count=500)\r\n\r\n// =============================================================================\r\n// 1. Settings (Inputs) \r\n// =============================================================================\r\n\r\n// [Main Settings] Symbol and Period\r\ngrp_main = \"1. Main Settings\"\r\nsym_index = input.symbol(\"NASDAQ:NDX\", \"Major Index (Baseline)\", group=grp_main, tooltip=\"Set the major market index as the baseline (e.g., SPX or NDX for Stocks, BTC for Crypto). All Alpha (excess return) calculations are relative to this symbol.\")\r\nsym_bench = input.symbol(\"NASDAQ:TSLA\", \"Benchmark Symbol (Comparison)\", group=grp_main, tooltip=\"A secondary benchmark to compare performance against a specific sector leader (e.g., TSLA for Tech, ETH for Alts).\")\r\ncorr_len  = input.int(30, \"Correlation Lookback\", minval=10, group=grp_main, tooltip=\"The lookback period for calculating correlation. Shorter lengths react faster to decoupling events.\")\r\nperf_len  = input.int(60, \"Performance Lookback\", minval=10, group=grp_main, tooltip=\"The number of bars used to calculate cumulative returns and dashboard statistics.\\nPositive values indicate the asset is outperforming the Major Index.\")\r\n\r\n// [Filters] Dashboard Thresholds & Logic\r\ngrp_filt = \"2. Dashboard Thresholds & Logic\"\r\n\r\n// 1. Performance Threshold\r\nval_sig_perf = input.float(0.0, \"Performance (Max %)\", step=1, group=grp_filt, tooltip=\"Signals trigger only when Excess Return (Alpha) is BELOW this value (Default: 0.0). Useful for identifying assets that haven't pumped yet.\")\r\n\r\n// 2. Decoupling Threshold\r\nthres_corr   = input.float(0, \"Decoupling Threshold\", step=0.1, minval=-1.0, maxval=1.0, group=grp_filt, tooltip=\"Highlights on the dashboard and triggers a signal if Correlation falls below this value (Default: 0).\")\r\n\r\n// 3. Defended Logic Inputs\r\n// Index Criteria: +0.1% ~ -0.05%\r\nval_def_idx_th = input.float(-0.05, \"Defended: Index Drop Condition (%)\", minval=-0.05, maxval=0.1, step=0.01, group=grp_filt, tooltip=\"To check for 'Defended' status, the Index return must be below this threshold (Default: -0.05%).\")\r\n// Asset Buffer: 0.01% ~ 0.2%\r\nval_def_buf    = input.float(0.05, \"Defended: Asset Buffer (%)\", minval=0.01, maxval=0.2, step=0.01, group=grp_filt, tooltip=\"To qualify as 'Defended', the Asset return must be >= (Index Return + Buffer).\\nExample: If Index is -0.1% and Buffer is 0.05%, Asset must be >= -0.05%.\")\r\nthres_def      = input.float(20.0, \"Defended: High Success Rate (%)\", step=5, group=grp_filt, tooltip=\"Highlights in Gold on the dashboard if the 'Defended' occurrence rate exceeds this value (Default: 25%).\")\r\n// Low Alert Threshold\r\nthres_def_low  = input.float(4.0,  \"Defended: Low Success Rate (%)\", step=1, group=grp_filt, tooltip=\"Highlights in Red if the 'Defended' occurrence rate is below this value (Default: 4%).\")\r\n\r\n// 4. Bullish Logic Inputs\r\n// Index Criteria: -0.05% ~ -0.5%\r\nval_bull_idx_th = input.float(-0.05, \"Bullish: Index Drop Condition (%)\", minval=-0.5, maxval=-0.05, step=0.01, group=grp_filt, tooltip=\"To check for 'Bullish' status, the Index must drop at least this amount.\")\r\n// Asset Buffer: 0.05% ~ 2%\r\nval_bull_buf    = input.float(0.1,   \"Bullish: Asset Buffer (%)\", minval=0.05, maxval=2.0, step=0.05, group=grp_filt, tooltip=\"To qualify as 'Bullish', the Asset return must be >= (Index Return + Buffer). Represents relative strength during dumps.\")\r\nthres_rise      = input.float(6.0, \"Bullish: Success Rate (%)\", step=5, group=grp_filt, tooltip=\"Highlights if the 'Bullish' occurrence rate exceeds this value (Default: 6%).\")\r\n\r\n// 5. Volume Settings\r\nvol_len      = input.int(60, \"Volume MA Length\", minval=1, group=grp_filt, tooltip=\"Length of the Volume SMA used to detect volume spikes.\")\r\nuse_vol_rise = input.bool(true, \"Apply Vol Filter to 'Bullish'\", group=grp_filt, tooltip=\"If enabled, 'Bullish' counts only when Volume is higher than the Volume MA.\")\r\nuse_vol_def  = input.bool(false, \"Apply Vol Filter to 'Defended'\", group=grp_filt, tooltip=\"If enabled, 'Defended' counts only when Volume is higher than the Volume MA.\")\r\n\r\n\r\n// [Visuals] Table Position and Style\r\ngrp_vis = \"3. Dashboard Visuals\"\r\ntable_pos   = input.string(\"Bottom Right\", \"Position\", options=[\"Top Right\", \"Bottom Right\", \"Top Left\", \"Bottom Left\"], group=grp_vis)\r\ntext_size   = input.string(\"Small\", \"Text Size\", options=[\"Tiny\", \"Small\", \"Normal\", \"Large\"], group=grp_vis)\r\nshow_table  = input.bool(true, \"Show Dashboard\", group=grp_vis)\r\nc_lbl_bg    = input.color(color.new(#272727, 50), \"Label Background\", group=grp_vis)\r\nc_lbl_txt   = input.color(color.rgb(197, 197, 197), \"Label Text Color\", group=grp_vis)\r\n\r\n\r\n// =============================================================================\r\n// [Signal Customization] - Logic with AND/OR Selection\r\n// =============================================================================\r\ngrp_sig = \"4. Signal Logic Settings\"\r\ntip_logic = \"AND: This condition must be met ALONG WITH other active 'AND' conditions.\\nOR: This condition triggers a signal INDEPENDENTLY (Standalone).\"\r\n\r\n// 1. Performance Logic\r\nuse_sig_perf = input.bool(true, \"Performance\", group=grp_sig, inline=\"perf\")\r\nlog_sig_perf = input.string(\"AND\", \"\", options=[\"AND\", \"OR\"], group=grp_sig, inline=\"perf\", tooltip=tip_logic)\r\n\r\n// 2. Correlation Logic\r\nuse_sig_corr = input.bool(false, \"Decoupling (Correlation)\", group=grp_sig, inline=\"corr\")\r\nlog_sig_corr = input.string(\"AND\", \"\", options=[\"AND\", \"OR\"], group=grp_sig, inline=\"corr\", tooltip=tip_logic)\r\n\r\n// 3. Bullish Logic\r\nuse_sig_bull = input.bool(false, \"Bullish Rate\", group=grp_sig, inline=\"bull\")\r\nlog_sig_bull = input.string(\"AND\", \"\", options=[\"AND\", \"OR\"], group=grp_sig, inline=\"bull\", tooltip=tip_logic)\r\n\r\n// 4. Defended Logic (High)\r\nuse_sig_def  = input.bool(true, \"Defended Rate (High)\", group=grp_sig, inline=\"def\")\r\nlog_sig_def  = input.string(\"AND\", \"\", options=[\"AND\", \"OR\"], group=grp_sig, inline=\"def\", tooltip=tip_logic)\r\n\r\n// 4.1 Defended Logic (Low)\r\nuse_sig_def_low = input.bool(false, \"Defended Rate (Low)\", group=grp_sig, inline=\"def_low\")\r\nlog_sig_def_low = input.string(\"AND\", \"\", options=[\"AND\", \"OR\"], group=grp_sig, inline=\"def_low\", tooltip=\"Triggers a signal when Defended Rate drops BELOW the 'Low Success Rate' threshold.\")\r\n\r\n// 5. Benchmark Logic\r\nuse_sig_bnc  = input.bool(false, \"Defended > Benchmark\", group=grp_sig, inline=\"bnc\")\r\nlog_sig_bnc  = input.string(\"AND\", \"\", options=[\"AND\", \"OR\"], group=grp_sig, inline=\"bnc\", tooltip=tip_logic)\r\n\r\n// 6. Volume Spike Logic (SMA)\r\nuse_sig_vol  = input.bool(true, \"Volume Spike\", group=grp_sig, inline=\"vol\")\r\nval_sig_v_mul= input.float(2.0, \"Multiplier (X)\", step=1, group=grp_sig, inline=\"vol\", tooltip=\"Current volume must be this many times larger than the average volume.\")\r\nlog_sig_vol  = input.string(\"AND\", \"\", options=[\"AND\", \"OR\"], group=grp_sig, inline=\"vol\", tooltip=tip_logic)\r\n\r\n// 7. RSI Logic\r\nuse_sig_rsi     = input.bool(true, \"RSI Oversold\", group=grp_sig, inline=\"rsi\")\r\nval_sig_rsi_lvl = input.float(30.0, \"Below Level\", step=1.0, group=grp_sig, inline=\"rsi\", tooltip=\"Trigger when RSI(14) is below this value.\")\r\nlog_sig_rsi     = input.string(\"AND\", \"\", options=[\"AND\", \"OR\"], group=grp_sig, inline=\"rsi\", tooltip=tip_logic)\r\n\r\n// 8. Decoupling Move Logic\r\nuse_sig_dcp_mv   = input.bool(true, \"Decoupling Move\", group=grp_sig, inline=\"dcp_mv\")\r\nlog_sig_dcp_mv   = input.string(\"AND\", \"\", options=[\"AND\", \"OR\"], group=grp_sig, inline=\"dcp_mv\", tooltip=tip_logic)\r\nval_sig_idx_drop = input.float(-0.2, \"Index Drop <=\", minval=-1.0, maxval=-0.05, step=0.05, group=grp_sig, tooltip=\"Signal triggers only when Index return is below this threshold (Default: -0.2%).\")\r\nval_sig_diff     = input.float(0.05, \"Asset > Index +\", minval=0.0, maxval=5.0, step=0.05, group=grp_sig, tooltip=\"Asset return must exceed Index return by at least this amount (Default: 0.05%).\")\r\n\r\n// 9. USD Volume Logic (NEW)\r\nuse_sig_vol_usd = input.bool(true, \"Min USD Volume\", group=grp_sig, inline=\"vol_usd\")\r\nval_sig_vol_usd = input.float(500000.0, \"($)\", step=100000, group=grp_sig, inline=\"vol_usd\", tooltip=\"Trigger only if calculated USD Volume > this value.\\nFormula: hlc3 * volume\")\r\nlog_sig_vol_usd = input.string(\"AND\", \"\", options=[\"AND\", \"OR\"], group=grp_sig, inline=\"vol_usd\", tooltip=tip_logic)\r\n\r\n\r\n// [Signal Label Visuals]\r\ngrp_lbl = \"5. Signal Label Visuals\"\r\nshow_signal  = input.bool(true, \"Show Label on Chart\", group=grp_lbl)\r\nsig_text     = input.string(\"ALPHA\", \"Label Text\", group=grp_lbl)\r\nsig_style_st = input.string(\"Label Up\", \"Label Style\", options=[\"Label Down\", \"Label Up\", \"Triangle Down\", \"Triangle Up\", \"Circle\", \"Diamond\"], group=grp_lbl)\r\nsig_loc_st   = input.string(\"Below Bar\", \"Location\", options=[\"Above Bar\", \"Below Bar\"], group=grp_lbl)\r\nsig_size_st  = input.string(\"Small\", \"Size\", options=[\"Tiny\", \"Small\", \"Normal\", \"Large\", \"Huge\"], group=grp_lbl)\r\nsig_col_bg   = input.color(color.new(#ffee00, 0), \"Label Color\", group=grp_lbl)\r\nsig_col_txt  = input.color(color.black, \"Text Color\", group=grp_lbl)\r\n\r\n\r\n// [Colors]\r\ngrp_c1 = \"Color: Row 1 (Performance)\"\r\nc_perf_up_bg = input.color(color.new(#23a081, 20), \"Positive Bg\", group=grp_c1, tooltip=\"Background color when Performance is positive.\")\r\nc_perf_up_tx = input.color(color.white, \"Positive Text\", group=grp_c1)\r\nc_perf_dn_bg = input.color(color.new(#ff5252, 20), \"Negative Bg\", group=grp_c1, tooltip=\"Background color when Performance is negative.\")\r\nc_perf_dn_tx = input.color(color.white, \"Negative Text\", group=grp_c1)\r\n\r\ngrp_c2 = \"Color: Row 2 (Decoupling)\"\r\nc_corr_hi_bg = input.color(color.new(#307dbd, 20), \"Decoupling Bg\", group=grp_c2, tooltip=\"Background color when Decoupling occurs.\")\r\nc_corr_hi_tx = input.color(color.white, \"Decoupling Text\", group=grp_c2)\r\n\r\ngrp_c3 = \"Color: Row 3 (Bullish)\"\r\nc_rise_hi_bg = input.color(color.new(#ffd000, 20), \"Highlight Bg\", group=grp_c3, tooltip=\"Background color when Bullish Rate is high.\")\r\nc_rise_hi_tx = input.color(color.rgb(255, 255, 255), \"Highlight Text\", group=grp_c3)\r\n\r\ngrp_c4 = \"Color: Row 4 (Defended)\"\r\nc_def_hi_bg  = input.color(color.new(#c5b520, 20), \"Success High Bg\", group=grp_c4, tooltip=\"Background color when Defended Rate is high.\")\r\nc_def_hi_tx  = input.color(color.white, \"Success High Text\", group=grp_c4)\r\n// [NEW] Low Alert Colors\r\nc_def_low_bg = input.color(color.new(#ff5252, 20), \"Success Low Bg\", group=grp_c4, tooltip=\"Background color when Defended Rate is critically low.\")\r\nc_def_low_tx = input.color(color.white, \"Success Low Text\", group=grp_c4)\r\n\r\ngrp_c5 = \"Color: Row 5 (Benchmark)\"\r\nc_bench_hi_bg = input.color(color.new(#505050, 60), \"Highlight Bg\", group=grp_c5, tooltip=\"Background color when outperforming Benchmark.\")\r\nc_bench_hi_tx = input.color(color.white, \"Highlight Text\", group=grp_c5)\r\n\r\n// Note: c_def_bg means \"Default Background\".\r\nc_def_bg = input.color(color.new(#505050, 60), \"Default Background\", group=\"Common Colors\", tooltip=\"Standard background color for inactive cells.\")\r\nc_def_tx = input.color(color.white, \"Default Text\", group=\"Common Colors\")\r\n\r\n\r\n// =============================================================================\r\n// 2. Data Calculation\r\n// =============================================================================\r\n\r\n[idx_p, idx_p1, idx_ago] = request.security(sym_index, timeframe.period, [close, close[1], close[perf_len]])\r\n[bnc_p, bnc_p1, bnc_v, bnc_v_sma] = request.security(sym_bench, timeframe.period, [close, close[1], volume, ta.sma(volume, vol_len)])\r\n\r\n// 1) Correlation\r\nfloat correl = nz(ta.correlation(close, idx_p, corr_len), 0.0)\r\nfloat clean_corr = nz(correl, 0.0)\r\n\r\n// 2) Cumulative Performance (Relative Performance)\r\nfloat p_ago = nz(close[perf_len])\r\nfloat ret_asset = (p_ago != 0) ? ((close - p_ago) / p_ago * 100) : 0.0\r\nfloat ret_index = (nz(idx_ago) != 0) ? ((idx_p - idx_ago) / idx_ago * 100) : 0.0\r\nfloat perf_diff = ret_asset - ret_index\r\n\r\n// 3) Daily Percent Change\r\nfloat pct_idx = (nz(idx_p1) != 0) ? ((idx_p - idx_p1) / idx_p1 * 100) : 0.0\r\nfloat pct_ast = (nz(close[1]) != 0) ? ((close - close[1]) / close[1] * 100) : 0.0\r\nfloat pct_bnc = (nz(bnc_p1) != 0) ? ((bnc_p - bnc_p1) / bnc_p1 * 100) : 0.0\r\n\r\n// Volume Conditions\r\nbool vol_cond_ast = volume >= ta.sma(volume, vol_len)\r\nbool vol_cond_bnc = nz(bnc_v) >= nz(bnc_v_sma) \r\n\r\n// -----------------------------------------------------------------------------\r\n// [Logic] Defended & Bullish Conditions\r\n// -----------------------------------------------------------------------------\r\n\r\n// Defended Condition:\r\n// Index <= Threshold (e.g. 0.05%) AND Asset >= Index + Buffer (e.g. 0.05%)\r\nbool cond_def_ast = (pct_idx <= val_def_idx_th) and (pct_ast >= (pct_idx + val_def_buf))\r\n\r\n// Bullish Condition:\r\n// Index <= Threshold (e.g. -0.05%) AND Asset >= Index + Buffer (e.g. 0.1%)\r\nbool cond_rise_ast = (pct_idx <= val_bull_idx_th) and (pct_ast >= (pct_idx + val_bull_buf))\r\n\r\n// Benchmark Defended\r\nbool cond_def_bnc = (pct_idx <= val_def_idx_th) and (pct_bnc >= (pct_idx + val_def_buf))\r\n\r\n\r\n// Apply Filters\r\nbool is_def_ast  = use_vol_def  ? (cond_def_ast and vol_cond_ast)  : cond_def_ast\r\nbool is_def_bnc  = use_vol_def  ? (cond_def_bnc and vol_cond_bnc)  : cond_def_bnc\r\nbool is_rise_ast = use_vol_rise ? (cond_rise_ast and vol_cond_ast) : cond_rise_ast\r\n\r\n// Rate Calculation\r\nfloat rate_def   = math.sum(is_def_ast ? 1 : 0, perf_len)  / perf_len * 100\r\nfloat rate_rise  = math.sum(is_rise_ast ? 1 : 0, perf_len) / perf_len * 100\r\nfloat rate_bench = math.sum(is_def_bnc ? 1 : 0, perf_len)  / perf_len * 100\r\n\r\n// =============================================================================\r\n// 3. Signal Logic\r\n// =============================================================================\r\n\r\nbool cond_and_chain = true\r\nbool cond_or_chain  = false\r\nbool has_active_and = false\r\n\r\n// 1. Performance\r\nif use_sig_perf\r\n    bool c = perf_diff <= val_sig_perf\r\n    if log_sig_perf == \"AND\"\r\n        cond_and_chain := cond_and_chain and c\r\n        has_active_and := true\r\n    else\r\n        cond_or_chain := cond_or_chain or c\r\n\r\n// 2. Correlation\r\nif use_sig_corr\r\n    bool c = clean_corr < thres_corr\r\n    if log_sig_corr == \"AND\"\r\n        cond_and_chain := cond_and_chain and c\r\n        has_active_and := true\r\n    else\r\n        cond_or_chain := cond_or_chain or c\r\n\r\n// 3. Bullish Rate\r\nif use_sig_bull\r\n    bool c = rate_rise >= thres_rise\r\n    if log_sig_bull == \"AND\"\r\n        cond_and_chain := cond_and_chain and c\r\n        has_active_and := true\r\n    else\r\n        cond_or_chain := cond_or_chain or c\r\n\r\n// 4. Defended Rate (High)\r\nif use_sig_def\r\n    bool c = rate_def >= thres_def\r\n    if log_sig_def == \"AND\"\r\n        cond_and_chain := cond_and_chain and c\r\n        has_active_and := true\r\n    else\r\n        cond_or_chain := cond_or_chain or c\r\n\r\n// 4.1 Defended Rate (Low)\r\nif use_sig_def_low\r\n    bool c = rate_def <= thres_def_low // Trigger if rate is BELOW the threshold\r\n    if log_sig_def_low == \"AND\"\r\n        cond_and_chain := cond_and_chain and c\r\n        has_active_and := true\r\n    else\r\n        cond_or_chain := cond_or_chain or c\r\n\r\n// 5. Benchmark Comparison (Defended > Benchmark)\r\nif use_sig_bnc\r\n    bool c = rate_def > rate_bench\r\n    if log_sig_bnc == \"AND\"\r\n        cond_and_chain := cond_and_chain and c\r\n        has_active_and := true\r\n    else\r\n        cond_or_chain := cond_or_chain or c\r\n\r\n// 6. Volume Spike (SMA)\r\nif use_sig_vol\r\n    float v_sma_check = ta.sma(volume, vol_len)\r\n    bool c = nz(volume) >= (nz(v_sma_check) * val_sig_v_mul)\r\n    if log_sig_vol == \"AND\"\r\n        cond_and_chain := cond_and_chain and c\r\n        has_active_and := true\r\n    else\r\n        cond_or_chain := cond_or_chain or c\r\n\r\n// 7. RSI\r\nif use_sig_rsi\r\n    float rsi_val = ta.rsi(close, 14)\r\n    bool c = nz(rsi_val, 50) <= val_sig_rsi_lvl\r\n    if log_sig_rsi == \"AND\"\r\n        cond_and_chain := cond_and_chain and c\r\n        has_active_and := true\r\n    else\r\n        cond_or_chain := cond_or_chain or c\r\n\r\n// 8. Decoupling Move\r\nif use_sig_dcp_mv\r\n    bool c = (nz(pct_idx) <= val_sig_idx_drop) and (nz(pct_ast) >= (nz(pct_idx) + val_sig_diff))\r\n    if log_sig_dcp_mv == \"AND\"\r\n        cond_and_chain := cond_and_chain and c\r\n        has_active_and := true\r\n    else\r\n        cond_or_chain := cond_or_chain or c\r\n\r\n// 9. USD Volume Logic (NEW)\r\nif use_sig_vol_usd\r\n    // Calc: Average Price * Volume = Approx USD Volume\r\n    float current_vol_usd = hlc3 * volume\r\n    bool c = current_vol_usd >= val_sig_vol_usd\r\n    if log_sig_vol_usd == \"AND\"\r\n        cond_and_chain := cond_and_chain and c\r\n        has_active_and := true\r\n    else\r\n        cond_or_chain := cond_or_chain or c\r\n\r\n\r\nbool trigger_alpha = false\r\nif has_active_and\r\n    trigger_alpha := cond_and_chain or cond_or_chain\r\nelse\r\n    trigger_alpha := cond_or_chain\r\n\r\nalertcondition(trigger_alpha, title=\"GMP Alpha Signal\", message=\"GMP Alpha: Custom Signal Conditions Met!\")\r\n\r\n// Signal Visualization\r\nvar style_choice = sig_style_st == \"Label Up\" ? label.style_label_up : sig_style_st == \"Triangle Down\" ? label.style_triangledown : sig_style_st == \"Triangle Up\" ? label.style_triangleup : sig_style_st == \"Circle\" ? label.style_circle : sig_style_st == \"Diamond\" ? label.style_diamond : label.style_label_down \r\nvar yloc_choice = sig_loc_st == \"Below Bar\" ? yloc.belowbar : yloc.abovebar\r\nvar size_choice  = sig_size_st == \"Tiny\" ? size.tiny : sig_size_st == \"Normal\" ? size.normal : sig_size_st == \"Large\" ? size.large : sig_size_st == \"Huge\" ? size.huge : size.small\r\n\r\nif show_signal and trigger_alpha\r\n    label.new(bar_index, high, text=sig_text, color=sig_col_bg, textcolor=sig_col_txt, style=style_choice, yloc=yloc_choice, size=size_choice)\r\n\r\n// =============================================================================\r\n// 4. Dashboard Output\r\n// =============================================================================\r\n\r\nif show_table\r\n    var pos = table_pos == \"Top Left\" ? position.top_left : table_pos == \"Top Right\" ? position.top_right : table_pos == \"Bottom Left\" ? position.bottom_left : position.bottom_right\r\n    var txt_sz = text_size == \"Tiny\" ? size.tiny : text_size == \"Normal\" ? size.normal : text_size == \"Large\" ? size.large : size.small\r\n    var tbl = table.new(pos, 2, 5, border_width=1)\r\n\r\n    // Row 1: Performance\r\n    table.cell(tbl, 0, 0, \"Rel. Performance\\n(\" + str.tostring(perf_len) + \" bars)\", bgcolor=c_lbl_bg, text_color=c_lbl_txt, text_size=txt_sz)\r\n    color bg_r1 = perf_diff > 0 ? c_perf_up_bg : (perf_diff < 0 ? c_perf_dn_bg : c_def_bg)\r\n    color tx_r1 = perf_diff > 0 ? c_perf_up_tx : (perf_diff < 0 ? c_perf_dn_tx : c_def_tx)\r\n    string txt_r1 = (perf_diff > 0 ? \"+\" : \"\") + str.tostring(perf_diff, \"#.#\") + \"%\"\r\n    table.cell(tbl, 1, 0, txt_r1, bgcolor=bg_r1, text_color=tx_r1, text_size=txt_sz)\r\n\r\n    // Row 2: Decoupling\r\n    table.cell(tbl, 0, 1, \"Decoupling\", bgcolor=c_lbl_bg, text_color=c_lbl_txt, text_size=txt_sz)\r\n    table.cell(tbl, 1, 1, str.tostring(clean_corr, \"#.##\"), bgcolor=clean_corr < thres_corr ? c_corr_hi_bg : c_def_bg, text_color=clean_corr < thres_corr ? c_corr_hi_tx : c_def_tx, text_size=txt_sz)\r\n\r\n    // Row 3: Bullish\r\n    table.cell(tbl, 0, 2, \"Bullish\" + (use_vol_rise ? \" (Vol)\" : \"\"), bgcolor=c_lbl_bg, text_color=c_lbl_txt, text_size=txt_sz)\r\n    bool is_super_rise = rate_rise >= thres_rise\r\n    string txt_r3 = str.tostring(math.round(rate_rise * perf_len / 100)) + \"(\" + str.tostring(rate_rise, \"#.1\") + \"%)\"\r\n    table.cell(tbl, 1, 2, txt_r3, bgcolor=is_super_rise ? c_rise_hi_bg : c_def_bg, text_color=is_super_rise ? c_rise_hi_tx : c_def_tx, text_size=txt_sz)\r\n\r\n    // Row 4: Defended\r\n    table.cell(tbl, 0, 3, \"Defended\" + (use_vol_def ? \" (Vol)\" : \"\"), bgcolor=c_lbl_bg, text_color=c_lbl_txt, text_size=txt_sz)\r\n    \r\n    bool is_well_defended = rate_def >= thres_def\r\n    bool is_poor_defended = rate_def <= thres_def_low // Low threshold check\r\n\r\n    // Color Logic: High(Gold) > Low(Red) > Default(Gray)\r\n    color bg_r4 = is_well_defended ? c_def_hi_bg : (is_poor_defended ? c_def_low_bg : c_def_bg)\r\n    color tx_r4 = is_well_defended ? c_def_hi_tx : (is_poor_defended ? c_def_low_tx : c_def_tx)\r\n\r\n    string txt_r4 = str.tostring(math.round(rate_def * perf_len / 100)) + \"(\" + str.tostring(rate_def, \"#.1\") + \"%)\"\r\n    table.cell(tbl, 1, 3, txt_r4, bgcolor=bg_r4, text_color=tx_r4, text_size=txt_sz)\r\n\r\n    // Row 5: Benchmark\r\n    table.cell(tbl, 0, 4, \"Bench. Defense\", bgcolor=c_lbl_bg, text_color=c_lbl_txt, text_size=txt_sz)\r\n    bool is_bench_good = rate_bench > 20\r\n    string txt_r5 = str.tostring(math.round(rate_bench * perf_len / 100)) + \"(\" + str.tostring(rate_bench, \"#.1\") + \"%)\"\r\n    table.cell(tbl, 1, 4, txt_r5, bgcolor=is_bench_good ? c_bench_hi_bg : c_def_bg, text_color=is_bench_good ? c_bench_hi_tx : c_def_tx, text_size=txt_sz)"
  },
  "https://www.tradingview.com/script/8owCUqFq-Multi-Distribution-Volume-Profile-Zeiierman/": {
    "id": 20084056,
    "url": "https://www.tradingview.com/script/8owCUqFq-Multi-Distribution-Volume-Profile-Zeiierman/",
    "name": "Multi-Distribution Volume Profile (Zeiierman)",
    "description": "‚ñà  Overview \n Multi-Distribution Volume Profile (Zeiierman)  is a flexible, structure-first volume profile tool that lets you reshape how volume is distributed across price, from classic uniform profiles to advanced statistical curves like Gaussian, Lognormal, Student-t, and more.\n\nInstead of forcing every market into a single \"one-size-fits-all\" profile, this tool lets you model how volume is likely concentrated inside each bar (body vs wicks, midpoint, tails, center bias, right-skew, heavy tails, etc.) and then stacks that behavior across a whole lookback window to build a rich, multi-distribution map of traded activity.\n   \nOn top of that, it overlays a dynamic Center Band (value area) and a fade/gradient model that can color each price row by volume, hits, recency, volatility, reversals, or even liquidity voids, turning a plain profile into a multi-dimensional context map.\n  \n Highlights \n \n Choose from multiple Profile Build Modes , including uniform, body-only, wick-only, midpoint/close/open, center-weighted, and a suite of probability-style distributions (Gaussian, Lognormal, Weibull, Student-t, etc.)\n Flexible anchor layout:  draw the profile on Right/Left (horizontal) or Bottom/Top (vertical) to fit any chart layout\n Value Area / Center Band  computed from volume quantiles around the POC.\n Gradient-based Fade Metrics:  volume, price hits, freshness (time decay), volatility impact, dwell time, reversal density, compression, and liquidity voids\n Separate bullish vs bearish volume  at each price row for directional structure insights\n \n  \n‚ñà  How It Works \n ‚ö™  Profile Construction \nThe script scans a user-defined Bars Included window and finds the full high‚Äìlow span of that zone. It then divides this range into a user-controlled number of Price Levels (rows).\n\n For each historical bar within the window: \n \n It measures the candle‚Äôs price range, body, and wicks.\n It assigns volume to rows according to the selected Profile Build Mode, for example:\n* Range Uniform ‚Äì volume spread evenly across the full high‚Äìlow range.\n* Range Body Only / Range Wick Only ‚Äì concentrate volume inside the body or wicks only.\n* Midpoint / Close / Open Only ‚Äì allocate volume entirely into one price row (pinpoint modeling).\n   HL2 / Body Center Weighted ‚Äì center weights around the middle of the range/body.\n   Recent-Weighted Volume ‚Äì amplify newer bars using exponential time decay.\n   Volume Squared (Hard) ‚Äì aggressively boost bars with large volume.\n   Up Bars Only / Down Bars Only ‚Äì filter volume to only bullish or bearish bars.\n \n For more advanced shapes, the script uses continuous distributions across the bar‚Äôs span: \n \n Linear, Triangular, Exponential to High\n Cosine Centered, PERT\n Gaussian, Lognormal, Cauchy, Laplace\n Pareto, Weibull, Logistic, Gumbel\n Gamma, Beta, Chi-Square, Student-t, F-Shape\n \nEach distribution produces a weight for each row within the bar‚Äôs range, normalized so the total volume remains consistent, but the shape of where that volume lands changes.\n\n‚ö™  POC & Center Band (Value Area) \n\n Once all rows are accumulated: \n \n The row with the highest total volume becomes the Point of Control (POC)\n The script computes cumulative volume and finds the band that wraps a user-defined Center of Profile % (e.g., 68%) around the center of distribution.\n This range is displayed as a central band, often treated like a value area where price has spent the most ‚Äúeffort‚Äù trading.\n \n‚ö™  Gradient Fade Engine \n\n Each row also gets a fade metric, chosen in Fade Metric: \n \n Volume ‚Äì opacity based on relative volume.\n Price Hits ‚Äì how frequently that row was touched.\n Blended (Vol+Hits) ‚Äì average of volume & hits.\n Freshness ‚Äì emphasizes recent activity, controlled by Decay.\n Volatility Impact ‚Äì rows that saw larger ranges contribute more.\n Dwell Time ‚Äì where price ‚Äúcamped‚Äù the longest.\n Reversal Density ‚Äì where direction changes cluster.\n Compression ‚Äì tight-range compression zones.\n Liquidity Void ‚Äì inverse of volume (thin liquidity zones).\n \nWhen Apply Gradient is enabled, the row‚Äôs bullish/bearish colors are tinted from faint to strong based on this chosen metric, effectively turning the profile into a heatmap of your chosen structural property.\n \n‚ñà  How to Use \n\n‚ö™  Explore Different Distribution Assumptions \n\nSwitch between multiple Profile Build Modes to see how your assumptions about intrabar volume affect structure:\n\n Use Range Uniform for classical profile reading.  \n Deploy Gaussian, Logistic, or Cosine shapes to emphasize central clustering. \n  \n Try Pareto, Lognormal, or F-Shape to focus on tail / extremal activity. \n  \n Use Recent-Weighted Volume to prioritize the most recent structural behavior. \n  \nThis is especially useful for traders who want to test how different modeling assumptions change perceived value areas and levels of interest.\n\n‚ö™  Identify Value, Acceptance & Rejection Zones \n\n Use the POC and Center of Profile (%) band to distinguish: \n \n High-acceptance zones ‚Äì  wide central band, thick rows, strong gradient ‚Üí fair value areas\n Rejection zones & tails ‚Äì  thin extremes, low dwell time, high volatility or reversal density\n \n These regions can be used as: \n \n Targets and origin zones for mean reversion\n Context for breakout validation (leaving value)\n Bias reference for intraday rotations or swing rotations\n \n  \n‚ö™  Read Directional Structure Within the Profile \n\n Because each row is split into bullish vs bearish contributions, you can visually read: \n \n Where buyers dominated a price region (large bullish slice)\n Where sellers absorbed or defended (large bearish slice)\n \nCombining this with Fade Metrics like Reversal Density, Dwell Time, or Freshness turns the profile into a structural order-flow map, without needing raw tick-by-tick volume data.\n  \n‚ö™  Use Fade Metrics for Contextual Heatmaps \n\n Each Fade Metric can be used for a different analytical lens: \n \n Volume / Blended ‚Äì  emphasize where volume and activity are concentrated.\n Freshness ‚Äì  highlight the most recently active zones that still matter.\n Volatility Impact & Compression ‚Äì  spot areas of explosive moves vs coiled ranges.\n Reversal Density ‚Äì  locate micro turning points and battle zones.\n Liquidity Void ‚Äì  visually pop out thin regions that may act as speedways or magnets.\n \n  \n\n‚ñà  Settings \n \n Profile Build Mode ‚Äì  Selects how each bar‚Äôs volume is distributed across its price range (uniform, body/wick, midpoint/close/open, center-weighted, or statistical distribution families).\n Bars Included ‚Äì  Number of bars used to build the profile from the current bar backward.\n Price Levels ‚Äì  Vertical resolution of the profile: more levels = smoother but heavier.\n Anchor Side ‚Äì  Where the profile is drawn on the chart: Right, Left, Bottom, or Top.\n Offset (bars) ‚Äì  Horizontal offset from the last bar to the profile when using Right/Left modes.\n Apply Gradient ‚Äì  Toggles the fade/heatmap coloring based on the selected metric.\n Fade Metric ‚Äì  Chooses the property driving row opacity (Volume, Hits, Freshness, Volatility Impact, Dwell Time, Reversal Density, Compression, Liquidity Void).\n Decay ‚Äì  Time-decay factor for Freshness (values close to 1 keep older activity relevant for longer).\n Profile Thickness ‚Äì  Relative thickness of the profile along the time axis, as a % of the lookback window.\n Center of Profile (%) ‚Äì  Volume percentage used to define the central band (value area) around the POC.\n \n\n-----------------\nDisclaimer\n\nThe content provided in my scripts, indicators, ideas, algorithms, and systems is for educational and informational purposes only. It does not constitute financial advice, investment recommendations, or a solicitation to buy or sell any financial instruments. I will not accept liability for any loss or damage, including without limitation any loss of profit, which may arise directly or indirectly from the use of or reliance on such information.\n\nAll investments involve risk, and the past performance of a security, industry, sector, market, financial product, trading strategy, backtest, or individual's trading does not guarantee future results or returns. Investors are fully responsible for any investment decisions they make. Such decisions should be based solely on an evaluation of their financial circumstances, investment objectives, risk tolerance, and liquidity needs.\n",
    "author_name": "Zeiierman",
    "likes_count": 286,
    "comments_count": 2,
    "views_count": 0,
    "created_at": "2025-12-11T09:50:29+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "OANDA:GBPUSD",
      "full_name": "OANDA:GBPUSD",
      "short_name": "GBPUSD",
      "exchange": "OANDA",
      "type": "forex",
      "logo_id": null,
      "currency_logo_id": "country/US",
      "base_currency_logo_id": "country/GB",
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/country/GB.svg",
        "https://s3-symbol-logo.tradingview.com/country/US.svg"
      ],
      "interval": "240",
      "direction": 0,
      "badge": {
        "label": "OANDA:GBPUSD",
        "url": "/symbols/GBPUSD/"
      }
    },
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "// This work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International  \r\n// https://creativecommons.org/licenses/by-nc-sa/4.0/\r\n// ¬© Zeiierman {\r\n//@version=6\r\nindicator('Multi-Distribution Volume Profile (Zeiierman)', overlay = true, max_boxes_count = 500, max_bars_back = 5000)\r\n//}\r\n// ~~ Tooltips {\r\nvar string t1  = \"How each bar's volume is distributed across price levels (uniform, body/wick based, or statistical shapes).\"\r\nvar string t2  = \"Number of historical bars to include when building the volume profile, counted back from the current bar.\"\r\nvar string t3  = \"Number of price levels (rows) used in the profile. Higher = smoother but heavier, lower = coarser.\"\r\nvar string t4  = \"Side of the chart where the profile is drawn (right/left as horizontal map or top/bottom as vertical map).\"\r\nvar string t5  = \"Horizontal offset in bars from the last bar to where the profile is anchored. Ignored in Top/Bottom modes.\"\r\nvar string t6  = \"If enabled, row colors are faded using the selected metric instead of a flat, uniform color.\"\r\nvar string t7  = \"Metric that controls the fade/opacity of each row (volume, hits, freshness, volatility, reversals, voids, etc.).\"\r\nvar string t8  = \"Per-bar decay factor for the Freshness metric. Closer to 1.000 keeps older activity visible for longer.\"\r\nvar string t9  = \"Relative thickness of the profile on the time axis, as a percentage of the lookback window.\"\r\nvar string t10 = \"Percentage of total volume used to define the central band (value area) around the POC (e.g., 68% ‚âà 1œÉ).\"\r\nvar string t11 = \"Fill color used for bullish rows that lie inside the central profile band (value area).\"\r\nvar string t12 = \"Fill color used for bearish rows that lie inside the central profile band (value area).\"\r\nvar string t13 = \"Base body color for bullish volume outside the central band. Gradient is applied on top if enabled.\"\r\nvar string t14 = \"Base body color for bearish volume outside the central band. Gradient is applied on top if enabled.\"\r\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\r\n\r\n// ~~ Inputs {\r\nprofileMode = input.string('Gaussian Center', 'Profile Build Mode', options = ['Range Uniform', \r\n 'Range Body Only', 'Range Wick Only', 'Midpoint Only', 'Close Price Only', 'Open Price Only', \r\n 'HL2 Center Weighted', 'Body Center Weighted', 'Recent-Weighted Volume', 'Volume Squared (Hard)', \r\n 'Up Bars Only', 'Down Bars Only', 'Linear', 'Triangular Center', 'Exponential to High', \r\n 'Cosine Centered', 'PERT', 'Gaussian Center', 'Lognormal (Right-Skew)', 'Cauchy (Heavy Tails)', \r\n 'Laplace (Sharp Center)', 'Pareto (Tail-heavy)', 'Weibull (Shape Bias)', 'Logistic (S-Curve)', \r\n 'Gumbel (Extreme Value)', 'Gamma (Right-Skew)', 'Beta (Flexible Shape)', 'Chi-Square (Right-Tail)', \r\n 'Student-t (Fat Tails)', 'F-Shape (Variance Tail)'], \r\n group = \"Profile\", inline=\"profile\", tooltip=t1)\r\n\r\nbarsLookbackIn = input.int(240, 'Bars Included', minval = 50, maxval = 4000, step = 20, group = \"Profile\", inline=\"profile\", tooltip=t1+ \"\\n\\n\" +t2)\r\nlevelsIn       = input.int(250, 'Price Levels', minval = 8, maxval = 250, step = 8, group = \"Profile\", inline=\"\", tooltip=t3)\r\n\r\nsideChoice     = input.string('Right Side', 'Anchor Side', options = ['Right Side', 'Left Side', 'Bottom', 'Top'], group = \"Profile Layout\", inline=\"anchor\", tooltip=t4)\r\nedgeOffsetBars = input.int(100, 'Offset (bars)', minval = 0, maxval = 150, group = \"Profile Layout\", inline=\"anchor\", tooltip=t4+ \"\\n\\n\" +t5)\r\n\r\nuseGradient = input.bool(true, 'Apply Gradient', group = \"Style & Colors\", inline=\"gradient\", tooltip=t6)\r\nfadeMode    = input.string('Freshness', 'Fade Metric', options = ['Volume', 'Price Hits', 'Blended (Vol+Hits)', \r\n'Freshness', 'Volatility Impact', 'Dwell Time', 'Reversal Density', 'Compression', 'Liquidity Void'], group = \"Style & Colors\", inline=\"gradient\", tooltip=t7)\r\nfreshDecay  = input.float(0.99, 'Decay', minval = 0.90, maxval = 0.999, step = 0.001, group = \"Style & Colors\", inline=\"gradient\",active=fadeMode==\"Freshness\", tooltip=t6+ \"\\n\\n\" +t7+ \"\\n\\n\" +t8)\r\nthicknessPctIn  = input.float(40.0, 'Profile Thickness', minval = 5, maxval = 250, step = 1, group = \"Style & Colors\", inline=\"thickness\", tooltip=t9) / 100.0\r\ncenterBandPctIn = input.float(68.0, 'Center of Profile (%)', minval = 10, maxval = 95, step = 1, group = \"Style & Colors\", inline=\"Central\", tooltip=t10)  / 100.0\r\n\r\ncolBandUp = input.color(color.new(#1e88e5, 25), 'Bullish', group = \"Style & Colors\", inline=\"col\", tooltip=t11)\r\ncolBandDn = input.color(color.new(#ffb300, 25), 'Bearish', group = \"Style & Colors\", inline=\"col\", tooltip=t11+ \"\\n\\n\" +t12)\r\ncolBodyUp = input.color(color.new(#616161, 50), 'Bullish', group = \"Style & Colors\", inline=\"col1\", tooltip=t13)\r\ncolBodyDn = input.color(color.new(#cfd8dc, 55), 'Bearish', group = \"Style & Colors\", inline=\"col1\", tooltip=t13+ \"\\n\\n\" +t14)\r\n\r\nanchorRight  = sideChoice == 'Right Side'\r\nanchorLeft   = sideChoice == 'Left Side'\r\nanchorBottom = sideChoice == 'Bottom'\r\nanchorTop    = sideChoice == 'Top'\r\nextendRight  = anchorRight\r\nextendLeft   = anchorLeft \r\n\r\nshowMap = true\r\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\r\n\r\n// ~~ State {\r\nvar float profLow = na\r\nvar float profHigh = na\r\nvar int profStartIdx = na\r\n\r\n// boxes for drawing\r\nvar array<box> boxes = array.new_box()\r\n\r\n// per-row data\r\nvar array<float> volTotal = array.new_float()\r\nvar array<float> volUp = array.new_float()\r\nvar array<float> volDn = array.new_float()\r\nvar array<int> rowHits = array.new_int()\r\nvar array<int> reversalHits = array.new_int()\r\nvar array<float> rowVolatility = array.new_float()\r\nvar array<float> dwellTime = array.new_float()\r\nvar array<float> recencyScore = array.new_float()\r\nvar array<float> compressionSc = array.new_float()\r\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\r\n\r\n// ~~ Helper {\r\nf_reset_arrays(rows) =>\r\n    if volTotal.size() != rows\r\n        volTotal.clear()\r\n        volUp.clear()\r\n        volDn.clear()\r\n        rowHits.clear()\r\n        reversalHits.clear()\r\n        rowVolatility.clear()\r\n        dwellTime.clear()\r\n        recencyScore.clear()\r\n        compressionSc.clear()\r\n        for i = 0 to rows - 1 by 1\r\n            volTotal.push(0.0)\r\n            volUp.push(0.0)\r\n            volDn.push(0.0)\r\n            rowHits.push(0)\r\n            reversalHits.push(0)\r\n            rowVolatility.push(0.0)\r\n            dwellTime.push(0.0)\r\n            recencyScore.push(0.0)\r\n            compressionSc.push(0.0)\r\n    else\r\n        for i = 0 to rows - 1 by 1\r\n            volTotal.set(i, 0.0)\r\n            volUp.set(i, 0.0)\r\n            volDn.set(i, 0.0)\r\n            rowHits.set(i, 0)\r\n            reversalHits.set(i, 0)\r\n            rowVolatility.set(i, 0.0)\r\n            dwellTime.set(i, 0.0)\r\n            recencyScore.set(i, 0.0)\r\n            compressionSc.set(i, 0.0)\r\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}\r\n\r\n// ~~ Main { \r\nif barstate.islast and showMap\r\n    // 1. Determine effective lookback & start index {\r\n    lookbackBars = math.min(barsLookbackIn, bar_index + 1)\r\n    profStartIdx := bar_index - lookbackBars + 1\r\n    //} \r\n\r\n    if lookbackBars > 0\r\n        // 2. Find price bounds within window {\r\n        float lo = high\r\n        float hi = low\r\n        for i = 0 to lookbackBars - 1 by 1\r\n            lo := math.min(lo, low[i])\r\n            hi := math.max(hi, high[i])\r\n            hi\r\n\r\n        profLow := lo\r\n        profHigh := hi\r\n\r\n        priceSpan = profHigh - profLow\r\n        rows = math.max(levelsIn, 1)\r\n        priceStep = priceSpan > 0 ? priceSpan / rows : na\r\n        //}  \r\n\r\n        if priceSpan > 0 and not na(priceStep)\r\n            // 3. Reset arrays {\r\n            f_reset_arrays(rows)\r\n            //}  \r\n\r\n            // 4. Accumulate per-row stats (depends on profileMode) {\r\n            for iBar = 0 to lookbackBars - 1 by 1\r\n                barLow = low[iBar]\r\n                barHigh = high[iBar]\r\n                barVol = volume[iBar]\r\n                isUp = close[iBar] >= open[iBar]\r\n                barRange = barHigh - barLow\r\n                barVolat = barRange\r\n\r\n                dir = close[iBar] > open[iBar] ? 1 : close[iBar] < open[iBar] ? -1 : 0\r\n                prevDir = close[iBar + 1] > open[iBar + 1] ? 1 : close[iBar + 1] < open[iBar + 1] ? -1 : 0\r\n                isReversalBar = dir != 0 and prevDir != 0 and dir != prevDir\r\n\r\n                bodyLow = math.min(open[iBar], close[iBar])\r\n                bodyHigh = math.max(open[iBar], close[iBar])\r\n\r\n                startRow = math.max(math.floor((barLow - profLow) / priceStep), 0)\r\n                endRow = math.min(math.floor((barHigh - profLow) / priceStep), rows - 1)\r\n                span = endRow - startRow + 1\r\n\r\n                bodyStartRow = math.max(math.floor((bodyLow - profLow) / priceStep), 0)\r\n                bodyEndRow = math.min(math.floor((bodyHigh - profLow) / priceStep), rows - 1)\r\n                bodySpan = bodyEndRow >= bodyStartRow ? bodyEndRow - bodyStartRow + 1 : 0\r\n\r\n                lowWickSpan = bodyStartRow > startRow ? bodyStartRow - startRow : 0\r\n                highWickSpan = bodyEndRow < endRow ? endRow - bodyEndRow : 0\r\n                wickSpan = lowWickSpan + highWickSpan\r\n\r\n                weightRec = math.pow(freshDecay, iBar)\r\n\r\n                effVol = barVol\r\n                effIsUp = isUp\r\n\r\n                if profileMode == 'Recent-Weighted Volume'\r\n                    effVol := barVol * weightRec\r\n                    effVol\r\n                if profileMode == 'Volume Squared (Hard)'\r\n                    effVol := barVol * barVol\r\n                    effVol\r\n                if profileMode == 'Up Bars Only' and not isUp\r\n                    effVol := 0.0\r\n                    effVol\r\n                if profileMode == 'Down Bars Only' and isUp\r\n                    effVol := 0.0\r\n                    effVol\r\n\r\n                if span <= 0 or effVol <= 0\r\n                    continue\r\n\r\n                midPrice = (barHigh + barLow) * 0.5\r\n                hl2Row = math.floor((midPrice - profLow) / priceStep)\r\n                closeRow = math.floor((close[iBar] - profLow) / priceStep)\r\n                openRow = math.floor((open[iBar] - profLow) / priceStep)\r\n                midRowClamped = math.min(math.max(hl2Row, 0), rows - 1)\r\n                closeRowClamped = math.min(math.max(closeRow, 0), rows - 1)\r\n                openRowClamped = math.min(math.max(openRow, 0), rows - 1)\r\n\r\n                bool customSpanDist = profileMode == 'Linear' or profileMode == 'Triangular Center' or \r\n                 profileMode == 'Exponential to High' or profileMode == 'Cosine Centered' or \r\n                 profileMode == 'PERT' or profileMode == 'Gaussian Center' or \r\n                 profileMode == 'Lognormal (Right-Skew)' or profileMode == 'Cauchy (Heavy Tails)' or \r\n                 profileMode == 'Laplace (Sharp Center)' or profileMode == 'Pareto (Tail-heavy)' or \r\n                 profileMode == 'Weibull (Shape Bias)' or profileMode == 'Logistic (S-Curve)' or \r\n                 profileMode == 'Gumbel (Extreme Value)' or profileMode == 'Gamma (Right-Skew)' or \r\n                 profileMode == 'Beta (Flexible Shape)' or profileMode == 'Chi-Square (Right-Tail)' or \r\n                 profileMode == 'Student-t (Fat Tails)' or profileMode == 'F-Shape (Variance Tail)'\r\n\r\n                // parameters for distribution modes\r\n                float sumW = 0.0\r\n                float expBase = 1.3\r\n                float pertAlpha = 2.5\r\n                float pertBeta = 2.5\r\n                float gaussMu = 0.5\r\n                float gaussSigma = 0.2\r\n                float lnMu = -0.5\r\n                float lnSigma = 0.4\r\n                float cauchyScale = 0.18\r\n                float laplaceB = 0.18\r\n                float paretoAlpha = 2.0\r\n                float weibullK = 2.0\r\n                float weibullLam = 1.0\r\n                float logisticScale = 0.12\r\n                float gumbelBeta = 0.20\r\n                float gammaK = 2.0\r\n                float gammaTheta = 0.5\r\n                float betaAlpha = 0.5\r\n                float betaBeta = 0.5\r\n                float chiK = 3.0\r\n                float studNu = 3.0\r\n                float studScale = 0.22\r\n                float fD1 = 3.0\r\n                float fD2 = 5.0\r\n\r\n                // precompute normalization for distribution modes\r\n                if customSpanDist and span > 0\r\n                    for k = 0 to span - 1 by 1\r\n                        float w = 0.0\r\n                        float t = span == 1 ? 0.5 : k / (span - 1.0)\r\n                        float tSafe = math.min(0.999, math.max(0.001, t))\r\n\r\n                        if profileMode == 'Linear'\r\n                            w := tSafe\r\n                            w\r\n\r\n                        else if profileMode == 'Triangular Center'\r\n                            center = 0.5\r\n                            w := 1.0 - math.abs(t - center) * 2.0\r\n                            w\r\n\r\n                        else if profileMode == 'Exponential to High'\r\n                            w := math.pow(expBase, t * (span - 1))\r\n                            w\r\n\r\n                        else if profileMode == 'Cosine Centered'\r\n                            w := 0.5 - 0.5 * math.cos(2.0 * math.pi * t)\r\n                            w\r\n\r\n                        else if profileMode == 'PERT'\r\n                            w := math.pow(tSafe, pertAlpha - 1.0) * math.pow(1.0 - tSafe, pertBeta - 1.0)\r\n                            w\r\n\r\n                        else if profileMode == 'Gaussian Center'\r\n                            z = (t - gaussMu) / gaussSigma\r\n                            w := math.exp(-0.5 * z * z)\r\n                            w\r\n\r\n                        else if profileMode == 'Lognormal (Right-Skew)'\r\n                            lnT = math.log(tSafe)\r\n                            zln = (lnT - lnMu) / lnSigma\r\n                            w := math.exp(-0.5 * zln * zln) / tSafe\r\n                            w\r\n\r\n                        else if profileMode == 'Cauchy (Heavy Tails)'\r\n                            x = (t - 0.5) / cauchyScale\r\n                            w := 1.0 / (1.0 + x * x)\r\n                            w\r\n\r\n                        else if profileMode == 'Laplace (Sharp Center)'\r\n                            w := math.exp(-math.abs(t - 0.5) / laplaceB)\r\n                            w\r\n\r\n                        else if profileMode == 'Pareto (Tail-heavy)'\r\n                            u = 1.0 - tSafe\r\n                            w := 1.0 / math.pow(u + 0.001, paretoAlpha)\r\n                            w\r\n\r\n                        else if profileMode == 'Weibull (Shape Bias)'\r\n                            w := weibullK * math.pow(tSafe / weibullLam, weibullK - 1.0) * math.exp(-math.pow(tSafe / weibullLam, weibullK))\r\n                            w\r\n\r\n                        else if profileMode == 'Logistic (S-Curve)'\r\n                            w := 1.0 / (1.0 + math.exp(-(t - 0.5) / logisticScale))\r\n                            w\r\n\r\n                        else if profileMode == 'Gumbel (Extreme Value)'\r\n                            zG = (t - 0.5) / gumbelBeta\r\n                            w := math.exp(-(zG + math.exp(-zG)))\r\n                            w\r\n\r\n                        else if profileMode == 'Gamma (Right-Skew)'\r\n                            w := math.pow(tSafe, gammaK - 1.0) * math.exp(-tSafe / gammaTheta)\r\n                            w\r\n\r\n                        else if profileMode == 'Beta (Flexible Shape)'\r\n                            w := math.pow(tSafe, betaAlpha - 1.0) * math.pow(1.0 - tSafe, betaBeta - 1.0)\r\n                            w\r\n\r\n                        else if profileMode == 'Chi-Square (Right-Tail)'\r\n                            w := math.pow(tSafe, chiK / 2.0 - 1.0) * math.exp(-tSafe / 2.0)\r\n                            w\r\n\r\n                        else if profileMode == 'Student-t (Fat Tails)'\r\n                            xT = (t - 0.5) / studScale\r\n                            w := math.pow(1.0 + xT * xT / studNu, -(studNu + 1.0) / 2.0)\r\n                            w\r\n\r\n                        else if profileMode == 'F-Shape (Variance Tail)'\r\n                            xF = tSafe\r\n                            numPow = fD1 / 2.0 - 1.0\r\n                            denPow = (fD1 + fD2) / 2.0\r\n                            w := math.pow(xF, numPow) / math.pow(1.0 + fD1 / fD2 * xF, denPow)\r\n                            w\r\n\r\n                        if w > 0\r\n                            sumW := sumW + w\r\n                            sumW\r\n\r\n                // loop through rows and apply mode-specific weighting\r\n                for r = startRow to endRow by 1\r\n                    rowActive = false\r\n                    rowWeight = 0.0\r\n\r\n                    isBodyRow = r >= bodyStartRow and r <= bodyEndRow and bodySpan > 0\r\n                    isWickRow = wickSpan > 0 and not isBodyRow\r\n\r\n                    if profileMode == 'Range Uniform'\r\n                        rowActive := true\r\n                        rowWeight := 1.0 / span\r\n                        rowWeight\r\n\r\n                    else if profileMode == 'Range Body Only'\r\n                        if isBodyRow and bodySpan > 0\r\n                            rowActive := true\r\n                            rowWeight := 1.0 / bodySpan\r\n                            rowWeight\r\n\r\n                    else if profileMode == 'Range Wick Only'\r\n                        if isWickRow and wickSpan > 0\r\n                            rowActive := true\r\n                            rowWeight := 1.0 / wickSpan\r\n                            rowWeight\r\n\r\n                    else if profileMode == 'Midpoint Only'\r\n                        if r == midRowClamped\r\n                            rowActive := true\r\n                            rowWeight := 1.0\r\n                            rowWeight\r\n\r\n                    else if profileMode == 'Close Price Only'\r\n                        if r == closeRowClamped\r\n                            rowActive := true\r\n                            rowWeight := 1.0\r\n                            rowWeight\r\n\r\n                    else if profileMode == 'Open Price Only'\r\n                        if r == openRowClamped\r\n                            rowActive := true\r\n                            rowWeight := 1.0\r\n                            rowWeight\r\n\r\n                    else if profileMode == 'HL2 Center Weighted'\r\n                        distNorm = span > 1 ? math.min(1.0, math.abs(r - midRowClamped) / (span - 1)) : 0.0\r\n                        wHL = 1.0 - distNorm\r\n                        if wHL > 0\r\n                            rowActive := true\r\n                            rowWeight := wHL / span\r\n                            rowWeight\r\n\r\n                    else if profileMode == 'Body Center Weighted'\r\n                        if isBodyRow and bodySpan > 0\r\n                            bodyMidRow = (bodyStartRow + bodyEndRow) * 0.5\r\n                            bodySpanNorm = bodySpan > 1 ? bodySpan - 1 : 1\r\n                            distNormBody = math.min(1.0, math.abs(r - bodyMidRow) / bodySpanNorm)\r\n                            wBody = 1.0 - distNormBody\r\n                            if wBody > 0\r\n                                rowActive := true\r\n                                rowWeight := wBody / bodySpan\r\n                                rowWeight\r\n\r\n                    else if profileMode == 'Recent-Weighted Volume'\r\n                        rowActive := true\r\n                        rowWeight := 1.0 / span\r\n                        rowWeight\r\n\r\n                    else if profileMode == 'Volume Squared (Hard)'\r\n                        rowActive := true\r\n                        rowWeight := 1.0 / span\r\n                        rowWeight\r\n\r\n                    else if profileMode == 'Up Bars Only'\r\n                        if effVol > 0\r\n                            rowActive := true\r\n                            rowWeight := 1.0 / span\r\n                            rowWeight\r\n\r\n                    else if profileMode == 'Down Bars Only'\r\n                        if effVol > 0\r\n                            rowActive := true\r\n                            rowWeight := 1.0 / span\r\n                            rowWeight\r\n\r\n                    else if customSpanDist\r\n                        pos = r - startRow\r\n                        float wRow = 0.0\r\n                        float tRow = span == 1 ? 0.5 : pos / (span - 1.0)\r\n                        float tSafeRow = math.min(0.999, math.max(0.001, tRow))\r\n\r\n                        if profileMode == 'Linear'\r\n                            wRow := tSafeRow\r\n                            wRow\r\n\r\n                        else if profileMode == 'Triangular Center'\r\n                            center2 = 0.5\r\n                            wRow := 1.0 - math.abs(tRow - center2) * 2.0\r\n                            wRow\r\n\r\n                        else if profileMode == 'Exponential to High'\r\n                            wRow := math.pow(expBase, tRow * (span - 1))\r\n                            wRow\r\n\r\n                        else if profileMode == 'Cosine Centered'\r\n                            wRow := 0.5 - 0.5 * math.cos(2.0 * math.pi * tRow)\r\n                            wRow\r\n\r\n                        else if profileMode == 'PERT'\r\n                            wRow := math.pow(tSafeRow, pertAlpha - 1.0) * math.pow(1.0 - tSafeRow, pertBeta - 1.0)\r\n                            wRow\r\n\r\n                        else if profileMode == 'Gaussian Center'\r\n                            zR = (tRow - gaussMu) / gaussSigma\r\n                            wRow := math.exp(-0.5 * zR * zR)\r\n                            wRow\r\n\r\n                        else if profileMode == 'Lognormal (Right-Skew)'\r\n                            lnTR = math.log(tSafeRow)\r\n                            zlnR = (lnTR - lnMu) / lnSigma\r\n                            wRow := math.exp(-0.5 * zlnR * zlnR) / tSafeRow\r\n                            wRow\r\n\r\n                        else if profileMode == 'Cauchy (Heavy Tails)'\r\n                            xR = (tRow - 0.5) / cauchyScale\r\n                            wRow := 1.0 / (1.0 + xR * xR)\r\n                            wRow\r\n\r\n                        else if profileMode == 'Laplace (Sharp Center)'\r\n                            wRow := math.exp(-math.abs(tRow - 0.5) / laplaceB)\r\n                            wRow\r\n\r\n                        else if profileMode == 'Pareto (Tail-heavy)'\r\n                            uR = 1.0 - tSafeRow\r\n                            wRow := 1.0 / math.pow(uR + 0.001, paretoAlpha)\r\n                            wRow\r\n\r\n                        else if profileMode == 'Weibull (Shape Bias)'\r\n                            wRow := weibullK * math.pow(tSafeRow / weibullLam, weibullK - 1.0) * math.exp(-math.pow(tSafeRow / weibullLam, weibullK))\r\n                            wRow\r\n\r\n                        else if profileMode == 'Logistic (S-Curve)'\r\n                            wRow := 1.0 / (1.0 + math.exp(-(tRow - 0.5) / logisticScale))\r\n                            wRow\r\n\r\n                        else if profileMode == 'Gumbel (Extreme Value)'\r\n                            zGR = (tRow - 0.5) / gumbelBeta\r\n                            wRow := math.exp(-(zGR + math.exp(-zGR)))\r\n                            wRow\r\n\r\n                        else if profileMode == 'Gamma (Right-Skew)'\r\n                            wRow := math.pow(tSafeRow, gammaK - 1.0) * math.exp(-tSafeRow / gammaTheta)\r\n                            wRow\r\n\r\n                        else if profileMode == 'Beta (Flexible Shape)'\r\n                            wRow := math.pow(tSafeRow, betaAlpha - 1.0) * math.pow(1.0 - tSafeRow, betaBeta - 1.0)\r\n                            wRow\r\n\r\n                        else if profileMode == 'Chi-Square (Right-Tail)'\r\n                            wRow := math.pow(tSafeRow, chiK / 2.0 - 1.0) * math.exp(-tSafeRow / 2.0)\r\n                            wRow\r\n\r\n                        else if profileMode == 'Student-t (Fat Tails)'\r\n                            xTR = (tRow - 0.5) / studScale\r\n                            wRow := math.pow(1.0 + xTR * xTR / studNu, -(studNu + 1.0) / 2.0)\r\n                            wRow\r\n\r\n                        else if profileMode == 'F-Shape (Variance Tail)'\r\n                            xFR = tSafeRow\r\n                            numPw = fD1 / 2.0 - 1.0\r\n                            denPw = (fD1 + fD2) / 2.0\r\n                            wRow := math.pow(xFR, numPw) / math.pow(1.0 + fD1 / fD2 * xFR, denPw)\r\n                            wRow\r\n\r\n                        if wRow > 0 and sumW > 0\r\n                            rowActive := true\r\n                            rowWeight := wRow / sumW\r\n                            rowWeight\r\n\r\n                    if not rowActive or rowWeight <= 0\r\n                        continue\r\n\r\n                    volContrib = effVol * rowWeight\r\n\r\n                    // accumulate profile volume\r\n                    oldTotal = volTotal.get(r)\r\n                    volTotal.set(r, oldTotal + volContrib)\r\n\r\n                    if effIsUp\r\n                        oldUp = volUp.get(r)\r\n                        volUp.set(r, oldUp + volContrib)\r\n                    else\r\n                        oldDn = volDn.get(r)\r\n                        volDn.set(r, oldDn + volContrib)\r\n\r\n                    // metrics\r\n                    hits = rowHits.get(r)\r\n                    rowHits.set(r, hits + 1)\r\n\r\n                    if isReversalBar\r\n                        rv = reversalHits.get(r)\r\n                        reversalHits.set(r, rv + 1)\r\n\r\n                    volImp = rowVolatility.get(r)\r\n                    rowVolatility.set(r, volImp + barVolat / span)\r\n\r\n                    dwell = dwellTime.get(r)\r\n                    dwellTime.set(r, dwell + 1.0 / span)\r\n\r\n                    rec = recencyScore.get(r)\r\n                    recencyScore.set(r, rec + weightRec)\r\n\r\n                    comp = compressionSc.get(r)\r\n                    compressionFactor = barRange > 0 ? priceStep / barRange : 0.0\r\n                    compressionSc.set(r, comp + compressionFactor / span)\r\n            //} \r\n\r\n            // 5. Compute POC and central band {\r\n            pocIdx = 0\r\n            maxVol = 0.0\r\n            totalVol = 0.0\r\n            for r = 0 to rows - 1 by 1\r\n                v = volTotal.get(r)\r\n                totalVol := totalVol + v\r\n                if v > maxVol\r\n                    maxVol := v\r\n                    pocIdx := r\r\n                    pocIdx\r\n\r\n            if totalVol > 0\r\n                lowerTarget = totalVol * (0.5 - centerBandPctIn * 0.5)\r\n                upperTarget = totalVol * (0.5 + centerBandPctIn * 0.5)\r\n\r\n                float cum = 0.0\r\n                int bandLowIdx = 0\r\n                int bandHiIdx = rows - 1\r\n                bool upperFound = false\r\n\r\n                for r = 0 to rows - 1 by 1\r\n                    cum := cum + volTotal.get(r)\r\n                    if cum <= lowerTarget\r\n                        bandLowIdx := r\r\n                        bandLowIdx\r\n                    if not upperFound and cum >= upperTarget\r\n                        bandHiIdx := r\r\n                        upperFound := true\r\n                        upperFound\r\n\r\n                pocPrice = profLow + (pocIdx + 0.5) * priceStep\r\n                bandLow = profLow + (bandLowIdx + 0.0) * priceStep\r\n                bandHigh = profLow + (bandHiIdx + 1.0) * priceStep\r\n                //} \r\n\r\n                // 6. per-row maxes for fade metrics {\r\n                maxHits = 0\r\n                maxRec = 0.0\r\n                maxVolImpRow = 0.0\r\n                maxDwellRow = 0.0\r\n                maxCompRow = 0.0\r\n                maxRevHits = 0\r\n\r\n                for r = 0 to rows - 1 by 1\r\n                    hits = rowHits.get(r)\r\n                    rec = recencyScore.get(r)\r\n                    vImp = rowVolatility.get(r)\r\n                    dw = dwellTime.get(r)\r\n                    comp = compressionSc.get(r)\r\n                    rev = reversalHits.get(r)\r\n\r\n                    maxHits := math.max(maxHits, hits)\r\n                    maxRec := math.max(maxRec, rec)\r\n                    maxVolImpRow := math.max(maxVolImpRow, vImp)\r\n                    maxDwellRow := math.max(maxDwellRow, dw)\r\n                    maxCompRow := math.max(maxCompRow, comp)\r\n                    maxRevHits := math.max(maxRevHits, rev)\r\n                    maxRevHits\r\n                //} \r\n\r\n                // 7. Clear existing boxes {\r\n                while boxes.size() > 0\r\n                    box.delete(boxes.pop())\r\n                //} \r\n\r\n                // 8. Horizontal span for drawing (time axis) {\r\n                plotLen = lookbackBars > 360 ? 360 : lookbackBars\r\n                profWidth = plotLen * thicknessPctIn\r\n\r\n                bool verticalMode = anchorBottom or anchorTop\r\n\r\n                float histHeight = priceSpan * 0.4\r\n                float baseYBottom = profLow - histHeight\r\n                float baseYTop = profHigh + histHeight\r\n\r\n                effectiveOffset = verticalMode ? 0 : edgeOffsetBars\r\n\r\n                histRight = bar_index + effectiveOffset\r\n                histLeft = histRight - rows \r\n\r\n                rightEdge = bar_index + effectiveOffset\r\n                leftEdge = rightEdge - int(profWidth)\r\n\r\n                baseLeft = extendRight ? leftEdge : profStartIdx\r\n                baseRight = extendRight ? rightEdge : profStartIdx + int(profWidth)\r\n                //}  \r\n\r\n                // 9. Row-by-row drawing {\r\n                for r = 0 to rows - 1 by 1\r\n                    rowVol = volTotal.get(r)\r\n                    upVol = volUp.get(r)\r\n                    dnVol = volDn.get(r)\r\n                    hits = rowHits.get(r)\r\n                    rev = reversalHits.get(r)\r\n                    vImp = rowVolatility.get(r)\r\n                    dw = dwellTime.get(r)\r\n                    rec = recencyScore.get(r)\r\n                    comp = compressionSc.get(r)\r\n\r\n                    volRel = maxVol > 0 ? rowVol / maxVol : 0.0\r\n                    hitRel = maxHits > 0 ? hits / maxHits : 0.0\r\n                    freshRel = maxRec > 0 ? rec / maxRec : 0.0\r\n                    volImpRel = maxVolImpRow > 0 ? vImp / maxVolImpRow : 0.0\r\n                    dwellRel = maxDwellRow > 0 ? dw / maxDwellRow : 0.0\r\n                    compRel = maxCompRow > 0 ? comp / maxCompRow : 0.0\r\n                    revRel = maxRevHits > 0 ? rev / maxRevHits : 0.0\r\n\r\n                    voidRel = 1.0 - volRel\r\n\r\n                    fadeRel = switch fadeMode\r\n                        'Volume' => volRel\r\n                        'Price Hits' => hitRel\r\n                        'Blended (Vol+Hits)' => (volRel + hitRel) * 0.5\r\n                        'Freshness' => freshRel\r\n                        'Volatility Impact' => volImpRel\r\n                        'Dwell Time' => dwellRel\r\n                        'Reversal Density' => revRel\r\n                        'Compression' => compRel\r\n                        'Liquidity Void' => voidRel\r\n                        => volRel\r\n\r\n                    upCol = useGradient ? color.from_gradient(fadeRel, 0.0, 1.0, color.new(colBodyUp, 95), color.new(colBodyUp, 0)) : colBodyUp\r\n                    dnCol = useGradient ? color.from_gradient(fadeRel, 0.0, 1.0, color.new(colBodyDn, 95), color.new(colBodyDn, 0)) : colBodyDn\r\n                    bandUp = useGradient ? color.from_gradient(fadeRel, 0.0, 1.0, color.new(colBandUp, 95), color.new(colBandUp, 0)) : colBandUp\r\n                    bandDn = useGradient ? color.from_gradient(fadeRel, 0.0, 1.0, color.new(colBandDn, 95), color.new(colBandDn, 0)) : colBandDn\r\n\r\n                    inBand = r >= bandLowIdx and r <= bandHiIdx\r\n\r\n                    upFrac = maxVol > 0 ? upVol / maxVol : 0.0\r\n                    dnFrac = maxVol > 0 ? dnVol / maxVol : 0.0\r\n\r\n                    if not verticalMode\r\n                        upBars = upFrac * profWidth\r\n                        dnBars = dnFrac * profWidth\r\n\r\n                        rowLo = profLow + (r + 0.05) * priceStep\r\n                        rowHi = profLow + (r + 0.95) * priceStep\r\n\r\n                        if upBars > 0\r\n                            bxStart = extendRight ? baseRight - int(upBars) : baseLeft\r\n                            bxEnd = extendRight ? baseRight : baseLeft + int(upBars)\r\n                            cRow = inBand ? bandUp : upCol\r\n                            b = box.new(bxStart, rowLo, bxEnd, rowHi, bgcolor = cRow, border_color = color.new(cRow, 100))\r\n                            boxes.push(b)\r\n\r\n                        if dnBars > 0\r\n                            bxStart2 = extendRight ? baseRight - int(upBars) - int(dnBars) : baseLeft + int(upBars)\r\n                            bxEnd2 = extendRight ? baseRight - int(upBars) : baseLeft + int(upBars) + int(dnBars)\r\n                            cRow2 = inBand ? bandDn : dnCol\r\n                            b2 = box.new(bxStart2, rowLo, bxEnd2, rowHi, bgcolor = cRow2, border_color = color.new(cRow2, 100))\r\n                            boxes.push(b2)\r\n\r\n                    else\r\n                        xStart = histLeft + r\r\n                        xEnd = xStart + 1\r\n\r\n                        heightScale = histHeight\r\n\r\n                        if anchorBottom\r\n                            baseY = baseYBottom\r\n\r\n                            if upFrac > 0\r\n                                y0u = baseY\r\n                                y1u = baseY + upFrac * heightScale\r\n                                cRowU = inBand ? bandUp : upCol\r\n                                bu = box.new(xStart, y0u, xEnd, y1u, bgcolor = cRowU, border_color = color.new(cRowU, 100))\r\n                                boxes.push(bu)\r\n\r\n                            if dnFrac > 0\r\n                                y0d = baseY + upFrac * heightScale\r\n                                y1d = baseY + (upFrac + dnFrac) * heightScale\r\n                                cRowD = inBand ? bandDn : dnCol\r\n                                bd = box.new(xStart, y0d, xEnd, y1d, bgcolor = cRowD, border_color = color.new(cRowD, 100))\r\n                                boxes.push(bd)\r\n\r\n                        else if anchorTop\r\n                            baseY = baseYTop\r\n\r\n                            if upFrac > 0\r\n                                y0u = baseY\r\n                                y1u = baseY - upFrac * heightScale\r\n                                cRowU = inBand ? bandUp : upCol\r\n                                bu = box.new(xStart, y0u, xEnd, y1u, bgcolor = cRowU, border_color = color.new(cRowU, 100))\r\n                                boxes.push(bu)\r\n\r\n                            if dnFrac > 0\r\n                                y0d = baseY - upFrac * heightScale\r\n                                y1d = baseY - (upFrac + dnFrac) * heightScale\r\n                                cRowD = inBand ? bandDn : dnCol\r\n                                bd = box.new(xStart, y0d, xEnd, y1d, bgcolor = cRowD, border_color = color.new(cRowD, 100))\r\n                                boxes.push(bd)\r\n                //} \r\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}"
  },
  "https://www.tradingview.com/script/AjqADRsu-Open-Interest-Z-Score-BackQuant/": {
    "id": 20082466,
    "url": "https://www.tradingview.com/script/AjqADRsu-Open-Interest-Z-Score-BackQuant/",
    "name": "Open Interest Z-Score [BackQuant]",
    "description": "Open Interest Z-Score  \n A standardized pressure gauge for futures positioning that turns multi venue open interest into a Z score, so you can see how extreme current positioning is relative to its own history and where leverage is stretched, decompressing, or quietly re loading. \n\n What this is \nThis indicator builds a single synthetic open interest series by aggregating futures OI across major derivatives venues, then standardises that aggregated OI into a rolling Z score. Instead of looking at raw OI or a simple change, you get a normalized signal that says \"how many standard deviations away from normal is positioning right now\", with optional smoothing, reference bands, and divergence detection against price.\n\nYou can render the Z score in several plotting modes:\n \n Line for a clean, classic oscillator.\n Colored line that encodes both sign and momentum of OI Z.\n Oscillator histogram that makes impulses and compressions obvious.\n \n\nThe script also includes:\n \n Aggregated open interest across Binance, Bybit, OKX, Bitget, Kraken, HTX, and Deribit, using multiple contract suffixes where applicable.\n Choice of OI units, either coin based or converted to USD notional.\n Standard deviation reference lines and adaptive extreme bands.\n A flexible smoothing layer with multiple moving average types.\n Automatic detection of regular and hidden divergences between price and OI Z.\n Alerts for zero line and ¬±2 sigma crosses.\n \n\n Aggregated open interest source \nAt the core is the same multi venue OI aggregation engine as in the OI RSI tool, adapted from NoveltyTrade's work and extended for this use case. The indicator:\n \n Anchors on the current chart symbol and its base currency.\n Loops over a set of exchanges, gated by user toggles:\n   \n   Binance.\n   Bybit.\n   OKX.\n   Bitget.\n   Kraken.\n   HTX.\n   Deribit.\n   \n For each exchange, loops over several contract suffixes such as USDT.P, USD.P, USDC.P, USD.PM to cover the common perp and margin styles.\n Requests OI candles for each exchange plus suffix pair into a small custom OI type that carries open, high, low and close of open interest.\n Converts each OI stream into a common unit via the  sw  method:\n   \n   In COIN mode, OI is normalized relative to the coin.\n   In USD mode, OI is scaled by price to approximate notional.\n   Exchange specific scaling factors are applied where needed to match contract multipliers.\n   \n Accumulates all valid OI candles into a single combined OI \"candle\" by summing open, high, low and close across venues.\n \n\nThe result is  oiClose , a synthetic close for aggregated OI that represents cross venue positioning. If there is no valid OI data for the symbol after this process, the script throws a clear runtime error so you know the market is unsupported rather than quietly plotting nonsense.\n\n How the Z score is computed \nOnce the aggregated OI close is available, the indicator computes a rolling Z score over a configurable lookback:\n \n Define  subject  as the aggregated OI close.\n Compute a rolling mean of this subject with EMA over  Z Score Lookback Period .\n Compute a rolling standard deviation over the same length.\n Subtract the mean from the current OI and divide by the standard deviation.\n \n\nThis gives a raw Z score:\n \n oi_z_raw = (subject ‚àí mean) √∑ stdDev .\n \n\nInstead of plotting this raw value directly, the script passes it through a smoothing layer:\n \n You pick a  Smoothing Type  and  Smoothing Period .\n Choices include SMA, HMA, EMA, WMA, DEMA, RMA, linear regression, ALMA, TEMA, and T3.\n The helper  ma  function applies the chosen smoother to the raw Z score.\n \n\nThe result is  oi_z , a smoothed Z score of aggregated open interest. A separate EMA with  EMA Period  is then applied on  oi_z  to create a signal line  ma  that can be used for crossovers and trend reads.\n\n Plotting modes \nThe  Plotting Type  input controls how this Z score is rendered:\n\n 1) Line \nIn line mode:\n \n The smoothed OI Z score is plotted as a single line using  Base Line Color .\n The EMA overlay is optionally plotted if  Show EMA  is enabled.\n This is the cleanest view when you want to treat OI Z like a standard oscillator, watching for zero line crosses, swings, and divergences.\n \n\n 2) Colored Line \nColored line mode adds conditional color logic to the Z score:\n \n If the Z score is above zero and rising, it is bright green, representing positive and strengthening positioning pressure.\n If the Z score is above zero and falling, it shifts to a cooler cyan, representing positive but weakening pressure.\n If the Z score is below zero and falling, it is bright red, representing negative and strengthening pressure (growing net de risking or shorting).\n If the Z score is below zero and rising, it is dark red, representing negative but recovering pressure.\n \n\nThis mapping makes it easy to see not only whether OI is above or below its historical mean, but also whether that deviation is intensifying or fading.\n\n 3) Oscillator \nOscillator mode turns the Z score into a histogram:\n \n The smoothed Z score is plotted as vertical columns around zero.\n Column colors use the same conditional palette as colored line mode, based on sign and change direction.\n The histogram base is zero, so bars extend up into positive Z and down into negative Z.\n \n\nOscillator mode is useful when you care about impulses in positioning, for example sharp jumps into positive Z that coincide with fast builds in leverage, or deep spikes into negative Z that show aggressive flushes.\n\n 4) None \nIf you only want reference lines, extreme bands, divergences, or alerts without the base oscillator, you can set plotting to None and keep the rest of the tooling active.\n\nThe EMA overlay respects plotting mode and only appears when a visible Z score line or histogram is present.\n\n Reference lines and standard deviation levels \nThe  Select Reference Lines  input offers two styles:\n\n Standard Deviation Levels \n \n Plots small markers at zero.\n Draws thin horizontal lines at +1, +2, ‚àí1 and ‚àí2 Z.\n Acts like a classic Z score ladder, zero as mean, ¬±1 as normal band, ¬±2 as outer band.\n \n\nThis mode is ideal if you want a textbook statistical framing, using ¬±1 and ¬±2 sigma as standard levels for \"normal\" versus \"extended\" positioning.\n\n Extreme Bands \nExtreme bands build on the same ¬±1 and ¬±2 lines, then add:\n \n Upper outer band between +3 and +4 Z.\n Lower outer band between ‚àí3 and ‚àí4 Z.\n Dynamic fill colors inside these bands:\n   \n   If the Z score is positive, the upper band fill turns red with an alpha that scales with the magnitude of |Z|, capped at a chosen max strength. Stronger deviations towards +4 produce more opaque red fills.\n   If the Z score is negative, the lower band fill turns green with the same adaptive alpha logic, highlighting deep negative deviations.\n   Opposite side bands remain a faint neutral white when not in use, so they still provide structural context without shouting.\n   \n \n\nThis creates a visual \"danger zone\" for position crowding. When the Z score enters these outer bands, open interest is many standard deviations away from its mean and you are dealing with rare but highly loaded positioning states.\n\n Z score as a positioning pressure gauge \nBecause this is a Z score of aggregated open interest, it measures how unusual current positioning is relative to its own recent history, not just whether OI is rising or falling:\n \n Z near zero means total OI is roughly in line with normal conditions for your lookback window.\n Positive Z means OI is above its recent mean. The further above zero, the more \"crowded\" or extended positioning is.\n Negative Z means OI is below its recent mean. Deep negatives often mark post flush environments where leverage has been cleared and the market is under positioned.\n \n\nThe smoothing options help control how much noise you want in the signal:\n \n Short Z score lookback and short smoothing will react quickly, suited for short term traders watching intraday positioning shocks.\n Longer Z score lookback with smoother MA types (EMA, RMA, T3) give a slower, more structural view of where the crowd sits over days to weeks.\n \n\n Divergences between price and OI Z \nThe indicator includes automatic divergence detection on the Z score versus price, using pivot highs and lows:\n \n You configure  Pivot Lookback Left  and  Pivot Lookback Right  to control swing sensitivity.\n Pivots are detected on the OI Z series.\n For each eligible pivot, the script compares OI Z and price at the last two pivots.\n \n\nIt looks for four patterns:\n \n Regular Bullish  ‚Äì price makes a lower low, OI Z makes a higher low. This can indicate selling exhaustion in positioning even as price washes out. These are marked with a line and a label \"‚Ñù\" below the oscillator, in the bullish color.\n Hidden Bullish  ‚Äì price makes a higher low, OI Z makes a lower low. This suggests continuation potential where price holds up while positioning resets. Marked with \"‚Ñç\" in the bullish color.\n Regular Bearish  ‚Äì price makes a higher high, OI Z makes a lower high. This is a classic warning sign of trend exhaustion, where price pushes higher while OI Z fails to confirm. Marked with \"‚Ñù\" in the bearish color.\n Hidden Bearish  ‚Äì price makes a lower high, OI Z makes a higher high. This is often seen in pullbacks within downtrends, where price retraces but positioning stretches again in the direction of the prevailing move. Marked with \"‚Ñç\" in the bearish color.\n \n\nEach divergence type can be toggled globally via  Show Detected Divergences . Internally, the script restricts how far back it will connect pivots, so you do not get stray signals linking very old structures to current bars.\n\n Trading applications \n\n Crowding and squeeze risk \nZ scores are a natural way to talk about crowding:\n \n High positive Z in aggregated OI means the market is running high leverage compared to its own norm. If price is also extended, the risk of a squeeze or sharp unwind rises.\n Deep negative Z means leverage has been cleaned out. While it can be painful to sit through, this environment often sets up cleaner new trends, since there is less one sided positioning to unwind.\n The extreme bands at ¬±3 to ¬±4 highlight the rare states where crowding is most intense. You can treat these events as regime markers rather than day to day noise.\n \n\n Trend confirmation and fade selection \nCombine Z score with price and trend:\n \n Bull trends with positive and rising Z are supported by fresh leverage, usually more persistent.\n Bull trends with flat or falling Z while price keeps grinding up can be more fragile. Divergences and extreme bands can help identify which edges you do not want to fade and which you might.\n In downtrends, deep negative Z that stays pinned can mean persistent de risking. Once the Z score starts to mean revert back toward zero, it can mark the early stages of stabilization.\n \n\n Event and liquidation context \nAround major events, you often see:\n \n Rapid spikes in Z as traders rush to position.\n Reversal and overshoot as liquidations and forced de risking clear the book.\n A move from positive extremes through zero into negative extremes as the market transitions from crowded to under exposed.\n \n\nThe Z score makes that path obvious, especially in oscillator mode, where you see a block of high positive bars before the crash, then a slab of deep negative bars after the flush.\n\n Settings overview \n\n Z Score group \n \n Plotting Type  ‚Äì None, Line, Colored Line, Oscillator.\n Z Score Lookback Period  ‚Äì window used for mean and standard deviation on aggregated OI.\n Smoothing Type  ‚Äì SMA, HMA, EMA, WMA, DEMA, RMA, linear regression, ALMA, TEMA or T3.\n Smoothing Period  ‚Äì length for the selected moving average on the raw Z score.\n \n\n Moving Average group \n \n Show EMA  ‚Äì toggle EMA overlay on Z score.\n EMA Period  ‚Äì EMA length for the signal line.\n EMA Color  ‚Äì color of the EMA line.\n \n\n Thresholds and Reference Lines group \n \n Select Reference Lines  ‚Äì None, Standard Deviation Levels, Extreme Bands.\n Standard deviation lines at 0, ¬±1, ¬±2 appear in both modes.\n Extreme bands add filled zones at ¬±3 to ¬±4 with adaptive opacity tied to |Z|.\n \n\n Extra Plotting and UI \n \n Base Line Color  ‚Äì default color for the simple line mode.\n Line Width  ‚Äì thickness of the oscillator line.\n Positive Color  ‚Äì positive or bullish condition color.\n Negative Color  ‚Äì negative or bearish condition color.\n \n\n Divergences group \n \n Show Detected Divergences  ‚Äì master toggle for divergence plotting.\n Pivot Lookback Left  and  Pivot Lookback Right  ‚Äì how many bars left and right to define a pivot, controlling divergence sensitivity.\n \n\n Open Interest Source group \n \n OI Units  ‚Äì COIN or USD.\n Exchange toggles for Binance, Bybit, OKX, Bitget, Kraken, HTX, Deribit.\n Internally, all enabled exchanges and contract suffixes are aggregated into one synthetic OI series.\n \n\n Alerts included \nThe indicator defines alert conditions for several key events:\n \n OI Z Score Positive  ‚Äì Z crosses above zero, aggregated OI moves from below mean to above mean.\n OI Z Score Negative  ‚Äì Z crosses below zero, aggregated OI moves from above mean to below mean.\n OI Z Score Enters +2œÉ  ‚Äì Z enters the +2 band and above, marking extended positive positioning.\n OI Z Score Enters ‚àí2œÉ  ‚Äì Z enters the ‚àí2 band and below, marking extended negative positioning.\n \n\nTie these into your strategy to be notified when leverage moves from normal to extended states.\n\n Notes \nThis indicator does not rely on price based oscillators. It is a statistical lens on cross venue open interest, which makes it a complementary tool rather than a replacement for your existing price or volume signals. Use it to:\n \n Quantify how unusual current futures positioning is compared to recent history.\n Identify crowded leverage phases that can fuel squeezes.\n Spot structural divergences between price and positioning.\n Frame risk and opportunity around events and regime shifts.\n \n\nIt is not a complete trading system. Combine it with your own entries, exits and risk rules to get the most out of what the Z score is telling you about positioning pressure under the hood of the market.\n",
    "author_name": "BackQuant",
    "likes_count": 356,
    "comments_count": 1,
    "views_count": 0,
    "created_at": "2025-12-11T04:53:44+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "INDEX:ETHUSD",
      "full_name": "INDEX:ETHUSD",
      "short_name": "ETHUSD",
      "exchange": "INDEX",
      "type": "index",
      "logo_id": null,
      "currency_logo_id": "country/US",
      "base_currency_logo_id": "crypto/XTVCETH",
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/crypto/XTVCETH.svg"
      ],
      "interval": "30",
      "direction": 0,
      "badge": {
        "label": "INDEX:ETHUSD",
        "url": "/symbols/ETHUSD/"
      }
    },
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "// This Pine Script¬Æ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// ¬© BackQuant\r\n// Aggregated OI logic adapted from \"Crypto OI Agregated\" by NoveltyTrade, ¬© NoveltyTrade\r\n// https://www.tradingview.com/script/1z6RXBA9-crypto-oi-agregated/\r\n\r\nimport TradingView/ta/11 as ta \r\n\r\n//@version=6\r\nindicator(\"Aggregated Open Interest Z-Score [BackQuant]\",\"Agg. OI Z [BackQuant]\",overlay=false)\r\n\r\n// Groups\r\nconst string grpZS  = \"Z-Score\"\r\nconst string grpMA  = \"Moving Average\"\r\nconst string grpThr = \"Thresholds & Reference Lines\"\r\nconst string grpUI  = \"Extra Plotting and UI\"\r\nconst string grpDiv = \"Divergences\"\r\nconst string grpOI  = \"Open Interest Source\"\r\n\r\n// Inputs\r\n\r\n// Z-Score\r\nstring plotting = input.string(\"Oscillator\",\"Plotting Type\",options=[\"None\",\"Line\",\"Colored Line\",\"Oscillator\"],group=grpZS,tooltip=\"Select how to render the OI Z-Score on the panel.\")\r\nint z_len = input.int(100,\"Z-Score Lookback Period\",group=grpZS,tooltip=\"Lookback period used to compute mean and standard deviation of aggregated OI.\")\r\nstring maType = input.string(\"EMA\", \"Smoothing Type\",options = [\"SMA\", \"HMA\", \"EMA\", \"WMA\", \"DEMA\", \"RMA\", \"LINREG\", \"ALMA\", \"TEMA\", \"T3\"], group =grpZS,inline=\"smooth\")\r\nsimple int smooth_len = input.int(5, \"Smoothing Period\", group = grpZS, inline=\"smooth\")\r\n\r\n// Moving Average\r\nbool show_ma = input.bool(true,\"Show EMA\",group=grpMA,tooltip=\"Toggle the EMA overlay on the OI Z-Score.\",inline=\"ema\")\r\nint ma_p = input.int(21,\"EMA Period\",group=grpMA,tooltip=\"EMA length applied to the OI Z-Score.\",inline=\"ema\")\r\ncolor ma_col = input.color(#ffffff,\"EMA Color\",group=grpMA,inline=\"ema\")\r\n\r\n// Thresholds & Reference Lines\r\nstring show_refs = input.string(\"Extreme Bands\",\"Select Reference Lines\",options=[\"None\",\"Standard Deviation Levels\",\"Extreme Bands\"],group=grpThr,tooltip=\"Control whether to show standard deviation levels or extreme bands.\")\r\n\r\n// Extra Plotting and UI\r\ncolor zs_col = input.color(#ffffff,\"Base Line Color\",group=grpUI)\r\nint lw = input.int(1,\"Line Width\",minval=1,maxval=5,group=grpUI)\r\ncolor long_col = input.color(#00ff00,\"Positive Color\",group=grpUI)\r\ncolor short_col = input.color(#ff0000,\"Negative Color\",group=grpUI)\r\n\r\n// Divergences\r\nbool showdivergences = input.bool(true,\"Show Detected Divergences?\",group=grpDiv)\r\nint lbR = input.int(30,\"Pivot Lookback Right\",group=grpDiv,inline=\"div\")\r\nint lbL = input.int(30,\"Pivot Lookback Left\",group=grpDiv,inline=\"div\")\r\n\r\n// Open Interest Source\r\nstring typ2 = input.string(\"COIN\",\"OI Units\",options=[\"USD\",\"COIN\"],group=grpOI,tooltip=\"Choose whether to aggregate OI in coin terms or converted to USD.\")\r\nbool ex1 = input.bool(true,\"Binance\",group=grpOI,inline=\"cexs\")\r\nbool ex2 = input.bool(true,\"Bybit\",group=grpOI,inline=\"cexs\")\r\nbool ex3 = input.bool(true,\"OKX\",group=grpOI,inline=\"cexs\")\r\nbool ex5 = input.bool(true,\"Bitget\",group=grpOI,inline=\"cexs\")\r\nbool ex6 = input.bool(true,\"Kraken\",group=grpOI,inline=\"cexs\")\r\nbool ex7 = input.bool(true,\"HTX\",group=grpOI,inline=\"cexs\")\r\nbool ex8 = input.bool(true,\"Deribit\",group=grpOI,inline=\"cexs\")\r\n\r\n// OI aggregation\r\ntype OI\r\n    float o\r\n    float h\r\n    float l\r\n    float c\r\n\r\nconst string[] exchanges = array.from(\r\n ex1 ? \"Binance\" : na,\r\n ex2 ? \"Bybit\"   : na,\r\n ex3 ? \"OKX\"     : na,\r\n ex5 ? \"Bitget\"  : na,\r\n ex6 ? \"Kraken\"  : na,\r\n ex7 ? \"HTX\"     : na,\r\n ex8 ? \"Deribit\" : na\r\n )\r\n\r\nconst string[] appendixes = array.from(\"USDT.P\",\"USD.P\",\"USDC.P\",\"USD.PM\")\r\nconst int bars = 10000\r\n\r\nmethod sw(float _v,string _ex,string _app) =>\r\n    float _tmp = (\r\n     (_app == \"USD.P\" and (_ex == \"Binance\" or _ex == \"Bybit\" or _ex == \"Kraken\")) or\r\n     _ex == \"OKX\" or _ex == \"Deribit\"\r\n     ) ? _v * (_ex == \"Binance\" ? (syminfo.basecurrency == \"BTC\" ? 100 : 10) : 1) / close : _v\r\n    typ2 == \"USD\" ? _tmp * close : _tmp\r\n\r\nOI candle = OI.new(0.0,0.0,0.0,0.0)\r\n\r\nfor [i, ex] in exchanges\r\n    if not na(ex)\r\n        for [j, app] in appendixes\r\n            OI oi_ex = request.security(ex + \":\" + syminfo.basecurrency + app + \"_OI\",\"\",OI.new(open,high,low,close),ignore_invalid_symbol=true,calc_bars_count=bars)\r\n            if not na(oi_ex)\r\n                float o_conv = oi_ex.o.sw(ex,app)\r\n                float h_conv = oi_ex.h.sw(ex,app)\r\n                float l_conv = oi_ex.l.sw(ex,app)\r\n                float c_conv = oi_ex.c.sw(ex,app)\r\n                candle.o += o_conv\r\n                candle.h += h_conv\r\n                candle.l += l_conv\r\n                candle.c += c_conv\r\n\r\nfloat oiClose = candle.c\r\n\r\nif barstate.islastconfirmedhistory and na(oiClose)\r\n    runtime.error(str.format(\"No aggregated Open Interest data for `{0}`.\",syminfo.prefix + \":\" + syminfo.ticker))\r\n\r\n// Helper MA Func\r\nma(src, len, type) =>\r\n    switch type\r\n        \"SMA\" => ta.sma(src, len)\r\n        \"HMA\" => ta.hma(src, len)\r\n        \"EMA\" => ta.ema(src, len)\r\n        \"WMA\" => ta.wma(src, len)\r\n        \"DEMA\" => ta.dema(src, len)\r\n        \"RMA\" => ta.rma(src, len)\r\n        \"LINREG\"=> ta.linreg(src, len, 0)\r\n        \"TEMA\" => ta.tema(src, len)\r\n        \"ALMA\" => ta.alma(src, len, 0, 6)\r\n        \"T3\" => ta.t3(src,len, 0.7)\r\n\r\n// Z-Score calculations on aggregated OI\r\nfloat subject = oiClose\r\nfloat mean = ta.ema(subject,z_len)\r\nfloat stdDev = ta.stdev(subject,z_len)\r\nfloat oi_z = ma((subject - mean) / stdDev, smooth_len, maType)\r\nfloat ma = ta.ema(oi_z,ma_p)\r\n\r\n// Mode flags\r\nbool isLine = plotting == \"Line\"\r\nbool isColLine = plotting == \"Colored Line\"\r\nbool isOsc = plotting == \"Oscillator\"\r\nbool show_ma_ = show_ma and (isLine or isColLine or isOsc)\r\n\r\n// Conditional color (same logic as LSMA Z-Score)\r\nbool posroc = oi_z > oi_z[1]\r\nbool negroc = oi_z < oi_z[1]\r\ncolor col = zs_col\r\nif oi_z > 0 and posroc\r\n    col := #00ff08\r\nif oi_z > 0 and negroc\r\n    col := #00bbd4\r\nif oi_z < 0 and negroc\r\n    col := #ff0000\r\nif oi_z < 0 and posroc\r\n    col := #771515\r\n\r\n// Base plots by plotting type\r\nplot(isLine ? oi_z : na,\"OI Z-Score Line\",color=zs_col,linewidth=lw)\r\nplot(isColLine ? oi_z : na,\"OI Z-Score Colored Line\",color=col,linewidth=lw)\r\nplot(isOsc ? oi_z : na,\"OI Z-Score Oscillator\",style=plot.style_columns,color=col,histbase=0)\r\nplot(show_ma_ ? ma : na,\"OI Z-Score EMA\",color=ma_col,linewidth=1)\r\n\r\n// Reference lines: standard deviation levels\r\nplotchar(show_refs == \"Standard Deviation Levels\" ? 0 : na,\"0\",\"‚Ä¢\",location.absolute,size=size.tiny,color=#8080804d)\r\nplot(show_refs == \"Standard Deviation Levels\" or show_refs == \"Extreme Bands\" ? 1 : na,\"1\",#8080804d,style=plot.style_linebr)\r\nplot(show_refs == \"Standard Deviation Levels\" or show_refs == \"Extreme Bands\" ? 2 : na,\"2\",#8080804d,style=plot.style_linebr)\r\nplot(show_refs == \"Standard Deviation Levels\" or show_refs == \"Extreme Bands\" ? -1 : na,\"-1\",#8080804d,style=plot.style_linebr)\r\nplot(show_refs == \"Standard Deviation Levels\" or show_refs == \"Extreme Bands\" ? -2 : na,\"-2\",#8080804d,style=plot.style_linebr)\r\n\r\n// Adaptive Trend Strength and extreme bands (reference line method)\r\nfloat trendStrength = math.abs(oi_z)\r\nfloat maxStrength = 4.5\r\nfloat normalizedStrength = math.min(trendStrength / maxStrength * 100.0,100.0)\r\nint alphaValue = int(100.0 - normalizedStrength)\r\n\r\nplot(show_refs == \"Extreme Bands\" ? 1 : na,\"1\",#8080804d,style=plot.style_linebr)\r\nplot(show_refs == \"Extreme Bands\" ? 2 : na,\"2\",#8080804d,style=plot.style_linebr)\r\nplot(show_refs == \"Extreme Bands\" ? -1 : na,\"-1\",#8080804d,style=plot.style_linebr)\r\nplot(show_refs == \"Extreme Bands\" ? -2 : na,\"-2\",#8080804d,style=plot.style_linebr)\r\n\r\n// Upper Extreme Levels\r\nu1 = plot(show_refs == \"Extreme Bands\" ? 4.0 : na,\"Upper\",color=#787b864d,editable=false)\r\nu2 = plot(show_refs == \"Extreme Bands\" ? 3.0 : na,\"Upper Inner\",color=#787b864d,editable=false)\r\nfill(u1,u2,show_refs == \"Extreme Bands\" ? (oi_z >= 0.0 ? color.new(color.rgb(255,0,0),alphaValue) : color.rgb(255,255,255,100)) : color.new(color.white,100),\"Extreme Upper\")\r\n\r\n// Lower Extreme Levels\r\nl1 = plot(show_refs == \"Extreme Bands\" ? -4.0 : na,\"Lower\",color=#787b864d,editable=false)\r\nl2 = plot(show_refs == \"Extreme Bands\" ? -3.0 : na,\"Lower Inner\",color=#787b864d,editable=false)\r\nfill(l1,l2,show_refs == \"Extreme Bands\" ? (oi_z < 0.0 ? color.new(color.rgb(0,255,0),alphaValue) : color.rgb(255,255,255,100)) : color.new(color.white,100),\"Extreme Lower\")\r\n\r\n\r\n// Divergences (on OI Z-Score)\r\ncolor obcol = #ff0000fc\r\ncolor oscol = #00ff00fc\r\ncolor bearColor = obcol\r\ncolor bullColor = oscol\r\ncolor hiddenBullColor = color.new(oscol,50)\r\ncolor hiddenBearColor = color.new(obcol,50)\r\ncolor textColor = color.white\r\ncolor noneColor = color.new(color.white,100)\r\n\r\nbool plFound = not na(ta.pivotlow(oi_z,lbL,lbR))\r\nbool phFound = not na(ta.pivothigh(oi_z,lbL,lbR))\r\n\r\n_inRange(bool cond) =>\r\n    int barsBack = ta.barssince(cond)\r\n    -80 <= barsBack and barsBack <= 80\r\n\r\n// Regular Bullish: price LL, osc HL\r\nbool oscHL = oi_z[lbR] > ta.valuewhen(plFound,oi_z[lbR],1) and _inRange(plFound[1])\r\nbool priceLL = low[lbR] < ta.valuewhen(plFound,low[lbR],1)\r\nbool bullCond = showdivergences and priceLL and oscHL and plFound\r\n\r\nplot(plFound ? oi_z[lbR] : na,offset=-lbR,title=\"Regular Bullish\",linewidth=2,color=bullCond ? bullColor : noneColor)\r\nplotshape(bullCond ? oi_z[lbR] : na,offset=-lbR,title=\"Regular Bullish Label\",text=\"‚Ñù\",style=shape.labelup,location=location.absolute,color=bullColor,textcolor=textColor)\r\n\r\n// Hidden Bullish: price HL, osc LL\r\nbool oscLL = oi_z[lbR] < ta.valuewhen(plFound,oi_z[lbR],1) and _inRange(plFound[1])\r\nbool priceHL = low[lbR] > ta.valuewhen(plFound,low[lbR],1)\r\nbool hiddenBullCond = showdivergences and priceHL and oscLL and plFound\r\n\r\nplot(plFound ? oi_z[lbR] : na,offset=-lbR,title=\"Hidden Bullish\",linewidth=2,color=hiddenBullCond ? hiddenBullColor : noneColor)\r\nplotshape(hiddenBullCond ? oi_z[lbR] : na,offset=-lbR,title=\"Hidden Bullish Label\",text=\"‚Ñç\",style=shape.labelup,location=location.absolute,color=bullColor,textcolor=textColor)\r\n\r\n// Regular Bearish: price HH, osc LH\r\nbool oscLH = oi_z[lbR] < ta.valuewhen(phFound,oi_z[lbR],1) and _inRange(phFound[1])\r\nbool priceHH = high[lbR] > ta.valuewhen(phFound,high[lbR],1)\r\nbool bearCond = showdivergences and priceHH and oscLH and phFound\r\n\r\nplot(phFound ? oi_z[lbR] : na,offset=-lbR,title=\"Regular Bearish\",linewidth=2,color=bearCond ? bearColor : noneColor)\r\nplotshape(bearCond ? oi_z[lbR] : na,offset=-lbR,title=\"Regular Bearish Label\",text=\"‚Ñù\",style=shape.labeldown,location=location.absolute,color=bearColor,textcolor=textColor)\r\n\r\n// Hidden Bearish: price LH, osc HH\r\nbool oscHH = oi_z[lbR] > ta.valuewhen(phFound,oi_z[lbR],1) and _inRange(phFound[1])\r\nbool priceLH = high[lbR] < ta.valuewhen(phFound,high[lbR],1)\r\nbool hiddenBearCond = showdivergences and priceLH and oscHH and phFound\r\n\r\nplot(phFound ? oi_z[lbR] : na,offset=-lbR,title=\"Hidden Bearish\",linewidth=2,color=hiddenBearCond ? hiddenBearColor : noneColor)\r\nplotshape(hiddenBearCond ? oi_z[lbR] : na,offset=-lbR,title=\"Hidden Bearish Label\",text=\"‚Ñç\",style=shape.labeldown,location=location.absolute,color=bearColor,textcolor=textColor)\r\n\r\n\r\n// Alerts\r\nalertcondition(ta.crossover(oi_z,0.0),\"OI Z-Score Positive\",\"Aggregated OI Z-Score crossed above 0 on {{exchange}}:{{ticker}}\")\r\nalertcondition(ta.crossunder(oi_z,0.0),\"OI Z-Score Negative\",\"Aggregated OI Z-Score crossed below 0 on {{exchange}}:{{ticker}}\")\r\nalertcondition(ta.crossover(oi_z,2.0),\"OI Z-Score Enters +2œÉ\",\"Aggregated OI Z-Score entered +2œÉ on {{exchange}}:{{ticker}}\")\r\nalertcondition(ta.crossunder(oi_z,-2.0),\"OI Z-Score Enters -2œÉ\",\"Aggregated OI Z-Score entered -2œÉ on {{exchange}}:{{ticker}}\")\r\n"
  },
  "https://www.tradingview.com/script/hOkqy6JB/": {
    "id": 20088386,
    "url": "https://www.tradingview.com/script/hOkqy6JB/",
    "name": "Momentum Candle V3 by Sekolah Trading",
    "description": "Momentum Candle v3 by Sekolah Trading\n\nDescription:\n\nMomentum Candle v3 is a technical indicator designed to identify market momentum signals based on price movement within a single candle. The indicator measures the size of the candle's body and wick to determine if the market is showing strong bullish or bearish momentum.\n\nKey Features:\n\nCandle Size: Measures price movement within a single candle to assess market momentum.\n\nShort Wick: Focuses on wick length, with short wicks indicating that the closing price is more significant than the opening price.\n\nBullish/Bearish Momentum: Provides bullish signals when the closing price is higher than the open, and bearish signals when the closing price is lower than the open.\n\nCustomizable Minimum Body: Users can adjust the minimum body size for XAUUSD and USDJPY pairs according to their trading preferences.\n\nTimeframe: Works on M5 and M15 timeframes for XAUUSD and USDJPY currency pairs.\n\nHow to Use:\n\nBullish Signal: The indicator signals bullish momentum when the candle body is sufficiently large and the wick is short, with the closing price higher than the open.\n\nBearish Signal: The indicator signals bearish momentum when the candle body is sufficiently large and the wick is short, with the closing price lower than the open.\n\nPip Parameters: Adjust the pip values for XAUUSD and USDJPY according to market conditions or your trading preferences.\n\nNote: This indicator is a tool for technical analysis and does not guarantee specific trading results. It is recommended to use it alongside other strategies and analyses for better accuracy.\n\nRealistic Backtest Results:\n\nTo ensure transparency and honesty in the backtest, here are some key factors to consider:\n\nPosition Size: The backtest uses a realistic position size of about 5-10% of the account equity per trade.\n\nCommission & Slippage: A commission of 0.1% per trade and slippage of 1 pip were used in the backtest simulation to reflect real market conditions.\n\nNumber of Trades: The backtest sample includes more than 100 trades for a representative result.\n\nExample of Backtest Results:\n\nProfitability: The backtest results on XAUUSD and USDJPY show consistent performance with this strategy on the M5 and M15 timeframes.\n\nCommission and Slippage: Adjusting for commission and slippage showed better accuracy under more realistic market scenarios.\n\nHow to Use the Indicator:\n\nSignals from this indicator can be used to confirm market momentum in trending conditions. However, it is highly recommended to combine this indicator with other technical analysis tools to minimize the risk of false signals.\n\nImportant Notes:\n\nHonesty & Transparency: This indicator is designed to provide signals based on technical analysis and does not guarantee specific trading results.\n\nNo Over-Claims: The backtest results displayed represent realistic scenarios and are not intended to promise certain profits.\n\nOriginal Content: The code for this indicator is original and does not violate any copyrights.\n\nTagging:\n\nSmart Tags: Momentum, Candle, XAUUSD, USDJPY, Bullish, Bearish, M5, M15, Technical Indicator, Market Momentum.\n\n",
    "author_name": "sekolah_trading",
    "likes_count": 180,
    "comments_count": 0,
    "views_count": 0,
    "created_at": "2025-12-12T03:59:25+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "OANDA:XAUUSD",
      "full_name": "OANDA:XAUUSD",
      "short_name": "XAUUSD",
      "exchange": "OANDA",
      "type": "commodity",
      "logo_id": "metal/gold",
      "currency_logo_id": "country/US",
      "base_currency_logo_id": null,
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/metal/gold.svg"
      ],
      "interval": "5",
      "direction": 0,
      "badge": {
        "label": "OANDA:XAUUSD",
        "url": "/symbols/XAUUSD/"
      }
    },
    "created": "2025-12-12",
    "updated": "2025-12-12",
    "source": "//@version=5\r\nindicator(\"Momentum Candle V3 by Sekolah Trading\", overlay=true)\r\n\r\n// ===== Pair & TF =====\r\nisGold = syminfo.ticker == \"XAUUSD\"\r\nisJpy  = syminfo.ticker == \"USDJPY\"\r\ntf     = timeframe.period\r\nisM5   = tf == \"5\"\r\nisM15  = tf == \"15\"\r\n\r\n// ===== Pip size =====\r\npipXAU = 0.1      // 1 pip XAU ‚âà 0.1 price\r\npipJPY = 0.01     // 1 pip JPY ‚âà 0.01 price\r\n\r\n// ===== Inputs (pip) =====\r\n// 0 = gunakan default auto (XAU: 35/45 pip; JPY: 10/15 pip)\r\ngrpXAU = \"XAUUSD Minimum Body (pip)\"\r\nxau_m5  = input.float(40, \"XAUUSD M5\",  group=grpXAU, minval=0)\r\nxau_m15 = input.float(50, \"XAUUSD M15\", group=grpXAU, minval=0)\r\n\r\ngrpJPY = \"USDJPY Minimum Body (pip)\"\r\njpy_m5  = input.float(7,  \"USDJPY M5\",  group=grpJPY, minval=0)\r\njpy_m15 = input.float(10, \"USDJPY M15\", group=grpJPY, minval=0)\r\n\r\n// ===== Helper: konversi pip -> price =====\r\ntoPrice(pips, pipSize) => pips * pipSize\r\n\r\n// ===== Tentukan minRange (hanya M5/M15) =====\r\nfloat minRange = na\r\n\r\nif isGold and (isM5 or isM15)\r\n    defPip = isM5 ? 35.0 : 45.0\r\n    usePip = isM5 ? (xau_m5 > 0 ? xau_m5 : defPip) : (xau_m15 > 0 ? xau_m15 : defPip)\r\n    minRange := toPrice(usePip, pipXAU)\r\n\r\nif isJpy and (isM5 or isM15)\r\n    defPip = isM5 ? 10.0 : 15.0\r\n    usePip = isM5 ? (jpy_m5 > 0 ? jpy_m5 : defPip) : (jpy_m15 > 0 ? jpy_m15 : defPip)\r\n    minRange := toPrice(usePip, pipJPY)\r\n\r\n// ===== Struktur candle (body only) =====\r\ntotalRange = math.abs(close - open)\r\nupperWick  = high - math.max(open, close)\r\nlowerWick  = math.min(open, close) - low\r\ntotalWick  = upperWick + lowerWick\r\n\r\n// ===== Validasi momentum (aktif hanya jika minRange ada) =====\r\nisActive    = not na(minRange)\r\nisBigCandle = isActive and totalRange >= minRange\r\nisWickShort = isActive and (totalWick / (totalRange + totalWick)) <= 0.3\r\nisBullish   = isActive and close > open\r\nisBearish   = isActive and (close < open or (close > open and close < open[1]))\r\nshowSignal  = isActive and isBigCandle and isWickShort and (isBullish or isBearish)\r\n\r\n// ===== Plot =====\r\nplotshape(showSignal and isBullish, location=location.belowbar, style=shape.triangleup,   color=color.new(color.blue, 0), size=size.small, title=\"Bull Momentum\")\r\nplotshape(showSignal and isBearish, location=location.abovebar, style=shape.triangledown, color=color.new(color.red, 0),  size=size.small, title=\"Bear Momentum\")\r\n\r\n// ===== Alert window: hanya bunyi 20‚Äì90 detik sebelum bar close pada bar belum confirm =====\r\nbarTimeLeft = time_close - timenow                  // ms\r\nalertWindow = isActive and (barTimeLeft <= 90000) and (barTimeLeft >= 20000) and not barstate.isconfirmed\r\n\r\nbullSignal = showSignal and isBullish\r\nbearSignal = showSignal and isBearish\r\n\r\n// ===== Alerts =====\r\nalertcondition(alertWindow and bullSignal, title=\"Momentum Bullish (pre-close 20‚Äì90s)\", message=\"Momentum candle bullish valid ‚Äî XAU/JPY M5/M15\")\r\nalertcondition(alertWindow and bearSignal, title=\"Momentum Bearish (pre-close 20‚Äì90s)\", message=\"Momentum candle bearish valid ‚Äî XAU/JPY M5/M15\")\r\n"
  },
  "https://www.tradingview.com/script/rRoIzEuk-RSI-Multi-Levels-kiawosch-TradingFinder-7-14-42-Consolidation/": {
    "id": 20083785,
    "url": "https://www.tradingview.com/script/rRoIzEuk-RSI-Multi-Levels-kiawosch-TradingFinder-7-14-42-Consolidation/",
    "name": "RSI Multi Levels kiawosch [TradingFinder]  7-14-42 Consolidation",
    "description": "üîµ Introduction \n\nThe Relative Strength Index or RSI is a tool used to measure the speed and intensity of price movement, oscillating between zero and one hundred. It is commonly applied to identify strength or weakness in market momentum across different time intervals. Despite its simple formula and wide usage, the behavior of RSI within specific ranges often provides more precise information than traditional overbought and oversold levels.\n\nThe Multi RSI layout displays three RSI values with periods 7, 14 and 42. The seven period RSI plays the primary role in short term analysis. When this value enters predefined ranges, it shows highly consistent and interpretable behavior that can signal trend continuation, corrections or the start of a range structure. The other two values, RSI 14 and RSI 42, help reveal higher timeframe momentum and provide context for the depth and quality of price movement.\n\n Three potential zones are defined, each representing a behavioral range. The position zones forms the basis for signal interpretation :\n\n \n High Potential : 78 to 85 & 22 to 15\n Mid Potential : 70 to 78 & 30 to 22\n Low Potential : 58 to 62 & 42 to 38\n \n\n  \n\nThese zones highlight areas where RSI reacts in specific ways to price movement. Entering the High Potential range usually aligns with new highs or lows in price and often precedes continuation after a correction. In contrast, reactions inside the Mid Potential range frequently appear during clean ranges or channel structures. This approach focuses on momentum quality and structural behavior rather than classic overbought and oversold thresholds.\n\n In summary, the logic behind the signals follows three principles :\n\n \n Trend continuation, When RSI 7 enters the High Potential zone and price prints a new high or low, continuation after a correction becomes the most likely outcome.\n  \n\n  \n\n Reversal or slowdown, When RSI exits the High Potential zone while price is reaching a previous high or low, the probability of a short term reversal increases.\n  \n\n Range behavior, In clean ranges or channel structures, RSI 7 typically reacts inside the Mid Potential zone and produces consistent swing responses.\n \n\nüîµ How to Use \n\nThis method is based on observing the repeating behavior of RSI within momentum zones and identifying moments when price continues after a shallow correction or, conversely, when signs of slowing and reversal appear. RSI 7 plays the main role since it gives the most sensitive response to short term price changes. Its entry into or exit from a potential zone, combined with the position of price relative to recent highs and lows, forms the core of the signal logic. RSI 14 and RSI 42 provide higher timeframe confirmation and help evaluate the broader strength or weakness behind each movement.\n\nüü£ Trend continuation after entering the High Potential zone \n\nWhen RSI 7 reaches the High Potential zone while price forms a new high or low, the probability of continuation becomes very high. The typical sequence includes a short correction in price and a retreat of RSI toward the Mid Potential zone. As long as price structure remains intact and RSI turns upward again, continuation becomes the most likely scenario. As shown in the charts, price often expands strongly after this type of correction and breaks the previous high.\n\n  \n\nüü£ Reversal or slowdown after exiting the High Potential zone \n\nIf RSI 7 enters the High Potential zone but then exits while price is interacting with a previous high or low, conditions for a short term reversal appear. This behavior is clear in the charts, where price hits a supply or demand area and RSI can no longer return to the upper zone. The drop in RSI reflects weakening momentum and, when accompanied by a confirming candle, increases the chance of a reversal or at least a temporary pause.\n\n  \n\nüü£ Strong reversal after hitting the Mid Potential zone during deeper corrections \n\nSometimes price enters a deeper corrective phase and RSI 7 moves into or through the Mid Potential zone. When this occurs near a previous low, it can mark the start of a significant reversal. The charts show this pattern clearly, where RSI turns upward while price reacts to support. If the other RSI values show relative alignment, the probability of a strong rebound increases. This signal is often seen after fast declines and can mark the beginning of a recovery wave.\n\n  \n\nüü£ Range structure and repetitive reactions inside the Mid Potential zone \n\nWhen price enters a clean range or channel, the behavior of RSI 7 changes completely. In such conditions, RSI repeatedly reacts inside the Mid Potential zone. Each time price touches the upper or lower boundary of the range, RSI approaches the upper or lower part of this zone as well. The result is a sequence of predictable swing reactions, perfectly suitable for mean reversion strategies. Breakouts in these environments also tend to show higher failure rates.\n\n\nüü£ Sharp reactions and fast reversals at extreme levels (RSI near 90 or below 10) \n\nAlthough this approach is not based on classic overbought and oversold logic, extremely high or low RSI readings such as ninety often produce strong immediate reactions in price. These conditions usually occur after sudden spikes or emotional breakouts. As visible in the charts, RSI collapses quickly after reaching such extremes and price often reverses sharply. While not a core signal, these moments add meaningful context to momentum interpretation.\n\n  \n\n\nüîµ Settings \n\n RSI Setting : This section allows enabling or disabling the three RSI values, adjusting their calculation length and customizing their colors. It is designed to help separate short, medium and longer term momentum visually on the chart.\n\n Zones Setting : This section controls the display of momentum zones and the color applied to each area. Adjusting these colors or toggling them on and off helps the trader visually track the intensity and structure of momentum.\n\n Levels Setting : This section allows editing the numeric boundaries of the levels or showing and hiding each one individually. These levels form the visual framework for interpreting RSI behavior within the defined momentum zones.\n\nüîµ Conclusion \n\nExamining RSI behavior across different momentum zones shows that entering these ranges creates relatively consistent patterns in price movement. Reaching the High Potential zone often corresponds to later stages of a trend, where price has the strength to continue after a brief correction and structure remains intact. In contrast, reactions within the Mid Potential zone occur more frequently when the market transitions into a range or a limited movement phase, where repetitive oscillations dominate.\n\nOverall, observing RSI inside these zones helps distinguish between trending movement, corrective phases and range conditions with greater clarity. Entry or exit from each zone provides insight into the underlying strength or weakness of momentum and reveals where the market is positioned within its movement cycle. This perspective, based on momentum regions rather than traditional values alone, offers a more refined understanding of price behavior and highlights the likely direction of the next move.\n\n",
    "author_name": "TFlab",
    "likes_count": 192,
    "comments_count": 2,
    "views_count": 0,
    "created_at": "2025-12-11T09:04:33+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "FX:EURUSD",
      "full_name": "FX:EURUSD",
      "short_name": "EURUSD",
      "exchange": "FX",
      "type": "forex",
      "logo_id": null,
      "currency_logo_id": "country/US",
      "base_currency_logo_id": "country/EU",
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/country/EU.svg",
        "https://s3-symbol-logo.tradingview.com/country/US.svg"
      ],
      "interval": "5",
      "direction": 0,
      "badge": {
        "label": "FX:EURUSD",
        "url": "/symbols/EURUSD/"
      }
    },
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "// This Pine Script¬Æ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// ¬© TFlab\r\n\r\n//@version=6\r\nindicator(\"RSI Multi Levels kiawosch [TradingFinder]  7-14-42 Consolidation\", 'Multi RSI')\r\n\r\n\r\n\r\nShow_Short  = input.bool(true, 'Short RSI', inline = 'Short', group = 'RSI Setting')\r\nLen_Short   = input.int(7, '', inline = 'Short', group = 'RSI Setting')\r\nColor_Short = input.color(color.red, '', inline = 'Short', group = 'RSI Setting')\r\n\r\n\r\nShow_Mid    = input.bool(true, 'Mid  RSI'  , inline = 'Mid', group = 'RSI Setting')\r\nLen_Mid     = input.int(14, '', inline = 'Mid', group = 'RSI Setting')\r\nColor_Mid   = input.color(color.orange, '', inline = 'Mid', group = 'RSI Setting')\r\n\r\n\r\nShow_Long   = input.bool(true, 'Long  RSI' , inline = 'Long', group = 'RSI Setting')\r\nLen_Long     = input.int(42, '', inline = 'Long', group = 'RSI Setting')\r\nColor_Long  = input.color(color.green, '', inline = 'Long', group = 'RSI Setting')\r\n\r\n\r\nShow_LP  = input.bool(true, 'Low Potential Zone', inline = 'Lp', group = 'Zones Setting')\r\nColor_LP = input.color(#2e10d783, '' , inline = 'Lp', group = 'Zones Setting')\r\n\r\nShow_MP  = input.bool(true, 'Mid Potential Zone', inline = 'MP', group = 'Zones Setting')\r\nColor_MP = input.color(#ffc13c52, '' , inline = 'MP', group = 'Zones Setting')\r\n\r\nShow_HP  = input.bool(true, 'High Potential Zone', inline = 'HP', group = 'Zones Setting')\r\nColor_HP = input.color(#10d7d44b, '' , inline = 'HP', group = 'Zones Setting')\r\n\r\n\r\nShow_Lvl_1 = input.bool(true, 'Level 1', inline = 'Lvl 1', group = 'Levels Setting')\r\nLvl_1      = input.int(10, '', inline = 'Lvl 1', group = 'Levels Setting')\r\n\r\nShow_Lvl_2 = input.bool(true, 'Level 2', inline = 'Lvl 2', group = 'Levels Setting')\r\nLvl_2      = input.int(15, '', inline = 'Lvl 2', group = 'Levels Setting')\r\n\r\nShow_Lvl_3 = input.bool(true, 'Level 3', inline = 'Lvl 3', group = 'Levels Setting')\r\nLvl_3      = input.int(22, '', inline = 'Lvl 3', group = 'Levels Setting')\r\n\r\nShow_Lvl_4 = input.bool(true, 'Level 4', inline = 'Lvl 4', group = 'Levels Setting')\r\nLvl_4      = input.int(30, '', inline = 'Lvl 4', group = 'Levels Setting')\r\n\r\nShow_Lvl_5 = input.bool(true, 'Level 5', inline = 'Lvl 5', group = 'Levels Setting')\r\nLvl_5      = input.int(38, '', inline = 'Lvl 5', group = 'Levels Setting')\r\n\r\nShow_Lvl_6 = input.bool(true, 'Level 6', inline = 'Lvl 6', group = 'Levels Setting')\r\nLvl_6      = input.int(42, '', inline = 'Lvl 6', group = 'Levels Setting')\r\n\r\nShow_Lvl_7 = input.bool(true, 'Level 7', inline = 'Lvl 7', group = 'Levels Setting')\r\nLvl_7      = input.int(50, '', inline = 'Lvl 7', group = 'Levels Setting')\r\n\r\nShow_Lvl_8 = input.bool(true, 'Level 8', inline = 'Lvl 8', group = 'Levels Setting')\r\nLvl_8      = input.int(58, '', inline = 'Lvl 8', group = 'Levels Setting')\r\n\r\nShow_Lvl_9 = input.bool(true, 'Level 9', inline = 'Lvl 9', group = 'Levels Setting')\r\nLvl_9      = input.int(62, '', inline = 'Lvl 9', group = 'Levels Setting')\r\n\r\nShow_Lvl_10 = input.bool(true, 'Level 10', inline = 'Lvl 10', group = 'Levels Setting')\r\nLvl_10      = input.int(70, '', inline = 'Lvl 10', group = 'Levels Setting')\r\n\r\nShow_Lvl_11 = input.bool(true, 'Level 11', inline = 'Lvl 11', group = 'Levels Setting')\r\nLvl_11      = input.int(78, '', inline = 'Lvl 11', group = 'Levels Setting')\r\n\r\nShow_Lvl_12 = input.bool(true, 'Level 12', inline = 'Lvl 12', group = 'Levels Setting')\r\nLvl_12      = input.int(85, '', inline = 'Lvl 12', group = 'Levels Setting')\r\n\r\nShow_Lvl_13 = input.bool(true, 'Level 13', inline = 'Lvl 13', group = 'Levels Setting')\r\nLvl_13      = input.int(90, '', inline = 'Lvl 13', group = 'Levels Setting')\r\n\r\n\r\nRSI_Short = ta.rsi(close, Len_Short)\r\nRSI_Mid   = ta.rsi(close, Len_Mid)\r\nRSI_Long  = ta.rsi(close, Len_Long)\r\n\r\n\r\nplot(RSI_Short, 'Short RSI', color = Color_Short, linewidth = 2, display = Show_Short ? display.all : display.none)\r\nplot(RSI_Mid  , 'Middle RSI', color = Color_Mid  , linewidth = 2, display = Show_Mid   ? display.all : display.none)\r\nplot(RSI_Long , 'Long RSI', color = Color_Long , linewidth = 2, display = Show_Long  ? display.all : display.none)\r\n\r\n// hline(0, linestyle = hline.style_dashed)\r\nhline(Lvl_1, linestyle = hline.style_dashed, display = Show_Lvl_1 ? display.all : display.none)\r\na = hline(Lvl_2, linestyle = hline.style_dashed, display = Show_Lvl_2 ? display.all : display.none)\r\nb = hline(Lvl_3, linestyle = hline.style_dashed, display = Show_Lvl_3 ? display.all : display.none)\r\nc = hline(Lvl_4, linestyle = hline.style_dashed, display = Show_Lvl_4 ? display.all : display.none)\r\nd = hline(Lvl_5, linestyle = hline.style_dashed, display = Show_Lvl_5 ? display.all : display.none)\r\ne = hline(Lvl_6, linestyle = hline.style_dashed, display = Show_Lvl_6 ? display.all : display.none)\r\nhline(Lvl_7, linestyle = hline.style_dashed, color = color.red, display = Show_Lvl_7 ? display.all : display.none)\r\nf = hline(Lvl_8, linestyle = hline.style_dashed, display = Show_Lvl_8 ? display.all : display.none)\r\ng = hline(Lvl_9, linestyle = hline.style_dashed, display = Show_Lvl_9 ? display.all : display.none)\r\nh = hline(Lvl_10, linestyle = hline.style_dashed, display = Show_Lvl_10 ? display.all : display.none)\r\ni = hline(Lvl_11, linestyle = hline.style_dashed, display = Show_Lvl_11 ? display.all : display.none)\r\nj = hline(Lvl_12, linestyle = hline.style_dashed, display = Show_Lvl_12 ? display.all : display.none)\r\nhline(Lvl_13, linestyle = hline.style_dashed, display = Show_Lvl_13 ? display.all : display.none)\r\n// hline(100, linestyle = hline.style_dashed)\r\n\r\n\r\nfill(d, e, Color_LP, 'Low Potential', display = Show_LP ? display.all : display.none)\r\nfill(f, g, Color_LP, 'Low Potential', display = Show_LP ? display.all : display.none)\r\n\r\nfill(b, c, Color_MP, 'Mid Potential', display = Show_MP ? display.all : display.none)\r\nfill(h, i, Color_MP, 'Mid Potential', display = Show_MP ? display.all : display.none)\r\n\r\nfill(a, b, Color_HP, 'High Potential', display =Show_HP ? display.all : display.none)\r\nfill(i, j, Color_HP, 'High Potential', display =Show_HP ? display.all : display.none)\r\n\r\n"
  },
  "https://www.tradingview.com/script/fSiyCIkr-Intermarket-Swing-Projection-LuxAlgo/": {
    "id": 20080956,
    "url": "https://www.tradingview.com/script/fSiyCIkr-Intermarket-Swing-Projection-LuxAlgo/",
    "name": "Intermarket Swing Projection [LuxAlgo]",
    "description": "The  Intermarket Swing Projection  allows traders to plot price movement swings from any user-selected asset directly onto the chart in the form of zigzags and/or horizontal support and resistance levels.\n\nThis tool rescale the external asset price on the user chart, enabling traders to make direct comparisons.\n\nIt answers the question of how different the price behavior is between two assets, accounting for each asset's volatility.\n\nüî∂  USAGE \n\n  \n\nThis tool is based on swing detection of two different assets: the chart and a user-selected asset. It allows traders to compare two assets on an equal footing while accounting for volatility and price behavior.\n\nTraders can customize the detection by selecting a custom ticker, timeframe, the number of swings and length for swing detection. This makes the tool a Swiss army knife for asset comparison.\n\n  \n\nAs we can see in the image below, the Show Last, Pivot Length, and Spread parameters are key to defining the final output of the tool.\n\n\"Show Last\" defines how many pivots are displayed. \"Pivot Length\" is used for pivot detection; a larger value will detect larger market structures. \"Spread\" defines how far apart the horizontal levels will be from their original location in terms of volatility.\n\nüîπ  Comparing different assets \n\n  \n\nThis image shows the Nasdaq 100 futures contract compared to four other futures contracts: S&P 500, gold, bitcoin, and euro/U.S. dollar.\n\nPlotting all of these assets in Nasdaq 100 terms makes it easy to compare and analyze price behaviors and identify key levels.\n \n In the top left chart, we have NQ vs. ES. It's no surprise that they are practically an exact match; a large portion of the S&P 500 is technology.\n In the top right chart, NQ vs. GC, we see totally different behaviors. We can clearly see the summer consolidation in gold and the resumption of the uptrend, which took gold above 29,200 NQ points, up from 21,200.\n In the bottom right chart, we see bitcoin making new highs, way above the Nasdaq in May, July, and October. However, the last high was way below the Nasdaq prices on October 27‚Äîthe first lower high in a while. Sellers are pushing down.\n Finally, the bottom left chart is NQ vs. 6E. We can see large volatility in the uptrend since February, with NQ unable to catch up until now. The last swing low was almost a match, and 6E is in a range.\n \nAs we can see, this tool allows us to perform intermarket analysis properly by accounting for each asset's volatility and price behavior. Then, we plot them on the same scale on equal terms, which makes performing this kind of analysis easy.\n\n  \n\nAs we can see in the chart above, the assets are the same as in the previous image, but the timeframe is 1H with different settings.\n\nNote the horizontal levels acting as support and resistance, as well as how NQ prices react to the zones marked with white circles. These levels are derived from custom assets selected by the user.\n\nüîπ  Displaying Elements \n\n  \n\nZig-zag allows traders to clearly see the path that the selected asset's price took, as well as its turning points.\n\nHorizontal levels are displayed from those turning points to the present and can be used as support or resistance. Traders can adjust the spread parameter in the settings panel to expand or contract those levels' volatility.\n\nThere are two color modes for the levels: average and pivots. In the first mode, green is used for levels below the average and red for levels above the average. The second uses green for swing lows and red for swing highs. \n\nThe backpaint feature is enabled by default and allows the swings to be displayed in the correct location. With this feature disabled, the swings will be displayed in the current location when a new swing is detected.\n\nüî∂  DETAILS \n\nOn a more technical note, the rescaling is formed by calculating three main elements from all the swings detected on the custom and chart assets:\n \n  The chart asset's average of all swing points\n  The chart asset's standard deviation of all swing points\n  The custom asset's z-score for each swing point\n \nThen, the re-scaled swing point is calculated as the average plus the z-score multiplied by the standard deviation. This makes it possible to plot AAPL swings on an NQ chart, for example.\n\nThanks to re-scaling, we can directly compare the price behavior of two assets with different price ranges and volatility on the same chart.\n\nüî∂  SETTINGS \n\nüîπ  Trendlines \n\n \n Ticker: Select the custom ticker.\n Timeframe: Select a custom timeframe.\n Show Last: Select how many swing points to display.\n Pivot Length: Select the size for swing point detection.\n Spread: Volatility multiplier for horizontal levels. Larger values mean the levels are farther apart.\n Backpaint: Enable or disable the backpaint feature. When enabled, the drawings will be displayed where they were detected. When disabled, the drawings will be displayed at the moment of detection.\n \n\nüîπ  Style \n\n \n Show ZigZag: Enable or disable the ZigZag display and choose a line style.\n Show Levels: Enable or disable the levels display and choose a line style.\n Color Mode: Choose between Average Mode, which colors all levels below the average bullish and all levels above bearish, and Pivot Mode, which colors swing highs bearish and swing lows bullish.\n Bullish: Select a bullish color.\n Bearish: Select a bearish color.\n ZigZag: Select the ZigZag color.\n",
    "author_name": "LuxAlgo",
    "likes_count": 960,
    "comments_count": 2,
    "views_count": 0,
    "created_at": "2025-12-10T20:44:22+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "NASDAQ:AAPL",
      "full_name": "NASDAQ:AAPL",
      "short_name": "AAPL",
      "exchange": "NASDAQ",
      "type": "stock",
      "logo_id": "apple",
      "currency_logo_id": "country/US",
      "base_currency_logo_id": null,
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/apple.svg"
      ],
      "interval": "15",
      "direction": 0,
      "badge": {
        "label": "NASDAQ:AAPL",
        "url": "/symbols/NASDAQ-AAPL/"
      }
    },
    "created": "2025-12-10",
    "updated": "2025-12-10",
    "source": "// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/\n// ¬© LuxAlgo\n\n//@version=6\nindicator('Intermarket Swing Projection [LuxAlgo]','LuxAlgo - Intermarket Swing Projection', overlay = true, max_lines_count = 500)\n//---------------------------------------------------------------------------------------------------------------------}\n//CONSTANTS & STRINGS & INPUTS\n//---------------------------------------------------------------------------------------------------------------------{\nGREEN               = #089981\nRED                 = #F23645\nSILVER              = color.silver\n\nDOTTED              = 'Dotted'\nDASHED              = 'Dashed'\nSOLID               = 'Solid'\n\nCOLOR_AVERAGE       = 'Average'\nCOLOR_PIVOTS        = 'Pivots'\n\nSTYLE_GROUP         = 'Style'\n\nEM_SPACE            = '‚ÄÉ'\n\ncolorModeSpacing    = EM_SPACE+EM_SPACE\ncolorModeTag        = 'Color Mode'+colorModeSpacing\n\ncustomAssetInput    = input.symbol(     'TVC:SPX',      'Ticker')\ncustomAssetTFInput  = input.timeframe(  '',             'Timeframe')\nshowLastInput       = input.int(        10,             'Show Last',    minval = 2, maxval = 500)\nswingLengthInput    = input.int(        20,             'Pivot Length', minval = 2)\nmultiplierInput     = input.float(      1.0,            'Spread',       step = 0.25)\nbackpaintInput      = input.bool(       true,           'Backpaint')\n\nshowZigzagInput     = input.bool(       true,           'Show ZigZag',  group = STYLE_GROUP, inline = 'zigzag')\nzigzagStyleInput    = input.string(     SOLID,          '',             group = STYLE_GROUP, inline = 'zigzag', options = [DOTTED,DASHED,SOLID])\n\nshowLevelsInput     = input.bool(       true,           'Show Levels',  group = STYLE_GROUP, inline = 'levels')\nlevelsStyleInput    = input.string(     SOLID,          '',             group = STYLE_GROUP, inline = 'levels', options = [DOTTED,DASHED,SOLID])\ncolorModeInput      = input.string(     COLOR_PIVOTS,   colorModeTag,   group = STYLE_GROUP, options = [COLOR_AVERAGE,COLOR_PIVOTS])\nbullishColorInput   = input.color(      GREEN,          'Bullish',      group = STYLE_GROUP)\nbearishColorInput   = input.color(      RED,            'Bearish',      group = STYLE_GROUP)\nzigzagColorInput    = input.color(      SILVER,         'ZigZag',       group = STYLE_GROUP)\n\n//---------------------------------------------------------------------------------------------------------------------}\n//USER-DEFINED FUNCTIONS\n//---------------------------------------------------------------------------------------------------------------------{\npivotDetection(length, showLast)=>    \n    var bool lastPivotWasHigh   = true\n    var array<int> times        = array.new<int>()\n    var array<float> prices     = array.new<float>()\n    int currentTime             = time[backpaintInput ? length : 0]\n    float ph                    = ta.pivothigh(length, length)\n    float pl                    = ta.pivotlow(length, length)\n\n    if not na(ph) and not lastPivotWasHigh\n        lastPivotWasHigh := true        \n        times.unshift(currentTime)\n        prices.unshift(ph)\n\n        if times.size() > showLast            \n            times.pop()\n            prices.pop()\n                        \n    if not na(pl) and lastPivotWasHigh\n        lastPivotWasHigh := false\n        times.unshift(currentTime)\n        prices.unshift(pl)\n\n        if times.size() > showLast\n            times.pop()        \n            prices.pop()\n\n    [prices,times]\n\nstyle(string style) =>\n    switch style\n        DOTTED  => line.style_dotted\n        DASHED  => line.style_dashed\n        SOLID   => line.style_solid\n\nplotDrawings(array<float> prices,array<float> assetPrices, array<int> assetTimes) =>\n    var polyline zigzag                     = na\n    var array<line> lines                   = array.new<line>()\n    array<chart.point> standarizedPoints    = array.new<chart.point>()\n    standarizedPrices                       = assetPrices.standardize()\n    float average                           = prices.avg()\n    float deviation                         = prices.stdev()\n    float levelsDeviation                   = prices.stdev() * multiplierInput\n\n    for eachLine in lines\n        eachLine.delete()\n\n    for [index,score] in standarizedPrices\n        int currentTime = assetTimes.get(index)\n\n        if showZigzagInput\n            float currentPrice = average + score * deviation            \n            standarizedPoints.push(chart.point.new(currentTime,na,currentPrice))\n\n        if showLevelsInput\n            float levelPrice    = average + score * levelsDeviation\n            color pivotColor    = score > standarizedPrices.get(index == 0 ? 1 : index - 1) ? bearishColorInput : bullishColorInput\n            color customColor   = colorModeInput == COLOR_AVERAGE ? (score <= 0 ? bullishColorInput : bearishColorInput) : pivotColor\n            lines.push(line.new(chart.point.new(currentTime,na,levelPrice), chart.point.new(last_bar_time,na,levelPrice), xloc.bar_time, color = customColor, style = style(levelsStyleInput)))\n\n    zigzag.delete()\n    zigzag := polyline.new(standarizedPoints,xloc = xloc.bar_time,line_color = zigzagColorInput, line_style = style(zigzagStyleInput))\n\n//---------------------------------------------------------------------------------------------------------------------}\n//MUTABLE VARIABLES & EXECUTION\n//---------------------------------------------------------------------------------------------------------------------{\n[prices,_]                  = pivotDetection(swingLengthInput, showLastInput)\n[assetPrices,assetTimes]    = request.security(customAssetInput, customAssetTFInput, pivotDetection(swingLengthInput, showLastInput))\n\nif barstate.islastconfirmedhistory or (barstate.isrealtime and barstate.isconfirmed)\n    if showZigzagInput or showLevelsInput\n        plotDrawings(prices,assetPrices,assetTimes)\n\n//---------------------------------------------------------------------------------------------------------------------}"
  },
  "https://www.tradingview.com/script/G5xAWHuw-Trinity-ATR-Real-Move-Detector/": {
    "id": 20083117,
    "url": "https://www.tradingview.com/script/G5xAWHuw-Trinity-ATR-Real-Move-Detector/",
    "name": "Trinity ATR Real Move Detector",
    "description": "Trinity ATR Real Move Detector\n\nThis ATR Energy Table indicator is one of the simplest yet most powerful filters you can have on a chart when trading short-dated or 0DTE options or swing trades on any timeframe from 1-minute up to 4-hour. Its entire job is to answer the single most important question in intraday and swing trading: ‚ÄúDoes the underlying actually have enough short-term explosive energy right now to make a directional position worth the theta and the spread, or is this just pretty candles that will die in ten minutes?‚Äù\n\nMost losing 0DTE and short-dated option trades happen because people buy or sell direction on a ‚Äúnice-looking‚Äù breakout or pullback while the underlying is actually in low-energy grind mode. The premium decays faster than the move develops, and you lose even when you‚Äôre ‚Äúright‚Äù on direction. This little table stops that from ever happening again.\n\nHere‚Äôs what it does in plain English:\n\nEvery bar it measures two things:\n- The current ATR on whatever timeframe you are using (1 min, 3 min, 5 min, 10 min, etc.). This tells you how big the average true range of the last 14 bars has been ‚Äî in other words, how violently the stock or index is actually moving right now.\n- The daily ATR (14-period on the daily chart). This is your benchmark for ‚Äúnormal‚Äù daily movement over the last two‚Äìthree weeks.\n\nIt then multiplies the daily ATR by a small number (the multiplier you set) and compares the two. If the short-term ATR is bigger than that percentage of the daily ATR, the table turns bright green and says ‚ÄúENOUGH ENERGY‚Äù. If not, it stays red and says ‚ÄúNOT ENOUGH‚Äù.\n\nWhy this works so well:\n- Real explosive moves that carry for 0DTE and 1‚Äì3 DTE options almost always show a short-term ATR spike well above the recent daily average. Quiet grind moves never do.\n- The comparison is completely adaptive ‚Äî on a high-vol day the threshold automatically rises, on a low-vol day it automatically drops. You never have to guess if ‚Äú2 points on SPY is big today‚Äù.\n- It removes emotion completely. You simply wait for green before you even think about clicking buy or sell on an option.\n\nKey settings and what to do with them:\n- Energy Multiplier ‚Äî this is the only number you ever touch. It is expressed as a decimal (0.15 = 15 % of the daily ATR). Lower = more signals, higher = stricter and higher win rate. The tooltip gives you the exact sweet-spot numbers for every popular timeframe (0.09 for 1-minute scalping, 0.13 for 3-minute, 0.14‚Äì0.16 for 5-minute, 0.15‚Äì0.19 for 10-minute, etc.). Just pick your timeframe once and type the number ‚Äî done forever.\n- ATR Length ‚Äî leave it at 14. That‚Äôs the standard and works perfectly.\n- Table Position ‚Äî move the table to wherever you want on the chart (top-right, bottom-right, bottom-left, top-left).\n- Table Size ‚Äî make the text Tiny, Small, Normal or Large depending on how much screen space you have.\n\nHow this helps you make money and stop losing it:\n- On most days you will see red 80‚Äì90 % of the time ‚Äî that‚Äôs good! It is forcing you to sit on your hands instead of overtrading low-energy chop that eats premium.\n- When it finally flips green you know institutions are actually pushing size right now ‚Äî follow-through probability jumps from ~40 % to 65‚Äì75 % depending on the stock and timeframe.\n- You stop buying calls on every green candle and puts on every red candle. You only strike when the market is genuinely ‚Äúawake‚Äù.\n- Over a week you take dramatically fewer trades, but your win rate and average winner size go way up ‚Äî which is exactly how consistent intraday option profits are made.\n\nIn short, this tiny table is the closest thing to an ‚Äúedge on/off switch‚Äù that exists for short-dated options. Red = preserve capital and go do something else. Green = pull the trigger with confidence. Use it religiously and you‚Äôll immediately feel the difference in your P&L.",
    "author_name": "EMA34TRADER",
    "likes_count": 142,
    "comments_count": 4,
    "views_count": 0,
    "created_at": "2025-12-11T07:11:39+00:00",
    "updated_at": "2025-12-12T05:08:14+00:00",
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "NYSE:JNJ",
      "full_name": "NYSE:JNJ",
      "short_name": "JNJ",
      "exchange": "NYSE",
      "type": "stock",
      "logo_id": "johnson-and-johnson",
      "currency_logo_id": "country/US",
      "base_currency_logo_id": null,
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/johnson-and-johnson.svg"
      ],
      "interval": "10",
      "direction": 0,
      "badge": {
        "label": "NYSE:JNJ",
        "url": "/symbols/NYSE-JNJ/"
      }
    },
    "created": "2025-12-12",
    "updated": "2025-12-12",
    "source": "// This Pine Script¬Æ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// ¬© EMA34TRADER\n//@version=5\nindicator(\"Trinity Real Move Detector Pro\", overlay=true, max_labels_count=500, max_lines_count=500)\n\n// INPUTS WITH FULL HINTS\nmultiplier = input.float(0.15, \"Energy Multiplier\", step=0.01,\n     tooltip = \n       \"Recommended values:\\n\\n\" +\n       \"1-minute   ‚Üí 0.08 ‚Äì 0.11\\n\" +\n       \"3-minute   ‚Üí 0.11 ‚Äì 0.14  ‚Üê most popular\\n\" +\n       \"5-minute   ‚Üí 0.12 ‚Äì 0.16  ‚Üê classic 0DTE\\n\" +\n       \"10-minute  ‚Üí 0.14 ‚Äì 0.19\\n\" +\n       \"15-minute  ‚Üí 0.18 ‚Äì 0.22\\n\" +\n       \"30-minute  ‚Üí 0.22 ‚Äì 0.28\\n\" +\n       \"1-hour     ‚Üí 0.28 ‚Äì 0.35\\n\" +\n       \"4-hour     ‚Üí 0.35 ‚Äì 0.45\\n\" +\n       \"Daily      ‚Üí 0.50 ‚Äì 0.70\\n\\n\" +\n       \"Just type the number for your timeframe!\")\n\natrLen     = input.int(14, \"ATR Length\")\ntable_pos  = input.string(\"top_right\", \"Table Position\", options=[\"top_right\",\"bottom_right\",\"bottom_left\",\"top_left\"])\ntable_size = input.string(\"small\", \"Table Size\", options=[\"tiny\",\"small\",\"normal\",\"large\"])\n\n// POSITION & SIZE\npos = table_pos == \"top_right\" ? position.top_right : table_pos == \"bottom_right\" ? position.bottom_right : table_pos == \"bottom_left\" ? position.bottom_left : position.top_left\ntxtSize = table_size == \"tiny\" ? size.tiny : table_size == \"small\" ? size.small : table_size == \"normal\" ? size.normal : size.large\n\n// CORE CALCULATION\ncurrentATR = ta.atr(atrLen)\ndailyATR   = request.security(syminfo.tickerid, \"D\", ta.atr(atrLen))\nthreshold  = dailyATR * multiplier\nenough     = currentATR >= threshold\n\n// BIAS (SuperTrend logic ‚Äî same as before, just for correct color)\nup   = close - currentATR\ndn   = close + currentATR\nvar int trend = 1\ntrend := close > dn[1] ? 1 : close < up[1] ? -1 : trend[1]\nbullBias = trend == 1\n\n// STATUS & COLORS\nstatusText  = enough ? (bullBias ? \"BULLISH ENERGY\" : \"BEARISH ENERGY\") : \"NOT ENOUGH\"\nstatusColor = enough ? (bullBias ? color.lime : color.red) : color.gray\nbgColor     = enough ? (bullBias ? color.new(color.green,80) : color.new(color.red,80)) : color.new(color.gray,85)\n\n// TABLE ONLY\nvar table t = table.new(pos, 2, 4, bgcolor=color.new(#000000,85), border_width=1)\n\nif barstate.islast\n    table.cell(t, 0, 0, \"Strength Detector Pro\",      text_color=#ffffff, bgcolor=#404040, text_size=txtSize)\n    table.cell(t, 1, 0, \"Value\",       text_color=#ffffff, bgcolor=#404040, text_size=txtSize)\n    table.cell(t, 0, 1, \"Current ATR\", text_color=#ffffff, text_size=txtSize)\n    table.cell(t, 1, 1, str.tostring(currentATR, \"#.##\"), text_color=enough ? #00ff00 : #ff0000, bgcolor=bgColor, text_size=txtSize)\n    table.cell(t, 0, 2, \"Threshold\",   text_color=#ffffff, text_size=txtSize)\n    table.cell(t, 1, 2, str.tostring(threshold, \"#.##\"), text_color=#ffaa00, text_size=txtSize)\n    table.cell(t, 0, 3, \"Status\",      text_color=#ffffff, text_size=txtSize)\n    table.cell(t, 1, 3, statusText,    text_color=statusColor, bgcolor=bgColor, text_size=txtSize)\n\n// ALERTS (still included)\nalertcondition(enough and not enough[1] and bullBias, title=\"BULLISH ENERGY\", message=\"BULLISH ENERGY {{ticker}} {{interval}}\")\nalertcondition(enough and not enough[1] and not bullBias, title=\"BEARISH ENERGY\", message=\"BEARISH ENERGY {{ticker}} {{interval}}\")\n"
  },
  "https://www.tradingview.com/script/Q0bvWSBe-Structure-Pivot-LL-HL-HH-LH/": {
    "id": 20089360,
    "url": "https://www.tradingview.com/script/Q0bvWSBe-Structure-Pivot-LL-HL-HH-LH/",
    "name": "Structure Pivot (LL-HL / HH-LH)",
    "description": "Structure Pivot (LL-HL / HH-LH) - Indicator Guide \n\nThis indicator scans for market structure pivot patterns‚Äîspecifically the bullish  Higher Low (LL‚ÄìHL)  and the bearish  Lower High (HH‚ÄìLH) ‚Äîacross multiple lengths simultaneously.\n\nIt automatically selects the most optimal pattern based on a \"Priority Mode\" and plots the structure and breakout/breakdown levels on the chart.\n\n 1. Basic Calculation Method \nThe indicator builds upon TradingView‚Äôs ta.pivotlow and ta.pivothigh functions to identify structural points.\n\n Bullish Structure (LL‚ÄìHL) \n1.LL (Lowest Low): A standard Pivot Low is identified.\n2.HL (Higher Low): A subsequent Pivot Low forms higher than the previous LL. This completes the setup.\n3.Pivot Line (Resistance): The indicator finds the highest price (High) that occurred between the LL and the HL. This level becomes the breakout trigger.\n\n Bearish Structure (HH‚ÄìLH) \n1.HH (Highest High): A standard Pivot High is identified.\n2.LH (Lower High): A subsequent Pivot High forms lower than the previous HH. This completes the setup.\n3.Pivot Line (Support): The indicator finds the lowest price (Low) that occurred between the HH and the LH. This level becomes the breakdown trigger.\n\n 2. Multi-Length Scanning \nUnlike standard indicators that use a single fixed length (e.g., Length = 5), this indicator scans a range of lengths simultaneously.\n„ÉªSettings: Defined by Min Length and Max Length.\n„ÉªMechanism: If set to Min=2 and Max=10, the indicator internally runs 9 separate calculations (Length 2 through 10) in parallel.\n\nThis allows it to capture everything from small, short-term pullbacks to larger, significant structural pivots without manual adjustment.\n\n 3. Priority Mode System \nSince multiple lengths are scanned, multiple valid patterns may appear at the same time. The  Priority Mode  determines which single pattern is the \"winner\" and gets displayed.\n\n A. Tightest Structure (Default) \n„ÉªFor Bullish (Long): Selects the pattern with the lowest Pivot Line (Resistance).\n„ÉªFor Bearish (Short): Selects the pattern with the highest Pivot Line (Support).\n„ÉªAdvantage: It finds the \"tightest\" contraction (like a VCP). This offers the entry point closest to the stop-loss level, providing the best Risk/Reward ratio.\n\n B. Longest Length \n„ÉªSelects the pattern detected by the longest length setting.\n„ÉªAdvantage: Focuses on major structural points, filtering out short-term noise. Best for trend confirmation.\n\n C. Shortest Length \n„ÉªSelects the pattern detected by the shortest length setting.\n„ÉªAdvantage: Extremely sensitive. Best for scalping or catching immediate micro-pullbacks.\n\n 4. Real-Time Logic & Features \nStructure Invalidation (Failure)\n„ÉªBullish: If the current price drops below the HL (the support of the structure), the setup is considered failed.\n„ÉªBearish: If the current price rises above the LH (the resistance of the structure), the setup is considered failed.\n„ÉªResult: All lines and labels for that structure are immediately deleted to keep the chart clean.\n\n Pivot Line Extension \n„ÉªAs long as the structure remains valid (price hasn't violated the HL or LH), the Pivot Line extends to the right, acting as a live reference for breakouts or breakdowns.\n\n Alerts \n„ÉªBullish Breakout: Triggered when the Close price crosses over the Pivot Line.\n„ÉªBearish Breakdown: Triggered when the Close price crosses under the Pivot Line.",
    "author_name": "oratnek",
    "likes_count": 165,
    "comments_count": 1,
    "views_count": 0,
    "created_at": "2025-12-12T07:40:11+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "NYSE:NOW",
      "full_name": "NYSE:NOW",
      "short_name": "NOW",
      "exchange": "NYSE",
      "type": "stock",
      "logo_id": "servicenow",
      "currency_logo_id": "country/US",
      "base_currency_logo_id": null,
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/servicenow.svg"
      ],
      "interval": "1D",
      "direction": 0,
      "badge": {
        "label": "NYSE:NOW",
        "url": "/symbols/NYSE-NOW/"
      }
    },
    "created": "2025-12-12",
    "updated": "2025-12-12",
    "source": "//@version=6\r\nindicator('Structure Pivot (LL-HL / HH-LH)', overlay = true, max_lines_count = 500, max_labels_count = 500)\r\n\r\n// --- Settings ---\r\ngrp_calc = 'Calculation'\r\ndetect_mode = input.string(\"Long Only (LL-HL)\", \"Detection Mode\", options=[\"Long Only (LL-HL)\", \"Short Only (HH-LH)\", \"Both\"], group=grp_calc)\r\nmin_len_input = input.int(2, 'Min Length', minval = 1, group = grp_calc)\r\nmax_len_input = input.int(10, 'Max Length', minval = 2, group = grp_calc)\r\npriority_mode = input.string(\"Tightest Structure\", \"Priority Mode\", options=[\"Tightest Structure\", \"Longest Length\", \"Shortest Length\"], group=grp_calc)\r\n\r\ngrp_vis = 'Visibility Settings'\r\nshow_Labels = input.bool(true, 'Show Labels', group = grp_vis)\r\nshow_Trend  = input.bool(true, 'Show Trendline', group = grp_vis)\r\nshow_PLine  = input.bool(true, 'Show Pivot Line', group = grp_vis)\r\nshow_PPrice = input.bool(true, 'Show Pivot Price', group = grp_vis)\r\n\r\ngrp_style = 'Style Settings'\r\nlblSize = input.string(size.normal, 'Text Size', options = [size.tiny, size.small, size.normal, size.large], group = grp_style)\r\ncol_Long = input.color(color.gray, 'Long Color (LL-HL)', group = grp_style)\r\ncol_Short = input.color(color.gray, 'Short Color (HH-LH)', group = grp_style)\r\nwidth_Line = input.int(1, 'Line Width', minval = 1, group = grp_style)\r\nstyle_Trend = input.string(line.style_dashed, 'Trendline Style', options = [line.style_solid, line.style_dashed, line.style_dotted], group = grp_style)\r\nstyle_Pivot = input.string(line.style_solid, 'Pivot Line Style', options = [line.style_solid, line.style_dashed, line.style_dotted], group = grp_style)\r\n\r\n// --- Structs ---\r\ntype PivotState\r\n    int len          \r\n    float prev_p     \r\n    int prev_idx     \r\n    float curr_p     \r\n    int curr_idx     \r\n    bool is_setup    \r\n    float break_val  \r\n    int break_idx    \r\n    bool is_long     \r\n\r\n// New Struct to handle drawing objects by reference\r\ntype DrawObjects\r\n    line l_trend = na\r\n    line l_pivot = na\r\n    label lbl_price = na\r\n    label lbl_curr = na\r\n    label lbl_prev = na\r\n    int sig = 0\r\n\r\n// --- Variables ---\r\nvar PivotState[] states_long = array.new<PivotState>()\r\nvar PivotState[] states_short = array.new<PivotState>()\r\n\r\nif bar_index == 0\r\n    for i = min_len_input to max_len_input\r\n        array.push(states_long, PivotState.new(i, na, na, na, na, false, na, na, true))\r\n        array.push(states_short, PivotState.new(i, na, na, na, na, false, na, na, false))\r\n\r\n// Initialize Drawing Objects\r\nvar DrawObjects d_long = DrawObjects.new()\r\nvar DrawObjects d_short = DrawObjects.new()\r\n\r\n// --- Method ---\r\nmethod update(PivotState st) =>\r\n    float p = st.is_long ? ta.pivotlow(low, st.len, st.len) : ta.pivothigh(high, st.len, st.len)\r\n    \r\n    if not na(p)\r\n        bool setup_cond = false\r\n        if not na(st.curr_p)\r\n            if st.is_long\r\n                if p > st.curr_p // Higher Low\r\n                    setup_cond := true\r\n            else\r\n                if p < st.curr_p // Lower High\r\n                    setup_cond := true\r\n        \r\n        st.prev_p := st.curr_p\r\n        st.prev_idx := st.curr_idx\r\n        st.curr_p := p\r\n        st.curr_idx := bar_index - st.len\r\n        st.is_setup := setup_cond\r\n        st.break_val := na\r\n        st.break_idx := na\r\n        \r\n        if setup_cond and not na(st.prev_idx)\r\n            float best_val = st.is_long ? 0.0 : 1000000.0\r\n            int best_idx = -1\r\n            int start_s = st.prev_idx + 1\r\n            int end_s = st.curr_idx - 1\r\n            \r\n            if end_s >= start_s\r\n                for i = start_s to end_s\r\n                    float v = st.is_long ? high[bar_index - i] : low[bar_index - i]\r\n                    if st.is_long\r\n                        if v > best_val\r\n                            best_val := v\r\n                            best_idx := i\r\n                    else\r\n                        if v < best_val\r\n                            best_val := v\r\n                            best_idx := i\r\n                            \r\n            if best_idx != -1\r\n                st.break_val := best_val\r\n                st.break_idx := best_idx\r\n\r\n// --- Main Logic ---\r\n\r\n// Update Arrays\r\nif detect_mode != \"Short Only (HH-LH)\"\r\n    for st in states_long\r\n        st.update()\r\n        // Fail condition Long\r\n        if st.is_setup and not na(st.curr_p) and low < st.curr_p\r\n            st.is_setup := false\r\n\r\nif detect_mode != \"Long Only (LL-HL)\"\r\n    for st in states_short\r\n        st.update()\r\n        // Fail condition Short\r\n        if st.is_setup and not na(st.curr_p) and high > st.curr_p\r\n            st.is_setup := false\r\n\r\n// Winner Logic\r\nfind_winner(PivotState[] arr, string p_mode) =>\r\n    PivotState w = na\r\n    for st in arr\r\n        if st.is_setup and not na(st.break_val)\r\n            bool upd = false\r\n            if na(w)\r\n                upd := true\r\n            else\r\n                if p_mode == \"Tightest Structure\"\r\n                    if st.is_long\r\n                        if st.break_val < w.break_val\r\n                            upd := true\r\n                    else\r\n                        if st.break_val > w.break_val\r\n                            upd := true\r\n                else if p_mode == \"Longest Length\"\r\n                    upd := true\r\n                else\r\n                    upd := false \r\n            if upd\r\n                w := st\r\n    w\r\n\r\nPivotState win_long = na\r\nPivotState win_short = na\r\n\r\nif detect_mode != \"Short Only (HH-LH)\"\r\n    win_long := find_winner(states_long, priority_mode)\r\n    if na(win_long) and array.size(states_long) > 0\r\n        win_long := array.get(states_long, 0)\r\n    // Tracking\r\n    if not win_long.is_setup and not na(win_long.curr_p) and low < win_long.curr_p\r\n        win_long.curr_p := low\r\n        win_long.curr_idx := bar_index\r\n\r\nif detect_mode != \"Long Only (LL-HL)\"\r\n    win_short := find_winner(states_short, priority_mode)\r\n    if na(win_short) and array.size(states_short) > 0\r\n        win_short := array.get(states_short, 0)\r\n    // Tracking\r\n    if not win_short.is_setup and not na(win_short.curr_p) and high > win_short.curr_p\r\n        win_short.curr_p := high\r\n        win_short.curr_idx := bar_index\r\n\r\n// --- Drawing Function (Using Struct Reference) ---\r\ndraw_struct(PivotState w, DrawObjects d, bool is_l) =>\r\n    int sig = w.curr_idx * 1000 + w.len * 10 + (w.is_setup ? 1 : 0)\r\n    color c_base = is_l ? col_Long : col_Short\r\n    \r\n    // New signature detected\r\n    if sig != d.sig\r\n        line.delete(d.l_trend)\r\n        line.delete(d.l_pivot)\r\n        label.delete(d.lbl_price)\r\n        label.delete(d.lbl_curr)\r\n        label.delete(d.lbl_prev)\r\n        \r\n        d.l_trend := na\r\n        d.l_pivot := na\r\n        d.lbl_price := na\r\n        d.lbl_curr := na\r\n        d.lbl_prev := na\r\n        \r\n        if not na(w.curr_p)\r\n            string txt_c = is_l ? (w.is_setup ? \"HL\" : \"LL\") : (w.is_setup ? \"LH\" : \"HH\")\r\n            string sty_c = is_l ? label.style_label_up : label.style_label_down\r\n            \r\n            if show_Labels\r\n                d.lbl_curr := label.new(w.curr_idx, w.curr_p, text=txt_c, style=sty_c, color=color.new(color.white, 100), textcolor=c_base, size=lblSize)\r\n            \r\n            if w.is_setup and not na(w.prev_idx)\r\n                string txt_p = is_l ? \"LL\" : \"HH\"\r\n                if show_Labels\r\n                    d.lbl_prev := label.new(w.prev_idx, w.prev_p, text=txt_p, style=sty_c, color=color.new(color.white, 100), textcolor=c_base, size=lblSize)\r\n                \r\n                if show_Trend\r\n                    d.l_trend := line.new(w.prev_idx, w.prev_p, w.curr_idx, w.curr_p, color=c_base, style=style_Trend, width=width_Line)\r\n                \r\n                if not na(w.break_idx)\r\n                    if show_PLine\r\n                        d.l_pivot := line.new(w.break_idx, w.break_val, bar_index + 10, w.break_val, color=c_base, width=width_Line, style=style_Pivot)\r\n                    if show_PPrice\r\n                        // Reverted to \"Pivot =\" and added comma formatting\r\n                        string p_txt = \"Pivot = \" + str.tostring(w.break_val, \"#,###.#####\")\r\n                        d.lbl_price := label.new(bar_index + 10, w.break_val, text=p_txt, style=label.style_label_left, color=color.new(color.white, 100), textcolor=c_base, size=lblSize)\r\n        \r\n        d.sig := sig\r\n            \r\n    // Extension & Failure Check\r\n    if w.is_setup\r\n        if not na(d.l_pivot)\r\n            line.set_x2(d.l_pivot, bar_index + 5)\r\n        if not na(d.lbl_price)\r\n            label.set_x(d.lbl_price, bar_index + 5)\r\n        \r\n        // Breakout Logic (Fail)\r\n        bool fail = is_l ? (low < w.curr_p) : (high > w.curr_p)\r\n        if fail\r\n            w.is_setup := false\r\n            line.delete(d.l_trend)\r\n            line.delete(d.l_pivot)\r\n            label.delete(d.lbl_price)\r\n            label.delete(d.lbl_curr)\r\n            label.delete(d.lbl_prev)\r\n            d.l_trend := na\r\n            d.l_pivot := na\r\n            d.sig := -1\r\n\r\n// Execute Drawing\r\nif detect_mode != \"Short Only (HH-LH)\" and not na(win_long)\r\n    draw_struct(win_long, d_long, true)\r\n\r\nif detect_mode != \"Long Only (LL-HL)\" and not na(win_short)\r\n    draw_struct(win_short, d_short, false)\r\n\r\n// --- Alerts ---\r\nbool alert_l = not na(win_long) and win_long.is_setup and not na(win_long.break_val) and ta.crossover(close, win_long.break_val)\r\nbool alert_s = not na(win_short) and win_short.is_setup and not na(win_short.break_val) and ta.crossunder(close, win_short.break_val)\r\n\r\nalertcondition(alert_l, \"Bullish Breakout\", \"Price broke above Pivot (Long)\")\r\nalertcondition(alert_s, \"Bearish Breakdown\", \"Price broke below Pivot (Short)\")"
  },
  "https://www.tradingview.com/script/NaH6ePAs-Sayed-Official-Sniper/": {
    "id": 20089080,
    "url": "https://www.tradingview.com/script/NaH6ePAs-Sayed-Official-Sniper/",
    "name": "Sayed Official Sniper",
    "description": "Sniper and Trading best swing of the year no body knows i get it premium to share with you guyz",
    "author_name": "oxaam479",
    "likes_count": 97,
    "comments_count": 4,
    "views_count": 0,
    "created_at": "2025-12-12T06:39:03+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "FX:XAUUSD",
      "full_name": "FX:XAUUSD",
      "short_name": "XAUUSD",
      "exchange": "FX",
      "type": "commodity",
      "logo_id": "metal/gold",
      "currency_logo_id": "country/US",
      "base_currency_logo_id": null,
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/metal/gold.svg"
      ],
      "interval": "15",
      "direction": 0,
      "badge": {
        "label": "FX:XAUUSD",
        "url": "/symbols/XAUUSD/"
      }
    },
    "created": "2025-12-12",
    "updated": "2025-12-12",
    "source": "//@version=6\nindicator(\"Red Wolf Trading Academy Swings Sniper\", \"RWTA Swings\", overlay=true, format=format.price, max_labels_count=500, max_lines_count=50)\n\n//--------------------- Library Import ---------------------//\nimport yashgode9/signalLib_yashgode9/2 as signalLib\n\n//--------------------- Inputs ---------------------//\nDEPTH_ENGINE = input.int(30, 'DEPTH_ENGINE', minval = 1, step = 1, group='Config')\nDEVIATION_ENGINE = input.int(5, 'DEVIATION_ENGINE', minval = 1, step = 1, group='Config')\nBACKSTEP_ENGINE = input.int(5, 'BACKSTEP_ENGINE', minval = 2, step = 1, group='Config')\n\nlabels = input(0, 'Labels Transparency', group='Labels')\nbuycolor = input(#03ff85, 'Buy Color', group='Colors')\nsellcolor = input(#fc0808, 'Sell Color', group='Colors')\nbuycolor1 = #000000\nsellcolor1 = #000000\nlabelsize__0 = input.int(3, 'Label Size', minval=1, maxval=5, group='Labels')\nlabelsize = switch labelsize__0\n    1 => size.tiny\n    2 => size.small\n    3 => size.normal\n    4 => size.large\n    5 => size.huge\n\nrepaint = true\nextend = false\n\n//--------------------- Swing Detection ---------------------//\nph = ta.pivothigh(high, DEPTH_ENGINE, DEPTH_ENGINE)\npl = ta.pivotlow(low, DEPTH_ENGINE, DEPTH_ENGINE)\n\nvar float lastSwingHigh = na\nvar float lastSwingLow = na\nvar label lastHighLabel = na\nvar label lastLowLabel = na\n\nif not na(ph)\n    lastSwingHigh := ph\n    label.delete(lastHighLabel)\n    lastHighLabel := label.new(bar_index, ph, \"Last High\", yloc=yloc.price, color=color.new(color.red, labels), style=label.style_label_down, size=size.tiny)\n\nif not na(pl)\n    lastSwingLow := pl\n    label.delete(lastLowLabel)\n    lastLowLabel := label.new(bar_index, pl, \"Last Low\", yloc=yloc.price, color=color.new(color.green, labels), style=label.style_label_up, size=size.tiny)\n\n//--------------------- Signal Logic ---------------------//\n[direction, zee1, zee2] = signalLib.signalLib(low, high, DEPTH_ENGINE, DEVIATION_ENGINE, BACKSTEP_ENGINE)\nstring nowPoint = ''\n\nvar float lastPoint = na\nvar float field_1 = na\nvar float field_2 = na\nvar float field_3 = na\n\nfield_0 = zee1.price\nif bool(ta.change(direction))\n    field_1 := zee1.price\n    lastPoint := field_1[1]\n    lastPoint\n\nline zeezee = na\nlabel point = na\n\nif repaint\n    nowPoint := direction < 0 ? zee2.price < lastPoint ? 'Buy-point' : 'Buy-point' : zee2.price > lastPoint ? 'Sell-point' : 'Sell-point'\n    point := label.new(zee2, nowPoint, xloc.bar_time, yloc.price, color.new(direction < 0 ? buycolor : sellcolor, labels), direction > 0 ? label.style_label_down : label.style_label_up, color.new(direction > 0 ? buycolor1 : sellcolor1, labels), labelsize)\n    if direction == direction[1]\n        line.delete(zeezee[1])\n        label.delete(point[1])\n    else\n        line.set_extend(zeezee[1], extend.none)\nelse\n    if direction != direction[1]\n        field_2 := zee2.price\n        field_3 := zee2.price\n        nowPoint := direction[1] < 0 ? field_2[1] < lastPoint[1] ? 'Buy-point' : 'Buy-point' : field_3[1] > lastPoint[1] ? 'Sell-point' : 'Sell-point'\n        point := label.new(zee2[1], nowPoint, xloc.bar_time, yloc.price, color.new(direction[1] < 0 ? buycolor : sellcolor, labels), direction[1] > 0 ? label.style_label_down : label.style_label_up, color.new(direction[1] > 0 ? buycolor1 : sellcolor1, labels), labelsize)\n        point\n\n//--------------------- Risk Management ---------------------//\nriskType = input.string(\"Fixed\", \"Risk Management Type\", options=[\"Fixed\", \"ATR\", \"Higher Swing\"])\n\n// Fixed TP/SL\nTP_perc = input.float(1.5, \"Fixed TP (%)\")\nSL_perc = input.float(1.0, \"Fixed SL (%)\")\n\n// ATR Based\natrLength = input.int(14, \"ATR Length\")\natrMult = input.float(1.5, \"ATR Multiplier\")\natrValue = ta.atr(atrLength)\n\n// Trade Entry Variables\nvar bool tradeActive = false\nvar float entryPrice = na\nvar float takeProfit = na\nvar float stopLoss = na\n\n// Trade Entry Logic\nif direction < 0 and not tradeActive\n    tradeActive := true\n    entryPrice := close\n    if riskType == \"Fixed\"\n        takeProfit := entryPrice * (1 + TP_perc/100)\n        stopLoss := entryPrice * (1 - SL_perc/100)\n    else if riskType == \"ATR\"\n        takeProfit := entryPrice + atrValue * atrMult\n        stopLoss := entryPrice - atrValue * atrMult\n    else if riskType == \"Higher Swing\"\n        takeProfit := lastSwingHigh\n        stopLoss := lastSwingLow\n    alert(\"Buy Trade Entered!\", alert.freq_once_per_bar_close)\n\nif direction > 0 and not tradeActive\n    tradeActive := true\n    entryPrice := close\n    if riskType == \"Fixed\"\n        takeProfit := entryPrice * (1 - TP_perc/100)\n        stopLoss := entryPrice * (1 + SL_perc/100)\n    else if riskType == \"ATR\"\n        takeProfit := entryPrice - atrValue * atrMult\n        stopLoss := entryPrice + atrValue * atrMult\n    else if riskType == \"Higher Swing\"\n        takeProfit := lastSwingLow\n        stopLoss := lastSwingHigh\n    alert(\"Sell Trade Entered!\", alert.freq_once_per_bar_close)\n\n// Trade Close Logic\nif tradeActive\n    // Buy Trade\n    if direction < 0\n        if close >= takeProfit or close <= stopLoss\n            tradeActive := false\n            alert(\"Buy Trade Closed!\", alert.freq_once_per_bar_close)\n    // Sell Trade\n    if direction > 0\n        if close <= takeProfit or close >= stopLoss\n            tradeActive := false\n            alert(\"Sell Trade Closed!\", alert.freq_once_per_bar_close)\n"
  },
  "https://www.tradingview.com/script/25eSqem2-RSI-Pivot-Breaks/": {
    "id": 20084716,
    "url": "https://www.tradingview.com/script/25eSqem2-RSI-Pivot-Breaks/",
    "name": "RSI Pivot Breaks",
    "description": "‚ñà OVERVIEW\nRSI Pivot Breaks is an RSI-based indicator that detects breakout events on oscillator-based pivot levels (RSI or MA RSI).\nThe tool automatically plots pivot levels, tracks their breakouts, highlights momentum shifts, and generates alerts for key events (pivot breaks and OB/OS crosses).\n\nThe indicator is designed primarily for momentum strategies ‚Äî pivot breakouts often precede directional price moves, making RSI Pivot Breaks a powerful tool for identifying accelerations and changes in strength.\n\n‚ñà CONCEPTS\nThe indicator analyzes local RSI extremes and transforms them into dynamic support/resistance levels.\nWhen RSI or MA RSI breaks the last pivot, it signals a shift in momentum balance, often leading to an impulse move.\n\nKey concepts:\n- pivot highs/lows detected on RSI or MA RSI,\n- pivot lines extend forward until broken,\n- pivot filters restrict pivot detection to specific RSI zones,\n- OB/OS levels provide contextual momentum thresholds.\n\n‚ñà FEATURES\nPivot Detection & Breakouts\n- Detection of pivot highs and lows on RSI or MA RSI.\n- Pivot filters allow you to limit pivot detection to specific RSI ranges (e.g., only bullish pivots below 50 or bearish pivots above 50).\n- Pivot lines update automatically after breakout.\n\nBackground highlights:\n- green on pivot-high breakouts,\n- red on pivot-low breakouts.\n\nRSI & MA RSI\n- Dynamic RSI colors based on momentum direction.\n- Optional MA RSI line (SMA/EMA/RMA/WMA) usable as a smoother pivot source.\n\nOB / OS Zones\n- Fully adjustable overbought/oversold levels.\n- Dedicated OB/OS colors.\n- Optional gradient backgrounds.\n\nHighlights\n- Instant identification of moments when RSI breaks a key pivot level.\n\nAlerts:\n- pivot high breakouts.\n- pivot low breakouts.\n- OB crosses.\n- OS crosses.\n\n‚ñà HOW TO USE\nAdd the indicator:\nIndicators ‚Üí RSI Pivot Breaks.\n\nRSI Settings\n- RSI Length ‚Äì core RSI period.\n- RSI MA Length & Type ‚Äì MA RSI smoothing parameters.\n\nPivot Settings\n- Pivot Left / Pivot Right ‚Äì number of bars required to form a pivot and also the number of bars of delay before the pivot becomes confirmed.\n(Higher values produce more reliable but slower pivots.)\n\nPivot Filters\n- Minimum/maximum allowed RSI levels for pivot Highs and Lows.\n- Examples:\n- detect only pivot Highs at low RSI values.\n- ignore pivots during extreme momentum.\n- allow only mid-range pivot detection depending on strategy.\n\nVisualization\n- Toggles for RSI and MA RSI visibility.\n- Optional gradients.\n- Full color and transparency customization.\n\nOB/OS Levels\n- Adjustable thresholds depending on instrument volatility and strategy style.\n\n‚ñà SIGNAL INTERPRETATION\nBUY\n- RSI breaks the latest pivot high.\n- RSI crosses upward out of OS.\n- Context example: pivot lows forming a rising sequence.\n\nSELL\n- RSI breaks the latest pivot low.\n- RSI drops downward from OB.\n- Context example: pivot highs forming a declining sequence.\n\nTrend / Momentum\n- Pivot breakouts indicate acceleration or continuation of momentum.\n- MA-based pivots provide smoother and more stable momentum structure.\n\n‚ñà APPLICATIONS\n- Momentum Trading ‚Äì pivot breaks as early acceleration signals.\n- Scalping & Intraday ‚Äì fast RSI pivots react quickly to short-term shifts.\n- Swing Trading ‚Äì smoother pivots using MA RSI for higher-timeframe structure.\n- Divergence Detection ‚Äì pivot behavior helps reveal divergence patterns, e.g.:\n- RSI pivots rising while price is falling ‚Üí potential early momentum reversal.\n- Custom Filtering ‚Äì pivot filters allow, for example:\n- blocking bullish signals near OB.\n- blocking bearish signals near OS.\n- detecting pivots only above/below mid-range during strong trends,\ndepending entirely on strategy design.\n\n‚ñà NOTES\n- Pivot detection includes natural delay equal to the Left/Right parameters.\n- Pivot filters significantly change the character of signals, allowing fine-tuning of aggressiveness for any strategy.",
    "author_name": "Uncle_the_shooter",
    "likes_count": 69,
    "comments_count": 2,
    "views_count": 0,
    "created_at": "2025-12-11T12:17:51+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "BINANCE:BTCUSDT",
      "full_name": "BINANCE:BTCUSDT",
      "short_name": "BTCUSDT",
      "exchange": "BINANCE",
      "type": "spot",
      "logo_id": null,
      "currency_logo_id": "crypto/XTVCUSDT",
      "base_currency_logo_id": "crypto/XTVCBTC",
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/crypto/XTVCBTC.svg",
        "https://s3-symbol-logo.tradingview.com/crypto/XTVCUSDT.svg"
      ],
      "interval": "240",
      "direction": 0,
      "badge": {
        "label": "BINANCE:BTCUSDT",
        "url": "/symbols/BTCUSDT/"
      }
    },
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "// This Pine Script¬Æ code is subject to the terms of the Mozilla Public License 2.0\r\n// ¬© Uncle_the_shooter\r\n\r\n//@version=6\r\nindicator('RSI Pivot Breaks', overlay=false, max_lines_count=500, max_bars_back=1000)\r\n\r\n// INPUTS\r\nrsiLength = input.int(14, 'RSI Length')\r\nmaLen     = input.int(14, 'RSI MA Length')\r\nmaType    = input.string('EMA', 'RSI MA Type', options=['SMA','EMA','RMA','WMA'])\r\n\r\n// OB / OS LINES\r\nobLine = input.int(70, 'OB Line Level')\r\nosLine = input.int(30, 'OS Line Level')\r\n\r\n// PIVOT LENGTH\r\nleft  = input.int(5, 'Pivot Left', minval=1)\r\nright = input.int(5, 'Pivot Right', minval=1)\r\n\r\n// NEW FILTERS FOR PIVOTS \r\n// Pivot High\r\nhiFilterMin = input.int(0, 'Pivot High Min Level')\r\nhiFilterMax = input.int(60, 'Pivot High Max Level')\r\n\r\n// Pivot Low\r\nloFilterMin = input.int(40, 'Pivot Low Min Level')\r\nloFilterMax = input.int(100, 'Pivot Low Max Level')\r\n\r\n// PIVOT SOURCE\r\npivotSourceOpt = input.string('RSI', 'Pivot Source', options=['RSI','MA RSI'])\r\n\r\n// INPUTS ‚Äì toggle visualization\r\nshowRsiSignal = input.bool(true, 'Show RSI Signal')\r\nshowMaRsi     = input.bool(true, 'Show MA RSI')\r\n\r\n// GRADIENTS\r\nuseGradient = input.bool(true, 'Gradient')\r\ngradTransp  = input.int(80, 'Gradient Transparency', minval=0, maxval=100)\r\n\r\n// HIGHLIGHT COLORS\r\nbullishColor = input.color(color.new(color.green, 70), 'Bullish Highlight Color')\r\nbearishColor = input.color(color.new(color.red, 70), 'Bearish Highlight Color')\r\n\r\n// COLORS ‚Äì OTHER (GROUP \"Colors\")\r\nrsiBullCol = input.color(color.rgb(6, 162, 47), 'RSI Bull Color', group = 'Colors')\r\nrsiBearCol = input.color(color.rgb(207, 23, 23), 'RSI Bear Color', group = 'Colors')\r\nmaColor    = input.color(color.rgb(192, 204, 22), 'RSI MA Color', group = 'Colors')\r\nobColor    = input.color(color.rgb(207, 23, 23), 'OB Line Color', group = 'Colors')\r\nosColor    = input.color(color.rgb(6, 162, 47), 'OS Line Color', group = 'Colors')\r\nmidColor   = input.color(#676b7a, 'Mid Line Color', group = 'Colors')\r\n\r\nmaxLines = 500\r\n\r\n// RSI + MA \r\nrsi = ta.rsi(close, rsiLength)\r\n\r\nmaRsi = switch maType\r\n    'SMA' => ta.sma(rsi, maLen)\r\n    'EMA' => ta.ema(rsi, maLen)\r\n    'RMA' => ta.rma(rsi, maLen)\r\n    'WMA' => ta.wma(rsi, maLen)\r\n\r\npivotSrc = pivotSourceOpt == 'MA RSI' ? maRsi : rsi\r\n\r\n// DYNAMIC COLORS\r\nrsiBaseCol = showRsiSignal ? (rsi >= 50 ? rsiBullCol : rsiBearCol) : na\r\nmaPlotCol  = showMaRsi ? maColor : na\r\n\r\n// PLOTS \r\nplot(rsi, 'RSI', color = rsiBaseCol, linewidth = 2)\r\nplot(rsi, color = showRsiSignal ? color.new(rsiBaseCol, 70) : na, linewidth = 5)\r\nplot(rsi, color = showRsiSignal ? color.new(rsiBaseCol, 80) : na, linewidth = 8)\r\n\r\nplot(maRsi, 'RSI MA', color = maPlotCol, linewidth = 2)\r\n\r\n// OB / OS / MID LINES\r\np_ob = plot(obLine, 'OB', color = obColor, linewidth = 1)\r\np_os = plot(osLine, 'OS', color = osColor, linewidth = 1)\r\n\r\np_mid = plot(50, display = display.none)\r\nhline(50, 'MID', color = midColor, linestyle = hline.style_dashed, linewidth = 1)\r\n\r\n// ARRAYS \r\nvar array<line>  hiLines = array.new_line()\r\nvar array<float> hiLvl   = array.new_float()\r\nvar array<bool>  hiLive  = array.new_bool()\r\n\r\nvar array<line>  loLines = array.new_line()\r\nvar array<float> loLvl   = array.new_float()\r\nvar array<bool>  loLive  = array.new_bool()\r\n\r\n// PIVOTS\r\nph = ta.pivothigh(pivotSrc, left, right)\r\npl = ta.pivotlow(pivotSrc, left, right)\r\n\r\n// CREATE HIGH LINES (filtered by hiFilterMin / hiFilterMax)\r\nif not na(ph) and ph >= hiFilterMin and ph <= hiFilterMax\r\n    int x = bar_index - right\r\n    l = line.new(x, ph, x + 1, ph, extend = extend.right, color = obColor, width = 2)\r\n    array.push(hiLines, l)\r\n    array.push(hiLvl, ph)\r\n    array.push(hiLive, true)\r\n\r\n// CREATE LOW LINES (filtered by loFilterMin / loFilterMax) \r\nif not na(pl) and pl >= loFilterMin and pl <= loFilterMax\r\n    int x = bar_index - right\r\n    l = line.new(x, pl, x + 1, pl, extend = extend.right, color = osColor, width = 2)\r\n    array.push(loLines, l)\r\n    array.push(loLvl, pl)\r\n    array.push(loLive, true)\r\n\r\n// RING BUFFER (cleanup)\r\nwhile array.size(hiLines) > maxLines\r\n    line.delete(array.shift(hiLines))\r\n    array.shift(hiLvl)\r\n    array.shift(hiLive)\r\n\r\nwhile array.size(loLines) > maxLines\r\n    line.delete(array.shift(loLines))\r\n    array.shift(loLvl)\r\n    array.shift(loLive)\r\n\r\n// BREAK LOGIC + HIGHLIGHT\r\nbool highlightBull = false\r\nbool highlightBear = false\r\n\r\nint hc = array.size(hiLines)\r\nif hc > 0\r\n    for j = 0 to hc - 1\r\n        int i = hc - 1 - j\r\n        if array.get(hiLive, i)\r\n            float lvl = array.get(hiLvl, i)\r\n            line ln = array.get(hiLines, i)\r\n            if pivotSrc > lvl\r\n                line.set_x2(ln, bar_index)\r\n                line.set_extend(ln, extend.none)\r\n                array.set(hiLive, i, false)\r\n                highlightBull := true\r\n\r\nint lc = array.size(loLines)\r\nif lc > 0\r\n    for j = 0 to lc - 1\r\n        int i = lc - 1 - j\r\n        if array.get(loLive, i)\r\n            float lvl = array.get(loLvl, i)\r\n            line ln = array.get(loLines, i)\r\n            if pivotSrc < lvl\r\n                line.set_x2(ln, bar_index)\r\n                line.set_extend(ln, extend.none)\r\n                array.set(loLive, i, false)\r\n                highlightBear := true\r\n\r\nbgcolor(highlightBull ? bullishColor : na)\r\nbgcolor(highlightBear ? bearishColor : na)\r\n\r\n// GRADIENT AREAS \r\np_top = plot(100, display = display.none)\r\np_bot = plot(0,   display = display.none)\r\n\r\ngradObColor = color.new(obColor, gradTransp)\r\ngradOsColor = color.new(osColor, gradTransp)\r\ntranspWhite = color.new(color.white, 100)\r\n\r\n// OB area\r\nfill(p_ob, p_top, useGradient ? obLine : na, useGradient ? 100 : na, gradObColor, transpWhite)\r\nfill(p_top, p_ob, useGradient ? 100 : na, useGradient ? obLine : na, transpWhite, gradObColor)\r\n\r\n// OS area\r\nfill(p_os, p_bot, useGradient ? osLine : na, useGradient ? 0 : na, gradOsColor, transpWhite)\r\nfill(p_bot, p_os, useGradient ? 0 : na, useGradient ? osLine : na, transpWhite, gradOsColor)\r\n\r\n// MID\r\ngrayStrong = color.new(midColor, 85)\r\ngrayWeak   = color.new(midColor, 100)\r\n\r\nfill(p_os, p_mid, useGradient ? osLine : na, useGradient ? 50 : na, grayStrong, grayWeak)\r\nfill(p_mid, p_os, useGradient ? 50 : na, useGradient ? osLine : na, grayWeak, grayStrong)\r\n\r\nfill(p_mid, p_ob, useGradient ? 50 : na, useGradient ? obLine : na, grayWeak, grayStrong)\r\nfill(p_ob, p_mid, useGradient ? obLine : na, useGradient ? 50 : na, grayStrong, grayWeak)\r\n\r\n// ALERTS \r\n// Bullish pivot break\r\nif highlightBull\r\n    alert('RSI (' + pivotSourceOpt + ') broke above pivot high', alert.freq_once_per_bar_close)\r\n\r\n// Bearish pivot break\r\nif highlightBear\r\n    alert('RSI (' + pivotSourceOpt + ') broke below pivot low', alert.freq_once_per_bar_close)\r\n\r\n// RSI crossing OB/OS\r\nif ta.crossover(pivotSrc, obLine)\r\n    alert('RSI (' + pivotSourceOpt + ') crossed above OB', alert.freq_once_per_bar_close)\r\n\r\nif ta.crossunder(pivotSrc, osLine)\r\n    alert('RSI (' + pivotSourceOpt + ') crossed below OS', alert.freq_once_per_bar_close)\r\n"
  },
  "https://www.tradingview.com/script/S7Ml4lna-Order-Block-Finder-MHA-Finverse/": {
    "id": 20087791,
    "url": "https://www.tradingview.com/script/S7Ml4lna-Order-Block-Finder-MHA-Finverse/",
    "name": "Order Block Finder [MHA Finverse]",
    "description": "Order Block Finder is a sophisticated Smart Money Concepts (SMC) tool designed to identify and visualize institutional order blocks on your charts. This indicator helps traders spot key areas where smart money has placed their orders, providing valuable insights for potential support and resistance zones.\n\n What are Order Blocks? \nOrder blocks are price zones where institutional traders have placed significant orders. This indicator identifies these zones by detecting pivot points in price action and tracking structural breaks in both internal (short-term) and swing (long-term) timeframes.\n\n  \n\n Key Features: \n\n‚Ä¢  Dual Structure Analysis \n  \n  - Internal Order Blocks: Fast-moving blocks based on 5-bar pivots for short-term trading\n  - Swing Order Blocks: Slower blocks based on 50-bar pivots for position trading\n  - Display up to 20 order blocks per type\n\n‚Ä¢  Volume Metrics \n  \n  Each order block displays two important metrics:\n  - Volume value: The total volume of the candle that formed the order block\n  - Percentage: Relative volume compared to all visible order blocks (always totals 100%)\n  Higher percentages indicate stronger institutional activity and more significant zones\n\n\n‚Ä¢  Smart Filtering System \n  - ATR Filter: Filters out high-volatility candles (>2x ATR) to focus on genuine order blocks\n  - CMR Filter: Uses Cumulative Mean Range for adaptive filtering across different market conditions\n\n‚Ä¢  Flexible Mitigation Options \n  Choose how order blocks are considered broken:\n  - High/Low: Order block breaks when price touches its boundary\n  - Close: Order block breaks only when candle closes through it\n\n‚Ä¢  Visual Customization \n  - Colored or Monochrome themes\n  - Adjustable text size for volume metrics\n  - Customizable colors for bullish and bearish blocks\n  - Historical or Present mode for clean chart analysis\n\n‚Ä¢  Built-in Alert System \n  - Real-time alerts when order blocks are mitigated\n  - Individual toggles for each alert type\n  - Clear emoji indicators (üîµ Bullish, üî¥ Bearish)\n  - Compatible with TradingView's alert system\n\n How It Works: \nThe indicator identifies order blocks by:\n1. Detecting pivot highs and lows in price structure\n2. Monitoring when price crosses these pivots (structure breaks)\n3. Finding the highest/lowest volatility-filtered candle in the pivot zone\n4. Marking this candle as an order block with its volume data\n5. Removing blocks when the price mitigates them\n\nOrder blocks with higher volume percentages represent stronger institutional interest and are typically more reliable for trading decisions.\n\n Best Practices: \n- Use Internal OBs for day trading and scalping\n- Use Swing OBs for swing trading and position entries\n- Pay attention to blocks with higher volume percentages\n- Combine with other SMC concepts for confirmation\n\nPerfect for traders who follow Smart Money Concepts, ICT methodology, and institutional trading analysis.\n\n Disclaimer: \nThis indicator is provided for educational and informational purposes only. It should not be considered as financial advice or a recommendation to buy or sell any financial instrument. Trading involves substantial risk of loss and is not suitable for all investors. Past performance does not guarantee future results. Always conduct your own research and consult with a qualified financial advisor before making any trading decisions. The creator of this indicator assumes no responsibility for any losses incurred from its use.",
    "author_name": "humayunmha",
    "likes_count": 112,
    "comments_count": 0,
    "views_count": 0,
    "created_at": "2025-12-12T00:41:45+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "FX:XAUUSD",
      "full_name": "FX:XAUUSD",
      "short_name": "XAUUSD",
      "exchange": "FX",
      "type": "commodity",
      "logo_id": "metal/gold",
      "currency_logo_id": "country/US",
      "base_currency_logo_id": null,
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/metal/gold.svg"
      ],
      "interval": "1",
      "direction": 0,
      "badge": {
        "label": "FX:XAUUSD",
        "url": "/symbols/XAUUSD/"
      }
    },
    "created": "2025-12-12",
    "updated": "2025-12-12",
    "source": "//@version=6\r\n\r\nindicator('Order Block Finder [MHA Finverse]', overlay = true, max_boxes_count = 500, max_labels_count = 500)\r\n\r\nUP_TREND = 1\r\nDOWN_TREND = 0\r\nBULL_BIAS = +1\r\nBEAR_BIAS = -1\r\n\r\nCLR_MONO_BULL = #b2b5be\r\nCLR_MONO_BEAR = #5d606b\r\n\r\nMODE_HIST = 'Historical'\r\nMODE_CURR = 'Present'\r\nTHEME_COLOR = 'Colored'\r\nTHEME_MONO = 'Monochrome'\r\n\r\nSZ_TINY = size.tiny\r\nSZ_SMALL = size.small\r\nSZ_NORMAL = size.normal\r\n\r\nFILTER_ATR = 'Atr'\r\nFILTER_CMR = 'Cumulative Mean Range'\r\n\r\nMITIGATION_CLOSE = 'Close'\r\nMITIGATION_HL = 'High/Low'\r\n\r\nGRP_SETTINGS = 'Settings'\r\nGRP_BLOCKS = 'Order Blocks'\r\nGRP_ALERTS = 'Alerts'\r\n\r\ndisplayModeInput = input.string(MODE_HIST, 'Mode', group = GRP_SETTINGS, options = [MODE_HIST, MODE_CURR])\r\nthemeInput = input.string(THEME_COLOR, 'Style', group = GRP_SETTINGS, options = [THEME_COLOR, THEME_MONO])\r\n\r\nshowInternalOBInput = input(true, 'Internal Order Blocks', group = GRP_BLOCKS, inline = 'iob')\r\ninternalOBCountInput = input.int(5, '', group = GRP_BLOCKS, minval = 1, maxval = 20, inline = 'iob')\r\nshowSwingOBInput = input(false, 'Swing Order Blocks', group = GRP_BLOCKS, inline = 'ob')\r\nswingOBCountInput = input.int(5, '', group = GRP_BLOCKS, minval = 1, maxval = 20, inline = 'ob')\r\nobFilterTypeInput = input.string(FILTER_ATR, 'Order Block Filter', group = GRP_BLOCKS, options = [FILTER_ATR, FILTER_CMR])\r\nobMitigationInput = input.string(MITIGATION_HL, 'Order Block Mitigation', group = GRP_BLOCKS, options = [MITIGATION_CLOSE, MITIGATION_HL])\r\ninternalBullOBClr = input.color(color.new(#31f5c4, 90), 'Internal Bullish OB', group = GRP_BLOCKS)\r\ninternalBearOBClr = input.color(color.new(#f77c80, 90), 'Internal Bearish OB', group = GRP_BLOCKS)\r\nswingBullOBClr = input.color(color.new(#1848cc, 90), 'Bullish OB', group = GRP_BLOCKS)\r\nswingBearOBClr = input.color(color.new(#b22833, 90), 'Bearish OB', group = GRP_BLOCKS)\r\ndisplayMetricsInput = input(true, 'Show Metrics', group = GRP_BLOCKS, tooltip = 'Display volume and percentage metrics for order blocks')\r\nmetricsTextSizeInput = input.string(SZ_NORMAL, 'Metrics Text Size', group = GRP_BLOCKS, options = [SZ_TINY, SZ_SMALL, SZ_NORMAL, 'Large', 'Huge', 'Auto'])\r\n\r\nenableAlertsInput = input(true, 'Enable Alerts', group = GRP_ALERTS)\r\nalertIntBullOBInput = input(true, 'Internal Bullish OB Mitigation', group = GRP_ALERTS)\r\nalertIntBearOBInput = input(true, 'Internal Bearish OB Mitigation', group = GRP_ALERTS)\r\nalertSwgBullOBInput = input(true, 'Swing Bullish OB Mitigation', group = GRP_ALERTS)\r\nalertSwgBearOBInput = input(true, 'Swing Bearish OB Mitigation', group = GRP_ALERTS)\r\n\r\ntype signalData\r\n    bool intBullOB = false\r\n    bool intBearOB = false\r\n    bool swgBullOB = false\r\n    bool swgBearOB = false\r\n\r\ntype biasData\r\n    int direction\r\n\r\ntype pivotData\r\n    float currLvl\r\n    float lastLvl\r\n    bool isCrossed\r\n    int barTm = time\r\n    int barIdx = bar_index\r\n\r\ntype blockData\r\n    float topVal\r\n    float bottomVal\r\n    int barTm\r\n    int direction\r\n    float volumeVal\r\n\r\nvar pivotData swgHi = pivotData.new(na, na, false)\r\nvar pivotData swgLo = pivotData.new(na, na, false)\r\nvar pivotData intHi = pivotData.new(na, na, false)\r\nvar pivotData intLo = pivotData.new(na, na, false)\r\nvar biasData swgBias = biasData.new(0)\r\nvar biasData intBias = biasData.new(0)\r\nvar array<float> adjHiArr = array.new<float>()\r\nvar array<float> adjLoArr = array.new<float>()\r\nvar array<int> tmArr = array.new<int>()\r\nvar array<blockData> swgOBArr = array.new<blockData>()\r\nvar array<blockData> intOBArr = array.new<blockData>()\r\nvar array<box> swgOBBoxArr = array.new<box>()\r\nvar array<box> intOBBoxArr = array.new<box>()\r\nvar array<label> metricsLabelArr = array.new<label>()\r\n\r\nsignalData currSig = signalData.new()\r\n\r\ngetMetricsTextSize(string s) =>\r\n    switch s\r\n        SZ_TINY => size.tiny\r\n        SZ_SMALL => size.small\r\n        SZ_NORMAL => size.normal\r\n        'Large' => size.large\r\n        'Huge' => size.huge\r\n        'Auto' => size.auto\r\n        => size.normal\r\n\r\nif barstate.isfirst\r\n    if showSwingOBInput\r\n        for i = 1 to swingOBCountInput\r\n            swgOBBoxArr.push(box.new(na, na, na, na, xloc = xloc.bar_time, extend = extend.right))\r\n    if showInternalOBInput\r\n        for i = 1 to internalOBCountInput\r\n            intOBBoxArr.push(box.new(na, na, na, na, xloc = xloc.bar_time, extend = extend.right))\r\n\r\nbearOBMitSrc = obMitigationInput == MITIGATION_CLOSE ? close : high\r\nbullOBMitSrc = obMitigationInput == MITIGATION_CLOSE ? close : low\r\natrVal = ta.atr(200)\r\nvolMeasure = obFilterTypeInput == FILTER_ATR ? atrVal : ta.cum(ta.tr) / bar_index\r\nisHighVol = (high - low) >= (2 * volMeasure)\r\nadjHi = isHighVol ? low : high\r\nadjLo = isHighVol ? high : low\r\n\r\nadjHiArr.push(adjHi)\r\nadjLoArr.push(adjLo)\r\ntmArr.push(time)\r\n\r\ngetTrendLeg(int len) =>\r\n    var legVal = 0\r\n    newHi = high[len] > ta.highest(len)\r\n    newLo = low[len] < ta.lowest(len)\r\n    if newHi\r\n        legVal := DOWN_TREND\r\n    else if newLo\r\n        legVal := UP_TREND\r\n    legVal\r\n\r\nisNewLeg(int leg) => ta.change(leg) != 0\r\nisBearLeg(int leg) => ta.change(leg) == -1\r\nisBullLeg(int leg) => ta.change(leg) == +1\r\n\r\ndetectPivots(int len, bool isInt = false) =>\r\n    currLeg = getTrendLeg(len)\r\n    isNew = isNewLeg(currLeg)\r\n    isLo = isBullLeg(currLeg)\r\n    isHi = isBearLeg(currLeg)\r\n    if isNew\r\n        if isLo\r\n            pivotData pv = isInt ? intLo : swgLo\r\n            pv.lastLvl := pv.currLvl\r\n            pv.currLvl := low[len]\r\n            pv.isCrossed := false\r\n            pv.barTm := time[len]\r\n            pv.barIdx := bar_index[len]\r\n        else\r\n            pivotData pv = isInt ? intHi : swgHi\r\n            pv.lastLvl := pv.currLvl\r\n            pv.currLvl := high[len]\r\n            pv.isCrossed := false\r\n            pv.barTm := time[len]\r\n            pv.barIdx := bar_index[len]\r\n\r\nremoveOBs(bool isInt = false) =>\r\n    array<blockData> obArr = isInt ? intOBArr : swgOBArr\r\n    for [idx, ob] in obArr\r\n        bool crossed = false\r\n        if bearOBMitSrc > ob.topVal and ob.direction == BEAR_BIAS\r\n            crossed := true\r\n            if isInt\r\n                currSig.intBearOB := true\r\n            else\r\n                currSig.swgBearOB := true\r\n        else if bullOBMitSrc < ob.bottomVal and ob.direction == BULL_BIAS\r\n            crossed := true\r\n            if isInt\r\n                currSig.intBullOB := true\r\n            else\r\n                currSig.swgBullOB := true\r\n        if crossed\r\n            obArr.remove(idx)\r\n\r\nsaveOB(pivotData pv, bool isInt = false, int dir) =>\r\n    if (not isInt and showSwingOBInput) or (isInt and showInternalOBInput)\r\n        array<float> arr = na\r\n        int idx = na\r\n        if dir == BEAR_BIAS\r\n            arr := adjHiArr.slice(pv.barIdx, bar_index)\r\n            idx := pv.barIdx + arr.indexof(arr.max())\r\n        else\r\n            arr := adjLoArr.slice(pv.barIdx, bar_index)\r\n            idx := pv.barIdx + arr.indexof(arr.min())\r\n        blockData ob = blockData.new(adjHiArr.get(idx), adjLoArr.get(idx), tmArr.get(idx), dir, volume[bar_index - idx])\r\n        array<blockData> obArr = isInt ? intOBArr : swgOBArr\r\n        if obArr.size() >= 100\r\n            obArr.pop()\r\n        obArr.unshift(ob)\r\n\r\nrenderOBs(bool isInt = false) =>\r\n    array<blockData> obArr = isInt ? intOBArr : swgOBArr\r\n    obSz = obArr.size()\r\n    if obSz > 0\r\n        maxOB = isInt ? internalOBCountInput : swingOBCountInput\r\n        array<blockData> filtOBArr = obArr.slice(0, math.min(maxOB, obSz))\r\n        array<box> bxArr = isInt ? intOBBoxArr : swgOBBoxArr\r\n        \r\n        for lbl in metricsLabelArr\r\n            lbl.delete()\r\n        metricsLabelArr.clear()\r\n        \r\n        if displayMetricsInput\r\n            float totalVolumeSum = 0\r\n            for ob in filtOBArr\r\n                totalVolumeSum += ob.volumeVal\r\n            \r\n            array<float> volumePercentages = array.new<float>()\r\n            for ob in filtOBArr\r\n                volumePercentages.push(math.floor((ob.volumeVal / totalVolumeSum) * 100))\r\n        \r\n            for [idx, ob] in filtOBArr\r\n                obClr = themeInput == THEME_MONO ? (ob.direction == BEAR_BIAS ? color.new(CLR_MONO_BEAR, 80) : color.new(CLR_MONO_BULL, 80)) : isInt ? (ob.direction == BEAR_BIAS ? internalBearOBClr : internalBullOBClr) : (ob.direction == BEAR_BIAS ? swingBearOBClr : swingBullOBClr)\r\n                box bx = bxArr.get(idx)\r\n                bx.set_top_left_point(chart.point.new(ob.barTm, na, ob.topVal))\r\n                bx.set_bottom_right_point(chart.point.new(last_bar_time, na, ob.bottomVal))\r\n                bx.set_border_color(isInt ? na : obClr)\r\n                bx.set_bgcolor(obClr)\r\n                \r\n                avgPrice = math.avg(ob.topVal, ob.bottomVal)\r\n                volPct = volumePercentages.get(idx)\r\n                metricsText = str.tostring(math.round(ob.volumeVal, 3), format.volume) + ' (' + str.tostring(volPct) + '%)'\r\n                \r\n                metricsLbl = label.new(\r\n                     bar_index - 1,\r\n                     avgPrice,\r\n                     metricsText,\r\n                     xloc.bar_index,\r\n                     color = color(na),\r\n                     textcolor = color.new(obClr, 30),\r\n                     style = label.style_label_left,\r\n                     size = getMetricsTextSize(metricsTextSizeInput))\r\n                metricsLabelArr.push(metricsLbl)\r\n        else\r\n            for [idx, ob] in filtOBArr\r\n                obClr = themeInput == THEME_MONO ? (ob.direction == BEAR_BIAS ? color.new(CLR_MONO_BEAR, 80) : color.new(CLR_MONO_BULL, 80)) : isInt ? (ob.direction == BEAR_BIAS ? internalBearOBClr : internalBullOBClr) : (ob.direction == BEAR_BIAS ? swingBearOBClr : swingBullOBClr)\r\n                box bx = bxArr.get(idx)\r\n                bx.set_top_left_point(chart.point.new(ob.barTm, na, ob.topVal))\r\n                bx.set_bottom_right_point(chart.point.new(last_bar_time, na, ob.bottomVal))\r\n                bx.set_border_color(isInt ? na : obClr)\r\n                bx.set_bgcolor(obClr)\r\n\r\nprocessStructure(bool isInt = false) =>\r\n    pivotData pv = isInt ? intHi : swgHi\r\n    biasData bs = isInt ? intBias : swgBias\r\n    extraCond = isInt ? intHi.currLvl != swgHi.currLvl : true\r\n    if ta.crossover(close, pv.currLvl) and not pv.isCrossed and extraCond\r\n        pv.isCrossed := true\r\n        bs.direction := BULL_BIAS\r\n        if (isInt and showInternalOBInput) or (not isInt and showSwingOBInput)\r\n            saveOB(pv, isInt, BULL_BIAS)\r\n    pv := isInt ? intLo : swgLo\r\n    extraCond := isInt ? intLo.currLvl != swgLo.currLvl : true\r\n    if ta.crossunder(close, pv.currLvl) and not pv.isCrossed and extraCond\r\n        pv.isCrossed := true\r\n        bs.direction := BEAR_BIAS\r\n        if (isInt and showInternalOBInput) or (not isInt and showSwingOBInput)\r\n            saveOB(pv, isInt, BEAR_BIAS)\r\n\r\ndetectPivots(50, false)\r\ndetectPivots(5, true)\r\n\r\nif showInternalOBInput\r\n    processStructure(true)\r\n\r\nif showSwingOBInput\r\n    processStructure()\r\n\r\nif showInternalOBInput\r\n    removeOBs(true)\r\n\r\nif showSwingOBInput\r\n    removeOBs()\r\n\r\nif barstate.islastconfirmedhistory or barstate.islast\r\n    if showInternalOBInput\r\n        renderOBs(true)\r\n    if showSwingOBInput\r\n        renderOBs()\r\n\r\nif enableAlertsInput\r\n    if alertIntBullOBInput and currSig.intBullOB\r\n        alert('üîµ Internal Bullish Order Block Mitigated at ' + str.tostring(close), alert.freq_once_per_bar)\r\n    if alertIntBearOBInput and currSig.intBearOB\r\n        alert('üî¥ Internal Bearish Order Block Mitigated at ' + str.tostring(close), alert.freq_once_per_bar)\r\n    if alertSwgBullOBInput and currSig.swgBullOB\r\n        alert('üîµ Swing Bullish Order Block Mitigated at ' + str.tostring(close), alert.freq_once_per_bar)\r\n    if alertSwgBearOBInput and currSig.swgBearOB\r\n        alert('üî¥ Swing Bearish Order Block Mitigated at ' + str.tostring(close), alert.freq_once_per_bar)\r\n\r\nalertcondition(currSig.intBullOB, 'Bullish Internal OB Breakout', 'Price broke bullish internal OB')\r\nalertcondition(currSig.intBearOB, 'Bearish Internal OB Breakout', 'Price broke bearish internal OB')\r\nalertcondition(currSig.swgBullOB, 'Bullish Swing OB Breakout', 'Price broke bullish swing OB')\r\nalertcondition(currSig.swgBearOB, 'Bearish Swing OB Breakout', 'Price broke bearish swing OB')"
  },
  "https://www.tradingview.com/script/DoBDt3SX-EMA21-Pullback-Buy/": {
    "id": 20085263,
    "url": "https://www.tradingview.com/script/DoBDt3SX-EMA21-Pullback-Buy/",
    "name": "EMA21 Pullback Buy",
    "description": "EMA21 Pullback Buy is a tool designed to identify constructive pullbacks to the 21-period EMA in strong uptrends.\n\nIt highlights candles where:\n\t‚Ä¢\tThe previous close was above EMA21\n\t‚Ä¢\tThe current low touches or dips below EMA21\n\t‚Ä¢\tThe candle closes back above EMA21\n\nThese candles are considered potential ‚Äúsupport tests‚Äù in a trending stock.\nYou can configure a maximum number of valid tests to avoid late-stage entries.\n\nThe script:\n\t‚Ä¢\tColors the test candles (optional)\n\t‚Ä¢\tMarks them with a small circle\n\t‚Ä¢\tTriggers a buy signal (green triangle) on the first bullish candle that breaks above the test candle‚Äôs high\n\nOptional alerts are included for both:\n\t‚Ä¢\tNew EMA21 test\n\t‚Ä¢\tBuy trigger after valid test\n\nThe goal is to help traders find low-risk entries in clean, trending stocks ‚Äî without chasing breakouts or reacting emotionally. Best used with strong RS names and proper trend context.",
    "author_name": "Kennedy08",
    "likes_count": 33,
    "comments_count": 1,
    "views_count": 0,
    "created_at": "2025-12-11T13:56:52+00:00",
    "updated_at": "2025-12-11T21:47:21+00:00",
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "NASDAQ:ALAB",
      "full_name": "NASDAQ:ALAB",
      "short_name": "ALAB",
      "exchange": "NASDAQ",
      "type": "stock",
      "logo_id": "astera-labs",
      "currency_logo_id": "country/US",
      "base_currency_logo_id": null,
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/astera-labs.svg"
      ],
      "interval": "1D",
      "direction": 0,
      "badge": {
        "label": "NASDAQ:ALAB",
        "url": "/symbols/NASDAQ-ALAB/"
      }
    },
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=6\r\nindicator(\"EMA21 Pullback Buy\", shorttitle=\"21 Pullback\", overlay=true, max_labels_count=500)\r\n\r\n// === Inputs ===\r\nemaLen            = input.int(21, \"EMA length\")\r\nsmaLen            = input.int(50, \"SMA length (trend)\")\r\nuseTrendFilter    = input.bool(true, \"Use trend filter\")\r\ntrendSensitivity  = input.string(\"Strict\", \"Trend Sensitivity\", options=[\"Strict\", \"Moderate\", \"Loose\"])\r\nuseEma10Filter    = input.bool(false, \"Use EMA10 momentum filter\")\r\nuseMaxTestLimit   = input.bool(true, \"Limit max number of EMA21 tests\")\r\nmaxTests          = input.int(6, \"Max number of EMA21 tests in trend\", minval=1, maxval=20)\r\nshowTestColor     = input.bool(true, \"Color EMA21 test candles\")\r\nshowBuySignal     = input.bool(true, \"Show buy signal after test\")\r\nemaTrendDays      = input.int(5, \"Min days above EMA21 (strict)\", minval=1)\r\nsmaUpDays         = input.int(5, \"Min days SMA50 rising (strict)\", minval=1)\r\n\r\n// === Moving averages ===\r\nema10 = ta.ema(close, 10)\r\nema21 = ta.ema(close, emaLen)\r\nsma50 = ta.sma(close, smaLen)\r\n\r\nplot(ema21, title=\"EMA21\", color=color.new(color.gray, 0))\r\nplot(sma50, title=\"SMA50\", color=color.new(color.silver, 0))\r\n\r\nemaReady = not na(ema21) and not na(sma50)\r\n\r\n// === Trend Sensitivity Logic ===\r\nemaSlopeOk              = ema21 > ema21[1] * 1.001\r\nemaAboveSmaWithMargin   = ema21 > sma50 * 1.01\r\nsmaRising               = sma50 > sma50[1]\r\nsmaRisingRecently       = ta.barssince(not smaRising) >= smaUpDays\r\naboveEmaRecently        = ta.barssince(close < ema21) >= emaTrendDays\r\nema10SlopeUp            = ema10 > ema10[1]\r\n\r\nstrictTrend = emaReady and close > ema21 and close > sma50 and\r\n              emaAboveSmaWithMargin and emaSlopeOk and\r\n              smaRisingRecently and aboveEmaRecently and\r\n              (not useEma10Filter or ema10SlopeUp)\r\n\r\nmoderateTrend = emaReady and close > ema21 and ema21 >= sma50\r\nlooseTrend    = emaReady and close > ema21\r\n\r\nuptrend = (trendSensitivity == \"Strict\"   and strictTrend) or\r\n          (trendSensitivity == \"Moderate\" and moderateTrend) or\r\n          (trendSensitivity == \"Loose\"    and looseTrend)\r\n\r\ntrendOk = useTrendFilter ? uptrend : emaReady\r\n\r\n// === EMA21 test candle ===\r\nwasAbovePrev   = emaReady and close[1] > ema21[1]\r\ntouchesOrUnder = emaReady and low <= ema21\r\nclosesAbove    = emaReady and close > ema21\r\n\r\nisTestCandidate = trendOk and wasAbovePrev and touchesOrUnder and closesAbove\r\n\r\n// === Count number of tests in uptrend ===\r\nvar int testCount = 0\r\nif not trendOk\r\n    testCount := 0\r\nelse\r\n    if isTestCandidate\r\n        testCount += 1\r\n\r\nlimitOk = not useMaxTestLimit or (testCount <= maxTests)\r\n\r\nisValidTest = isTestCandidate and limitOk\r\n\r\n// === Store info about latest valid test ===\r\nvar float lastTestHigh = na\r\nvar int   lastTestBarIndex = na\r\nvar bool  buyTriggered = false\r\n\r\nif isValidTest\r\n    lastTestHigh := high\r\n    lastTestBarIndex := bar_index\r\n    buyTriggered := false\r\n\r\n// === Reset if trend breaks or price closes below averages ===\r\nif not trendOk or close < ema21 or close < sma50\r\n    lastTestHigh := na\r\n    lastTestBarIndex := na\r\n    buyTriggered := false\r\n\r\n// === Coloring and marking of test candle ===\r\ntestBarColor = showTestColor and isValidTest ? color.new(color.white, 0) : na\r\nbarcolor(testBarColor)\r\nplotshape(isValidTest, title=\"EMA21 test\", style=shape.circle, location=location.belowbar, size=size.tiny, color=color.new(color.white, 0))\r\n\r\n// === Buy trigger: bullish candle that takes out last test high ===\r\nhasTest      = not na(lastTestHigh) and not na(lastTestBarIndex)\r\ntakesOutHigh = hasTest and high > lastTestHigh and bar_index > lastTestBarIndex\r\nisBullish    = close > open and open > ema21 and close > ema21\r\n\r\nisBuy = showBuySignal and hasTest and trendOk and not buyTriggered and takesOutHigh and isBullish\r\n\r\nif isBuy\r\n    buyTriggered := true\r\n\r\nplotshape(isBuy, title=\"Buy bullish reversal\", style=shape.triangleup, location=location.abovebar, size=size.small, color=color.new(color.lime, 0), text=\"Buy\", textcolor=color.lime)\r\n\r\n// === Alerts ===\r\nalertcondition(isValidTest, title=\"EMA21 test\", message=\"EMA21 test in strong uptrend, price went below ema21 and closed back above.\")\r\nalertcondition(isBuy, title=\"Buy bullish reversal\", message=\"First bullish reversal that takes out high of latest EMA21 test candle in strong uptrend.\")"
  },
  "https://www.tradingview.com/script/6oinSfZI-Zaka-Pro-Clear-Structure-HH-LL-MSS-Zones/": {
    "id": 20085980,
    "url": "https://www.tradingview.com/script/6oinSfZI-Zaka-Pro-Clear-Structure-HH-LL-MSS-Zones/",
    "name": "Zaka Pro: Clear Structure (HH/LL) + MSS Zones",
    "description": "Certainly! Here is a description of the Pine Script indicator you provided, focusing on its main functions and trading strategy, written in English.\n\n---\n\n## Zaka Pro: Clear Structure (HH/LL) + MSS Zones\n\nThis is a technical analysis indicator developed in Pine Script (`//@version=5`) designed to automatically identify and plot key price action structural elements based on the **Zig Zag** method, while incorporating a simplified **Market Structure Shift (MSS)** concept, often used in Smart Money Concepts (SMC) or Wyckoff trading.\n\n### Key Features:\n\n1.  **Pivot-Based Structure Identification:**\n    * The indicator uses the standard **`ta.pivothigh`** and **`ta.pivotlow`** functions, determined by the user-defined `Pivot Length` (`prd`). This forms the foundation of the price \"swing\" structure.\n2.  **Structural Labeling (HH/LL/LH/HL):**\n    * It automatically labels the resulting swing points to clearly show the prevailing trend:\n        * **HH (Higher High):** Continuation of an uptrend.\n        * **LL (Lower Low):** Continuation of a downtrend.\n        * **LH (Lower High):** A potential reversal or weakening of an uptrend.\n        * **HL (Higher Low):** A potential reversal or weakening of a downtrend.\n3.  **Zig Zag Plotting:**\n    * The indicator connects the identified pivot points with a **gray line** to visually represent the market swings.\n4.  **Market Structure Shift (MSS) Strategy:**\n    * The core strategy detects a potential **trend reversal** when the price breaks the most recent structural pivot:\n        * **Buy MSS Trigger:** Detected when the price breaks **above the last High** (`last_high`) while the market was in a confirmed **downtrend** (forming Lower Lows).\n        * **Sell MSS Trigger:** Detected when the price breaks **below the last Low** (`last_low`) while the market was in a confirmed **uptrend** (forming Higher Highs).\n5.  **Order Block / Entry Zone Plotting:**\n    * Upon detection of a confirmed MSS (reversal), the indicator plots a colored **Box** representing a potential re-entry zone:\n        * **BUY ZONE (Green Box):** Plotted after a Buy MSS (breakout to the upside). The zone is defined by the **High and Low of the two candles preceding the last swing Low** (`ob_low_top`, `ob_low_btm`). This acts as a simplified \"Order Block\" for potential long entries.\n        * **SELL ZONE (Red Box):** Plotted after a Sell MSS (breakout to the downside). The zone is defined by the **High and Low of the two candles preceding the last swing High** (`ob_high_top`, `ob_high_btm`). This acts as a simplified \"Order Block\" for potential short entries.\n6.  **Alerts:**\n    * Custom alerts are included to notify the user immediately when a Buy or Sell MSS (Market Structure Shift) is detected.\n\nIn summary, the indicator is a visual tool that simplifies price action analysis by drawing structure and highlights potential reversal points (MSS) by painting corresponding re-entry zones (Order Blocks) on the chart.",
    "author_name": "abdulrahmanalrajeh1",
    "likes_count": 51,
    "comments_count": 0,
    "views_count": 0,
    "created_at": "2025-12-11T15:58:50+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "CAPITALCOM:US100",
      "full_name": "CAPITALCOM:US100",
      "short_name": "US100",
      "exchange": "CAPITALCOM",
      "type": "index",
      "logo_id": "indices/nasdaq-100",
      "currency_logo_id": "country/US",
      "base_currency_logo_id": null,
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/indices/nasdaq-100.svg"
      ],
      "interval": "15",
      "direction": 0,
      "badge": {
        "label": "CAPITALCOM:US100",
        "url": "/symbols/CAPITALCOM-US100/"
      }
    },
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=5\r\nindicator(\"Zaka Pro: Clear Structure (HH/LL) + MSS Zones\", overlay=true, max_boxes_count=500, max_lines_count=500, max_labels_count=500)\r\n\r\n// ==========================================\r\n// 1. ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™\r\n// ==========================================\r\nprd = input.int(10, title=\"ÿ∑ŸàŸÑ ŸÖŸàÿ¨ÿ© ÿßŸÑÿ≤ŸÇ ÿ≤ÿßŸÇ (Pivot Length)\", minval=2)\r\nshow_zigzag = input.bool(true, title=\"ÿ±ÿ≥ŸÖ ÿÆÿ∑Ÿàÿ∑ ÿßŸÑÿ≤ŸÇ ÿ≤ÿßŸÇ\")\r\nshow_labels = input.bool(true, title=\"ŸÉÿ™ÿßÿ®ÿ© ÿßŸÑÿ±ŸÖŸàÿ≤ (HH, LL, etc.)\")\r\ntxt_size = input.string(size.small, \"ÿ≠ÿ¨ŸÖ ÿßŸÑÿÆÿ∑\", options=[size.tiny, size.small, size.normal])\r\n\r\n// ==========================================\r\n// 2. ÿ≠ÿ≥ÿßÿ® ÿßŸÑŸÇŸÖŸÖ ŸàÿßŸÑŸÇŸäÿπÿßŸÜ\r\n// ==========================================\r\nph = ta.pivothigh(high, prd, prd)\r\npl = ta.pivotlow(low, prd, prd)\r\n\r\n// ŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ŸÑÿ≠ŸÅÿ∏ ÿßŸÑŸÇŸäŸÖ ÿßŸÑÿ≥ÿßÿ®ŸÇÿ© ŸÑŸÑŸÖŸÇÿßÿ±ŸÜÿ©\r\nvar float prev_high_price = na\r\nvar float prev_low_price  = na\r\n\r\n// ŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ŸÑÿ≠ŸÅÿ∏ ÿ¢ÿÆÿ± ŸÇŸÖÿ© ŸàŸÇÿßÿπ (ŸÑŸÑÿßÿ≥ÿ™ÿ±ÿßÿ™Ÿäÿ¨Ÿäÿ©)\r\nvar float last_high = na\r\nvar float last_low  = na\r\nvar float last_high_prev = na // ÿßŸÑŸÇŸÖÿ© ÿßŸÑŸÑŸä ŸÇÿ®ŸÑ ÿßŸÑÿ£ÿÆŸäÿ±ÿ©\r\nvar float last_low_prev  = na // ÿßŸÑŸÇÿßÿπ ÿßŸÑŸÑŸä ŸÇÿ®ŸÑ ÿßŸÑÿ£ÿÆŸäÿ±\r\n\r\n// ŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ŸÖŸÜÿßÿ∑ŸÇ ÿßŸÑÿØÿÆŸàŸÑ (ÿ¢ÿÆÿ± ÿ¥ŸÖÿπÿ™ŸäŸÜ)\r\nvar float ob_high_top = na\r\nvar float ob_high_btm = na\r\nvar int   ob_high_idx = na\r\n\r\nvar float ob_low_top = na\r\nvar float ob_low_btm = na\r\nvar int   ob_low_idx = na\r\n\r\n// ==========================================\r\n// 3. ÿßŸÑÿ±ÿ≥ŸÖ ŸàÿßŸÑÿ™ÿ≥ŸÖŸäÿ© (Labelling Logic)\r\n// ==========================================\r\n\r\n// --- ÿπŸÜÿØ ÿßŸÉÿ™ÿ¥ÿßŸÅ ŸÇŸÖÿ© (High) ---\r\nif not na(ph)\r\n    // ÿ™ÿ≠ÿØŸäÿØ ŸÜŸàÿπ ÿßŸÑŸÇŸÖÿ©\r\n    // ÿ•ÿ∞ÿß ŸÉÿßŸÜÿ™ ÿ£ŸàŸÑ ŸÇŸÖÿ© (H) ÿ£Ÿà ÿ£ÿπŸÑŸâ ŸÖŸÜ ÿßŸÑÿ≥ÿßÿ®ŸÇÿ© (HH) ÿ£Ÿà ÿ£ÿØŸÜŸâ (LH)\r\n    lbl_txt = na(prev_high_price) ? \"H\" : (ph > prev_high_price ? \"HH\" : \"LH\")\r\n    lbl_col = (lbl_txt == \"HH\") ? color.green : color.red\r\n    \r\n    // ÿ±ÿ≥ŸÖ ÿßŸÑŸÜÿµ\r\n    if show_labels\r\n        label.new(bar_index[prd], ph, text=lbl_txt, style=label.style_label_down, color=color.new(color.white, 100), textcolor=lbl_col, size=txt_size)\r\n    \r\n    // ÿ±ÿ≥ŸÖ ÿßŸÑÿÆÿ∑\r\n    if show_zigzag and not na(last_low)\r\n        line.new(bar_index[prd], ph, bar_index - prd, last_low, color=color.gray, width=1)\r\n\r\n    // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™\r\n    prev_high_price := ph\r\n    last_high_prev := last_high\r\n    last_high := ph\r\n    \r\n    // ÿ≠ŸÅÿ∏ ŸÖŸÜÿ∑ŸÇÿ© ÿßŸÑÿ®Ÿäÿπ (ÿ¢ÿÆÿ± ÿ¥ŸÖÿπÿ™ŸäŸÜ)\r\n    idx = prd\r\n    ob_high_top := math.max(high[idx], high[idx+1])\r\n    ob_high_btm := math.min(low[idx], low[idx+1])\r\n    ob_high_idx := bar_index[idx+1]\r\n\r\n// --- ÿπŸÜÿØ ÿßŸÉÿ™ÿ¥ÿßŸÅ ŸÇÿßÿπ (Low) ---\r\nif not na(pl)\r\n    // ÿ™ÿ≠ÿØŸäÿØ ŸÜŸàÿπ ÿßŸÑŸÇÿßÿπ\r\n    // ŸáŸÑ ŸáŸà (HL) ÿ£ŸÖ (LL)\r\n    lbl_txt = na(prev_low_price) ? \"L\" : (pl < prev_low_price ? \"LL\" : \"HL\")\r\n    lbl_col = (lbl_txt == \"HL\") ? color.green : color.red\r\n    \r\n    // ÿ±ÿ≥ŸÖ ÿßŸÑŸÜÿµ\r\n    if show_labels\r\n        label.new(bar_index[prd], pl, text=lbl_txt, style=label.style_label_up, color=color.new(color.white, 100), textcolor=lbl_col, size=txt_size)\r\n\r\n    // ÿ±ÿ≥ŸÖ ÿßŸÑÿÆÿ∑\r\n    if show_zigzag and not na(last_high)\r\n        line.new(bar_index[prd], pl, bar_index - prd, last_high, color=color.gray, width=1)\r\n\r\n    // ÿ™ÿ≠ÿØŸäÿ´ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™\r\n    prev_low_price := pl\r\n    last_low_prev := last_low\r\n    last_low := pl\r\n    \r\n    // ÿ≠ŸÅÿ∏ ŸÖŸÜÿ∑ŸÇÿ© ÿßŸÑÿ¥ÿ±ÿßÿ° (ÿ¢ÿÆÿ± ÿ¥ŸÖÿπÿ™ŸäŸÜ)\r\n    idx = prd\r\n    ob_low_top := math.max(high[idx], high[idx+1])\r\n    ob_low_btm := math.min(low[idx], low[idx+1])\r\n    ob_low_idx := bar_index[idx+1]\r\n\r\n// ==========================================\r\n// 4. ÿßÿ≥ÿ™ÿ±ÿßÿ™Ÿäÿ¨Ÿäÿ© ÿßŸÑŸÉÿ≥ÿ± (MSS Trigger)\r\n// ==========================================\r\nvar bool broken_up = false\r\nvar bool broken_down = false\r\n\r\n// ÿ™ÿµŸÅŸäÿ± ÿßŸÑÿπÿØÿßÿØ ÿπŸÜÿØ ÿ™ŸÉŸàŸÜ ŸÇŸÖŸÖ ŸàŸÇŸäÿπÿßŸÜ ÿ¨ÿØŸäÿØÿ©\r\nif not na(ph) \r\n    broken_up := false\r\nif not na(pl)\r\n    broken_down := false\r\n\r\n// --- ÿ≥ŸäŸÜÿßÿ±ŸäŸà ÿßŸÑÿ¥ÿ±ÿßÿ° ---\r\n// ŸÉŸÜÿß ŸÅŸä Ÿáÿ®Ÿàÿ∑ (LL)ÿå ÿ´ŸÖ ŸÉÿ≥ÿ±ŸÜÿß ÿ¢ÿÆÿ± ŸÇŸÖÿ© (LH)\r\nis_downtrend = (last_low < last_low_prev) // ÿ™ÿ£ŸÉŸäÿØ ÿ£ŸÜŸÜÿß ŸÉŸÜÿß ŸÜÿ¥ŸÉŸÑ ŸÇŸäÿπÿßŸÜ Ÿáÿßÿ®ÿ∑ÿ©\r\nbreak_structure_up = (close > last_high) and not na(last_high)\r\n\r\nif is_downtrend and break_structure_up and not broken_up\r\n    if not na(ob_low_top)\r\n        box.new(ob_low_idx, ob_low_top, bar_index + 8, ob_low_btm, border_color=color.green, bgcolor=color.new(color.green, 60), text=\"BUY ZONE\", text_color=color.white)\r\n        alert(\"Buy MSS Detected\", alert.freq_once_per_bar_close)\r\n    broken_up := true\r\n\r\n// --- ÿ≥ŸäŸÜÿßÿ±ŸäŸà ÿßŸÑÿ®Ÿäÿπ ---\r\n// ŸÉŸÜÿß ŸÅŸä ÿµÿπŸàÿØ (HH)ÿå ÿ´ŸÖ ŸÉÿ≥ÿ±ŸÜÿß ÿ¢ÿÆÿ± ŸÇÿßÿπ (HL)\r\nis_uptrend = (last_high > last_high_prev) // ÿ™ÿ£ŸÉŸäÿØ ÿ£ŸÜŸÜÿß ŸÉŸÜÿß ŸÜÿ¥ŸÉŸÑ ŸÇŸÖŸÖ ÿµÿßÿπÿØÿ©\r\nbreak_structure_down = (close < last_low) and not na(last_low)\r\n\r\nif is_uptrend and break_structure_down and not broken_down\r\n    if not na(ob_high_top)\r\n        box.new(ob_high_idx, ob_high_top, bar_index + 8, ob_high_btm, border_color=color.red, bgcolor=color.new(color.red, 60), text=\"SELL ZONE\", text_color=color.white)\r\n        alert(\"Sell MSS Detected\", alert.freq_once_per_bar_close)\r\n    broken_down := true"
  },
  "https://www.tradingview.com/script/U1DqtWvi-Gold-Sniper-V21-M15-Holding-Master/": {
    "id": 20087401,
    "url": "https://www.tradingview.com/script/U1DqtWvi-Gold-Sniper-V21-M15-Holding-Master/",
    "name": "Gold Sniper V21: M15 Holding Master",
    "description": "Gold Sniper Entry (Follow Trend to enter)\nMy Indicator :\n- Clarify the M30 in Up/Down Trend\n- Only entry the trade in M1/M5 Timeframe to make a Sniper Entry.\n- Indicator will show when to TP before the Trend Change",
    "author_name": "dc910316",
    "likes_count": 51,
    "comments_count": 1,
    "views_count": 0,
    "created_at": "2025-12-11T22:02:03+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "VANTAGE:XAUUSD",
      "full_name": "VANTAGE:XAUUSD",
      "short_name": "XAUUSD",
      "exchange": "VANTAGE",
      "type": "commodity",
      "logo_id": "metal/gold",
      "currency_logo_id": "country/US",
      "base_currency_logo_id": null,
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/metal/gold.svg"
      ],
      "interval": "30",
      "direction": 0,
      "badge": {
        "label": "VANTAGE:XAUUSD",
        "url": "/symbols/XAUUSD/"
      }
    },
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=5\r\nindicator(\"Gold Sniper V21: M15 Holding Master\", overlay=true)\r\n\r\n// ============================\r\n// 1. ÂèÇÊï∞ËÆæÁΩÆ\r\n// ============================\r\n// --- M30 Ë∂ãÂäøÂèÇÊï∞ ---\r\ngroup_m30 = \"M30 Trend Settings\"\r\nrsi_len = input.int(6, title=\"RSI Length\", group=group_m30)\r\nrsi_sell_zone = input.int(60, title=\"RSI Sell Zone (Trend Bear)\", group=group_m30) \r\nrsi_buy_zone  = input.int(30, title=\"RSI Buy Zone (Trend Bull)\", group=group_m30)\r\n\r\n// --- M15 ÊåÅ‰ªìÂèÇÊï∞ (Êñ∞Â¢û) ---\r\ngroup_m15 = \"M15 Holding/Exit Settings (NEW)\"\r\nshow_m15_ema = input.bool(true, title=\"Show M15 EMA20 (Life Line)?\", group=group_m15)\r\nshow_m15_exit = input.bool(true, title=\"Show M15 Stoch Exit Signals?\", group=group_m15)\r\n\r\n// Stoch ÂèÇÊï∞\r\ngroup_stoch = \"Stoch Settings\"\r\nk_len    = input.int(5, title=\"Stoch K\", group=group_stoch)\r\nk_smooth = input.int(3, title=\"Stoch Smooth K\", group=group_stoch)\r\nd_smooth = input.int(3, title=\"Stoch Smooth D\", group=group_stoch)\r\n\r\n// --- M1 ËøõÂú∫ËøáÊª§ ---\r\ngroup_filter = \"M1 Entry Filters\"\r\nrsi_mid_line = input.int(50, title=\"RSI Mid-Line Filter\", group=group_filter)\r\n\r\n// --- Ê≠¢Áõà‰∏éÊä§Áõò (V17ÂäüËÉΩ) ---\r\ngroup_tp = \"Targets (ATR)\"\r\natr_period = input.int(14, title=\"ATR Period\", group=group_tp)\r\ntp1_mult = input.float(2.0, title=\"TP1 Distance\", group=group_tp)\r\ntp2_mult = input.float(4.0, title=\"TP2 Distance\", group=group_tp)\r\n\r\n// ============================\r\n// 2. ËÆ°ÁÆóÂáΩÊï∞ (ÈÄöÁî®)\r\n// ============================\r\ncalc_indicators() =>\r\n    _rsi = ta.rsi(close, rsi_len)\r\n    _k   = ta.sma(ta.stoch(close, high, low, k_len), k_smooth)\r\n    _d   = ta.sma(_k, d_smooth)\r\n    [_rsi, _k, _d, close, open, high, low]\r\n\r\n// Ëé∑Âèñ M30 Êï∞ÊçÆ (Â§ßË∂ãÂäø)\r\n[m30_rsi, m30_k, m30_d, m30_close, m30_open, m30_high, m30_low] = request.security(syminfo.tickerid, \"30\", calc_indicators(), lookahead=barmerge.lookahead_off)\r\n\r\n// ‚òÖ‚òÖ‚òÖ Ëé∑Âèñ M15 Êï∞ÊçÆ (Êñ∞Â¢ûÔºöÁî®‰∫éÊåÅ‰ªì) ‚òÖ‚òÖ‚òÖ\r\n// Ëé∑Âèñ M15 ÁöÑ EMA20 Âíå Stoch\r\n[m15_rsi, m15_k, m15_d, m15_c, m15_o, m15_h, m15_l] = request.security(syminfo.tickerid, \"15\", calc_indicators(), lookahead=barmerge.lookahead_off)\r\nm15_ema20 = request.security(syminfo.tickerid, \"15\", ta.ema(close, 20), lookahead=barmerge.lookahead_off)\r\n\r\n// ============================\r\n// 3. M30 Ë∂ãÂäøÈÄªËæë (Ê†∏ÂøÉ)\r\n// ============================\r\nm30_oversold_memory = ta.lowest(m30_rsi, 5) < rsi_buy_zone\r\nm30_overbought_memory = ta.highest(m30_rsi, 5) > rsi_sell_zone\r\nis_green_candle = m30_close >= m30_open\r\nis_red_candle   = m30_close < m30_open\r\n\r\nm30_buy_trigger  = m30_oversold_memory and ta.crossover(m30_k, m30_d) and is_green_candle and (m30_k > m30_d)\r\nm30_sell_trigger = m30_overbought_memory and ta.crossunder(m30_k, m30_d) and is_red_candle and (m30_k < m30_d)\r\n\r\nvar int trend_state = 0 \r\nvar float trend_base_price = na\r\n\r\nif m30_buy_trigger\r\n    trend_state := 1\r\n    trend_base_price := close\r\n\r\nif m30_sell_trigger\r\n    trend_state := -1\r\n    trend_base_price := close\r\n\r\n// ============================\r\n// 4. Êô∫ËÉΩÊ≠¢Áõà & M15 Êä§ÁõòÁ∫ø\r\n// ============================\r\natr = ta.atr(atr_period)\r\nfloat tp1_level = trend_state == 1 ? trend_base_price + (atr * tp1_mult) : trend_base_price - (atr * tp1_mult)\r\nfloat tp2_level = trend_state == 1 ? trend_base_price + (atr * tp2_mult) : trend_base_price - (atr * tp2_mult)\r\n\r\n// ============================\r\n// 5. M15 Á¶ªÂú∫ÈÄªËæë (NEW)\r\n// ============================\r\n// ÈÄªËæëÔºöÂ¶ÇÊûúÂÅöÂ§öÔºå‰ΩÜ M15 Stoch Ê≠ªÂèâ -> ÊèêÁ§∫Á¶ªÂú∫\r\nm15_exit_long = trend_state == 1 and ta.crossunder(m15_k, m15_d) and show_m15_exit\r\n// ÈÄªËæëÔºöÂ¶ÇÊûúÂÅöÁ©∫Ôºå‰ΩÜ M15 Stoch ÈáëÂèâ -> ÊèêÁ§∫Á¶ªÂú∫\r\nm15_exit_short = trend_state == -1 and ta.crossover(m15_k, m15_d) and show_m15_exit\r\n\r\n// ============================\r\n// 6. ËßÜËßâÂåñ (ÁªòÂõæ)\r\n// ============================\r\n// M30 ‰∫ëÂ±Ç\r\nplot_base = plot(trend_state != 0 ? trend_base_price : na, color=color.gray, style=plot.style_line, title=\"Base\")\r\nplot_curr = plot(trend_state != 0 ? close : na, display=display.none)\r\ncloud_color = trend_state == 1 ? color.new(color.blue, 85) : trend_state == -1 ? color.new(color.red, 85) : na\r\nfill(plot_base, plot_curr, color=cloud_color, title=\"Cloud\")\r\n\r\n// ‚òÖ‚òÖ‚òÖ ÁªòÂà∂ M15 EMA20 ÁîüÂëΩÁ∫ø ‚òÖ‚òÖ‚òÖ\r\n// Â§öÂ§¥ÊòæÁ§∫Ê©ôËâ≤ÔºåÁ©∫Â§¥ÊòæÁ§∫Á¥´Ëâ≤ÔºåÁ≤óÁ∫ø\r\nplot(show_m15_ema and trend_state != 0 ? m15_ema20 : na, color=trend_state == 1 ? color.orange : color.purple, linewidth=3, style=plot.style_stepline, title=\"M15 EMA20 (Hold Line)\")\r\n\r\n// ÁªòÂà∂ TP Á∫ø\r\nplot(trend_state != 0 ? tp1_level : na, color=color.green, style=plot.style_circles, linewidth=1, title=\"TP1\")\r\nplot(trend_state != 0 ? tp2_level : na, color=color.green, style=plot.style_cross, linewidth=2, title=\"TP2\")\r\n\r\n// M30 Ë∂ãÂäøÊ†áÁ≠æ\r\nplotshape(m30_buy_trigger, title=\"M30 Trend Start\", style=shape.labelup, location=location.belowbar, color=color.blue, size=size.normal, text=\"UP\", textcolor=color.white)\r\nplotshape(m30_sell_trigger, title=\"M30 Trend Start\", style=shape.labeldown, location=location.abovebar, color=color.red, size=size.normal, text=\"DOWN\", textcolor=color.white)\r\n\r\n// ============================\r\n// 7. M1 ËøõÂú∫‰ø°Âè∑\r\n// ============================\r\n[curr_rsi, curr_k, curr_d, curr_c, curr_o, curr_h, curr_l] = calc_indicators()\r\nis_rsi_low = curr_rsi < rsi_mid_line\r\nis_rsi_high = curr_rsi > rsi_mid_line\r\n\r\nvalid_long = trend_state == 1 and ta.crossover(curr_k, curr_d) and barstate.isconfirmed and is_rsi_low\r\nvalid_short = trend_state == -1 and ta.crossunder(curr_k, curr_d) and barstate.isconfirmed and is_rsi_high\r\n\r\nplotshape(valid_long, title=\"M1 Buy\", style=shape.triangleup, location=location.belowbar, color=color.blue, size=size.small, text=\"BUY\", textcolor=color.blue)\r\nplotshape(valid_short, title=\"M1 Sell\", style=shape.triangledown, location=location.abovebar, color=color.red, size=size.small, text=\"SELL\", textcolor=color.red)\r\n\r\n// ‚òÖ‚òÖ‚òÖ M15 Á¶ªÂú∫ÊèêÁ§∫Ê†áÁ≠æ ‚òÖ‚òÖ‚òÖ\r\nplotshape(m15_exit_long, title=\"M15 Exit Hint\", style=shape.xcross, location=location.abovebar, color=color.gray, size=size.small, text=\"EXIT?\", textcolor=color.gray)\r\nplotshape(m15_exit_short, title=\"M15 Exit Hint\", style=shape.xcross, location=location.belowbar, color=color.gray, size=size.small, text=\"EXIT?\", textcolor=color.gray)\r\n\r\n// ============================\r\n// 8. Áä∂ÊÄÅÈù¢Êùø\r\n// ============================\r\nvar table statusTable = table.new(position.bottom_right, 2, 6, border_width=1)\r\nif barstate.islast\r\n    table.cell(statusTable, 0, 0, \"GOLD SNIPER V21\", bgcolor=color.black, text_color=color.white)\r\n    table.cell(statusTable, 1, 0, \"M15 HOLDING\", bgcolor=color.black, text_color=color.white)\r\n\r\n    // 1. Ë∂ãÂäø\r\n    table.cell(statusTable, 0, 1, \"Trend Cloud\", bgcolor=color.gray, text_color=color.white)\r\n    table.cell(statusTable, 1, 1, trend_state == 1 ? \"UP (Blue)\" : trend_state == -1 ? \"DOWN (Red)\" : \"WAITING\", bgcolor=trend_state == 1 ? color.blue : trend_state == -1 ? color.red : color.black, text_color=color.white)\r\n    \r\n    // 2. M15 EMA ‰ª∑Ê†º (Êñ∞)\r\n    table.cell(statusTable, 0, 2, \"M15 EMA20 Line\", bgcolor=color.gray, text_color=color.white)\r\n    table.cell(statusTable, 1, 2, str.tostring(m15_ema20, \"#.##\"), text_color=color.purple)\r\n\r\n    // 3. M15 Stoch (Êñ∞) - Â∏Æ‰Ω†ÁúãM15ÊúâÊ≤°ÊúâÂèçËΩ¨\r\n    table.cell(statusTable, 0, 3, \"M15 Stoch K/D\", bgcolor=color.gray, text_color=color.white)\r\n    string m15_stoch_msg = str.tostring(m15_k, \"#.#\") + \" / \" + str.tostring(m15_d, \"#.#\")\r\n    // Â¶ÇÊûúÂÅöÁ©∫Êó∂ M15 ÈáëÂèâ‰∫ÜÔºåÊòæÁ§∫Á∫¢Ëâ≤Ë≠¶Âëä\r\n    bool warning = (trend_state == -1 and m15_k > m15_d) or (trend_state == 1 and m15_k < m15_d)\r\n    table.cell(statusTable, 1, 3, m15_stoch_msg, bgcolor=warning ? color.orange : color.black, text_color=color.white)\r\n\r\n    // 4. M30 Candle\r\n    table.cell(statusTable, 0, 4, \"M30 Candle\", bgcolor=color.gray, text_color=color.white)\r\n    table.cell(statusTable, 1, 4, is_green_candle ? \"GREEN\" : \"RED\", bgcolor=is_green_candle ? color.green : color.red, text_color=color.white)\r\n\r\n    // 5. RSI ËøáÊª§\r\n    string filter_msg = \"WAITING\"\r\n    color filter_col = color.gray\r\n    if trend_state == 1\r\n        filter_msg := is_rsi_low ? \"OK (<50)\" : \"NO (>50)\"\r\n        filter_col := is_rsi_low ? color.green : color.orange\r\n    else if trend_state == -1\r\n        filter_msg := is_rsi_high ? \"OK (>50)\" : \"NO (<50)\"\r\n        filter_col := is_rsi_high ? color.green : color.orange\r\n    table.cell(statusTable, 0, 5, \"M1 Entry Check\", bgcolor=color.gray, text_color=color.white)\r\n    table.cell(statusTable, 1, 5, filter_msg, bgcolor=filter_col, text_color=color.white)\r\n\r\n// Alerts\r\nalertcondition(m30_buy_trigger, title=\"Alert: M30 UP Trend\", message=\"Gold Sniper: UP Trend!\")\r\nalertcondition(valid_long, title=\"Alert: M1 Buy\", message=\"Gold Sniper: M1 BUY Signal!\")\r\nalertcondition(m15_exit_long or m15_exit_short, title=\"Alert: M15 Exit Suggestion\", message=\"Gold Sniper: Consider Exiting (M15 Reversal)\")"
  },
  "https://www.tradingview.com/script/lIb03e0X-Pivot-Oscillator/": {
    "id": 20090485,
    "url": "https://www.tradingview.com/script/lIb03e0X-Pivot-Oscillator/",
    "name": "Pivot Oscillator",
    "description": "‚ñà OVERVIEW\nPivot Oscillator is a versatile oscillator that measures market strength by comparing the current price to local price pivots. Values are scaled by ATR, normalized to a 0‚Äì100 range, and displayed along with an SMA line.\nOscillator: generates signals suitable for pullback strategies.\nSMA line: serves as a momentum indicator.\n\n‚ñà CONCEPTS\nPivot Oscillator is designed with dual functionality:\n- Oscillator & signals: ideal for pullback strategies, detecting local highs/lows and short-term reversals.\n- SMA (Momentum): shows stable market-side dominance and filters price impulses.\n\nCalculation logic:\n- Oscillator = closing price ‚àí pivot line (derived from average high/low pivots).\nScaled by ATR and normalized to 0‚Äì100:\n50 ‚Äì bullish dominance,\n< 50 ‚Äì bearish dominance.\n\nSMA is computed from smoothed oscillator values and serves as a momentum indicator.\n\n‚ñà FEATURES\nPivot Calculation:\n- Pivot Length (lenSwing) ‚Äì the number of bars used to identify local pivots (highs/lows). Higher values filter only larger extremes, while lower values make the oscillator react faster to local highs and lows.\n- Pivot Level (pivotLevel) ‚Äì determines the position of the pivot line between the average low and high pivots. A value of 0.5 places the pivotLine exactly halfway between the average high and low pivots; values closer to 0 or 1 shift the line toward the low or high pivots, respectively.\n- Pivot Lookback (lookback) ‚Äì the number of recent pivots used to calculate the average pivot, which smooths the pivotLine and reduces noise caused by individual extremes.\n- Oscillator calculation: closing price ‚àí pivotLine (average of pivots computed from the above parameters).\n\nThe pivotLine is then scaled by ATR and normalized to a 0‚Äì100 range.\nATR Scaling:\n- ATR period (atrLen)\n- Multipliers (multUp / multDown) for upper and lower scaling.\n\nDynamic Colors:\n- Oscillator > 50 ‚Üí green (bullish)\n- Oscillator < 50 ‚Üí red (bearish)\n\nSMA Line (Momentum):\n- Smoothed oscillator (SMA) serves as a momentum indicator.\n- Dynamic color indicates direction of SMA.\n- Helps identify dominant market side and trend.\n\nOverbought / Oversold Zones:\n- Configurable OB/OS levels for both oscillator and SMA.\n- Dynamic band colors: change depending on SMA relative to maOverbought / maOversold.\n- Provides visual confirmation for potential corrections or strong momentum.\n\nGradients & Visualization:\n- Oscillator and SMA gradients (3 layers) with adjustable transparency.\n- Gradient visualization for OB/OS zones and oscillator.\n- Full customization of colors, line width, and transparency.\n\nSignals:\n- Oscillator leaving oversold zone ‚Üí long signal\n- Oscillator leaving overbought zone ‚Üí short signal\n- OB/OS band colors dynamically reflect SMA levels for additional confirmation.\n\nAlerts:\n- OB/OS cross alerts.\n\n‚ñà HOW TO USE\nAdd the indicator to your TradingView chart ‚Üí Indicators ‚Üí search for ‚ÄúPivot Oscillator‚Äù.\n\nParameter Configuration:\n- Pivot Settings: pivot length, pivot level, pivot lookback.\n- ATR Settings: ATR period, scaling multipliers.\n- Threshold Levels: OB/OS levels for oscillator and SMA.\n- Signal Settings: SMA length, extra smoothing.\n- Style Settings: bullish/bearish colors, OB/OS lines, midline, text colors.\n- Gradient Settings: enable/disable gradients and transparency.\n\nSignal Interpretation:\nBUY (Long):\n- Oscillator leaves the oversold zone (OS crossover).\n- OB/OS band color may additionally confirm the signal when SMA < maOversold.\n\nSELL (Short):\n- Oscillator leaves the overbought zone (OB crossunder).\n- OB/OS band color may additionally confirm the signal when SMA > maOverbought.\n\n‚ñà APPLICATIONS\nPivot Oscillator and SMA can be scaled for different strategies:\n- Pullback strategies: oscillator detects local highs/lows.\n- Momentum / Trend: SMA shows market-side dominance and trend direction.\n\nAdjust pivot and ATR parameters:\n- Lower settings: faster reaction, suitable for scalping or intraday trading.\n- Higher settings: more stable readings, suitable for swing trading or longer timeframes.\n\n‚ñà NOTES\n- In strong trends, the oscillator may remain in extreme zones for extended periods ‚Äì reflects dominance, not necessarily a reversal.\n- OB/OS levels should be adapted to the instrument and pivot/ATR settings.\n- Works best when combined with other tools: support/resistance, market structure, and volume analysis.",
    "author_name": "Uncle_the_shooter",
    "likes_count": 58,
    "comments_count": 0,
    "views_count": 0,
    "created_at": "2025-12-12T11:15:21+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "BINANCE:BTCUSDT",
      "full_name": "BINANCE:BTCUSDT",
      "short_name": "BTCUSDT",
      "exchange": "BINANCE",
      "type": "spot",
      "logo_id": null,
      "currency_logo_id": "crypto/XTVCUSDT",
      "base_currency_logo_id": "crypto/XTVCBTC",
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/crypto/XTVCBTC.svg",
        "https://s3-symbol-logo.tradingview.com/crypto/XTVCUSDT.svg"
      ],
      "interval": "240",
      "direction": 0,
      "badge": {
        "label": "BINANCE:BTCUSDT",
        "url": "/symbols/BTCUSDT/"
      }
    },
    "created": "2025-12-12",
    "updated": "2025-12-12",
    "source": "// This Pine Script¬Æ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// ¬© Uncle_the_shooter\r\n\r\n//@version=6\r\nindicator('Pivot Oscillator', overlay=false, max_lines_count=500, max_labels_count=500, precision=2)\r\n\r\n// PIVOT SETTINGS (user inputs) \r\nlenSwing = input.int(5, 'Pivot Length', minval=1, group='Pivot Settings')\r\npivotLevel = input.float(0.5, 'Pivot Level', minval=0.0, maxval=1.0, step=0.01, group='Pivot Settings')\r\nlookback = input.int(5, 'Pivot Lookback', minval=1, group='Pivot Settings')\r\n\r\n// ATR SCALING \r\natrLen = input.int(14, 'ATR Length', minval=1, group='ATR Settings')\r\nmultUp = input.float(15.0, 'ATR Multiplier Up', minval=0.1, group='ATR Settings')\r\nmultDown = input.float(15.0, 'ATR Multiplier Down', minval=0.1, group='ATR Settings')\r\n\r\n// THRESHOLD LEVELS \r\nobLevel = input.float(70, 'Overbought Level', minval=51, maxval=99, group='Threshold Levels')\r\nosLevel = input.float(30, 'Oversold Level', minval=1, maxval=49, group='Threshold Levels')\r\nmaOverbought = input.float(60, 'MA Overbought Threshold', minval=51, maxval=99, group='Threshold Levels')\r\nmaOversold = input.float(40, 'MA Oversold Threshold', minval=1, maxval=49, group='Threshold Levels')\r\n\r\n// SIGNAL SETTINGS \r\nsignalLength = input.int(14, 'SMA Length for Signal', group='Signal Settings')\r\nextraSmooth = input.int(10, \"SMA Smoothing\", minval=1, group='Signal Settings')\r\n\r\n// COLORS \r\nbullColor = input.color(color.rgb(22,193,67), 'Bullish Color', group='Style Settings')\r\nbearColor = input.color(color.rgb(229,11,11), 'Bearish Color', group='Style Settings')\r\nsignalColorBull = input.color(color.rgb(22,193,67), 'Signal SMA Bullish', group='Style Settings')  \r\nsignalColorBear = input.color(color.rgb(229,11,11), 'Signal SMA Bearish', group='Style Settings')     \r\nobColor = input.color(color.red, 'Overbought Line Color', group='Style Settings')\r\nosColor = input.color(color.green, 'Oversold Line Color', group='Style Settings')\r\nmidLineColor = input.color(color.gray, 'Midline 50 Color', group='Style Settings')  // <--- nowy input\r\ntextColor = input.color(color.white, 'Text Color', group='Style Settings')\r\n\r\n// GRADIENT SETTINGS\r\nshowOverboughtGradient = input.bool(true, 'Show Overbought Gradient', group='Gradient Settings')\r\nshowOversoldGradient = input.bool(true, 'Show Oversold Gradient', group='Gradient Settings')\r\nshowOscillatorGradient = input.bool(true, 'Show Oscillator Gradient', group='Gradient Settings')\r\nshowMaGradient = input.bool(true, 'Show Moving Average Gradient', group='Gradient Settings')\r\nfillEnabled = input.bool(true, 'Enable Gradient Fill', group='Gradient Settings')\r\nfillTransparency = input.int(75, 'Gradient Fill Transparency', minval=0, maxval=100, group='Gradient Settings')\r\nbandTransparency = input.int(50, 'Band/Label Gradient Transparency', minval=0, maxval=100, group='Gradient Settings')\r\n\r\n// INTERNAL VARIABLES \r\nrangeUpper = 60\r\nrangeLower = 5\r\nvar int gradientTransparency = 85\r\n\r\n// PIVOTS CALCULATION\r\nph = ta.pivothigh(high, lenSwing, lenSwing)\r\npl = ta.pivotlow(low, lenSwing, lenSwing)\r\n\r\nvar float[] phArray = array.new_float()\r\nvar float[] plArray = array.new_float()\r\n\r\nif not na(ph)\r\n    array.push(phArray, ph)\r\n    if array.size(phArray) > lookback\r\n        array.shift(phArray)\r\n\r\nif not na(pl)\r\n    array.push(plArray, pl)\r\n    if array.size(plArray) > lookback\r\n        array.shift(plArray)\r\n\r\navgPH = array.size(phArray) > 0 ? array.avg(phArray) : na\r\navgPL = array.size(plArray) > 0 ? array.avg(plArray) : na\r\n\r\npivotLine = not na(avgPH) and not na(avgPL) ? avgPL + (avgPH - avgPL) * pivotLevel : na\r\n\r\nosc_raw = close - nz(pivotLine)\r\n\r\n// ATR SCALING\r\natr = ta.atr(atrLen)\r\natr_safe = atr > 0 ? atr : 1\r\nupper_bound = atr_safe * multUp\r\nlower_bound = atr_safe * multDown\r\n\r\nfloat osc_scaled = 50.0\r\nif osc_raw > 0\r\n    osc_scaled := 50.0 + 50.0 * (osc_raw / upper_bound)\r\nelse if osc_raw < 0\r\n    osc_scaled := 50.0 + 50.0 * (osc_raw / lower_bound)\r\nelse\r\n    osc_scaled := 50.0\r\nosc_scaled := math.max(1.0, math.min(100.0, osc_scaled))\r\n\r\noscSignal = ta.sma(osc_scaled, signalLength)\r\n\r\n// DYNAMIC COLORS FOR OB/OS \r\nob_gradient_color = oscSignal >= maOverbought ? obColor : color.gray\r\nos_gradient_color = oscSignal <= maOversold ? osColor : color.gray\r\n\r\n// PLOTTING \r\nhline(obLevel, 'Overbought', color=obColor, linestyle=hline.style_dashed, linewidth=1)\r\nplot(showOverboughtGradient ? obLevel : na, 'OB Gradient', color=color.new(ob_gradient_color, bandTransparency), linewidth=8, editable=false)\r\n\r\nhline(osLevel, 'Oversold', color=osColor, linestyle=hline.style_dashed, linewidth=1)\r\nplot(showOversoldGradient ? osLevel : na, 'OS Gradient', color=color.new(os_gradient_color, bandTransparency), linewidth=8, editable=false)\r\n\r\n// MIDLINE 50\r\nhline(50, 'Midline 50', color=midLineColor, linestyle=hline.style_dashed, linewidth=1)\r\n\r\nhline(1, 'Min', color=color.new(color.gray, 80), linestyle=hline.style_dotted)\r\nhline(100, 'Max', color=color.new(color.gray, 80), linestyle=hline.style_dotted)\r\n\r\nlineColor = osc_raw > 0 ? bullColor : bearColor\r\npOsc = plot(osc_scaled, 'Oscillator 1‚Äì100', color=lineColor, linewidth=2)\r\nplot(showOscillatorGradient ? osc_scaled : na, 'Osc Gradient', color=color.new(lineColor, gradientTransparency), linewidth=10)\r\n\r\n// SMA SMOOTHED + DYNAMIC COLOR + GRADIENT\r\nsmoothSignal = ta.sma(oscSignal, extraSmooth) \r\n\r\ndynSignalColor =\r\n      smoothSignal > smoothSignal[1] ? signalColorBull :  \r\n      smoothSignal < smoothSignal[1] ? signalColorBear :  \r\n      color.gray                                         \r\n\r\n// SMA PLOT\r\npSignal = plot(showMaGradient ? smoothSignal : smoothSignal, \"Signal SMA\", dynSignalColor, 2)\r\n\r\n// SMA GRADIENT ‚Äì 3 layers\r\nplot(showMaGradient ? smoothSignal : na, \"\", color.new(dynSignalColor, 60), 5)\r\nplot(showMaGradient ? smoothSignal : na, \"\", color.new(dynSignalColor, 35), 3)\r\nplot(showMaGradient ? smoothSignal : na, \"\", color.new(dynSignalColor, 0), 1)\r\n\r\n// GRADIENT FILL \r\npMid1 = plot(osc_scaled * 0.8 + 50 * 0.2, color=na, display=display.none)\r\npMid2 = plot(osc_scaled * 0.6 + 50 * 0.4, color=na, display=display.none)\r\npMid3 = plot(osc_scaled * 0.4 + 50 * 0.6, color=na, display=display.none)\r\npMid4 = plot(osc_scaled * 0.2 + 50 * 0.8, color=na, display=display.none)\r\n\r\nfill(pOsc, pMid1, color=fillEnabled ? color.new(lineColor, fillTransparency) : na)\r\nfill(pMid1, pMid2, color=fillEnabled ? color.new(lineColor, fillTransparency + 5) : na)\r\nfill(pMid2, pMid3, color=fillEnabled ? color.new(lineColor, fillTransparency + 10) : na)\r\nfill(pMid3, pMid4, color=fillEnabled ? color.new(lineColor, fillTransparency + 15) : na)\r\n\r\n// SIGNALS\r\nlongSignalObos = ta.crossover(osc_scaled, osLevel)\r\nshortSignalObos = ta.crossunder(osc_scaled, obLevel)\r\n\r\n// plotshape\r\nplotshape(longSignalObos ? osc_scaled : na, location=location.bottom, color=osColor, style=shape.triangleup, size=size.tiny, title='Buy (OS)')\r\nplotshape(shortSignalObos ? osc_scaled : na, location=location.top, color=obColor, style=shape.triangledown, size=size.tiny, title='Sell (OB)')\r\n\r\n// ALERTS \r\nalertcondition(longSignalObos, 'Buy (Oversold)', 'Oscillator crossed above oversold.')\r\nalertcondition(shortSignalObos, 'Sell (Overbought)', 'Oscillator crossed below overbought.')\r\n"
  },
  "https://www.tradingview.com/script/8I2576zL-Mutanabby-AI-ONEUSDT-MR1/": {
    "id": 20085532,
    "url": "https://www.tradingview.com/script/8I2576zL-Mutanabby-AI-ONEUSDT-MR1/",
    "name": "Mutanabby_AI | ONEUSDT_MR1 ",
    "description": "\nONEUSDT Mean-Reversion Strategy | 74.68% Win Rate | 417% Net Profit\n\n\nThis is a long-only mean-reversion strategy designed specifically for ONEUSDT on the 1-hour timeframe. The core logic identifies oversold conditions following sharp declines and enters positions when selling pressure exhausts, capturing the subsequent recovery bounce.\n\nBacktested Period: June 2019 ‚Äì December 2025 (~6 years)\n\n Performance Summary\n\n| Metric | Value |\n|--------|-------|\n| Net Profit | +417.68% |\n| Win Rate | 74.68% |\n| Profit Factor | 4.019 |\n| Total Trades | 237 |\n| Sharpe Ratio | 0.364 |\n| Sortino Ratio | 1.917 |\n| Max Drawdown | 51.08% |\n| Avg Win | +3.14% |\n| Avg Loss | -2.30% |\n| Buy & Hold Return | -80.44% |\n\n\nStrategy Logic :\n\n Entry Conditions (Long Only): \n\nThe strategy seeks confluence of three conditions that identify exhausted selling:\n\n1. Prior Move Filter:*The price change from 5 bars ago to 3 bars ago must be ‚â• -7% (ensures we're not entering during freefall)\n\n2. Current Move Filter: The price change over the last 2 bars must be ‚â§ 0% (confirms momentum is stalling or reversing)\n\n3.  Three-Bar Decline: The price change from 5 bars ago to 3 bars ago must be ‚â§ -5% (confirms a significant recent drop occurred)\n\nWhen all three conditions align, the strategy identifies a potential reversal point where sellers are exhausted.\n\n Exit Conditions: \n\n- Primary Exit: Close above the previous bar's high while the open of the previous bar is at or below the close from 9 bars ago (profit-taking on strength)\n- Trailing Stop: 11x ATR trailing stop that locks in profits as price rises\n\n\n Risk Management\n \n- Position Sizing:Fixed position based on account equity divided by entry price\n- Trailing Stop:11√ó ATR (14-period) provides wide enough room for crypto volatility while protecting gains\n- Pyramiding:Up to 4 orders allowed (can scale into winning positions)\n- **Commission:** 0.1% per trade (realistic exchange fees included)\n\n\n\n Important Disclaimers\n \n\n‚ö†Ô∏è This is NOT financial advice.\n\n- Past performance does not guarantee future results\n- Backtest results may contain look-ahead bias or curve-fitting\n- Real trading involves slippage, liquidity issues, and execution delays\n- This strategy is optimized for ONEUSDT specifically ‚Äî results may differ on other pairs\n- Always test  before risking real capital\n\n\n Recommended Usage\n \n- Timeframe:*1H (as designed)\n- Pair: ONEUSDT (Binance)\n- Account Size: Ensure sufficient capital to survive max drawdown\n\n\n Source Code\n \n\n\n Feedback Welcome\n \n\nI'm sharing this strategy freely for educational purposes. Please:\n- Drop a comment with your backtesting results any you analysis \n- Share any modifications that improve performance\n- Let me know if you spot any issues in the logic\n\n Happy trading\n \n\n\n\nAs a quant trader, do you think this strategy will survive in live trading?\nYes or No? And why?\nI want to hear from you guys",
    "author_name": "Mutanabby_AI",
    "likes_count": 36,
    "comments_count": 1,
    "views_count": 0,
    "created_at": "2025-12-11T14:39:46+00:00",
    "updated_at": null,
    "script_type": "strategy",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "BINANCE:ONEUSDT",
      "full_name": "BINANCE:ONEUSDT",
      "short_name": "ONEUSDT",
      "exchange": "BINANCE",
      "type": "spot",
      "logo_id": null,
      "currency_logo_id": "crypto/XTVCUSDT",
      "base_currency_logo_id": "crypto/XTVCONE",
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/crypto/XTVCONE.svg",
        "https://s3-symbol-logo.tradingview.com/crypto/XTVCUSDT.svg"
      ],
      "interval": "60",
      "direction": 0,
      "badge": {
        "label": "BINANCE:ONEUSDT",
        "url": "/symbols/ONEUSDT/"
      }
    },
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=5\r\nstrategy(\"ONEUSDT(1)_MR1\", overlay=true, initial_capital=100, default_qty_type=strategy.fixed, default_qty_value=100)\r\n\r\n// Input Parameters\r\nvar float TRAIL_ATR_MULT = 11.0\r\nvar int ATR_LENGTH = 14\r\nvar float ACCOUNT_SIZE = 100.0\r\n\r\n\r\n// Tracking Variables\r\nvar int profx = 0\r\nvar float trailLevel = na\r\nvar int barsInTrade = 0\r\n\r\n// Calculate Technical Indicators\r\natr = ta.atr(ATR_LENGTH)\r\n\r\n// Position Size Calculation\r\npositionSize = math.floor(ACCOUNT_SIZE / close)\r\n\r\n// Calculate Price Changes\r\npercentChange2Bars(offset) =>\r\n    ((close[offset] - close[offset+2]) / close[offset+2]) * 100\r\n\r\n// Entry Conditions\r\n\r\npriorMove = percentChange2Bars(3) >= -7\r\ncurrentMove = percentChange2Bars(0) <= 0\r\nthreeBarBack = percentChange2Bars(3) <= -5\r\n\r\nlongCondition =  priorMove and currentMove and threeBarBack\r\n\r\n// Exit Conditions\r\nexitCondition = close > high[1] and open[1] <= close[9]\r\n\r\n// Track Trade Duration and Profitable Closes\r\nif (strategy.position_size > 0)\r\n    barsInTrade := barsInTrade + 1\r\n    if (close >= strategy.position_avg_price)\r\n        profx := profx + 1\r\nelse\r\n    barsInTrade := 0\r\n\r\n// Trailing Stop Logic\r\nif (strategy.position_size > 0)\r\n    float newTrail = close - (atr * TRAIL_ATR_MULT)\r\n    trailLevel := na(trailLevel) ? newTrail : math.max(trailLevel, newTrail)\r\nelse\r\n    trailLevel := na\r\n\r\n// Execute Strategy\r\nif (longCondition)\r\n    strategy.entry(\"Long\", strategy.long, qty=positionSize)\r\n    profx := 0\r\n\r\n// Exit Conditions\r\nif (strategy.position_size > 0)\r\n    // Trailing Stop\r\n    strategy.exit(\"Trail\", \"Long\", stop=trailLevel)\r\n    \r\n    // Signal Exit\r\n    if (exitCondition)\r\n        strategy.close(\"Long\", comment=\"Signal Exit\")\r\n    \r\n\r\n\r\n// Visualization\r\nplot(strategy.position_size > 0 ? trailLevel : na, \"Trailing Stop\", color=color.red, style=plot.style_stepline)\r\nplotshape(longCondition, \"Entry\", location=location.belowbar, color=color.green, style=shape.triangleup, size=size.small)\r\nplotshape(exitCondition and strategy.position_size > 0, \"Exit\", location=location.abovebar, color=color.red, style=shape.triangledown, size=size.small)"
  },
  "https://www.tradingview.com/script/PDbtXoSD-TRI-Multi-Timeframe-Support-and-Resistance/": {
    "id": 20087069,
    "url": "https://www.tradingview.com/script/PDbtXoSD-TRI-Multi-Timeframe-Support-and-Resistance/",
    "name": "TRI - Multi-Timeframe Support and Resistance",
    "description": "TRI - MULTI-TIMEFRAME SUPPORT & RESISTANCE v3.0.0 \n\n DESCRIPTION: \nAdvanced multi-timeframe Support & Resistance indicator using ta.pivothigh/ta.pivotlow\nto display pivot-based S/R levels from higher timeframes on your current chart.\nFeatures smart pivot positioning, dynamic level merging, and comprehensive alert system.\n\n KEY FEATURES: \n \n Multi-timeframe pivot detection using ta.pivothigh/ta.pivotlow on candle body\n Smart pivot positioning - pivots are placed on the correct candle type (bullish for highs, bearish for lows)\n Automatic timeframe selection - configure different S/R timeframes for each chart timeframe\n Dynamic level merging - nearby levels are merged based on ATR tolerance (newer wins)\n Mitigated level tracking - shows recently broken levels with distinct styling\n Smart visualization - always shows N closest levels above and below current price\n Comprehensive alert system with 9 different alert types\n Significant breakout detection with configurable parameters\n Memory efficient - automatic cleanup of expired levels\n \n\n HOW IT WORKS: \nThe indicator uses ta.pivothigh() and ta.pivotlow() on the selected higher timeframe.\nPivot highs are positioned on bullish candles (using close price).\nPivot lows are positioned on bearish candles (using close price).\nIf the pivot candle is not the correct type, it searches back up to 5 candles.\nOnly unbreached levels are displayed as active support/resistance.\nWhen a level is breached, it becomes a \"mitigated level\" with distinct styling.\nMitigation is checked only after the first candle following the pivot (to avoid false triggers).\n\n LEVEL MERGING: \nNearby levels of the same type are automatically merged based on ATR tolerance.\nThe newer pivot always wins, replacing older levels within the tolerance range.\nTolerance = HTF ATR √ó Merge Tolerance setting (default 0.5 ATR).\n\n VISUALIZATION: \nThe indicator always displays the N closest levels above and below the current price.\nLevels are sorted by distance, ensuring the most relevant S/R are always visible.\nActive levels show as solid lines, mitigated levels as dashed lines.\n\n ALERT SYSTEM: \n \n Breakout (any level) - triggers when any level is broken with coherent candle\n Breakout Support - triggers when a support level is broken by bearish candle\n Breakout Resistance - triggers when a resistance level is broken by bullish candle\n New Pivot (any) - triggers when a new pivot is detected\n New Pivot Support - triggers when a new support pivot is detected\n New Pivot Resistance - triggers when a new resistance pivot is detected\n Significant Breakout (any) - triggers on high-quality breakouts\n Significant Breakout Support - high-quality support breakout\n Significant Breakout Resistance - high-quality resistance breakout\n \n\n SIGNIFICANT BREAKOUT CRITERIA: \nA breakout is considered \"significant\" when:\n \n Candle direction is coherent (bearish for support, bullish for resistance)\n At least X% of the candle body crosses the level (configurable, default 50%)\n Opposite wick is limited to Y% of candle range (configurable, default 30%)\n \nExample: For a bearish candle breaking support, the upper wick must be small.\n\n TIMEFRAME CONFIGURATION: \nConfigure different S/R timeframes based on current chart timeframe:\n \n 1m-5m charts ‚Üí Default 4h S/R\n 15m charts ‚Üí Default 4h S/R\n 30m-1h charts ‚Üí Default 4h S/R\n 4h charts ‚Üí Default 4h S/R\n Daily charts ‚Üí Default Daily S/R\n Weekly charts ‚Üí Default Weekly S/R\n Monthly charts ‚Üí Default Monthly S/R\n \nAll timeframes are configurable via input settings.\n\n SETTINGS OVERVIEW: \n \n Timeframe Configuration - Set S/R timeframe for each chart timeframe\n Pivot Detection - Max levels, left/right bars, merge tolerance, level extension\n Mitigation Settings - How long mitigated levels remain visible\n Visual Settings - Colors, line width, price scale display\n Significant Breakout - Min body cross %, max opposite wick %\n Debug - Show pivot detection markers\n",
    "author_name": "riccardo_tempesta",
    "likes_count": 33,
    "comments_count": 0,
    "views_count": 0,
    "created_at": "2025-12-11T20:23:59+00:00",
    "updated_at": "2025-12-11T21:38:23+00:00",
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "PEPPERSTONE:NZDCHF",
      "full_name": "PEPPERSTONE:NZDCHF",
      "short_name": "NZDCHF",
      "exchange": "PEPPERSTONE",
      "type": "forex",
      "logo_id": null,
      "currency_logo_id": "country/CH",
      "base_currency_logo_id": "country/NZ",
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/country/NZ.svg",
        "https://s3-symbol-logo.tradingview.com/country/CH.svg"
      ],
      "interval": "240",
      "direction": 0,
      "badge": {
        "label": "PEPPERSTONE:NZDCHF",
        "url": "/symbols/NZDCHF/"
      }
    },
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=6\r\n// [b]TRI - MULTI-TIMEFRAME SUPPORT & RESISTANCE v3.1.0[/b]\r\n\r\n// [b]DESCRIPTION:[/b]\r\n// Advanced multi-timeframe Support & Resistance indicator using ta.pivothigh/ta.pivotlow\r\n// to display pivot-based S/R levels from higher timeframes on your current chart.\r\n// Features smart pivot positioning, dynamic level merging, retest detection, and comprehensive alert system.\r\n\r\n// [b]KEY FEATURES:[/b]\r\n// [list]\r\n// [*]Multi-timeframe pivot detection using ta.pivothigh/ta.pivotlow on candle body\r\n// [*]Smart pivot positioning - pivots are placed on the correct candle type (bullish for highs, bearish for lows)\r\n// [*]Automatic timeframe selection - configure different S/R timeframes for each chart timeframe\r\n// [*]Dynamic level merging - nearby levels are merged based on ATR tolerance (newer wins)\r\n// [*]Mitigated level tracking - shows recently broken levels with distinct styling\r\n// [*]Smart visualization - always shows N closest levels above and below current price\r\n// [*]Retest detection - identifies bounces off S/R levels with configurable parameters\r\n// [*]Comprehensive alert system with 12 different alert types\r\n// [*]Significant breakout detection with configurable parameters\r\n// [*]Memory efficient - automatic cleanup of expired levels\r\n// [/list]\r\n\r\n// [b]HOW IT WORKS:[/b]\r\n// The indicator uses ta.pivothigh() and ta.pivotlow() on the selected higher timeframe.\r\n// Pivot highs are positioned on bullish candles (using close price).\r\n// Pivot lows are positioned on bearish candles (using close price).\r\n// If the pivot candle is not the correct type, it searches back up to 5 candles.\r\n// Only unbreached levels are displayed as active support/resistance.\r\n// When a level is breached, it becomes a \"mitigated level\" with distinct styling.\r\n// Mitigation is checked only after the first candle following the pivot (to avoid false triggers).\r\n\r\n// [b]LEVEL MERGING:[/b]\r\n// Nearby levels of the same type are automatically merged based on ATR tolerance.\r\n// The newer pivot always wins, replacing older levels within the tolerance range.\r\n// Tolerance = HTF ATR √ó Merge Tolerance setting (default 0.5 ATR).\r\n\r\n// [b]VISUALIZATION:[/b]\r\n// The indicator always displays the N closest levels above and below the current price.\r\n// Levels are sorted by distance, ensuring the most relevant S/R are always visible.\r\n// Active levels show as solid lines, mitigated levels as dashed lines.\r\n\r\n// [b]RETEST DETECTION:[/b]\r\n// Detects when price tests a S/R level and bounces back. Two patterns are recognized:\r\n// [list]\r\n// [*]Pattern 1: Single candle with long wick touching level and body moving away\r\n// [*]Pattern 2: Previous candle touches level, current candle is reaction candle\r\n// [/list]\r\n// Parameters:\r\n// [list]\r\n// [*]ATR Tolerance - How close price must be to level (default 0.3 ATR)\r\n// [*]Min Wick % - Minimum wick size to confirm rejection (default 30%)\r\n// [/list]\r\n// Support retest: bullish bounce (long lower wick or bullish follow-through)\r\n// Resistance retest: bearish rejection (long upper wick or bearish follow-through)\r\n\r\n// [b]ALERT SYSTEM:[/b]\r\n// [list]\r\n// [*]Breakout (any level) - triggers when any level is broken with coherent candle\r\n// [*]Breakout Support - triggers when a support level is broken by bearish candle\r\n// [*]Breakout Resistance - triggers when a resistance level is broken by bullish candle\r\n// [*]New Pivot (any) - triggers when a new pivot is detected\r\n// [*]New Pivot Support - triggers when a new support pivot is detected\r\n// [*]New Pivot Resistance - triggers when a new resistance pivot is detected\r\n// [*]Significant Breakout (any) - triggers on high-quality breakouts\r\n// [*]Significant Breakout Support - high-quality support breakout\r\n// [*]Significant Breakout Resistance - high-quality resistance breakout\r\n// [*]Retest (any) - triggers when any level is retested\r\n// [*]Retest Support - triggers when support is retested with bullish bounce\r\n// [*]Retest Resistance - triggers when resistance is retested with bearish rejection\r\n// [/list]\r\n\r\n// [b]SIGNIFICANT BREAKOUT CRITERIA:[/b]\r\n// A breakout is considered \"significant\" when:\r\n// [list]\r\n// [*]Candle direction is coherent (bearish for support, bullish for resistance)\r\n// [*]At least X% of the candle body crosses the level (configurable, default 50%)\r\n// [*]Opposite wick is limited to Y% of candle range (configurable, default 30%)\r\n// [/list]\r\n// Example: For a bearish candle breaking support, the upper wick must be small.\r\n\r\n// [b]TIMEFRAME CONFIGURATION:[/b]\r\n// Configure different S/R timeframes based on current chart timeframe:\r\n// [list]\r\n// [*]1m-5m charts ‚Üí Default 4h S/R\r\n// [*]15m charts ‚Üí Default 4h S/R\r\n// [*]30m-1h charts ‚Üí Default 4h S/R\r\n// [*]4h charts ‚Üí Default 4h S/R\r\n// [*]Daily charts ‚Üí Default Daily S/R\r\n// [*]Weekly charts ‚Üí Default Weekly S/R\r\n// [*]Monthly charts ‚Üí Default Monthly S/R\r\n// [/list]\r\n// All timeframes are configurable via input settings.\r\n\r\n// [b]SETTINGS OVERVIEW:[/b]\r\n// [list]\r\n// [*]Timeframe Configuration - Set S/R timeframe for each chart timeframe\r\n// [*]Pivot Detection - Max levels, left/right bars, merge tolerance, level extension\r\n// [*]Mitigation Settings - How long mitigated levels remain visible\r\n// [*]Visual Settings - Colors, line width, price scale display\r\n// [*]Significant Breakout - Min body cross %, max opposite wick %\r\n// [*]Retest Detection - ATR tolerance, min wick %\r\n// [*]Debug - Show pivot/retest detection markers\r\n// [/list]\r\n\r\nindicator(\"TRI - Multi-Timeframe Support and Resistance\", shorttitle=\"TRI - MTFSR\", overlay=true, max_lines_count=100, max_labels_count=100, max_bars_back=5000)\r\n\r\n// ============================================================================\r\n// INPUTS - TIMEFRAME SELECTION\r\n// ============================================================================\r\nvar G_TF = \"Timeframe Configuration\"\r\n\r\n// Timeframe configuration for each chart timeframe range\r\ntf1mTo5m = input.timeframe(\"240\", \"1m-5m Charts ‚Üí S/R TF\", group=G_TF)\r\ntf15m = input.timeframe(\"240\", \"15m Charts ‚Üí S/R TF\", group=G_TF)\r\ntf30mTo1h = input.timeframe(\"240\", \"30m-1h Charts ‚Üí S/R TF\", group=G_TF)\r\ntf4h = input.timeframe(\"240\", \"4h Charts ‚Üí S/R TF\", group=G_TF)\r\ntfDaily = input.timeframe(\"D\", \"Daily Charts ‚Üí S/R TF\", group=G_TF)\r\ntfWeekly = input.timeframe(\"W\", \"Weekly Charts ‚Üí S/R TF\", group=G_TF)\r\ntfMonthly = input.timeframe(\"M\", \"Monthly Charts ‚Üí S/R TF\", group=G_TF)\r\n\r\n// Pivot Settings\r\nvar G_PIVOT = \"Pivot Detection\"\r\nmaxLevels = input.int(5, \"Max Levels per Type\", minval=1, maxval=20, group=G_PIVOT)\r\npivotLeftBars = input.int(3, \"Pivot Left Bars\", minval=2, maxval=20, group=G_PIVOT,\r\n  tooltip=\"Number of bars to the left for pivot detection\")\r\npivotRightBars = input.int(3, \"Pivot Right Bars\", minval=2, maxval=20, group=G_PIVOT,\r\n  tooltip=\"Number of bars to the right for pivot detection\")\r\nmergeTolerance = input.float(0.5, \"Merge Tolerance (ATR)\", minval=0.1, maxval=2.0, step=0.1, group=G_PIVOT,\r\n  tooltip=\"Levels within this ATR distance merge. Newer level wins. 0 = disabled\")\r\n\r\n// Mitigation Settings\r\nvar G_MITIGATION = \"Mitigation Settings\"\r\nmitigatedBars = input.int(10, \"Mitigated Level Bars (HTF)\", minval=1, maxval=100, group=G_MITIGATION, \r\n  tooltip=\"Number of HTF bars to keep mitigated levels visible\")\r\nshowMitigated = input.bool(true, \"Show Mitigated Levels\", group=G_MITIGATION)\r\n\r\n// Visual Settings\r\nvar G_VISUAL = \"Visual Settings\"\r\nzoneExtensionBars = input.int(2, \"Zone Extension Bars\", minval=0, maxval=20, group=G_VISUAL, \r\n  tooltip=\"Number of bars to extend levels beyond the last closed candle\")\r\n\r\nsupportColor = input.color(color.new(color.green, 0), \"Support Color\", group=G_VISUAL)\r\nresistanceColor = input.color(color.new(color.red, 0), \"Resistance Color\", group=G_VISUAL)\r\nmitigatedColor = input.color(color.new(color.orange, 0), \"Mitigated Color\", group=G_VISUAL)\r\n\r\nlineWidth = input.int(1, \"Line Width\", minval=1, maxval=5, group=G_VISUAL)\r\nshowPriceScale = input.bool(true, \"Show on Price Scale\", group=G_VISUAL, \r\n  tooltip=\"Show S/R levels as colored labels on the price scale\")\r\nshowRightLabels = input.bool(true, \"Show Right Labels\", group=G_VISUAL,\r\n  tooltip=\"Show level info labels on the right side of the chart\")\r\nrightLabelSize = input.string(\"small\", \"Right Label Size\", options=[\"tiny\", \"small\", \"normal\", \"large\"], group=G_VISUAL)\r\n\r\n// Performance Settings\r\nmaxLevelHistory = input.int(50, \"Max Level History\", minval=10, maxval=200, group=\"Performance\",\r\n  tooltip=\"Maximum number of levels to keep in memory\")\r\n\r\n// Significant Breakout Settings\r\nvar G_SIG_BREAKOUT = \"üìä Significant Breakout\"\r\nminBodyCrossPercent = input.float(50.0, \"Min Body Cross %\", minval=10.0, maxval=100.0, step=5.0, group=G_SIG_BREAKOUT,\r\n  tooltip=\"Minimum % of candle body that must cross the level\")\r\nmaxOppositeWickPercent = input.float(30.0, \"Max Opposite Wick %\", minval=0.0, maxval=100.0, step=5.0, group=G_SIG_BREAKOUT,\r\n  tooltip=\"Maximum % of opposite wick relative to candle range. For bearish breaking support: max upper wick. For bullish breaking resistance: max lower wick.\")\r\n\r\n// Retest Settings\r\nvar G_RETEST = \"üîÑ Retest Detection\"\r\nretestATRTolerance = input.float(0.15, \"Retest ATR Tolerance\", minval=0.05, maxval=0.5, step=0.05, group=G_RETEST,\r\n  tooltip=\"How close price must be to level (in ATR) to count as a touch\")\r\nretestMinWickPercent = input.float(30.0, \"Min Wick %\", minval=10.0, maxval=80.0, step=5.0, group=G_RETEST,\r\n  tooltip=\"Minimum wick size as % of candle range to confirm rejection\")\r\n\r\n// Debug Settings\r\nvar G_DEBUG = \"üîß Debug\"\r\nshowDebugPivots = input.bool(false, \"Show Pivot Detection\", group=G_DEBUG,\r\n  tooltip=\"Show arrows when pivots are detected\")\r\nshowDebugRetests = input.bool(false, \"Show Retest Detection\", group=G_DEBUG,\r\n  tooltip=\"Show markers when retests are detected\")\r\nshowDebugBreakouts = input.bool(false, \"Show Breakout Detection\", group=G_DEBUG,\r\n  tooltip=\"Show markers when breakouts are detected\")\r\nshowDebugSignificantBreakouts = input.bool(false, \"Show Significant Breakouts\", group=G_DEBUG,\r\n  tooltip=\"Show markers when significant breakouts are detected\")\r\n\r\n// ============================================================================\r\n// TIMEFRAME FUNCTIONS\r\n// ============================================================================\r\ngetCurrentTFMinutes() =>\r\n    int minutes = 240\r\n    \r\n    if timeframe.isdaily\r\n        minutes := 1440\r\n    else if timeframe.isweekly\r\n        minutes := 10080\r\n    else if timeframe.ismonthly\r\n        minutes := 43200\r\n    else\r\n        minutes := switch timeframe.period\r\n            \"1\" => 1\r\n            \"3\" => 3\r\n            \"5\" => 5\r\n            \"15\" => 15\r\n            \"30\" => 30\r\n            \"45\" => 45\r\n            \"60\" => 60\r\n            \"120\" => 120\r\n            \"180\" => 180\r\n            \"240\" => 240\r\n            => timeframe.in_seconds() / 60\r\n    \r\n    minutes\r\n\r\ncurrentTFMinutes = getCurrentTFMinutes()\r\n\r\ngetSelectedSRTimeframe() =>\r\n    string result = tf4h\r\n    \r\n    if currentTFMinutes <= 5\r\n        result := tf1mTo5m\r\n    else if currentTFMinutes == 15\r\n        result := tf15m\r\n    else if currentTFMinutes > 15 and currentTFMinutes <= 60\r\n        result := tf30mTo1h\r\n    else if currentTFMinutes > 60 and currentTFMinutes <= 240\r\n        result := tf4h\r\n    else if currentTFMinutes > 240 and currentTFMinutes <= 1440\r\n        result := tfDaily\r\n    else if currentTFMinutes > 1440 and currentTFMinutes <= 10080\r\n        result := tfWeekly\r\n    else if currentTFMinutes > 10080\r\n        result := tfMonthly\r\n    \r\n    result\r\n\r\nselectedSRTimeframe = getSelectedSRTimeframe()\r\n\r\ngetHumanReadableTF(string tf) =>\r\n    string result = tf\r\n    \r\n    if str.contains(tf, \"D\") or str.contains(tf, \"W\") or str.contains(tf, \"M\")\r\n        result := tf\r\n    else\r\n        minutes = str.tonumber(tf)\r\n        if not na(minutes)\r\n            if minutes < 60\r\n                result := str.tostring(minutes) + \"m\"\r\n            else if minutes < 1440\r\n                hours = minutes / 60\r\n                result := str.tostring(hours, \"#\") + \"h\"\r\n            else if minutes < 10080\r\n                days = minutes / 1440\r\n                result := str.tostring(days, \"#\") + \"D\"\r\n            else if minutes < 43200\r\n                weeks = minutes / 10080\r\n                result := str.tostring(weeks, \"#\") + \"W\"\r\n            else\r\n                months = minutes / 43200\r\n                result := str.tostring(months, \"#\") + \"M\"\r\n    \r\n    result\r\n\r\nhumanReadableSRTF = getHumanReadableTF(selectedSRTimeframe)\r\n\r\n// ============================================================================\r\n// TYPE DEFINITIONS\r\n// ============================================================================\r\ntype SRLevel\r\n    float price\r\n    int barTime\r\n    int barTimeExpiry\r\n    int mitigationAllowedTime  // Don't check mitigation until this time (skip first candle)\r\n    bool isResistance\r\n    bool isMitigated\r\n    int mitigationTime\r\n    int visibleUntilTime\r\n    line levelLine\r\n    label circleLabel\r\n    label rightLabel\r\n\r\n// ============================================================================\r\n// ARRAYS FOR LEVEL MANAGEMENT\r\n// ============================================================================\r\nvar array<SRLevel> srLevels = array.new<SRLevel>()\r\n\r\n// ============================================================================\r\n// HELPER FUNCTIONS\r\n// ============================================================================\r\nmethod delete(SRLevel level) =>\r\n    if not na(level.levelLine)\r\n        level.levelLine.delete()\r\n    if not na(level.circleLabel)\r\n        level.circleLabel.delete()\r\n    if not na(level.rightLabel)\r\n        level.rightLabel.delete()\r\n\r\n// Check if level was breached\r\nmethod isBreach(SRLevel level, float htfClose) =>\r\n    if level.isResistance\r\n        htfClose > level.price\r\n    else\r\n        htfClose < level.price\r\n\r\n// Check if breakout is significant (coherent candle direction + body cross + limited opposite wick)\r\n// Returns [isSignificant, isCoherent]\r\ncheckSignificantBreakout(float levelPrice, bool isResistance, float candleOpen, float candleClose, float candleHigh, float candleLow) =>\r\n    bool isSignificant = false\r\n    bool isCoherent = false\r\n    \r\n    float candleRange = candleHigh - candleLow\r\n    float bodyHigh = math.max(candleOpen, candleClose)\r\n    float bodyLow = math.min(candleOpen, candleClose)\r\n    float bodySize = bodyHigh - bodyLow\r\n    \r\n    bool isBullish = candleClose > candleOpen\r\n    bool isBearish = candleClose < candleOpen\r\n    \r\n    if candleRange > 0 and bodySize > 0\r\n        if isResistance\r\n            // Breaking resistance: candle must be BULLISH\r\n            isCoherent := isBullish\r\n            if isCoherent\r\n                // Calculate how much body crossed above level\r\n                float bodyCrossed = bodyHigh - levelPrice\r\n                float bodyCrossPercent = (bodyCrossed / bodySize) * 100\r\n                \r\n                // Calculate opposite wick (lower wick for bullish breaking resistance)\r\n                float lowerWick = bodyLow - candleLow\r\n                float lowerWickPercent = (lowerWick / candleRange) * 100\r\n                \r\n                isSignificant := bodyCrossPercent >= minBodyCrossPercent and lowerWickPercent <= maxOppositeWickPercent\r\n        else\r\n            // Breaking support: candle must be BEARISH\r\n            isCoherent := isBearish\r\n            if isCoherent\r\n                // Calculate how much body crossed below level\r\n                float bodyCrossed = levelPrice - bodyLow\r\n                float bodyCrossPercent = (bodyCrossed / bodySize) * 100\r\n                \r\n                // Calculate opposite wick (upper wick for bearish breaking support)\r\n                float upperWick = candleHigh - bodyHigh\r\n                float upperWickPercent = (upperWick / candleRange) * 100\r\n                \r\n                isSignificant := bodyCrossPercent >= minBodyCrossPercent and upperWickPercent <= maxOppositeWickPercent\r\n    \r\n    [isSignificant, isCoherent]\r\n\r\n// Check if current candle is a retest of a level\r\n// Returns true if:\r\n// - Price touched the level (within ATR tolerance)\r\n// - Candle shows rejection (long wick on the level side, body away from level)\r\n// - OR: previous BEARISH candle touched support + current BULLISH (or vice versa for resistance)\r\ncheckRetest(float levelPrice, bool isResistance, float candleOpen, float candleClose, float candleHigh, float candleLow, float atrValue, float prevOpen, float prevLow, float prevHigh, float prevClose) =>\r\n    bool isRetest = false\r\n    \r\n    float tolerance = atrValue * retestATRTolerance\r\n    float candleRange = candleHigh - candleLow\r\n    bool isBullish = candleClose > candleOpen\r\n    bool isBearish = candleClose < candleOpen\r\n    bool prevWasBearish = prevClose < prevOpen\r\n    bool prevWasBullish = prevClose > prevOpen\r\n    \r\n    if candleRange > 0 and not na(atrValue) and atrValue > 0\r\n        if not isResistance\r\n            // SUPPORT RETEST: price touches support from above and bounces up\r\n            bool touchedNow = candleLow <= levelPrice + tolerance and candleLow >= levelPrice - tolerance\r\n            bool touchedPrev = prevLow <= levelPrice + tolerance and prevLow >= levelPrice - tolerance\r\n            \r\n            // Pattern 1: Single bullish candle with long lower wick touching support\r\n            if touchedNow and isBullish\r\n                float lowerWick = math.min(candleOpen, candleClose) - candleLow\r\n                float lowerWickPercent = (lowerWick / candleRange) * 100\r\n                if lowerWickPercent >= retestMinWickPercent\r\n                    isRetest := true\r\n            \r\n            // Pattern 2: Previous BEARISH candle touched support, current candle is BULLISH\r\n            // (bearish candle tests support, bullish candle confirms bounce)\r\n            if touchedPrev and prevWasBearish and isBullish and candleClose > prevClose\r\n                isRetest := true\r\n        else\r\n            // RESISTANCE RETEST: price touches resistance from below and bounces down\r\n            bool touchedNow = candleHigh >= levelPrice - tolerance and candleHigh <= levelPrice + tolerance\r\n            bool touchedPrev = prevHigh >= levelPrice - tolerance and prevHigh <= levelPrice + tolerance\r\n            \r\n            // Pattern 1: Single bearish candle with long upper wick touching resistance\r\n            if touchedNow and isBearish\r\n                float upperWick = candleHigh - math.max(candleOpen, candleClose)\r\n                float upperWickPercent = (upperWick / candleRange) * 100\r\n                if upperWickPercent >= retestMinWickPercent\r\n                    isRetest := true\r\n            \r\n            // Pattern 2: Previous BULLISH candle touched resistance, current candle is BEARISH\r\n            // (bullish candle tests resistance, bearish candle confirms rejection)\r\n            if touchedPrev and prevWasBullish and isBearish and candleClose < prevClose\r\n                isRetest := true\r\n    \r\n    isRetest\r\n\r\nmethod markMitigated(SRLevel level, int htfMitigationTime, int htfBarDuration) =>\r\n    level.isMitigated := true\r\n    level.mitigationTime := htfMitigationTime\r\n    level.visibleUntilTime := level.mitigationTime + (htfBarDuration * mitigatedBars)\r\n    \r\n    // Update visual immediately\r\n    if not na(level.levelLine)\r\n        line.set_color(level.levelLine, mitigatedColor)\r\n        line.set_style(level.levelLine, line.style_dashed)\r\n        line.set_width(level.levelLine, lineWidth)\r\n    if not na(level.circleLabel)\r\n        label.set_color(level.circleLabel, color.new(mitigatedColor, 50))\r\n\r\nmethod applyActiveVisual(SRLevel level, int endTime) =>\r\n    color levelColor = level.isResistance ? resistanceColor : supportColor\r\n    \r\n    if not na(level.levelLine)\r\n        line.set_x2(level.levelLine, endTime)\r\n        line.set_color(level.levelLine, levelColor)\r\n\r\nmethod applyMitigatedVisual(SRLevel level, int endTime) =>\r\n    if not na(level.levelLine)\r\n        line.set_x2(level.levelLine, endTime)\r\n        line.set_color(level.levelLine, mitigatedColor)\r\n        line.set_style(level.levelLine, line.style_dashed)\r\n        line.set_width(level.levelLine, lineWidth)\r\n\r\nmethod hasExpired(SRLevel level, int htfCurrentTime) =>\r\n    bool expired = false\r\n    if level.isMitigated\r\n        expired := htfCurrentTime >= level.visibleUntilTime\r\n    else\r\n        expired := htfCurrentTime > level.barTimeExpiry\r\n    expired\r\n\r\n// Check if two levels are nearby (same type, close price within tolerance)\r\nmethod isNearby(SRLevel levelA, SRLevel levelB, float tolerance) =>\r\n    bool result = false\r\n    // Only merge levels of same type (both resistance or both support)\r\n    if levelA.isResistance == levelB.isResistance\r\n        result := math.abs(levelA.price - levelB.price) <= tolerance\r\n    result\r\n\r\n// Remove older levels that are too close to newer ones\r\n// Newer level wins (lower index = newer since we unshift)\r\nremoveNearbyLevels(array<SRLevel> levels, float tolerance) =>\r\n    if tolerance > 0\r\n        int levelsSize = array.size(levels)\r\n        if levelsSize > 1\r\n            array<bool> toRemove = array.new<bool>()\r\n            for i = 0 to levelsSize - 1\r\n                array.push(toRemove, false)\r\n            \r\n            // Compare all pairs: i is newer, j is older\r\n            for i = 0 to levelsSize - 2\r\n                if array.get(toRemove, i)\r\n                    continue\r\n                levelA = array.get(levels, i)\r\n                \r\n                for j = i + 1 to levelsSize - 1\r\n                    if array.get(toRemove, j)\r\n                        continue\r\n                    levelB = array.get(levels, j)\r\n                    \r\n                    if levelA.isNearby(levelB, tolerance)\r\n                        array.set(toRemove, j, true)\r\n            \r\n            // Remove from highest index to prevent shifting\r\n            for i = levelsSize - 1 to 0\r\n                if array.get(toRemove, i)\r\n                    level = array.get(levels, i)\r\n                    level.delete()\r\n                    array.remove(levels, i)\r\n\r\n// ============================================================================\r\n// LEVEL CREATION\r\n// ============================================================================\r\ncreateSRLevel(float price, int barTime, int htfBarDuration, bool isResistance, string tfLabel, int extTime, int levelExtend) =>\r\n    level = SRLevel.new(\r\n      price = price,\r\n      barTime = barTime,\r\n      barTimeExpiry = barTime + (htfBarDuration * levelExtend),\r\n      mitigationAllowedTime = barTime + htfBarDuration,  // Skip first candle after pivot\r\n      isResistance = isResistance,\r\n      isMitigated = false,\r\n      mitigationTime = na,\r\n      visibleUntilTime = na,\r\n      levelLine = line(na),\r\n      circleLabel = label(na),\r\n      rightLabel = label(na))\r\n    \r\n    color levelColor = isResistance ? resistanceColor : supportColor\r\n    string levelType = isResistance ? \"R\" : \"S\"\r\n    \r\n    // Create line with right extension\r\n    level.levelLine := line.new(\r\n      x1 = barTime,\r\n      y1 = price,\r\n      x2 = extTime,\r\n      y2 = price,\r\n      xloc = xloc.bar_time,\r\n      extend = extend.right,\r\n      color = levelColor,\r\n      width = lineWidth,\r\n      style = line.style_solid)\r\n    \r\n    // Create circle at pivot point\r\n    level.circleLabel := label.new(\r\n      x = barTime,\r\n      y = price,\r\n      text = \"\",\r\n      xloc = xloc.bar_time,\r\n      yloc = yloc.price,\r\n      color = color.new(levelColor, 50),\r\n      style = label.style_circle,\r\n      size = size.tiny)\r\n    \r\n    level\r\n\r\n// ============================================================================\r\n// MULTI-TIMEFRAME DATA REQUEST\r\n// ============================================================================\r\n\r\n// Request HTF OHLC data for body-based pivot detection\r\n[htfOpen, htfClose] = request.security(syminfo.tickerid, selectedSRTimeframe, \r\n    [open, close], lookahead=barmerge.lookahead_off)\r\n\r\n// Calculate body high/low (max/min of open/close)\r\nhtfBodyHigh = math.max(htfOpen, htfClose)\r\nhtfBodyLow = math.min(htfOpen, htfClose)\r\n\r\n// Request HTF pivot data using body instead of wicks\r\nhtfPivotHigh = request.security(syminfo.tickerid, selectedSRTimeframe, \r\n    ta.pivothigh(math.max(open, close), pivotLeftBars, pivotRightBars), lookahead=barmerge.lookahead_off)\r\nhtfPivotLow = request.security(syminfo.tickerid, selectedSRTimeframe, \r\n    ta.pivotlow(math.min(open, close), pivotLeftBars, pivotRightBars), lookahead=barmerge.lookahead_off)\r\n\r\n// Request HTF data for mitigation and visualization\r\n[htfTime, htfCurrentTime, htfCurrentClose] = \r\n  request.security(syminfo.tickerid, selectedSRTimeframe, \r\n    [time[1], time, close], lookahead=barmerge.lookahead_off)\r\n\r\n// Request HTF OHLC for current candle (for significant breakout analysis)\r\n[htfCurrentOpen, htfCurrentHigh, htfCurrentLow] = \r\n  request.security(syminfo.tickerid, selectedSRTimeframe, \r\n    [open, high, low], lookahead=barmerge.lookahead_off)\r\n\r\n// Request HTF previous candle data (for retest detection)\r\n[htfPrevOpen, htfPrevHigh, htfPrevLow, htfPrevClose] = \r\n  request.security(syminfo.tickerid, selectedSRTimeframe, \r\n    [open[1], high[1], low[1], close[1]], lookahead=barmerge.lookahead_off)\r\n\r\n// Request ATR for dynamic merge tolerance\r\nhtfATR = request.security(syminfo.tickerid, selectedSRTimeframe, ta.atr(14), lookahead=barmerge.lookahead_off)\r\n\r\n// Track HTF bar changes and pivot detection\r\nvar int lastHTFTime = na\r\nvar bool firstRun = true\r\nvar float lastPivotHigh = na\r\nvar float lastPivotLow = na\r\n\r\nbool isNewHTFBar = false\r\nif not na(htfTime)\r\n    if firstRun\r\n        isNewHTFBar := true\r\n        firstRun := false\r\n    else if na(lastHTFTime) or htfTime != lastHTFTime\r\n        isNewHTFBar := true\r\n\r\n// Calculate HTF bar duration\r\nvar int htfBarDuration = na\r\nif isNewHTFBar and not na(lastHTFTime) and not na(htfTime)\r\n    htfBarDuration := htfTime - lastHTFTime\r\nelse if na(htfBarDuration)\r\n    htfBarDuration := timeframe.in_seconds(selectedSRTimeframe) * 1000\r\n\r\nif not na(htfTime)\r\n    lastHTFTime := htfTime\r\n\r\n// Current timeframe bar duration\r\nvar int currentBarDuration = na\r\nif na(currentBarDuration)\r\n    currentBarDuration := timeframe.in_seconds() * 1000\r\n\r\nint extensionTime = time + (currentBarDuration * zoneExtensionBars)\r\n\r\n// Level extension in HTF bars\r\nlevelExtendBars = input.int(100, \"Level Extension Bars\", minval=10, maxval=500, group=G_PIVOT,\r\n  tooltip=\"Number of HTF bars to extend levels\")\r\n\r\n// Calculate dynamic merge tolerance based on HTF ATR\r\nfloat mergeToleranceValue = not na(htfATR) and htfATR > 0 and mergeTolerance > 0 ? htfATR * mergeTolerance : 0\r\n\r\n// ============================================================================\r\n// LEVEL DETECTION AND MANAGEMENT\r\n// ============================================================================\r\n\r\n// Function to find correct candle for pivot high (should be bullish candle)\r\n// Returns [time, price] where price is the CLOSE of the bullish candle\r\nfindPivotHighData() =>\r\n    int resultTime = na\r\n    float resultPrice = na\r\n    if not na(ta.pivothigh(math.max(open, close), pivotLeftBars, pivotRightBars))\r\n        int offset = pivotRightBars\r\n        // If pivot candle is bearish (close < open), find previous bullish\r\n        if close[offset] < open[offset]\r\n            // Search back up to 5 candles for a bullish candle\r\n            for i = offset + 1 to offset + 5\r\n                if close[i] > open[i]\r\n                    offset := i\r\n                    break\r\n        resultTime := time[offset]\r\n        // Use CLOSE of bullish candle for resistance level\r\n        resultPrice := close[offset]\r\n    [resultTime, resultPrice]\r\n\r\n// Function to find correct candle for pivot low (should be bearish candle)\r\n// Returns [time, price] where price is the CLOSE of the bearish candle\r\nfindPivotLowData() =>\r\n    int resultTime = na\r\n    float resultPrice = na\r\n    if not na(ta.pivotlow(math.min(open, close), pivotLeftBars, pivotRightBars))\r\n        int offset = pivotRightBars\r\n        // If pivot candle is bullish (close > open), find previous bearish\r\n        if close[offset] > open[offset]\r\n            // Search back up to 5 candles for a bearish candle\r\n            for i = offset + 1 to offset + 5\r\n                if close[i] < open[i]\r\n                    offset := i\r\n                    break\r\n        resultTime := time[offset]\r\n        // Use CLOSE of bearish candle for support level\r\n        resultPrice := close[offset]\r\n    [resultTime, resultPrice]\r\n\r\n// Request pivot bar time and corrected price\r\n[htfPivotHighTime, htfPivotHighPrice] = request.security(syminfo.tickerid, selectedSRTimeframe, findPivotHighData(), lookahead=barmerge.lookahead_off)\r\n[htfPivotLowTime, htfPivotLowPrice] = request.security(syminfo.tickerid, selectedSRTimeframe, findPivotLowData(), lookahead=barmerge.lookahead_off)\r\n\r\n// Alert condition tracking variables\r\nvar bool newPivotResistance = false\r\nvar bool newPivotSupport = false\r\nnewPivotResistance := false\r\nnewPivotSupport := false\r\n\r\n// Detect pivots when they are confirmed (change from NA to non-NA)\r\nif not na(htfBarDuration) and not na(htfCurrentClose)\r\n    // Detect pivot high (when it changes from NA to non-NA)\r\n    if not na(htfPivotHigh) and (na(lastPivotHigh) or htfPivotHigh != lastPivotHigh)\r\n        if not na(htfPivotHighTime) and not na(htfPivotHighPrice)\r\n            // Use corrected price (CLOSE of bullish candle)\r\n            newLevel = createSRLevel(htfPivotHighPrice, htfPivotHighTime, htfBarDuration, true, humanReadableSRTF, extensionTime, levelExtendBars)\r\n            array.unshift(srLevels, newLevel)\r\n            \r\n            // Set alert condition\r\n            newPivotResistance := true\r\n            \r\n            // Debug: mark pivot high detection at actual pivot location\r\n            if showDebugPivots\r\n                label.new(htfPivotHighTime, htfPivotHighPrice, \"‚ñº PH\\n\" + str.tostring(htfPivotHighPrice, format.mintick), \r\n                  xloc=xloc.bar_time, color=color.new(resistanceColor, 20), textcolor=color.white, \r\n                  style=label.style_label_down, size=size.small)\r\n    \r\n    // Detect pivot low (when it changes from NA to non-NA)\r\n    if not na(htfPivotLow) and (na(lastPivotLow) or htfPivotLow != lastPivotLow)\r\n        if not na(htfPivotLowTime) and not na(htfPivotLowPrice)\r\n            // Use corrected price (CLOSE of bearish candle)\r\n            newLevel = createSRLevel(htfPivotLowPrice, htfPivotLowTime, htfBarDuration, false, humanReadableSRTF, extensionTime, levelExtendBars)\r\n            array.unshift(srLevels, newLevel)\r\n            \r\n            // Set alert condition\r\n            newPivotSupport := true\r\n            \r\n            // Debug: mark pivot low detection at actual pivot location\r\n            if showDebugPivots\r\n                label.new(htfPivotLowTime, htfPivotLowPrice, \"‚ñ≤ PL\\n\" + str.tostring(htfPivotLowPrice, format.mintick), \r\n                  xloc=xloc.bar_time, color=color.new(supportColor, 20), textcolor=color.white, \r\n                  style=label.style_label_up, size=size.small)\r\n    \r\n    // Update last pivot values\r\n    lastPivotHigh := htfPivotHigh\r\n    lastPivotLow := htfPivotLow\r\n    \r\n    // Merge nearby levels (newer wins)\r\n    if mergeToleranceValue > 0 and array.size(srLevels) > 1\r\n        removeNearbyLevels(srLevels, mergeToleranceValue)\r\n    \r\n    // Limit array size\r\n    if array.size(srLevels) > maxLevelHistory\r\n        oldLevel = array.pop(srLevels)\r\n        oldLevel.delete()\r\n\r\n// Breakout alert condition tracking\r\nvar bool breakoutSupport = false\r\nvar bool breakoutResistance = false\r\nvar bool significantBreakoutSupport = false\r\nvar bool significantBreakoutResistance = false\r\n\r\n// Retest alert condition tracking\r\nvar bool retestSupport = false\r\nvar bool retestResistance = false\r\n\r\n// Flags to prevent duplicate alerts in same HTF bar\r\nvar bool alertedBreakoutSupport = false\r\nvar bool alertedBreakoutResistance = false\r\nvar bool alertedSignificantBreakoutSupport = false\r\nvar bool alertedSignificantBreakoutResistance = false\r\nvar bool alertedRetestSupport = false\r\nvar bool alertedRetestResistance = false\r\n\r\n// Reset alert conditions every bar\r\nbreakoutSupport := false\r\nbreakoutResistance := false\r\nsignificantBreakoutSupport := false\r\nsignificantBreakoutResistance := false\r\nretestSupport := false\r\nretestResistance := false\r\n\r\n// Reset duplicate prevention flags on new HTF bar\r\nif isNewHTFBar\r\n    alertedBreakoutSupport := false\r\n    alertedBreakoutResistance := false\r\n    alertedSignificantBreakoutSupport := false\r\n    alertedSignificantBreakoutResistance := false\r\n    alertedRetestSupport := false\r\n    alertedRetestResistance := false\r\n\r\n// Update levels every bar\r\nif array.size(srLevels) > 0 and not na(htfBarDuration) and not na(htfCurrentClose) and not na(htfCurrentTime)\r\n    // First pass: check for mitigation and set alert conditions\r\n    for i = array.size(srLevels) - 1 to 0\r\n        level = array.get(srLevels, i)\r\n        if not level.isMitigated\r\n            // Check mitigation only after first candle (skip immediate next candle)\r\n            if htfCurrentTime >= level.mitigationAllowedTime\r\n                if level.isBreach(htfCurrentClose)\r\n                    level.markMitigated(htfCurrentTime, htfBarDuration)\r\n                    \r\n                    // Check for significant breakout\r\n                    [isSignificant, isCoherent] = checkSignificantBreakout(level.price, level.isResistance, htfCurrentOpen, htfCurrentClose, htfCurrentHigh, htfCurrentLow)\r\n                    \r\n                    // Set breakout alert conditions (only coherent breakouts)\r\n                    if isCoherent\r\n                        // Basic breakout conditions\r\n                        if level.isResistance and not alertedBreakoutResistance\r\n                            alertedBreakoutResistance := true\r\n                            breakoutResistance := true\r\n                            // Debug marker for resistance breakout\r\n                            if showDebugBreakouts\r\n                                label.new(bar_index, htfCurrentHigh, \"‚¨ÜÔ∏è BRK R\\n\" + str.tostring(level.price, format.mintick), \r\n                                  color=color.new(color.lime, 20), textcolor=color.white, \r\n                                  style=label.style_label_down, size=size.small)\r\n                        \r\n                        if not level.isResistance and not alertedBreakoutSupport\r\n                            alertedBreakoutSupport := true\r\n                            breakoutSupport := true\r\n                            // Debug marker for support breakout\r\n                            if showDebugBreakouts\r\n                                label.new(bar_index, htfCurrentLow, \"‚¨áÔ∏è BRK S\\n\" + str.tostring(level.price, format.mintick), \r\n                                  color=color.new(color.red, 20), textcolor=color.white, \r\n                                  style=label.style_label_up, size=size.small)\r\n                        \r\n                        // Significant breakout conditions\r\n                        if isSignificant\r\n                            if level.isResistance and not alertedSignificantBreakoutResistance\r\n                                alertedSignificantBreakoutResistance := true\r\n                                significantBreakoutResistance := true\r\n                                // Debug marker for significant resistance breakout\r\n                                if showDebugSignificantBreakouts\r\n                                    label.new(bar_index, htfCurrentHigh * 1.001, \"üöÄ SIG R\\n\" + str.tostring(level.price, format.mintick), \r\n                                      color=color.new(color.aqua, 10), textcolor=color.white, \r\n                                      style=label.style_label_down, size=size.normal)\r\n                            \r\n                            if not level.isResistance and not alertedSignificantBreakoutSupport\r\n                                alertedSignificantBreakoutSupport := true\r\n                                significantBreakoutSupport := true\r\n                                // Debug marker for significant support breakout\r\n                                if showDebugSignificantBreakouts\r\n                                    label.new(bar_index, htfCurrentLow * 0.999, \"üí• SIG S\\n\" + str.tostring(level.price, format.mintick), \r\n                                      color=color.new(color.fuchsia, 10), textcolor=color.white, \r\n                                      style=label.style_label_up, size=size.normal)\r\n                else\r\n                    // Level not breached - check for retest\r\n                    if not na(htfATR) and htfATR > 0\r\n                        bool isRetest = checkRetest(level.price, level.isResistance, htfCurrentOpen, htfCurrentClose, htfCurrentHigh, htfCurrentLow, htfATR, htfPrevOpen, htfPrevLow, htfPrevHigh, htfPrevClose)\r\n                        \r\n                        if isRetest\r\n                            if level.isResistance and not alertedRetestResistance\r\n                                alertedRetestResistance := true\r\n                                retestResistance := true\r\n                                // Debug marker for resistance retest\r\n                                if showDebugRetests\r\n                                    label.new(bar_index, htfCurrentHigh, \"üîª RT\\n\" + str.tostring(level.price, format.mintick), \r\n                                      color=color.new(resistanceColor, 30), textcolor=color.white, \r\n                                      style=label.style_label_down, size=size.small)\r\n                            \r\n                            if not level.isResistance and not alertedRetestSupport\r\n                                alertedRetestSupport := true\r\n                                retestSupport := true\r\n                                // Debug marker for support retest\r\n                                if showDebugRetests\r\n                                    label.new(bar_index, htfCurrentLow, \"üî∫ RT\\n\" + str.tostring(level.price, format.mintick), \r\n                                      color=color.new(supportColor, 30), textcolor=color.white, \r\n                                      style=label.style_label_up, size=size.small)\r\n    \r\n    // Build arrays of active levels ABOVE and BELOW current price, sorted by distance\r\n    array<int> aboveIndices = array.new<int>()\r\n    array<float> aboveDistances = array.new<float>()\r\n    array<int> belowIndices = array.new<int>()\r\n    array<float> belowDistances = array.new<float>()\r\n    \r\n    for i = 0 to array.size(srLevels) - 1\r\n        level = array.get(srLevels, i)\r\n        if not level.isMitigated\r\n            float dist = math.abs(level.price - close)\r\n            if level.price > close\r\n                // Level is ABOVE current price\r\n                array.push(aboveIndices, i)\r\n                array.push(aboveDistances, dist)\r\n            else\r\n                // Level is BELOW current price\r\n                array.push(belowIndices, i)\r\n                array.push(belowDistances, dist)\r\n    \r\n    // Sort by distance (closest first) using simple bubble sort\r\n    if array.size(aboveIndices) > 1\r\n        for i = 0 to array.size(aboveIndices) - 2\r\n            for j = 0 to array.size(aboveIndices) - 2 - i\r\n                if array.get(aboveDistances, j) > array.get(aboveDistances, j + 1)\r\n                    // Swap distances\r\n                    float tmpDist = array.get(aboveDistances, j)\r\n                    array.set(aboveDistances, j, array.get(aboveDistances, j + 1))\r\n                    array.set(aboveDistances, j + 1, tmpDist)\r\n                    // Swap indices\r\n                    int tmpIdx = array.get(aboveIndices, j)\r\n                    array.set(aboveIndices, j, array.get(aboveIndices, j + 1))\r\n                    array.set(aboveIndices, j + 1, tmpIdx)\r\n    \r\n    if array.size(belowIndices) > 1\r\n        for i = 0 to array.size(belowIndices) - 2\r\n            for j = 0 to array.size(belowIndices) - 2 - i\r\n                if array.get(belowDistances, j) > array.get(belowDistances, j + 1)\r\n                    // Swap distances\r\n                    float tmpDist = array.get(belowDistances, j)\r\n                    array.set(belowDistances, j, array.get(belowDistances, j + 1))\r\n                    array.set(belowDistances, j + 1, tmpDist)\r\n                    // Swap indices\r\n                    int tmpIdx = array.get(belowIndices, j)\r\n                    array.set(belowIndices, j, array.get(belowIndices, j + 1))\r\n                    array.set(belowIndices, j + 1, tmpIdx)\r\n    \r\n    // Mark which levels to show (closest N above and closest N below)\r\n    array<bool> shouldShow = array.new<bool>()\r\n    for i = 0 to array.size(srLevels) - 1\r\n        array.push(shouldShow, false)\r\n    \r\n    // Mark closest N levels above\r\n    int aboveCount = math.min(maxLevels, array.size(aboveIndices))\r\n    if aboveCount > 0\r\n        for i = 0 to aboveCount - 1\r\n            int idx = array.get(aboveIndices, i)\r\n            array.set(shouldShow, idx, true)\r\n    \r\n    // Mark closest N levels below\r\n    int belowCount = math.min(maxLevels, array.size(belowIndices))\r\n    if belowCount > 0\r\n        for i = 0 to belowCount - 1\r\n            int idx = array.get(belowIndices, i)\r\n            array.set(shouldShow, idx, true)\r\n    \r\n    // Second pass: update visuals and remove expired/excess levels\r\n    for i = array.size(srLevels) - 1 to 0\r\n        level = array.get(srLevels, i)\r\n        bool shouldRemove = false\r\n        \r\n        if level.isMitigated\r\n            if showMitigated\r\n                int mitigatedEndTime = math.min(level.visibleUntilTime, extensionTime)\r\n                level.applyMitigatedVisual(mitigatedEndTime)\r\n                if level.hasExpired(htfCurrentTime)\r\n                    shouldRemove := true\r\n            else\r\n                shouldRemove := true\r\n        else\r\n            // Check if this level should be shown based on distance sorting\r\n            bool showThisLevel = i < array.size(shouldShow) ? array.get(shouldShow, i) : false\r\n            \r\n            if not showThisLevel\r\n                shouldRemove := true\r\n            else\r\n                level.applyActiveVisual(extensionTime)\r\n                \r\n                // Check expiration\r\n                if level.hasExpired(htfCurrentTime)\r\n                    shouldRemove := true\r\n        \r\n        if shouldRemove\r\n            level.delete()\r\n            array.remove(srLevels, i)\r\n    \r\n    // Update right labels on last bar\r\n    if barstate.islast and showRightLabels\r\n        // Update or create right labels for all visible levels\r\n        for i = 0 to array.size(srLevels) - 1\r\n            level = array.get(srLevels, i)\r\n            \r\n            // Only show label if level is visible (not removed)\r\n            bool isVisible = level.isMitigated ? showMitigated : true\r\n            if isVisible\r\n                string levelType = level.isResistance ? \"Resistance\" : \"Support\"\r\n                string statusStr = level.isMitigated ? \" ‚úó\" : \"\"\r\n                string labelText = \" \" + humanReadableSRTF + \" \" + levelType + statusStr + \" \"\r\n                \r\n                color textColor = level.isMitigated ? mitigatedColor : (level.isResistance ? resistanceColor : supportColor)\r\n                \r\n                // Delete old label if exists\r\n                if not na(level.rightLabel)\r\n                    level.rightLabel.delete()\r\n                \r\n                // Create new label with white background and colored text\r\n                if rightLabelSize == \"tiny\"\r\n                    level.rightLabel := label.new(bar_index + 3, level.price, labelText, xloc.bar_index, yloc.price, color.white, label.style_label_left, textColor, size.tiny)\r\n                else if rightLabelSize == \"small\"\r\n                    level.rightLabel := label.new(bar_index + 3, level.price, labelText, xloc.bar_index, yloc.price, color.white, label.style_label_left, textColor, size.small)\r\n                else if rightLabelSize == \"normal\"\r\n                    level.rightLabel := label.new(bar_index + 3, level.price, labelText, xloc.bar_index, yloc.price, color.white, label.style_label_left, textColor, size.normal)\r\n                else if rightLabelSize == \"large\"\r\n                    level.rightLabel := label.new(bar_index + 3, level.price, labelText, xloc.bar_index, yloc.price, color.white, label.style_label_left, textColor, size.large)\r\n                else\r\n                    level.rightLabel := label.new(bar_index + 3, level.price, labelText, xloc.bar_index, yloc.price, color.white, label.style_label_left, textColor, size.small)\r\n\r\n// ============================================================================\r\n// PRICE SCALE LABELS (trackprice)\r\n// ============================================================================\r\n\r\n// Get level price and color by index (combined for efficiency)\r\ngetLevelPriceAndColor(int index, bool isMitigated) =>\r\n    float resultPrice = na\r\n    color resultColor = na\r\n    if showPriceScale and barstate.islast\r\n        int count = 0\r\n        if array.size(srLevels) > 0\r\n            for i = 0 to array.size(srLevels) - 1\r\n                level = array.get(srLevels, i)\r\n                // Only include levels with valid visual elements\r\n                if level.isMitigated == isMitigated and not na(level.levelLine)\r\n                    if count == index\r\n                        resultPrice := level.price\r\n                        resultColor := isMitigated ? mitigatedColor : (level.isResistance ? resistanceColor : supportColor)\r\n                        break\r\n                    count += 1\r\n    [resultPrice, resultColor]\r\n\r\n// Get level price by index (wrapper for compatibility)\r\ngetLevelPrice(int index, bool isMitigated) =>\r\n    [price, color] = getLevelPriceAndColor(index, isMitigated)\r\n    price\r\n\r\n// Get level color by index (wrapper for compatibility)\r\ngetLevelColor(int index, bool isMitigated) =>\r\n    [price, color] = getLevelPriceAndColor(index, isMitigated)\r\n    color\r\n\r\n// Plot active levels on price scale (up to 10)\r\nplot(getLevelPrice(0, false), \"Active 1\", color=getLevelColor(0, false), style=plot.style_linebr, trackprice=true, display=display.price_scale)\r\nplot(getLevelPrice(1, false), \"Active 2\", color=getLevelColor(1, false), style=plot.style_linebr, trackprice=true, display=display.price_scale)\r\nplot(getLevelPrice(2, false), \"Active 3\", color=getLevelColor(2, false), style=plot.style_linebr, trackprice=true, display=display.price_scale)\r\nplot(getLevelPrice(3, false), \"Active 4\", color=getLevelColor(3, false), style=plot.style_linebr, trackprice=true, display=display.price_scale)\r\nplot(getLevelPrice(4, false), \"Active 5\", color=getLevelColor(4, false), style=plot.style_linebr, trackprice=true, display=display.price_scale)\r\nplot(getLevelPrice(5, false), \"Active 6\", color=getLevelColor(5, false), style=plot.style_linebr, trackprice=true, display=display.price_scale)\r\nplot(getLevelPrice(6, false), \"Active 7\", color=getLevelColor(6, false), style=plot.style_linebr, trackprice=true, display=display.price_scale)\r\nplot(getLevelPrice(7, false), \"Active 8\", color=getLevelColor(7, false), style=plot.style_linebr, trackprice=true, display=display.price_scale)\r\nplot(getLevelPrice(8, false), \"Active 9\", color=getLevelColor(8, false), style=plot.style_linebr, trackprice=true, display=display.price_scale)\r\nplot(getLevelPrice(9, false), \"Active 10\", color=getLevelColor(9, false), style=plot.style_linebr, trackprice=true, display=display.price_scale)\r\n\r\n// Plot mitigated levels on price scale (up to 5)\r\nplot(getLevelPrice(0, true), \"Mitigated 1\", color=mitigatedColor, style=plot.style_linebr, trackprice=true, display=display.price_scale)\r\nplot(getLevelPrice(1, true), \"Mitigated 2\", color=mitigatedColor, style=plot.style_linebr, trackprice=true, display=display.price_scale)\r\nplot(getLevelPrice(2, true), \"Mitigated 3\", color=mitigatedColor, style=plot.style_linebr, trackprice=true, display=display.price_scale)\r\nplot(getLevelPrice(3, true), \"Mitigated 4\", color=mitigatedColor, style=plot.style_linebr, trackprice=true, display=display.price_scale)\r\nplot(getLevelPrice(4, true), \"Mitigated 5\", color=mitigatedColor, style=plot.style_linebr, trackprice=true, display=display.price_scale)\r\n\r\n// ============================================================================\r\n// ALERT CONDITIONS\r\n// ============================================================================\r\n\r\n// New Pivot Alerts\r\nalertcondition(newPivotResistance or newPivotSupport, title=\"New Pivot (any)\", message=\"New Pivot detected\")\r\nalertcondition(newPivotSupport, title=\"New Pivot Support\", message=\"New Support Pivot detected\")\r\nalertcondition(newPivotResistance, title=\"New Pivot Resistance\", message=\"New Resistance Pivot detected\")\r\n\r\n// Breakout Alerts\r\nalertcondition(breakoutResistance or breakoutSupport, title=\"Breakout (any)\", message=\"Breakout detected\")\r\nalertcondition(breakoutSupport, title=\"Breakout Support\", message=\"Support Breakout detected\")\r\nalertcondition(breakoutResistance, title=\"Breakout Resistance\", message=\"Resistance Breakout detected\")\r\n\r\n// Significant Breakout Alerts\r\nalertcondition(significantBreakoutResistance or significantBreakoutSupport, title=\"Significant Breakout (any)\", message=\"Significant Breakout detected\")\r\nalertcondition(significantBreakoutSupport, title=\"Significant Breakout Support\", message=\"Significant Support Breakout detected\")\r\nalertcondition(significantBreakoutResistance, title=\"Significant Breakout Resistance\", message=\"Significant Resistance Breakout detected\")\r\n\r\n// Retest Alerts\r\nalertcondition(retestResistance or retestSupport, title=\"Retest Level (any)\", message=\"Level Retest detected\")\r\nalertcondition(retestSupport, title=\"Retest Support\", message=\"Support Retest detected - bullish bounce\")\r\nalertcondition(retestResistance, title=\"Retest Resistance\", message=\"Resistance Retest detected - bearish rejection\")\r\n"
  },
  "https://www.tradingview.com/script/7aUUCr3m-RSI-Median-Deviation/": {
    "id": 20086651,
    "url": "https://www.tradingview.com/script/7aUUCr3m-RSI-Median-Deviation/",
    "name": "RSI Median Deviation",
    "description": "RSI Median Deviation ‚Äì Adaptive Statistical RSI for High-Probability Extremes\n\nThe Relative Strength Index (RSI) is a momentum oscillator developed by J. Welles Wilder in 1978 to measure the magnitude of recent price changes and identify potential overbought or oversold conditions. It calculates the ratio of upward to downward price movements over a specified period, scaled to 0-100. However, standard RSI often relies on fixed thresholds like 70/30, which can produce unreliable signals in varying market regimes due to their lack of adaptability to the actual distribution of RSI values.\n\nThis indicator was developed because I needed a reliable tool for spotting intermediate high-probability bottoms and tops. Instead of arbitrary horizontal lines, it uses the RSI‚Äôs own historical median as a dynamic centerline and measures how far the current RSI deviates from that median over a chosen lookback period. The main signals are triggered only at 2 standard deviation (2œÉ) extremes ‚Äî statistically rare events that occur roughly 5 % of the time under a normal distribution. I selected 2œÉ because it is extreme enough to be meaningful yet frequent enough for practical trading. For oversold signals I further require RSI to be below 42, a filter that significantly improved results in my mean-reversion tests (enter on oversold, exit on the first bar the condition is no longer true).\n\n   \n\nThe combination of percentile median + standard deviation bands is deliberate: the median is far more robust to outliers than a simple average, while the SD bands automatically adjust to the current volatility of the RSI itself, producing adaptive envelopes that work equally well in ranging and trending markets.\n\n Underlying Concepts and Calculations \n\nBase RSI: RSI = 100 ‚àí (100 / (1 + RS)), RS = average gain / average loss (default length 10).\nPercentile Median: 50th percentile of the last \"N\" RSI values (default 28 = 4 weeks) \n‚Üí dynamic, outlier-resistant centerline.\n\nStandard Deviation Bands: rolling stdev of RSI (default length 27 = = 4 weeks (almost)) \n‚Üí bands = median ¬± 1œÉ / 2œÉ.\n\nOptional Dynamic MA Envelopes: user-selectable moving average (TEMA, WMA, etc., default WMA length 37) for additional momentum context.\n\n  \n\n Trend Bias Coloring \n\nIndependent of the statistical extremes, the RSI line itself is colored green when above the user-defined Long Threshold (default 60) and red when below the Short Threshold (default 47). This provides an instant bullish/bearish bias overlay similar to classic RSI usage, without interfering with the main 2œÉ extreme signals.\nExtremes are highlighted with background color (green for oversold 2œÉ + RSI<42, magenta for overbought 2œÉ) and small diamond markers for ultra-extremes (RSI <25 or >85).\n\n  \n\n Originality and Development Rationale \n\nThe indicator was built and refined through extensive testing on dozens of assets including major cryptocurrencies:\n\n (BTC, ETH, SOL, SUI, BNB, XRP, TRX, DOGE, LINK, PAXG, CVX, HYPE, VIRTUAL and many more), \nthe Magnificent 7 stocks,, QQQ, SPX, and gold.\n \nDefault parameters were chosen to deliver consistent profitability in simple mean-reversion setups while maximizing Sortino ratio and minimizing maximum drawdown across this broad universe ‚Äî ensuring the settings are robust and not overfitted to any single instrument or timeframe.\n\n How to Use It \n\nIdeal for swing / position trading on the 1h to daily charts (the same defaults work).\n\nOversold (high-probability long): RSI crosses below lower 2œÉ band AND RSI < 42 \n‚Üí green background \n‚Üí enter long, exit the first bar the condition disappears.\n\nOverbought (high-probability short): RSI crosses above upper 2œÉ band \n‚Üí magenta background \n‚Üí enter short, exit on opposite signal or at median. (Shorts were not tested, it's only an idea)\n\nUse the green/red RSI line coloring for quick trend context and to avoid fighting strong momentum.\n\n Always confirm with price action and manage risk appropriately. \n\n This indicator is not a standalone trading system. \n\n Disclaimer: This is not financial advice. Backtests are based on past results and are not indicative of future performance. \n",
    "author_name": "PaulWegelin",
    "likes_count": 17,
    "comments_count": 2,
    "views_count": 0,
    "created_at": "2025-12-11T18:20:39+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "INDEX:BTCUSD",
      "full_name": "INDEX:BTCUSD",
      "short_name": "BTCUSD",
      "exchange": "INDEX",
      "type": "index",
      "logo_id": null,
      "currency_logo_id": "country/US",
      "base_currency_logo_id": "crypto/XTVCBTC",
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/crypto/XTVCBTC.svg"
      ],
      "interval": "1D",
      "direction": 0,
      "badge": {
        "label": "INDEX:BTCUSD",
        "url": "/symbols/BTCUSD/"
      }
    },
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "// This Pine Script‚Ñ¢ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// ¬© PaulWegelin\r\n\r\n//@version=6\r\nindicator(\"RSI Median Deviation\", max_labels_count = 500)\r\nimport TradingView/ta/11\r\n\r\n//              ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó              //\r\n//              ‚ïë         SETTINGS         ‚ïë              //\r\n//              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù              //\r\n\r\nvar string CS       = \"RSi Settings\", var string CSS = \"RSI Smoothing Settings\"\r\n\r\nsrc                 = input.source(close,       \"RSI Source\",                                       group = CS)\r\nrsiLength           = input.int(10,             \"RSI Length\",                                       group = CS)\r\n\r\nlongTH              = input.int(60,             \"Long Threshold\",                                   group = CS)\r\nshortTH             = input.int(47,             \"Short Threshold\",                                  group = CS)\r\n\r\nlength              = input.int(28,             \"Median Length\",                                    group= CSS ,minval = 1, step=1)\r\nsdLength            = input.int(27,             \"SD Length\",                                        group = CSS)\r\nrsiMA               = input.string(\"TEMA\",      \"RSI MA-Type\",                                      group = CSS,  options = [\"SMA\", \"EMA\", \"DEMA\", \"TEMA\", \"WMA\", \"VWMA\",\"HMA\" , \"ALMA\"])\r\nsmoothLEN           = input.int(27,             \"RSI MA Length\",                                    group = CSS)\r\n\r\nbandLEN             = input.int(37,             \"RSI MA Band Length\",                               group = \"MA Bands\")\r\nrsiMA2              = input.string(\"WMA\",       \"RSI Band MA-Type\",                                 group = \"MA Bands\",  options = [\"SMA\", \"EMA\", \"DEMA\", \"TEMA\", \"WMA\", \"VWMA\", \"HMA\", \"ALMA\"])\r\n\r\n//              ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó              //\r\n//              ‚ïë     DYNAMIC MA INPUT     ‚ïë              //\r\n//              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù              //\r\n\r\nma(type, src, len) =>\r\n    float result = na\r\n    if type == \"SMA\"  \r\n        result := ta.sma(src, len)\r\n        result\r\n    else if type == \"EMA\"  \r\n        result := ta.ema(src, len)\r\n        result\r\n    else if type == \"DEMA\"  \r\n        result := ta.dema(src, len)\r\n        result\r\n    else if type == \"TEMA\"  \r\n        result := ta.tema(src, len)\r\n        result\r\n    else if type == \"WMA\"  \r\n        result := ta.wma(src, len)\r\n        result\r\n    else if type == \"VWMA\"\r\n        result := ta.vwma(src, len)\r\n        result\r\n    else if type == \"HMA\"  \r\n        result := ta.hma(src, len)\r\n        result\r\n    else if type == \"ALMA\"\r\n        result := ta.alma(src, len, 0, 6)\r\n        result\r\n    result\r\n\r\n//              ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó              //\r\n//              ‚ïë       Calculations       ‚ïë              //\r\n//              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù              //\r\n\r\nrsi         = ta.rsi(src, rsiLength)\r\ndynRSIfl    = ma(rsiMA, rsi, smoothLEN)\r\nmedian      = ta.percentile_nearest_rank(rsi, length,50)\r\n\r\n//              ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó              //\r\n//              ‚ïë    Standard Deviation    ‚ïë              //\r\n//              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù              //\r\n\r\nstdev       = ta.stdev(rsi , sdLength)\r\nu1          = median + 1 * stdev\r\nu2          = median + 2 * stdev\r\n\r\nd1          = median - 1 * stdev\r\nd2          = median - 2 * stdev\r\n\r\nbandL       = close > d1\r\nbandS       = close < u1\r\n\r\ndynRSIfl2    = ma(rsiMA2, rsi, bandLEN)\r\ndynBandUP   = dynRSIfl2 + 2 * stdev\r\ndynBandDOWN = dynRSIfl2 - 2 * stdev\r\n\r\n//              ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó              //\r\n//              ‚ïë     Trend Condition      ‚ïë              //\r\n//              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù              //\r\n\r\nL           = rsi > longTH\r\nS           = rsi < shortTH\r\n\r\nvar trend = 0\r\n\r\nif L and not S \r\n\ttrend := 1\r\n\r\nif S \r\n\ttrend := -1\r\n\r\n//              ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó              //\r\n//              ‚ïë      Colors & Bools      ‚ïë              //\r\n//              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù              //\r\n\r\n//Switches\r\nCalc                 = input.string(\"Median SD\", title=\"OBOS Calculations\", group=\"Switches\", \r\n     options = [\"Median SD\", \"Moving Average SD\"], display = display.none)\r\n\r\n\r\nCol                 = input.string(\"SciFi\", title=\"Color Settings\", group=\"Switches\", \r\n     options = [\"Original\", \"Classic\", \"SciFi\", \"Ocean\",\"Lush\", \"Evening\", \"Ultra Violet\", \"Monochrom\", \"Ice\"], display = display.none)\r\n\r\n\r\n[color_up, color_dn]=  switch   Col\r\n    \"Original\"      => [#00d400, #b10000]\r\n    \"Classic\"       => [#00ffdd, #ff0095]\r\n    \"SciFi\"         => [#00FFFF, #FF00FF] \r\n    \"Ocean\"         => [#10cab8, #2196f3]\r\n    \"Lush\"          => [#5ffae0, #c22ed0]\r\n    \"Evening\"       => [#ffbb00, #770737]\r\n    \"Ultra Violet\"  => [#9618f7, #ff0078]\r\n    \"Monochrom\"     => [#dee2e6, #495057]\r\n    \"Ice\"           => [#049ef7, #ffffff]\r\n\r\ncolor col_up0       = color_up\r\ncolor col_up25      = color.new(color_up, 25)\r\ncolor col_up50      = color.new(color_up, 50)\r\ncolor col_up75      = color.new(color_up, 75)\r\ncolor col_up80      = color.new(color_up, 80)\r\ncolor col_dn0       = color_dn\r\ncolor col_dn25      = color.new(color_dn, 25)\r\ncolor col_dn50      = color.new(color_dn, 50)\r\ncolor col_dn75      = color.new(color_dn, 75)\r\ncolor col_dn80      = color.new(color_dn, 80)\r\n\r\n//              ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó              //\r\n//              ‚ïë     OS/OB Conditions     ‚ïë              //\r\n//              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù              //\r\n\r\n//OB & OS switches and bools\r\nOnOff               = input.bool(true,          \"Turn BG On/Off\",                                  group = \"OS and OB\")\r\ncriticalOSOB        = input.bool(true,          \"Extreme OS/OB Signal\",                            group = \"OS and OB\")\r\nbarswitch           = input.bool(false,         \"Barcolor On/Off\",                                 group = \"OS and OB\")\r\n\r\n\r\n//OB & OS calculations\r\nmedianOS            = (rsi < d2) and rsi < 42\r\nmedianOB            = (rsi > u2)\r\n\r\nmaOS                = (rsi < dynBandDOWN)\r\nmaOB                = (rsi > dynBandUP)\r\n\r\nmedianEXTREMES      = medianOS ? col_up80 : medianOB ? col_dn80 : na\r\nmaEXTREMES          = maOS     ? col_up80 : maOB     ? col_dn80 : na\r\n\r\noppertunityZone     = rsi < 25 \r\ndangerZone          = rsi > 85\r\n\r\nOSOBswitch =  switch Calc\r\n    \"Median SD\"            => medianEXTREMES\r\n    \"Moving Average SD\"    => maEXTREMES\r\n\r\nOBOS_COL            = OnOff ? OSOBswitch : na\r\nbarcolor            = trend >  0 ? col_up50 : trend < 0 ?  col_dn50 : na\r\nchartCol            = barswitch ? barcolor : na\r\n\r\n//              ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó              //\r\n//              ‚ïë           PLOTS          ‚ïë              //\r\n//              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù              //\r\n\r\n//RSI Plots\r\nrsi_p               = plot(rsi, linewidth = 2, color = trend >  0 ? col_up0 : trend < 0 ?  col_dn0 : na)                                        // RSI plot                                       \r\n\r\nrsi_dny             = plot(dynRSIfl, linewidth = 1, color = dynRSIfl < median ? col_dn50 : dynRSIfl > median ? col_up50 : color.gray)         // Dynamic RSI plot\r\n\r\nup                  = plot(longTH, display = display.none, editable = false)\r\nlw                  = plot(shortTH, display = display.none, editable = false)\r\n\r\n//Zone and Line Plots\r\nU2                  = plot(dynBandUP, color = col_dn25, linewidth = 2)                                                                          // Dynamic MA upper Band\r\nL1                  = plot(dynBandDOWN, color = col_up25, linewidth = 2)                                                                        // Dynamic MA lower Band\r\n\r\n//Median and Bands\r\nmaRSI               = plot(median, title = \"smoothed RSI\", linewidth = 1,color = dynRSIfl < median ? col_dn25 : dynRSIfl > median ? col_up25 : color.gray)\r\nmaRSIband2          = plot(u2, color = col_dn75, linewidth = 2, display = display.all)\r\nmaRSIband5          = plot(d2, color = col_up75, linewidth = 2, display = display.all)\r\n\r\n//              ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó              //\r\n//              ‚ïë Fill, Shapes and Candles ‚ïë              //\r\n//              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù              //\r\n\r\n//Shapes, fills and background\r\nfill(maRSIband2, maRSI, u2, median, col_dn75, color.new(chart.bg_color, 75), \"Second Band\", display = display.all)\r\nfill(maRSI, maRSIband5, median, d2, color.new(chart.bg_color, 75), col_up75, \"Second Band\", display = display.all)\r\n\r\nplotshape(oppertunityZone and criticalOSOB, \"OS\", style = shape.diamond, location = location.bottom, color = col_up50, size = size.tiny)\r\nplotshape(dangerZone and criticalOSOB,      \"OB\", style = shape.diamond, location = location.top,    color = col_dn50, size = size.tiny)\r\n\r\nbgcolor(OBOS_COL, force_overlay = false)\r\n\r\nplotcandle(open, high, low, close, 'BarColor', color = chartCol, bordercolor = chartCol, wickcolor = chartCol, force_overlay = true)\r\n\r\n//              ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó              //\r\n//              ‚ïë          Alerts          ‚ïë              //\r\n//              ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù              //\r\n\r\n// Long (Bullish) Condition Alert.\r\nalertcondition(trend > 0,  title = \"RSI Long\",  message = \"RSI Median Deviation above threshold on: {{exchange}}:{{ticker}}\")\r\nalertcondition(medianOS,  title = \"RSI Median Deviation Bands oversold\",  message = \"RSI Median Deviation Bands oversold on: {{exchange}}:{{ticker}}\")\r\nalertcondition(maOS,  title = \"RSI Median Deviation MA oversold\",  message = \"RSI Median Deviation oversold MA on: {{exchange}}:{{ticker}}\")\r\nalertcondition(dynRSIfl > median,  title = \"RSI Median Deviation increasing momentum\",  message = \"RSI Median Deviation increasing momentum on: {{exchange}}:{{ticker}}\")\r\n\r\n// Short/Cash (Bearish) Condition Alert.\r\nalertcondition(trend < 0,  title = \"RSI Short\",  message = \"RSI Median Deviation below threshold on: {{exchange}}:{{ticker}}\")\r\nalertcondition(medianOB,  title = \"RSI Median Deviation Bands overbought\",  message = \"RSI Median Deviation Bands overbought on: {{exchange}}:{{ticker}}\")\r\nalertcondition(maOB,  title = \"RSI Median Deviation MA overbought\",  message = \"RSI Median Deviation overbought MA on: {{exchange}}:{{ticker}}\")\r\nalertcondition(dynRSIfl < median,  title = \"RSI Median Deviation slowing momentum\",  message = \"RSI Median Deviation slowing momentum on: {{exchange}}:{{ticker}}\")\r\n\r\n//:)"
  },
  "https://www.tradingview.com/script/eNcNUgzX-Situational-Awareness-Structure/": {
    "id": 20084497,
    "url": "https://www.tradingview.com/script/eNcNUgzX-Situational-Awareness-Structure/",
    "name": "Situational Awareness - Structure",
    "description": "Green dot is positive structure\nred dot is negative structure ",
    "author_name": "ecdesk06",
    "likes_count": 53,
    "comments_count": 0,
    "views_count": 0,
    "created_at": "2025-12-11T11:26:44+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "TVC:SILVER",
      "full_name": "TVC:SILVER",
      "short_name": "SILVER",
      "exchange": "TVC",
      "type": "commodity",
      "logo_id": "metal/silver",
      "currency_logo_id": "country/US",
      "base_currency_logo_id": null,
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/metal/silver.svg"
      ],
      "interval": "1D",
      "direction": 0,
      "badge": {
        "label": "TVC:SILVER",
        "url": "/symbols/SILVER/"
      }
    },
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=5\r\nindicator(\"Pivot HH&HL ‚Äî MultiTF Dots (mid-right) + Red for LH&LL\", overlay=true)\r\n\r\n// ===== Inputs =====\r\nlen = input.int(10, \"Pivot Length (len)\", minval=1)\r\n\r\n// Timeframe 1\r\nuse_tf1 = input.bool(true, \"Enable TF1\")\r\ntf1 = input.string(\"D\", \"TF1 timeframe\")\r\n// Timeframe 2\r\nuse_tf2 = input.bool(true, \"Enable TF2\")\r\ntf2 = input.string(\"240\", \"TF2 timeframe\")\r\n// Timeframe 3\r\nuse_tf3 = input.bool(false, \"Enable TF3\")\r\ntf3 = input.string(\"60\", \"TF3 timeframe\")\r\n// Timeframe 4\r\nuse_tf4 = input.bool(false, \"Enable TF4\")\r\ntf4 = input.string(\"15\", \"TF4 timeframe\")\r\n\r\ndot_symbol = input.string(\"‚óè\", \"Dot symbol\")\r\ndot_size = input.string(\"large\", \"Dot text size\", options=[\"tiny\",\"small\",\"normal\",\"large\",\"huge\"])\r\n\r\n// // helper: map text size\r\n// f_text_size(_s) =>\r\n//     _s == \"tiny\" ? size.tiny :\r\n//     _s == \"small\" ? size.small :\r\n//     _s == \"normal\" ? size.normal :\r\n//     _s == \"large\" ? size.large :\r\n//     size.huge\r\n\r\n// txt_size = f_text_size(dot_size)\r\n\r\n// ===== function to compute HH&HL / LH&LL on a given timeframe (runs inside that TF via request.security) =====\r\n// Returns: 1 = HH & HL (green), 2 = LH & LL (red), 0 = none\r\nget_hhhl_flag(lenTF) =>\r\n    ph = ta.pivothigh(high, lenTF, lenTF)\r\n    pl = ta.pivotlow(low, lenTF, lenTF)\r\n    // persistent holders on that timeframe\r\n    var float lastH = na\r\n    var float prevH = na\r\n    var float lastL = na\r\n    var float prevL = na\r\n    if not na(ph)\r\n        prevH := lastH\r\n        lastH := ph\r\n    if not na(pl)\r\n        prevL := lastL\r\n        lastL := pl\r\n    // Need two highs and two lows\r\n    haveTwo = not na(lastH) and not na(prevH) and not na(lastL) and not na(prevL)\r\n    if not haveTwo\r\n        0\r\n    else\r\n        hh = lastH > prevH\r\n        hl = lastL > prevL\r\n        lh = lastH < prevH\r\n        ll = lastL < prevL\r\n        hh and hl ? 1 : (lh and ll ? 2 : 0)\r\n\r\n// ===== request.security calls for each enabled TF =====\r\nflag_tf1 = use_tf1 ? request.security(syminfo.tickerid, tf1, get_hhhl_flag(len), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off) : 0\r\nflag_tf2 = use_tf2 ? request.security(syminfo.tickerid, tf2, get_hhhl_flag(len), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off) : 0\r\nflag_tf3 = use_tf3 ? request.security(syminfo.tickerid, tf3, get_hhhl_flag(len), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off) : 0\r\nflag_tf4 = use_tf4 ? request.security(syminfo.tickerid, tf4, get_hhhl_flag(len), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off) : 0\r\n\r\n// ===== Build list of enabled TFs and flags =====\r\nvar string[] tfLabels = array.new_string()\r\nvar int[]    tfFlags  = array.new_int()\r\n\r\n// helper to add if enabled\r\nf_add_tf(_use, _label, _flag) =>\r\n    if _use\r\n        array.push(tfLabels, _label)\r\n        array.push(tfFlags, _flag)\r\n\r\n// reset arrays each bar to keep alignment with latest enabled set\r\narray.clear(tfLabels)\r\narray.clear(tfFlags)\r\n\r\nf_add_tf(use_tf1, tf1, flag_tf1)\r\nf_add_tf(use_tf2, tf2, flag_tf2)\r\nf_add_tf(use_tf3, tf3, flag_tf3)\r\nf_add_tf(use_tf4, tf4, flag_tf4)\r\n\r\n// ===== Draw mid-right table with rows = enabled TFs, 2 columns (label | dot) =====\r\nrows = array.size(tfLabels)\r\n\r\n// create table once (persistent). We'll reuse same table variable.\r\nvar table t = table.new(position.middle_right, 4, 2)\r\n\r\n// Clear and rewrite only on last bar to keep UI stable\r\nif barstate.islast\r\n    // clear all allocated rows (4) first\r\n    for r = 0 to 3\r\n        table.cell(t, r, 0, \"\")\r\n        table.cell(t, r, 1, \"\")\r\n    // fill enabled rows\r\n    for i = 0 to rows - 1\r\n        lbl = array.get(tfLabels, i)\r\n        flag = array.get(tfFlags, i)\r\n        // left cell: timeframe label\r\n        table.cell(t, i, 0, lbl, text_color=color.white, bgcolor=color.new(color.black, 80), text_size=size.small)\r\n        // right cell: dot if flag==1 (green) or flag==2 (red)\r\n        if flag == 1\r\n            table.cell(t, i, 1, dot_symbol, text_color=color.white, bgcolor=color.new(color.green, 0), text_size=size.auto)\r\n        else if flag == 2\r\n            table.cell(t, i, 1, dot_symbol, text_color=color.white, bgcolor=color.new(color.red, 0), text_size=size.auto)\r\n        else\r\n            table.cell(t, i, 1, \"\", text_color=color.white, bgcolor=color.new(color.black, 90), text_size=size.small)\r\n"
  },
  "https://www.tradingview.com/script/HcY4PBUH/": {
    "id": 20084873,
    "url": "https://www.tradingview.com/script/HcY4PBUH/",
    "name": "Estrategia Visual PRO: Momentum Edition",
    "description": "Indicador con estrategia propia basado en cruce de emas editables son sombreado de tendencia del precio y niveles de soporte y resistencias donde el precio tiene reaccion, tambien cuenta con filtro de rsi donde colorea las velas segun la fuerza del rsi, colores editables y cuando el precio pierde fuerza \n\nThis indicator, with its own strategy based on editable EMA crossovers, features price trend shading and support and resistance levels where the price reacts. It also includes an RSI filter that colors the candles according to the strength of the RSI, with editable colors, and alerts you when the price loses strength.",
    "author_name": "MartinTrader1989",
    "likes_count": 40,
    "comments_count": 0,
    "views_count": 0,
    "created_at": "2025-12-11T12:46:53+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "BYBIT:SOLUSDT.P",
      "full_name": "BYBIT:SOLUSDT.P",
      "short_name": "SOLUSDT.P",
      "exchange": "BYBIT",
      "type": "swap",
      "logo_id": null,
      "currency_logo_id": "crypto/XTVCUSDT",
      "base_currency_logo_id": "crypto/XTVCSOL",
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/crypto/XTVCSOL.svg",
        "https://s3-symbol-logo.tradingview.com/crypto/XTVCUSDT.svg"
      ],
      "interval": "1",
      "direction": 0,
      "badge": {
        "label": "BYBIT:SOLUSDT.P",
        "url": "/symbols/SOLUSDT.P/"
      }
    },
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=6\r\nindicator(\"Estrategia Visual PRO: Momentum Edition\", overlay=true, max_lines_count=100)\r\n\r\n// ==============================================\r\n// --- 1. CONFIGURACI√ìN DEL SISTEMA DE CRUCE (EMAs) ---\r\n// ==============================================\r\ngrpEma = \"Sistema de Cruce (EMAs)\"\r\nlenPrincipal = input.int(10, minval=1, title=\"Longitud EMA Principal (R√°pida)\", group=grpEma)\r\nsrcPrincipal = input.source(close, title=\"Fuente EMA Principal\", group=grpEma)\r\n\r\nlenSecundaria = input.int(50, minval=1, title=\"Longitud EMA Secundaria (Lenta)\", group=grpEma)\r\nsrcSecundaria = input.source(close, title=\"Fuente EMA Secundaria\", group=grpEma)\r\n\r\n// ==============================================\r\n// --- 2. CONFIGURACI√ìN DE VELAS DE MOMENTUM (NUEVO) ---\r\n// ==============================================\r\ngrpCol = \"Coloreado de Velas (Limpieza Visual)\"\r\nuseBarColor = input.bool(true, \"Colorear Velas por Fuerza?\", group=grpCol, tooltip=\"Gris = Rango/Sin Fuerza. Colores Vivos = Tendencia Fuerte.\")\r\n// Filtro adicional para definir fuerza (RSI > 50 o solo EMAs)\r\nuseRsiFilter = input.bool(false, \"Usar RSI para confirmar fuerza?\", group=grpCol)\r\n\r\n// ==============================================\r\n// --- 3. CONFIGURACI√ìN DE SMAs ADICIONALES ---\r\n// ==============================================\r\ngrpSma = \"SMAs de Referencia (Adicionales)\"\r\nshowSMA1 = input.bool(true, \"Mostrar SMA 1\", group=grpSma, inline=\"sma1\")\r\nlenSMA1 = input.int(50, \"Longitud\", group=grpSma, inline=\"sma1\")\r\ncolSMA1 = input.color(color.purple, \"\", group=grpSma, inline=\"sma1\")\r\n\r\nshowSMA2 = input.bool(true, \"Mostrar SMA 2\", group=grpSma, inline=\"sma2\")\r\nlenSMA2 = input.int(100, \"Longitud\", group=grpSma, inline=\"sma2\")\r\ncolSMA2 = input.color(color.yellow, \"\", group=grpSma, inline=\"sma2\")\r\n\r\nshowSMA3 = input.bool(true, \"Mostrar SMA 3\", group=grpSma, inline=\"sma3\")\r\nlenSMA3 = input.int(200, \"Longitud\", group=grpSma, inline=\"sma3\")\r\ncolSMA3 = input.color(color.white, \"\", group=grpSma, inline=\"sma3\")\r\n\r\n// ==============================================\r\n// --- 4. DETECTOR DE VOLUMEN (VSA) ---\r\n// ==============================================\r\ngrpVol = \"Detector de Volumen en Mechas\"\r\nvolLength = input.int(20, \"Promedio de Volumen (SMA)\", group=grpVol)\r\nfactorMecha = input.float(2.0, \"Factor de Tama√±o de Mecha\", minval=1.0, step=0.1, group=grpVol)\r\n\r\n// ==============================================\r\n// --- 5. SOPORTES Y RESISTENCIAS ---\r\n// ==============================================\r\ngrpSR = \"Soportes y Resistencias Din√°micos\"\r\nshowSR = input.bool(true, \"Mostrar Niveles S/R\", group=grpSR)\r\nsrLen = input.int(20, \"Importancia del Nivel\", minval=5, group=grpSR)\r\nmaxLines = input.int(6, \"M√°ximo de L√≠neas\", minval=1, maxval=20, group=grpSR)\r\n\r\n// ==============================================\r\n// --- C√ÅLCULOS T√âCNICOS ---\r\n// ==============================================\r\n// EMAs\r\nemaPrincipal = ta.ema(srcPrincipal, lenPrincipal)\r\nemaSecundaria = ta.ema(srcSecundaria, lenSecundaria)\r\n\r\n// SMAs\r\nsmaVal1 = ta.sma(close, lenSMA1)\r\nsmaVal2 = ta.sma(close, lenSMA2)\r\nsmaVal3 = ta.sma(close, lenSMA3)\r\n\r\n// RSI (para filtro de color opcional)\r\nrsiVal = ta.rsi(close, 14)\r\n\r\n// ==============================================\r\n// --- L√ìGICA DE MOMENTUM (COLOREADO) ---\r\n// ==============================================\r\n// Definimos condiciones de fuerza\r\nbullTrend = close > emaPrincipal and close > emaSecundaria and (useRsiFilter ? rsiVal > 50 : true)\r\nbearTrend = close < emaPrincipal and close < emaSecundaria and (useRsiFilter ? rsiVal < 50 : true)\r\n\r\n// Asignamos color a la barra\r\nvar color barColor = na\r\nif bullTrend\r\n    barColor := color.lime // Tendencia Alcista Fuerte\r\nelse if bearTrend\r\n    barColor := color.red  // Tendencia Bajista Fuerte\r\nelse\r\n    barColor := color.gray // Zona Muerta / Rango (¬°NO OPERAR!)\r\n\r\n// Aplicar color\r\nbarcolor(useBarColor ? barColor : na)\r\n\r\n// ==============================================\r\n// --- C√ÅLCULOS DE VOLUMEN (VSA) ---\r\n// ==============================================\r\ncuerpo = math.abs(close - open)\r\nmechaSup = high - math.max(open, close)\r\nmechaInf = math.min(open, close) - low\r\nvolMedio = ta.sma(volume, volLength)\r\nvolAlto = volume > volMedio \r\npresionVenta = volAlto and (mechaSup > (cuerpo * factorMecha)) and (mechaSup > mechaInf)\r\npresionCompra = volAlto and (mechaInf > (cuerpo * factorMecha)) and (mechaInf > mechaSup)\r\n\r\n// ==============================================\r\n// --- MOTOR DE SOPORTES Y RESISTENCIAS ---\r\n// ==============================================\r\nph = ta.pivothigh(high, srLen, srLen)\r\npl = ta.pivotlow(low, srLen, srLen)\r\nvar line[] resLines = array.new_line()\r\nvar line[] supLines = array.new_line()\r\n\r\nif showSR\r\n    if not na(ph)\r\n        l = line.new(bar_index[srLen], ph, bar_index, ph, color=color.new(color.red, 30), width=1)\r\n        line.set_extend(l, extend.right)\r\n        array.push(resLines, l)\r\n        if array.size(resLines) > maxLines\r\n            line.delete(array.shift(resLines))\r\n    if not na(pl)\r\n        l = line.new(bar_index[srLen], pl, bar_index, pl, color=color.new(color.green, 30), width=1)\r\n        line.set_extend(l, extend.right)\r\n        array.push(supLines, l)\r\n        if array.size(supLines) > maxLines\r\n            line.delete(array.shift(supLines))\r\n\r\n// ==============================================\r\n// --- VISUALIZACI√ìN ---\r\n// ==============================================\r\np1 = plot(emaPrincipal, color=color.new(color.blue, 0), linewidth=2, title=\"EMA Principal\")\r\np2 = plot(emaSecundaria, color=color.new(color.orange, 0), linewidth=2, title=\"EMA Secundaria\")\r\nfill(p1, p2, color=emaPrincipal > emaSecundaria ? color.new(color.green, 90) : color.new(color.red, 90))\r\n\r\nplot(showSMA1 ? smaVal1 : na, color=colSMA1, linewidth=1, title=\"SMA 1\")\r\nplot(showSMA2 ? smaVal2 : na, color=colSMA2, linewidth=2, title=\"SMA 2\")\r\nplot(showSMA3 ? smaVal3 : na, color=colSMA3, linewidth=2, title=\"SMA 3\")\r\n\r\nplotshape(presionVenta, style=shape.cross, location=location.abovebar, color=color.red, size=size.small, title=\"VSA Venta\")\r\nplotshape(presionCompra, style=shape.cross, location=location.belowbar, color=color.lime, size=size.small, title=\"VSA Compra\")\r\n\r\ncruceArriba = ta.crossover(emaPrincipal, emaSecundaria)\r\ncruceAbajo = ta.crossunder(emaPrincipal, emaSecundaria)\r\nplotshape(cruceArriba, style=shape.labelup, location=location.belowbar, color=color.green, text=\"BUY\", textcolor=color.white, size=size.small)\r\nplotshape(cruceAbajo, style=shape.labeldown, location=location.abovebar, color=color.red, text=\"SELL\", textcolor=color.white, size=size.small)"
  },
  "https://www.tradingview.com/script/LdAGhrMA-Contra-Trading-Setup-Buy-on-Close/": {
    "id": 20088198,
    "url": "https://www.tradingview.com/script/LdAGhrMA-Contra-Trading-Setup-Buy-on-Close/",
    "name": "Contra Trading Setup - Buy on Close",
    "description": "Contra Trding Setp\n\n1. Closing Price is less than 20SMA\n2. Today low is less than last 5 days low\n3.Today close is above yesterday close\n4. If all 3 conditions met\nThen tomorrow close should be >Today Close\nBuy On Close\nExit After 5 - 7 Trading Session.",
    "author_name": "BalkrushnaHirani",
    "likes_count": 14,
    "comments_count": 0,
    "views_count": 0,
    "created_at": "2025-12-12T03:09:25+00:00",
    "updated_at": null,
    "script_type": "indicator",
    "script_access": 1,
    "is_hot": true,
    "is_picked": false,
    "symbol": {
      "name": "NSE:BANKNIFTY",
      "full_name": "NSE:BANKNIFTY",
      "short_name": "BANKNIFTY",
      "exchange": "NSE",
      "type": "index",
      "logo_id": "sector/financial",
      "currency_logo_id": "country/IN",
      "base_currency_logo_id": null,
      "logo_urls": [
        "https://s3-symbol-logo.tradingview.com/sector/financial.svg"
      ],
      "interval": "1D",
      "direction": 0,
      "badge": {
        "label": "NSE:BANKNIFTY",
        "url": "/symbols/NSE-BANKNIFTY/"
      }
    },
    "created": "2025-12-12",
    "updated": "2025-12-12",
    "source": "// This Pine Script¬Æ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// ¬© BalkrushnaHirani\r\n//@version=5\r\nindicator(\"Contra Trading Setup - Buy on Close\", overlay=true, shorttitle=\"ContraBuy\")\r\n\r\n// === Inputs ===\r\nsma_len = input.int(20, \"SMA Length\", minval=1)\r\nlookback = input.int(5, \"Lookback for Low (prev days)\", minval=1)\r\nexit_bars = input.int(5, \"Exit after N bars (suggested)\", minval=1, maxval=30)\r\nshow_setup_label = input.bool(true, \"Show Setup Labels\")\r\nshow_buy_label = input.bool(true, \"Show Buy Labels\")\r\nshow_exit_label = input.bool(true, \"Show Exit Labels\")\r\n\r\n// === Indicators ===\r\nsma20 = ta.sma(close, sma_len)\r\n\r\n// Condition definitions (on bar T)\r\ncond_sma = close < sma20\r\n// lowest low of previous `lookback` bars (exclude current bar)\r\nprev_lowest = ta.lowest(low[1], lookback)\r\ncond_low = low < prev_lowest\r\ncond_close_up = close > close[1]\r\n\r\n// Setup occurs when all three conditions true on the same bar (call it bar T)\r\nsetup = cond_sma and cond_low and cond_close_up\r\n\r\n// We only act on the next bar (T+1). To do that: remember when setup happened\r\nvar int setup_bar_index = na\r\nif setup\r\n    setup_bar_index := bar_index\r\n// If more than one setup happens before next bar it will overwrite ‚Äî that's fine since we only care previous-bar setup\r\n\r\n// On current bar (call this bar B), check if previous bar (B-1) was a setup:\r\nis_prev_setup = (setup_bar_index == bar_index - 1)\r\n\r\n// Trigger buy on close of this bar B if previous bar was setup AND close(B) > close(B-1)\r\nbuy_trigger = is_prev_setup and (close > close[1])\r\n\r\n// Record buys and schedule exit bar index\r\nvar int last_buy_bar = na\r\nvar int last_exit_bar = na\r\nif buy_trigger\r\n    last_buy_bar := bar_index\r\n    last_exit_bar := bar_index + exit_bars\r\n\r\n// Determine if current bar is an exit bar for the last buy\r\nis_exit_now = not na(last_exit_bar) and (bar_index == last_exit_bar)\r\n\r\n// === Plotting ===\r\n// SMA\r\nplot(sma20, title=\"SMA 20\", linewidth=2)\r\n\r\n// Mark setup bar\r\nif show_setup_label and setup\r\n    label.new(bar_index, high, \"SETUP\", yloc=yloc.abovebar, style=label.style_label_up, color=color.orange, textcolor=color.white)\r\n\r\n// Mark buy (on the bar where buy_trigger is true)\r\nif show_buy_label and buy_trigger\r\n    label.new(bar_index, low, \"BUY\\n(on close)\", yloc=yloc.belowbar, style=label.style_label_down, color=color.green, textcolor=color.white)\r\n\r\n// Mark exit\r\nif show_exit_label and is_exit_now\r\n    label.new(bar_index, high, \"EXIT\\n(\" + str.tostring(exit_bars) + \" bars)\", yloc=yloc.abovebar, style=label.style_label_up, color=color.red, textcolor=color.white)\r\n\r\n// Also plot shapes for quick view\r\nplotshape(setup, title=\"Setup Marker\", location=location.abovebar, color=color.new(color.orange, 0), style=shape.triangleup, size=size.tiny, offset=0)\r\nplotshape(buy_trigger, title=\"Buy Marker\", location=location.belowbar, color=color.new(color.green, 0), style=shape.triangleup, size=size.small)\r\nplotshape(is_exit_now, title=\"Exit Marker\", location=location.abovebar, color=color.new(color.red, 0), style=shape.triangledown, size=size.small)\r\n\r\n// === Table (optional small status) ===\r\nvar table t = table.new(position.top_right, 1, 3)\r\nif barstate.islast\r\n    table.cell(t, 0, 0, \"Last setup: \" + (na(setup_bar_index) ? \"n/a\" : str.tostring(setup_bar_index)), text_color=color.white)\r\n    table.cell(t, 0, 1, \"Last buy bar: \" + (na(last_buy_bar) ? \"n/a\" : str.tostring(last_buy_bar)), text_color=color.white)\r\n    table.cell(t, 0, 2, \"Exit bars: \" + str.tostring(exit_bars), text_color=color.white)\r\n\r\n// === Alerts ===\r\n// You can create alerts from TradingView using these boolean series:\r\n// - buy_trigger  -> create alert for Buy on close\r\n// - setup        -> create alert for Setup detected\r\n// - is_exit_now  -> create alert for suggested exit\r\n// Example: create alert condition \"buy_trigger\" with message \"Contra BUY on close\"\r\n\r\n// Plot a background color for the bar where prev-setup exists (optional visual)\r\nbgcolor(is_prev_setup ? color.new(color.green, 90) : na)"
  }
}