[
  {
    "url": "8I2576zL-Mutanabby-AI-ONEUSDT-MR1",
    "name": "Mutanabby_AI | ONEUSDT_MR1 ",
    "description": "\nONEUSDT Mean-Reversion Strategy | 74.68% Win Rate | 417% Net Profit\n\n\nThis is a long-only mean-reversion strategy designed specifically for ONEUSDT on the 1-hour timeframe. The core logic identifies oversold conditions following sharp declines and enters positions when selling pressure exhausts, capturing the subsequent recovery bounce.\n\nBacktested Period: June 2019 â€“ December 2025 (~6 years)\n\n Performance Summary\n\n| Metric | Value |\n|--------|-------|\n| Net Profit | +417.68% |\n| Win Rate | 74.68% |\n| Profit Factor | 4.019 |\n| Total Trades | 237 |\n| Sharpe Ratio | 0.364 |\n| Sortino Ratio | 1.917 |\n| Max Drawdown | 51.08% |\n| Avg Win | +3.14% |\n| Avg Loss | -2.30% |\n| Buy & Hold Return | -80.44% |\n\n\nStrategy Logic :\n\n Entry Conditions (Long Only): \n\nThe strategy seeks confluence of three conditions that identify exhausted selling:\n\n1. Prior Move Filter:*The price change from 5 bars ago to 3 bars ago must be â‰¥ -7% (ensures we're not entering during freefall)\n\n2. Current Move Filter: The price change over the last 2 bars must be â‰¤ 0% (confirms momentum is stalling or reversing)\n\n3.  Three-Bar Decline: The price change from 5 bars ago to 3 bars ago must be â‰¤ -5% (confirms a significant recent drop occurred)\n\nWhen all three conditions align, the strategy identifies a potential reversal point where sellers are exhausted.\n\n Exit Conditions: \n\n- Primary Exit: Close above the previous bar's high while the open of the previous bar is at or below the close from 9 bars ago (profit-taking on strength)\n- Trailing Stop: 11x ATR trailing stop that locks in profits as price rises\n\n\n Risk Management\n \n- Position Sizing:Fixed position based on account equity divided by entry price\n- Trailing Stop:11Ã— ATR (14-period) provides wide enough room for crypto volatility while protecting gains\n- Pyramiding:Up to 4 orders allowed (can scale into winning positions)\n- **Commission:** 0.1% per trade (realistic exchange fees included)\n\n\n\n Important Disclaimers\n \n\nâš ï¸ This is NOT financial advice.\n\n- Past performance does not guarantee future results\n- Backtest results may contain look-ahead bias or curve-fitting\n- Real trading involves slippage, liquidity issues, and execution delays\n- This strategy is optimized for ONEUSDT specifically â€” results may differ on other pairs\n- Always test  before risking real capital\n\n\n Recommended Usage\n \n- Timeframe:*1H (as designed)\n- Pair: ONEUSDT (Binance)\n- Account Size: Ensure sufficient capital to survive max drawdown\n\n\n Source Code\n \n\n\n Feedback Welcome\n \n\nI'm sharing this strategy freely for educational purposes. Please:\n- Drop a comment with your backtesting results any you analysis \n- Share any modifications that improve performance\n- Let me know if you spot any issues in the logic\n\n Happy trading\n \n\n\n\nAs a quant trader, do you think this strategy will survive in live trading?\nYes or No? And why?\nI want to hear from you guys",
    "image_url": "8I2576zL",
    "author": "Mutanabby_AI",
    "likes": 36,
    "comments_count": 1,
    "script_type": "strategy",
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=5\r\nstrategy(\"ONEUSDT(1)_MR1\", overlay=true, initial_capital=100, default_qty_type=strategy.fixed, default_qty_value=100)\r\n\r\n// Input Parameters\r\nvar float TRAIL_ATR_MULT = 11.0\r\nvar int ATR_LENGTH = 14\r\nvar float ACCOUNT_SIZE = 100.0\r\n\r\n\r\n// Tracking Variables\r\nvar int profx = 0\r\nvar float trailLevel = na\r\nvar int barsInTrade = 0\r\n\r\n// Calculate Technical Indicators\r\natr = ta.atr(ATR_LENGTH)\r\n\r\n// Position Size Calculation\r\npositionSize = math.floor(ACCOUNT_SIZE / close)\r\n\r\n// Calculate Price Changes\r\npercentChange2Bars(offset) =>\r\n    ((close[offset] - close[offset+2]) / close[offset+2]) * 100\r\n\r\n// Entry Conditions\r\n\r\npriorMove = percentChange2Bars(3) >= -7\r\ncurrentMove = percentChange2Bars(0) <= 0\r\nthreeBarBack = percentChange2Bars(3) <= -5\r\n\r\nlongCondition =  priorMove and currentMove and threeBarBack\r\n\r\n// Exit Conditions\r\nexitCondition = close > high[1] and open[1] <= close[9]\r\n\r\n// Track Trade Duration and Profitable Closes\r\nif (strategy.position_size > 0)\r\n    barsInTrade := barsInTrade + 1\r\n    if (close >= strategy.position_avg_price)\r\n        profx := profx + 1\r\nelse\r\n    barsInTrade := 0\r\n\r\n// Trailing Stop Logic\r\nif (strategy.position_size > 0)\r\n    float newTrail = close - (atr * TRAIL_ATR_MULT)\r\n    trailLevel := na(trailLevel) ? newTrail : math.max(trailLevel, newTrail)\r\nelse\r\n    trailLevel := na\r\n\r\n// Execute Strategy\r\nif (longCondition)\r\n    strategy.entry(\"Long\", strategy.long, qty=positionSize)\r\n    profx := 0\r\n\r\n// Exit Conditions\r\nif (strategy.position_size > 0)\r\n    // Trailing Stop\r\n    strategy.exit(\"Trail\", \"Long\", stop=trailLevel)\r\n    \r\n    // Signal Exit\r\n    if (exitCondition)\r\n        strategy.close(\"Long\", comment=\"Signal Exit\")\r\n    \r\n\r\n\r\n// Visualization\r\nplot(strategy.position_size > 0 ? trailLevel : na, \"Trailing Stop\", color=color.red, style=plot.style_stepline)\r\nplotshape(longCondition, \"Entry\", location=location.belowbar, color=color.green, style=shape.triangleup, size=size.small)\r\nplotshape(exitCondition and strategy.position_size > 0, \"Exit\", location=location.abovebar, color=color.red, style=shape.triangledown, size=size.small)"
  },
  {
    "url": "ZWOqYiQq-ORB-Strategy-Extensions-Custom-SL-EOD-Live-Lines",
    "name": "ORB Strategy: Extensions & Custom SL (EOD & Live Lines)",
    "description": "That's a great request. Since you've now built a complex Pine Script Strategy with several user-configurable risk management, targeting, and exit options, the description should focus on the systematic rules used for entering, managing, and exiting trades.\n\nHere is a clear, written description of the trading strategy you have built:\n\nTrading Strategy Description: ORB Extension Breakout with Custom Stop, Live Tracking, and EOD Exit\nThis strategy is a systematic, momentum-based system designed for intraday trading. It operates on the principle of an Opening Range Breakout (ORB), utilizing the initial market consolidation to project high-probability targets, while offering multiple methods for managing risk and enforcing a mandatory end-of-day closure.\n\n1. Market Identification (The Opening Range)\nThe strategy first defines the market's initial boundaries and volatility:\n\nSession Window: The strategy calculates the Opening Range (OR) over a user-defined time period (default: 9:30 AM to 10:30 AM New York Time).\n\nORB Levels: Two key price levels are established and locked once the time window closes:\n\nWick High/Low: The absolute highest and lowest prices of the session. These serve as the entry trigger lines.\n\nBody High/Low (Shaded Range): The highest and lowest open/close prices of the session. The height of this range is used as the basis for calculating all targets and stops.\n\n2. Entry Rule (The Breakout)\nThe strategy waits passively for a breakout that confirms direction and ensures the move has not yet reached its immediate target.\n\nTrigger Condition: A trade is signaled when a candle closes either:\n\nAbove the Wick High (for a Long entry).\n\nBelow the Wick Low (for a Short entry).\n\nConstraint (Fresh Breakout): The entry is invalidated if the breakout candle's price action (High for Long, Low for Short) has already touched or surpassed the projected Take Profit (0.5 Extension) level before the candle closes.\n\nExecution: The entry is a Market Order executed on the candle that meets the trigger conditions, subject to a user-defined Entry Delay (default 0 bars).\n\nDirection Control: The user can select to trade Long Only, Short Only, or Both.\n\n3. Exit and Risk Management\nAll trades are placed with simultaneous Take Profit and Stop Loss orders (a bracket order) upon entry.\n\nA. Take Profit (TP)\nThe Take Profit is set at the 0.5 Extension of the Shaded Range (Body Range).\n\nCalculation: The distance from the Body High/Low to the TP level is exactly 50% of the total height of the Shaded Range.\n\nB. Stop Loss (SL)\nThe Stop Loss is dynamically calculated based on a user-selected method for risk control:\n\nRange 0.5 (Body Range): The SL is placed an equal distance (0.5 times the Body Range height) outside the opposite side of the Body Range.\n\nATR Multiple: The Stop Loss distance is calculated as a user-defined Multiplier times the Average True Range (ATR).\n\nRecent Swing Low/High: The Stop Loss is placed based on a structural low (for Long) or high (for Short) within a user-defined lookback period.\n\nC. End-of-Day (EOD) Exit\nAny open position is forced closed at the market price if it is still open when the user-defined closing time (default: 16:00 HHMM) is reached. This prevents carrying intraday risk overnight.\n\n4. Visualization\nThe strategy includes comprehensive visual cues for analysis:\n\nORB Drawing: Displays the Wick High/Low and the shaded Body Range.\n\nBreakout Signals: Highlights the specific bar where the validated entry signal occurs.\n\nClosed Trades: Draws persistent lines for the Entry and Exit prices of the last few closed trades.\n\nLive Open Trades: Draws persistent lines for the current Entry Price, active Take Profit Level, and active Stop Loss Level for any open position.",
    "image_url": "ZWOqYiQq",
    "author": "ChadAnt",
    "likes": 21,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=5\nstrategy(\"ORB Strategy: Extensions & Custom SL (EOD & Live Lines)\", overlay=true, shorttitle=\"ORB Str\")\n\n// ==========================================\n// 1. USER INPUTS\n// ==========================================\n\n// --- STRATEGY SETTINGS ---\ngrp_strategy = \"Strategy Execution\"\nentryDelay = input.int(0, \"Entry Delay (Bars after Break)\", minval=0, maxval=5, group=grp_strategy)\ntradeDirection = input.string(\"Both\", \"Trade Direction\", options=[\"Long Only\", \"Short Only\", \"Both\"], group=grp_strategy)\n\n// --- END-OF-DAY SETTINGS ---\ngrp_eod = \"End-of-Day Exit\"\ncloseTimeInput = input.int(1600, \"Forced Close Time (HHMM)\", minval=0000, maxval=2359, group=grp_eod, tooltip=\"Closes all open trades at this time in the defined timezone.\")\n\n\n// --- VISUALIZATION SETTINGS ---\ngrp_vis = \"Trade Visualization\"\nnumTradesToDisplay = input.int(3, \"Closed Trades to Display (0 to disable)\", minval=0, maxval=50, group=grp_vis)\nnumOpenTradesToDisplay = input.int(1, \"Open Trades (Live Levels) to Display\", minval=0, maxval=10, group=grp_vis)\nlineLength = input.int(15, \"Trade Line Length (Bars)\", minval=5, group=grp_vis)\n\n\n// Stop Loss Management\ngrp_sl = \"Stop Loss Settings\"\nslType = input.string(\"Range 0.5 (Body Range)\", \"Stop Loss Type\", \n     options=[\"Range 0.5 (Body Range)\", \"ATR Multiple\", \"Recent Swing Low/High\"], \n     group=grp_sl) \natrLength = input.int(14, \"ATR Lookback\", minval=1, group=grp_sl)\natrMultiplier = input.float(2.0, \"ATR Multiplier\", minval=0.1, group=grp_sl)\nswingLookback = input.int(10, \"Swing Lookback Bars\", minval=5, group=grp_sl)\n\n\n// --- ORB Time Settings ---\ngrp_time = \"ORB Time Settings\"\nsessionInput = input.session(\"0930-1030\", \"Opening Range Session (NY Time)\", group=grp_time)\nendTimeInput = input.int(1600, \"ORB Lines Stop Time (HHMM)\", group=grp_time)\ntimezone     = \"America/New_York\" \n\n// --- ORB Extension Settings ---\ngrp_ext = \"ORB Extensions (Body Range Based)\"\ntpStep = 0.5 // Fixed Take Profit at 0.5 extension as per request\nstdDevSteps  = input.float(0.5, \"Step Size (e.g. 0.5 = 50% of range)\", step=0.1, group=grp_ext, tooltip=\"This input controls the SL/TP step size.\")\nstdDevQty    = input.int(3, \"Number of Extension Lines\", minval=1, maxval=10, group=grp_ext) \nextLineStyle = input.string(\"Dotted\", \"Extension Line Style\", options=[\"Solid\", \"Dotted\", \"Dashed\"], group=grp_ext)\n\n// --- ORB Visuals (kept for compatibility and analysis) ---\ngrp_style = \"ORB Visuals (Non-Trading)\"\nwickColor = input.color(color.new(color.gray, 0), \"Wick Line Color\", group=grp_style)\nbodyColor = input.color(color.new(color.blue, 0), \"Body Line Color\", group=grp_style)\nfillColor = input.color(color.new(color.blue, 90), \"Body Range Fill Color\", group=grp_style)\nlineWidth = input.int(2, \"Line Width\", minval=1, group=grp_style)\n\n// ==========================================\n// 2. ORB LOGIC\n// ==========================================\n\n// Detect New Day & Time Checks\nisNewDay = ta.change(time(\"D\"))\nnyHour = hour(time, timezone)\nnyMinute = minute(time, timezone)\ncurrNyTime = nyHour * 100 + nyMinute\npastCutoff = currNyTime >= endTimeInput\ninFormingSession = not na(time(timeframe.period, sessionInput + \":1234567\", timezone))\n\n// State Variables\nvar float rHigh = na\nvar float rLow = na\nvar float rBodyHigh = na\nvar float rBodyLow = na\nvar bool bullBreakHappened = false\nvar bool bearBreakHappened = false\nvar float breakOutPrice = na \n// Variables to store TP/SL for live visualization (if strategy.position_size is not zero)\nvar float longStopLossLevel = na\nvar float longTakeProfitLevel = na\nvar float shortStopLossLevel = na\nvar float shortTakeProfitLevel = na\n\n\n// Reset on New Day\nif isNewDay\n    rHigh := na\n    rLow := na\n    rBodyHigh := na\n    rBodyLow := na\n    bullBreakHappened := false\n    bearBreakHappened := false\n    breakOutPrice := na\n\n// Update Logic during session\nif inFormingSession and not inFormingSession[1]\n    rHigh := high\n    rLow := low\n    rBodyHigh := math.max(open, close)\n    rBodyLow := math.min(open, close)\n    bullBreakHappened := false \n    bearBreakHappened := false\nelse if inFormingSession\n    rHigh := math.max(rHigh, high)\n    rLow := math.min(rLow, low)\n    rBodyHigh := math.max(rBodyHigh, math.max(open, close))\n    rBodyLow := math.min(rBodyLow, math.min(open, close))\n\n// ORB Boundary Check\nsessionEnded = not inFormingSession and not na(rHigh)\n\n// Global calculation for range height and TP/SL levels\nbodyRangeHeight = rBodyHigh - rBodyLow \ntpLongLevel = rBodyHigh + (bodyRangeHeight * tpStep)\ntpShortLevel = rBodyLow - (bodyRangeHeight * tpStep)\n\n// New Constraint: Check if the candle high/low hits the TP level before close.\npreTargetHitBullish = high >= tpLongLevel \npreTargetHitBearish = low <= tpShortLevel\n\n// Check for close outside the wick (trigger condition) AND apply the constraint\nbullBreakCondition = sessionEnded and not bullBreakHappened and close > rHigh and not preTargetHitBullish\nbearBreakCondition = sessionEnded and not bearBreakHappened and close < rLow and not preTargetHitBearish\n\n// Update Breakout Status and save price for delayed entry\nif bullBreakCondition\n    bullBreakHappened := true\n    breakOutPrice := close\nif bearBreakCondition\n    bearBreakHappened := true\n    breakOutPrice := close\n\n// ==========================================\n// 3. TARGET & STOP LOSS CALCULATION\n// ==========================================\n\nvar float entryPrice = na\nvar float takeProfit = na\nvar float stopLoss = na\n\n// --- ATR Calculation for SL Option ---\natrValue = ta.atr(atrLength)\n\n// --- Swing High/Low Calculation for SL Option ---\nswingLowPrice = ta.lowest(low, swingLookback)\nswingHighPrice = ta.highest(high, swingLookback)\n\n\n// Function to calculate SL based on user choice\ncalcStopLoss(isLong, currentEntryPrice, rangeHeight, currentATR) =>\n    sl = float(na)\n    if slType == \"Range 0.5 (Body Range)\"\n        sl := isLong ? rBodyLow - (rangeHeight * stdDevSteps) : rBodyHigh + (rangeHeight * stdDevSteps)\n    else if slType == \"ATR Multiple\"\n        sl := isLong ? currentEntryPrice - (currentATR * atrMultiplier) : currentEntryPrice + (currentATR * atrMultiplier)\n    else if slType == \"Recent Swing Low/High\"\n        sl := isLong ? swingLowPrice : swingHighPrice\n    sl\n\n// Function to calculate TP (always 0.5 extension of shaded range)\ncalcTakeProfit(isLong, rangeHeight) =>\n    tp = float(na)\n    tp := isLong ? tpLongLevel : tpShortLevel\n    tp\n\n// ==========================================\n// 4. STRATEGY ENTRY & EXIT LOGIC\n// ==========================================\n\n// Entry Logic: Use `ta.barssince()` to count bars since the breakout condition was met\nbarsSinceBullBreak = ta.barssince(bullBreakCondition)\nbarsSinceBearBreak = ta.barssince(bearBreakCondition)\n\n// --- LONG TRADE ENTRY ---\nif barsSinceBullBreak == entryDelay and (tradeDirection == \"Long Only\" or tradeDirection == \"Both\") and strategy.position_size == 0\n    entryPrice := breakOutPrice[entryDelay]\n    takeProfit := calcTakeProfit(true, bodyRangeHeight)\n    stopLoss := calcStopLoss(true, entryPrice, bodyRangeHeight, atrValue)\n    \n    strategy.entry(\"Long ORB\", strategy.long, comment=\"L-ORB\") \n    \n    strategy.exit(\"TP/SL Long\", \"Long ORB\", limit=takeProfit, stop=stopLoss)\n    breakOutPrice := na // Clear breakout price so it doesn't trigger again\n    \n    // Store levels for live visualization\n    longTakeProfitLevel := takeProfit\n    longStopLossLevel := stopLoss\n\n\n// --- SHORT TRADE ENTRY ---\nif barsSinceBearBreak == entryDelay and (tradeDirection == \"Short Only\" or tradeDirection == \"Both\") and strategy.position_size == 0\n    entryPrice := breakOutPrice[entryDelay]\n    takeProfit := calcTakeProfit(false, bodyRangeHeight)\n    stopLoss := calcStopLoss(false, entryPrice, bodyRangeHeight, atrValue)\n    \n    strategy.entry(\"Short ORB\", strategy.short, comment=\"S-ORB\") \n    \n    strategy.exit(\"TP/SL Short\", \"Short ORB\", limit=takeProfit, stop=stopLoss)\n    breakOutPrice := na // Clear breakout price so it doesn't trigger again\n    \n    // Store levels for live visualization\n    shortTakeProfitLevel := takeProfit\n    shortStopLossLevel := stopLoss\n\n// --- END-OF-DAY CLOSURE LOGIC ---\n// Check if current time has passed the forced close time\ncloseTimeReached = currNyTime >= closeTimeInput\n\nif closeTimeReached and strategy.position_size != 0\n    // Close the entire position at market price\n    strategy.close_all(comment=\"EOD Close\")\n\n\n// ==========================================\n// 5. ORB VISUALS (Existing)\n// ==========================================\n\n// Plotting the ORB Levels\ncanDraw = not na(rHigh) and not pastCutoff\nplot(canDraw ? rHigh : na, color=wickColor, linewidth=1, title=\"Wick High\", style=plot.style_linebr)\nplot(canDraw ? rLow : na, color=wickColor, linewidth=1, title=\"Wick Low\", style=plot.style_linebr)\np_bh = plot(canDraw ? rBodyHigh : na, color=bodyColor, linewidth=lineWidth, title=\"Body High\", style=plot.style_linebr)\np_bl = plot(canDraw ? rBodyLow : na, color=bodyColor, linewidth=lineWidth, title=\"Body Low\", style=plot.style_linebr)\nfill(p_bh, p_bl, color = inFormingSession ? fillColor : color.new(color.white, 100))\n\n// Draw Breakout and Extension Visuals\ngetLineStyle(s) => s == \"Dotted\" ? line.style_dotted : s == \"Dashed\" ? line.style_dashed : line.style_solid\n\n// Visuals for Breakout Candle (Only draw if the conditions were met, including the TP constraint)\nplotshape(bullBreakCondition, style=shape.labelup, location=location.belowbar, color=color.green, text=\"BREAK\", textcolor=color.white, size=size.small)\nplotshape(bearBreakCondition, style=shape.labeldown, location=location.abovebar, color=color.red, text=\"BREAK\", textcolor=color.white, size=size.small)\n\n// Visuals for Extension Lines (Redrawn only on the break candle for neatness)\nif bullBreakCondition or bearBreakCondition\n    // Draw only for the successful break direction\n    if bullBreakCondition\n        line.new(bar_index, tpLongLevel, bar_index + 10, tpLongLevel, color=color.green, style=getLineStyle(extLineStyle), width=2)\n    if bearBreakCondition\n        line.new(bar_index, tpShortLevel, bar_index + 10, tpShortLevel, color=color.red, style=getLineStyle(extLineStyle), width=2)\n\n\n// ==========================================\n// 6. TRADE VISUALIZATION\n// ==========================================\n\n// --- CLOSED TRADES (Existing Logic) ---\ndrawTradeClosed(idx, entry, exit, isLong, tradeNum) => \n    exitColor = exit > entry and isLong or exit < entry and not isLong ? color.green : color.red\n    \n    // Draw lines for Entry, Exit, and Exit Line\n    line.new(idx, entry, idx + lineLength, entry, color=color.new(color.yellow, 0), width=2, style=line.style_solid)\n    line.new(idx, exit, idx + lineLength, exit, color=color.new(exitColor, 0), width=2, style=line.style_dotted)\n    line.new(idx, exit, idx + lineLength, exit, color=color.new(exitColor, 40), width=1, style=line.style_dashed)\n\n    label.new(idx + lineLength, entry, text=\"C-Entry #\" + str.tostring(tradeNum), style=label.style_label_right, color=color.yellow, textcolor=color.black, size=size.small)\n\nif strategy.closedtrades > 0 and numTradesToDisplay > 0\n    maxTrades = math.min(strategy.closedtrades, numTradesToDisplay)\n    for i = 1 to maxTrades\n        tradeIndex = strategy.closedtrades - i \n        entryPriceTrade = strategy.closedtrades.entry_price(tradeIndex)\n        exitPriceTrade = strategy.closedtrades.exit_price(tradeIndex)\n        entryBarIndex = strategy.closedtrades.entry_bar_index(tradeIndex)\n        entryComment = strategy.closedtrades.entry_comment(tradeIndex)\n        isLongTrade = entryComment == \"L-ORB\"\n        \n        drawTradeClosed(entryBarIndex, entryPriceTrade, exitPriceTrade, isLongTrade, i)\n\n\n// --- OPEN TRADES (NEW LIVE LOGIC) ---\n// This draws the lines persistently for the CURRENT open trade(s)\n\nif strategy.position_size != 0 and numOpenTradesToDisplay > 0\n    // Get details of the current trade\n    currentEntryPrice = strategy.position_avg_price\n    isLong = strategy.position_size > 0\n    \n    // Since only one position is active at a time in this strategy, we use \n    // the stored TP/SL variables from the entry logic.\n    tpLevel = isLong ? longTakeProfitLevel : shortTakeProfitLevel\n    slLevel = isLong ? longStopLossLevel : shortStopLossLevel\n    \n    entryBarIndex = strategy.opentrades.entry_bar_index(0) // Get bar index of the current entry\n\n    // Draw lines for Entry, TP, and SL\n    // Entry Price (Solid Yellow)\n    line.new(entryBarIndex, currentEntryPrice, bar_index + lineLength, currentEntryPrice, color=color.new(color.yellow, 0), width=2, style=line.style_solid)\n    // TP Level (Dotted Green)\n    line.new(entryBarIndex, tpLevel, bar_index + lineLength, tpLevel, color=color.new(color.green, 0), width=2, style=line.style_dotted)\n    // SL Level (Dashed Red)\n    line.new(entryBarIndex, slLevel, bar_index + lineLength, slLevel, color=color.new(color.red, 0), width=1, style=line.style_dashed)\n    \n    // Label the entry line\n    label.new(bar_index + lineLength, currentEntryPrice, text=\"Live Entry\", style=label.style_label_right, color=color.yellow, textcolor=color.black, size=size.small)"
  },
  {
    "url": "n1xKPRA2-DR-IDR-Break-5-TP",
    "name": "DR/IDR Break .5 TP",
    "description": "DR/IDR Extension Breakout with Custom Stop\nThis strategy is a systematic, counter-trend, and momentum-based system designed for intraday trading. It operates on the principle of an Opening Range Breakout (ORB), utilizing the initial market consolidation to project high-probability targets, while offering multiple methods for managing risk.\n\n1. Market Identification (The Opening Range)\nThe strategy begins by defining the market's initial boundaries and volatility:\n\nSession Window: The strategy calculates the Opening Range (OR) over a user-defined time period (default: 9:30 AM to 10:30 AM New York Time).\n\nORB Levels: Two key price levels are established and locked once the time window closes:\n\nWick High/Low: The absolute highest and lowest prices of the session. These serve as the entry trigger lines.\n\nBody High/Low (Shaded Range): The highest and lowest open/close prices of the session. The height of this range is used to calculate the Take Profit and Stop Loss levels.\n\n2. Entry Rule (The Breakout)\nThe strategy is passive until the range is violated, looking for a strong move out of the consolidation area.\n\nTrigger Condition: A trade is signaled when a candle closes either:\n\nAbove the Wick High (for a Long entry).\n\nBelow the Wick Low (for a Short entry).\n\nExecution: The entry is a Market Order executed on the candle that meets the trigger condition, subject to a user-defined Entry Delay (default 0 bars, meaning the entry is taken immediately upon the breakout candle's close).\n\nDirection Control: The user can select to trade Long Only, Short Only, or Both.\n\n3. Exit and Risk Management\nAll trades are placed with simultaneous Take Profit and Stop Loss orders (a bracket order) once the entry is filled.\n\nA. Take Profit (TP)\nThe Take Profit is set at the 0.5 Extension of the Shaded Range (Body Range).\n\nCalculation: The distance from the Body High/Low to the TP level is exactly 50% of the total height of the Shaded Range.\n\nB. Stop Loss (SL)\nThe Stop Loss is dynamically calculated based on a user-selected method for risk control:\n\nRange 0.5 (Body Range): The Stop Loss is placed an equal distance (0.5 times the Body Range height) outside the opposite side of the Body Range.\n\nExample (Long): If entry is above the Wick High, the SL is set 0.5 times the Body Range height below the Body Low.\n\nATR Multiple: The Stop Loss distance is determined by the asset's recent volatility.\n\nCalculation: The distance is calculated as a user-defined Multiplier (default 2.0) times the Average True Range (ATR).\n\nRecent Swing Low/High: The Stop Loss is placed based on a structural level defined by recent price action.\n\nLong Entry: SL is placed at the Lowest Swing Low within a user-defined lookback period.\n\nShort Entry: SL is placed at the Highest Swing High within a user-defined lookback period.\n\nSummary of Workflow\nThe market sets the Wick and Body boundaries (e.g., 9:30â€“10:30 AM).\n\nPrice breaks and closes beyond a Wick boundary, triggering a signal.\n\nThe trade enters after the specified delay.\n\nA bracket order is placed: TP is fixed at the 0.5 Extension, and SL is set based on the user's chosen risk method.\n\nThe trade is closed upon reaching either the TP or the SL level.",
    "image_url": "n1xKPRA2",
    "author": "ChadAnt",
    "likes": 12,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=5\r\nstrategy(\"DR/IDR Break .5 TP\", overlay=true, shorttitle=\"DR/IDR break .5 TP\")\r\n\r\n// ==========================================\r\n// 1. USER INPUTS\r\n// ==========================================\r\n\r\n// --- STRATEGY SETTINGS ---\r\ngrp_strategy = \"Strategy Execution\"\r\n// CHANGED: entryDelay logic modified internally for better execution.\r\nentryDelay = input.int(0, \"Entry Delay (Bars after Break)\", minval=0, maxval=5, group=grp_strategy)\r\ntradeDirection = input.string(\"Both\", \"Trade Direction\", options=[\"Long Only\", \"Short Only\", \"Both\"], group=grp_strategy)\r\n\r\n// Stop Loss Management\r\ngrp_sl = \"Stop Loss Settings\"\r\nslType = input.string(\"Range 0.5 (Body Range)\", \"Stop Loss Type\", \r\n     options=[\"Range 0.5 (Body Range)\", \"ATR Multiple\", \"Recent Swing Low/High\"], \r\n     group=grp_sl) \r\natrLength = input.int(14, \"ATR Lookback\", minval=1, group=grp_sl)\r\natrMultiplier = input.float(2.0, \"ATR Multiplier\", minval=0.1, group=grp_sl)\r\nswingLookback = input.int(10, \"Swing Lookback Bars\", minval=5, group=grp_sl)\r\n\r\n\r\n// --- ORB Time Settings ---\r\ngrp_time = \"ORB Time Settings\"\r\nsessionInput = input.session(\"0930-1030\", \"Opening Range Session (NY Time)\", group=grp_time)\r\nendTimeInput = input.int(1600, \"ORB Lines Stop Time (HHMM)\", group=grp_time)\r\ntimezone     = \"America/New_York\" \r\n\r\n// --- ORB Extension Settings ---\r\ngrp_ext = \"ORB Extensions (Body Range Based)\"\r\ntpStep = 0.5 // Fixed Take Profit at 0.5 extension as per request\r\nstdDevSteps  = input.float(0.5, \"Step Size (e.g. 0.5 = 50% of range)\", step=0.1, group=grp_ext, tooltip=\"This input controls the SL/TP step size.\")\r\nstdDevQty    = input.int(3, \"Number of Extension Lines\", minval=1, maxval=10, group=grp_ext) \r\nextLineStyle = input.string(\"Dotted\", \"Extension Line Style\", options=[\"Solid\", \"Dotted\", \"Dashed\"], group=grp_ext)\r\n\r\n// --- ORB Visuals (kept for compatibility and analysis) ---\r\ngrp_style = \"ORB Visuals (Non-Trading)\"\r\nwickColor = input.color(color.new(color.gray, 0), \"Wick Line Color\", group=grp_style)\r\nbodyColor = input.color(color.new(color.blue, 0), \"Body Line Color\", group=grp_style)\r\nfillColor = input.color(color.new(color.blue, 90), \"Body Range Fill Color\", group=grp_style)\r\nlineWidth = input.int(2, \"Line Width\", minval=1, group=grp_style)\r\n\r\n// ==========================================\r\n// 2. ORB LOGIC\r\n// ==========================================\r\n\r\n// Detect New Day & Time Checks\r\nisNewDay = ta.change(time(\"D\"))\r\ninFormingSession = not na(time(timeframe.period, sessionInput + \":1234567\", timezone))\r\nnyHour = hour(time, timezone)\r\nnyMinute = minute(time, timezone)\r\ncurrNyTime = nyHour * 100 + nyMinute\r\npastCutoff = currNyTime >= endTimeInput\r\n\r\n// State Variables\r\nvar float rHigh = na\r\nvar float rLow = na\r\nvar float rBodyHigh = na\r\nvar float rBodyLow = na\r\nvar bool bullBreakHappened = false\r\nvar bool bearBreakHappened = false\r\n// New variable to store the price when the break was first detected\r\nvar float breakOutPrice = na \r\n\r\n// Reset on New Day\r\nif isNewDay\r\n    rHigh := na\r\n    rLow := na\r\n    rBodyHigh := na\r\n    rBodyLow := na\r\n    bullBreakHappened := false\r\n    bearBreakHappened := false\r\n    breakOutPrice := na\r\n\r\n// Update Logic during session\r\nif inFormingSession and not inFormingSession[1]\r\n    rHigh := high\r\n    rLow := low\r\n    rBodyHigh := math.max(open, close)\r\n    rBodyLow := math.min(open, close)\r\n    bullBreakHappened := false \r\n    bearBreakHappened := false\r\nelse if inFormingSession\r\n    rHigh := math.max(rHigh, high)\r\n    rLow := math.min(rLow, low)\r\n    rBodyHigh := math.max(rBodyHigh, math.max(open, close))\r\n    rBodyLow := math.min(rBodyLow, math.min(open, close))\r\n\r\n// ORB Boundary Check\r\nsessionEnded = not inFormingSession and not na(rHigh)\r\n// Check for close outside the wick (trigger condition)\r\nbullBreakCondition = sessionEnded and not bullBreakHappened and close > rHigh\r\nbearBreakCondition = sessionEnded and not bearBreakHappened and close < rLow\r\n\r\n// Update Breakout Status and save price for delayed entry\r\nif bullBreakCondition\r\n    bullBreakHappened := true\r\n    breakOutPrice := close\r\nif bearBreakCondition\r\n    bearBreakHappened := true\r\n    breakOutPrice := close\r\n\r\n// ==========================================\r\n// 3. TARGET & STOP LOSS CALCULATION\r\n// ==========================================\r\n\r\nvar float entryPrice = na\r\nvar float takeProfit = na\r\nvar float stopLoss = na\r\nbodyRangeHeight = rBodyHigh - rBodyLow \r\n\r\n// --- ATR Calculation for SL Option ---\r\natrValue = ta.atr(atrLength)\r\n\r\n// --- Swing High/Low Calculation for SL Option ---\r\nswingLowPrice = ta.lowest(low, swingLookback)\r\nswingHighPrice = ta.highest(high, swingLookback)\r\n\r\n\r\n// Function to calculate SL based on user choice\r\ncalcStopLoss(isLong, currentEntryPrice, rangeHeight, currentATR) =>\r\n    sl = float(na)\r\n    if slType == \"Range 0.5 (Body Range)\"\r\n        sl := isLong ? rBodyLow - (rangeHeight * stdDevSteps) : rBodyHigh + (rangeHeight * stdDevSteps)\r\n    else if slType == \"ATR Multiple\"\r\n        sl := isLong ? currentEntryPrice - (currentATR * atrMultiplier) : currentEntryPrice + (currentATR * atrMultiplier)\r\n    else if slType == \"Recent Swing Low/High\"\r\n        sl := isLong ? swingLowPrice : swingHighPrice\r\n    sl\r\n\r\n// Function to calculate TP (always 0.5 extension of shaded range)\r\ncalcTakeProfit(isLong, rangeHeight) =>\r\n    tp = float(na)\r\n    tp := isLong ? rBodyHigh + (rangeHeight * tpStep) : rBodyLow - (rangeHeight * tpStep)\r\n    tp\r\n\r\n// ==========================================\r\n// 4. STRATEGY ENTRY & EXIT LOGIC (MODIFIED)\r\n// ==========================================\r\n\r\n// Entry Logic: Use `ta.barssince()` to count bars since the breakout condition was met\r\nbarsSinceBullBreak = ta.barssince(bullBreakCondition)\r\nbarsSinceBearBreak = ta.barssince(bearBreakCondition)\r\n\r\n// --- LONG TRADE ENTRY ---\r\nif barsSinceBullBreak == entryDelay and (tradeDirection == \"Long Only\" or tradeDirection == \"Both\") and strategy.position_size == 0\r\n    entryPrice := breakOutPrice[entryDelay] // Use the close of the breakout candle for entry price\r\n    takeProfit := calcTakeProfit(true, bodyRangeHeight)\r\n    stopLoss := calcStopLoss(true, entryPrice, bodyRangeHeight, atrValue)\r\n    \r\n    strategy.entry(\"Long ORB\", strategy.long, comment=\"L-ORB\", stop=close) // Set entry with a market order\r\n    \r\n    // Define Exit Orders based on calculated prices\r\n    strategy.exit(\"TP/SL Long\", \"Long ORB\", limit=takeProfit, stop=stopLoss)\r\n    // Clear breakout price so it doesn't trigger again\r\n    breakOutPrice := na\r\n\r\n\r\n// --- SHORT TRADE ENTRY ---\r\nif barsSinceBearBreak == entryDelay and (tradeDirection == \"Short Only\" or tradeDirection == \"Both\") and strategy.position_size == 0\r\n    entryPrice := breakOutPrice[entryDelay] // Use the close of the breakout candle for entry price\r\n    takeProfit := calcTakeProfit(false, bodyRangeHeight)\r\n    stopLoss := calcStopLoss(false, entryPrice, bodyRangeHeight, atrValue)\r\n    \r\n    strategy.entry(\"Short ORB\", strategy.short, comment=\"S-ORB\", stop=close) // Set entry with a market order\r\n    \r\n    // Define Exit Orders based on calculated prices\r\n    strategy.exit(\"TP/SL Short\", \"Short ORB\", limit=takeProfit, stop=stopLoss)\r\n    // Clear breakout price so it doesn't trigger again\r\n    breakOutPrice := na\r\n\r\n\r\n// ==========================================\r\n// 5. VISUALS\r\n// ==========================================\r\n\r\n// Plotting the ORB Levels\r\ncanDraw = not na(rHigh) and not pastCutoff\r\nplot(canDraw ? rHigh : na, color=wickColor, linewidth=1, title=\"Wick High\", style=plot.style_linebr)\r\nplot(canDraw ? rLow : na, color=wickColor, linewidth=1, title=\"Wick Low\", style=plot.style_linebr)\r\np_bh = plot(canDraw ? rBodyHigh : na, color=bodyColor, linewidth=lineWidth, title=\"Body High\", style=plot.style_linebr)\r\np_bl = plot(canDraw ? rBodyLow : na, color=bodyColor, linewidth=lineWidth, title=\"Body Low\", style=plot.style_linebr)\r\nfill(p_bh, p_bl, color = inFormingSession ? fillColor : color.new(color.white, 100))\r\n\r\n// Draw Breakout and Extension Visuals\r\ngetLineStyle(s) => s == \"Dotted\" ? line.style_dotted : s == \"Dashed\" ? line.style_dashed : line.style_solid\r\n\r\n// Visuals for Breakout Candle\r\nplotshape(bullBreakCondition, style=shape.labelup, location=location.belowbar, color=color.green, text=\"BREAK\", textcolor=color.white, size=size.small)\r\nplotshape(bearBreakCondition, style=shape.labeldown, location=location.abovebar, color=color.red, text=\"BREAK\", textcolor=color.white, size=size.small)\r\n\r\n// Visuals for Extension Lines (Redrawn only on the break candle for neatness)\r\nif bullBreakCondition or bearBreakCondition\r\n    // Long TP (fixed at 0.5)\r\n    tpLongLevel = rBodyHigh + (bodyRangeHeight * tpStep)\r\n    // Short TP (fixed at 0.5)\r\n    tpShortLevel = rBodyLow - (bodyRangeHeight * tpStep)\r\n    \r\n    // Draw only for the successful break direction\r\n    if bullBreakCondition\r\n        line.new(bar_index, tpLongLevel, bar_index + 10, tpLongLevel, color=color.green, style=getLineStyle(extLineStyle), width=2)\r\n    if bearBreakCondition\r\n        line.new(bar_index, tpShortLevel, bar_index + 10, tpShortLevel, color=color.red, style=getLineStyle(extLineStyle), width=2)"
  },
  {
    "url": "ZkZBYPrK",
    "name": "Trend Following $ZEC - Multi-Timeframe Structure Filter + Revers",
    "description": "# Trend Following  CRYPTOCAP:ZEC  - Strategy Guide\n\n## ðŸ“Š Strategy Overview\n\nTrend Following  CRYPTOCAP:ZEC  is an enhanced Turtle Trading system designed for cryptocurrency spot trading, combining Donchian Channel breakouts, multi-timeframe structure filtering, and ATR-based dynamic risk management for both long and short positions.\n\n---\n\n## ðŸŽ¯ Core Features\n\n1. Multi-Timeframe Structure Filtering\n   - Uses Swing High/Low to identify market structure\n   - Customizable structure timeframe (default: 1 minute)\n   - Only enters trades in the direction of the trend, avoiding counter-trend positions\n\n2. Reverse Signal Exit\n   - No fixed stop-loss or fixed-period exits\n   - Exits only when a reverse entry signal triggers\n   - Maximizes trend profits, reduces premature exits\n\n3. ATR Dynamic Pyramiding\n   - Adds positions when price moves 0.5 ATR in favorable direction\n   - Supports up to 2 units maximum (adjustable)\n   - Pyramid scaling to enhance profitability\n\n4. Complete Risk Management\n   - Fixed position size (5000 USD per unit)\n   - Commission fee 0.06% (Binance spot rate)\n   - Initial capital 10,000 USD\n\n---\n\n## ðŸ“ˆ Trading Logic\n\nEntry Conditions\n\nâœ… Long Entry: \n- Close price breaks above 20-period high\n- Structure trend is bullish (price breaks above Swing High)\n\nâœ… Short Entry: \n- Close price breaks below 20-period low\n- Structure trend is bearish (price breaks below Swing Low)\n\nAdd Position Conditions\n- Long: Price rises â‰¥ 0.5 ATR\n- Short: Price falls â‰¥ 0.5 ATR\n- Maximum 2 units including initial entry\n\nExit Conditions\n- Long Exit: When short entry signal triggers (price breaks 20-period low + structure turns bearish)\n- Short Exit: When long entry signal triggers (price breaks 20-period high + structure turns bullish)\n\n---\n\n## âš™ï¸ Parameter Settings\n\nChannel Settings\n- Entry Channel Period: 20 (Donchian Channel breakout period)\n- Exit Channel Period: 10 (reserved parameter, actually uses reverse signal exit)\n\nATR Settings\n- ATR Period: 20\n- Stop Loss ATR Multiplier: 2.0 (reserved parameter)\n- Add Position ATR Multiplier: 0.5\n\nStructure Filter\n- Swing Length: 160 (Swing High/Low calculation period)\n- Structure Timeframe: 1 minute (can change to 5/15/60, etc.)\n\nPosition Management\n- Maximum Units: 2 (including initial entry)\n- Capital Per Unit: 5000 USD\n\n---\n\n## ðŸŽ¨ Visualization Features\n\nBackground Colors\n- Light Green: Bullish structure\n- Light Red: Bearish structure\n- Dark Green: Long entry\n- Dark Red: Short entry\n\nOptional Display (Default: OFF)\n- Entry/exit channel lines\n- Structure high/low lines\n- ATR stop-loss line\n- Next add position indicator\n- Entry/exit labels\n\n---\n\n## ðŸ“± Alert Message Format\n\nStrategy sends notifications on entry/exit with the following format:\n\n- Entry: `1m Long EP:428.26`\n- Add Position: `15m Add Long 2/2 EP:429.50`\n- Exit: `1m Close Long Reverse Signal`\n\nWhere:\n- `1m`/`15m` = Current chart timeframe\n- `EP` = Entry Price\n\n---\n\n## ðŸ’° Backtest Settings\n\nCapital Allocation\n- Initial Capital: 10,000 USD\n- Per Entry: 5,000 USD (split into 2 entries)\n- Leverage: 0x (spot trading)\n\nTrading Costs\n- Commission: 0.06% (Binance spot VIP0)\n- Slippage: 0\n\n---\n\n## ðŸŽ¯ Use Cases\n\nâœ… Best Scenarios\n- Trending markets\n- Moderate volatility assets\n- 1-minute to 4-hour timeframes\n\nâš ï¸ Not Suitable For\n- Highly volatile choppy markets\n- Low liquidity small-cap coins\n- Extreme market conditions (black swan events)\n\n---\n\n## ðŸ“Š Usage Recommendations\n\nTimeframe Suggestions\n\n| Timeframe | Trading Style | Suggested Parameter Adjustment |\n|-----------|--------------|-------------------------------|\n| 1-5 min | Scalping | Swing Length 100-160 |\n| 15-30 min | Short-term | Swing Length 50-100 |\n| 1-4 hour | Swing Trading | Swing Length 20-50 |\n\nOptimization Tips\n1. Adjust swing length based on backtest results\n2. Different coins may require different parameters\n3. Recommend backtesting on 1-minute chart first before live trading\n4. Enable labels to observe entry/exit points\n\n---\n\n## âš ï¸ Risk Disclaimer\n\n1. Past Performance Does Not Guarantee Future Results\n   - Backtest data is for reference only\n   - Live trading may be affected by slippage, delays, etc.\n\n2. Market Condition Changes\n   - Strategy performs better in trending markets\n   - May experience frequent stops in ranging markets\n\n3. Capital Management\n   - Do not invest more than you can afford to lose\n   - Recommend setting total capital stop-loss threshold\n\n4. Commission Impact\n   - Frequent trading accumulates commission fees\n   - Recommend using exchange discounts (BNB fee reduction, etc.)\n\n---\n\n## ðŸ”§ Troubleshooting\n\nQ: No entry signals?\nA: Check if structure filter is too strict, adjust swing length or timeframe\n\nQ: Too many labels displayed?\nA: Turn off \"Show Labels\" option in settings\n\nQ: Poor backtest performance?\nA: \n1. Check if the coin is suitable for trend-following strategies\n2. Adjust parameters (swing length, channel period)\n3. Try different timeframes\n\nQ: How to set alerts?\nA: \n1. Click \"Alert\" in top-right corner of chart\n2. Condition: Select \"Strategy - Trend Following  CRYPTOCAP:ZEC \"\n3. Choose \"Order filled\"\n4. Set notification method (Webhook/Email/App)\n\n---\n\n## ðŸ“ž Contact Information\n\nStrategy Name: Trend Following  CRYPTOCAP:ZEC \nVersion: v1.0\nPine Script Version: v6\nLast Updated: December 2025\n\n---\n\n## ðŸ“„ Copyright Notice\n\nThis strategy is for educational and research purposes only.\nAll risks of using this strategy for live trading are borne by the user.\nCommercial use without authorization is prohibited.\n\n---\n\n## ðŸŽ“ Learning Resources\n\nTo understand the strategy principles in depth, recommended reading:\n- \"The Complete TurtleTrader\" - Curtis Faith\n- \"Trend Following\" - Michael Covel\n- TradingView Pine Script Official Documentation\n\n---\n\nHappy Trading! Remember to manage your risk ðŸ“ˆ",
    "image_url": "ZkZBYPrK",
    "author": "ssun_6",
    "likes": 16,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-12",
    "updated": "2025-12-12",
    "source": "//@version=6\r\nstrategy(\"Trend $ZEC/AXL\", shorttitle=\"$ZEC/AXL 1/15m\", overlay=true, \r\n         initial_capital=10000, \r\n         default_qty_type=strategy.cash, \r\n         default_qty_value=5000, \r\n         commission_type=strategy.commission.percent, \r\n         commission_value=0.06,\r\n         slippage=0,\r\n         max_lines_count=500,\r\n         max_labels_count=500)\r\n\r\n// ========== åƒæ•¸è¨­å®š ==========\r\n// å”å¥‡å®‰é€šé“åƒæ•¸\r\nentry_period = input.int(20, \"é€²å ´é€šé“é€±æœŸ\", minval=1, group=\"é€šé“è¨­å®š\")\r\nexit_period = input.int(10, \"å‡ºå ´é€šé“é€±æœŸ\", minval=1, group=\"é€šé“è¨­å®š\")\r\n\r\n// ATR åƒæ•¸\r\natr_period = input.int(20, \"ATR é€±æœŸ\", minval=1, group=\"ATR è¨­å®š\")\r\natr_stop_mult = input.float(2.0, \"æ­¢æ ATR å€æ•¸\", minval=0.1, step=0.1, group=\"ATR è¨­å®š\")\r\natr_add_mult = input.float(0.5, \"åŠ å€‰ ATR å€æ•¸\", minval=0.1, step=0.1, group=\"ATR è¨­å®š\")\r\n\r\n// å¤šç©ºçµæ§‹åƒæ•¸ - åŠ å…¥å¤šæ™‚é–“æ¡†æž¶\r\nswing_length = input.int(160, \"çµæ§‹æ“ºå‹•é•·åº¦\", minval=1, group=\"ðŸ“Š å¤šç©ºçµæ§‹éŽæ¿¾\")\r\nstructure_timeframe = input.timeframe(\"1\", \"çµæ§‹æ™‚é–“æ¡†æž¶\", group=\"ðŸ“Š å¤šç©ºçµæ§‹éŽæ¿¾\", tooltip=\"é¸æ“‡çµæ§‹åˆ¤æ–·çš„æ™‚é–“é€±æœŸ,ç©ºç™½=ç•¶å‰åœ–è¡¨,D=æ—¥ç·š,W=é€±ç·š\")\r\nshow_structure_lines = input.bool(false, \"é¡¯ç¤ºçµæ§‹ç·š\", group=\"ðŸ“Š å¤šç©ºçµæ§‹éŽæ¿¾\")\r\nshow_structure_labels = input.bool(false, \"é¡¯ç¤ºçµæ§‹æ¨™ç±¤\", group=\"ðŸ“Š å¤šç©ºçµæ§‹éŽæ¿¾\")\r\n\r\n// åŠ å€‰è¨­å®š\r\nmax_units = input.int(2, \"æœ€å¤§å–®ä½æ•¸(å«é¦–æ¬¡)\", minval=1, maxval=10, group=\"å€‰ä½ç®¡ç†\")\r\nposition_size = input.int(5000, \"æ¯å–®ä½è³‡é‡‘(USD)\", minval=100, group=\"å€‰ä½ç®¡ç†\", tooltip=\"10000Uæœ¬é‡‘åˆ†2æ¬¡é€²å ´ï¼Œæ¯æ¬¡5000U\")\r\n\r\n// é¡¯ç¤ºè¨­å®š\r\nshow_channels = input.bool(false, \"é¡¯ç¤ºé€šé“\", group=\"é¡¯ç¤ºè¨­å®š\")\r\nshow_atr_lines = input.bool(false, \"é¡¯ç¤º ATR ç·š\", group=\"é¡¯ç¤ºè¨­å®š\")\r\nshow_labels = input.bool(true, \"é¡¯ç¤ºæ¨™ç±¤\", group=\"é¡¯ç¤ºè¨­å®š\")\r\nshow_table = input.bool(false, \"é¡¯ç¤ºè³‡è¨Šé¢æ¿\", group=\"é¡¯ç¤ºè¨­å®š\")\r\nlabel_distance = input.float(2.5, \"æ¨™ç±¤è·é›¢ K æ£’å€æ•¸\", minval=0.1, step=0.1, group=\"é¡¯ç¤ºè¨­å®š\", tooltip=\"æ¨™ç±¤è·é›¢Kæ£’çš„ATRå€æ•¸\")\r\nshow_label_lines = input.bool(false, \"é¡¯ç¤ºæ¨™ç±¤é€£ç·š\", group=\"é¡¯ç¤ºè¨­å®š\")\r\n\r\n// ========== è¨ˆç®—å”å¥‡å®‰é€šé“ ==========\r\nentry_upper = ta.highest(high, entry_period)\r\nentry_lower = ta.lowest(low, entry_period)\r\nexit_upper = ta.highest(high, exit_period)\r\nexit_lower = ta.lowest(low, exit_period)\r\n\r\n// ========== è¨ˆç®— ATR (Nå€¼) ==========\r\nN = ta.atr(atr_period)\r\n\r\n// ========== å¤šæ™‚é–“æ¡†æž¶å¤šç©ºçµæ§‹åˆ¤æ–· ==========\r\n// è¨ˆç®—çµæ§‹çš„å‡½æ•¸\r\nf_calculate_structure() =>\r\n    var int trend = 0\r\n    var float lastHigh = na\r\n    var float lastLow = na\r\n    \r\n    swingHigh = ta.pivothigh(high, swing_length, swing_length)\r\n    swingLow = ta.pivotlow(low, swing_length, swing_length)\r\n    \r\n    if not na(swingHigh)\r\n        lastHigh := swingHigh\r\n    \r\n    if not na(swingLow)\r\n        lastLow := swingLow\r\n    \r\n    if not na(lastHigh) and close > lastHigh and trend != 1\r\n        trend := 1\r\n    \r\n    if not na(lastLow) and close < lastLow and trend != -1\r\n        trend := -1\r\n    \r\n    [trend, lastHigh, lastLow]\r\n\r\n// ç²å–æŒ‡å®šæ™‚é–“æ¡†æž¶çš„çµæ§‹\r\n[structure_trend_mtf, last_structure_high_mtf, last_structure_low_mtf] = request.security(syminfo.tickerid, structure_timeframe, f_calculate_structure(), lookahead=barmerge.lookahead_off)\r\n\r\n// ä½¿ç”¨å¤šæ™‚é–“æ¡†æž¶çš„çµæ§‹è¶¨å‹¢\r\nstructure_trend = structure_trend_mtf\r\nlast_structure_high = last_structure_high_mtf\r\nlast_structure_low = last_structure_low_mtf\r\n\r\n// æª¢æ¸¬çµæ§‹è®ŠåŒ–ï¼ˆç”¨æ–¼ç¹ªè£½æ¨™ç±¤ï¼‰\r\nvar int prev_structure_trend = 0\r\nbool bull_break = structure_trend == 1 and prev_structure_trend != 1\r\nbool bear_break = structure_trend == -1 and prev_structure_trend != -1\r\nprev_structure_trend := structure_trend\r\n\r\n// ç¹ªè£½çµæ§‹çªç ´æ¨™ç±¤\r\nif show_structure_labels\r\n    if bull_break\r\n        label.new(bar_index, low, \"å¤šæ–¹çµæ§‹\", style=label.style_label_up, color=color.new(color.green, 0), textcolor=color.white, size=size.small)\r\n    \r\n    if bear_break\r\n        label.new(bar_index, high, \"ç©ºæ–¹çµæ§‹\", style=label.style_label_down, color=color.new(color.red, 0), textcolor=color.white, size=size.small)\r\n\r\n// ========== æŒå€‰ç‹€æ…‹è¿½è¹¤ ==========\r\nvar float entry_price = na\r\nvar float[] add_prices = array.new_float(0)\r\nvar int position = 0\r\nvar int units = 0\r\nvar float stop_loss = na\r\n\r\n// ========== é€²å ´è¨Šè™Ÿ (åŠ å…¥çµæ§‹éŽæ¿¾) ==========\r\nlong_entry_signal = close > entry_upper[1] and structure_trend == 1\r\nshort_entry_signal = close < entry_lower[1] and structure_trend == -1\r\n\r\nlong_entry = long_entry_signal and position != 1\r\nshort_entry = short_entry_signal and position != -1\r\n\r\n// ========== åŠ å€‰è¨Šè™Ÿ ==========\r\nlong_add = false\r\nshort_add = false\r\n\r\nif position == 1 and units < max_units\r\n    if array.size(add_prices) > 0\r\n        last_add_price = array.get(add_prices, array.size(add_prices) - 1)\r\n        long_add := close >= last_add_price + (atr_add_mult * N)\r\n    else\r\n        long_add := close >= entry_price + (atr_add_mult * N)\r\n\r\nif position == -1 and units < max_units\r\n    if array.size(add_prices) > 0\r\n        last_add_price = array.get(add_prices, array.size(add_prices) - 1)\r\n        short_add := close <= last_add_price - (atr_add_mult * N)\r\n    else\r\n        short_add := close <= entry_price - (atr_add_mult * N)\r\n\r\n// ========== å‡ºå ´è¨Šè™Ÿ (æ”¹ç‚ºåå‘è¨Šè™Ÿå‡ºå ´) ==========\r\n// å¤šå–®å‡ºå ´ï¼šç•¶ç©ºå–®é€²å ´è¨Šè™Ÿè§¸ç™¼æ™‚\r\nlong_exit = (position == 1) and short_entry_signal\r\n\r\n// ç©ºå–®å‡ºå ´ï¼šç•¶å¤šå–®é€²å ´è¨Šè™Ÿè§¸ç™¼æ™‚\r\nshort_exit = (position == -1) and long_entry_signal\r\n\r\n// ========== æ›´æ–°æŒå€‰ç‹€æ…‹ ==========\r\nif long_entry\r\n    position := 1\r\n    units := 1\r\n    entry_price := close\r\n    array.clear(add_prices)\r\n    array.push(add_prices, close)\r\n    stop_loss := close - (atr_stop_mult * N)\r\n    alert_msg = timeframe.period + \" åšå¤š EP:\" + str.tostring(close, \"#.##\")\r\n    strategy.entry(\"å¤šå–®1\", strategy.long, qty=position_size/close, comment=alert_msg, alert_message=alert_msg)\r\n    \r\nelse if short_entry\r\n    position := -1\r\n    units := 1\r\n    entry_price := close\r\n    array.clear(add_prices)\r\n    array.push(add_prices, close)\r\n    stop_loss := close + (atr_stop_mult * N)\r\n    alert_msg = timeframe.period + \" åšç©º EP:\" + str.tostring(close, \"#.##\")\r\n    strategy.entry(\"ç©ºå–®1\", strategy.short, qty=position_size/close, comment=alert_msg, alert_message=alert_msg)\r\n    \r\nelse if long_add\r\n    units := units + 1\r\n    array.push(add_prices, close)\r\n    stop_loss := close - (atr_stop_mult * N)\r\n    alert_msg = timeframe.period + \" åŠ å€‰å¤š \" + str.tostring(units) + \"/\" + str.tostring(max_units) + \" EP:\" + str.tostring(close, \"#.##\")\r\n    strategy.entry(\"å¤šå–®\" + str.tostring(units), strategy.long, qty=position_size/close, comment=alert_msg, alert_message=alert_msg)\r\n    \r\nelse if short_add\r\n    units := units + 1\r\n    array.push(add_prices, close)\r\n    stop_loss := close + (atr_stop_mult * N)\r\n    alert_msg = timeframe.period + \" åŠ å€‰ç©º \" + str.tostring(units) + \"/\" + str.tostring(max_units) + \" EP:\" + str.tostring(close, \"#.##\")\r\n    strategy.entry(\"ç©ºå–®\" + str.tostring(units), strategy.short, qty=position_size/close, comment=alert_msg, alert_message=alert_msg)\r\n    \r\nelse if long_exit or short_exit\r\n    if long_exit\r\n        alert_msg = timeframe.period + \" å¹³å¤š åå‘è¨Šè™Ÿ\"\r\n        strategy.close_all(comment=alert_msg, alert_message=alert_msg)\r\n    if short_exit\r\n        alert_msg = timeframe.period + \" å¹³ç©º åå‘è¨Šè™Ÿ\"\r\n        strategy.close_all(comment=alert_msg, alert_message=alert_msg)\r\n    \r\n    position := 0\r\n    units := 0\r\n    entry_price := na\r\n    array.clear(add_prices)\r\n    stop_loss := na\r\n\r\n// ========== ç¹ªè£½é€šé“ ==========\r\nplot(show_channels ? entry_upper : na, \"é€²å ´ä¸Šè»Œ\", color=color.new(color.red, 0), linewidth=2)\r\nplot(show_channels ? entry_lower : na, \"é€²å ´ä¸‹è»Œ\", color=color.new(color.green, 0), linewidth=2)\r\nplot(show_channels ? exit_upper : na, \"å‡ºå ´ä¸Šè»Œ\", color=color.new(color.orange, 50), linewidth=1, style=plot.style_circles)\r\nplot(show_channels ? exit_lower : na, \"å‡ºå ´ä¸‹è»Œ\", color=color.new(color.blue, 50), linewidth=1, style=plot.style_circles)\r\n\r\n// ç¹ªè£½çµæ§‹é«˜ä½Žé»ž\r\nplot(show_structure_lines ? last_structure_high : na, \"çµæ§‹é«˜é»ž\", color=color.new(color.red, 85), linewidth=2, style=plot.style_stepline)\r\nplot(show_structure_lines ? last_structure_low : na, \"çµæ§‹ä½Žé»ž\", color=color.new(color.green, 85), linewidth=2, style=plot.style_stepline)\r\n\r\n// ========== ç¹ªè£½ ATR ç·š ==========\r\nplot(show_atr_lines and position != 0 ? stop_loss : na, \"æ­¢æç·š\", color=color.new(color.red, 0), linewidth=2, style=plot.style_cross)\r\n\r\nvar float next_add_long = na\r\nif position == 1 and units < max_units\r\n    next_add_long := array.size(add_prices) > 0 ? array.get(add_prices, array.size(add_prices) - 1) + (atr_add_mult * N) : entry_price + (atr_add_mult * N)\r\nelse\r\n    next_add_long := na\r\n\r\nplot(show_atr_lines and position == 1 and units < max_units ? next_add_long : na, \"ä¸‹æ¬¡åŠ å€‰(å¤š)\", color=color.new(color.yellow, 30), linewidth=1, style=plot.style_stepline)\r\n\r\nvar float next_add_short = na\r\nif position == -1 and units < max_units\r\n    next_add_short := array.size(add_prices) > 0 ? array.get(add_prices, array.size(add_prices) - 1) - (atr_add_mult * N) : entry_price - (atr_add_mult * N)\r\nelse\r\n    next_add_short := na\r\n\r\nplot(show_atr_lines and position == -1 and units < max_units ? next_add_short : na, \"ä¸‹æ¬¡åŠ å€‰(ç©º)\", color=color.new(color.yellow, 30), linewidth=1, style=plot.style_stepline)\r\n\r\n// ========== ç¹ªè£½è¨Šè™Ÿæ¨™ç±¤ ==========\r\nif show_labels\r\n    label_offset = N * label_distance\r\n    long_label_style = show_label_lines ? label.style_label_up : label.style_none\r\n    short_label_style = show_label_lines ? label.style_label_down : label.style_none\r\n    \r\n    if long_entry\r\n        label.new(bar_index, low - label_offset, \"åšå¤šZEC\\nå–®ä½1/\" + str.tostring(max_units), color=color.new(color.green, 0), style=long_label_style, textcolor=color.white, size=size.normal, textalign=text.align_center)\r\n    \r\n    if short_entry\r\n        label.new(bar_index, high + label_offset, \"åšç©ºZEC\\nå–®ä½1/\" + str.tostring(max_units), color=color.new(color.red, 0), style=short_label_style, textcolor=color.white, size=size.normal, textalign=text.align_center)\r\n    \r\n    if long_add\r\n        label.new(bar_index, low - label_offset, \"åŠ å€‰å¤šå–®ZEC\\nå–®ä½\" + str.tostring(units) + \"/\" + str.tostring(max_units), color=color.new(color.lime, 0), style=long_label_style, textcolor=color.black, size=size.small, textalign=text.align_center)\r\n    \r\n    if short_add\r\n        label.new(bar_index, high + label_offset, \"åŠ å€‰ç©ºå–®ZEC\\nå–®ä½\" + str.tostring(units) + \"/\" + str.tostring(max_units), color=color.new(color.maroon, 0), style=short_label_style, textcolor=color.white, size=size.small, textalign=text.align_center)\r\n    \r\n    if long_exit\r\n        label.new(bar_index, low - label_offset, \"å¹³å¤šZEC\\nåå‘è¨Šè™Ÿ\", color=color.new(color.orange, 0), style=long_label_style, textcolor=color.white, size=size.normal, textalign=text.align_center)\r\n    \r\n    if short_exit\r\n        label.new(bar_index, high + label_offset, \"å¹³ç©ºZEC\\nåå‘è¨Šè™Ÿ\", color=color.new(color.blue, 0), style=short_label_style, textcolor=color.white, size=size.normal, textalign=text.align_center)\r\n\r\n// ========== èƒŒæ™¯é¡è‰² ==========\r\nbgcolor(structure_trend == 1 ? color.new(color.green, 70) : structure_trend == -1 ? color.new(color.red, 70) : na, title=\"çµæ§‹è¶¨å‹¢\")\r\nbgcolor(long_entry ? color.new(color.green, 85) : na, title=\"å¤šå–®é€²å ´\")\r\nbgcolor(short_entry ? color.new(color.red, 85) : na, title=\"ç©ºå–®é€²å ´\")\r\nbgcolor(long_add ? color.new(color.lime, 90) : na, title=\"å¤šå–®åŠ å€‰\")\r\nbgcolor(short_add ? color.new(color.maroon, 90) : na, title=\"ç©ºå–®åŠ å€‰\")"
  },
  {
    "url": "YVaGAcV3",
    "name": "Trend Following $BTC - Multi-Timeframe Structure + Revers",
    "description": "TREND FOLLOWING STRATEGY - MULTI-TIMEFRAME STRUCTURE BREAKOUT SYSTEM\n\nStrategy Overview\n\nThis is an enhanced Turtle Trading system designed for cryptocurrency spot trading. It combines Donchian Channel breakouts with multi-timeframe structure filtering and ATR-based dynamic risk management. The strategy trades both long and short positions using reverse signal exits to maximize trend capture.\n\nCore Features\n\nMulti-Timeframe Structure Filtering\nThe strategy uses Swing High/Low analysis to identify market structure trends. You can customize the structure timeframe (default: 3 minutes) to match your trading style. Only enters trades aligned with the identified trend direction, avoiding counter-trend positions that often lead to losses.\n\nReverse Signal Exit System\nInstead of using fixed stop-losses or time-based exits, this strategy exits positions only when a reverse entry signal triggers. This approach maximizes trend profits and reduces premature exits during normal market retracements.\n\nATR Dynamic Pyramiding\nAutomatically adds positions when price moves 0.5 ATR in your favor. Supports up to 2 units maximum (adjustable). This pyramid scaling enhances profitability during strong trends while maintaining disciplined risk management.\n\nComplete Risk Management\nFixed position sizing at 5000 USD per unit. Includes realistic commission fees of 0.06% (Binance spot rate). Initial capital set at 10,000 USD. All backtest parameters reflect real-world trading conditions.\n\nTrading Logic\n\nEntry Conditions\nLong Entry: Close price breaks above the 20-period high AND structure trend is bullish (price breaks above Swing High)\nShort Entry: Close price breaks below the 20-period low AND structure trend is bearish (price breaks below Swing Low)\n\nPosition Scaling\nLong positions: Add when price rises 0.5 ATR or more\nShort positions: Add when price falls 0.5 ATR or more\nMaximum 2 units including initial entry\n\nExit Conditions\nLong Exit: Triggers when short entry signal appears (price breaks 20-period low + structure turns bearish)\nShort Exit: Triggers when long entry signal appears (price breaks 20-period high + structure turns bullish)\n\nDefault Parameters\n\nChannel Settings\nEntry Channel Period: 20 (Donchian Channel breakout period)\nExit Channel Period: 10 (reserved parameter)\n\nATR Settings\nATR Period: 20\nStop Loss ATR Multiplier: 2.0\nAdd Position ATR Multiplier: 0.5\n\nStructure Filter\nSwing Length: 300 (Swing High/Low calculation period)\nStructure Timeframe: 3 minutes\nAdjust these based on your trading timeframe and asset volatility\n\nPosition Management\nMaximum Units: 2 (including initial entry)\nCapital Per Unit: 5000 USD\n\nVisualization Features\n\nBackground Colors\nLight Green: Bullish market structure\nLight Red: Bearish market structure\nDark Green: Long position entry\nDark Red: Short position entry\n\nOptional Display Elements (Default: OFF)\nEntry and exit channel lines\nStructure high/low reference lines\nATR stop-loss indicator\nNext position add level\nEntry/exit labels\n\nAlert Message Format\n\nThe strategy sends notifications with the following format:\nEntry: \"5m Long EP:90450.50\"\nAdd Position: \"15m Add Long 2/2 EP:91000.25\"\nExit: \"5m Close Long Reverse Signal\"\n\nWhere the first part shows your current chart timeframe and EP indicates Entry Price\n\nBacktest Settings\n\nCapital Allocation\nInitial Capital: 10,000 USD\nPer Entry: 5,000 USD (split into 2 potential entries)\nLeverage: 0x (spot trading only)\n\nTrading Costs\nCommission: 0.06% (Binance spot VIP0 rate)\nSlippage: 0 (adjust based on your experience)\n\nBest Use Cases\n\nIdeal Scenarios\nTrending markets with clear directional movement\nModerate to high volatility assets\nTimeframes from 1-minute to 4-hour charts\nBest suited for major cryptocurrencies with good liquidity\n\nNot Recommended For\nHighly volatile choppy/ranging markets\nLow liquidity small-cap coins\nExtreme market conditions or black swan events\n\nUsage Recommendations\n\nTimeframe Guidelines\n1-5 minute charts: Use for scalping, consider Swing Length 100-160\n15-30 minute charts: Good for short-term trading, Swing Length 50-100\n1-4 hour charts: Suitable for swing trading, Swing Length 20-50\n\nOptimization Tips\nAlways backtest on historical data before live trading\nAdjust swing length based on asset volatility and your timeframe\nDifferent cryptocurrencies may require different parameter settings\nEnable visualization options initially to understand entry/exit points\nMonitor win rate and drawdown during backtesting\n\nTechnical Details\n\nBuilt on Pine Script v6\nNo repainting - uses proper bar referencing with   offset\nPrevents lookahead bias with lookahead=off parameter\nStrategy mode with accurate commission and slippage modeling\nMulti-timeframe security function for structure analysis\nProper position state tracking to avoid duplicate signals\n\nRisk Disclaimer\n\nThis strategy is provided for educational and research purposes only. Past performance does not guarantee future results. Backtesting results may differ from live trading due to slippage, execution delays, and changing market conditions. The strategy performs best in trending markets and may experience drawdowns during ranging conditions. Always practice proper risk management and never risk more than you can afford to lose. It is recommended to paper trade first and start with small position sizes when going live.\n\nHow to Use\n\nAdd the strategy to your TradingView chart\nSelect your desired timeframe (1m to 4h recommended)\nAdjust parameters based on your risk tolerance and trading style\nReview backtest results in the Strategy Tester tab\nSet up alerts for automated notifications\nConsider paper trading before risking real capital\n\nTags\nTrend Following, Turtle Trading, Donchian Channel, Structure Breakout, ATR, Cryptocurrency, Spot Trading, Risk Management, Pyramiding, Multi-Timeframe Analysis\n\n---\n\nStrategy Name: Trend Following BTC\nVersion: v1.0\nPine Script Version: v6\nLast Updated: December 2025",
    "image_url": "YVaGAcV3",
    "author": "ssun_6",
    "likes": 15,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-12",
    "updated": "2025-12-12",
    "source": "//@version=6\r\nstrategy(\"Trend $BTC/LUNC/SOMI\", shorttitle=\"$BTC/LUNC/SOMI 5/15m\", overlay=true, \r\n         initial_capital=10000, \r\n         default_qty_type=strategy.cash, \r\n         default_qty_value=5000, \r\n         commission_type=strategy.commission.percent, \r\n         commission_value=0.06,\r\n         slippage=0,\r\n         max_lines_count=500,\r\n         max_labels_count=500)\r\n\r\n// ========== åƒæ•¸è¨­å®š ==========\r\n// å”å¥‡å®‰é€šé“åƒæ•¸\r\nentry_period = input.int(20, \"é€²å ´é€šé“é€±æœŸ\", minval=1, group=\"é€šé“è¨­å®š\")\r\nexit_period = input.int(10, \"å‡ºå ´é€šé“é€±æœŸ\", minval=1, group=\"é€šé“è¨­å®š\")\r\n\r\n// ATR åƒæ•¸\r\natr_period = input.int(20, \"ATR é€±æœŸ\", minval=1, group=\"ATR è¨­å®š\")\r\natr_stop_mult = input.float(2.0, \"æ­¢æ ATR å€æ•¸\", minval=0.1, step=0.1, group=\"ATR è¨­å®š\")\r\natr_add_mult = input.float(0.5, \"åŠ å€‰ ATR å€æ•¸\", minval=0.1, step=0.1, group=\"ATR è¨­å®š\")\r\n\r\n// å¤šç©ºçµæ§‹åƒæ•¸ - åŠ å…¥å¤šæ™‚é–“æ¡†æž¶\r\nswing_length = input.int(300, \"çµæ§‹æ“ºå‹•é•·åº¦\", minval=1, group=\"ðŸ“Š å¤šç©ºçµæ§‹éŽæ¿¾\")\r\nstructure_timeframe = input.timeframe(\"3\", \"çµæ§‹æ™‚é–“æ¡†æž¶\", group=\"ðŸ“Š å¤šç©ºçµæ§‹éŽæ¿¾\", tooltip=\"é¸æ“‡çµæ§‹åˆ¤æ–·çš„æ™‚é–“é€±æœŸ,ç©ºç™½=ç•¶å‰åœ–è¡¨,D=æ—¥ç·š,W=é€±ç·š\")\r\nshow_structure_lines = input.bool(false, \"é¡¯ç¤ºçµæ§‹ç·š\", group=\"ðŸ“Š å¤šç©ºçµæ§‹éŽæ¿¾\")\r\nshow_structure_labels = input.bool(false, \"é¡¯ç¤ºçµæ§‹æ¨™ç±¤\", group=\"ðŸ“Š å¤šç©ºçµæ§‹éŽæ¿¾\")\r\n\r\n// åŠ å€‰è¨­å®š\r\nmax_units = input.int(2, \"æœ€å¤§å–®ä½æ•¸(å«é¦–æ¬¡)\", minval=1, maxval=10, group=\"å€‰ä½ç®¡ç†\")\r\nposition_size = input.int(5000, \"æ¯å–®ä½è³‡é‡‘(USD)\", minval=100, group=\"å€‰ä½ç®¡ç†\", tooltip=\"10000Uæœ¬é‡‘åˆ†2æ¬¡é€²å ´ï¼Œæ¯æ¬¡5000U\")\r\n\r\n// é¡¯ç¤ºè¨­å®š\r\nshow_channels = input.bool(false, \"é¡¯ç¤ºé€šé“\", group=\"é¡¯ç¤ºè¨­å®š\")\r\nshow_atr_lines = input.bool(false, \"é¡¯ç¤º ATR ç·š\", group=\"é¡¯ç¤ºè¨­å®š\")\r\nshow_labels = input.bool(true, \"é¡¯ç¤ºæ¨™ç±¤\", group=\"é¡¯ç¤ºè¨­å®š\")\r\nshow_table = input.bool(false, \"é¡¯ç¤ºè³‡è¨Šé¢æ¿\", group=\"é¡¯ç¤ºè¨­å®š\")\r\nlabel_distance = input.float(2.5, \"æ¨™ç±¤è·é›¢ K æ£’å€æ•¸\", minval=0.1, step=0.1, group=\"é¡¯ç¤ºè¨­å®š\", tooltip=\"æ¨™ç±¤è·é›¢Kæ£’çš„ATRå€æ•¸\")\r\nshow_label_lines = input.bool(false, \"é¡¯ç¤ºæ¨™ç±¤é€£ç·š\", group=\"é¡¯ç¤ºè¨­å®š\")\r\n\r\n// ========== è¨ˆç®—å”å¥‡å®‰é€šé“ ==========\r\nentry_upper = ta.highest(high, entry_period)\r\nentry_lower = ta.lowest(low, entry_period)\r\nexit_upper = ta.highest(high, exit_period)\r\nexit_lower = ta.lowest(low, exit_period)\r\n\r\n// ========== è¨ˆç®— ATR (Nå€¼) ==========\r\nN = ta.atr(atr_period)\r\n\r\n// ========== å¤šæ™‚é–“æ¡†æž¶å¤šç©ºçµæ§‹åˆ¤æ–· ==========\r\n// è¨ˆç®—çµæ§‹çš„å‡½æ•¸\r\nf_calculate_structure() =>\r\n    var int trend = 0\r\n    var float lastHigh = na\r\n    var float lastLow = na\r\n    \r\n    swingHigh = ta.pivothigh(high, swing_length, swing_length)\r\n    swingLow = ta.pivotlow(low, swing_length, swing_length)\r\n    \r\n    if not na(swingHigh)\r\n        lastHigh := swingHigh\r\n    \r\n    if not na(swingLow)\r\n        lastLow := swingLow\r\n    \r\n    if not na(lastHigh) and close > lastHigh and trend != 1\r\n        trend := 1\r\n    \r\n    if not na(lastLow) and close < lastLow and trend != -1\r\n        trend := -1\r\n    \r\n    [trend, lastHigh, lastLow]\r\n\r\n// ç²å–æŒ‡å®šæ™‚é–“æ¡†æž¶çš„çµæ§‹\r\n[structure_trend_mtf, last_structure_high_mtf, last_structure_low_mtf] = request.security(syminfo.tickerid, structure_timeframe, f_calculate_structure(), lookahead=barmerge.lookahead_off)\r\n\r\n// ä½¿ç”¨å¤šæ™‚é–“æ¡†æž¶çš„çµæ§‹è¶¨å‹¢\r\nstructure_trend = structure_trend_mtf\r\nlast_structure_high = last_structure_high_mtf\r\nlast_structure_low = last_structure_low_mtf\r\n\r\n// æª¢æ¸¬çµæ§‹è®ŠåŒ–ï¼ˆç”¨æ–¼ç¹ªè£½æ¨™ç±¤ï¼‰\r\nvar int prev_structure_trend = 0\r\nbool bull_break = structure_trend == 1 and prev_structure_trend != 1\r\nbool bear_break = structure_trend == -1 and prev_structure_trend != -1\r\nprev_structure_trend := structure_trend\r\n\r\n// ç¹ªè£½çµæ§‹çªç ´æ¨™ç±¤\r\nif show_structure_labels\r\n    if bull_break\r\n        label.new(bar_index, low, \"å¤šæ–¹çµæ§‹\", style=label.style_label_up, color=color.new(color.green, 0), textcolor=color.white, size=size.small)\r\n    \r\n    if bear_break\r\n        label.new(bar_index, high, \"ç©ºæ–¹çµæ§‹\", style=label.style_label_down, color=color.new(color.red, 0), textcolor=color.white, size=size.small)\r\n\r\n// ========== æŒå€‰ç‹€æ…‹è¿½è¹¤ ==========\r\nvar float entry_price = na\r\nvar float[] add_prices = array.new_float(0)\r\nvar int position = 0\r\nvar int units = 0\r\nvar float stop_loss = na\r\n\r\n// ========== é€²å ´è¨Šè™Ÿ (åŠ å…¥çµæ§‹éŽæ¿¾) ==========\r\nlong_entry_signal = close > entry_upper[1] and structure_trend == 1\r\nshort_entry_signal = close < entry_lower[1] and structure_trend == -1\r\n\r\nlong_entry = long_entry_signal and position != 1\r\nshort_entry = short_entry_signal and position != -1\r\n\r\n// ========== åŠ å€‰è¨Šè™Ÿ ==========\r\nlong_add = false\r\nshort_add = false\r\n\r\nif position == 1 and units < max_units\r\n    if array.size(add_prices) > 0\r\n        last_add_price = array.get(add_prices, array.size(add_prices) - 1)\r\n        long_add := close >= last_add_price + (atr_add_mult * N)\r\n    else\r\n        long_add := close >= entry_price + (atr_add_mult * N)\r\n\r\nif position == -1 and units < max_units\r\n    if array.size(add_prices) > 0\r\n        last_add_price = array.get(add_prices, array.size(add_prices) - 1)\r\n        short_add := close <= last_add_price - (atr_add_mult * N)\r\n    else\r\n        short_add := close <= entry_price - (atr_add_mult * N)\r\n\r\n// ========== å‡ºå ´è¨Šè™Ÿ (æ”¹ç‚ºåå‘è¨Šè™Ÿå‡ºå ´) ==========\r\n// å¤šå–®å‡ºå ´ï¼šç•¶ç©ºå–®é€²å ´è¨Šè™Ÿè§¸ç™¼æ™‚\r\nlong_exit = (position == 1) and short_entry_signal\r\n\r\n// ç©ºå–®å‡ºå ´ï¼šç•¶å¤šå–®é€²å ´è¨Šè™Ÿè§¸ç™¼æ™‚\r\nshort_exit = (position == -1) and long_entry_signal\r\n\r\n// ========== æ›´æ–°æŒå€‰ç‹€æ…‹ ==========\r\nif long_entry\r\n    position := 1\r\n    units := 1\r\n    entry_price := close\r\n    array.clear(add_prices)\r\n    array.push(add_prices, close)\r\n    stop_loss := close - (atr_stop_mult * N)\r\n    alert_msg = timeframe.period + \" åšå¤š EP:\" + str.tostring(close, \"#.##\")\r\n    strategy.entry(\"å¤šå–®1\", strategy.long, qty=position_size/close, comment=alert_msg, alert_message=alert_msg)\r\n    \r\nelse if short_entry\r\n    position := -1\r\n    units := 1\r\n    entry_price := close\r\n    array.clear(add_prices)\r\n    array.push(add_prices, close)\r\n    stop_loss := close + (atr_stop_mult * N)\r\n    alert_msg = timeframe.period + \" åšç©º EP:\" + str.tostring(close, \"#.##\")\r\n    strategy.entry(\"ç©ºå–®1\", strategy.short, qty=position_size/close, comment=alert_msg, alert_message=alert_msg)\r\n    \r\nelse if long_add\r\n    units := units + 1\r\n    array.push(add_prices, close)\r\n    stop_loss := close - (atr_stop_mult * N)\r\n    alert_msg = timeframe.period + \" åŠ å€‰å¤š \" + str.tostring(units) + \"/\" + str.tostring(max_units) + \" EP:\" + str.tostring(close, \"#.##\")\r\n    strategy.entry(\"å¤šå–®\" + str.tostring(units), strategy.long, qty=position_size/close, comment=alert_msg, alert_message=alert_msg)\r\n    \r\nelse if short_add\r\n    units := units + 1\r\n    array.push(add_prices, close)\r\n    stop_loss := close + (atr_stop_mult * N)\r\n    alert_msg = timeframe.period + \" åŠ å€‰ç©º \" + str.tostring(units) + \"/\" + str.tostring(max_units) + \" EP:\" + str.tostring(close, \"#.##\")\r\n    strategy.entry(\"ç©ºå–®\" + str.tostring(units), strategy.short, qty=position_size/close, comment=alert_msg, alert_message=alert_msg)\r\n    \r\nelse if long_exit or short_exit\r\n    if long_exit\r\n        alert_msg = timeframe.period + \" å¹³å¤š åå‘è¨Šè™Ÿ\"\r\n        strategy.close_all(comment=alert_msg, alert_message=alert_msg)\r\n    if short_exit\r\n        alert_msg = timeframe.period + \" å¹³ç©º åå‘è¨Šè™Ÿ\"\r\n        strategy.close_all(comment=alert_msg, alert_message=alert_msg)\r\n    \r\n    position := 0\r\n    units := 0\r\n    entry_price := na\r\n    array.clear(add_prices)\r\n    stop_loss := na\r\n\r\n// ========== ç¹ªè£½é€šé“ ==========\r\nplot(show_channels ? entry_upper : na, \"é€²å ´ä¸Šè»Œ\", color=color.new(color.red, 0), linewidth=2)\r\nplot(show_channels ? entry_lower : na, \"é€²å ´ä¸‹è»Œ\", color=color.new(color.green, 0), linewidth=2)\r\nplot(show_channels ? exit_upper : na, \"å‡ºå ´ä¸Šè»Œ\", color=color.new(color.orange, 50), linewidth=1, style=plot.style_circles)\r\nplot(show_channels ? exit_lower : na, \"å‡ºå ´ä¸‹è»Œ\", color=color.new(color.blue, 50), linewidth=1, style=plot.style_circles)\r\n\r\n// ç¹ªè£½çµæ§‹é«˜ä½Žé»ž\r\nplot(show_structure_lines ? last_structure_high : na, \"çµæ§‹é«˜é»ž\", color=color.new(color.red, 85), linewidth=2, style=plot.style_stepline)\r\nplot(show_structure_lines ? last_structure_low : na, \"çµæ§‹ä½Žé»ž\", color=color.new(color.green, 85), linewidth=2, style=plot.style_stepline)\r\n\r\n// ========== ç¹ªè£½ ATR ç·š ==========\r\nplot(show_atr_lines and position != 0 ? stop_loss : na, \"æ­¢æç·š\", color=color.new(color.red, 0), linewidth=2, style=plot.style_cross)\r\n\r\nvar float next_add_long = na\r\nif position == 1 and units < max_units\r\n    next_add_long := array.size(add_prices) > 0 ? array.get(add_prices, array.size(add_prices) - 1) + (atr_add_mult * N) : entry_price + (atr_add_mult * N)\r\nelse\r\n    next_add_long := na\r\n\r\nplot(show_atr_lines and position == 1 and units < max_units ? next_add_long : na, \"ä¸‹æ¬¡åŠ å€‰(å¤š)\", color=color.new(color.yellow, 30), linewidth=1, style=plot.style_stepline)\r\n\r\nvar float next_add_short = na\r\nif position == -1 and units < max_units\r\n    next_add_short := array.size(add_prices) > 0 ? array.get(add_prices, array.size(add_prices) - 1) - (atr_add_mult * N) : entry_price - (atr_add_mult * N)\r\nelse\r\n    next_add_short := na\r\n\r\nplot(show_atr_lines and position == -1 and units < max_units ? next_add_short : na, \"ä¸‹æ¬¡åŠ å€‰(ç©º)\", color=color.new(color.yellow, 30), linewidth=1, style=plot.style_stepline)\r\n\r\n// ========== ç¹ªè£½è¨Šè™Ÿæ¨™ç±¤ ==========\r\nif show_labels\r\n    label_offset = N * label_distance\r\n    long_label_style = show_label_lines ? label.style_label_up : label.style_none\r\n    short_label_style = show_label_lines ? label.style_label_down : label.style_none\r\n    \r\n    if long_entry\r\n        label.new(bar_index, low - label_offset, \"åšå¤šBTC\\nå–®ä½1/\" + str.tostring(max_units), color=color.new(color.green, 0), style=long_label_style, textcolor=color.white, size=size.normal, textalign=text.align_center)\r\n    \r\n    if short_entry\r\n        label.new(bar_index, high + label_offset, \"åšç©ºBTC\\nå–®ä½1/\" + str.tostring(max_units), color=color.new(color.red, 0), style=short_label_style, textcolor=color.white, size=size.normal, textalign=text.align_center)\r\n    \r\n    if long_add\r\n        label.new(bar_index, low - label_offset, \"åŠ å€‰å¤šå–®BTC\\nå–®ä½\" + str.tostring(units) + \"/\" + str.tostring(max_units), color=color.new(color.lime, 0), style=long_label_style, textcolor=color.black, size=size.small, textalign=text.align_center)\r\n    \r\n    if short_add\r\n        label.new(bar_index, high + label_offset, \"åŠ å€‰ç©ºå–®BTC\\nå–®ä½\" + str.tostring(units) + \"/\" + str.tostring(max_units), color=color.new(color.maroon, 0), style=short_label_style, textcolor=color.white, size=size.small, textalign=text.align_center)\r\n    \r\n    if long_exit\r\n        label.new(bar_index, low - label_offset, \"å¹³å¤šBTC\\nåå‘è¨Šè™Ÿ\", color=color.new(color.orange, 0), style=long_label_style, textcolor=color.white, size=size.normal, textalign=text.align_center)\r\n    \r\n    if short_exit\r\n        label.new(bar_index, high + label_offset, \"å¹³ç©ºBTC\\nåå‘è¨Šè™Ÿ\", color=color.new(color.blue, 0), style=short_label_style, textcolor=color.white, size=size.normal, textalign=text.align_center)\r\n\r\n// ========== èƒŒæ™¯é¡è‰² ==========\r\nbgcolor(structure_trend == 1 ? color.new(color.green, 70) : structure_trend == -1 ? color.new(color.red, 70) : na, title=\"çµæ§‹è¶¨å‹¢\")\r\nbgcolor(long_entry ? color.new(color.green, 85) : na, title=\"å¤šå–®é€²å ´\")\r\nbgcolor(short_entry ? color.new(color.red, 85) : na, title=\"ç©ºå–®é€²å ´\")\r\nbgcolor(long_add ? color.new(color.lime, 90) : na, title=\"å¤šå–®åŠ å€‰\")\r\nbgcolor(short_add ? color.new(color.maroon, 90) : na, title=\"ç©ºå–®åŠ å€‰\")\r\n"
  },
  {
    "url": "YCs14F4c-Volatility-Trend-Follower",
    "name": "Volatility Trend Follower",
    "description": "The script combines several classic technical analysis techniques:\n\nSuperTrend / Adaptive Band - The main idea comes from the SuperTrend indicator, which uses ATR (Average True Range) to create a trailing band that adapts to volatility\n\nATR (Average True Range) - A volatility measure developed by J. Welles Wilder Jr.\n\nEMA (Exponential Moving Average) - Used as a global trend filter\n\nHeikin Ashi - An option to smooth prices and reduce noise",
    "image_url": "YCs14F4c",
    "author": "Benji1302",
    "likes": 7,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=5\nstrategy(\"Volatility Trend Follower\", overlay=true, default_qty_type=strategy.percent_of_equity, default_qty_value=100)\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// PARAMÃˆTRES UTILISATEUR\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nmultiplier      = input.float(2.0,   \"Multiplicateur VolatilitÃ©\", minval=0.5, maxval=5, step=0.1)\nvolatilityLen   = input.int(14,      \"PÃ©riode VolatilitÃ©\", minval=1)\ntrendFilterLen  = input.int(100,     \"PÃ©riode Filtre Tendance\", minval=10)\nuseHeikinAshi   = input.bool(false,  \"Utiliser Heikin Ashi\")\nuseTrendFilter  = input.bool(true,   \"Activer Filtre Tendance\")\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// CALCUL DE LA SOURCE DE PRIX\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nhaClose = request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, close)\npriceSource = useHeikinAshi ? haClose : close\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// INDICATEUR DE VOLATILITÃ‰ (bande dynamique)\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nvolatility = ta.atr(volatilityLen)\nbandDistance = multiplier * volatility\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// BANDE ADAPTATIVE (trailing)\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nvar float adaptiveBand = na\nvar int currentDirection = 0\n\nupperBand = priceSource + bandDistance\nlowerBand = priceSource - bandDistance\n\nif na(adaptiveBand)\n    adaptiveBand := lowerBand\n    currentDirection := 1\nelse\n    if currentDirection == 1\n        adaptiveBand := math.max(adaptiveBand, lowerBand)\n        if priceSource < adaptiveBand\n            adaptiveBand := upperBand\n            currentDirection := -1\n    else\n        adaptiveBand := math.min(adaptiveBand, upperBand)\n        if priceSource > adaptiveBand\n            adaptiveBand := lowerBand\n            currentDirection := 1\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// FILTRE DE TENDANCE GLOBAL\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\ntrendLine = ta.ema(priceSource, trendFilterLen)\nbullishTrend = priceSource > trendLine\nbearishTrend = priceSource < trendLine\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// DÃ‰TECTION DES SIGNAUX\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\ndirectionChanged = currentDirection != currentDirection[1]\nlongSignal  = directionChanged and currentDirection == 1\nshortSignal = directionChanged and currentDirection == -1\n\n// Application du filtre de tendance\nvalidLong  = longSignal and (useTrendFilter ? bullishTrend : true)\nvalidShort = shortSignal and (useTrendFilter ? bearishTrend : true)\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// AFFICHAGE\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nbandColor = currentDirection == 1 ? color.new(color.teal, 0) : color.new(color.maroon, 0)\nplot(adaptiveBand, \"Bande Adaptative\", color=bandColor, linewidth=2)\nplot(useTrendFilter ? trendLine : na, \"Tendance\", color=color.gray, linewidth=1)\n\nplotshape(validLong,  \"Achat\",  shape.triangleup,   location.belowbar, color.teal,   size=size.small)\nplotshape(validShort, \"Vente\",  shape.triangledown, location.abovebar, color.maroon, size=size.small)\n\nbarcolor(currentDirection == 1 ? color.new(color.teal, 70) : color.new(color.maroon, 70))\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// EXÃ‰CUTION STRATÃ‰GIE\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nif validLong\n    strategy.close(\"Short\")\n    strategy.entry(\"Long\", strategy.long)\n\nif validShort\n    strategy.close(\"Long\")\n    strategy.entry(\"Short\", strategy.short)\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// ALERTES\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nalertcondition(validLong,  \"Signal Achat\",  \"ACHAT_SIGNAL\")\nalertcondition(validShort, \"Signal Vente\",  \"VENTE_SIGNAL\")"
  },
  {
    "url": "cVhMmD9X-Combined-Signal-Auto-Day-Plan-Volume",
    "name": "Combined Signal + Auto Day Plan + Volume",
    "description": "ðŸ“˜ TradingView Description â€” Combined Signal + Auto Day Plan + Volume\nStrategy Overview\n\nThis strategy combines trend-following signals, daily context levels, and volume confirmation to generate high-probability intraday trading setups.\nIt is designed to filter noise, identify trend direction early, and avoid trades during low-quality market conditions.\n\nðŸ”· 1. Combined Signal Logic\n\nThe strategy merges multiple indicators to produce a single, cleaner signal:\n\nLong Signal\n\nTrend bias is bullish\n\nMomentum histogram (MACD/Custom) shows upward pressure\n\nPrice crosses above the midline (WMA/EMA/etc.)\n\nVolume supports the move\n\nShort Signal\n\nTrend bias is bearish\n\nMomentum histogram shows downward pressure\n\nPrice crosses below the midline\n\nVolume supports the move\n\nThis reduces false breakouts and ensures signals appear only during strong directional moves.\n\nðŸ”¶ 2. Auto Day Plan Levels (D-1 â†’ D)\n\nThe script automatically reads previous day levels and displays them on todayâ€™s session:\n\nPrevious Day High (PDH)\n\nPrevious Day Low (PDL)\n\nPrevious Day Close (PDC)\n\nPrevious Day Mid / Range Zones\n\nOptional FIB levels or custom zones\n\nThese levels act as intraday support/resistance, helping identify breakout, reversal, and retest opportunities.\n\nBehavior:\n\nD-1 levels are plotted from todayâ€™s open until todayâ€™s close.\n\nLevels do not overlap into the wrong day.\n\nOptional: extend lines to next day (D+1) for planning.\n\nðŸ”· 3. Volume Confirmation\n\nTo improve entry accuracy, the script checks for strength in volume:\n\nVolume > X-period average\n\nVolume spike detection\n\nRelative Volume (RVOL) filter\n\nOptional low-volume avoidance\n\nA trade is taken only when the market shows real participation, reducing traps and sideways chop trades.\n\nðŸ”¶ 4. Entry & Exit Logic\nEntry\n\nLong Entry: Combined bull signal + volume confirmation\n\nShort Entry: Combined bear signal + volume confirmation\n\nExit\n\nLong Exit â†’ Histogram turns down (hist < hist )\n\nShort Exit â†’ Histogram turns up (hist > hist )\n\nOptional:\n\nAuto SL at PDL/PDH\n\nTrailing based on midline\n\nTake profit using FIB or volatility levels\n\nðŸ’  5. Visuals\n\nThe chart plots:\n\nBuy/Sell markers\n\nD-1 support/resistance lines\n\nTrend direction midline\n\nVolume confirmation label\n\nCombined signal status\n\nColors and styles can be customized from the input panel.\n\nðŸŽ¯ 6. Purpose of the Strategy\n\nThis is a complete intraday automation tool combining:\n\nâœ” Trend\nâœ” Momentum\nâœ” Volume strength\nâœ” Key day levels\n\nThe goal is to provide structured, mechanical, rule-based trading â€” reducing emotional decisions and improving consistency.",
    "image_url": "cVhMmD9X",
    "author": "PK-TELUGUTRADER",
    "likes": 5,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-12",
    "updated": "2025-12-12",
    "source": "//@version=5\r\nstrategy(\"Combined Signal + Auto Day Plan + Volume (English Version)\", overlay=true, max_lines_count=500, max_labels_count=100)\r\n\r\n// === Signal Settings\r\nlenImpulse = input.int(20, \"Impulse Length\")\r\nsmaLen     = input.int(50, \"SMA Length\")\r\nlevelRatio = input.float(0.2, \"SL/TP Multiplier\", step=0.01)\r\nvolLen     = input.int(20, \"Volume SMA Length\")\r\nmaxSignals = 100\r\n\r\n// === Trend\r\nsma = ta.sma(close, smaLen)\r\nbias = close > sma ? 1 : -1  // 1 = LONG, -1 = SHORT\r\n\r\n// === Impulse Range\r\nimpulseHigh = ta.highest(high, lenImpulse)\r\nimpulseLow  = ta.lowest(low, lenImpulse)\r\nimpulseRange = impulseHigh - impulseLow\r\n\r\n// === Signal\r\nvar float entryPrice = na\r\nvar int lastBias = na\r\nvar bool activeSignal = false\r\nvar int sig_bar = na\r\n\r\nvar float TP1 = na\r\nvar float TP2 = na\r\nvar float TP3 = na\r\nvar float SL  = na\r\n\r\nvar line lineTP1 = na\r\nvar line lineTP2 = na\r\nvar line lineTP3 = na\r\nvar line lineEntry = na\r\nvar line lineSL = na\r\n\r\n// === Signal Expiration\r\nsignalExpired = false\r\nif activeSignal and not na(entryPrice)\r\n    signalExpired := lastBias == 1 ? (close >= TP3 or close <= SL) : (close <= TP3 or close >= SL)\r\n\r\n// === Signal Reset Conditions\r\nsignalChanged = na(lastBias) or bias != lastBias or signalExpired\r\n\r\nif signalChanged\r\n    entryPrice := close\r\n    lastBias := bias\r\n    activeSignal := true\r\n    sig_bar := bar_index\r\n\r\n    TP1 := lastBias == 1 ? entryPrice + impulseRange * 0.382 : entryPrice - impulseRange * 0.382\r\n    TP2 := lastBias == 1 ? entryPrice + impulseRange * 0.618 : entryPrice - impulseRange * 0.618\r\n    TP3 := lastBias == 1 ? entryPrice + impulseRange * 0.786 : entryPrice - impulseRange * 0.786\r\n    SL  := lastBias == 1 ? entryPrice - impulseRange * levelRatio : entryPrice + impulseRange * levelRatio\r\n\r\n    if not na(lineTP1)\r\n        line.delete(lineTP1)\r\n        line.delete(lineTP2)\r\n        line.delete(lineTP3)\r\n        line.delete(lineEntry)\r\n        line.delete(lineSL)\r\n\r\n    lineTP1 := line.new(bar_index, TP1, bar_index+1, TP1, extend=extend.right, color=color.green)\r\n    lineTP2 := line.new(bar_index, TP2, bar_index+1, TP2, extend=extend.right, color=color.green)\r\n    lineTP3 := line.new(bar_index, TP3, bar_index+1, TP3, extend=extend.right, color=color.green)\r\n    lineEntry := line.new(bar_index, entryPrice, bar_index+1, entryPrice, extend=extend.right, color=color.yellow)\r\n    lineSL := line.new(bar_index, SL, bar_index+1, SL, extend=extend.right, color=color.red)\r\n\r\n// === Volume Strength\r\nvolSMA = ta.sma(volume, volLen)\r\nvolCategory = volume > volSMA * 1.5 ? \"Strong\" : volume < volSMA * 0.8 ? \"Weak\" : \"Normal\"\r\nvolColor     = volume > volSMA * 1.5 ? color.green : volume < volSMA * 0.8 ? color.red : color.yellow\r\n\r\n// === Signal Table\r\nvar table sigTbl = table.new(position.top_right, 2, 8, border_width=3)\r\n\r\nif not na(entryPrice)\r\n    table.cell(sigTbl, 0,0,\"ðŸ“ˆ Signal:\", text_color=color.black, bgcolor= lastBias==1 ? color.new(color.green,60) : color.new(color.red,60))\r\n    table.cell(sigTbl, 1,0, lastBias==1 ? \"LONG\" : \"SHORT\", text_color=color.black)\r\n\r\n    table.cell(sigTbl, 0,1,\"ðŸŽ¯ TP1:\", text_color=color.black)\r\n    table.cell(sigTbl, 1,1,str.tostring(TP1, format.mintick), text_color=color.green)\r\n\r\n    table.cell(sigTbl, 0,2,\"ðŸŽ¯ TP2:\", text_color=color.black)\r\n    table.cell(sigTbl, 1,2,str.tostring(TP2, format.mintick), text_color=color.green)\r\n\r\n    table.cell(sigTbl, 0,3,\"ðŸŽ¯ TP3:\", text_color=color.black)\r\n    table.cell(sigTbl, 1,3,str.tostring(TP3, format.mintick), text_color=color.green)\r\n\r\n    table.cell(sigTbl, 0,4,\"ðŸŸ¡ Entry:\", text_color=color.black)\r\n    table.cell(sigTbl, 1,4,str.tostring(entryPrice, format.mintick), text_color=color.black)\r\n\r\n    table.cell(sigTbl, 0,5,\"ðŸ›‘ Stop Loss:\", text_color=color.black)\r\n    table.cell(sigTbl, 1,5,str.tostring(SL, format.mintick), text_color=color.red)\r\n\r\n    table.cell(sigTbl, 0,6,\"ðŸ“Š Volume:\", text_color=color.black)\r\n    table.cell(sigTbl, 1,6,volCategory, text_color=volColor)\r\n\r\n// === Auto Day Plan Settings\r\nbaseTF = input.timeframe(\"60\", \"Base Timeframe for Zones/VWAP/Pivot\", [\"60\",\"240\",\"D\"])\r\nfwdBars = input.int(6, \"Forward Bars\", minval=1)\r\natrMult1 = input.float(1.0, \"ATR Multiplier Target 1\", step=0.1)\r\natrMult2 = input.float(2.0, \"ATR Multiplier Target 2\", step=0.1)\r\n\r\natrBase = request.security(syminfo.tickerid, baseTF, ta.atr(14))\r\natr1d   = request.security(syminfo.tickerid, \"D\", ta.atr(14))\r\natrAvg  = baseTF == \"D\" ? atr1d : (atrBase + atr1d)/2\r\n\r\nprevCloseTF = request.security(syminfo.tickerid, baseTF, close[1])\r\n\r\ncalc_from(base, m) => base + m * atrAvg\r\n\r\nsup1  = calc_from(prevCloseTF, -1.6)\r\nbalLo = calc_from(prevCloseTF, -1.0)\r\nbalHi = calc_from(prevCloseTF, -0.6)\r\nresLo = calc_from(prevCloseTF, 1.4)\r\nresHi = calc_from(prevCloseTF, 2.1)\r\npivot = prevCloseTF\r\n\r\n// === VWAP\r\nisNewPeriod = ta.change(time(baseTF))\r\nvar float vNum = 0\r\nvar float vDen = 0\r\n\r\nif isNewPeriod\r\n    vNum := 0\r\n    vDen := 0\r\n\r\nvNum += hlc3 * volume\r\nvDen += volume\r\nvwap = vDen > 0 ? vNum / vDen : na\r\n\r\n// === EMA Trend\r\nemaFast = ta.ema(close, 50)\r\nemaSlow = ta.ema(close, 200)\r\n\r\ntrendUp = emaFast > emaSlow\r\ntrendDown = emaFast < emaSlow\r\n\r\nexpectUp = trendUp and close > vwap and close > pivot\r\nexpectDown = trendDown and close < vwap and close < pivot\r\ndir = expectUp ? 1 : expectDown ? -1 : 0\r\n\r\n// === Zones\r\nvar box resBox = box.new(bar_index, resHi, bar_index, resLo, extend=extend.right, bgcolor=color.new(color.red,70))\r\nvar box balBox = box.new(bar_index, balHi, bar_index, balLo, extend=extend.right, bgcolor=color.new(color.orange,80))\r\nvar line supLine = line.new(bar_index, sup1, bar_index, sup1, extend=extend.right, color=color.green)\r\nvar line pivotLine = line.new(bar_index, pivot, bar_index, pivot, extend=extend.right, color=color.blue, style=line.style_dashed)\r\nvar line vwapLine = line.new(bar_index, vwap, bar_index, vwap, extend=extend.right, color=color.teal)\r\n\r\nbox.set_right(resBox, bar_index)\r\nbox.set_top(resBox, resHi)\r\nbox.set_bottom(resBox, resLo)\r\n\r\nbox.set_right(balBox, bar_index)\r\nbox.set_top(balBox, balHi)\r\nbox.set_bottom(balBox, balLo)\r\n\r\nline.set_xy1(supLine, bar_index, sup1)\r\nline.set_xy2(supLine, bar_index+1, sup1)\r\n\r\nline.set_xy1(pivotLine, bar_index, pivot)\r\nline.set_xy2(pivotLine, bar_index+1, pivot)\r\n\r\nline.set_xy1(vwapLine, bar_index, vwap)\r\nline.set_xy2(vwapLine, bar_index+1, vwap)\r\n\r\n// === Targets\r\ntgtUp1 = pivot + atrAvg * atrMult1\r\ntgtUp2 = pivot + atrAvg * atrMult2\r\ntgtDn1 = pivot - atrAvg * atrMult1\r\ntgtDn2 = pivot - atrAvg * atrMult2\r\n\r\nvar line t1Line = na\r\nvar line t2Line = na\r\n\r\nif dir != 0\r\n    col = dir == 1 ? color.lime : color.red\r\n    if na(t1Line)\r\n        t1Line := line.new(bar_index, dir==1?tgtUp1:tgtDn1, bar_index+fwdBars, dir==1?tgtUp1:tgtDn1, extend=extend.right, color=col, style=line.style_dotted)\r\n    if na(t2Line)\r\n        t2Line := line.new(bar_index, dir==1?tgtUp2:tgtDn2, bar_index+fwdBars, dir==1?tgtUp2:tgtDn2, extend=extend.right, color=col, style=line.style_dotted)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// ---------------------------\r\n// STRATEGY ENTRY CONDITIONS\r\n// ---------------------------\r\nlongEntry  = signalChanged and lastBias == 1\r\nshortEntry = signalChanged and lastBias == -1\r\n\r\nif (longEntry)\r\n    strategy.entry(\"LONG\", strategy.long, comment = \"LONG Entry\")\r\n\r\nif (shortEntry)\r\n    strategy.entry(\"SHORT\", strategy.short, comment = \"SHORT Entry\")\r\n\r\n// ---------------------------\r\n// STRATEGY EXIT CONDITIONS\r\n// ---------------------------\r\n\r\n\r\n// ---- TP1 exits ----\r\ntp1HitLong  = activeSignal and lastBias == 1  and high >= TP3\r\ntp1HitShort = activeSignal and lastBias == -1 and low <= TP3\r\n\r\nif (tp1HitLong)\r\n    strategy.exit(\"TP1 LONG EXIT\", from_entry = \"LONG\", limit = TP1, comment = \"TP1 Long Hit\")\r\n\r\nif (tp1HitShort)\r\n    strategy.exit(\"TP1 SHORT EXIT\", from_entry = \"SHORT\", limit = TP1, comment = \"TP1 Short Hit\")\r\n\r\n// ---- STOP LOSS exits ----\r\nslHitLong  = activeSignal and lastBias == 1  and close <= SL\r\nslHitShort = activeSignal and lastBias == -1 and close >= SL\r\n\r\nif (slHitLong)\r\n    strategy.exit(\"SL LONG EXIT\", from_entry = \"LONG\", stop = SL, comment = \"SL Long Hit\")\r\n\r\nif (slHitShort)\r\n    strategy.exit(\"SL SHORT EXIT\", from_entry = \"SHORT\", stop = SL, comment = \"SL Short Hit\")\r\n\r\n// =======================================\r\n// ALERT CONDITIONS (for real-time trading)\r\n// =======================================\r\nalertcondition(longEntry,  title=\"LONG Entry\",  message=\"LONG Entry Triggered\")\r\nalertcondition(shortEntry, title=\"SHORT Entry\", message=\"SHORT Entry Triggered\")\r\n\r\nalertcondition(tp1HitLong,  title=\"TP1 Hit LONG\",  message=\"TP1 Hit for LONG\")\r\nalertcondition(tp1HitShort, title=\"TP1 Hit SHORT\", message=\"TP1 Hit for SHORT\")\r\n\r\nalertcondition(slHitLong,  title=\"SL Hit LONG\",  message=\"Stoploss Hit LONG\")\r\nalertcondition(slHitShort, title=\"SL Hit SHORT\", message=\"Stoploss Hit SHORT\")\r\n"
  },
  {
    "url": "KlaTN7AD-Elliott-Wave-Full-Fractal-System-v2-0",
    "name": "Elliott Wave Full Fractal System v2.0",
    "description": "Elliott Wave Full Fractal System v2.0 â€“ Q.C. FINAL (Guaranteed R/R) \n\nElliott Wave Full Fractal System is a multi-timeframe wave engine that automatically labels Elliott impulses and ABC corrections, then builds a rule-based, ATR-driven risk/reward framework around the â€œW3â€“W4â€“W5â€ leg.\nâ€œGuaranteed R/Râ€ here means every order is placed with a predefined stop-loss and take-profit that respect a minimum Reward:Risk ratio â€“ it does  not  mean guaranteed profits.\n\n Core Idea \nThis strategy turns a full fractal Elliott Wave labelling engine into a systematic trading model.\nIt scans fractal pivots on three wave degrees (Primary, Intermediate, Minor) to detect 5-wave impulses and ABC corrections.\nA separate â€œTrading Degreeâ€ pivot stream, filtered by a 200-EMA trend filter and ATR-based dynamic pivots, is then used to find W4 pullback entries with a minimum, user-defined Reward:Risk ratio.\n\n Default Properties & Risk Assumptions \nThe backtest uses realistic but conservative defaults:\n\n \n// Default properties used for backtesting\nstrategy(\n\"Elliott Wave Full Fractal System - Q.C. FINAL (Guaranteed R/R)\",\noverlay           = true,\ninitial_capital   = 10000,      // realistic account size\ndefault_qty_type  = strategy.percent_of_equity,\ndefault_qty_value = 1,          // 1% risk per trade\ncommission_type   = strategy.commission.cash_per_contract,\ncommission_value  = 0.005,      // example stock commission\nslippage          = 0           // see notes below\n)\n \n \n Account size:  10,000 (can be changed to match your own account).\n Position sizing:  1% of equity per trade to keep risk per idea sustainable and aligned with TradingViewâ€™s recommendations.\n Commission:  0.005 cash per contract/share as a realistic example for stock trading.\n Slippage:  set to 0 in code for clarity of â€œpure logicâ€ backtesting. Real-life trading will experience slippage, so users should adjust this according to their market and broker.\n \n Always re-run the backtest after changing any of these values, and avoid using high risk fractions (5â€“10%+) as that is rarely sustainable. \n\n 1. Full Fractal Wave Engine \nThe script builds and maintains four pivot streams using ATR-adaptive fractals:\n \n Primary Degree (Macro Trend): \nCaptures the large swings that define the major trend. Labels â‘ â€“â‘¤ and â’¶â’·â’¸ using blue â€œCircleâ€ labels and thicker lines.\n Intermediate Degree (Trading Degree): \nCaptures the medium swings (swing-trading horizon). Uses teal labels ( (1)â€¦(5), (A)(B)(C) ).\n Minor Degree (Micro Structure): \nTracks short-term swings inside the larger waves. Uses red roman numerals (iâ€¦v, a b c).\n ABC Corrections (Optional): \nWhen enabled, the engine tries to detect standard Aâ€“Bâ€“C corrective structures that follow a completed 5-wave impulse and plots them with dashed lines.\n \nEach degree uses a dynamic pivot lookback that expands when ATR is above its EMA, so the system naturally requires â€œstrongerâ€ pivots in volatile environments and reacts faster in quiet conditions.\n\n 2. Theory Rules & Strict Mode \n \n Normal Mode:  More permissive detection. Designed to show more wave structures for educational / exploratory use.\n Strict Mode:  Enforces key Elliott constraints:\n \n Wave 3 not shorter than waves 1 and 5.\n No invalid W4 overlap with W1 (for standard impulses).\n \n ABC Logic:  After a confirmed bullish impulse, the script expects a down-up-down corrective pattern (A,B,C). After a bearish impulse, it looks for up-down-up.\n \n 3. Trend Filter & Pivots \n \n EMA Trend Filter:  A configurable EMA (default 200) is used as a non-wave trend filter.\n \n Price above EMA â†’ Only long setups are considered.\n Price below EMA â†’ Only short setups are considered.\n \n ATR-Adaptive Pivots:  The pivot engine scales its left/right bars based on current ATR vs ATR EMA, making waves and trading pivots more robust in volatile regimes.\n \n 4. Dynamic Risk Management (Guaranteed R/R Engine) \n\nThe trading engine is designed around risk, not just pattern recognition:\n \n ATR-Based Stop: \nStop-loss is placed at:\n Entry Â± ATR Ã— Multiplier  (user-configurable, default 2.0).\nThis anchors risk to current volatility.\n Minimum Reward:Risk Ratio: \nFor each setup, the script:\n \n Computes the distance from entry to stop (risk).\n Projects a take-profit target at  risk Ã— min_rr_ratio  away from entry.\n Only accepts the setup if risk is positive and the required R:R ratio is achievable.\n \n Result:  Every order is created with both TP and SL at a predefined distance, so each trade starts with a known, minimum Reward:Risk profile by design.\n \n â€œGuaranteed R/Râ€ refers exclusively to this order placement logic (TP/SL geometry), not to win-rate or profitability. \n\n 5. Trading Logic â€“ W3â€“W4â€“W5 Pattern \n\nThe Trading pivot stream (separate from visual wave degrees) looks for a simple but powerful pattern:\n \n Bullish structure: \n \n Sequence of pivots forms a higher-high / higher-low pattern.\n Price is above the EMA trend filter.\n A strong â€œW3â€ leg is confirmed with structure rules (optionally stricter in Strict mode).\n \n Entry (Long â€“ W4 Pullback): \n \n The â€œheightâ€ of W3 is measured.\n Entry is placed at a configurable Fibonacci pullback (default 50%) inside that leg.\n ATR-based stop is placed below entry.\n Take-profit is projected to satisfy min Reward:Risk.\n \n Bearish structure: \nMirrored logic (lower highs/lows, price below EMA, W3 down, W4 retrace up, W5 continuation down).\n \nOnce a valid setup is found, the script draws a colored box around the entry zone and a label describing the type of signal (â€œLONG SETUPâ€ or â€œSHORT SETUPâ€) with the suggested limit price.\n\n 6. Orders & Execution \n \n Entry Orders:  The strategy uses  limit  orders at the computed W4 level (â€œSniper Longâ€ or â€œSniper Shortâ€).\n Exits:  A single strategy.exit() is attached to each entry with:\n \n Take-profit at the projected minimum R:R target.\n Stop-loss at ATR-based level.\n \n One Trade at a Time:  New setups are only used when there is no open position (strategy.opentrades == 0) to keep the logic clear and risk contained.\n \n 7. Visual Guide on the Chart \n \n Wave Labels: \n \n Primary: â‘ ,â‘¡,â‘¢,â‘£,â‘¤, â’¶â’·â’¸\n Intermediate: (1)â€¦(5), (A)(B)(C)\n Minor: iâ€¦v, a b c\n \n Trend EMA:  Single blue EMA showing the dominant trend.\n Setup Boxes: \n \n Green transparent box â†’ long entry zone.\n Red transparent box â†’ short entry zone.\n \n Labels:  â€œLONG SETUP / SHORT SETUPâ€ labels mark the proposed limit entry with price.\n \n 8. How to Use This Strategy \n \n Attach the strategy to your chart \nChoose your market (stocks, indices, FX, crypto, futures, etc.) and timeframe (for example 1h, 4h, or Daily). Then add the strategy to the chart from your Scripts list.\n\n Start with the default settings \nLeave all inputs on their defaults first. This lets you see the â€œintendedâ€ behaviour and the exact properties used for the published backtest (account size, 1% risk, commission, etc.).\n\n Study the wave map \nZoom in and out and look at the three wave degrees:\n \n Blue circles â†’ Primary degree (big picture trend).\n Teal (1)â€¦(5) â†’ Intermediate degree (swing structure).\n Red iâ€¦v â†’ Minor degree (micro waves).\n \nUse this to understand how the engine is interpreting the Elliott structure on your symbol.\n\n Watch for valid setups \nLook for the coloured boxes and labels:\n \n Green box + â€œLONG SETUPâ€ label â†’ potential W4 pullback long in an uptrend.\n Red box + â€œSHORT SETUPâ€ label â†’ potential W4 pullback short in a downtrend.\n \nOnly trades in the direction of the EMA trend filter are allowed by the strategy.\n\n Check the Reward:Risk of each idea \nFor each setup, inspect:\n \n Limit entry price.\n ATR-based stop level.\n Projected take-profit level.\n \nMake sure the minimum Reward:Risk ratio matches your own rules before you consider trading it.\n\n Backtest and evaluate \nOpen the Strategy Tester:\n \n Verify you have a decent sample size (ideally 100+ trades).\n Check drawdowns, average trade, win-rate and R:R distribution.\n Change markets and timeframes to see where the logic behaves best.\n \n Adapt to your own risk profile \nIf you plan to use it live:\n \n Set  Initial Capital  to your real account size.\n Adjust  default_qty_value  to a risk level you are comfortable with (often 0.5â€“2% per trade).\n Set  commission  and  slippage  to realistic broker values.\n Re-run the backtest after every major change.\n \n Use as a framework, not a signal machine \nTreat this as a structured Elliott/R:R framework:\n \n Filter signals by higher-timeframe trend, major S/R, volume, or fundamentals.\n Optionally hide some wave degrees or ABC labels if you want a cleaner chart.\n Combine the systemâ€™s structure with your own trade management and discretion.\n \n \n Best Practices & Limitations \n \n This is an  approximate  Elliott Wave engine based on fractal pivots. It does not replace a full discretionary Elliott analysis.\n All wave counts are algorithmic and can differ from a manual analystâ€™s interpretation.\n Like any backtest, results depend heavily on:\n \n Symbol and timeframe.\n Sample size (more trades are better).\n Realistic commission/slippage settings.\n \n The 0-slippage default is chosen only to show the â€œraw logicâ€. In real markets, slippage can significantly impact performance.\n No strategy wins all the time. Losing streaks and drawdowns will still occur even with a strict R:R framework.\n \n Disclaimer \n\n This script is for educational and research purposes only and does not constitute financial advice or a recommendation to buy or sell any security. Past performance, whether real or simulated, is not indicative of future results. Always test on multiple symbols/timeframes, use conservative risk, and consult your financial advisor before trading live capital. \n",
    "image_url": "KlaTN7AD",
    "author": "mbedaiwi2",
    "likes": 15,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// Â© mbedaiwi2\n\n//@version=6 \nstrategy(\n     \"Elliott Wave Full Fractal System v2.0\", \n     overlay             = true,\n     max_labels_count    = 500,\n     max_lines_count     = 500,\n     max_boxes_count     = 500,\n     initial_capital     = 10000,\n     default_qty_type    = strategy.percent_of_equity,\n     default_qty_value   = 1,\n     commission_type     = strategy.commission.cash_per_contract,\n     commission_value    = 0.005,\n     slippage            = 0\n)\n\n// 1. SETTINGS -------------------------------------------------------------\n\n// 1.1 Wave degrees\ngrpCycle   = \"1. Primary Degree (Macro Trend)\"\nshowPrimary = input.bool(true, \"Show Primary Waves (1, 2...)\", group = grpCycle)\nlenPriL     = input.int(21, \"Primary Lookback Left\",  group = grpCycle)\nlenPriR     = input.int(21, \"Primary Lookback Right\", group = grpCycle)\n\ngrpInter   = \"2. Intermediate Degree (Trading Degree)\"\nshowInter   = input.bool(true, \"Show Intermediate Waves ((1), (2)...)\", group = grpInter)\nlenIntL = input.int(5,   \"Intermediate Lookback Left\",  minval = 2, group = grpInter)\nlenIntR = input.int(5,   \"Intermediate Lookback Right\", minval = 2, group = grpInter)\n\ngrpMinor   = \"3. Minor Degree (Micro Structure)\"\nshowMinor   = input.bool(true, \"Show Minor Waves (i, ii...)\", group = grpMinor)\nlenMinL = input.int(3,   \"Minor Lookback Left\",  group = grpMinor)\nlenMinR = input.int(3,   \"Minor Lookback Right\", group = grpMinor)\n\n// 1.2 Rules\ngrpRules    = \"Theory Rules\"\nrule_Strict = input.bool(false, \"Strict Rules (No Overlap, W3 Not Shortest)\", group = grpRules)\nshowABC     = input.bool(true, \"Show ABC Corrections\", group = grpRules)\n\n// 1.3 Pivot / ATR\ngrpVol = \"Pivot Dynamics\"\natr_len = input.int(14, \"ATR Lookback for Dynamic Pivots\", group = grpVol)\n\n// 1.4 EMA Trend Filter\ngrpFilter = \"4. Trend Filter (Non-Wave)\"\nema_len = input.int(200, \"EMA Trend Filter Length\", group = grpFilter)\nema_filter = ta.ema(close, ema_len)\nplot(ema_filter, color = color.blue, title = \"Trend EMA\")\n\n// 1.5 Dynamic Risk Management\ngrpRisk = \"5. Dynamic Risk Management\"\natr_stop_mult = input.float(2.0, \"ATR Stop Multiplier (Stop = Entry +/- ATR*X)\", minval = 1.0, step = 0.1, group = grpRisk)\nmin_rr_ratio = input.float(2.0, \"Minimum Reward/Risk Ratio (TP Target)\", minval = 1.5, step = 0.5, group = grpRisk)\n\n// 1.6 Trading Settings\ngrpTrade   = \"STRATEGY SETTINGS\"\ntrade_on = input.bool(true, \"Active Trading Signals\", group = grpTrade)\nfib_entry = input.float(0.50, \"W4 Entry Fib\", minval = 0.2, maxval = 0.7, step = 0.02, group = grpTrade)\nfib_target = input.float(1.618, \"W5 Target Extension (Deprecated)\", group = grpTrade) \n\n// 2. GLOBAL ARRAYS & STATE (Unchanged)\nvar int[]  pri_idx = array.new_int()\nvar float[] pri_prc = array.new_float()\nvar int[]  pri_typ = array.new_int()\n\nvar int[]  int_idx = array.new_int()\nvar float[] int_prc = array.new_float()\nvar int[]  int_typ = array.new_int()\n\nvar int[]  min_idx = array.new_int()\nvar float[] min_prc = array.new_float()\nvar int[]  min_typ = array.new_int()\n\nvar int[]  trd_idx = array.new_int()\nvar float[] trd_prc = array.new_float()\nvar int[]  trd_typ = array.new_int()\n\nvar int[]  lastIdxArr     = array.new_int(3, 0)\nvar int[]  lastW5IdxArr   = array.new_int(3, 0)\nvar bool[] lastWasBullArr = array.new_bool(3, false)\n\n\n// 3. HELPER FUNCTIONS ---------------------------------------------------------\n\n// Visual Styles\nf_get_style(_degree) =>\n    color waveColor = color.new(color.blue, 0)\n    string fmt = \"Circle\"\n    int w = 2\n    if _degree == \"Primary\"\n        waveColor := color.new(color.blue, 0)\n        fmt := \"Circle\"\n        w := 3\n    else if _degree == \"Intermediate\"\n        waveColor := color.new(color.teal, 0)\n        fmt := \"Paren\"\n        w := 2\n    else\n        waveColor := color.new(color.red, 0)\n        fmt := \"Roman\"\n        w := 1\n    [waveColor, fmt, w]\n\n// Label Drawer\nf_draw_wave(int _idx, float _price, int _count, bool _isBull, string _degree) =>\n    [cWave, fmt, wid] = f_get_style(_degree)\n    string txt = \"\"\n    if fmt == \"Circle\"\n        txt := _count == 1 ? \"â‘ \" : _count == 2 ? \"â‘¡\" : _count == 3 ? \"â‘¢\" : _count == 4 ? \"â‘£\" : _count == 5 ? \"â‘¤\" : _count == 11 ? \"â’¶\" : _count == 12 ? \"â’·\" : _count == 13 ? \"â’¸\" : \"?\"\n    else if fmt == \"Paren\"\n        txt := _count == 1 ? \"(1)\" : _count == 2 ? \"(2)\" : _count == 3 ? \"(3)\" : _count == 4 ? \"(4)\" : _count == 5 ? \"(5)\" : _count == 11 ? \"(A)\" : _count == 12 ? \"(B)\" : _count == 13 ? \"(C)\" : \"?\"\n    else\n        txt := _count == 1 ? \"i\" : _count == 2 ? \"ii\" : _count == 3 ? \"iii\" : _count == 4 ? \"iv\" : _count == 5 ? \"v\" : _count == 11 ? \"a\" : _count == 12 ? \"b\" : _count == 13 ? \"c\" : \"?\"\n\n    label.new(\n          _idx, _price, txt, xloc = xloc.bar_index, yloc = _isBull ? yloc.abovebar : yloc.belowbar,\n          style = _isBull ? label.style_label_down : label.style_label_up, color = cWave, textcolor = color.white,\n          size = _degree == \"Primary\" ? size.normal : size.small)\n\n// Utility: limit array size\nf_trim_arrays(int[] idx, float[] prc, int[] typ, int maxSize) =>\n    while array.size(idx) > maxSize\n        array.shift(idx)\n        array.shift(prc)\n        array.shift(typ)\n\n// Dynamic Pivot Updater\nf_update_pivots(int _L, int _R, int[] idx, float[] prc, int[] typ) =>\n    float atrValue = ta.atr(atr_len)\n    float avgAtr   = ta.ema(atrValue, 50)\n\n    int dynamic_L = math.round(_L * (atrValue > avgAtr ? 1.5 : 1.0))\n    int dynamic_R = math.round(_R * (atrValue > avgAtr ? 1.5 : 1.0))\n\n    dynamic_L := math.max(2, dynamic_L)\n    dynamic_R := math.max(2, dynamic_R)\n\n    float ph = ta.pivothigh(high, dynamic_L, dynamic_R)\n    float pl = ta.pivotlow(low,  dynamic_L, dynamic_R)\n\n    if not na(ph)\n        array.push(idx, bar_index[dynamic_R])\n        array.push(prc, ph)\n        array.push(typ, 1)\n    if not na(pl)\n        array.push(idx, bar_index[dynamic_R])\n        array.push(prc, pl)\n        array.push(typ, -1)\n\n    f_trim_arrays(idx, prc, typ, 300)\n\n// Visualization Engine for one degree\nf_process_degree(string _degName, int _degIndex, bool _show, int[] idx, float[] prc, int[] typ) =>\n    if not _show\n        [0, 0, false]\n    else\n        int  lastIdx     = array.get(lastIdxArr, _degIndex)\n        int  lastW5Idx   = array.get(lastW5IdxArr, _degIndex)\n        bool lastWasBull = array.get(lastWasBullArr, _degIndex)\n\n        if array.size(idx) >= 6\n            int sz = array.size(idx)\n\n            int  i0 = array.get(idx, sz - 6)\n            int  i1 = array.get(idx, sz - 5)\n            int  i2 = array.get(idx, sz - 4)\n            int  i3 = array.get(idx, sz - 3)\n            int  i4 = array.get(idx, sz - 2)\n            int  i5 = array.get(idx, sz - 1)\n            float p0 = array.get(prc, sz - 6)\n            float p1 = array.get(prc, sz - 5)\n            float p2 = array.get(prc, sz - 4)\n            float p3 = array.get(prc, sz - 3)\n            float p4 = array.get(prc, sz - 2)\n            float p5 = array.get(prc, sz - 1)\n            int  t0 = array.get(typ, sz - 6)\n\n            // â”€â”€ IMPULSE WAVE DETECTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n            if i0 > lastIdx\n                // Bullish 5-wave\n                if t0 == -1 and p1 > p0 and p3 > p1 and p5 > p3 and p2 > p0 and p4 > p2\n                    \n                    bool r3_gt_r1      = rule_Strict ? (math.abs(p3 - p2) > math.abs(p1 - p0)) : true\n                    bool r4_no_overlap = rule_Strict ? (p4 > p1) : true\n\n                    float len1          = math.abs(p1 - p0)\n                    float len3          = math.abs(p3 - p2)\n                    float len5          = math.abs(p5 - p4)\n                    float min_len       = math.min(len1, math.min(len3, len5))\n                    bool  r3_not_short  = rule_Strict ? (len3 > min_len) : true\n\n                    if r3_gt_r1 and r4_no_overlap and r3_not_short\n                        lastIdx     := i5\n                        lastW5Idx   := i5\n                        lastWasBull := true\n\n                        f_draw_wave(i1, p1, 1, true, _degName)\n                        f_draw_wave(i2, p2, 2, true, _degName)\n                        f_draw_wave(i3, p3, 3, true, _degName)\n                        f_draw_wave(i4, p4, 4, true, _degName)\n                        f_draw_wave(i5, p5, 5, true, _degName)\n                        [c, _, w] = f_get_style(_degName)\n                        line.new(i0, p0, i1, p1, color = c, width = w)\n                        line.new(i1, p1, i2, p2, color = c, width = w)\n                        line.new(i2, p2, i3, p3, color = c, width = w)\n                        line.new(i3, p3, i4, p4, color = c, width = w)\n                        line.new(i4, p4, i5, p5, color = c, width = w)\n\n                // Bearish 5-wave\n                else if t0 == 1 and p1 < p0 and p3 < p1 and p5 < p3 and p2 < p0 and p4 < p2\n                    bool r3b_gt_r1b      = rule_Strict ? (math.abs(p2 - p3) > math.abs(p0 - p1)) : true\n                    bool r4b_no_overlap  = rule_Strict ? (p4 < p1) : true\n\n                    float len1b         = math.abs(p0 - p1)\n                    float len3b         = math.abs(p2 - p3)\n                    float len5b         = math.abs(p4 - p5)\n                    float min_lenb      = math.min(len1b, math.min(len3b, len5b))\n                    bool  r3_not_short_b = rule_Strict ? (len3b > min_lenb) : true\n\n                    if r3b_gt_r1b and r4b_no_overlap and r3_not_short_b\n                        lastIdx     := i5\n                        lastW5Idx   := i5\n                        lastWasBull := false\n\n                        f_draw_wave(i1, p1, 1, false, _degName)\n                        f_draw_wave(i2, p2, 2, false, _degName)\n                        f_draw_wave(i3, p3, 3, false, _degName)\n                        f_draw_wave(i4, p4, 4, false, _degName)\n                        f_draw_wave(i5, p5, 5, false, _degName)\n                        [c, _, w] = f_get_style(_degName)\n                        line.new(i0, p0, i1, p1, color = c, width = w)\n                        line.new(i1, p1, i2, p2, color = c, width = w)\n                        line.new(i2, p2, i3, p3, color = c, width = w)\n                        line.new(i3, p3, i4, p4, color = c, width = w)\n                        line.new(i4, p4, i5, p5, color = c, width = w)\n\n            // â”€â”€ ABC CORRECTION DETECTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n            if showABC and lastW5Idx > 0 and i3 >= lastW5Idx\n                int  ia = i3, ib = i4, ic = i5\n                float pa = p3, pb = p4, pc = p5\n\n                // After bullish impulse: look for down-up-down\n                if lastWasBull and p3 < p2\n                    if pc < pa and pb < array.get(prc, sz - 4)\n                        lastIdx := ic\n                        f_draw_wave(ia, pa, 11, false, _degName)   // A\n                        f_draw_wave(ib, pb, 12, true,  _degName)   // B\n                        f_draw_wave(ic, pc, 13, false, _degName)   // C\n                        [cA, _, _wA] = f_get_style(_degName)\n                        line.new(i2, p2, ia, pa, color = color.new(cA, 50), width = 1, style = line.style_dashed)\n                        line.new(ia, pa, ib, pb, color = color.new(cA, 50), width = 1, style = line.style_dashed)\n                        line.new(ib, pb, ic, pc, color = color.new(cA, 50), width = 1, style = line.style_dashed)\n\n                // After bearish impulse: look for up-down-up\n                if not lastWasBull and p3 > p2\n                    if pc > pa and pb > array.get(prc, sz - 4)\n                        lastIdx := ic\n                        f_draw_wave(ia, pa, 11, true,  _degName)   // A\n                        f_draw_wave(ib, pb, 12, false, _degName)   // B\n                        f_draw_wave(ic, pc, 13, true,  _degName)   // C\n                        [cB, _, _wB] = f_get_style(_degName)\n                        line.new(i2, p2, ia, pa, color = color.new(cB, 50), width = 1, style = line.style_dashed)\n                        line.new(ia, pa, ib, pb, color = color.new(cB, 50), width = 1, style = line.style_dashed)\n                        line.new(ib, pb, ic, pc, color = color.new(cB, 50), width = 1, style = line.style_dashed)\n\n            // Save updated state back into arrays\n            array.set(lastIdxArr,     _degIndex, lastIdx)\n            array.set(lastW5IdxArr,   _degIndex, lastW5Idx)\n            array.set(lastWasBullArr, _degIndex, lastWasBull)\n\n        [lastIdx, lastW5Idx, lastWasBull]\n\n// 4. UPDATE PIVOTS (once per bar) ---------------------------------------------\n\nf_update_pivots(lenPriL, lenPriR, pri_idx, pri_prc, pri_typ)\nf_update_pivots(lenIntL, lenIntR, int_idx, int_prc, int_typ)\nf_update_pivots(lenMinL, lenMinR, min_idx, min_prc, min_typ)\nf_update_pivots(lenIntL, lenIntR, trd_idx, trd_prc, trd_typ)\n\n// 5. DRAW WAVES FOR EACH DEGREE -----------------------------------------------\n\nf_process_degree(\"Primary\", 0, showPrimary, pri_idx, pri_prc, pri_typ)\nf_process_degree(\"Intermediate\", 1, showInter, int_idx, int_prc, int_typ)\nf_process_degree(\"Minor\", 2, showMinor, min_idx, min_prc, min_typ)\n\n// 6. TRADING ENGINE -----------------------------------------------------------\n\n// Trade state\nvar int trade_lastW3 = 0\nvar int trade_dir = 0\nvar float trade_entry = na\nvar float trade_stop = na\nvar float trade_tp = na\n\n// 6.1 Setup detection based on trading pivots\nif trade_on and array.size(trd_idx) >= 4\n    int sz = array.size(trd_idx)\n\n    int i3 = array.get(trd_idx, sz - 1)\n    float p0 = array.get(trd_prc, sz - 4)\n    float p1 = array.get(trd_prc, sz - 3)\n    float p2 = array.get(trd_prc, sz - 2)\n    float p3 = array.get(trd_prc, sz - 1)\n    int t0 = array.get(trd_typ, sz - 4)\n    int t3 = array.get(trd_typ, sz - 1)\n    \n    // **FIXED: ATR calculation moved here**\n    float current_atr = ta.atr(atr_len)\n\n    // Only react to a fresh pivot sequence\n    if i3 > trade_lastW3\n        bool is_bull_trend = close > ema_filter\n        bool is_bear_trend = close < ema_filter\n\n        // â”€â”€ LONG SETUP\n        if t0 == -1 and t3 == 1 and is_bull_trend\n            bool isBullStruct = (p1 > p0) and (p2 > p0) and (p2 < p1) and (p3 > p1)\n\n            float len1 = math.abs(p1 - p0)\n            float len3 = math.abs(p3 - p2)\n            bool r3_gt1 = rule_Strict ? (len3 > len1) : true\n\n            if isBullStruct and r3_gt1\n                trade_lastW3 := i3\n                float w3_height = p3 - p2\n\n                float entryPrice = p3 - (w3_height * fib_entry)\n                float stopPrice  = entryPrice - (current_atr * atr_stop_mult)\n                \n                // Calculate TP to GUARANTEE min_rr_ratio\n                float risk_long  = entryPrice - stopPrice\n                float tpPrice    = entryPrice + (risk_long * min_rr_ratio) \n\n                // Check stop viability and ensure risk > 0\n                bool  rr_ok      = risk_long > 0 \n                \n                if entryPrice > stopPrice and rr_ok\n                    trade_dir  := 1\n                    trade_entry := entryPrice\n                    trade_stop := stopPrice\n                    trade_tp := tpPrice\n\n                    box.new(bar_index, p3, bar_index + 20, entryPrice, xloc = xloc.bar_index, bgcolor = color.new(color.green, 85), border_color = na)\n                    label.new(bar_index, entryPrice, \"LONG SETUP\\nLimit Buy: \" + str.tostring(entryPrice, \"#.##\"), xloc = xloc.bar_index, yloc = yloc.belowbar, style = label.style_label_up, color = color.green, textcolor = color.white, size = size.small)\n\n\n        // â”€â”€ SHORT SETUP\n        else if t0 == 1 and t3 == -1 and is_bear_trend\n            bool isBearStruct = (p1 < p0) and (p2 < p0) and (p2 > p1) and (p3 < p1)\n\n            float len1b  = math.abs(p0 - p1)\n            float len3b  = math.abs(p2 - p3)\n            bool r3_gt1b = rule_Strict ? (len3b > len1b) : true\n\n            if isBearStruct and r3_gt1b\n                trade_lastW3 := i3\n                float w3_height = p2 - p3\n\n                float entryPrice = p3 + (w3_height * fib_entry)\n                float stopPrice  = entryPrice + (current_atr * atr_stop_mult)\n                \n                // Calculate TP to GUARANTEE min_rr_ratio\n                float risk_short   = stopPrice - entryPrice\n                float tpPrice   = entryPrice - (risk_short * min_rr_ratio)\n\n                // Check stop viability and ensure risk > 0\n                bool  rr_ok      = risk_short > 0\n\n                if entryPrice < stopPrice and rr_ok\n                    trade_dir  := -1\n                    trade_entry := entryPrice\n                    trade_stop := stopPrice\n                    trade_tp := tpPrice\n\n                    box.new(bar_index, p3, bar_index + 20, entryPrice, xloc = xloc.bar_index, bgcolor = color.new(color.red, 85), border_color = na)\n                    label.new(bar_index, entryPrice, \"SHORT SETUP\\nLimit Sell: \" + str.tostring(entryPrice, \"#.##\"), xloc = xloc.bar_index, yloc = yloc.abovebar, style = label.style_label_down, color = color.red, textcolor = color.white, size = size.small)\n\n// 7. ORDER EXECUTION ----------------------------------------------------------\n\n// Long execution\nif trade_dir == 1 and strategy.opentrades == 0\n    strategy.order(\"Sniper Long\", strategy.long, limit = trade_entry, comment = \"W4 Buy Limit\")\n    strategy.exit(\"TP/SL Long\", \"Sniper Long\", limit = trade_tp, stop = trade_stop, comment = \"W5 TP / ATR SL\")\n    trade_dir  := 0\n    trade_entry := na\n    trade_stop := na\n    trade_tp := na\n\n// Short execution\nif trade_dir == -1 and strategy.opentrades == 0\n    strategy.order(\"Sniper Short\", strategy.short, limit = trade_entry, comment = \"W4 Sell Limit\")\n    strategy.exit(\"TP/SL Short\", \"Sniper Short\", limit = trade_tp, stop = trade_stop, comment = \"W5 TP / ATR SL\")\n    trade_dir  := 0\n    trade_entry := na\n    trade_stop := na\n    trade_tp := na"
  },
  {
    "url": "yP9aTS37-Layered-Bi-Directional-Grid-Maker-SUPERBEST",
    "name": "Layered Bi-Directional Grid Maker SUPERBEST",
    "description": "super best for btc 1m scalp trade please be careful",
    "image_url": "yP9aTS37",
    "author": "Besttraderalltheworld",
    "likes": 9,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=5\r\nstrategy(\"Layered Bi-Directional Grid Maker (FIXED)\", overlay=true, pyramiding=20, initial_capital=50000, default_qty_type=strategy.fixed, default_qty_value=12, currency=currency.USDT)\r\n\r\n// --- 1. INPUT PENGATURAN ---\r\ngrp_main = \"Pengaturan Grid\"\r\n// Jarak antar layer order dalam persen.\r\ngridDistPct = input.float(0.15, \"Jarak Grid (%)\", step=0.01, group=grp_main) \r\n// Target profit untuk menutup posisi rata-rata.\r\ntakeProfitPct = input.float(0.25, \"Target Profit (%)\", step=0.01, group=grp_main) \r\n// Input ini dipertahankan, namun visualisasinya disederhanakan (lihat bagian 4)\r\nmaxLayers = input.int(10, \"Maksimal Layer (Visualisasi Disederhanakan)\", minval=1, maxval=20, group=grp_main) \r\n\r\n// --- 2. LOGIKA ENTRY (2 ARAH) ---\r\n\r\n// Tentukan apakah ini adalah trade awal\r\nisInitialEntry = strategy.position_size == 0\r\n\r\n// Tentukan harga rata-rata acuan: 'close' saat posisi 0, atau 'strategy.position_avg_price' saat posisi ada.\r\nfloat avgPrice = strategy.position_avg_price == 0 ? close : strategy.position_avg_price\r\n\r\n// KONDISI ENTRY LONG (BUY)\r\n// Perhitungan Threshold/Ambang Batas untuk layer baru\r\nlongEntryThreshold = avgPrice * (1 - gridDistPct/100)\r\nbool longEntryCond = isInitialEntry or close < longEntryThreshold\r\n\r\nif longEntryCond\r\n    // Limit order Buy ditempatkan sedikit di bawah harga close untuk mensimulasikan \"Maker\"\r\n    strategy.entry(\"Grid Buy\", strategy.long, qty=12, limit=close * 0.9995, comment=\"ðŸ”µ Buy Layer\")\r\n\r\n\r\n// KONDISI ENTRY SHORT (SELL)\r\n// Perhitungan Threshold/Ambang Batas untuk layer baru\r\nshortEntryThreshold = avgPrice * (1 + gridDistPct/100)\r\nbool shortEntryCond = isInitialEntry or close > shortEntryThreshold\r\n\r\nif shortEntryCond\r\n    // Limit order Sell ditempatkan sedikit di atas harga close\r\n    strategy.entry(\"Grid Sell\", strategy.short, qty=12, limit=close * 1.0005, comment=\"ðŸ”´ Sell Layer\")\r\n\r\n\r\n// --- 3. LOGIKA EXIT (TAKE PROFIT) ---\r\n// Exit untuk Long (Profit Target di atas rata-rata harga beli)\r\nif (strategy.position_size > 0)\r\n    tpLongPrice = strategy.position_avg_price * (1 + takeProfitPct/100)\r\n    strategy.exit(\"TP Long\", \"Grid Buy\", profit=na, limit=tpLongPrice, comment=\"ðŸ’° TP Long\")\r\n\r\n// Exit untuk Short (Profit Target di bawah rata-rata harga jual)\r\nif (strategy.position_size < 0)\r\n    tpShortPrice = strategy.position_avg_price * (1 - takeProfitPct/100)\r\n    strategy.exit(\"TP Short\", \"Grid Sell\", profit=na, limit=tpShortPrice, comment=\"ðŸ’° TP Short\")\r\n\r\n\r\n// --- 4. VISUALISASI GRID (PINESCRIPT V5 COMPLIANT) ---\r\nplotGrid = input.bool(true, \"Tampilkan Level Grid\", group=\"Visualisasi\")\r\n\r\n// 4a. Plot Garis Rata-rata Posisi (Pusat Grid)\r\nfloat avgPricePlot = strategy.position_avg_price != 0 and plotGrid ? strategy.position_avg_price : na\r\nplot(avgPricePlot, color=color.new(color.black, 0), style=plot.style_line, linewidth=2, title=\"Average Entry Price\")\r\n\r\n// 4b. Plot Level Grid Pertama (yang akan dieksekusi berikutnya)\r\nfloat nextLongLevel = avgPrice * (1 - (gridDistPct / 100))\r\nfloat nextShortLevel = avgPrice * (1 + (gridDistPct / 100))\r\n\r\n// Kondisikan nilai yang di-plot (menggunakan 'na' saat kondisi plot tidak terpenuhi)\r\nfloat plotNextLong = plotGrid ? nextLongLevel : na\r\nfloat plotNextShort = plotGrid ? nextShortLevel : na\r\n\r\n// Plotting Next Layers\r\n// NOTE: Fungsi plot() dipanggil dari global scope.\r\nplot(plotNextLong, color=color.new(color.green, 40), style=plot.style_linebr, title=\"Next Buy Layer\") \r\nplot(plotNextShort, color=color.new(color.red, 40), style=plot.style_linebr, title=\"Next Sell Layer\")\r\n\r\n// Visualisasi Background\r\nbgcolor(strategy.position_size > 0 ? color.new(color.green, 95) : strategy.position_size < 0 ? color.new(color.red, 95) : na)"
  },
  {
    "url": "xvYoa3vU-Strategia-S-P-500-vs-US10Y-Yield",
    "name": "Strategia S&P 500 vs US10Y Yield",
    "description": "This strategy explores the macroeconomic relationship between the equity market (S&P 500) and the debt market (10-Year Treasury Yield). Historically, rapid spikes in bond yields often exert downward pressure on equity valuations, leading to corrections or bear markets.\n\nThe goal of this strategy is capital preservation. It attempts to switch to cash when yields are rising too aggressively and re-enter the stock market when the bond market stabilizes.",
    "image_url": "xvYoa3vU",
    "author": "adamniestoj",
    "likes": 6,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=5\nstrategy(\"Strategia S&P 500 vs US10Y Yield\", overlay=true, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=100)\n\n// --- USTAWIENIA ---\n// Symbol rentownoÅ›ci obligacji (Treasury Yield 10Y)\nyieldSymbol = input.symbol(\"US10Y\", \"Symbol RentownoÅ›ci (Yield)\")\n// Okres dla zakresu (range) - z obrazka wynika, Å¼e to 63 dni (ok. 3 miesiÄ…ce handlowe)\nlookbackPeriod = input.int(63, \"Okres zakresu (dni)\", minval=1)\n// PrÃ³g procentowy (80% zakresu)\nthresholdPercent = input.float(0.80, \"PrÃ³g zakresu (0.80 = 80%)\", step=0.01)\n\n// --- POBIERANIE DANYCH ---\n// Pobieramy zamkniÄ™cia rentownoÅ›ci 10-letniej. UÅ¼ywamy request.security, aby mieÄ‡ dane niezaleÅ¼nie od wykresu, na ktÃ³rym jesteÅ›my.\nyieldClose = request.security(yieldSymbol, \"D\", close)\n\n// --- OBLICZENIA WSKAÅ¹NIKA (Yield % of Range) ---\n// Obliczamy najwyÅ¼szy i najniÅ¼szy poziom rentownoÅ›ci w oknie 63 dni\nyieldHigh = ta.highest(yieldClose, lookbackPeriod)\nyieldLow  = ta.lowest(yieldClose, lookbackPeriod)\n\n// Obliczamy pozycjÄ™ obecnej rentownoÅ›ci w tym zakresie (Stochastic formula)\n// WzÃ³r: (Obecna cena - Minimum) / (Maksimum - Minimum)\nyieldPosition = (yieldClose - yieldLow) / (yieldHigh - yieldLow)\n\n// --- LOGIKA STRATEGII ---\n// Warunek \"Risk Off\" (Ucieczka do gotÃ³wki): JeÅ›li Yield jest powyÅ¼ej 80% zakresu\nisRiskOff = yieldPosition > thresholdPercent\n\n// Warunek \"Risk On\" (Kupno akcji): JeÅ›li Yield jest poniÅ¼ej lub rÃ³wny 80% zakresu\nisRiskOn = not isRiskOff\n\n// --- WYKONYWANIE ZLECEÅƒ ---\nif (isRiskOn)\n    // JeÅ›li jest bezpiecznie, wchodzimy w pozycjÄ™ dÅ‚ugÄ… (lub jÄ… utrzymujemy)\n    strategy.entry(\"Long SP500\", strategy.long, comment=\"Kupno\")\nelse\n    // JeÅ›li rentownoÅ›Ä‡ roÅ›nie gwaÅ‚townie (Risk Off), zamykamy pozycjÄ™ (przechodzimy w gotÃ³wkÄ™)\n    strategy.close(\"Long SP500\", comment=\"GotÃ³wka\")\n\n// --- WIZUALIZACJA (Opcjonalna) ---\n// Kolor tÅ‚a, Å¼eby widzieÄ‡ kiedy strategia jest poza rynkiem\nbgcolor(isRiskOff ? color.new(color.red, 90) : na, title=\"Okresy w gotÃ³wce\")\n\n// MoÅ¼esz dodaÄ‡ plotowanie wskaÅºnika w osobnym oknie, jeÅ›li zmienisz overlay=false\n// plot(yieldPosition, title=\"Yield Position\", color=color.red)\n// hline(thresholdPercent, title=\"PrÃ³g 80%\", color=color.gray, linestyle=hline.style_dashed)"
  },
  {
    "url": "yn4Tqapn-N1E-UTBOAT",
    "name": "N1E_UTBOAT",
    "description": "N1E_UTBOAT\n\nATR trailing stop\n\nOptional Heikin Ashi source\n\nBuy/Sell signals based on a crossover of price vs ATR trailing stop\n\nStrategy long/short entries",
    "image_url": "yn4Tqapn",
    "author": "swma4444",
    "likes": 9,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "\r\n//@version=5\r\nstrategy(\"UT Bot Strategy (v5) â€” HeikinAshi fix\", overlay=true)\r\n\r\n// Inputs\r\na = input.float(1.0, title = \"Key Value (Sensitivity)\")\r\nc = input.int(10, title = \"ATR Period\")\r\nuseHA = input.bool(false, title = \"Use Heikin Ashi Source\")\r\n\r\n// --- Heikin Ashi (computed locally) ---\r\nha_close = (open + high + low + close) / 4.0\r\nha_open  = float(na)\r\nha_open  := nz(ha_open[1], (open + close) / 2.0)   // initialize from first bar\r\nha_open  := (ha_open + ha_close[1]) / 2.0\r\nha_high  = math.max(high, math.max(ha_open, ha_close))\r\nha_low   = math.min(low,  math.min(ha_open, ha_close))\r\n\r\nsrc = useHA ? ha_close : close\r\n\r\n// ATR & trailing stop\r\nxATR  = ta.atr(c)\r\nnLoss = a * xATR\r\n\r\nvar float xStop = na\r\nxStop := if src > nz(xStop[1], 0) and src[1] > nz(xStop[1], 0)\r\n    math.max(nz(xStop[1]), src - nLoss)\r\nelse if src < nz(xStop[1], 0) and src[1] < nz(xStop[1], 0)\r\n    math.min(nz(xStop[1]), src + nLoss)\r\nelse\r\n    src > nz(xStop[1], 0) ? src - nLoss : src + nLoss\r\n\r\n// Position detection (not strictly required but kept from original)\r\nvar int pos = 0\r\npos := src[1] < nz(xStop[1]) and src > nz(xStop[1]) ? 1 :\r\n       src[1] > nz(xStop[1]) and src < nz(xStop[1]) ? -1 : nz(pos[1], 0)\r\n\r\n// Signal logic\r\nema1 = ta.ema(src, 1)\r\nabove = ta.crossover(ema1, xStop)\r\nbelow = ta.crossover(xStop, ema1)\r\n\r\nbuy  = src > xStop and above\r\nsell = src < xStop and below\r\n\r\n// Plotting / visuals\r\nplot(xStop, title=\"ATR Trailing Stop\", linewidth=2, style=plot.style_line)\r\nplotshape(buy,  title=\"Buy\",  text=\"Buy\",  style=shape.labelup,   location=location.belowbar, color=color.green, textcolor=color.white, size=size.tiny)\r\nplotshape(sell, title=\"Sell\", text=\"Sell\", style=shape.labeldown, location=location.abovebar, color=color.red,   textcolor=color.white, size=size.tiny)\r\nbarcolor(src > xStop ? color.new(color.green, 0) : src < xStop ? color.new(color.red, 0) : na)\r\n\r\n// Entries\r\nstrategy.entry(\"Long\",  strategy.long,  when = buy)\r\nstrategy.entry(\"Short\", strategy.short, when = sell)"
  },
  {
    "url": "u5Iy0SMM-Multi-MA-RSI-Pullback-Strategy-Jordan",
    "name": "Multi-MA + RSI Pullback Strategy (Jordan)",
    "description": "1ï¸âƒ£ Strategy logic Iâ€™ll code\n\nFrom your screenshots:\n\nIndicators\n\tâ€¢\tEMAs: 600 / 200 / 100 / 50\n\tâ€¢\tRSI: length 6, levels 80 / 20\n\nRules (simplified so a script can handle them):\n\tâ€¢\tUse a higher-timeframe trend filter (15m or 1h) using the EMAs.\n\tâ€¢\tTake entries on the chart timeframe (you can use 1m or 5m).\n\tâ€¢\tLong:\n\tâ€¢\tHigher-TF trend is up.\n\tâ€¢\tPrice is pulling back into a zone (between 50 EMA and 100 EMA on the entry timeframe â€“ this approximates your 50â€“61% retrace).\n\tâ€¢\tRSI crosses below 20 (oversold).\n\tâ€¢\tShort:\n\tâ€¢\tHigher-TF trend is down.\n\tâ€¢\tPrice pulls back between 50 & 100 EMAs.\n\tâ€¢\tRSI crosses above 80 (overbought).\n\tâ€¢\tExits: ATR-based stop + take-profit with adjustable R:R (2:1 or 3:1).\n\tâ€¢\tMax 4 trades per day.\n\nNews filter & â€œonly trade goldâ€ you handle manually (run it on XAUUSD and avoid news times yourself â€“ TradingView canâ€™t read the economic calendar from code).\n",
    "image_url": "u5Iy0SMM",
    "author": "jordana4r79",
    "likes": 1,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=5\nstrategy(\"Multi-MA + RSI Pullback Strategy\", overlay=true, margin_long=100, margin_short=100)\n\n// === INPUTS ===\nema50 = ta.ema(close, 50)\nema100 = ta.ema(close, 100)\nema200 = ta.ema(close, 200)\nema600 = ta.ema(close, 600)\nrsiPeriod = input.int(6, \"RSI Period\")\nrsiOB = input.int(80, \"RSI Overbought\")\nrsiOS = input.int(20, \"RSI Oversold\")\nrsi = ta.rsi(close, rsiPeriod)\n\n// === TREND DIRECTION ===\nisBull = ema50 > ema100 and ema100 > ema200 and ema200 > ema600\nisBear = ema50 < ema100 and ema100 < ema200 and ema200 < ema600\n\n// === ENTRY CONDITIONS ===\nlongCond = isBull and ta.crossunder(rsi, rsiOS)\nshortCond = isBear and ta.crossover(rsi, rsiOB)\n\n// === STRATEGY EXECUTION ===\nif (longCond)\n    strategy.entry(\"Long\", strategy.long)\n\nif (shortCond)\n    strategy.entry(\"Short\", strategy.short)\n\n// === EXIT CONDITIONS ===\nrr = input.float(2.0, \"Risk/Reward Ratio\", step=0.1)\nstopATR = ta.atr(14)\nif strategy.position_size > 0\n    strategy.exit(\"Long Exit\", \"Long\", stop=close - stopATR, limit=close + stopATR * rr)\nif strategy.position_size < 0\n    strategy.exit(\"Short Exit\", \"Short\", stop=close + stopATR, limit=close - stopATR * rr)\n\n// === PLOTTING ===\nplot(ema50, color=color.red)\nplot(ema100, color=color.yellow)\nplot(ema200, color=color.green)\nplot(ema600, color=color.blue)\nplot(rsi, title=\"RSI\", color=color.new(color.white, 0), display=display.none)"
  },
  {
    "url": "L9Uyla3a-Strategia-S-P-500-vs-US10Y-Yield-od-2000",
    "name": "Strategia S&P 500 vs US10Y Yield (od 2000)",
    "description": "This strategy explores the macroeconomic relationship between the equity market (S&P 500) and the debt market (10-Year Treasury Yield). Historically, rapid spikes in bond yields often exert downward pressure on equity valuations, leading to corrections or bear markets.\n\nThe goal of this strategy is capital preservation. It attempts to switch to cash when yields are rising too aggressively and re-enter the stock market when the bond market stabilizes.",
    "image_url": "L9Uyla3a",
    "author": "adamniestoj",
    "likes": 2,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=5\nstrategy(\"Strategia S&P 500 vs US10Y Yield (od 2000)\", overlay=true, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=100)\n\n// --- USTAWIENIA ---\nyieldSymbol = input.symbol(\"TVC:US10Y\", \"Symbol RentownoÅ›ci (Yield)\") \nlookbackPeriod = input.int(63, \"Okres zakresu (dni)\", minval=1)\nthresholdPercent = input.float(0.80, \"PrÃ³g zakresu (0.80 = 80%)\", step=0.01)\n\n// NOWE: Ustawienie daty startowej\nstartYear = input.int(2000, \"Rok poczÄ…tkowy backtestu\", minval=1900)\n\n// --- POBIERANIE DANYCH ---\n// Zabezpieczenie: gaps=barmerge.gaps_off uzupeÅ‚nia luki w danych\nyieldClose = request.security(yieldSymbol, \"D\", close, gaps=barmerge.gaps_off)\n\n// --- DIAGNOSTYKA (DEBUG) ---\nplotchar(na(yieldClose), \"Brak Danych\", \"âŒ\", location.top, color.red, size=size.tiny, text=\"Brak danych US10Y!\")\n\n// --- OBLICZENIA WSKAÅ¹NIKA ---\nvalidData = not na(yieldClose)\n\nyieldHigh = ta.highest(yieldClose, lookbackPeriod)\nyieldLow  = ta.lowest(yieldClose, lookbackPeriod)\n\nrangeDiff = yieldHigh - yieldLow\nyieldPosition = (rangeDiff > 0) ? (yieldClose - yieldLow) / rangeDiff : 0.5\n\n// --- LOGIKA STRATEGII ---\nisRiskOff = validData and (yieldPosition > thresholdPercent)\nisRiskOn = validData and (yieldPosition <= thresholdPercent)\n\n// --- FILTR CZASOWY ---\n// Tworzymy znacznik czasu dla 1 stycznia wybranego roku\nstartTime = timestamp(startYear, 1, 1, 0, 0)\n// Sprawdzamy, czy obecna Å›wieczka jest po tej dacie\ninDateRange = time >= startTime\n\n// --- WYKONYWANIE ZLECEÅƒ ---\n// Dodano warunek \"and inDateRange\"\nif (bar_index > lookbackPeriod and inDateRange)\n    if (isRiskOn)\n        strategy.entry(\"Long SP500\", strategy.long, comment=\"Kupno\")\n    \n    if (isRiskOff)\n        strategy.close(\"Long SP500\", comment=\"GotÃ³wka\")\n\n// --- WIZUALIZACJA ---\n// TÅ‚o rysuje siÄ™ tylko w wybranym zakresie dat\nbgcolor(isRiskOff and inDateRange ? color.new(color.red, 85) : na, title=\"Cash Mode\")"
  },
  {
    "url": "eZGgOsDY",
    "name": "2 Dip/Tepe + Destek/DirenÃ§ + Tek Sinyal Stratejisi",
    "description": "â­ A Brief Summary of What the Strategy Does\nðŸŽ¯ 1) Market analysis is being released (bottom-top analysis)\n\nIt automatically finds pivot bottoms and pivot tops on the strategic chart. Then:\n\nIf the bottoms are rising (HL â€“ High Low): the trend is upward\n\nIf the tops are falling (LH â€“ Lower High): the trend is downward\n\nit interprets this.\n\nðŸŽ¯ 2) Support and resistance lines are formed\n\nLast pivot top = resistance line\n\nLast pivot bottom = support line\n\nThese lines are automatically drawn on the chart.\n\nðŸŽ¯ 3) Breakout is expected according to the trend structure\nFor LONG:\n\nThe last two bottoms will be rising bottoms\n\nThe price will rise above the last resistance line\n\nThis gives a single LONG signal.\n\nFor SHORT:\n\nThe last two peaks will be falling peaks\n\nThe price will fall below the support line\n\nThis gives a single SHORT signal.",
    "image_url": "eZGgOsDY",
    "author": "hayrialbayir",
    "likes": 8,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=5\nstrategy(\"2 Dip/Tepe + Destek/DirenÃ§ + Tek Sinyal Stratejisi\", overlay=true, margin_long=100, margin_short=100, initial_capital=100000)\n\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n// Pivot AyarlarÄ±\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\nleft  = input.int(5, \"Sol Pivot\")\nright = input.int(5, \"SaÄŸ Pivot\")\n\npivotLow  = ta.pivotlow(low, left, right)\npivotHigh = ta.pivothigh(high, left, right)\n\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n// Son iki dip (HL iÃ§in) ve son iki tepe (LH iÃ§in)\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\nvar float lastLow1  = na\nvar float lastLow2  = na\nvar float lastHigh1 = na\nvar float lastHigh2 = na\n\nif not na(pivotLow)\n    lastLow2 := lastLow1\n    lastLow1 := pivotLow\n\nif not na(pivotHigh)\n    lastHigh2 := lastHigh1\n    lastHigh1 := pivotHigh\n\n// KoÅŸullarÄ±n var olmasÄ±\nvalidLows  = not na(lastLow1)  and not na(lastLow2)\nvalidHighs = not na(lastHigh1) and not na(lastHigh2)\n\n// YÃ¼kselen Dip (HL) â†’ LONG setup\nisHL = validLows and lastLow1 > lastLow2\n\n// AlÃ§alan Tepe (LH) â†’ SHORT setup\nisLH = validHighs and lastHigh1 < lastHigh2\n\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n// Destek & DirenÃ§ Ã§izgileri\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\nvar float resistance = na\nvar float support    = na\n\nif not na(pivotHigh)\n    resistance := pivotHigh\n\nif not na(pivotLow)\n    support := pivotLow\n\nplot(resistance, \"DirenÃ§\", color=color.red, linewidth=2)\nplot(support, \"Destek\", color=color.green, linewidth=2)\n\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n// SINYAL TEKRARLAMASINI ENGELLEME\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\nvar bool longTriggered  = false\nvar bool shortTriggered = false\n\n// LONG sinyali mantÄ±ÄŸÄ±\nlongSignal = isHL and not na(resistance) and close > resistance and not longTriggered\n\n// SHORT sinyali mantÄ±ÄŸÄ±\nshortSignal = isLH and not na(support) and close < support and not shortTriggered\n\n// Sinyal geldiÄŸinde sadece 1 kez tetikle\nif longSignal\n    strategy.entry(\"LONG\", strategy.long)\n    longTriggered := true\n    shortTriggered := false   // yÃ¶n deÄŸiÅŸince reset\n\nif shortSignal\n    strategy.entry(\"SHORT\", strategy.short)\n    shortTriggered := true\n    longTriggered := false    // yÃ¶n deÄŸiÅŸince reset\n\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n// Opsiyonel Stop-Loss / Take-Profit\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\nslPct = input.float(3.0, \"Stop-Loss %\", step=0.1)\ntpPct = input.float(6.0, \"Take-Profit %\", step=0.1)\n\nif strategy.position_size > 0\n    strategy.exit(\"Exit Long\", from_entry=\"LONG\", stop = strategy.position_avg_price * (1 - slPct/100), limit = strategy.position_avg_price * (1 + tpPct/100))\n\nif strategy.position_size < 0\n    strategy.exit(\"Exit Short\", from_entry=\"SHORT\", stop = strategy.position_avg_price * (1 + slPct/100), limit = strategy.position_avg_price * (1 - tpPct/100))\n\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n// GÃ¶rsel iÅŸaretler\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\nplotshape(longSignal,  title=\"Long Sinyal\",  color=color.green, style=shape.labelup,   text=\"LONG\")\nplotshape(shortSignal, title=\"Short Sinyal\", color=color.red,   style=shape.labeldown, text=\"SHORT\")\n\n"
  },
  {
    "url": "SYuloc1g-Keltner-Channels-Strategy-New",
    "name": "Keltner Channels Strategy New",
    "description": "The strategy is chenging the same as an original copy, but this one is for tests, so I will publish it and check results",
    "image_url": "SYuloc1g",
    "author": "agodovanik",
    "likes": 3,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=6\nstrategy(title=\"Keltner Channels Strategy\", overlay=true)\nlength = input.int(20, minval=1)\nmult = input.float(2.0, \"Multiplier\")\nsrc = input(close, title=\"Source\")\nexp = input(true, \"Use Exponential MA\", display = display.data_window)\nBandsStyle = input.string(\"Average True Range\", options = [\"Average True Range\", \"True Range\", \"Range\"], title=\"Bands Style\", display = display.data_window)\natrlength = input(10, \"ATR Length\", display = display.data_window)\nesma(source, length)=>\n\ts = ta.sma(source, length)\n\te = ta.ema(source, length)\n\texp ? e : s\nma = esma(src, length)\nrangema = BandsStyle == \"True Range\" ? ta.tr(true) : BandsStyle == \"Average True Range\" ? ta.atr(atrlength) : ta.rma(high - low, length)\nupper = ma + rangema * mult\nlower = ma - rangema * mult\ncrossUpper = ta.crossover(src, upper)\ncrossLower = ta.crossunder(src, lower)\nbprice = 0.0\nbprice := crossUpper ? high+syminfo.mintick : nz(bprice[1])\nsprice = 0.0\nsprice := crossLower ? low -syminfo.mintick : nz(sprice[1])\ncrossBcond = false\ncrossBcond := crossUpper ? true : crossBcond[1]\ncrossScond = false\ncrossScond := crossLower ? true : crossScond[1]\ncancelBcond = crossBcond and (src < ma or high >= bprice )\ncancelScond = crossScond and (src > ma or low <= sprice )\nif (cancelBcond)\n\tstrategy.cancel(\"KltChLE\")\nif (crossUpper)\n\tstrategy.entry(\"KltChLE\", strategy.long, stop=bprice, comment=\"KltChLE\")\nif (cancelScond)\n\tstrategy.cancel(\"KltChSE\")\nif (crossLower)\n\tstrategy.entry(\"KltChSE\", strategy.short, stop=sprice, comment=\"KltChSE\")"
  },
  {
    "url": "xTnfnVLA-SM-021-Gaussian-Trend-System-Optimized",
    "name": "[SM-021] Gaussian Trend System [Optimized]",
    "description": "This script is a comprehensive trend-following strategy centered around a Gaussian Channel. It is designed to capture significant market movements while filtering out noise during consolidation phases. This version (v2) introduces code optimizations using Pine Script v6 Arrays and a new Intraday Time Control feature.\n\n 1. Core Methodology & Math\n The foundation of this strategy is the Gaussian Filter, originally conceptualized by @DonovanWall.\nGaussian Poles: Unlike standard moving averages (SMA/EMA), this filter uses \"poles\" (referencing signal processing logic) to reduce lag while maintaining smoothness.\nArray Optimization: In this specific iteration, the f_pole function has been refactored to utilize Pine Script Arrays. This improves calculation efficiency and rendering speed compared to recursive variable calls, especially when calculating deep historical data.\nChannel Logic: The strategy calculates a \"Filtered True Range\" to create High and Low bands around the main Gaussian line.\nLong Entry: Price closes above the High Band.\nShort Entry: Price closes below the Low Band.\n\n 2. Signal Filtering (Confluence)\n To reduce false signals common in trend-following systems, the strategy employs a \"confluence\" approach using three additional layers:\nBaseline Filter: A 200-period (customizable) EMA or SMA acts as a regime filter. Longs are only taken above the baseline; Shorts only below.\nADX Filter (Volatility): The Average Directional Index (ADX) is used to measure trend strength. If the ADX is below a user-defined threshold (default: 20), the market is considered \"choppy,\" and new entries are blocked.\nMomentum Check: A Stochastic RSI check ensures that momentum aligns with the breakout direction.\n\n 3. NEW: Intraday Session Filter\n Per user requests, a time-based filter has been added to restrict trading activity to specific market sessions (e.g., the New York Open).\nHow it works: Users can toggle a checkbox to enable/disable the filter.\nConfiguration: You can define a specific time range (Default: 09:30 - 16:00) and a specific Timezone (Default: New York).\nLogic: The strategy longCondition and shortCondition now check if the current bar's timestamp falls within this window. If outside the window, no new entries are generated, though existing trades are managed normally.\n\n 4. Risk Management\n The strategy relies on volatility-based exits rather than fixed percentage stops:\nATR Stop Loss: A multiple of the Average True Range (ATR) is calculated at the moment of entry to set a dynamic Stop Loss.\nATR Take Profit: An optional Reward-to-Risk (RR) ratio can be set to place a Take Profit target relative to the Stop Loss distance.\nBand Exit: If the trend reverses and price crosses the opposite band, the trade is closed immediately to prevent large drawdowns.\n\n Credits & Attribution\n Original Gaussian Logic: Developed by @DonovanWalll. This script utilizes his mathematical formula for the pole filters.\nStrategy Wrapper & Array Refactor: Developed by @sebamarghella.\nCommunity Request: The Intraday Session Filter was added to assist traders focusing on specific liquidity windows.\n\n Disclaimer: This strategy is for educational purposes. Past performance is not indicative of future results. Please use the settings menu to adjust the Session Time and Risk parameters to fit your specific asset class.",
    "image_url": "xTnfnVLA",
    "author": "sebamarghella",
    "likes": 0,
    "type": "strategy",
    "created": "2025-12-12",
    "updated": "2025-12-12",
    "source": "// This Pine Scriptâ„¢ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// Â© sebamarghella\r\n\r\n//CREDITS:\r\n// The core Gaussian Filter logic is based on the work by @DonovanWall. \r\n// I have refactored the original 'f_pole' function to use Pine Script v5/v6 Arrays for improved performance and calculation speed.\r\n// This strategy wraps that engine in a complete Risk Management system including ATR Stops, ADX volatility filtering, and Multi-Timeframe alignment.\r\n\r\n//@version=6\r\nstrategy(title=\"[SM-021-v2] Gaussian Trend System [Optimized]\", overlay=true, calc_on_every_tick=false, initial_capital=1000, default_qty_type=strategy.percent_of_equity, default_qty_value=10, commission_type=strategy.commission.percent, commission_value=0.1, slippage=3)\r\n\r\n//-----------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n// Trading Direction Toggles\r\n//-----------------------------------------------------------------------------------------------------------------------------------------------------------------\r\nallowLongs = input.bool(true, \"Enable Long Trading\", group=\"Trading Direction\")\r\nallowShorts = input.bool(true, \"Enable Short Trading\", group=\"Trading Direction\")\r\n\r\n//-----------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n// Date condition inputs\r\n//-----------------------------------------------------------------------------------------------------------------------------------------------------------------\r\nstartDate = input.time(timestamp(\"1 January 2018 00:00 +0000\"), \"Start Date\", group=\"Main Algo Settings\")\r\nendDate = input.time(timestamp(\"31 Dec 2069 23:59 +0000\"), \"End Date\", group=\"Main Algo Settings\")\r\ntimeCondition = time >= startDate and time <= endDate\r\n\r\n//-----------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n// NEW: Intraday Session Filter (9:30AM - 4:00PM NY)\r\n//-----------------------------------------------------------------------------------------------------------------------------------------------------------------\r\nuseSessionFilter = input.bool(true, \"Use Session Filter\", group=\"Intraday Session Filter\")\r\nsessionTime      = input.session(\"0930-1600\", \"Session Time\", group=\"Intraday Session Filter\", tooltip=\"Format: HHMM-HHMM\")\r\nsessionZone      = input.string(\"America/New_York\", \"Timezone\", group=\"Intraday Session Filter\")\r\n\r\n// Logic to check if current bar is inside the session\r\ninSession = not useSessionFilter or not na(time(timeframe.period, sessionTime, sessionZone))\r\n\r\n//-----------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n// Filter 1: Baseline (Trend Regime)\r\n//-----------------------------------------------------------------------------------------------------------------------------------------------------------------\r\nuseBaseline = input.bool(true, \"Use Baseline Filter\", group=\"Filter 1: Baseline\")\r\nbaselineLen = input.int(200, \"Baseline Length\", group=\"Filter 1: Baseline\")\r\nbaselineType = input.string(\"EMA\", \"Baseline Type\", options=[\"EMA\", \"SMA\"], group=\"Filter 1: Baseline\")\r\n\r\nfloat baseline = switch baselineType\r\n    \"EMA\" => ta.ema(close, baselineLen)\r\n    \"SMA\" => ta.sma(close, baselineLen)\r\n    => na\r\n\r\nbaselineCondition = not useBaseline or close > baseline\r\nplot(useBaseline ? baseline : na, color=color.white, title=\"Baseline Filter\")\r\n\r\n//-----------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n// Filter 2: ADX (Chop Filter)\r\n//-----------------------------------------------------------------------------------------------------------------------------------------------------------------\r\nuseAdx = input.bool(false, \"Use ADX Filter\", group=\"Filter 2: ADX\")\r\nadxLen = input.int(14, \"ADX Length\", group=\"Filter 2: ADX\")\r\nadxThresh = input.int(20, \"ADX Threshold\", group=\"Filter 2: ADX\")\r\n\r\n[diplus, diminus, adxValue] = ta.dmi(adxLen, adxLen)\r\nadxCondition = not useAdx or adxValue > adxThresh\r\n\r\n//-----------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n// Filter 3: HTF Trend\r\n//-----------------------------------------------------------------------------------------------------------------------------------------------------------------\r\nuseHtfFilter = input.bool(false, \"Use Higher Timeframe Filter\", group=\"Filter 3: HTF Trend\")\r\nhtfTimeframe = input.timeframe(\"D\", \"Higher Timeframe\", group=\"Filter 3: HTF Trend\")\r\nemaFastLen   = input.int(13, \"HTF Fast EMA\", group=\"Filter 3: HTF Trend\")\r\nemaSlowLen   = input.int(25, \"HTF Slow EMA\", group=\"Filter 3: HTF Trend\")\r\n\r\nhtfFastEma = request.security(syminfo.tickerid, htfTimeframe, ta.ema(close, emaFastLen))\r\nhtfSlowEma = request.security(syminfo.tickerid, htfTimeframe, ta.ema(close, emaSlowLen))\r\n\r\nhtfUptrend   = htfFastEma > htfSlowEma\r\nhtfDowntrend = htfFastEma < htfSlowEma\r\nhtfLongCond  = not useHtfFilter or htfUptrend\r\nhtfShortCond = not useHtfFilter or htfDowntrend\r\n\r\n//-----------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n// Risk Management (ATR Stops & Targets)\r\n//-----------------------------------------------------------------------------------------------------------------------------------------------------------------\r\nuseAtrStop   = input.bool(true, \"Use ATR Stop Loss\", group=\"Risk Management\")\r\nuseAtrTarget = input.bool(false, \"Use ATR Take Profit\", group=\"Risk Management\")\r\natrLength    = input.int(14, \"ATR Length\", group=\"Risk Management\")\r\natrMult      = input.float(2.0, \"ATR Stop Multiplier\", step=0.1, group=\"Risk Management\")\r\nrrRatio      = input.float(3.0, \"Reward to Risk Ratio\", step=0.1, group=\"Risk Management\") \r\n\r\natrVal = ta.atr(atrLength)\r\n\r\n//-----------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n// Gaussian Channel Indicator - courtesy of @DonovanWall (Optimized)\r\n//-----------------------------------------------------------------------------------------------------------------------------------------------------------------\r\nsrc = input(defval=hl2, title=\"Source\", group=\"Gaussian Settings\")\r\nN = input.int(defval=8, title=\"Poles\", minval=1, maxval=9, group=\"Gaussian Settings\")\r\nper = input.int(defval=300, title=\"Sampling Period\", minval=2, group=\"Gaussian Settings\")\r\nmult = input.float(defval=0, title=\"Filtered True Range Multiplier\", minval=0, group=\"Gaussian Settings\")\r\nmodeLag  = input.bool(defval=false, title=\"Reduced Lag Mode\", group=\"Gaussian Settings\")\r\nmodeFast = input.bool(defval=false, title=\"Fast Response Mode\", group=\"Gaussian Settings\")\r\n\r\n// --- NEW OPTIMIZED FUNCTION START ---\r\nf_pole(_a, _s, _i) =>\r\n    var arr = array.new<float>(9, 0.0)\r\n    float _fn = nz(_s)\r\n    float _f1 = na\r\n    int _len = math.max(1, math.min(int(_i), 9))\r\n    for i = 0 to _len - 1\r\n        float prev_val = array.get(arr, i)\r\n        _fn := _a * _fn + (1 - _a) * prev_val\r\n        if i == 0\r\n            _f1 := _fn\r\n        array.set(arr, i, _fn)\r\n    [_fn, _f1]\r\n\r\n// --- NEW OPTIMIZED FUNCTION END ---\r\n\r\nbeta  = (1 - math.cos(4*math.asin(1)/per)) / (math.pow(1.414, 2/N) - 1)\r\nalpha = -beta + math.sqrt(math.pow(beta, 2) + 2*beta)\r\nlag = (per - 1)/(2*N)\r\nsrcdata = modeLag ? src + (src - src[lag]) : src\r\ntrdata  = modeLag ? ta.tr(true) + (ta.tr(true) - ta.tr(true)[lag]) : ta.tr(true)\r\n\r\n[filtn, filt1]     = f_pole(alpha, srcdata, N)\r\n[filtntr, filt1tr] = f_pole(alpha, trdata,  N)\r\n\r\nfilt   = modeFast ? (filtn + filt1)/2 : filtn\r\nfilttr = modeFast ? (filtntr + filt1tr)/2 : filtntr\r\nhband = filt + filttr*mult\r\nlband = filt - filttr*mult\r\nfcolor   = filt > filt[1] ? #0aff68 : filt < filt[1] ? #ff0a5a : #cccccc\r\nbarcolor = (src > src[1]) and (src > filt) and (src < hband) ? #0aff68 : \r\n           (src > src[1]) and (src >= hband) ? #0aff1b : \r\n           (src <= src[1]) and (src > filt) ? #00752d : \r\n           (src < src[1]) and (src < filt) and (src > lband) ? #ff0a5a : \r\n           (src < src[1]) and (src <= lband) ? #ff0a11 : \r\n           (src >= src[1]) and (src < filt) ? #990032 : #cccccc\r\n\r\nfiltplot = plot(filt, title=\"Filter\", color=fcolor, linewidth=3)\r\nhbandplot = plot(hband, title=\"Filtered True Range High Band\", color=fcolor)\r\nlbandplot = plot(lband, title=\"Filtered True Range Low Band\", color=fcolor)\r\nfill(hbandplot, lbandplot, title=\"Channel Fill\", color=color.new(fcolor, 80))\r\nbarcolor(barcolor)\r\n\r\n//-----------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n// Stoch RSI\r\n//-----------------------------------------------------------------------------------------------------------------------------------------------------------------\r\nstochSmoothK = input.int(2, \"Stoch RSI K\", minval=1, group=\"Stoch RSI\")\r\nstochSmoothD = input.int(2, \"Stoch RSI D\", minval=1, group=\"Stoch RSI\")\r\nstochLengthRSI = input.int(14, \"Stoch RSI RSI Length\", minval=1, group=\"Stoch RSI\")\r\nstochLengthStoch = input.int(100, \"Stoch RSI Stochastic Length\", minval=1, group=\"Stoch RSI\")\r\nstochSrc = input(close, title=\"Stoch RSI Source\", group=\"Stoch RSI\")\r\n\r\nstochRSI = ta.rsi(stochSrc, stochLengthRSI)\r\nk = ta.sma(ta.stoch(stochRSI, stochRSI, stochRSI, stochLengthStoch), stochSmoothK)\r\nd = ta.sma(k, stochSmoothD)\r\n\r\n//-----------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n// Trading Logic\r\n//-----------------------------------------------------------------------------------------------------------------------------------------------------------------\r\ngaussianGreen = filt > filt[1]\r\ngaussianRed = filt < filt[1]\r\n\r\n// Added \"inSession\" to conditions\r\nlongCondition = allowLongs and gaussianGreen and close > hband and (k > 80 or k < 20) and baselineCondition and adxCondition and htfLongCond and timeCondition and inSession\r\ncloseLongCondition = ta.crossunder(close, hband) and timeCondition\r\n\r\n// Added \"inSession\" to conditions\r\nshortCondition = allowShorts and gaussianRed and close < lband and (k > 80 or k < 20) and htfShortCond and timeCondition and inSession\r\ncloseShortCondition = ta.crossover(close, lband) and timeCondition\r\n\r\n//-----------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n// Execution Logic\r\n//-----------------------------------------------------------------------------------------------------------------------------------------------------------------\r\n\r\nif longCondition\r\n    strategy.entry(\"Long\", strategy.long)\r\n    float slPrice = close - (atrVal * atrMult)\r\n    float tpPrice = close + (atrVal * atrMult * rrRatio)\r\n    \r\n    if useAtrStop and useAtrTarget\r\n        strategy.exit(\"Risk Exit Long\", \"Long\", stop=slPrice, limit=tpPrice)\r\n    else if useAtrStop\r\n        strategy.exit(\"SL Exit Long\", \"Long\", stop=slPrice)\r\n    else if useAtrTarget\r\n        strategy.exit(\"TP Exit Long\", \"Long\", limit=tpPrice)\r\n\r\nif closeLongCondition\r\n    strategy.close(\"Long\", comment=\"Band Exit\")\r\n\r\nif shortCondition\r\n    strategy.entry(\"Short\", strategy.short)\r\n    float slPriceShort = close + (atrVal * atrMult)\r\n    float tpPriceShort = close - (atrVal * atrMult * rrRatio)\r\n    \r\n    if useAtrStop and useAtrTarget\r\n        strategy.exit(\"Risk Exit Short\", \"Short\", stop=slPriceShort, limit=tpPriceShort)\r\n    else if useAtrStop\r\n        strategy.exit(\"SL Exit Short\", \"Short\", stop=slPriceShort)\r\n    else if useAtrTarget\r\n        strategy.exit(\"TP Exit Short\", \"Short\", limit=tpPriceShort)\r\n\r\nif closeShortCondition\r\n    strategy.close(\"Short\", comment=\"Band Exit\")"
  },
  {
    "url": "z9MwNqWe-Trend-Vector-Pro-v2-0",
    "name": "Trend Vector Pro v2.0",
    "description": "Title: Trend Vector Pro v2.0 \n ðŸ‘¨â€ðŸ’» Developed by: Mohammed Bedaiwi \n\n ðŸ’¡ Strategy Overview & Coherence \n\n Trend Vector Pro (TVPro)  is a momentum-based trend & reversal strategy that uses a custom smoothed oscillator, an optional ADX filter, and classic Pivot Points to create a single, coherent trading framework.\n\n Instead of stacking random indicators, TVPro is built around these integrated components: \n \n  A custom momentum engine (signal generation)\n  An optional ADX filter (trend quality control)\n  Daily Pivot Points (context, targets & S/R)\n  Swing-based â€œGolden Barâ€ trailing stops (trade management)\n  Optional extended bar detection (overextension alerts)\n \nAll parts are designed to work together and are documented below to address originality & usefulness requirements.\n\n ðŸ” Core Components & Justification \n\n 1. Custom Momentum Engine (Main Signal Source) \nTVProâ€™s engine is a custom oscillator derived from the bar midpoint ( hl2 ), similar in spirit to the Awesome Oscillator but adapted and fully integrated into the strategy. It measures velocity and acceleration of price, letting the script distinguish between strong impulses, weakening trends, and pure noise.\n\n 2. ADX Filter (Trend Strength Validation â€“ Optional) \nUses Average Directional Index (ADX) as a gatekeeper.\n Why this matters:  This prevents the strategy from firing signals in choppy, non-trending environments (when ADX is below the threshold) and keeps trades focused on periods of clear directional strength.\n\n 3. Classic Pivot Points (Context & Targets) \nCalculates Daily Pivot Points ( PP, R1-R3, S1-S3 ) via  request.security()  using prior session data.\n Why this matters:  Momentum gives the signal, ADX validates the environment, and Pivots add external structure for risk and target planning. This is a designed interaction, not a random mashup.\n\n ðŸ§­ Trend State Logic (5-State Bar Coloring) \n\nThe strategy uses the momentum's value + slope to define five states, turning the chart into a visual momentum map:\n \n   ðŸŸ¢ STRONG BULL (Bright Green):  Momentum accelerating UP. â†’ Strong upside impulse.\n   ðŸŒ² WEAK BULL (Dark Green):  Momentum decelerating DOWN (while positive). â†’ Pullback/pause zone.\n   ðŸ”´ STRONG BEAR (Bright Red):  Momentum accelerating DOWN. â†’ Strong downside impulse.\n   ðŸ· WEAK BEAR (Dark Red):  Momentum decelerating UP (while negative). â†’ Rally/short-covering zone.\n   ðŸ”µ NEUTRAL / CHOP (Cyan):  Momentum is near zero (based on noise threshold). â†’ Consolidation / low volatility.\n \n ðŸŽ¯ Signal Logic Modes \n\nTVPro provides two selectable entry styles, controlled by input:\n \n   Reversals Only (Cleaner Mode â€“ Default):  Targets trend flips. Entry triggers when the current state is Bullish (or Bearish) and the previous state was not. This reduces noise and over-trading.\n   All Strong Pulses (Aggressive Mode):  Targets acceleration phases. Entry triggers when the bar turns to  STRONG BULL  or  STRONG BEAR  after any other state. This mode produces more trades.\n \n ðŸ“Œ Risk Management Tools \n \n    Golden Bars â€“ Trailing Stops:  Yellow â€œTrailâ€ Arrows mark confirmed Swing Highs/Lows. These are used as logical trailing stop levels based on market structure.\n   Extended Bars:  Detects when price closes outside a 2-standard-deviation channel, flagging overextension where a pullback is more likely.\n   Pivot Points:  Used as external targets for Take Profit and structural stop placement.\n \n âš™ï¸ Strategy Defaults (Crucial for Publication Compliance) \n\n To keep backtest results realistic and in line with House Rules, TVPro is published with the following fixed default settings: \n \n   Order Size:   5% of equity per trade  ( default_qty_value = 5 )\n   Commission:   0.04% per order  ( commission_value = 0.04 )\n   Slippage:   2 ticks  ( slippage = 2 )\n   Initial Capital:  10,000\n \n ðŸ“˜ How to Trade with Trend Vector Pro \n \n   Entry:  Take Long when a Long signal appears and confirm the bar is Green (Bull state). Short for Red (Bear state).\n   Stop Loss:  Place the initial SL near the latest swing High/Low, or near a relevant Pivot level.\n   Trade Management:  Follow  Golden (Trail) Arrows  to trail your stop behind structure.\n   Exits:  Exit when: the trailing stop is hit, Price reaches a major Pivot level, or an opposite signal prints.\n \n ðŸ›‘ Disclaimer \n \n This script is for educational purposes only and does not constitute financial advice.  Past performance does not guarantee future results. Always forward-test and use proper risk management before applying any strategy to live trading.\n",
    "image_url": "z9MwNqWe",
    "author": "mbedaiwi2",
    "likes": 31,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-10",
    "updated": "2025-12-10",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// Â© mbedaiwi2\n\n//@version=6\nstrategy(\"Trend Vector Pro v2.0\", shorttitle=\"TVPro\", overlay=true, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=5, \ncommission_type=strategy.commission.percent, commission_value=0.04, slippage=2) \n\n// -----------------------------------------------------------------------------\n// 1. CONFIGURATION & INPUTS  \n// -----------------------------------------------------------------------------\ngrp_main = \"Trend Configuration\"\nint fastLen = input.int(5, \"Fast Momentum Length\", minval=1, group=grp_main)\nint slowLen = input.int(34, \"Slow Momentum Length\", minval=1, group=grp_main)\nint smooth = input.int(5, \"Smoothing Factor\", minval=1, group=grp_main)\n\ngrp_filters = \"Signal Filters & Strategy\"\n// Signal Mode Selection\nstring sigMode = input.string(\"Reversals Only (Cleaner)\", \"Signal Logic Mode\", options=[\"Reversals Only (Cleaner)\", \"All Strong Pulses (Aggressive)\"], group=grp_filters)\n\n// ADX Filter\nbool useAdx = input.bool(false, \"Use ADX Filter?\", group=grp_filters)\nint adxThresh = input.int(20, \"ADX Threshold\", minval=1, group=grp_filters)\n\ngrp_visuals = \"Visual Settings\"\nstring textSize = input.string(size.small, \"Labels Text Size\", options=[size.auto, size.tiny, size.small, size.normal, size.large], group=grp_visuals)\n\ncolor col_strong_bull = input.color(color.new(#00FF00, 0), \"Strong Bullish\", group=grp_visuals)\ncolor col_weak_bull   = input.color(color.new(#006400, 0), \"Neutral/Bullish\", group=grp_visuals)\ncolor col_neutral     = input.color(color.new(#00FFFF, 0), \"Neutral (Cyan)\", group=grp_visuals)\ncolor col_weak_bear   = input.color(color.new(#8B0000, 0), \"Neutral/Bearish\", group=grp_visuals)\ncolor col_strong_bear = input.color(color.new(#FF0000, 0), \"Strong Bearish\", group=grp_visuals)\ncolor col_golden      = input.color(color.new(#FFD700, 0), \"Golden Bar\", group=grp_visuals)\ncolor col_extended    = input.color(color.new(#D3D3D3, 0), \"Extended Bar\", group=grp_visuals)\n\ngrp_pivots = \"Pivots Lines\"\nbool showPivotLines = input.bool(true, \"Show Pivot Lines on Chart\", group=grp_pivots)\nstring pivotPeriod = input.timeframe(\"D\", \"Pivot Timeframe\", group=grp_pivots)\n\n// -----------------------------------------------------------------------------\n// 2. MOMENTUM ENGINE & ADX\n// -----------------------------------------------------------------------------\nfloat mid = hl2\nfloat ao = ta.sma(mid, fastLen) - ta.sma(mid, slowLen)\nfloat aoSmooth = ta.ema(ao, smooth) \n\n// ADX Calculation\n[diplus, diminus, adxValue] = ta.dmi(14, 14)\nbool marketIsTrending = useAdx ? (adxValue > adxThresh) : true\n\n// -----------------------------------------------------------------------------\n// 3. TREND STATE LOGIC\n// -----------------------------------------------------------------------------\nvar color barColor = na\nstring stateBias = \"NEUTRAL\"\n\nif aoSmooth > 0\n    if aoSmooth > aoSmooth[1]\n        barColor := col_strong_bull\n        stateBias := \"STRONG BULL\"\n    else\n        barColor := col_weak_bull\n        stateBias := \"WEAK BULL\"\nelse\n    if aoSmooth < aoSmooth[1]\n        barColor := col_strong_bear\n        stateBias := \"STRONG BEAR\"\n    else\n        barColor := col_weak_bear\n        stateBias := \"WEAK BEAR\"\n\nfloat noiseThreshold = ta.stdev(aoSmooth, 100) * 0.2\nif math.abs(aoSmooth) < noiseThreshold\n    barColor := col_neutral\n    stateBias := \"NEUTRAL\"\n\n// -----------------------------------------------------------------------------\n// 4. SPECIAL BAR LOGIC (Visuals Only)\n// -----------------------------------------------------------------------------\n// Extended Bars Logic (Visual)\nbool showExtended = true // Internal Force\nint extPeriod = 20\nfloat extDev = 2.0\nfloat basis = ta.sma(close, extPeriod)\nfloat dev = ta.stdev(close, extPeriod)\nfloat upper = basis + (dev * extDev)\nfloat lower = basis - (dev * extDev)\nbool isExtended = (close > upper) or (close < lower)\n\nif isExtended\n    barColor := col_extended\n    stateBias := \"EXTENDED\"\n\n// Golden Bars (Swing Points) - Used for Trailing Visuals\nbool showGolden = true\nbool isSwingHigh = high[1] > high[0] and high[1] > high[2]\nbool isSwingLow = low[1] < low[0] and low[1] < low[2]\nbool goldenBull = (stateBias == \"STRONG BULL\" or stateBias == \"WEAK BULL\") and isSwingHigh\nbool goldenBear = (stateBias == \"STRONG BEAR\" or stateBias == \"WEAK BEAR\") and isSwingLow\n\nif goldenBull or goldenBear\n    barColor := col_golden\n\nbarcolor(barColor)\n\n// -----------------------------------------------------------------------------\n// 5. SIGNALS GENERATION (FIXED LOGIC)\n// -----------------------------------------------------------------------------\n// Initialize as false to prevent 'na' errors\nbool entryLong = false\nbool entryShort = false\n\n// Logic A: Aggressive\nbool aggLong = (barColor == col_strong_bull) and (barColor[1] != col_strong_bull)\nbool aggShort = (barColor == col_strong_bear) and (barColor[1] != col_strong_bear)\n\n// Logic B: Reversals Only\nbool isBullBias = (stateBias == \"STRONG BULL\" or stateBias == \"WEAK BULL\")\nbool isBearBias = (stateBias == \"STRONG BEAR\" or stateBias == \"WEAK BEAR\")\nbool revLong = isBullBias and not isBullBias[1]\nbool revShort = isBearBias and not isBearBias[1]\n\n// Select Mode\nif sigMode == \"Reversals Only (Cleaner)\"\n    entryLong := revLong\n    entryShort := revShort\nelse\n    entryLong := aggLong\n    entryShort := aggShort\n\n// Apply ADX Filter\nif useAdx\n    entryLong := entryLong and marketIsTrending\n    entryShort := entryShort and marketIsTrending\n\n// -----------------------------------------------------------------------------\n// 6. STRATEGY EXECUTION (BACKTESTING)\n// -----------------------------------------------------------------------------\nif entryLong\n    strategy.entry(\"Long\", strategy.long, comment=\"Long\")\n\nif entryShort\n    strategy.entry(\"Short\", strategy.short, comment=\"Short\")\n\n// -----------------------------------------------------------------------------\n// 7. VISUALS: ARROWS & LABELS\n// -----------------------------------------------------------------------------\ncolor dynamicText = chart.fg_color \n\n// Entry Visuals\nplotshape(entryLong, title=\"Long Entry\", style=shape.arrowup, location=location.belowbar, color=col_strong_bull, size=size.tiny)\nplotshape(entryShort, title=\"Short Entry\", style=shape.arrowdown, location=location.abovebar, color=col_strong_bear, size=size.tiny)\n\nif entryLong\n    label.new(bar_index, low, \"Long\", yloc=yloc.belowbar, color=color(na), textcolor=dynamicText, style=label.style_none, size=textSize)\nif entryShort\n    label.new(bar_index, high, \"Short\", yloc=yloc.abovebar, color=color(na), textcolor=dynamicText, style=label.style_none, size=textSize)\n\n// Trailing Visuals\nplotshape(goldenBear, title=\"Trail Stop (Short)\", style=shape.arrowdown, location=location.abovebar, color=color.yellow, size=size.tiny)\nplotshape(goldenBull, title=\"Trail Stop (Long)\", style=shape.arrowup, location=location.belowbar, color=color.yellow, size=size.tiny)\n\nif goldenBear\n    label.new(bar_index, high, \"Trail\\nShort\", yloc=yloc.abovebar, color=color(na), textcolor=dynamicText, style=label.style_none, size=textSize)\nif goldenBull\n    label.new(bar_index, low, \"Trail\\nLong\", yloc=yloc.belowbar, color=color(na), textcolor=dynamicText, style=label.style_none, size=textSize)\n\n// -----------------------------------------------------------------------------\n// 8. DASHBOARD\n// -----------------------------------------------------------------------------\nvar label infoLabel = label.new(na, na, \"\")\nlabel.delete(infoLabel)\n\nif barstate.islast\n    string biasText = \"BIAS: \" + stateBias\n    color txtColor = barColor == col_extended ? color.gray : barColor == col_golden ? color.yellow : barColor\n    infoLabel := label.new(bar_index + 3, close, text=biasText, color=color.new(chart.bg_color, 0), textcolor=txtColor, style=label.style_label_left, text_formatting=text.format_bold, size=size.small)\n\n// -----------------------------------------------------------------------------\n// 9. PIVOT POINTS\n// -----------------------------------------------------------------------------\np_h = request.security(syminfo.tickerid, pivotPeriod, high[1], lookahead=barmerge.lookahead_on)\np_l = request.security(syminfo.tickerid, pivotPeriod, low[1], lookahead=barmerge.lookahead_on)\np_c = request.security(syminfo.tickerid, pivotPeriod, close[1], lookahead=barmerge.lookahead_on)\n\nfloat pp = (p_h + p_l + p_c) / 3\nfloat r1 = (2 * pp) - p_l\nfloat s1 = (2 * pp) - p_h\nfloat r2 = pp + (p_h - p_l)\nfloat s2 = pp - (p_h - p_l)\nfloat r3 = p_h + 2 * (pp - p_l)\nfloat s3 = p_l - 2 * (p_h - pp)\n\ncolor c_res = color.new(color.red, 30)\ncolor c_sup = color.new(color.green, 30)\ncolor c_pp  = color.new(color.yellow, 0)\n\ndraw_pivot_line(price, col, width) =>\n    line.new(bar_index, price, bar_index, price, color=col, width=width)\n\nvar line l_r3 = na\nvar line l_r2 = na\nvar line l_r1 = na\nvar line l_pp = na\nvar line l_s1 = na\nvar line l_s2 = na\nvar line l_s3 = na\n\nbool isNewPivotPeriod = ta.change(time(pivotPeriod)) != 0\n\nif showPivotLines\n    if isNewPivotPeriod\n        l_r3 := draw_pivot_line(r3, c_res, 1)\n        l_r2 := draw_pivot_line(r2, c_res, 1)\n        l_r1 := draw_pivot_line(r1, c_res, 1)\n        l_pp := draw_pivot_line(pp, c_pp, 2)\n        l_s1 := draw_pivot_line(s1, c_sup, 1)\n        l_s2 := draw_pivot_line(s2, c_sup, 1)\n        l_s3 := draw_pivot_line(s3, c_sup, 1)\n    else\n        line.set_x2(l_r3, bar_index)\n        line.set_x2(l_r2, bar_index)\n        line.set_x2(l_r1, bar_index)\n        line.set_x2(l_pp, bar_index)\n        line.set_x2(l_s1, bar_index)\n        line.set_x2(l_s2, bar_index)\n        line.set_x2(l_s3, bar_index)"
  },
  {
    "url": "csOouivq-Trend-Vector-Pro-v2-0",
    "name": "Trend Vector Pro v2.0",
    "description": "Trend Vector Pro v2.0 \n ðŸ‘¨â€ðŸ’» Developed by: Mohammed Bedaiwi \n\n ðŸ’¡ Strategy Overview & Coherence \n\n Trend Vector Pro (TVPro)  is a momentum-based trend & reversal strategy that uses a custom smoothed oscillator, an optional ADX filter, and classic Pivot Points to create a single, coherent trading framework.\n\n Instead of stacking random indicators, TVPro is built around these integrated components: \n \n  A custom momentum engine (signal generation)\n  An optional ADX filter (trend quality control)\n  Daily Pivot Points (context, targets & S/R)\n  Swing-based â€œGolden Barâ€ trailing stops (trade management)\n  Optional extended bar detection (overextension alerts)\n \nAll parts are designed to work together and are documented below to address originality & usefulness requirements.\n\n ðŸ” Core Components & Justification \n\n 1. Custom Momentum Engine (Main Signal Source) \nTVProâ€™s engine is a custom oscillator derived from the bar midpoint ( hl2 ), similar in spirit to the Awesome Oscillator but adapted and fully integrated into the strategy. It measures velocity and acceleration of price, letting the script distinguish between strong impulses, weakening trends, and pure noise.\n\n 2. ADX Filter (Trend Strength Validation â€“ Optional) \nUses Average Directional Index (ADX) as a gatekeeper.\n Why this matters:  This prevents the strategy from firing signals in choppy, non-trending environments (when ADX is below the threshold) and keeps trades focused on periods of clear directional strength.\n\n 3. Classic Pivot Points (Context & Targets) \nCalculates Daily Pivot Points ( PP, R1-R3, S1-S3 ) via  request.security()  using prior session data.\n Why this matters:  Momentum gives the signal, ADX validates the environment, and Pivots add external structure for risk and target planning. This is a designed interaction, not a random mashup.\n\n ðŸ§­ Trend State Logic (5-State Bar Coloring) \n\nThe strategy uses the momentum's value + slope to define five states, turning the chart into a visual momentum map:\n\n \n   ðŸŸ¢ STRONG BULL (Bright Green):  Momentum accelerating UP. â†’ Strong upside impulse.\n   ðŸŒ² WEAK BULL (Dark Green):  Momentum decelerating DOWN (while positive). â†’ Pullback/pause zone.\n   ðŸ”´ STRONG BEAR (Bright Red):  Momentum accelerating DOWN. â†’ Strong downside impulse.\n   ðŸ· WEAK BEAR (Dark Red):  Momentum decelerating UP (while negative). â†’ Rally/short-covering zone.\n   ðŸ”µ NEUTRAL / CHOP (Cyan):  Momentum is near zero (based on noise threshold). â†’ Consolidation / low volatility.\n \n\n ðŸŽ¯ Signal Logic Modes \n\nTVPro provides two selectable entry styles, controlled by input:\n\n \n   Reversals Only (Cleaner Mode â€“ Default):  Targets trend flips. Entry triggers when the current state is Bullish (or Bearish) and the previous state was not. This reduces noise and over-trading.\n   All Strong Pulses (Aggressive Mode):  Targets acceleration phases. Entry triggers when the bar turns to  STRONG BULL  or  STRONG BEAR  after any other state. This mode produces more trades.\n \n\n ðŸ“Œ Risk Management Tools \n\n \n   ðŸŸ¡ Golden Bars â€“ Trailing Stops:  Yellow â€œTrailâ€ Arrows mark confirmed Swing Highs/Lows. These are used as logical trailing stop levels based on market structure.\n   Extended Bars:  Detects when price closes outside a 2-standard-deviation channel, flagging overextension where a pullback is more likely.\n   Pivot Points:  Used as external targets for Take Profit and structural stop placement.\n \n\n âš™ï¸ Strategy Defaults (Crucial for Publication Compliance) \n\n To keep backtest results realistic and in line with House Rules, TVPro is published with the following fixed default settings: \n\n \n   Order Size:   5% of equity per trade  ( default_qty_value = 5 )\n   Commission:   0.04% per order  ( commission_value = 0.04 )\n   Slippage:   2 ticks  ( slippage = 2 )\n   Initial Capital:  10,000\n \n\n ðŸ“˜ How to Trade with Trend Vector Pro \n\n \n   Entry:  Take Long when a Long signal appears and confirm the bar is Green (Bull state). Short for Red (Bear state).\n   Stop Loss:  Place the initial SL near the latest swing High/Low, or near a relevant Pivot level.\n   Trade Management:  Follow  Golden (Trail) Arrows  to trail your stop behind structure.\n   Exits:  Exit when: the trailing stop is hit, Price reaches a major Pivot level, or an opposite signal prints.\n \n\n ðŸ›‘ Disclaimer \n\n \n This script is for educational purposes only and does not constitute financial advice.  Past performance does not guarantee future results. Always forward-test and use proper risk management before applying any strategy to live trading.\n",
    "image_url": "csOouivq",
    "author": "mbedaiwi2",
    "likes": 4,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-10",
    "updated": "2025-12-10",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// Â© mbedaiwi2\n\n//@version=6\nstrategy(\"Trend Vector Pro v2.0\", shorttitle=\"TVPro\", overlay=true, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=5, \ncommission_type=strategy.commission.percent, commission_value=0.04, slippage=2) \n\n// -----------------------------------------------------------------------------\n// 1. CONFIGURATION & INPUTS  \n// -----------------------------------------------------------------------------\ngrp_main = \"Trend Configuration\"\nint fastLen = input.int(5, \"Fast Momentum Length\", minval=1, group=grp_main)\nint slowLen = input.int(34, \"Slow Momentum Length\", minval=1, group=grp_main)\nint smooth = input.int(5, \"Smoothing Factor\", minval=1, group=grp_main)\n\ngrp_filters = \"Signal Filters & Strategy\"\n// Signal Mode Selection\nstring sigMode = input.string(\"Reversals Only (Cleaner)\", \"Signal Logic Mode\", options=[\"Reversals Only (Cleaner)\", \"All Strong Pulses (Aggressive)\"], group=grp_filters)\n\n// ADX Filter\nbool useAdx = input.bool(false, \"Use ADX Filter?\", group=grp_filters)\nint adxThresh = input.int(20, \"ADX Threshold\", minval=1, group=grp_filters)\n\ngrp_visuals = \"Visual Settings\"\nstring textSize = input.string(size.small, \"Labels Text Size\", options=[size.auto, size.tiny, size.small, size.normal, size.large], group=grp_visuals)\n\ncolor col_strong_bull = input.color(color.new(#00FF00, 0), \"Strong Bullish\", group=grp_visuals)\ncolor col_weak_bull   = input.color(color.new(#006400, 0), \"Neutral/Bullish\", group=grp_visuals)\ncolor col_neutral     = input.color(color.new(#00FFFF, 0), \"Neutral (Cyan)\", group=grp_visuals)\ncolor col_weak_bear   = input.color(color.new(#8B0000, 0), \"Neutral/Bearish\", group=grp_visuals)\ncolor col_strong_bear = input.color(color.new(#FF0000, 0), \"Strong Bearish\", group=grp_visuals)\ncolor col_golden      = input.color(color.new(#FFD700, 0), \"Golden Bar\", group=grp_visuals)\ncolor col_extended    = input.color(color.new(#D3D3D3, 0), \"Extended Bar\", group=grp_visuals)\n\ngrp_pivots = \"Pivots Lines\"\nbool showPivotLines = input.bool(true, \"Show Pivot Lines on Chart\", group=grp_pivots)\nstring pivotPeriod = input.timeframe(\"D\", \"Pivot Timeframe\", group=grp_pivots)\n\n// -----------------------------------------------------------------------------\n// 2. MOMENTUM ENGINE & ADX\n// -----------------------------------------------------------------------------\nfloat mid = hl2\nfloat ao = ta.sma(mid, fastLen) - ta.sma(mid, slowLen)\nfloat aoSmooth = ta.ema(ao, smooth) \n\n// ADX Calculation\n[diplus, diminus, adxValue] = ta.dmi(14, 14)\nbool marketIsTrending = useAdx ? (adxValue > adxThresh) : true\n\n// -----------------------------------------------------------------------------\n// 3. TREND STATE LOGIC\n// -----------------------------------------------------------------------------\nvar color barColor = na\nstring stateBias = \"NEUTRAL\"\n\nif aoSmooth > 0\n    if aoSmooth > aoSmooth[1]\n        barColor := col_strong_bull\n        stateBias := \"STRONG BULL\"\n    else\n        barColor := col_weak_bull\n        stateBias := \"WEAK BULL\"\nelse\n    if aoSmooth < aoSmooth[1]\n        barColor := col_strong_bear\n        stateBias := \"STRONG BEAR\"\n    else\n        barColor := col_weak_bear\n        stateBias := \"WEAK BEAR\"\n\nfloat noiseThreshold = ta.stdev(aoSmooth, 100) * 0.2\nif math.abs(aoSmooth) < noiseThreshold\n    barColor := col_neutral\n    stateBias := \"NEUTRAL\"\n\n// -----------------------------------------------------------------------------\n// 4. SPECIAL BAR LOGIC (Visuals Only)\n// -----------------------------------------------------------------------------\n// Extended Bars Logic (Visual)\nbool showExtended = true // Internal Force\nint extPeriod = 20\nfloat extDev = 2.0\nfloat basis = ta.sma(close, extPeriod)\nfloat dev = ta.stdev(close, extPeriod)\nfloat upper = basis + (dev * extDev)\nfloat lower = basis - (dev * extDev)\nbool isExtended = (close > upper) or (close < lower)\n\nif isExtended\n    barColor := col_extended\n    stateBias := \"EXTENDED\"\n\n// Golden Bars (Swing Points) - Used for Trailing Visuals\nbool showGolden = true\nbool isSwingHigh = high[1] > high[0] and high[1] > high[2]\nbool isSwingLow = low[1] < low[0] and low[1] < low[2]\nbool goldenBull = (stateBias == \"STRONG BULL\" or stateBias == \"WEAK BULL\") and isSwingHigh\nbool goldenBear = (stateBias == \"STRONG BEAR\" or stateBias == \"WEAK BEAR\") and isSwingLow\n\nif goldenBull or goldenBear\n    barColor := col_golden\n\nbarcolor(barColor)\n\n// -----------------------------------------------------------------------------\n// 5. SIGNALS GENERATION (FIXED LOGIC)\n// -----------------------------------------------------------------------------\n// Initialize as false to prevent 'na' errors\nbool entryLong = false\nbool entryShort = false\n\n// Logic A: Aggressive\nbool aggLong = (barColor == col_strong_bull) and (barColor[1] != col_strong_bull)\nbool aggShort = (barColor == col_strong_bear) and (barColor[1] != col_strong_bear)\n\n// Logic B: Reversals Only\nbool isBullBias = (stateBias == \"STRONG BULL\" or stateBias == \"WEAK BULL\")\nbool isBearBias = (stateBias == \"STRONG BEAR\" or stateBias == \"WEAK BEAR\")\nbool revLong = isBullBias and not isBullBias[1]\nbool revShort = isBearBias and not isBearBias[1]\n\n// Select Mode\nif sigMode == \"Reversals Only (Cleaner)\"\n    entryLong := revLong\n    entryShort := revShort\nelse\n    entryLong := aggLong\n    entryShort := aggShort\n\n// Apply ADX Filter\nif useAdx\n    entryLong := entryLong and marketIsTrending\n    entryShort := entryShort and marketIsTrending\n\n// -----------------------------------------------------------------------------\n// 6. STRATEGY EXECUTION (BACKTESTING)\n// -----------------------------------------------------------------------------\nif entryLong\n    strategy.entry(\"Long\", strategy.long, comment=\"Long\")\n\nif entryShort\n    strategy.entry(\"Short\", strategy.short, comment=\"Short\")\n\n// -----------------------------------------------------------------------------\n// 7. VISUALS: ARROWS & LABELS\n// -----------------------------------------------------------------------------\ncolor dynamicText = chart.fg_color \n\n// Entry Visuals\nplotshape(entryLong, title=\"Long Entry\", style=shape.arrowup, location=location.belowbar, color=col_strong_bull, size=size.tiny)\nplotshape(entryShort, title=\"Short Entry\", style=shape.arrowdown, location=location.abovebar, color=col_strong_bear, size=size.tiny)\n\nif entryLong\n    label.new(bar_index, low, \"Long\", yloc=yloc.belowbar, color=color(na), textcolor=dynamicText, style=label.style_none, size=textSize)\nif entryShort\n    label.new(bar_index, high, \"Short\", yloc=yloc.abovebar, color=color(na), textcolor=dynamicText, style=label.style_none, size=textSize)\n\n// Trailing Visuals\nplotshape(goldenBear, title=\"Trail Stop (Short)\", style=shape.arrowdown, location=location.abovebar, color=color.yellow, size=size.tiny)\nplotshape(goldenBull, title=\"Trail Stop (Long)\", style=shape.arrowup, location=location.belowbar, color=color.yellow, size=size.tiny)\n\nif goldenBear\n    label.new(bar_index, high, \"Trail\\nShort\", yloc=yloc.abovebar, color=color(na), textcolor=dynamicText, style=label.style_none, size=textSize)\nif goldenBull\n    label.new(bar_index, low, \"Trail\\nLong\", yloc=yloc.belowbar, color=color(na), textcolor=dynamicText, style=label.style_none, size=textSize)\n\n// -----------------------------------------------------------------------------\n// 8. DASHBOARD\n// -----------------------------------------------------------------------------\nvar label infoLabel = label.new(na, na, \"\")\nlabel.delete(infoLabel)\n\nif barstate.islast\n    string biasText = \"BIAS: \" + stateBias\n    color txtColor = barColor == col_extended ? color.gray : barColor == col_golden ? color.yellow : barColor\n    infoLabel := label.new(bar_index + 3, close, text=biasText, color=color.new(chart.bg_color, 0), textcolor=txtColor, style=label.style_label_left, text_formatting=text.format_bold, size=size.small)\n\n// -----------------------------------------------------------------------------\n// 9. PIVOT POINTS\n// -----------------------------------------------------------------------------\np_h = request.security(syminfo.tickerid, pivotPeriod, high[1], lookahead=barmerge.lookahead_on)\np_l = request.security(syminfo.tickerid, pivotPeriod, low[1], lookahead=barmerge.lookahead_on)\np_c = request.security(syminfo.tickerid, pivotPeriod, close[1], lookahead=barmerge.lookahead_on)\n\nfloat pp = (p_h + p_l + p_c) / 3\nfloat r1 = (2 * pp) - p_l\nfloat s1 = (2 * pp) - p_h\nfloat r2 = pp + (p_h - p_l)\nfloat s2 = pp - (p_h - p_l)\nfloat r3 = p_h + 2 * (pp - p_l)\nfloat s3 = p_l - 2 * (p_h - pp)\n\ncolor c_res = color.new(color.red, 30)\ncolor c_sup = color.new(color.green, 30)\ncolor c_pp  = color.new(color.yellow, 0)\n\ndraw_pivot_line(price, col, width) =>\n    line.new(bar_index, price, bar_index, price, color=col, width=width)\n\nvar line l_r3 = na\nvar line l_r2 = na\nvar line l_r1 = na\nvar line l_pp = na\nvar line l_s1 = na\nvar line l_s2 = na\nvar line l_s3 = na\n\nbool isNewPivotPeriod = ta.change(time(pivotPeriod)) != 0\n\nif showPivotLines\n    if isNewPivotPeriod\n        l_r3 := draw_pivot_line(r3, c_res, 1)\n        l_r2 := draw_pivot_line(r2, c_res, 1)\n        l_r1 := draw_pivot_line(r1, c_res, 1)\n        l_pp := draw_pivot_line(pp, c_pp, 2)\n        l_s1 := draw_pivot_line(s1, c_sup, 1)\n        l_s2 := draw_pivot_line(s2, c_sup, 1)\n        l_s3 := draw_pivot_line(s3, c_sup, 1)\n    else\n        line.set_x2(l_r3, bar_index)\n        line.set_x2(l_r2, bar_index)\n        line.set_x2(l_r1, bar_index)\n        line.set_x2(l_pp, bar_index)\n        line.set_x2(l_s1, bar_index)\n        line.set_x2(l_s2, bar_index)\n        line.set_x2(l_s3, bar_index)"
  },
  {
    "url": "gG8XPeRl-Advanced-Breakout-System-v2-0",
    "name": "Advanced Breakout System v2.0",
    "description": "Advanced Breakout System v2.0 \n Developed by:  Mohammed Bedaiwi\n\nThis script hunts for high-probability breakouts by combining price consolidation zones, volume spikes vs. average volume, smart money flow (OBV), and a Momentum Override for explosive moves that skip consolidation. Additionally, it automatically identifies and plots Support and Resistance levels with price labels to help you visualize market structure.\n\nThe system follows a \"Watch & Confirm\" logic: it first prints a WATCH setup, then a BUY only if price confirms strength.\n\n ðŸ’¡ JUSTIFICATION OF CONCEPTS (MASHUP & ORIGINALITY) \n\nThis script is an original mashup combining several analytical concepts to address common breakout failures:\n \n Volatility Compression Engine: Uses built-in functions like ta.highest() and ta.lowest() to mathematically define the setup phase where price volatility is compressed below a user-defined threshold.\n\n Volume Spike Confirmation: The breakout must be confirmed by a volume increase greater than a moving average of volume, signaling strong market interest.\n\n Smart Volume Filter (OBV): This is the key component. By checking if ta.obv is above its own Moving Average, we confirm that accumulation has been occurring during the consolidation period, suggesting institutional positioning before the price break.\n\n Multi-Exit Risk System: Employs dynamic exits (EMA cross, volume dump, bearish pattern) instead of static stop-losses to manage risk adaptively based on real-time market action.\n\n Market Structure Visualization: The script also includes a Support & Resistance engine to plot key swing pivots and price labels for visual context.\n \n âœ… STRATEGY RESULTS & POLICY COMPLIANCE \n\nTo ensure non-misleading and transparent backtesting results, this strategy is published with the following fully compliant properties:\n \n Dataset Compliance: The backtest is performed on the CMTL Daily (1D) chart across a long history, generating 201 total trades. This significantly exceeds the minimum requirement of 100 trades, providing a robust test dataset.\n\n Risk Control: The strategy uses a conservative order size set to 2% of equity (default_qty_value=2), strictly adhering to the sustainable risk recommendation of 5-10% of equity per trade.\n\n Transaction Costs: Realistic trading conditions are modeled using 0.07% commission and 3 ticks slippage to prevent the overestimation of profitability.\n \n âš™ï¸ VISUAL GUIDE & SIGNAL LOGIC \n\nKey Color Legend (Visual Guide):\n \n WATCH â€“ Setup (Yellow Arrow Down): Potential breakout setup detected.\n\n BUY â€“ Confirmation (Green Arrow Up): Confirmed breakout, triggered when price trades above the high of the WATCH candle.\n\n SELL â€“ Break (Orange Arrow): Short-term trend weakness, triggered when price closes below the Fast EMA (9).\n\n SELL â€“ Dump (Dark Red Arrow): Distribution / volume dump, triggered by a bearish candle with abnormally high volume.\n\n SELL â€“ Pattern (Purple Arrow): Bearish price-action pattern (such as a bearish engulfing).\n\n Support & Resistance Lines (Red/Green): Small horizontal lines plotted at key swing points with exact price labels.\n \n âŒ¨ï¸ INPUTS (DEFAULT SETTINGS) \n \n Entry settings: Consolidation Lookback (default 20) = bars used to detect consolidation. Consolidation Range % (default 12%) = max allowed range size. Volume Spike Multiplier (default 1.2) = factor above average volume to count as a spike. Force Signal on Big Moves (default ON) = forces a WATCH signal on high-momentum moves.\n\n Exit settings: Enable Fast Exit (EMA 9) toggles the SELL â€“ Break signal. Dump Volume Multiplier defines what counts as â€œdumpâ€ volume.\n\n Support & Resistance: Adjustable Pivot Left/Right bars control the sensitivity of the support and resistance lines.\n \n âš ï¸ Disclaimer  Trading involves significant risk of loss. This script is for educational and informational purposes only and is not financial advice or a recommendation to buy or sell any asset. BUY and SELL signals are rule-based and derived from historical behavior and do not guarantee future performance. Always use your own analysis and risk management. This is an open-source strategy; users are encouraged to test it across different symbols and timeframes.",
    "image_url": "gG8XPeRl",
    "author": "mbedaiwi2",
    "likes": 30,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-10",
    "updated": "2025-12-10",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// Â© mbedaiwi2\n\n//@version=6\nstrategy(\"Advanced Breakout System v2.0\", overlay=true, initial_capital=10000, \n     default_qty_type=strategy.percent_of_equity, \n     default_qty_value=2, currency=currency.USD, \n     commission_type=strategy.commission.percent, \n     commission_value=0.07,      slippage=3 )\n     \n// -------------------------------------------------------------------------\n// 1. Settings (Inputs)\n// -------------------------------------------------------------------------\ngroup_entry = \"Entry Settings\"\n// --- CONDITIONAL INPUTS ---\n// Apply less restrictive settings on Daily chart to force more trades for policy compliance\nis_daily = timeframe.isdaily\n\n// Less restrictive Lookback (e.g., 5 bars instead of 20) on Daily\ndaily_lookback = 5\ndefault_lookback = input.int(20, \"Consolidation Lookback (Bars)\", minval=5, group=group_entry)\nlookback_period = is_daily ? daily_lookback : default_lookback\n\n// More restrictive Range (e.g., 50% instead of 12%) on Daily\ndaily_range_percent = 50.0 // Allow a much wider range for a 'consolidation'\ndefault_range_percent = input.float(12.0, \"Consolidation Range %\", minval=1.0, step=0.5, group=group_entry)\nrange_percent_val = is_daily ? daily_range_percent : default_range_percent\nrange_percent = range_percent_val / 100 \n// -------------------------------------------------------------------------\n// The rest of the script remains the same, but replaces these:\n// lookback_period = input.int(...)  // Delete this line\n// range_percent = input.float(...) / 100 // Delete this line\n// -------------------------------------------------------------------------\nvol_multiplier  = input.float(1.2, \"Volume Spike Multiplier\", minval=1.0, step=0.1, group=group_entry)\nuse_obv_filter  = input.bool(true, \"Enable Smart Volume Filter (OBV)\", group=group_entry)\nignore_cons_on_big_move = input.bool(true, \"Force Signal on Big Moves (>5%)\", tooltip=\"Triggers an immediate WATCH signal for strong moves, bypassing all filters\", group=group_entry)\n\ngroup_exit = \"Exit Settings (Warnings)\"\nuse_fast_exit    = input.bool(true, \"Enable Fast Exit (EMA 9)\", group=group_exit)\nuse_vol_exit     = input.bool(true, \"Enable Volume Dump Exit\", group=group_exit)\nvol_exit_mult    = input.float(2.0, \"Dump Volume Multiplier\", group=group_exit)\nuse_pattern_exit = input.bool(true, \"Enable Bearish Engulfing Exit\", group=group_exit)\n\n// --- GROUP: Support & Resistance ---\ngroup_sr = \"Support & Resistance Points\"\nsr_left_bars  = input.int(15, \"Pivot Left Bars\", minval=2, tooltip=\"Minimum bars to the left to confirm a point\", group=group_sr)\nsr_right_bars = input.int(5, \"Pivot Right Bars\", minval=1, tooltip=\"Minimum bars to the right to confirm a point (lag)\", group=group_sr)\n\n// -------------------------------------------------------------------------\n// 2. Indicators & Calculations\n// -------------------------------------------------------------------------\nhighest_high = ta.highest(high, lookback_period)[1]\nlowest_low   = ta.lowest(low, lookback_period)[1]\n\navg_volume = ta.sma(volume, 20)\nema_fast   = ta.ema(close, 9)\nsma_slow   = ta.sma(close, 20)\n\nobv_value = ta.obv\nobv_ma    = ta.sma(obv_value, lookback_period)\nis_obv_strong = (obv_value > obv_ma)\n\n// --- Pivot Calculation ---\npivot_high = ta.pivothigh(high, sr_left_bars, sr_right_bars)\npivot_low  = ta.pivotlow(low, sr_left_bars, sr_right_bars)\n\n// -------------------------------------------------------------------------\n// 3. Logic & Strategy\n// -------------------------------------------------------------------------\nis_consolidating = ((highest_high - lowest_low) / close[1]) < range_percent\nis_big_move = (close > open * 1.05)\nbreakout_core = close > highest_high and volume > (avg_volume * vol_multiplier)\n\nnormal_trigger = breakout_core and is_consolidating[1]\nfinal_normal_trigger = use_obv_filter ? (normal_trigger and is_obv_strong) : normal_trigger\nmomentum_trigger = breakout_core and is_big_move and ignore_cons_on_big_move\nbreakout_condition = final_normal_trigger or momentum_trigger\n\nvar bool pending_confirmation = false\nvar float breakout_high_price = 0.0\n\nif breakout_condition\n    pending_confirmation := true\n    breakout_high_price := high\n\nif pending_confirmation and close < lowest_low\n    pending_confirmation := false\n\nvalid_entry = pending_confirmation and high > breakout_high_price and bar_index > 0 and not breakout_condition\n\nif valid_entry\n    pending_confirmation := false\n\n// -------------------------------------------------------------------------\n// 4. Exits Logic\n// -------------------------------------------------------------------------\nexit_trend = use_fast_exit and ta.crossunder(close, ema_fast)\nexit_vol = use_vol_exit and close < open and volume > (avg_volume * vol_exit_mult)\nis_engulfing = close < open and close[1] > open[1] and close < low[1] and open > high[1]\nexit_pattern = use_pattern_exit and is_engulfing\nany_exit_signal = exit_trend or exit_vol or exit_pattern\n\n// -------------------------------------------------------------------------\n// 5. Strategy Execution\n// -------------------------------------------------------------------------\nif valid_entry\n    strategy.entry(\"Long Position\", strategy.long, stop=breakout_high_price)\n\nif strategy.position_size > 0 and any_exit_signal\n    strategy.close(\"Long Position\", comment=\"Exit Signal\")\n\n// -------------------------------------------------------------------------\n// 6. Alerts\n// -------------------------------------------------------------------------\nif breakout_condition\n    alert(\"ðŸŸ¡ WATCH SETUP: \" + syminfo.ticker + \" - Breakout Detected. Prepare for entry.\", alert.freq_once_per_bar_close)\n\nif valid_entry\n    alert(\"ðŸŸ¢ BUY SIGNAL: \" + syminfo.ticker + \" - Price Confirmed above Breakout Level.\", alert.freq_once_per_bar_close)\n\nif any_exit_signal\n    string exit_reason = \"\"\n    if exit_trend\n        exit_reason := \"Trend Broken (EMA 9)\"\n    else if exit_vol\n        exit_reason := \"Volume Dump (Distribution)\"\n    else if exit_pattern\n        exit_reason := \"Bearish Pattern (Engulfing)\"\n    alert(\"ðŸ”´ SELL SIGNAL: \" + syminfo.ticker + \" - Reason: \" + exit_reason, alert.freq_once_per_bar_close)\n\n// -------------------------------------------------------------------------\n// 7. Visualization\n// -------------------------------------------------------------------------\nfill(plot(highest_high, display=display.none), plot(lowest_low, display=display.none), color=is_consolidating ? color.new(color.blue, 90) : na, title=\"Consolidation Zone\")\nplot(use_fast_exit ? ema_fast : na, \"EMA 9 (Fast Exit)\", color.orange)\nplot(sma_slow, \"SMA 20 (Trend)\", color.gray)\n\n// Signals\nplotshape(breakout_condition, \"Breakout Setup\", shape.arrowdown, location.abovebar, color.yellow, 0, \"WATCH\", color.yellow, size=size.small)\nplotshape(valid_entry, \"Buy Confirmation\", shape.arrowup, location.belowbar, color.green, 0, \"BUY\", color.green, size=size.small)\nplotshape(exit_trend, \"Trend Break\", shape.arrowdown, location.abovebar, color.orange, 0, \"BREAK\", color.orange, size=size.small)\nplotshape(exit_vol, \"Volume Dump\", shape.arrowdown, location.abovebar, color.maroon, 0, \"DUMP\", color.maroon, size=size.small)\nplotshape(exit_pattern, \"Bearish Pattern\", shape.arrowdown, location.abovebar, color.purple, 0, \"PATTERN\", color.purple, size=size.small)\n\n// --- NEW: Support & Resistance (Lines & Price Labels) ---\n\n// 1. Draw Resistance (Red Line + Price)\nif not na(pivot_high)\n    // Pivot location is in the past\n    pivot_loc = bar_index - sr_right_bars\n    // Draw small red line\n    line.new(x1=pivot_loc - 1, y1=pivot_high, x2=pivot_loc + 1, y2=pivot_high, color=color.red, width=2)\n    // Draw price text above\n    label.new(x=pivot_loc, y=pivot_high, text=str.tostring(pivot_high, format.mintick), style=label.style_label_down, color=color.new(color.white, 100), textcolor=color.red, size=size.small)\n\n// 2. Draw Support (Green Line + Price)\nif not na(pivot_low)\n    // Pivot location is in the past\n    pivot_loc = bar_index - sr_right_bars\n    // Draw small green line\n    line.new(x1=pivot_loc - 1, y1=pivot_low, x2=pivot_loc + 1, y2=pivot_low, color=color.green, width=2)\n    // Draw price text below\n    label.new(x=pivot_loc, y=pivot_low, text=str.tostring(pivot_low, format.mintick), style=label.style_label_up, color=color.new(color.white, 100), textcolor=color.green, size=size.small)"
  },
  {
    "url": "BC1UkDQc-2026-CHRISTMAS-PRESENT",
    "name": "2026 CHRISTMAS PRESENT ",
    "description": "CHRISTMAS PRESENT \n\n Overview \n\nThe Cash Detector is a comprehensive trading strategy that combines momentum analysis with price action confirmation to identify high-probability entry points. This strategy is designed to capture trend reversals and continuation moves by requiring multiple confirming signals before entry, significantly reducing false signals common in single-indicator systems.\n\n\n Strategy Background \n\nThe strategy is built on the principle of confluence trading requiring multiple technical factors to align before taking a position. It focuses on two critical phases of market rotation:\n\nQ2 Momentum Phase: Uses MACD crossovers to identify shifts in market momentum, signaling when bulls or bears are gaining control.\n\nQ4 Trigger Phase: Employs engulfing candlestick patterns to confirm strong directional pressure and validate the momentum signal with actual price action.\n\nBy combining these elements, the strategy filters out weak signals and focuses only on setups where both momentum AND price action agree on direction.\n\n\n Key Features \n\n\n Dual Confirmation System: Requires both MACD momentum shift and engulfing candle pattern\n\n RSI Filter: Optional overbought/oversold filter to avoid extreme conditions\n\n Built-in Risk Management: Configurable stop loss and take profit levels\n\n Performance Dashboard: Real-time ROI metrics displayed on chart\n\n Full Backtesting: Strategy mode allows historical performance analysis\n\n\n\n Trading Rules \n\n\n LONG ENTRY BUY \n\nAll conditions must occur on the same candle:\n\n 1. Momentum Confirmation: \nMACD line crosses above signal line bullish crossover\n\n 2. Price Action Confirmation: \nBullish engulfing pattern forms:\nCurrent close greater than previous open\nCurrent open less than previous close\nCurrent close greater than current open\n\n 3. RSI Filter Optional: \nRSI less than 70 not overbought\n\nVisual Signal: Green LONG label appears below the candle\n\n\n SHORT ENTRY SELL \n\nAll conditions must occur on the same candle:\n\n 1. Momentum Confirmation: \nMACD line crosses below signal line bearish crossover\n\n 2. Price Action Confirmation: \nBearish engulfing pattern forms:\nCurrent close less than previous open\nCurrent open greater than previous close\nCurrent close less than current open\n\n 3. RSI Filter Optional: \nRSI greater than 30 not oversold\n\nVisual Signal: Red SHORT label appears above the candle\n\n \nExit Rules \n\n\n Stop Loss Default 2 percent \n\nLong: Exit if price drops 2 percent below entry\n\nShort: Exit if price rises 2 percent above entry\n\n\n Take Profit Default 4 percent \n\nLong: Exit if price rises 4 percent above entry\n\nShort: Exit if price drops 4 percent below entry\n\n\n Input Parameters\n\n\nIndicator Settings \n\nMACD Fast Length: 12 default\n\nMACD Slow Length: 26 default\n\nRSI Length: 14 default\n\n \nRisk Management \n\nUse Stop Loss: Enable or disable stop loss\n\nStop Loss percent: Percentage risk per trade default 2 percent\n\nUse Take Profit: Enable or disable take profit\n\nTake Profit percent: Target profit per trade default 4 percent\n\n\nFilters\n\nUse RSI Filter: Enable or disable RSI overbought oversold filter\n\nRSI Overbought: Upper threshold default 70\n\nRSI Oversold: Lower threshold default 30\n\n\nPerformance Metrics\n\nThe built-in dashboard displays:\n\nNet Profit: Total profit loss in currency and percentage\n\nTotal Trades: Number of completed trades\n\nWin Rate: Percentage of profitable trades\n\nProfit Factor: Ratio of gross profit to gross loss\n\nAverage Win Loss: Mean profit per winning losing trade\n\nMax Drawdown: Largest peak to trough decline\n\n\n Best Practices \n\n1. Timeframe Selection: Works on multiple timeframes test on 15min 1H 4H and daily\n\n2. Market Conditions: Most effective in trending markets with clear momentum\n\n3. Risk Reward Ratio: Default 1:2 ratio 2 percent risk 4 percent reward is conservative adjust based on backtesting\n\n4. Combine with Context: Consider overall market trend and support resistance levels\n\n5. Backtest First: Always backtest on your specific instrument and timeframe before live trading\n\n\n Risk Disclaimer \n\nThis strategy is for educational purposes. Past performance does not guarantee future results. Always:\n\nBacktest thoroughly on historical data\n\nPaper trade before using real capital\n\nUse proper position sizing and risk management\n\nNever risk more than you can afford to lose\n\n\nCustomization Tips\n\nAggressive traders: Reduce stop loss to 1.5 percent increase take profit to 5 percent\n\nConservative traders: Increase stop loss to 3 percent reduce take profit to 3 percent\n\nRanging markets: Enable RSI filter to avoid false breakouts\n\nStrong trends: Disable RSI filter to catch all momentum shifts\n\n\nTechnical Details\n\nIndicators Used:\n\nMoving Average Convergence Divergence MACD\n\nRelative Strength Index RSI\n\nCandlestick Pattern Recognition\n\nStrategy Type: Trend following with momentum confirmation\n\nBest Suited For: Stocks Forex Crypto Indices\n\n\nVersion 1.0\n\nCompatible with Pine Script v5\n\n",
    "image_url": "BC1UkDQc",
    "author": "hushedDiamond97573",
    "likes": 1216,
    "comments_count": 8,
    "script_type": "strategy",
    "created": "2025-12-10",
    "updated": "2025-12-10",
    "source": "//@version=5\nstrategy(\"Quad Rotation Detector with ROI\", overlay=true, \n     default_qty_type=strategy.percent_of_equity, default_qty_value=100)\n\n// ========== Input Parameters ==========\nlenMACD = input.int(12, \"MACD Fast Length\", minval=1)\nlenSignal = input.int(26, \"MACD Slow Length\", minval=1)\nlenRSI = input.int(14, \"RSI Length\", minval=1)\n\n// Trade Settings\nuseStopLoss = input.bool(true, \"Use Stop Loss\", group=\"Risk Management\")\nstopLossPct = input.float(2.0, \"Stop Loss %\", minval=0.1, maxval=20, step=0.1, group=\"Risk Management\")\nuseTakeProfit = input.bool(true, \"Use Take Profit\", group=\"Risk Management\")\ntakeProfitPct = input.float(4.0, \"Take Profit %\", minval=0.1, maxval=50, step=0.1, group=\"Risk Management\")\n\n// Signal Filters\nuseRSIFilter = input.bool(true, \"Use RSI Filter\", group=\"Filters\")\nrsiOverbought = input.int(70, \"RSI Overbought\", minval=50, maxval=100, group=\"Filters\")\nrsiOversold = input.int(30, \"RSI Oversold\", minval=0, maxval=50, group=\"Filters\")\n\n// ========== Q2 â€“ Momentum ==========\n[macdLine, signalLine, _] = ta.macd(close, lenMACD, lenSignal, 9)\nmacdCrossUp = ta.crossover(macdLine, signalLine)\nmacdCrossDown = ta.crossunder(macdLine, signalLine)\nrsi = ta.rsi(close, lenRSI)\n\n// ========== Q4 â€“ Trigger Candle ==========\nengulfingBull = close > open[1] and open < close[1] and close > open\nengulfingBear = close < open[1] and open > close[1] and close < open\n\n// ========== Signal Logic ==========\n// Long signal: Momentum up + Bullish engulfing\nlongSignal = macdCrossUp and engulfingBull\nif useRSIFilter\n    longSignal := longSignal and rsi < rsiOverbought\n\n// Short signal: Momentum down + Bearish engulfing\nshortSignal = macdCrossDown and engulfingBear\nif useRSIFilter\n    shortSignal := shortSignal and rsi > rsiOversold\n\n// ========== Strategy Execution ==========\nif longSignal\n    strategy.entry(\"Long\", strategy.long)\n    if useStopLoss\n        strategy.exit(\"Long Exit\", \"Long\", \n             stop=close * (1 - stopLossPct / 100),\n             limit=useTakeProfit ? close * (1 + takeProfitPct / 100) : na)\n\nif shortSignal\n    strategy.entry(\"Short\", strategy.short)\n    if useStopLoss\n        strategy.exit(\"Short Exit\", \"Short\",\n             stop=close * (1 + stopLossPct / 100),\n             limit=useTakeProfit ? close * (1 - takeProfitPct / 100) : na)\n\n// ========== Visual Markers ==========\nplotshape(macdCrossUp, title=\"Momentum Up\", location=location.belowbar,\n     color=color.new(color.green, 0), style=shape.triangleup, size=size.tiny)\nplotshape(macdCrossDown, title=\"Momentum Down\", location=location.abovebar,\n     color=color.new(color.red, 0), style=shape.triangledown, size=size.tiny)\n\nplotshape(longSignal, title=\"LONG Signal\", location=location.belowbar,\n     color=color.new(color.lime, 0), style=shape.labelup, text=\"LONG\", size=size.small)\nplotshape(shortSignal, title=\"SHORT Signal\", location=location.abovebar,\n     color=color.new(color.maroon, 0), style=shape.labeldown, text=\"SHORT\", size=size.small)\n\n// ========== Performance Dashboard ==========\nvar table perfTable = table.new(position.top_right, 2, 8, \n     bgcolor=color.new(color.white, 10), border_width=2, border_color=color.gray)\n\nif barstate.islast\n    // Calculate metrics\n    totalTrades = strategy.closedtrades\n    winningTrades = 0\n    losingTrades = 0\n    totalProfit = 0.0\n    \n    for i = 0 to totalTrades - 1\n        profit = strategy.closedtrades.profit(i)\n        totalProfit := totalProfit + profit\n        if profit > 0\n            winningTrades := winningTrades + 1\n        else\n            losingTrades := losingTrades + 1\n    \n    winRate = totalTrades > 0 ? (winningTrades / totalTrades) * 100 : 0\n    avgWin = winningTrades > 0 ? strategy.grossprofit / winningTrades : 0\n    avgLoss = losingTrades > 0 ? strategy.grossloss / losingTrades : 0\n    profitFactor = strategy.grossloss != 0 ? strategy.grossprofit / math.abs(strategy.grossloss) : 0\n    \n    // Display table\n    table.cell(perfTable, 0, 0, \"Performance Metrics\", \n         text_color=color.white, text_size=size.normal, bgcolor=color.new(color.blue, 20))\n    table.merge_cells(perfTable, 0, 0, 1, 0)\n    \n    table.cell(perfTable, 0, 1, \"Net Profit:\", text_color=color.black, text_size=size.small)\n    table.cell(perfTable, 1, 1, str.tostring(strategy.netprofit, \"#.##\") + \" (\" + \n         str.tostring((strategy.netprofit / strategy.initial_capital) * 100, \"#.##\") + \"%)\",\n         text_color=strategy.netprofit > 0 ? color.green : color.red, text_size=size.small)\n    \n    table.cell(perfTable, 0, 2, \"Total Trades:\", text_color=color.black, text_size=size.small)\n    table.cell(perfTable, 1, 2, str.tostring(totalTrades), text_color=color.black, text_size=size.small)\n    \n    table.cell(perfTable, 0, 3, \"Win Rate:\", text_color=color.black, text_size=size.small)\n    table.cell(perfTable, 1, 3, str.tostring(winRate, \"#.##\") + \"%\",\n         text_color=winRate > 50 ? color.green : color.orange, text_size=size.small)\n    \n    table.cell(perfTable, 0, 4, \"Profit Factor:\", text_color=color.black, text_size=size.small)\n    table.cell(perfTable, 1, 4, str.tostring(profitFactor, \"#.##\"),\n         text_color=profitFactor > 1 ? color.green : color.red, text_size=size.small)\n    \n    table.cell(perfTable, 0, 5, \"Avg Win:\", text_color=color.black, text_size=size.small)\n    table.cell(perfTable, 1, 5, str.tostring(avgWin, \"#.##\"), \n         text_color=color.green, text_size=size.small)\n    \n    table.cell(perfTable, 0, 6, \"Avg Loss:\", text_color=color.black, text_size=size.small)\n    table.cell(perfTable, 1, 6, str.tostring(avgLoss, \"#.##\"),\n         text_color=color.red, text_size=size.small)\n    \n    table.cell(perfTable, 0, 7, \"Max Drawdown:\", text_color=color.black, text_size=size.small)\n    table.cell(perfTable, 1, 7, str.tostring(strategy.max_drawdown, \"#.##\") + \" (\" +\n         str.tostring((strategy.max_drawdown / strategy.initial_capital) * 100, \"#.##\") + \"%)\",\n         text_color=color.orange, text_size=size.small)"
  },
  {
    "url": "bZzxTcfj-ALT-Risk-Metric-Strategy",
    "name": "ALT Risk Metric Strategy",
    "description": "Here's a professional write-up for your ALT Risk Strategy script:\n\nALT/BTC Risk Strategy - Multi-Crypto DCA with Bitcoin Correlation Analysis\nOverview\nThis strategy uses Bitcoin correlation as a risk indicator to time entries and exits for altcoins. By analyzing how your chosen altcoin performs relative to Bitcoin, the strategy identifies optimal accumulation periods (when alt/BTC is oversold) and profit-taking opportunities (when alt/BTC is overbought). Perfect for traders who want to outperform Bitcoin by strategically timing altcoin positions.\nKey Innovation: Why Alt/BTC Matters\nMost traders focus solely on USD price, but Alt/BTC ratios reveal true altcoin strength:\n\nWhen Alt/BTC is low â†’ Altcoin is undervalued relative to Bitcoin (buy opportunity)\nWhen Alt/BTC is high â†’ Altcoin has outperformed Bitcoin (take profits)\nThis approach captures the rotation between BTC and alts that drives crypto cycles\n\nKey Features\nðŸ“Š Advanced Technical Analysis\n\nRSI (60% weight): Primary momentum indicator on weekly timeframe\nLong-term MA Deviation (35% weight): Measures distance from 150-period baseline\nMACD (5% weight): Minor confirmation signal\nEMA Smoothing: Filters noise while maintaining responsiveness\nAll calculations performed on Alt/BTC pairs for superior market timing\n\nðŸ’° 3-Tier DCA System\n\nLevel 1 (Risk â‰¤ 70): Conservative entry, base allocation\nLevel 2 (Risk â‰¤ 50): Increased allocation, strong opportunity\nLevel 3 (Risk â‰¤ 30): Maximum allocation, extreme undervaluation\nContinuous buying: Executes every bar while below threshold for true DCA behavior\nCumulative sizing: L3 triggers = L1 + L2 + L3 amounts combined\n\nðŸ“ˆ Smart Profit Management\n\nSequential selling: Must complete L1 before L2, L2 before L3\nPercentage-based exits: Sell portions of position, not fixed amounts\nAuto-reset on re-entry: New buy signals reset sell progression\nPrevents premature full exits during volatile conditions\n\nðŸ¤– 3Commas Automation\n\nPre-configured JSON webhooks for Custom Signal Bots\nMulti-exchange support: Binance, Coinbase, Kraken, Bitfinex, Bybit\nFlexible quote currency: USD, USDT, or BUSD\nDynamic order sizing: Automatically adjusts to your tier thresholds\nFull webhook documentation compliance\n\nðŸŽ¨ Multi-Asset Support\nPre-configured for popular altcoins:\n\nETH (Ethereum)\nSOL (Solana)\nADA (Cardano)\nLINK (Chainlink)\nUNI (Uniswap)\nXRP (Ripple)\nDOGE\nRENDER\nCustom option for any other crypto\n\nHow It Works\nRisk Metric Calculation (0-100 scale):\n\nFetches weekly Alt/BTC price data for stability\nCalculates RSI, MACD, and deviation from 150-period MA\nNormalizes MACD to 0-100 range using 500-bar lookback\nCombines weighted components: (MACD Ã— 0.05) + (RSI Ã— 0.60) + (Deviation Ã— 0.35)\nApplies 5-period EMA smoothing for cleaner signals\n\nColor-Coded Risk Zones:\n\nGreen (0-30): Extreme buying opportunity - Alt heavily oversold vs BTC\nLime/Yellow (30-70): Accumulation range - favorable risk/reward\nOrange (70-85): Caution zone - consider taking initial profits\nRed/Maroon (85-100+): Euphoria zone - aggressive profit-taking\n\nEntry Logic:\n\nBuys execute every candle when risk is below threshold\nAs risk decreases, position sizing automatically scales up\nExample: If risk drops from 60â†’25, you'll be buying at L1 rate until it hits 50, then L2 rate, then L3 rate\n\nExit Logic:\n\nSells only trigger when in profit AND risk exceeds thresholds\nSequential execution ensures partial profit-taking\nIf new buy signal occurs before all sells complete, sell levels reset to L1\n\nConfiguration Guide\nChoosing Your Altcoin:\n\nSelect crypto from dropdown (or use CUSTOM for unlisted coins)\nPick your exchange\nChoose quote currency (USD, USDT, BUSD)\n\nRisk Metric Tuning:\n\nLong Term MA (default 150): Higher = more extreme signals, Lower = more frequent\nRSI Length (default 10): Lower = more volatile, Higher = smoother\nSmoothing (default 5): Increase for less noise, decrease for faster reaction\n\nBuy Settings (Aggressive DCA Example):\n\nL1 Threshold: 70 | Amount: $5\nL2 Threshold: 50 | Amount: $6\nL3 Threshold: 30 | Amount: $7\nTotal L3 buy = $18 per candle when deeply oversold\n\nSell Settings (Balanced Exit Example):\n\nL1: 70 threshold, 25% position\nL2: 85 threshold, 35% position\nL3: 100 threshold, 40% position (final exit)\n\n3Commas Setup\nBot Configuration:\n\nCreate Custom Signal Bot in 3Commas\nSet trading pair to your altcoin/USD (e.g., ETH/USD, SOL/USDT)\nOrder size: Select \"Send in webhook, quote\" to use strategy's dollar amounts\nCopy Bot UUID and Secret Token\n\nScript Configuration:\n\nPaste credentials into 3Commas section inputs\nCheck \"Enable 3Commas Alerts\"\nSave and apply to chart\n\nTradingView Alert:\n\nCreate Alert â†’ Condition: \"alert() function calls only\"\nWebhook URL: api.3commas.io\nEnable \"Webhook URL\" checkbox\nExpiration: Open-ended\n\nStrategy Advantages\nâœ… Outperform Bitcoin: Designed specifically to beat BTC by timing alt rotations\nâœ… Capture Alt Seasons: Automatically accumulates when alts lag, sells when they pump\nâœ… Risk-Adjusted Sizing: Buys more when cheaper (better risk/reward)\nâœ… Emotional Discipline: Systematic approach removes fear and FOMO\nâœ… Multi-Asset: Run same strategy across multiple altcoins simultaneously\nâœ… Proven Indicators: Combines RSI, MACD, and MA deviation - battle-tested tools\nBacktesting Insights\nOptimal Timeframes:\n\nDaily chart: Best for backtesting and signal generation\nWeekly data is fetched internally regardless of display timeframe\n\nHistorical Performance Characteristics:\n\nAccumulates heavily during bear markets and BTC dominance periods\nCaptures explosive altcoin rallies when BTC stagnates\nSequential selling preserves capital during extended downtrends\nWorks best on established altcoins with multi-year history\n\nRisk Considerations:\n\nRequires capital reserves for extended accumulation periods\nSome altcoins may never recover if fundamentals deteriorate\nPast correlation patterns may not predict future performance\nAlways size positions according to personal risk tolerance\n\nVisual Interface\nIndicator Panel Displays:\n\nDynamic color line: Greenâ†’Limeâ†’Yellowâ†’Orangeâ†’Red as risk increases\nHorizontal threshold lines: Dashed lines mark your buy/sell levels\nEntry/Exit labels: Green labels for buys, Orange/Red/Maroon for sells\nReal-time risk value: Numerical display on price scale\n\nCustomization:\n\nAll threshold lines are adjustable via inputs\nColor scheme clearly differentiates buy zones (green spectrum) from sell zones (red spectrum)\nLine weights emphasize most extreme thresholds (L3 buy and L3 sell)\n\nStrategy Philosophy\nThis strategy is built on the principle that altcoins move in cycles relative to Bitcoin. During Bitcoin rallies, alts often bleed against BTC (high sell, accumulate). When Bitcoin consolidates, alts pump (take profits). By measuring risk on the Alt/BTC chart instead of USD price, we time these rotations with precision.\nThe 3-tier system ensures you're always averaging in at better prices and scaling out at better prices, maximizing your Bitcoin-denominated returns.\nAdvanced Tips\nMulti-Bot Strategy:\nRun this on 5-10 different altcoins simultaneously to:\n\nDiversify correlation risk\nCapture whichever alt is pumping\nSmooth equity curve through rotation\n\nPairing with BTC Strategy:\nUse alongside the BTC DCA Risk Strategy for complete portfolio coverage:\n\nBTC strategy for core holdings\nALT strategies for alpha generation\nRebalance between them based on BTC dominance\n\nThreshold Calibration:\n\nCheck 2-3 years of historical data for your chosen alt\nNote where risk metric sat during major bottoms (set buy thresholds)\nNote where it peaked during euphoria (set sell thresholds)\nAdjust for your risk tolerance and holding period\n\nCredits\nStrategy Development & 3Commas Integration: Claude AI (Anthropic)\nTechnical Analysis Framework: RSI, MACD, Moving Average theory\nImplementation: pommesUNDwurst\nDisclaimer\nThis strategy is for educational purposes only. Cryptocurrency trading involves substantial risk of loss. Altcoins are especially volatile and many fail completely. The strategy assumes liquid markets and reliable Alt/BTC price data. Always do your own research, understand the fundamentals of any asset you trade, and never risk more than you can afford to lose. Past performance does not guarantee future results. The authors are not financial advisors and assume no liability for trading decisions.\nAdditional Warning: Using leverage or trading illiquid altcoins amplifies risk significantly. This strategy is designed for spot trading of established cryptocurrencies with deep liquidity.\n\nTags: Altcoin, Alt/BTC, DCA, Risk Metric, Dollar Cost Averaging, 3Commas, ETH, SOL, Crypto Rotation, Bitcoin Correlation, Automated Trading, Alt Season\n\nFeel free to modify any sections to better match your style or add specific backtesting results you've observed! ðŸš€Claude is AI and can make mistakes. Please double-check responses. Sonnet 4.5",
    "image_url": "bZzxTcfj",
    "author": "nakphanan",
    "likes": 15,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-10",
    "updated": "2025-12-10",
    "source": "//@version=5\r\nstrategy(\"ALT Risk Strategy\", overlay=false, initial_capital=10000, default_qty_type=strategy.cash, commission_type=strategy.commission.percent, commission_value=0.1)\r\n\r\n// === TICKER SELECTION ===\r\ncryptoSymbol = input.string(\"ETH\", \"Crypto Symbol\", options=[\"ETH\", \"SOL\", \"ADA\", \"LINK\", \"UNI\", \"XRP\", \"XDG\", \"RENDER\", \"CUSTOM\"])\r\ncustomSymbol = input.string(\"\", \"Custom Symbol (if CUSTOM selected)\")\r\nquoteSymbol = input.string(\"USD\", \"Quote Currency\", options=[\"USD\", \"USDT\", \"BUSD\"])\r\nexchange = input.string(\"BINANCE\", \"Exchange\", options=[\"BINANCE\", \"COINBASE\", \"KRAKEN\", \"BITFINEX\", \"BYBIT\"])\r\n\r\n// Build the tickers\r\nuseSymbol = cryptoSymbol == \"CUSTOM\" ? customSymbol : cryptoSymbol\r\nCRYPTO_BTC_TICKER = exchange + \":\" + useSymbol + \"BTC\"  // For risk metric calculation\r\nCRYPTO_USD_TICKER = useSymbol + quoteSymbol  // For 3Commas trading\r\n\r\n// === RISK METRIC INPUTS ===\r\nlongTermLength   = input.int(150, \"Long Term MA Length\", minval=10, group=\"Risk Metric\")\r\nrsiLength        = input.int(10, \"RSI Length\", minval=1, group=\"Risk Metric\")\r\nsignalFastLength = input.int(8, \"MACD Fast Length\", minval=1, group=\"Risk Metric\")\r\nsignalSlowLength = input.int(26, \"MACD Slow Length\", minval=1, group=\"Risk Metric\")\r\nsmoothingLength  = input.int(5, \"Smoothing Length\", minval=1, group=\"Risk Metric\")\r\n\r\n// === 3COMMAS CREDENTIALS ===\r\nbot_uuid = input.string(\"\", \"3Commas Bot UUID\", group=\"3Commas\", tooltip=\"Get this from your Signal Bot settings\")\r\nsecret_token = input.string(\"\", \"3Commas Secret Token\", group=\"3Commas\", tooltip=\"Get this from your Signal Bot settings\")\r\nuse_3commas = input.bool(false, \"Enable 3Commas Alerts\", group=\"3Commas\")\r\n// === BUY THRESHOLDS & AMOUNTS ===\r\nbuyL1_thresh = input.float(70.0, \"Buy L1 Threshold\", group=\"Buy Settings\")\r\nbuyL2_thresh = input.float(50.0, \"Buy L2 Threshold\", group=\"Buy Settings\")\r\nbuyL3_thresh = input.float(30.0, \"Buy L3 Threshold\", group=\"Buy Settings\")\r\nbuyL1_amt = input.float(5.0, \"Buy L1 $ Amount\", group=\"Buy Settings\")\r\nbuyL2_amt = input.float(6.0, \"Buy L2 $ Amount\", group=\"Buy Settings\")\r\nbuyL3_amt = input.float(7.0, \"Buy L3 $ Amount\", group=\"Buy Settings\")\r\n\r\n// === SELL THRESHOLDS & PERCENTAGES ===\r\nsellL1_thresh = input.float(70.0, \"Sell L1 Threshold\", group=\"Sell Settings\")\r\nsellL2_thresh = input.float(85.0, \"Sell L2 Threshold\", group=\"Sell Settings\")\r\nsellL3_thresh = input.float(100.0, \"Sell L3 Threshold\", group=\"Sell Settings\")\r\nsellL1_pct = input.float(25.0, \"Sell L1 %\", group=\"Sell Settings\")\r\nsellL2_pct = input.float(35.0, \"Sell L2 %\", group=\"Sell Settings\")\r\nsellL3_pct = input.float(40.0, \"Sell L3 %\", group=\"Sell Settings\")\r\n\r\n// === FUNCTION TO CALCULATE MACD, RSI, DEVIATION ===\r\nf_get_fixed_data() =>\r\n    fastMA   = ta.ema(close, signalFastLength)\r\n    slowMA   = ta.ema(close, signalSlowLength)\r\n    macdLine = fastMA - slowMA\r\n    rsiVal   = ta.rsi(close, rsiLength)\r\n    longMA   = ta.sma(close, longTermLength)\r\n    deviation = (close - longMA) / longMA\r\n    [macdLine, rsiVal, deviation]\r\n\r\n// === FETCH WEEKLY DATA ===\r\n[macdLine_W, rsi_W, dev_W] = request.security(CRYPTO_BTC_TICKER, \"W\", f_get_fixed_data(), barmerge.gaps_off)\r\n\r\n// === NORMALIZE MACD ===\r\nmacdMax = ta.highest(macdLine_W, 500)\r\nmacdMin = ta.lowest(macdLine_W, 500)\r\nmacdRange = macdMax != macdMin ? (macdLine_W - macdMin) / (macdMax - macdMin) * 100 : 50\r\nnormalizedMacd = macdRange < 0 ? 0 : macdRange > 100 ? 100 : macdRange\r\n\r\n// === CALCULATE RISK METRIC ===\r\nriskOsc = (normalizedMacd * 0.05) + (rsi_W * 0.60) + ((dev_W + 1) * 0.35 * 100)\r\nriskMetric = ta.ema(riskOsc, smoothingLength)\r\n\r\n// === STATE VARIABLES ===\r\nvar bool sellL1_done = false\r\nvar bool sellL2_done = false\r\nvar bool sellL3_done = false\r\n\r\n// === BUY LOGIC ===\r\nvar float buyAmount = 0.0\r\nbuyTier = \"NONE\"\r\n\r\nif riskMetric <= buyL3_thresh\r\n    buyAmount := buyL1_amt + buyL2_amt + buyL3_amt\r\n    buyTier := \"L3\"\r\nelse if riskMetric <= buyL2_thresh\r\n    buyAmount := buyL1_amt + buyL2_amt\r\n    buyTier := \"L2\"\r\nelse if riskMetric <= buyL1_thresh\r\n    buyAmount := buyL1_amt\r\n    buyTier := \"L1\"\r\nelse\r\n    buyAmount := 0\r\n    buyTier := \"NONE\"\r\n\r\nbuyTrigger = buyAmount > 0\r\n\r\n// === BUY EXECUTION ===\r\nif buyTrigger\r\n    strategy.entry(\"BUY\", strategy.long, qty=buyAmount/close, comment=\"BUY \" + buyTier)\r\n    label.new(bar_index, riskMetric, \"BUY \" + buyTier + \"\\n$\" + str.tostring(buyAmount), \r\n         style=label.style_label_up, color=color.green, textcolor=color.white, size=size.small)\r\n    \r\n    // Reset sell levels when new buy occurs\r\n    sellL1_done := false\r\n    sellL2_done := false\r\n    sellL3_done := false\r\n\r\n    // Send 3Commas buy alert\r\n    if use_3commas\r\n        buyJson = '{\"secret\":\"' + secret_token + '\",\"max_lag\":\"300\",\"timestamp\":\"' + str.tostring(timenow) + '\",\"trigger_price\":\"' + str.tostring(close) + '\",\"tv_exchange\":\"' + exchange + '\",\"tv_instrument\":\"' + CRYPTO_USD_TICKER + '\",\"action\":\"enter_long\",\"bot_uuid\":\"' + bot_uuid + '\",\"order\":{\"amount\":\"' + str.tostring(buyAmount) + '\",\"currency_type\":\"quote\",\"order_type\":\"market\"}}'\r\n        alert(buyJson, alert.freq_once_per_bar_close)\r\n    \r\n// === SELL LOGIC ===\r\nsell1Cond = strategy.position_size > 0 and riskMetric >= sellL1_thresh and not sellL1_done\r\nsell2Cond = strategy.position_size > 0 and riskMetric >= sellL2_thresh and sellL1_done and not sellL2_done\r\nsell3Cond = strategy.position_size > 0 and riskMetric >= sellL3_thresh and sellL2_done and not sellL3_done\r\n\r\nif sell1Cond\r\n    strategy.close(\"BUY\", qty_percent=sellL1_pct, comment=\"SELL L1\")\r\n    label.new(bar_index, riskMetric, \"SELL L1\\n\" + str.tostring(sellL1_pct) + \"%\", \r\n         style=label.style_label_down, color=color.orange, textcolor=color.white, size=size.small)\r\n    sellL1_done := true\r\n    \r\n    if use_3commas\r\n        sellJson = '{\"secret\":\"' + secret_token + '\",\"max_lag\":\"300\",\"timestamp\":\"' + str.tostring(timenow) + '\",\"trigger_price\":\"' + str.tostring(close) + '\",\"tv_exchange\":\"' + exchange + '\",\"tv_instrument\":\"' + CRYPTO_USD_TICKER + '\",\"action\":\"exit_long\",\"bot_uuid\":\"' + bot_uuid + '\",\"order\":{\"amount\":\"' + str.tostring(sellL1_pct) + '\",\"currency_type\":\"position_percent\",\"order_type\":\"market\"}}'\r\n        alert(sellJson, alert.freq_once_per_bar_close)\r\n\r\nif sell2Cond\r\n    strategy.close(\"BUY\", qty_percent=sellL2_pct, comment=\"SELL L2\")\r\n    label.new(bar_index, riskMetric, \"SELL L2\\n\" + str.tostring(sellL2_pct) + \"%\", \r\n         style=label.style_label_down, color=color.red, textcolor=color.white, size=size.small)\r\n    sellL2_done := true\r\n    \r\n    if use_3commas\r\n        sellJson = '{\"secret\":\"' + secret_token + '\",\"max_lag\":\"300\",\"timestamp\":\"' + str.tostring(timenow) + '\",\"trigger_price\":\"' + str.tostring(close) + '\",\"tv_exchange\":\"' + exchange + '\",\"tv_instrument\":\"' + CRYPTO_USD_TICKER + '\",\"action\":\"exit_long\",\"bot_uuid\":\"' + bot_uuid + '\",\"order\":{\"amount\":\"' + str.tostring(sellL2_pct) + '\",\"currency_type\":\"position_percent\",\"order_type\":\"market\"}}'\r\n        alert(sellJson, alert.freq_once_per_bar_close)\r\n\r\nif sell3Cond\r\n    strategy.close(\"BUY\", qty_percent=sellL3_pct, comment=\"SELL L3\")\r\n    label.new(bar_index, riskMetric, \"SELL L3\\n\" + str.tostring(sellL3_pct) + \"%\", \r\n         style=label.style_label_down, color=color.maroon, textcolor=color.white, size=size.small)\r\n    sellL3_done := true\r\n    \r\n    if use_3commas\r\n        sellJson = '{\"secret\":\"' + secret_token + '\",\"max_lag\":\"300\",\"timestamp\":\"' + str.tostring(timenow) + '\",\"trigger_price\":\"' + str.tostring(close) + '\",\"tv_exchange\":\"' + exchange + '\",\"tv_instrument\":\"' + CRYPTO_USD_TICKER + '\",\"action\":\"exit_long\",\"bot_uuid\":\"' + bot_uuid + '\",\"order\":{\"amount\":\"' + str.tostring(sellL3_pct) + '\",\"currency_type\":\"position_percent\",\"order_type\":\"market\"}}'\r\n        alert(sellJson, alert.freq_once_per_bar_close)\r\n\r\n// === COLOR-CODED PLOTTING ===\r\nriskColor = (riskMetric <= buyL3_thresh ? color.green :\r\n             riskMetric <= buyL2_thresh ? color.lime :\r\n             riskMetric <= buyL1_thresh ? color.yellow :\r\n             riskMetric <= sellL1_thresh ? color.orange :\r\n             riskMetric <= sellL2_thresh ? color.red :\r\n             color.maroon)\r\n\r\nplot(riskMetric, title=\"Risk Metric\", color=riskColor, linewidth=2)\r\n\r\n// === HORIZONTAL THRESHOLDS ===\r\nhline(buyL3_thresh, \"Buy L3\", color=color.green, linewidth=2)\r\nhline(buyL2_thresh, \"Buy L2\", color=color.lime)\r\nhline(buyL1_thresh, \"Buy L1\", color=color.yellow, linestyle=hline.style_dashed)\r\nhline(sellL1_thresh, \"Sell L1\", color=color.orange, linestyle=hline.style_dashed)\r\nhline(sellL2_thresh, \"Sell L2\", color=color.red)\r\nhline(sellL3_thresh, \"Sell L3\", color=color.maroon, linewidth=2)"
  },
  {
    "url": "rGv72PnR-BTC-DCA-Risk-Metric-Strategy",
    "name": "BTC DCA Risk Metric Strategy",
    "description": "BTC DCA Risk Strategy - Automated Dollar Cost Averaging with 3Commas Integration\nOverview\nThis strategy combines the proven Oakley Wood Risk Metric with an intelligent tiered Dollar Cost Averaging (DCA) system, designed to help traders systematically accumulate Bitcoin during periods of low risk and take profits during high-risk conditions.\nKey Features\nðŸ“Š Multi-Component Risk Assessment\n\n4-Year SMA Deviation: Measures Bitcoin's distance from its long-term mean\n20-Week MA Analysis: Tracks medium-term momentum shifts\n50-Day/50-Week MA Ratio: Captures short-to-medium term trend strength\nAll metrics are normalized by time to account for Bitcoin's maturing market dynamics\n\nðŸ’° 3-Tier DCA Buy System\n\nLevel 1 (Low Risk): Conservative entry with base allocation\nLevel 2 (Lower Risk): Increased allocation as opportunity improves\nLevel 3 (Extreme Low Risk): Maximum allocation during rare buying opportunities\nBuys execute every bar while risk remains below thresholds, enabling true DCA accumulation\n\nðŸ“ˆ Progressive Profit Taking\n\nSell Level 1: Take initial profits as risk increases\nSell Level 2: Scale out further positions during elevated risk\nSell Level 3: Final exit during extreme market conditions\nSell levels automatically reset when new buy signals occur, allowing flexible re-entry\n\nðŸ¤– 3Commas Integration\n\nFully automated webhook alerts for Custom Signal Bots\nJSON payloads formatted per 3Commas API specifications\nSupports multiple exchanges (Binance, Coinbase, Kraken, Gemini, Bybit)\nConfigurable quote currency (USD, USDT, BUSD)\n\nHow It Works\nThe strategy calculates a composite risk metric (0-1 scale):\n\n0.0-0.2: Extreme buying opportunity (green zone)\n0.2-0.5: Favorable accumulation range (yellow zone)\n0.5-0.8: Neutral to cautious territory (orange zone)\n0.8-1.0+: High risk, profit-taking zone (red zone)\n\nBuy Logic: As risk decreases, position sizes increase automatically. If risk drops from L1 to L3 threshold, the strategy combines all three tier allocations for maximum exposure.\nSell Logic: Sequential profit-taking ensures you capture gains progressively. The system won't advance to Sell L2 until L1 completes, preventing premature full exits.\nConfiguration\nRisk Metric Parameters:\n\nAll calculations use Bitcoin price data (any BTC chart works)\nTime-normalized formulas adapt to market maturity\nNo manual parameter tuning required\n\nBuy Settings:\n\nSet risk thresholds for each tier (default: 0.20, 0.10, 0.00)\nDefine dollar amounts per tier (default: $10, $15, $20)\nFully customizable to your risk tolerance and capital\n\nSell Settings:\n\nConfigure risk thresholds for profit-taking (default: 1.00, 1.50, 2.00)\nSet percentage of position to sell at each level (default: 25%, 35%, 40%)\n\n3Commas Setup:\n\nCreate a Custom Signal Bot in 3Commas\nCopy Bot UUID and Secret Token into strategy inputs\nEnable 3Commas Alerts checkbox\nCreate TradingView alert: Condition â†’ \"alert() function calls only\", Webhook â†’ api.3commas.io\n\nBacktesting Results\nStrengths:\n\nSystematically buys dips without emotion\nAverages down during extended bear markets\nCaptures explosive bull run profits through tiered exits\nPyramiding (1000 max orders) allows true DCA behavior\n\nConsiderations:\n\nRequires sufficient capital for multiple buys during prolonged downtrends\nBacktest on Daily timeframe for most reliable signals\nPast performance does not guarantee future results\n\nVisual Design\nThe indicator pane displays:\n\nColor-coded risk metric line: Changes from whiteâ†’redâ†’orangeâ†’yellowâ†’green as risk decreases\nBackground zones: Green (buy), yellow (hold), red (sell) areas\nDashed threshold lines: Clear visual markers for each buy/sell level\nEntry/Exit labels: Green buy labels and orange/red sell labels mark all trades\n\nCredits\nOriginal Risk Metric: Oakley Wood\nStrategy Development & 3Commas Integration: Claude AI (Anthropic)\nModifications: pommesUNDwurst\nDisclaimer\nThis strategy is for educational and informational purposes only. Cryptocurrency trading carries substantial risk of loss. Always conduct your own research and never invest more than you can afford to lose. The authors are not financial advisors and assume no responsibility for trading decisions made using this tool.",
    "image_url": "rGv72PnR",
    "author": "nakphanan",
    "likes": 14,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-10",
    "updated": "2025-12-10",
    "source": "//@version=5\r\n// Risk Metric by Oakley Wood (modified by pommesUNDwurst)\r\n// DCA Strategy implementation with 3Commas integration\r\nstrategy(\"BTC DCA Risk Strategy\", \r\n     overlay=false, \r\n     initial_capital=10000, \r\n     default_qty_type=strategy.cash, \r\n     commission_type=strategy.commission.percent, \r\n     commission_value=0.1,\r\n     pyramiding=1000,\r\n     calc_on_order_fills=false,\r\n     calc_on_every_tick=false,\r\n     process_orders_on_close=true)\r\n\r\n// === EXCHANGE SELECTION ===\r\nexchange = input.string(\"KRAKEN\", \"Exchange\", options=[\"BINANCE\", \"COINBASE\", \"KRAKEN\", \"GEMINI\", \"BYBIT\"])\r\nquoteSymbol = input.string(\"USD\", \"Quote Currency\", options=[\"USD\", \"USDT\", \"BUSD\"])\r\n\r\n// Build tickers\r\nBTC_TICKER = syminfo.tickerid\r\nBTC_TRADE_TICKER = \"BTC\" + quoteSymbol\r\n\r\n// === 3COMMAS CREDENTIALS ===\r\nbot_uuid = input.string(\"\", \"3Commas Bot UUID\", group=\"3Commas\")\r\nsecret_token = input.string(\"\", \"3Commas Secret Token\", group=\"3Commas\")\r\nuse_3commas = input.bool(false, \"Enable 3Commas Alerts\", group=\"3Commas\")\r\n\r\n// === BUY THRESHOLDS & AMOUNTS ===\r\nbuyL1_thresh = input.float(0.20, \"Buy L1 Threshold\", group=\"Buy Settings\", tooltip=\"Risk metric threshold for first buy tier\")\r\nbuyL2_thresh = input.float(0.10, \"Buy L2 Threshold\", group=\"Buy Settings\")\r\nbuyL3_thresh = input.float(0.00, \"Buy L3 Threshold\", group=\"Buy Settings\")\r\nbuyL1_amt = input.float(10.0, \"Buy L1 $ Amount\", group=\"Buy Settings\")\r\nbuyL2_amt = input.float(15.0, \"Buy L2 $ Amount\", group=\"Buy Settings\")\r\nbuyL3_amt = input.float(20.0, \"Buy L3 $ Amount\", group=\"Buy Settings\")\r\n\r\n// === SELL THRESHOLDS & PERCENTAGES ===\r\nsellL1_thresh = input.float(1.00, \"Sell L1 Threshold\", group=\"Sell Settings\")\r\nsellL2_thresh = input.float(1.50, \"Sell L2 Threshold\", group=\"Sell Settings\")\r\nsellL3_thresh = input.float(2.00, \"Sell L3 Threshold\", group=\"Sell Settings\")\r\nsellL1_pct = input.float(25.0, \"Sell L1 %\", group=\"Sell Settings\")\r\nsellL2_pct = input.float(35.0, \"Sell L2 %\", group=\"Sell Settings\")\r\nsellL3_pct = input.float(40.0, \"Sell L3 %\", group=\"Sell Settings\")\r\n\r\n// === RISK METRIC CALCULATION (Oakley Wood) ===\r\n\r\n// METRIC 1: (BTC - 4 year SMA) / StdDev, normalized by time\r\nd1460_sma = request.security(BTC_TICKER, 'D', ta.sma(close, 1460)) \r\nstdev1 = request.security(BTC_TICKER, 'D', ta.stdev(close, 1460)) \r\nbtc = request.security(BTC_TICKER, 'D', close)\r\nmaxRiskOne = -38.12 * math.log(timenow) + 1078.5\r\nriskOne = ((btc - d1460_sma) / stdev1) / maxRiskOne\r\n\r\n// METRIC 2: ln(BTC / 20 week MA), normalized by time\r\nw20_sma = request.security(BTC_TICKER, \"W\", ta.sma(close, 20))\r\nminRiskTwo = -3.719 * math.log(timenow) + 105\r\nmaxRiskTwo = -6 * math.pow(10, -12) * timenow + 10.93\r\nriskTwo = (math.log(btc / w20_sma) + minRiskTwo) / maxRiskTwo\r\n\r\n// METRIC 3: 50D MA / 50W MA, normalized by time\r\nd50_sma = request.security(BTC_TICKER, 'D', ta.sma(close, 50))\r\nw50_sma = request.security(BTC_TICKER, 'W', ta.sma(close, 50))\r\nmaxRiskThree = -12.55 * math.log(timenow) + 355.15\r\nriskThree = (d50_sma / w50_sma) / maxRiskThree\r\n\r\n// COMPOUND RISK METRIC (0 = extreme buy, 1 = extreme sell)\r\nriskMetric = (nz(riskOne,0) + nz(riskTwo,0) + nz(riskThree,0)) / 3\r\n\r\n// === STATE VARIABLES ===\r\nvar bool sellL1_done = false\r\nvar bool sellL2_done = false\r\nvar bool sellL3_done = false\r\n\r\n// === BUY LOGIC ===\r\nvar float buyAmount = 0.0\r\nbuyTier = \"NONE\"\r\n\r\nif riskMetric <= buyL3_thresh\r\n    buyAmount := buyL1_amt + buyL2_amt + buyL3_amt\r\n    buyTier := \"L3\"\r\nelse if riskMetric <= buyL2_thresh\r\n    buyAmount := buyL1_amt + buyL2_amt\r\n    buyTier := \"L2\"\r\nelse if riskMetric <= buyL1_thresh\r\n    buyAmount := buyL1_amt\r\n    buyTier := \"L1\"\r\nelse\r\n    buyAmount := 0\r\n    buyTier := \"NONE\"\r\n\r\nbuyTrigger = buyAmount > 0\r\n\r\n// === BUY EXECUTION ===\r\nif buyTrigger\r\n    strategy.entry(\"BUY\", strategy.long, qty=buyAmount/close, comment=\"BUY \" + buyTier)\r\n    label.new(bar_index, riskMetric, \"BUY \" + buyTier + \"\\n$\" + str.tostring(buyAmount), \r\n         style=label.style_label_up, color=color.green, textcolor=color.white, size=size.small)\r\n    \r\n    sellL1_done := false\r\n    sellL2_done := false\r\n    sellL3_done := false\r\n    \r\n    if use_3commas\r\n        buyJson = '{\"secret\":\"' + secret_token + '\",\"max_lag\":\"300\",\"timestamp\":\"' + str.tostring(timenow) + '\",\"trigger_price\":\"' + str.tostring(close) + '\",\"tv_exchange\":\"' + exchange + '\",\"tv_instrument\":\"' + BTC_TRADE_TICKER + '\",\"action\":\"enter_long\",\"bot_uuid\":\"' + bot_uuid + '\",\"order\":{\"amount\":\"' + str.tostring(buyAmount) + '\",\"currency_type\":\"quote\",\"order_type\":\"market\"}}'\r\n        alert(buyJson, alert.freq_once_per_bar_close)\r\n\r\n// === SELL LOGIC ===\r\nsell1Cond = strategy.position_size > 0 and riskMetric >= sellL1_thresh and not sellL1_done\r\nsell2Cond = strategy.position_size > 0 and riskMetric >= sellL2_thresh and sellL1_done and not sellL2_done\r\nsell3Cond = strategy.position_size > 0 and riskMetric >= sellL3_thresh and sellL2_done and not sellL3_done\r\n\r\nif sell1Cond\r\n    strategy.close(\"BUY\", qty_percent=sellL1_pct, comment=\"SELL L1\")\r\n    label.new(bar_index, riskMetric, \"SELL L1\\n\" + str.tostring(sellL1_pct) + \"%\", \r\n         style=label.style_label_down, color=color.orange, textcolor=color.white, size=size.small)\r\n    sellL1_done := true\r\n    \r\n    if use_3commas\r\n        sellJson = '{\"secret\":\"' + secret_token + '\",\"max_lag\":\"300\",\"timestamp\":\"' + str.tostring(timenow) + '\",\"trigger_price\":\"' + str.tostring(close) + '\",\"tv_exchange\":\"' + exchange + '\",\"tv_instrument\":\"' + BTC_TRADE_TICKER + '\",\"action\":\"exit_long\",\"bot_uuid\":\"' + bot_uuid + '\",\"order\":{\"amount\":\"' + str.tostring(sellL1_pct) + '\",\"currency_type\":\"position_percent\",\"order_type\":\"market\"}}'\r\n        alert(sellJson, alert.freq_once_per_bar_close)\r\n\r\nif sell2Cond\r\n    strategy.close(\"BUY\", qty_percent=sellL2_pct, comment=\"SELL L2\")\r\n    label.new(bar_index, riskMetric, \"SELL L2\\n\" + str.tostring(sellL2_pct) + \"%\", \r\n         style=label.style_label_down, color=color.red, textcolor=color.white, size=size.small)\r\n    sellL2_done := true\r\n    \r\n    if use_3commas\r\n        sellJson = '{\"secret\":\"' + secret_token + '\",\"max_lag\":\"300\",\"timestamp\":\"' + str.tostring(timenow) + '\",\"trigger_price\":\"' + str.tostring(close) + '\",\"tv_exchange\":\"' + exchange + '\",\"tv_instrument\":\"' + BTC_TRADE_TICKER + '\",\"action\":\"exit_long\",\"bot_uuid\":\"' + bot_uuid + '\",\"order\":{\"amount\":\"' + str.tostring(sellL2_pct) + '\",\"currency_type\":\"position_percent\",\"order_type\":\"market\"}}'\r\n        alert(sellJson, alert.freq_once_per_bar_close)\r\n\r\nif sell3Cond\r\n    strategy.close(\"BUY\", qty_percent=sellL3_pct, comment=\"SELL L3\")\r\n    label.new(bar_index, riskMetric, \"SELL L3\\n\" + str.tostring(sellL3_pct) + \"%\", \r\n         style=label.style_label_down, color=color.maroon, textcolor=color.white, size=size.small)\r\n    sellL3_done := true\r\n    \r\n    if use_3commas\r\n        sellJson = '{\"secret\":\"' + secret_token + '\",\"max_lag\":\"300\",\"timestamp\":\"' + str.tostring(timenow) + '\",\"trigger_price\":\"' + str.tostring(close) + '\",\"tv_exchange\":\"' + exchange + '\",\"tv_instrument\":\"' + BTC_TRADE_TICKER + '\",\"action\":\"exit_long\",\"bot_uuid\":\"' + bot_uuid + '\",\"order\":{\"amount\":\"' + str.tostring(sellL3_pct) + '\",\"currency_type\":\"position_percent\",\"order_type\":\"market\"}}'\r\n        alert(sellJson, alert.freq_once_per_bar_close)\r\n\r\n// === COLOR-CODED PLOTTING (matching original) ===\r\nvar colorway = color.white\r\n\r\nif (riskMetric >= 0.8) \r\n    colorway := color.white\r\nelse if (riskMetric >= 0.65) \r\n    colorway := color.red\r\nelse if (riskMetric >= 0.5) \r\n    colorway := color.orange\r\nelse if (riskMetric >= 0.35) \r\n    colorway := color.yellow\r\nelse if (riskMetric >= 0.2) \r\n    colorway := color.rgb(21, 255, 0) \r\nelse if (riskMetric >= 0.0) \r\n    colorway := color.rgb(255, 255, 255)\r\n\r\nriskMetricPlot = plot(riskMetric, title=\"Risk Metric\", color=colorway, linewidth=1, display=display.all)\r\n\r\n// === HORIZONTAL THRESHOLD PLOTS (hidden by default) ===\r\ni_plot = plot(0.9, color=color.new(color.white, 100), linewidth=1, display=display.none)\r\nh_plot = plot(0.8, color=color.new(color.white, 100), linewidth=1, display=display.none)\r\ng_plot = plot(0.7, color=color.new(color.white, 100), linewidth=1, display=display.none)\r\nf_plot = plot(0.6, color=color.new(color.white, 100), linewidth=1, display=display.none)\r\nneutral_plot = plot(0.5, color=color.new(color.yellow, 100), linewidth=1, display=display.none)\r\nd_plot = plot(0.4, color=color.new(color.white, 100), linewidth=1, display=display.none)\r\nc_plot = plot(0.3, color=color.new(color.white, 100), linewidth=1, display=display.none)\r\nb_plot = plot(0.2, color=color.new(color.green, 100), linewidth=1, display=display.none)\r\na_plot = plot(0.1, color=color.new(color.white, 100), linewidth=1, display=display.none)\r\nsell_plot = plot(0.8, color=color.new(color.red, 100), linewidth=1, display=display.none)\r\nbuy_plot = plot(0.2, color=color.new(color.green, 100), linewidth=1, display=display.none)\r\n\r\n// === BACKGROUND FILLS (matching original) ===\r\nallinColor = riskMetric < 0.1 ? color.new(color.green, 0) : na\r\nbullColor = riskMetric < 0.2 ? color.new(color.green, 60) : na\r\nyellow = riskMetric > 0.2 ? color.new(color.yellow, 50) : na\r\norange = riskMetric < 0.8 ? color.new(color.orange, 50) : na\r\nbearColor = riskMetric > 0.8 ? color.new(color.red, 60) : na\r\nalloutColor = riskMetric > 0.9 ? color.new(color.red, 0) : na\r\n\r\nfill(riskMetricPlot, a_plot, color=allinColor)\r\nfill(riskMetricPlot, buy_plot, color=bullColor)\r\nfill(riskMetricPlot, sell_plot, color=bearColor)\r\nfill(riskMetricPlot, i_plot, color=alloutColor)\r\n\r\n// Custom buy/sell threshold lines (thinnest, dashed, 100% opacity)\r\nplot(buyL1_thresh, \"Buy L1\", color=color.new(color.yellow, 0), linewidth=1, style=plot.style_linebr)\r\nplot(buyL2_thresh, \"Buy L2\", color=color.new(color.lime, 0), linewidth=1, style=plot.style_linebr)\r\nplot(buyL3_thresh, \"Buy L3\", color=color.new(color.green, 0), linewidth=1, style=plot.style_linebr)\r\nplot(sellL1_thresh, \"Sell L1\", color=color.new(color.orange, 0), linewidth=1, style=plot.style_linebr)\r\nplot(sellL2_thresh, \"Sell L2\", color=color.new(color.red, 0), linewidth=1, style=plot.style_linebr)\r\nplot(sellL3_thresh, \"Sell L3\", color=color.new(color.maroon, 0), linewidth=1, style=plot.style_linebr)"
  },
  {
    "url": "r06oBNid",
    "name": "Estrategia Infalible Futuros Supertrend+RSI+EMAS+VWAP (30m) ",
    "description": "Estrategia para futuros especialmente enfocada en MBT",
    "image_url": "r06oBNid",
    "author": "jaimezura",
    "likes": 23,
    "comments_count": 3,
    "script_type": "strategy",
    "created": "2025-12-10",
    "updated": "2025-12-10",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// Â© jaimezura\r\n//2025-09-05 07:18\r\n//@version=5\r\nstrategy(\"VWAP+RSI+Supertrend+ADX - FINAL 50% TARGET (v2.0)\", overlay=true,\r\n     initial_capital = 100000,\r\n     default_qty_type = strategy.percent_of_equity,\r\n     pyramiding = 2,\r\n     commission_value = 0)\r\n\r\n// ... (INPUTS, INDICADORES, FILTROS Y CONDICIONES se mantienen iguales) ...\r\n// AsegÃºrate de copiar todo el bloque de INPUTS, INDICADORES (con ADX manual) y FILTROS/CONDICIONES del cÃ³digo anterior.\r\n\r\n// =========================\r\n// ------ INDICADORES (Bloque completo con ADX manual) -------\r\n// =========================\r\n\r\n// Detectar tipos de sÃ­mbolos\r\nsymbol = syminfo.ticker\r\n\r\nis_mbt   = symbol == \"MBT1!\"\r\nis_sil   = symbol == \"SIL1!\"\r\nis_gol   = symbol == \"MGC1!\"\r\nis_mnq   = symbol == \"MNQ1!\"\r\nis_mes   = symbol == \"MES1!\"\r\nis_6e    = symbol == \"6E1!\"\r\nis_6a    = symbol == \"6A1!\"\r\nis_6b    = symbol == \"6B1!\"\r\nis_mng   = symbol == \"MNG1!\"\r\nis_m2k   = symbol == \"M2K1!\"\r\n\r\nint rsiEntry=if is_mbt\r\n    input.int(53, \"RSI entry threshold (Giro)\")\r\nelse if is_sil\r\n    input.int(55, \"RSI entry threshold (Giro)\")\r\nelse if is_sil\r\n    input.int(55, \"RSI entry threshold (Giro)\") \r\nelse if is_gol\r\n    input.int(55, \"RSI entry threshold (Giro)\")\r\nelse if is_mnq\r\n    input.int(55, \"RSI entry threshold (Giro)\")\r\nelse if is_mes\r\n    input.int(55, \"RSI entry threshold (Giro)\")\r\nelse if is_6e\r\n    input.int(55, \"RSI entry threshold (Giro)\")\r\nelse if is_6a\r\n    input.int(55, \"RSI entry threshold (Giro)\")\r\nelse if is_6b\r\n    input.int(55, \"RSI entry threshold (Giro)\")\r\nelse if is_mng\r\n    input.int(58, \"RSI entry threshold (Giro)\")\r\nelse if is_m2k\r\n    input.int(55, \"RSI entry threshold (Giro)\")\r\nelse\r\n    input.int(55, \"RSI entry threshold (Giro)\")\r\n\r\nfloat stFactor=if is_mbt\r\n    input.float(1.2, \"Supertrend Factor (OPTIMIZADO: MÃ¡s lento para Cortos)\")\r\nelse if is_sil\r\n    input.float(1.2, \"Supertrend Factor (OPTIMIZADO: MÃ¡s lento para Cortos)\")\r\nelse if is_sil\r\n    input.float(1.2, \"Supertrend Factor (OPTIMIZADO: MÃ¡s lento para Cortos)\")\r\nelse if is_gol\r\n    input.float(1.2, \"Supertrend Factor (OPTIMIZADO: MÃ¡s lento para Cortos)\")\r\nelse if is_mnq\r\n    input.float(1.2, \"Supertrend Factor (OPTIMIZADO: MÃ¡s lento para Cortos)\")\r\nelse if is_mes\r\n    input.float(1.2, \"Supertrend Factor (OPTIMIZADO: MÃ¡s lento para Cortos)\")\r\nelse if is_6e\r\n    input.float(1.2, \"Supertrend Factor (OPTIMIZADO: MÃ¡s lento para Cortos)\")\r\nelse if is_6a\r\n    input.float(1.2, \"Supertrend Factor (OPTIMIZADO: MÃ¡s lento para Cortos)\")\r\nelse if is_6b\r\n    input.float(1.2, \"Supertrend Factor (OPTIMIZADO: MÃ¡s lento para Cortos)\")\r\nelse if is_mng\r\n    input.float(1.2, \"Supertrend Factor (OPTIMIZADO: MÃ¡s lento para Cortos)\")\r\nelse if is_m2k\r\n    input.float(1.2, \"Supertrend Factor (OPTIMIZADO: MÃ¡s lento para Cortos)\")\r\nelse\r\n    input.float(1.2, \"Supertrend Factor (OPTIMIZADO: MÃ¡s lento para Cortos)\")\r\n\r\natrPeriod = input.int(8, \"ATR Period\")\r\n//stFactor = input.float(1.2, \"Supertrend Factor (OPTIMIZADO: MÃ¡s lento para Cortos)\") // AJUSTE CLAVE\r\nrsiPeriod = input.int(14, \"RSI Period\")\r\nemaLen = input.int(9, \"EMA 9 length\")\r\nemaLenLong = input.int(18, \"EMA 18 length\")\r\nadxPeriod = input.int(10, \"ADX Period\")\r\n//int rsiEntry = input.int(53, \"RSI entry threshold (Giro)\")\r\nadxThreshold = input.float(19.89, \"ADX Min. Strength Threshold\")\r\nmaxVWAPDist = input.float(1.72, \"MÃ¡x. Dist. VWAP (%)\")\r\nminBarRange = input.float(0.141, \"MÃ­n. Bar Range (%)\")\r\nsessionStart = input.string(\"0000-2359\", \"Trading Session (02:00-22:00 UTC)\")\r\n\r\n// --- Variables y Filtros ---\r\ninSession = time(timeframe.period, sessionStart)\r\nvwapLine = ta.vwap\r\nrsi = ta.rsi(close, rsiPeriod)\r\n[stVal, stDir] = ta.supertrend(stFactor, atrPeriod)\r\natr = ta.atr(atrPeriod)\r\nemaFast = ta.ema(close, emaLen)\r\nemaLong = ta.ema(close, emaLenLong)\r\n\r\n// CÃLCULO MANUAL DEL ADX\r\nup = high - high[1]\r\ndown = low[1] - low\r\nplusDM = (up > down and up > 0) ? up : 0\r\nminusDM = (down > up and down > 0) ? down : 0\r\nplusDI = 109* ta.ema(plusDM, adxPeriod) / ta.ema(atr, adxPeriod)\r\nminusDI = 100 * ta.ema(minusDM, adxPeriod) / ta.ema(atr, adxPeriod)\r\nadxValue = ta.ema(math.abs(plusDI - minusDI) / (plusDI + minusDI == 0 ? 1 : plusDI + minusDI) * 100, adxPeriod)\r\n\r\n// CONDICIONES (Asumidas correctas)\r\ndistPerc = math.abs(close - vwapLine) / vwapLine * 100\r\ndistOK = distPerc <= maxVWAPDist \r\nbarRangePerc = (high - low) / close * 100\r\nrangeOK = barRangePerc >= minBarRange\r\natrRel = atr / close * 100\r\nminAtrRel = 0.05\r\nvolOK = atrRel >= minAtrRel\r\nrsiTurnUp = rsi[1] <= rsiEntry and rsi > rsiEntry \r\nrsiTurnDown = rsi[1] >= (100 - rsiEntry) and rsi < (100 - rsiEntry) \r\n\r\nlongCond = inSession and distOK and rangeOK and volOK and (adxValue > adxThreshold) and (close > vwapLine) and (stDir < 0) and rsiTurnUp and (close > emaFast) and (close > emaLong)\r\nshortCond = inSession and distOK and rangeOK and volOK and (adxValue > adxThreshold) and (close < vwapLine) and (stDir > 0) and rsiTurnDown and (close < emaFast) and (close < emaLong)\r\n\r\n\r\n// =========================\r\n// ----- GESTIÃ“N DE RIESGO DE DOS TIEMPOS (OPTIMIZADA) -------\r\n// =========================\r\n\r\nrisk_unit = atr * 0.97 // Stop Loss de 1.0x ATR (Riesgo base)\r\ntp1_mult = 1.6 // OPTIMIZADO: TP1 a 1.2x ATR (Salida RÃ¡pida para mÃ¡xima tasa de acierto)\r\ntp2_mult = 2.5 // OPTIMIZADO: TP2 a 2.5x ATR (Objetivo realista)\r\ntrail_points_mult = 0.1 // OPTIMIZADO: Trailing Stop muy ajustado\r\n\r\n// --- CÃLCULO de Precios ---\r\nlongSL = close - risk_unit\r\nlongTP1 = close + (atr * tp1_mult)*6\r\nlongTP2 = close + (atr * tp2_mult)*6\r\n\r\nshortSL = close + risk_unit\r\nshortTP1 = close - atr * tp1_mult*6\r\nshortTP2 = close - atr * tp2_mult*6\r\n\r\n// =========================\r\n// ----- ENTRADAS Y SALIDAS -------\r\n// =========================\r\nif (is_mbt)\r\n    if longCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"L1\", strategy.long, qty=10, stop=longSL)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"L2\", strategy.long, qty=10, stop=longSL)\r\n\r\n    if shortCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"S1\", strategy.short, qty=10, stop=shortSL)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"S2\", strategy.short, qty=10, stop=shortSL)\r\nif (is_gol)\r\n    if longCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"L12\", strategy.long, qty=10, stop=longSL)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"L2\", strategy.long, qty=10, stop=longSL)\r\n\r\n    if shortCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"S1\", strategy.short, qty=10, stop=shortSL*0.99)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"S2\", strategy.short, qty=10, stop=shortSL*0.99)\r\nif (is_sil)\r\n    if longCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"L12\", strategy.long, qty=10, stop=longSL)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"L2\", strategy.long, qty=10, stop=longSL)\r\n\r\n    if shortCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"S1\", strategy.short, qty=10, stop=shortSL*0.912)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"S2\", strategy.short, qty=10, stop=shortSL*0.9749)\r\nif (is_mnq)\r\n    if longCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"L12\", strategy.long, qty=5, stop=longSL)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"L2\", strategy.long, qty=5, stop=longSL)\r\n\r\n    if shortCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"S1\", strategy.short, qty=5, stop=shortSL*0.989)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"S2\", strategy.short, qty=5, stop=shortSL*0.989)\r\nif (is_mes)\r\n    if longCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"L12\", strategy.long, qty=5, stop=longSL)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"L2\", strategy.long, qty=5, stop=longSL)\r\n\r\n    if shortCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"S1\", strategy.short, qty=5, stop=shortSL*0.909)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"S2\", strategy.short, qty=5, stop=shortSL*0.909)\r\nif (is_6e)\r\n    if longCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"L12\", strategy.long, qty=5, stop=longSL)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"L2\", strategy.long, qty=5, stop=longSL)\r\n\r\n    if shortCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"S1\", strategy.short, qty=5, stop=shortSL*0.99)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"S2\", strategy.short, qty=5, stop=shortSL*0.99)\r\nif (is_6a)\r\n    if longCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"L12\", strategy.long, qty=5, stop=longSL*1.0009)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"L2\", strategy.long, qty=5, stop=longSL*1.0009)\r\n\r\n    if shortCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"S1\", strategy.short, qty=5, stop=shortSL*1)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"S2\", strategy.short, qty=5, stop=shortSL*1)\r\nif (is_6b)\r\n    if longCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"L12\", strategy.long, qty=5, stop=longSL*1)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"L2\", strategy.long, qty=5, stop=longSL*1)\r\n\r\n    if shortCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"S1\", strategy.short, qty=5, stop=shortSL*1)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"S2\", strategy.short, qty=5, stop=shortSL*1)\r\nif (is_mng)\r\n    if longCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"L12\", strategy.long, qty=20, stop=longSL*1)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"L2\", strategy.long, qty=20, stop=longSL*1)\r\n\r\n    if shortCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"S1\", strategy.short, qty=50, stop=shortSL*0.88)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"S2\", strategy.short, qty=50, stop=shortSL*1)\r\nif (is_m2k)\r\n    if longCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"L12\", strategy.long, qty=5, stop=longSL*1)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"L2\", strategy.long, qty=5, stop=longSL*1)\r\n\r\n    if shortCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"S1\", strategy.short, qty=5, stop=shortSL*0.982)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"S2\", strategy.short, qty=5, stop=shortSL*0.982)\r\n        \r\n// Entrada: Tomamos una posiciÃ³n completa con dos Ã³rdenes separadas\r\n\r\n// 1. GESTIÃ“N DE SALIDA RÃPIDA (TP1)\r\n// Cierra la mitad de la posiciÃ³n a 1.2x ATR (Asegura R:B > 1)\r\nstrategy.exit(\"TP1 Long\", from_entry=\"L1\", limit=longTP1, stop=longSL)\r\nstrategy.exit(\"TP1 Short\", from_entry=\"S1\", limit=shortTP1, stop=shortSL)\r\n\r\n\r\n// 2. GESTIÃ“N DE LA SEGUNDA PARTE (TP2, alto objetivo + Trailing Stop)\r\n// Esta orden gestiona el 50% restante con Trailing Stop ajustado.\r\nstrategy.exit(\"TP2/Trail Long\", from_entry=\"L2\", limit=longTP2, stop=longSL, trail_points=atr * trail_points_mult)\r\nstrategy.exit(\"TP2/Trail Short\", from_entry=\"S2\", limit=shortTP2, stop=shortSL, trail_points=atr * trail_points_mult)\r\n\r\n\r\n// 3. BREAK EVEN (ProtecciÃ³n de TP2 despuÃ©s de alcanzar TP1)\r\n// Usamos el estado de la posiciÃ³n reducida para saber si TP1 fue tocado.\r\nlongPosOpen = strategy.position_size > 0\r\nshortPosOpen = strategy.position_size < 0\r\n\r\n// Si la posiciÃ³n se redujo (TP1 tocado) y aÃºn hay posiciÃ³n abierta...\r\nif longPosOpen and strategy.position_size[1] > strategy.position_size \r\n    // Mover el SL de L2 (o lo que quede) al punto de entrada + buffer (0.10 ATR)\r\n    strategy.exit(\"BE L2\", from_entry=\"L2\", stop=strategy.position_avg_price + atr * 0.10)\r\n\r\nif shortPosOpen and strategy.position_size[1] < strategy.position_size\r\n    // Mover el SL de S2 (o lo que quede) al punto de entrada - buffer\r\n    strategy.exit(\"BE S2\", from_entry=\"S2\", stop=strategy.position_avg_price - atr * 0.10)\r\n\r\n\r\n// 4. Salida por cambio de Supertrend (Cierra todo lo que quede)\r\nif longPosOpen and stDir > 0\r\n    strategy.close_all(comment=\"ST Trend Rev\")\r\nif shortPosOpen and stDir < 0\r\n    strategy.close_all(comment=\"ST Trend Rev\")\r\n\r\n// ... (PLOTS & INFO se mantienen iguales) ...\r\n// =========================\r\n// ----- PLOTS & INFO -------\r\n// =========================\r\n//plot(vwapLine, title=\"VWAP\", color=color.blue, linewidth=2)\r\nstColor = stDir < 0 ? color.lime : color.red\r\nplot(stVal, title=\"Supertrend\", color = stColor, linewidth=2)\r\nplot(emaLen ? emaFast : na, title=\"EMA Trend Filter (20)\", color=color.orange, linewidth=1)\r\nplot(emaLenLong ? emaLong : na, title=\"EMA Trend Filter (200)\", color=color.white, linewidth=2)\r\n//plotshape(longCond, title=\"LongSignal\", style=shape.triangleup, location=location.belowbar, color=color.green, size=size.small)\r\n//plotshape(shortCond, title=\"ShortSignal\", style=shape.triangledown, location=location.abovebar, color=color.red, size=size.small)\r\n"
  },
  {
    "url": "yq0cDVGO-Hash-Ratings-Engine",
    "name": "Hash Ratings Engine",
    "description": "Hash Ratings Engine - Technical Consensus Strategy \nA systematic trading strategy that harnesses TradingView's Technical Ratings to generate high-conviction entries with institutional-grade risk management.\n\n What It Does \nThis strategy aggregates the consensus of 26+ technical indicators (RSI, MACD, Stochastics, multiple Moving Averages, etc.) into a single actionable signal. When enough indicators align bullish or bearish, the engine triggers an entry. Built-in trend filtering and ATR-based exits keep you on the right side of the market.\n\n Key Features \n Trend Filter  - Only takes longs in uptrends, shorts in downtrends. This single filter typically improves results by 20-40% by avoiding counter-trend trades.\n ATR-Based Risk Management  - Stop loss and trailing stops adapt to current market volatility. Tight stops in calm markets, wider stops in volatile conditions.\n Cooldown System  - After a losing trade, the strategy waits before re-entering. This prevents the consecutive loss streaks that destroy accounts.\n Clean Visuals  - Fluorescent entry/exit signals with price level references. See exactly where you got in and out.\n\n Settings Guide \n Indicator Timeframe:  Leave blank for current chart. Use higher timeframe for fewer, higher-quality signals.\n Rating Source:  \"All\" for balanced approach. \"MAs\" for trend-following. \"Oscillators\" for mean-reversion.\n\n Entry Thresholds \n Strong Signal Threshold:  Higher = fewer trades but better conviction. Start at 0.5, test 0.4-0.6.\n\n Risk Management \n ATR Period:  12 is responsive, 14 is standard, 20+ is smoother.\n Stop Loss:  2-3x ATR for tight stops, 3.5-4x for moderate, 5x+ for wide.\n Trail Activation:  How far price must move in profit before trailing begins.\n Trail Offset:  How closely the trail follows price.\n \nTrend Filter \n EMA Length:  150 works well on 4H charts. Use 100 for lower timeframes, 200 for daily.\n\n Trade Timing \n Cooldown:  Keep enabled. 5 bars is a good starting point.\n\n Best Practices \nStart with default settings and backtest on your preferred instrument. Adjust the Strong Signal Threshold first - this has the biggest impact on trade frequency. Then tune the EMA length to match your timeframe. Finally, optimize the ATR multipliers for your risk tolerance.\nWorks on any liquid market - crypto, forex, stocks, futures. Higher timeframes (4H, Daily) tend to produce cleaner signals than lower timeframes.\n\n Disclaimer \nPast performance does not guarantee future results. Always backtest thoroughly and use proper position sizing. This strategy is for educational purposes - trade at your own risk.\n",
    "image_url": "yq0cDVGO",
    "author": "Hash_Capital",
    "likes": 52,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-10",
    "updated": "2025-12-10",
    "source": "//@version=6\r\nstrategy(title=\"Hash Ratings Engine\", shorttitle=\"HRE\", default_qty_type=strategy.percent_of_equity, default_qty_value=5, overlay=true, pyramiding=0, calc_on_every_tick=false, initial_capital=100000, commission_type=strategy.commission.percent, commission_value=0.1)\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•  HASH CAPITAL RESEARCH  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// Hash Ratings Engine - Technical Consensus Strategy\r\n// Optimized for high profit factor, win rate, and reduced drawdown\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n\r\nimport TradingView/TechnicalRating/3 as rating\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// FLUORESCENT COLOR PALETTE\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\nvar color fluorescentGreen  = #00FF41\r\nvar color fluorescentRed    = #FF073A\r\nvar color fluorescentCyan   = #00FFFF\r\nvar color fluorescentCyan50 = color.new(#00FFFF, 50)\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// INPUT GROUPS\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\nstring grp_signal   = \"Signal Settings\"\r\nstring grp_entry    = \"Entry Thresholds\"\r\nstring grp_risk     = \"Risk Management\"\r\nstring grp_trend    = \"Trend Filter\"\r\nstring grp_timing   = \"Trade Timing\"\r\nstring grp_visual   = \"Visuals\"\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// SIGNAL SETTINGS\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\nstring tip_timeframe = \"Timeframe for rating calculation.\\n\\n\" +\r\n     \"TUNING:\\n\" +\r\n     \"â€¢ Blank = current chart timeframe\\n\" +\r\n     \"â€¢ Higher TF (e.g., 'D' on 4H chart) = fewer signals, higher conviction\\n\" +\r\n     \"â€¢ Lower TF = more signals, more noise\\n\\n\" +\r\n     \"RECOMMENDATION: Start with blank, then try 1 step higher if too many signals.\"\r\n\r\nstring tip_source = \"Which indicators to base signals on.\\n\\n\" +\r\n     \"TUNING:\\n\" +\r\n     \"â€¢ MAs = trend-following bias, better in trending markets\\n\" +\r\n     \"â€¢ Oscillators = mean-reversion bias, better in ranging markets\\n\" +\r\n     \"â€¢ All = balanced approach, works in most conditions\\n\\n\" +\r\n     \"RECOMMENDATION: Use 'All' for most cases. Use 'MAs' in strong trends.\"\r\n\r\nres = input.timeframe(\"\", title=\"Indicator Timeframe\", tooltip=tip_timeframe, group=grp_signal)\r\nratingSignal = input.string(defval=\"All\", title=\"Rating Source\", options=[\"MAs\", \"Oscillators\", \"All\"], tooltip=tip_source, group=grp_signal)\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// ENTRY THRESHOLDS\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\nstring tip_strong = \"Minimum rating to trigger entry. Rating ranges from -1 (strong sell) to +1 (strong buy).\\n\\n\" +\r\n     \"TUNING:\\n\" +\r\n     \"â€¢ 0.3 = more signals, lower conviction, higher win count but more losers\\n\" +\r\n     \"â€¢ 0.5 = balanced (default), good starting point\\n\" +\r\n     \"â€¢ 0.7 = fewer signals, higher conviction, better win rate but fewer trades\\n\\n\" +\r\n     \"OPTIMIZATION: Backtest 0.4, 0.5, 0.6 and compare profit factors.\"\r\n\r\nstring tip_weak = \"Secondary threshold for signal strength classification. Used for visual feedback only.\\n\\n\" +\r\n     \"Not currently used for trade logic but available for future enhancements.\"\r\n\r\nstrongBound = input.float(defval=0.5, title=\"Strong Signal Threshold\", minval=0.1, maxval=0.9, step=0.05, tooltip=tip_strong, group=grp_entry)\r\nweakBound   = input.float(defval=0.1, title=\"Weak Signal Threshold\", minval=0.0, maxval=0.5, step=0.05, tooltip=tip_weak, group=grp_entry)\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// RISK MANAGEMENT\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\nstring tip_atr = \"Lookback period for ATR (Average True Range) calculation.\\n\\n\" +\r\n     \"TUNING:\\n\" +\r\n     \"â€¢ 7-10 = more responsive to recent volatility, tighter stops\\n\" +\r\n     \"â€¢ 12 = slightly faster than standard (default)\\n\" +\r\n     \"â€¢ 20-30 = smoother, wider stops, less reactive\\n\\n\" +\r\n     \"RECOMMENDATION: 12-14 works well for most timeframes.\"\r\n\r\nstring tip_sl = \"Stop loss distance as multiple of ATR.\\n\\n\" +\r\n     \"TUNING:\\n\" +\r\n     \"â€¢ 1.5-2.0 = tight stops, more stops hit, smaller losses per trade\\n\" +\r\n     \"â€¢ 2.5-3.5 = moderate (default 3.5), good balance\\n\" +\r\n     \"â€¢ 4.0-5.0 = wide stops, fewer stops hit, larger losses when hit\\n\\n\" +\r\n     \"OPTIMIZATION: Tighter stops improve win rate but may reduce profit factor. Test 2.0, 3.0, 4.0.\"\r\n\r\nstring tip_trail = \"Profit distance before trailing stop activates (ATR multiple).\\n\\n\" +\r\n     \"TUNING:\\n\" +\r\n     \"â€¢ 3.0-4.0 = trail activates quickly, locks profit early, may exit winners too soon\\n\" +\r\n     \"â€¢ 5.0-6.0 = moderate (default 5.5), lets winners develop\\n\" +\r\n     \"â€¢ 7.0-10.0 = patient, lets big winners run, may give back more profit\\n\\n\" +\r\n     \"RECOMMENDATION: Should be larger than SL multiplier.\"\r\n\r\nstring tip_offset = \"How far behind price the trailing stop follows (ATR multiple).\\n\\n\" +\r\n     \"TUNING:\\n\" +\r\n     \"â€¢ 1.0-1.5 = tight trail, locks in more profit, may exit on normal pullbacks\\n\" +\r\n     \"â€¢ 2.0-3.0 = moderate (default 2.0), allows breathing room\\n\" +\r\n     \"â€¢ 3.5-5.0 = loose trail, rides trends longer, gives back more on reversals\\n\\n\" +\r\n     \"RECOMMENDATION: Typically 40-60% of trail activation value.\"\r\n\r\natrPeriod       = input.int(defval=12, title=\"ATR Period\", minval=5, maxval=50, tooltip=tip_atr, group=grp_risk)\r\nslMultiplier    = input.float(defval=3.5, title=\"Stop Loss (ATRÃ—)\", minval=0.5, maxval=10.0, step=0.5, tooltip=tip_sl, group=grp_risk)\r\ntrailMultiplier = input.float(defval=5.5, title=\"Trail Activation (ATRÃ—)\", minval=1.0, maxval=15.0, step=0.5, tooltip=tip_trail, group=grp_risk)\r\ntrailOffset     = input.float(defval=2.0, title=\"Trail Offset (ATRÃ—)\", minval=0.5, maxval=10.0, step=0.5, tooltip=tip_offset, group=grp_risk)\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// TREND FILTER\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\nstring tip_trend_enable = \"Filter trades by trend direction using EMA.\\n\\n\" +\r\n     \"TUNING:\\n\" +\r\n     \"â€¢ ON = only longs above EMA, only shorts below EMA\\n\" +\r\n     \"â€¢ OFF = take signals regardless of trend\\n\\n\" +\r\n     \"RECOMMENDATION: Keep ON. This single filter typically improves profit factor 20-40% by avoiding counter-trend trades.\"\r\n\r\nstring tip_trend_len = \"EMA length for trend determination.\\n\\n\" +\r\n     \"TUNING:\\n\" +\r\n     \"â€¢ 50-100 = shorter-term trend, more responsive, more trades\\n\" +\r\n     \"â€¢ 150 = balanced (default), good for 4H and daily\\n\" +\r\n     \"â€¢ 200-300 = institutional standard, very reliable but slower\\n\\n\" +\r\n     \"OPTIMIZATION: Test 100, 150, 200. Shorter works better on lower TFs.\"\r\n\r\nuseTrendFilter = input.bool(defval=true, title=\"Enable Trend Filter\", tooltip=tip_trend_enable, group=grp_trend)\r\ntrendEmaLength = input.int(defval=150, title=\"Trend EMA Length\", minval=20, maxval=500, step=10, tooltip=tip_trend_len, group=grp_trend)\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// TRADE TIMING\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\nstring tip_time_enable = \"Restrict trading to specific hours.\\n\\n\" +\r\n     \"TUNING:\\n\" +\r\n     \"â€¢ ON = only trade during specified hours (exchange time)\\n\" +\r\n     \"â€¢ OFF = trade 24/7\\n\\n\" +\r\n     \"USE CASE: Avoid Asian session on US equities, or avoid weekends on crypto.\"\r\n\r\nstring tip_cooldown_enable = \"Wait period after a losing trade before new entries.\\n\\n\" +\r\n     \"TUNING:\\n\" +\r\n     \"â€¢ ON = prevents rapid re-entry after stops, reduces consecutive losses\\n\" +\r\n     \"â€¢ OFF = can re-enter immediately\\n\\n\" +\r\n     \"RECOMMENDATION: Keep ON. Prevents the 'revenge trading' pattern where you get stopped, re-enter immediately, and get stopped again.\"\r\n\r\nstring tip_cooldown_bars = \"Number of bars to wait after a stop loss.\\n\\n\" +\r\n     \"TUNING:\\n\" +\r\n     \"â€¢ 3-5 = short cooldown, quick recovery\\n\" +\r\n     \"â€¢ 5-10 = moderate (default 5), lets dust settle\\n\" +\r\n     \"â€¢ 10-20 = conservative, waits for new setup to develop\\n\\n\" +\r\n     \"Scale with timeframe: use higher values on lower TFs.\"\r\n\r\nuseTimeFilter  = input.bool(defval=false, title=\"Enable Time Filter\", tooltip=tip_time_enable, group=grp_timing)\r\nsessionStart   = input.int(defval=9, title=\"Session Start Hour\", minval=0, maxval=23, group=grp_timing)\r\nsessionEnd     = input.int(defval=16, title=\"Session End Hour\", minval=0, maxval=23, group=grp_timing)\r\n\r\nuseCooldown    = input.bool(defval=true, title=\"Enable Cooldown After Stop\", tooltip=tip_cooldown_enable, group=grp_timing)\r\ncooldownBars   = input.int(defval=5, title=\"Cooldown Bars\", minval=1, maxval=25, tooltip=tip_cooldown_bars, group=grp_timing)\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// VISUAL SETTINGS\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\nshowTrendEma   = input.bool(defval=true, title=\"Show Trend EMA\", group=grp_visual)\r\nshowSignals    = input.bool(defval=true, title=\"Show Entry/Exit Signals\", group=grp_visual)\r\nshowLevels     = input.bool(defval=true, title=\"Show Entry/Exit Levels\", group=grp_visual)\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// CORE CALCULATIONS\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n\r\n// Fetch technical ratings\r\n[ratingTotal, ratingOther, ratingMA] = request.security(syminfo.tickerid, res, rating.calcRatingAll())\r\n\r\n// Select rating source\r\ngetSignal(float total, float oscillators, float mas) =>\r\n    switch ratingSignal\r\n        \"MAs\"         => mas\r\n        \"Oscillators\" => oscillators\r\n        => total\r\n\r\ntradeSignal = getSignal(ratingTotal, ratingOther, ratingMA)\r\n\r\n// Trend filter\r\ntrendEma = ta.ema(close, trendEmaLength)\r\naboveTrend = close > trendEma\r\nbelowTrend = close < trendEma\r\n\r\n// ATR for risk management\r\natrValue = ta.atr(atrPeriod)\r\n\r\n// Convert ATR to points\r\ndynSLpoints(float factor) => \r\n    atrValue * factor / syminfo.mintick\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// TIME FILTER\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\ncurrentHour = hour(time)\r\ninSession = useTimeFilter ? (currentHour >= sessionStart and currentHour < sessionEnd) : true\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// COOLDOWN LOGIC\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\nvar int barsSinceStop = 100\r\nvar int lastTradeCount = 0\r\n\r\nif strategy.closedtrades > lastTradeCount\r\n    lastTradeProfit = strategy.closedtrades.profit(strategy.closedtrades - 1)\r\n    if lastTradeProfit < 0\r\n        barsSinceStop := 0\r\n    lastTradeCount := strategy.closedtrades\r\n\r\nbarsSinceStop := barsSinceStop + 1\r\n\r\ncooldownActive = useCooldown and barsSinceStop <= cooldownBars\r\ncanTrade = not cooldownActive\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// ENTRY CONDITIONS\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n\r\nstrongLongSignal  = tradeSignal > strongBound\r\nstrongShortSignal = tradeSignal < -strongBound\r\n\r\ntrendLongOk  = useTrendFilter ? aboveTrend : true\r\ntrendShortOk = useTrendFilter ? belowTrend : true\r\n\r\nlongCondition  = strongLongSignal and trendLongOk and inSession and canTrade\r\nshortCondition = strongShortSignal and trendShortOk and inSession and canTrade\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// STRATEGY EXECUTION\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n\r\nif longCondition\r\n    strategy.entry(\"Long\", strategy.long)\r\n\r\nif shortCondition\r\n    strategy.entry(\"Short\", strategy.short)\r\n\r\nstrategy.exit(\"Long Exit\", from_entry=\"Long\", loss=dynSLpoints(slMultiplier), trail_points=dynSLpoints(trailMultiplier), trail_offset=dynSLpoints(trailOffset))\r\nstrategy.exit(\"Short Exit\", from_entry=\"Short\", loss=dynSLpoints(slMultiplier), trail_points=dynSLpoints(trailMultiplier), trail_offset=dynSLpoints(trailOffset))\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// POSITION TRACKING FOR VISUALS\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\nisLong  = strategy.position_size > 0\r\nisShort = strategy.position_size < 0\r\nisFlat  = strategy.position_size == 0\r\n\r\n// Entry tracking\r\nvar float entryPrice = na\r\nvar int entryBar = na\r\n\r\nif isLong and not isLong[1]\r\n    entryPrice := close\r\n    entryBar := bar_index\r\nif isShort and not isShort[1]\r\n    entryPrice := close\r\n    entryBar := bar_index\r\nif isFlat and not isFlat[1]\r\n    entryPrice := na\r\n    entryBar := na\r\n\r\n// Exit tracking with matching line length\r\nvar float exitPrice = na\r\nvar int exitBar = na\r\nvar int tradeDuration = na\r\n\r\nif isFlat and not isFlat[1]\r\n    exitPrice := close[1]\r\n    exitBar := bar_index\r\n    tradeDuration := nz(bar_index - entryBar[1], 5)\r\nelse if bar_index > exitBar + nz(tradeDuration, 5)\r\n    exitPrice := na\r\n    exitBar := na\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// VISUAL ELEMENTS\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n\r\n// Trend EMA\r\nplot(showTrendEma ? trendEma : na, title=\"Trend EMA\", color=close > trendEma ? fluorescentGreen : fluorescentRed, linewidth=2)\r\n\r\n// Entry signals\r\nlongEntry  = isLong and not isLong[1]\r\nshortEntry = isShort and not isShort[1]\r\n\r\nplotshape(showSignals and longEntry, title=\"Long Entry\", location=location.belowbar, style=shape.circle, size=size.tiny, color=fluorescentGreen)\r\nplotshape(showSignals and shortEntry, title=\"Short Entry\", location=location.abovebar, style=shape.circle, size=size.tiny, color=fluorescentRed)\r\n\r\n// Exit signals\r\nlongExit  = isFlat and isLong[1]\r\nshortExit = isFlat and isShort[1]\r\n\r\nplotshape(showSignals and longExit, title=\"Long Exit\", location=location.abovebar, style=shape.xcross, size=size.tiny, color=fluorescentCyan)\r\nplotshape(showSignals and shortExit, title=\"Short Exit\", location=location.belowbar, style=shape.xcross, size=size.tiny, color=fluorescentCyan)\r\n\r\n// Entry price line - shows during position\r\nplot(showLevels and (isLong or isShort) ? entryPrice : na, title=\"Entry Price\", color=color.gray, linewidth=1, style=plot.style_linebr)\r\n\r\n// Exit price line - matches trade duration length\r\nplot(showLevels and not na(exitPrice) ? exitPrice : na, title=\"Exit Price\", color=fluorescentCyan50, linewidth=1, style=plot.style_linebr)\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// END OF SCRIPT\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n"
  },
  {
    "url": "ixBY1TYg-MA-Strategy-Dual-Entry-Filter",
    "name": "MA Strategy: Dual Entry Filter",
    "description": "Configurable MA Dual-Filter Strategy\nThis strategy is an enhanced and highly configurable Moving Average (MA) Crossover system designed to mitigate false signals and align trades with the prevailing market trend. It is built to offer traders granular control over entry criteria, elevating it beyond basic, built-in MA crossover indicators.\n\nOriginality & Key Features\nThe script's originality and utility lie in the combination of its two primary, optional filtering mechanics:\n\nDual Entry Mode (Key Filter): Users can choose between two distinct methods for trade entry:\n\nCrossover (Classic): Immediate entry when the price crosses the main MA.\n\nFull Candle Confirmation (Unique Feature): This mode requires the entire candle body (open, high, low, and close) to be completely above or below the main MA after a crossover event to confirm the signal before entry. This strict confirmation helps to filter out weak crossovers, reducing whipsaws in choppy markets.\n\nOptional Trend Filter: A second, slower MA (Trend Filter MA) can be activated. Trades are only permitted when the faster main MA is aligned with the slower Trend MA (i.e., long only if main MA > Trend MA), ensuring trades are executed with the established higher-timeframe direction.\n\nHow to Use the Strategy\nThe strategy logic is built on simple MA principles but utilizes Pine Script's switch function to allow users to select from six different MA types for both the main signal and the trend filter: SMA, EMA, WMA, HMA, VWMA, and RMA.\n\nCore Logic:\n\nSignal: A cross of the price over the Main MA (filtered by the chosen Entry Mode).\n\nDirectional Filter: The Trend Filter must confirm the direction (if enabled).\n\nExit: Trades are exited on the opposite price crossover of the Main MA.\n\nCustomizable Settings Include:\n\nMain MA Type & Length (Default: 40 EMA): The primary signal generator.\n\nTrend Filter MA Type & Length (Default: 70 EMA): The optional, slower trend bias.\n\nEntry Mode: Switch between Crossover or Full Candle Confirmation.\n\nStrategy Results and High-Risk Disclaimer\nThe default setting for trade size is set to 40% of equity for backtesting demonstration purposes only. This high value is used to generate a large and diverse sample size of trades for historical review on the chart.\n\nThis 40% value is NOT a recommended setting for live trading. Per TradingView guidelines, traders are strongly advised to change this input to a sustainable risk level, typically 5% to 10% of equity per trade. Past performance is not a guarantee of future results.",
    "image_url": "ixBY1TYg",
    "author": "ravi_matrix",
    "likes": 15,
    "type": "strategy",
    "created": "2025-12-09",
    "updated": "2025-12-09",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n\n// Â© ravi_matrix\n\n\n\n//@version=6\n\nstrategy('MA Strategy: Dual Entry Filter', shorttitle = 'MA Strategy', overlay = true, default_qty_type = strategy.percent_of_equity, default_qty_value = 40)\n\n\n\n// ==================== MAIN SETTINGS ====================\n\nma_type = input.string('EMA', 'Moving Average Type', options = ['SMA', 'EMA', 'WMA', 'HMA', 'VWMA', 'RMA'], group = 'MA Settings')\n\nma_length = input.int(40, 'MA Length', minval = 1, group = 'MA Settings')\n\n\n\n// ==================== TREND FILTER SETTINGS ====================\n\nuse_trend_filter = input.bool(false, 'Use Trend Filter MA', group = 'Trend Filter')\n\ntrend_ma_type = input.string('EMA', 'Trend MA Type', options = ['SMA', 'EMA', 'WMA', 'HMA', 'VWMA', 'RMA'], group = 'Trend Filter')\n\ntrend_ma_length = input.int(70, 'Trend MA Length', minval = 1, group = 'Trend Filter')\n\n\n\n// ==================== ENTRY SETTINGS ====================\n\nentry_mode = input.string('Crossover', 'Entry Mode', options = ['Crossover', 'Full Candle Confirmation'], group = 'Entry Settings')\n\nenable_long = input.bool(true, 'Enable Long Trades', group = 'Entry Settings')\n\nenable_short = input.bool(true, 'Enable Short Trades', group = 'Entry Settings')\n\n\n\n// ==================== MA CALCULATION FUNCTION ====================\n\nget_ma(source, length, ma_type) =>\n\n    switch ma_type\n\n        'SMA' => ta.sma(source, length)\n\n        'EMA' => ta.ema(source, length)\n\n        'WMA' => ta.wma(source, length)\n\n        'HMA' => ta.hma(source, length)\n\n        'VWMA' => ta.vwma(source, length)\n\n        'RMA' => ta.rma(source, length)\n\n        => ta.sma(source, length)\n\n\n\n// ==================== CALCULATE MA ====================\n\nma_value = get_ma(close, ma_length, ma_type)\n\n\n\n// Calculate Trend Filter MA\n\ntrend_ma_value = use_trend_filter ? get_ma(close, trend_ma_length, trend_ma_type) : na\n\n\n\n// Trend direction based on MA relationship\n\ntrend_is_bullish = use_trend_filter ? ma_value > trend_ma_value : true\n\ntrend_is_bearish = use_trend_filter ? ma_value < trend_ma_value : true\n\n\n\n// ==================== CROSSOVER SIGNALS ====================\n\nbullish_cross = ta.crossover(close, ma_value)\n\nbearish_cross = ta.crossunder(close, ma_value)\n\n\n\n// Price position relative to MA\n\nprice_above_ma = close > ma_value\n\nprice_below_ma = close < ma_value\n\n\n\n// ==================== FULL CANDLE CONFIRMATION ====================\n\n// Full candle above MA: open, high, low, close all above MA\n\nfull_candle_above = open > ma_value and high > ma_value and low > ma_value and close > ma_value\n\n\n\n// Full candle below MA: open, high, low, close all below MA\n\nfull_candle_below = open < ma_value and high < ma_value and low < ma_value and close < ma_value\n\n\n\n// Track if we had a crossover recently and haven't entered yet\n\nvar bool waiting_for_long = false\n\nvar bool waiting_for_short = false\n\n\n\n// Reset waiting flags if price crosses back OR if trend filter changes\n\nif bearish_cross\n\n    waiting_for_long := false\n\n    waiting_for_long\n\nif bullish_cross\n\n    waiting_for_short := false\n\n    waiting_for_short\n\n\n\n// Also reset waiting flags if trend filter condition is no longer valid\n\nif use_trend_filter\n\n    if not trend_is_bullish\n\n        waiting_for_long := false\n\n        waiting_for_long\n\n    if not trend_is_bearish\n\n        waiting_for_short := false\n\n        waiting_for_short\n\n\n\n// Entry conditions based on mode\n\nbool long_condition = false\n\nbool short_condition = false\n\n\n\nif entry_mode == 'Crossover'\n\n    long_condition := bullish_cross and enable_long and trend_is_bullish\n\n    short_condition := bearish_cross and enable_short and trend_is_bearish\n\n    short_condition\n\nelse if entry_mode == 'Full Candle Confirmation'\n\n    // Mark that we're waiting for confirmation after crossover (only if trend allows)\n\n    if bullish_cross and trend_is_bullish\n\n        waiting_for_long := true\n\n        waiting_for_long\n\n    if bearish_cross and trend_is_bearish\n\n        waiting_for_short := true\n\n        waiting_for_short\n\n\n\n    // Enter when we get a full candle above/below after crossover (and trend still valid)\n\n    long_condition := waiting_for_long and full_candle_above and enable_long and trend_is_bullish\n\n    short_condition := waiting_for_short and full_candle_below and enable_short and trend_is_bearish\n\n\n\n    // Reset flags after entry\n\n    if long_condition\n\n        waiting_for_long := false\n\n        waiting_for_long\n\n    if short_condition\n\n        waiting_for_short := false\n\n        waiting_for_short\n\n\n\n// ==================== DYNAMIC COLOR ====================\n\n// Green when price above MA, Red when price below MA\n\nma_color = price_above_ma ? color.new(#04b304, 25) : color.new(#d60303, 19)\n\n\n\n// Trend MA color - blue\n\ntrend_ma_color = color.new(#0066ff, 0)\n\n\n\n// ==================== PLOT MA ====================\n\nplot(ma_value, 'Moving Average', color = ma_color, linewidth = 1)\n\nplot(use_trend_filter ? trend_ma_value : na, 'Trend Filter MA', color = trend_ma_color, linewidth = 1)\n\n\n\n// ==================== STRATEGY EXECUTION ====================\n\n// Entry logic\n\nif long_condition\n\n    strategy.close('Short')\n\n    strategy.entry('Long', strategy.long)\n\n\n\nif short_condition\n\n    strategy.close('Long')\n\n    strategy.entry('Short', strategy.short)\n\n\n\n// Exit logic - close on opposite crossover\n\nif bearish_cross and strategy.position_size > 0\n\n    strategy.close('Long', comment = 'Exit on Crossunder')\n\n\n\nif bullish_cross and strategy.position_size < 0\n\n    strategy.close('Short', comment = 'Exit on Crossover')"
  },
  {
    "url": "isu2jsPD-Gyspy-Bot-Trade-Engine-V1-2B-Strategy-12-7-25-SignalLynx",
    "name": "Gyspy Bot Trade Engine - V1.2B - Strategy 12-7-25 - SignalLynx",
    "description": "Gypsy Bot Trade Engine (MK6 V1.2B) - Ultimate Strategy & Backtest\n\nBrought to you by Signal Lynx | Automation for the Night-Shift Nation ðŸŒ™\n\n1. Executive Summary & Architecture\n\nGypsy Bot (MK6 V1.2B) is not merely a strategy; it is a massive, modular Trade Engine built specifically for the TradingView Pine Script environment. While most strategies rely on a single dominant indicator (like an RSI cross or a MACD flip) to generate signals, Gypsy Bot functions as a sophisticated Consensus Algorithm.\n\nThe engine calculates data from up to 12 distinct Technical Analysis Modules simultaneously on every bar closing. It aggregates these signals into a \"Vote Count\" and only executes a trade entry when a user-defined threshold of concurring signals is met. This \"Voting System\" acts as a noise filter, requiring multiple independent mathematical modelsâ€”ranging from volume flow and momentum to cyclical harmonics and trend strengthâ€”to agree on market direction before capital is committed.\n\nBeyond entries, Gypsy Bot features a proprietary Risk Management suite called the Dump Protection Team (DPT). This logic layer operates independently of the entry modules, specifically scanning for \"Moon\" (Parabolic) or \"Nuke\" (Crash) volatility events to force-exit positions, overriding standard stops to preserve capital during Black Swan events.\n\n2. âš ï¸ The Philosophy of \"Curve Fitting\" (Must Read)\n\nOne must be careful when applying Gypsy Bot to new pairs or charts.\n\nTo be fully transparent: Gypsy Bot is, by definition, a very advanced curve-fitting engine. Because it grants the user granular control over 12 modules, dozens of thresholds, and specific voting requirements, it is extremely easy to \"over-fit\" the data. You can easily toggle switches until the backtest shows a 100% win rate, only to have the strategy fail immediately in live markets because it was tuned to historical noise rather than market structure.\n\nTo use this engine successfully, you must adopt a specific optimization mindset:\n\nIgnore Raw Net Profit: Do not tune for the highest dollar amount. A strategy that makes $1M in the backtest but has a 40% drawdown is useless.\n\nPrioritize Stability: Look for a high Profit Factor (1.5+), a high Percent Profitable, and a smooth equity curve.\n\nRegular Maintenance is Mandatory: Markets shift regimes (e.g., from Bull Trend to Crab Range). Parameters that worked perfectly in 2021 may fail in 2024. Gypsy Bot settings should be reviewed and adjusted at regular intervals (e.g., quarterly) to ensure the voting logic remains aligned with current market volatility.\n\nTimeframe Recommendations:\nGypsy Bot is optimized for High Time Frame (HTF) trend following. It generally produces the most reliable results on charts ranging from 1-Hour to 12-Hours, with the 4-Hour timeframe historically serving as the \"sweet spot\" for most major cryptocurrency assets.\n\n3. The Voting Mechanism: How Entries Are Generated\n\nThe heart of the Gypsy Bot engine is the ActivateOrders input (found in the \"Order Signal Modifier\" settings).\n\nThe engine constantly monitors the output of all enabled Modules.\n\nLong Votes: GoLongCount\n\nShort Votes: GoShortCount\n\nIf you have 10 Modules enabled, and you set ActivateOrders to 7:\n\nThe engine will ONLY trigger a Buy Entry if 7 or more modules return a valid \"Buy\" signal on the same closed candle.\n\nIf only 6 modules agree, the trade is rejected.\n\nThis allows you to mix \"Leading\" indicators (Oscillators) with \"Lagging\" indicators (Moving Averages) to create a high-probability entry signal that requires momentum, volume, and trend to all be in alignment.\n\n4. Technical Deep Dive: The 12 Modules\n\nGypsy Bot allows you to toggle the following modules On/Off individually to suit the asset you are trading.\n\nModule 1: Modified Slope Angle (MSA)\n\nLogic: Calculates the geometric angle of a moving average relative to the timeline.\n\nFunction: It filters out \"lazy\" trends. A trend is only considered valid if the slope exceeds a specific steepness threshold. This helps avoid entering trades during weak drifts that often precede a reversal.\n\nModule 2: Correlation Trend Indicator (CTI)\n\nLogic: Based on John Ehlers' work, this measures how closely the current price action correlates to a straight line (a perfect trend).\n\nFunction: It outputs a confidence score (-1 to 1). Gypsy Bot uses this to ensure that we are not just moving up, but moving up with high statistical correlation, reducing fake-outs.\n\nModule 3: Ehlers Roofing Filter\n\nLogic: A sophisticated spectral filter that combines a High-Pass filter (to remove long-term drift) with a Super Smoother (to remove high-frequency noise).\n\nFunction: It attempts to isolate the \"Roof\" of the price action. It is excellent at catching cyclical turning points before standard moving averages react.\n\nModule 4: Forecast Oscillator\n\nLogic: Uses Linear Regression forecasting to predict where price \"should\" be relative to where it is.\n\nFunction: When the Forecast Oscillator crosses its zero line, it indicates that the regression trend has flipped. We offer both \"Aggressive\" and \"Conservative\" calculation modes for this module.\n\nModule 5: Chandelier ATR Stop\n\nLogic: A volatility-based trend follower that hangs a \"leash\" (ATR multiple) from the highest high (for longs) or lowest low (for shorts).\n\nFunction: Used here as an entry filter. If price is above the Chandelier line, the trend is Bullish. It also includes a \"Bull/Bear Qualifier\" check to ensure structural support.\n\nModule 6: Crypto Market Breadth (CMB)\n\nLogic: This is a macro-filter. It pulls data from multiple major tickers (BTC, ETH, and Perpetual Contracts) across different exchanges.\n\nFunction: It calculates a \"Market Health\" percentage. If Bitcoin is rising but the rest of the market is dumping, this module can veto a trade, ensuring you don't buy into a \"fake\" rally driven by a single asset.\n\nModule 7: Directional Index Convergence (DIC)\n\nLogic: Analyzes the convergence/divergence between Fast and Slow Directional Movement indices.\n\nFunction: Identifies when trend strength is expanding. A buy signal is generated only when the positive directional movement overpowers the negative movement with expanding momentum.\n\nModule 8: Market Thrust Indicator (MTI)\n\nLogic: A volume-weighted breadth indicator. It uses Advance/Decline data and Up/Down Volume data.\n\nFunction: This is one of the most powerful modules. It confirms that price movement is supported by actual volume flow. We recommend using the \"SSMA\" (Super Smoother) MA Type for the cleanest signals on the 4H chart.\n\nModule 9: Simple Ichimoku Cloud\n\nLogic: Traditional Japanese trend analysis using the Tenkan-sen and Kijun-sen.\n\nFunction: Checks for a \"Kumo Breakout.\" Price must be fully above the Cloud (for longs) or below it (for shorts). This is a classic \"trend confirmation\" module.\n\nModule 10: Simple Harmonic Oscillator\n\nLogic: Analyzes the harmonic wave properties of price action to detect cyclical tops and bottoms.\n\nFunction: Serves as a counter-trend or early-reversal detector. It tries to identify when a cycle has bottomed out (for buys) or topped out (for sells) before the main trend indicators catch up.\n\nModule 11: HSRS Compression / Super AO\n\nLogic: Two options in one.\n\nHSRS: Hirashima Sugita Resistance Support. Detects volatility compression (squeezes) relative to dynamic support/resistance bands.\n\nSuper AO: A combination of the Awesome Oscillator and SuperTrend logic.\n\nFunction: Great for catching explosive moves that result from periods of low volatility (consolidation).\n\nModule 12: Fisher Transform (MTF)\n\nLogic: Converts price data into a Gaussian normal distribution.\n\nFunction: Identifies extreme price deviations. This module uses Multi-Timeframe (MTF) logic to look at higher-timeframe trends (e.g., looking at the Daily Fisher while trading the 4H chart) to ensure you aren't trading against the major trend.\n\n5. Global Inhibitors (The Veto Power)\n\nEven if 12 out of 12 modules vote \"Buy,\" Gypsy Bot performs a final safety check using Global Inhibitors. If any of these are triggered, the trade is blocked.\n\nBitcoin Halving Logic:\n\nHardcoded dates for past and projected future Bitcoin halvings (up to 2040).\n\nTrading is inhibited or restricted during the chaotic weeks immediately surrounding a Halving event to avoid volatility crushes.\n\nMiner Capitulation:\n\nUses Hash Rate Ribbons (Moving averages of Hash Rate).\n\nIf miners are capitulating (Shutting down rigs due to unprofitability), the engine flags a \"Bearish\" regime and can flip logic to Short-only or flat.\n\nADX Filter (Flat Market Protocol):\n\nIf the Average Directional Index (ADX) is below a specific threshold (e.g., 20), the market is deemed \"Flat/Choppy.\" The bot will refuse to open trend-following trades in a flat market.\n\nCryptoCap Trend:\n\nChecks the total Crypto Market Cap chart. If the broad market is in a downtrend, it can inhibit Long entries on individual altcoins.\n\n6. Risk Management & The Dump Protection Team (DPT)\n\nGypsy Bot separates \"Entry Logic\" from \"Risk Management Logic.\"\n\nDump Protection Team (DPT)\n\nThis is a specialized logic branch designed to save the account during Black Swan events.\n\nNuke Protection: If the DPT detects a volatility signature consistent with a flash crash, it overrides all other logic and forces an immediate exit.\n\nMoon Protection: If a parabolic pump is detected that violates statistical probability (Bollinger deviations), DPT can force a profit take before the inevitable correction.\n\nAdvanced Adaptive Trailing Stop (AATS)\n\nUnlike a static trailing stop (e.g., \"trail by 5%\"), AATS is dynamic.\n\nPenthouse Level: If price is at the top of the HSRS channel (High Volatility), the stop loosens to allow for wicks.\n\nDungeon Level: If price is compressed at the bottom, the stop tightens to protect capital.\n\nStaged Take Profits\n\nTP1: Scalp a portion (e.g., 10%) to cover fees and secure a win.\n\nTP2: Take the bulk of profit.\n\nTP3: Leave a \"Runner\" position with a loose trailing stop to catch \"Moon\" moves.\n\n7. Recommended Setup Guide\n\nWhen applying Gypsy Bot to a new chart, follow this sequence:\n\nSet Timeframe: 4 Hours (4H).\n\nReset: Turn OFF Trailing Stop, Stop Loss, and Take Profits. (We want to see raw entry performance first).\n\nTune DPT: Adjust \"Dump/Moon Protection\" inputs first. These have the highest impact on net performance.\n\nTune Module 8 (MTI): This module is a heavy filter. Experiment with the MA Type (SSMA is recommended).\n\nSelect Modules: Enable/Disable modules 1-12 based on the asset's personality (Trending vs. Ranging).\n\nVoting Threshold: Adjust ActivateOrders. A lower number = More Trades (Aggressive). A higher number = Fewer, higher conviction trades (Conservative).\n\nFinal Polish: Re-enable Stop Losses, Trailing Stops, and Staged Take Profits to smooth the equity curve and define your max risk per trade.\n\n8. Technical Specs\n\nEngine Version: Pine Script V6\n\nRepainting: This strategy uses Closed Candle data for all Risk Management and Entry decisions. This ensures that Backtest results align closely with real-time behavior (no repainting of historical signals).\n\nAlerts: This script generates Strategy alerts. If you require visual-only alerts, see the source code header for instructions on switching to \"Study\" (Indicator) mode.\n\nDisclaimer:\nThis script is a complex algorithmic tool for market analysis. Past performance is not indicative of future results. Use this tool to assist your own decision-making, not to replace it.\n\n9. About Signal Lynx\n\nAutomation for the Night-Shift Nation ðŸŒ™\n\nSignal Lynx focuses on helping traders and developers bridge the gap between indicator logic and real-world automation. The same RM engine you see here powers multiple internal systems and templates, including other public scripts like the Super-AO Strategy with Advanced Risk Management.\n\nWe provide this code open source under the Mozilla Public License 2.0 (MPL-2.0) to:\n\nDemonstrate how Adaptive Logic and structured Risk Management can outperform static, one-layer indicators\n\nGive Pine Script users a battle-tested RM backbone they can reuse, remix, and extend\n\nIf you are looking to automate your TradingView strategies, route signals to exchanges, or simply want safer, smarter strategy structures, please keep Signal Lynx in your search.\n\nLicense: Mozilla Public License 2.0 (Open Source).\nIf you make beneficial modifications, please consider releasing them back to the community so everyone can benefit.",
    "image_url": "isu2jsPD",
    "author": "SignalLynx",
    "likes": 8,
    "type": "strategy",
    "created": "2025-12-09",
    "updated": "2025-12-09",
    "source": "//@version=6\r\n////////////////////////////////////////////////////////////////\r\n//* Gypsy Bot Trade Engine - Study, Strategy, and Backtest   *//\r\n//////////////////////////////////////////////////////////////// \r\n\r\n//Code by SignalLynx\r\n//Signal Lynx | Free Scripts supporting Automation for the Night-Shift Nation\r\n\r\n// NOTE FOR NEW PINESCRIPT USERS: \r\n// If you want to see the alerts purely visually without running a backtest, \r\n// you would comment out the 'strategy' line and uncomment the 'study' line.\r\n// In addition, you will need to comment out the strategy buys/sells at the \r\n// bottom of this file, and uncomment the alert plots.\r\n\r\n//indicator(\"Gyspy Bot Trade Engine - V1.2B - (Gypsy Bot) Alerts 12-7-25\", shorttitle=\"Gyspy Bot Trade Engine - V1.2B - Alerts\", overlay=false)\r\n\r\n// The line below is the \"Strategy\" declaration. This allows for backtesting (buy/sell simulation).\r\n// overlay=true means the buy/sell arrows appear ON the price chart, not in a separate pane below it.\r\n// initial_capital set to 1000 USD for testing purposes.\r\nstrategy('Gyspy Bot Trade Engine - V1.2B - Strategy 12-7-25', shorttitle = 'Gyspy Bot Trade Engine - V1.2B - Strat', overlay = true, initial_capital = 1000, commission_type = strategy.commission.percent, commission_value = 0.26, currency = currency.USD, default_qty_type = strategy.percent_of_equity, default_qty_value = 100, pyramiding = 0, slippage = 5)\r\n\r\n////////////////////////////////////////////////////////////////  \r\n//* Gypsy Bot Trade Engine - Code Information                *// \r\n////////////////////////////////////////////////////////////////    \r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n// Gypsy Bot Trade Engine (MK6 V1.2B) â€“ Executive Summary\r\n//\r\n// Gypsy Bot is a highly sophisticated, modular \"Trade Engine\" designed for the TradingView \r\n// Pine Script v6 environment. Unlike traditional strategies that rely on a single indicator \r\n// or simple crossover logic, Gypsy Bot functions as a consensus algorithm. It aggregates data \r\n// from up to 12 distinct technical analysis modulesâ€”ranging from Guppy MMAs and Ehlers Roofing \r\n// Filters to Ichimoku Clouds and Harmonic Oscillatorsâ€”to determine high-probability market entries.\r\n//\r\n// The engine operates on a voting system: it monitors all active modules and only executes a trade \r\n// when a user-defined threshold of concurring signals is met. This consensus approach helps filter \r\n// out noise and false signals common in volatile cryptocurrency markets.\r\n//\r\n// Risk Management & Volatility Protection:\r\n// Beyond entry signals, Gypsy Bot distinguishes itself with a robust Risk Management suite. \r\n// It features a specialized \"Dump Protection Team\" (DPT) module designed to identify extreme \r\n// market volatility (Moon/Nuke scenarios) and force-exit positions or pause trading to preserve \r\n// capital. Additional filters include Miner Capitulation logic, BTC dominance checks, and \r\n// flat-market filters (ADX) to prevent trading during non-trending periods.\r\n//\r\n// Critical Note on Optimization and Curve Fitting:\r\n// Users must exercise caution when applying Gypsy Bot to new pairs. By design, this engine allows \r\n// for granular control over dozens of variables, effectively making it a powerful curve-fitting \r\n// algorithm. \r\n// -- Do not chase raw Net Profit: When tuning parameters, prioritize high Profit Factor and \r\n//    Percent Profitable rates. A strategy tuned solely for maximum profit on historical data \r\n//    is often over-fitted and will fail in live market conditions.\r\n// -- Regular Maintenance: Market conditions shift. Parameters that worked in a bull market may \r\n//    fail in a crab or bear market. Gypsy Bot settings should be reviewed and adjusted at regular  \r\n//    intervals to ensure continued optimal performance.\r\n//\r\n// Timeframe Recommendations:\r\n// Gypsy Bot is optimized for High Time Frame (HTF) trend following. It generally produces the \r\n// most reliable results on charts ranging from 1-Hour to 12-Hours, with the 4-Hour timeframe \r\n// historically serving as the \"sweet spot\" for most major cryptocurrency assets.\r\n//\r\n// Key Features:\r\n// -- 12 Selectable Signal Modules: Mix and match indicators like TSI, MTI, Forecast Oscillators, etc.\r\n// -- Advanced Exit Logic: Includes Staged Take Profits (TP1, TP2, TP3), Adaptive Trailing Stops (ATS), \r\n//    and Martingale/DCA recovery options.\r\n// -- Market Filters: Integrated Bitcoin Halving logic, Weekend Trading halts, and CryptoCap market \r\n//    breadth analysis, and a sentiment ribbon.\r\n// -- Pine v6 Compliance: Fully updated to adhere to strict type-checking and historical consistency \r\n//    requirements of Pine Script v6.\r\n///////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n//Revision Control and Code Information\r\n\r\n//This is a trade engine (MK6, V1.2B - Gypsy Bot) - Code Release date: 12-7-25\r\n//This code is in perpetual development - Gyspy Bot first build was in November 2019 - It has come a long way\r\n//Variable names may get a bit odd - Evidence of when I got a bit loopy during coding (Captain DeadPool for instance)\r\n//\r\n//MK6 V1.2B - Upgrade to pinescript v6\r\n//MK6 V1.2A Fixes issues with QUANDL data for hashrate\r\n//MK6 V1.2 Changes Houbi tickers to Kraken - Houbi tickers were banned by TV (morons); Also integrates additional adaptations for further flexibility\r\n//MK6 V1.1 is the releaseed version of the MK6 V1.0 development series\r\n//MK6 V1.0Z is a build off of V1.0Y and looks at reducing memory consumption without sacrificing performance\r\n//MK6 V1.0Y is built off of V1.0X, but looks at how to slow down trades in times of major chop/crab\r\n//MK6 V1.0X is an offshoot of V1.0 - in order to preserve V1.0'X performance - v.10X looks at enhanced integration of renko overlays and removal of TD9- \r\n//MK6 V1.0 - Featuring upgrades with CyrptoCap and moved to Pine V5\r\n//MK5 code replaces fisher transform error that Killed mk5. Additional improvements.\r\n//MK4 codes look at data back to 1/1/17 (MK3 was 1/1/2019 forward), and features trend based parameter changes\r\n//MK3 CodesV2.62 looks at improving performance on dates 2019 and earlier, and miner captiulation settings/parameters\r\n//V2.60RR Looks at improving the MESA filter due to a missed 30% long\r\n//V2.59RR attempts to revert the code to a more succesful calculation method\r\n//V2.4+ is reduced Modules in order to decrease compilation/power requirements\r\n//Earlier codes - see individual code.\r\n//Trade engine is designed to allow various code modules to be easily dropped into the main body, to allow for a\r\n//complex code, quick and easy changing of variables.\r\n//Trade engine buit by SignalLynx, with code peices from numerous individuals. I have done by best to maintain documentation, but its basically a new system built out over time.\r\n//RSI Qualifier Code by SignalLynx\r\n//Risk Managment built by SignalLynx - initially started with some script segments from other TV users (names have been lost to time)\r\n\r\n//Code shall be kept as freesource, any privization of code is not allowed; Inclusive of any downstream use in other codes\r\n//Violators will be reported to Tradingview\r\n//Note: Code peices have been picked up along the way, and likely have forgotten to mention contributors (Appologies in advance)\r\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n////////////////////////////////////////////////////////////////\r\n//* Backtest Setting                                         *//\r\n////////////////////////////////////////////////////////////////\r\n\r\n// Grouping inputs makes the settings menu cleaner in TradingView.\r\nvar BackTestMod = 'Back Test Inputs'\r\n\r\n// Users can define the specific window of time to run the backtest.\r\ntestStartYear = input(2019, '- Start year', group = BackTestMod)\r\ntestStartMonth = input(01, '- Start month', group = BackTestMod)\r\ntestStartDay = input(01, '- Start day', group = BackTestMod)\r\n// Timestamp converts human readable dates into computer time (milliseconds since 1970).\r\ntestPeriodStart = timestamp(testStartYear, testStartMonth, testStartDay, 0, 0)\r\n\r\ntestStopYear = input(99999, '- Stop year', group = BackTestMod)\r\ntestStopMonth = input(12, '- Stop month', group = BackTestMod)\r\ntestStopDay = input(30, '-Stop day', group = BackTestMod)\r\ntestPeriodStop = timestamp(testStopYear, testStopMonth, testStopDay, 0, 0)\r\n\r\n// This function checks if the current bar on the chart is within the user-defined date range.\r\ntestPeriod() =>\r\n    time >= testPeriodStart and time <= testPeriodStop ? true : false\r\n\r\n\r\n/////////////////////////////////////\r\n//Longs and shorts\r\n\r\nvar LnS = 'Strategy Options - Longs and Shorts'\r\nLnS_Longs = input(true, title = 'Longs', group = LnS)\r\nLnS_Shorts = input(true, title = 'Shorts', group = LnS)\r\n\r\n// Logic to determine direction: 1=Both, 2=Longs Only, 3=Shorts Only\r\nLongAndShort = LnS_Longs == true and LnS_Shorts == true ? 1 : LnS_Longs == true and LnS_Shorts == false ? 2 : LnS_Longs == false and LnS_Shorts == true ? 3 : 1\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n//Credit provoidided to original creators, however most sections have been Modified by SignalLynx\r\n// Note: MK5 removed - Removed Hull MA to reduce memory consumption\r\n// Original las mods by @NeoButane 12 July 2018\r\n// Original Guppy by @ChrisMoody: https://www.tradingview.com/script/3rxOtFe0-CM-Guppy-EMA/\r\n// Original Super Guppy by @FritzMurphy: https://www.tradingview.com/script/ViEwbRCA-CM-Super-Guppy/\r\n// Original Log=space ideas by @fskrypt: https://www.tradingview.com/u/fskrypt/\r\n\r\n// Guppy Multiple Moving Average (GMMA) Logic\r\n// This pulls daily ('D') closing prices regardless of the chart timeframe you are on.\r\ntypeSPI = request.security(syminfo.tickerid, 'D', close[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)\r\nsrcSPI = math.log(typeSPI) // Uses Logarithmic scale for better trend detection on crypto\r\n\r\n// Custom Moving Average function\r\nmaSPI(_lenSPI) =>\r\n    ema_1SPI = ta.ema(srcSPI, _lenSPI)\r\n    ema_2SPI = ta.ema(srcSPI, _lenSPI)\r\n    math.exp(ema_1SPI)\r\n\r\n// Defining MA lengths\r\nma1SPI = 3\r\nma13SPI = 39\r\nma2SPI = 6\r\nma14SPI = 42\r\nma3SPI = 9\r\nma15SPI = 45\r\nma4SPI = 12\r\nma16SPI = 48\r\nma5SPI = 15\r\nma17SPI = 51\r\nma6SPI = 18\r\nma18SPI = 54\r\nma7SPI = 21\r\nma19SPI = 57\r\nma8SPI = 24\r\nma20SPI = 60\r\nma9SPI = 27\r\nma21SPI = 63\r\nma10SPI = 30\r\nma22SPI = 66\r\nma11SPI = 33\r\nma23SPI = 200\r\nma12SPI = 36\r\n\r\n// --- V6 FIX EXPLANATION ---\r\n// In Pine Script V6, functions that calculate based on history (like maSPI calling ta.ema) \r\n// MUST execute on every single bar to maintain consistency.\r\n// Previously, these were called inside the boolean logic (e.g., if x > y). \r\n// If x wasn't > y, the subsequent MAs wouldn't calculate, breaking the historical series.\r\n// We now pre-calculate them into variables (v_ma1, v_ma2, etc) to ensure they run every time.\r\nv_ma1 = maSPI(ma1SPI), v_ma2 = maSPI(ma2SPI), v_ma3 = maSPI(ma3SPI), v_ma4 = maSPI(ma4SPI), v_ma5 = maSPI(ma5SPI), v_ma6 = maSPI(ma6SPI), v_ma7 = maSPI(ma7SPI)\r\nv_ma8 = maSPI(ma8SPI), v_ma9 = maSPI(ma9SPI), v_ma10 = maSPI(ma10SPI), v_ma11 = maSPI(ma11SPI), v_ma12 = maSPI(ma12SPI), v_ma13 = maSPI(ma13SPI)\r\nv_ma14 = maSPI(ma14SPI), v_ma15 = maSPI(ma15SPI), v_ma16 = maSPI(ma16SPI), v_ma17 = maSPI(ma17SPI), v_ma18 = maSPI(ma18SPI), v_ma19 = maSPI(ma19SPI)\r\nv_ma20 = maSPI(ma20SPI), v_ma21 = maSPI(ma21SPI), v_ma22 = maSPI(ma22SPI)\r\n\r\n// Logic: Are the Fast MAs stacked properly (1 > 2 > 3...)?\r\nfastLongXSPI = v_ma1 > v_ma2 and v_ma2 > v_ma3 and v_ma3 > v_ma4 and v_ma4 > v_ma5 and v_ma5 > v_ma6 and v_ma6 > v_ma7\r\nfastShortXSPI = v_ma1 < v_ma2 and v_ma2 < v_ma3 and v_ma3 < v_ma4 and v_ma4 < v_ma5 and v_ma5 < v_ma6 and v_ma6 < v_ma7\r\n// Logic: Are the Slow MAs stacked properly?\r\nslowLongXSPI = v_ma8 > v_ma9 and v_ma9 > v_ma10 and v_ma10 > v_ma11 and v_ma11 > v_ma12 and v_ma12 > v_ma13 and v_ma13 > v_ma14 and v_ma14 > v_ma15 and v_ma15 > v_ma16 and v_ma16 > v_ma17 and v_ma17 > v_ma18 and v_ma18 > v_ma19 and v_ma19 > v_ma20 and v_ma20 > v_ma21 and v_ma21 > v_ma22\r\nslowShortXSPI = v_ma8 < v_ma9 and v_ma9 < v_ma10 and v_ma10 < v_ma11 and v_ma11 < v_ma12 and v_ma12 < v_ma13 and v_ma13 < v_ma14 and v_ma14 < v_ma15 and v_ma15 < v_ma16 and v_ma16 < v_ma17 and v_ma17 < v_ma18 and v_ma18 < v_ma19 and v_ma19 < v_ma20 and v_ma20 < v_ma21 and v_ma21 < v_ma22\r\n\r\ntraderbullsigSPI = 3\r\ntraderbearsigSPI = -3\r\ninvestorbullsigSPI = 2\r\ninvestorbearsigSPI = -2\r\n\r\n// Determine Fast Signal Strength\r\nfastSigSPI(_bullSPI, _bullishSPI, _bearSPI, _bearishSPI) =>\r\n    ma__1SPI = maSPI(ma1SPI)\r\n    mom_1SPI = ta.mom(ma__1SPI, 4) // Momentum of the fastest MA\r\n    // Ternary operator: If Bullish -> 3, If Bearish -> -3, Else check momentum\r\n    _sigSPI = _bullSPI and _bullishSPI ? traderbullsigSPI : _bearSPI and _bearishSPI ? traderbearsigSPI : not _bullishSPI and not _bearSPI and not _bearishSPI and mom_1SPI > 0 ? 1 : -1\r\n    _sigSPI\r\nsig1SPI = fastSigSPI(fastLongXSPI, slowLongXSPI, fastShortXSPI, slowShortXSPI)\r\n\r\n// Determine Slow Signal Strength\r\nslowSigSPI(_sharkSPI, _tadpoleSPI) =>\r\n    ma__1SPI = maSPI(ma8SPI)\r\n    mom_1SPI = ta.mom(ma__1SPI, 3)\r\n    _sigSPI = _sharkSPI ? investorbullsigSPI : _tadpoleSPI ? investorbearsigSPI : not _sharkSPI and not _tadpoleSPI and mom_1SPI > 0 ? 1 : -1\r\n    _sigSPI\r\nsig2SPI = slowSigSPI(slowLongXSPI, slowShortXSPI)\r\n\r\n// Smoothing the signals to reduce noise\r\nsig1smoother = ta.ema(sig1SPI, 14)\r\nsig2smoother = ta.ema(sig2SPI, 5)\r\n// Final check: If both smoothers agree, we have a signal.\r\nSPI_Final_Sig = sig1smoother > 0 and sig2smoother > 0 ? 1 : sig1smoother < 0 and sig2smoother < 0 ? -1 : 0\r\n// A very long EMA (4000) acts as a baseline trend filter.\r\nSSGuppy = ta.ema(sig1smoother, 4000)\r\n\r\n// True Strength Index (TSI) Calculation\r\nlongTSI = 25\r\nshortTSI = 13\r\nsignalTSI = 50\r\npriceTSI = close\r\ndouble_smoothTSI(srcTSI, longTSI, shortTSI) =>\r\n    fist_smoothTSI = ta.ema(srcTSI, longTSI)\r\n    ta.ema(fist_smoothTSI, shortTSI)\r\npcTSI = ta.change(priceTSI)\r\ndouble_smoothed_pcTSI = double_smoothTSI(pcTSI, longTSI, shortTSI)\r\ndouble_smoothed_abs_pcTSI = double_smoothTSI(math.abs(pcTSI), longTSI, shortTSI)\r\ntsi_valueTSI = 100 * (double_smoothed_pcTSI / double_smoothed_abs_pcTSI)\r\n\r\nTSI_Inhib = ta.ema(tsi_valueTSI, signalTSI)\r\nTSI_InhibFinal = TSI_Inhib < 0 ? -1 : 0\r\n\r\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n//Hirashima Sugita R/S Code HSRS\r\n// This calculates dynamic Support/Resistance based on linear regression and weighted moving averages\r\nlengthHSRS = 1000\r\nmaHSRS = ta.ema(close, lengthHSRS)\r\ndHSRS = close - maHSRS\r\n\r\nsHSRS = ta.linreg(dHSRS, lengthHSRS, 0)\r\nxHSRS = maHSRS + sHSRS\r\n\r\nd_HSRS = close - xHSRS\r\ns_HSRS = ta.linreg(d_HSRS, lengthHSRS, 0)\r\nbasisHSRS = maHSRS + sHSRS + ta.change(s_HSRS)\r\n\r\nupperHSRS = basisHSRS + ta.wma(math.abs(dHSRS), lengthHSRS)\r\nlowerHSRS = basisHSRS - ta.wma(math.abs(dHSRS), lengthHSRS)\r\nupper_HSRS = upperHSRS + ta.wma(math.abs(dHSRS), lengthHSRS)\r\nlower_HSRS = lowerHSRS - ta.wma(math.abs(dHSRS), lengthHSRS)\r\n\r\nHSRS_Gap = upper_HSRS - lower_HSRS\r\nHSRS_Threshold = 10 // input.int(title='HSRS Threshold', defval=10, minval=0) / 100\r\n// HSRS Inhibitor: If gap is wide, volatility is high.\r\nHSRS_InhibXy = close * HSRS_Threshold < HSRS_Gap ? 0 : 1\r\n\r\n// Check if the HSRS Gap is falling (Volatility decreasing)\r\ns_HSRS2 = HSRS_Gap\r\nnm_HSRS = 21\r\nfalling_old_HSRS(s_HSRS2, nm_HSRS) =>\r\n    res = true\r\n    for i = 1 to nm_HSRS by 1\r\n        if s_HSRS2[0] >= s_HSRS2[i]\r\n            res := false\r\n            break\r\n    res\r\n\r\nHSRS_Gap_Falling = falling_old_HSRS(s_HSRS2, nm_HSRS) ? 1 : 0\r\n\r\n// Bitcoin Halving Dates (Known and Projected)\r\nhalving_1 = timestamp(2012, 11, 28, 0, 0)\r\nhalving_2 = timestamp(2016, 7, 9, 0, 0)\r\nhalving_3 = timestamp(2020, 4, 30, 0, 0)\r\nhalving_4 = timestamp(2024, 4, 19, 0, 0) \r\nhalving_5 = timestamp(2028, 3, 26, 0, 0) // projected! https://www.bitcoinclock.com/\r\nhalving_6 = timestamp(2032, 4, 14, 0, 0) // projected! https://www.bitcoinclock.com/\r\nhalving_7 = timestamp(2036, 4, 18, 0, 0) // projected! https://www.bitcoinclock.com/\r\nhalving_8 = timestamp(2040, 4, 21, 0, 0) // projected! https://www.bitcoinclock.com/\r\n\r\n//Inhibitors for Miner Capitulation Flip - from 7 days before halving to 90 days after\r\n// This logic prevents certain trades during chaotic periods around BTC halvings.\r\nh1_range = time >= halving_1 - 7 * 24 * 60 * 60 * 1000 and time <= halving_1 + 720 * 24 * 60 * 60 * 1000 ? 1 : 0\r\nh2_range = time >= halving_2 - 7 * 24 * 60 * 60 * 1000 and time <= halving_2 + 720 * 24 * 60 * 60 * 1000 ? 1 : 0\r\nh3_range = time >= halving_3 - 7 * 24 * 60 * 60 * 1000 and time <= halving_3 + 720 * 24 * 60 * 60 * 1000 ? 1 : 0\r\nh4_range = time >= halving_4 - 14 * 24 * 60 * 60 * 1000 and time <= halving_4 + 720 * 24 * 60 * 60 * 1000 ? 1 : 0\r\nh5_range = time >= halving_5 - 14 * 24 * 60 * 60 * 1000 and time <= halving_5 + 720 * 24 * 60 * 60 * 1000 ? 1 : 0\r\nh6_range = time >= halving_6 - 14 * 24 * 60 * 60 * 1000 and time <= halving_6 + 720 * 24 * 60 * 60 * 1000 ? 1 : 0\r\nh7_range = time >= halving_7 - 14 * 24 * 60 * 60 * 1000 and time <= halving_7 + 720 * 24 * 60 * 60 * 1000 ? 1 : 0\r\nh8_range = time >= halving_8 - 14 * 24 * 60 * 60 * 1000 and time <= halving_8 + 720 * 24 * 60 * 60 * 1000 ? 1 : 0\r\n\r\nh1_range2 = time >= halving_1 - 500 * 24 * 60 * 60 * 1000 and time <= halving_1 + 500 * 24 * 60 * 60 * 1000 ? 1 : 0\r\nh2_range2 = time >= halving_2 - 500 * 24 * 60 * 60 * 1000 and time <= halving_2 + 500 * 24 * 60 * 60 * 1000 ? 1 : 0\r\nh3_range2 = time >= halving_3 - 500 * 24 * 60 * 60 * 1000 and time <= halving_3 + 500 * 24 * 60 * 60 * 1000 ? 1 : 0\r\nh4_range2 = time >= halving_4 - 500 * 24 * 60 * 60 * 1000 and time <= halving_4 + 500 * 24 * 60 * 60 * 1000 ? 1 : 0\r\nh5_range2 = time >= halving_5 - 500 * 24 * 60 * 60 * 1000 and time <= halving_5 + 500 * 24 * 60 * 60 * 1000 ? 1 : 0\r\nh6_range2 = time >= halving_6 - 500 * 24 * 60 * 60 * 1000 and time <= halving_6 + 500 * 24 * 60 * 60 * 1000 ? 1 : 0\r\nh7_range2 = time >= halving_7 - 500 * 24 * 60 * 60 * 1000 and time <= halving_7 + 500 * 24 * 60 * 60 * 1000 ? 1 : 0\r\nh8_range2 = time >= halving_8 - 500 * 24 * 60 * 60 * 1000 and time <= halving_8 + 500 * 24 * 60 * 60 * 1000 ? 1 : 0\r\n\r\nh7range = time >= timestamp(2019, 1, 1, 0, 0) and time <= timestamp(2020, 10, 31, 0, 0) ? 1 : 0\r\nHalvingInhibitor2 = h1_range2 == 1 or h2_range2 == 1 or h3_range2 == 1 or h4_range2 == 1 or h5_range2 == 1 or h6_range2 == 1 or h7_range2 == 1 or h8_range2 == 1 ? 1 : 0\r\n\r\n// High Time Frame (14 Day) RSI Check\r\nclose_HTF = request.security(syminfo.tickerid, '14D', close[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)\r\nRSI_HTF = ta.rsi(close_HTF, 1000)\r\nsmoothedCloseRSI_HTF = ta.wma(RSI_HTF, 125)\r\nRSI_HTF_Activator = smoothedCloseRSI_HTF >= 50 ? 1 : 0\r\nRSI_HTF_Activator2 = smoothedCloseRSI_HTF >= 50 ? 1 : 0\r\n\r\n// Combining Guppy, Halving, and RSI Filters\r\nSSGuppyFinal = SSGuppy >= 0 or HalvingInhibitor2 == 1 or TSI_InhibFinal == 0 ? 1 : -1\r\nTrendPath = SSGuppy <= 0 or RSI_HTF_Activator2 == 0 ? 1 : 0\r\nTrendPath2 = RSI_HTF_Activator2 == 0 ? 1 : 0\r\nHalvingInhibitor = h1_range == 1 or h2_range == 1 or h3_range == 1 or h4_range == 1 or h5_range == 1 or h6_range == 1 or h7_range == 1 or h8_range == 1 or SSGuppyFinal == -1 or RSI_HTF_Activator == 1 ? 1 : 0\r\nEngagey = TrendPath2 == 1 and HalvingInhibitor2 == 0 ? 1 : 0\r\n\r\n//Kicker Variables\r\nBBADXKicker = float(na)\r\n\r\n///////CryptoCap Module\r\n// This module checks the Total Crypto Market Cap to see if the overall market is trending up or down.\r\nvar CCMod = 'CryptoCap Modifier'\r\nUseBTCDMod = input(false, title = 'Use CryptoCap - Trades with CryptoCap Market Value (Default = No) ', group = CCMod)\r\nBTCDCloseCheck = input(false, title = 'Close Trade on CryptoCap Signal? (Default = No)', group = CCMod)\r\nBTCvsAltCheck = input(false, title = 'Flip CryptoCap Signals? (Default = No)', group = CCMod)\r\n\r\nintval1FTMTFX = input.string('H01', 'CryptoCap ATR', options = ['M01', 'M03', 'M05', 'M15', 'M30', 'M45', 'H01', 'H02', 'H03', 'H04', 'H06', 'H08', 'H12', 'Day', 'Week', 'Month', 'Year'], group = CCMod)\r\n\r\n// Helper function to standardize interval strings\r\ngetRezFTMTFX(intvalFTMTFX) =>\r\n    iff_1X = intvalFTMTFX == 'Year' ? '12M' : '60'\r\n    iff_2X = intvalFTMTFX == 'Month' ? 'M' : iff_1X\r\n    iff_3X = intvalFTMTFX == 'Week' ? 'W' : iff_2X\r\n    iff_4X = intvalFTMTFX == 'Day' ? 'D' : iff_3X\r\n    iff_5X = intvalFTMTFX == 'H12' ? '720' : iff_4X\r\n    iff_6X = intvalFTMTFX == 'H08' ? '480' : iff_5X\r\n    iff_7X = intvalFTMTFX == 'H06' ? '360' : iff_6X\r\n    iff_8X = intvalFTMTFX == 'H04' ? '240' : iff_7X\r\n    iff_9X = intvalFTMTFX == 'H03' ? '180' : iff_8X\r\n    iff_10X = intvalFTMTFX == 'H02' ? '120' : iff_9X\r\n    iff_11X = intvalFTMTFX == 'H01' ? '60' : iff_10X\r\n    iff_12X = intvalFTMTFX == 'M45' ? '45' : iff_11X\r\n    iff_13X = intvalFTMTFX == 'M30' ? '30' : iff_12X\r\n    iff_14X = intvalFTMTFX == 'M15' ? '15' : iff_13X\r\n    iff_15X = intvalFTMTFX == 'M05' ? '5' : iff_14X\r\n    iff_16X = intvalFTMTFX == 'M03' ? '3' : iff_15X\r\n    int_1FTMTFX = intvalFTMTFX == 'M01' ? '1' : iff_16X\r\n    int_1FTMTFX\r\n\r\nresFTMTFX = getRezFTMTFX(intval1FTMTFX)\r\n\r\n// Getting data from CRYPTOCAP:TOTAL\r\nTCAP_PSAR = request.security('CRYPTOCAP:TOTAL', resFTMTFX, ta.ema(close, 21)[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)\r\nTCAP_Close = request.security('CRYPTOCAP:TOTAL', resFTMTFX, close[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)\r\n\r\ndirSARTrue = TCAP_PSAR < TCAP_Close ? 1 : -1\r\ndirSARFlipped = TCAP_PSAR < TCAP_Close ? -1 : 1\r\n\r\n//final signals for trade engine\r\nBTCD_FlipCheck = BTCvsAltCheck == false ? dirSARTrue : dirSARFlipped\r\n\r\n//Final Trade Engine signals conversions from BTC.D\r\n\r\nBTCDSignal = BTCD_FlipCheck\r\n//Check to see if we should be using BTC.D Module signals for buys/sells BTCD\r\n\r\nLgCheck_BTCDMod = UseBTCDMod == true ? BTCDSignal : 1\r\nShCheck_BTCDMod = UseBTCDMod == true ? BTCDSignal : -1\r\n\r\nLgCheck_BTCDModDPT = BTCDSignal == 1 ? 1 : 0\r\nShCheck_BTCDModDPT = BTCDSignal == -1 ? -1 : 0\r\n\r\nBTCD_inLong = BTCDSignal == 1 ? 1 : 0\r\nBTCD_inShort = BTCDSignal == -1 ? -1 : 0\r\n\r\n//check to see if we should be closing trades on BTCD Module Signals\r\nBTCD_LongCloseCheck = BTCDCloseCheck == true ? BTCD_inLong : 1\r\nBTCD_ShortCloseCheck = BTCDCloseCheck == true ? BTCD_inShort : -1\r\n\r\n//End of CryptoCap  Module code\r\n\r\n////////////////////////////////////////////////////////////////\r\n//* Code Module Section                                      *//\r\n////////////////////////////////////////////////////////////////\r\n\r\n//Trade engine is set up for a multiple code moduals: First Module is Main; Second Module is constraining, etc\r\n// The strategy votes on trades based on how many modules are active.\r\n\r\n////////////////////////////////////////////////////////////////\r\n//* First Module                                             *//\r\n//*Code Type - Modified Slope Angle                          *//\r\n////////////////////////////////////////////////////////////////\r\n\r\n//First Module - Yes or no to use\r\nvar TEMod1 = 'First Module - Modified Slope Angle (MSA)'\r\nUse1stMod = input(true, title = 'Use First Module - Modified Slope Angle (MSA)', group = TEMod1)\r\nFstCloseCheck = input(false, title = 'Close Trade on MSA Signal? (Default = No)', group = TEMod1)\r\n\r\n//place first Module code below this line\r\n\r\n// Modified Angle Slope (Code build 12-19-21) - Originally by aamonkey, modified by SignalLynx with alternate timeframes and adapted for TE\r\n\r\nftMAS = 2\r\nfbMAS = -2\r\nsrcMAS = close\r\n\r\n//Alternate TF\r\nintvalMAS = input.string('H01', 'Modified Slope Angle - ATR', options = ['M01', 'M03', 'M05', 'M15', 'M30', 'M45', 'H01', 'H02', 'H03', 'H04', 'H06', 'H08', 'H12', 'Day', 'Week', 'Month', 'Year'], group = TEMod1)\r\nMASLength = input.int(14, 'Modified Slope Angle - Length (Default=14)', minval = 0, group = TEMod1)\r\n\r\n\r\n// Correct the interval used //MAS\r\ngetRezMAS(intvalMAS) =>\r\n    iff_1MAS = intvalMAS == 'Year' ? '12M' : '60'\r\n    iff_2MAS = intvalMAS == 'Month' ? 'M' : iff_1MAS\r\n    iff_3MAS = intvalMAS == 'Week' ? 'W' : iff_2MAS\r\n    iff_4MAS = intvalMAS == 'Day' ? 'D' : iff_3MAS\r\n    iff_5MAS = intvalMAS == 'H12' ? '720' : iff_4MAS\r\n    iff_6MAS = intvalMAS == 'H08' ? '480' : iff_5MAS\r\n    iff_7MAS = intvalMAS == 'H06' ? '360' : iff_6MAS\r\n    iff_8MAS = intvalMAS == 'H04' ? '240' : iff_7MAS\r\n    iff_9MAS = intvalMAS == 'H03' ? '180' : iff_8MAS\r\n    iff_10MAS = intvalMAS == 'H02' ? '120' : iff_9MAS\r\n    iff_11MAS = intvalMAS == 'H01' ? '60' : iff_10MAS\r\n    iff_12MAS = intvalMAS == 'M45' ? '45' : iff_11MAS\r\n    iff_13MAS = intvalMAS == 'M30' ? '30' : iff_12MAS\r\n    iff_14MAS = intvalMAS == 'M15' ? '15' : iff_13MAS\r\n    iff_15MAS = intvalMAS == 'M05' ? '5' : iff_14MAS\r\n    iff_16MAS = intvalMAS == 'M03' ? '3' : iff_15MAS\r\n    int_MAS = intvalMAS == 'M01' ? '1' : iff_16MAS\r\n    int_MAS\r\n\r\nresMAS = getRezMAS(intvalMAS)\r\n\r\n//// //// Determine Angle by KyJ //// //// \r\nangleMAS(_srcMAS) =>\r\n    rad2degreeMAS = 180 / 3.14159265359 //pi  \r\n    angMAS = rad2degreeMAS * math.atan((_srcMAS[0] - _srcMAS[1]) / ta.atr(14))\r\n    angMAS\r\n\r\nmaMASPre = request.security(syminfo.tickerid, resMAS, close[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)\r\nmaMAS = ta.ema(maMASPre, MASLength)\r\nma_slopeMAS = angleMAS(maMAS)\r\n\r\n///////////// Final Signal /////////////\r\nsignalMAS = ma_slopeMAS > ftMAS ? 1 : ma_slopeMAS < fbMAS ? -1 : 0\r\n\r\n//Convert Module signal to trade engine\r\n//1 for Buy, -1 for sell, 0 is no trade\r\n\r\nFirstSignal = signalMAS\r\n\r\n//No Module code below this line -trade engine code\r\n\r\n//Final Trade Engine signals conversions from first Module\r\n\r\n//Check to see if we should be using 1st Module signals for buys/sells \r\n// Logic: If Module is ON, use the signal. If OFF, return 1 (neutral/pass).\r\n\r\nLgCheck_1stMod = Use1stMod == true ? FirstSignal : 1\r\nShCheck_1stMod = Use1stMod == true ? FirstSignal : -1\r\n\r\nLgCheck_1stModDPT = FirstSignal == 1 ? 1 : 0\r\nShCheck_1stModDPT = FirstSignal == -1 ? -1 : 0\r\n\r\nFst_inLong = FirstSignal == 1 ? 1 : 0\r\nFst_inShort = FirstSignal == -1 ? -1 : 0\r\n\r\n//check to see if we should be closing trades on 1st Module Signals\r\nFst_LongCloseCheck = FstCloseCheck == true ? Fst_inLong : 1\r\nFst_ShortCloseCheck = FstCloseCheck == true ? Fst_inShort : -1\r\n\r\n//End of first Module code\r\n\r\n////////////////////////////////////////////////////////////////\r\n//* Second  Module                                           *//\r\n//*Code Type - Ehlers Correlation trend Indicator (CTI)      *//\r\n////////////////////////////////////////////////////////////////\r\n\r\n//Second Module - Yes or no to use\r\nvar TEMod2 = 'Second Module - Correlation trend Indicator (CTE)'\r\nUseSecondMod = input(true, title = 'Use Second Module - Correlation Trend Indicator (CTI)', group = TEMod2)\r\nSecondCloseCheck = input(false, title = 'Close Trade on CTI Signal? (Default = No)', group = TEMod2)\r\n\r\n//Originally by Crypohythms, modified by SignalLynx \r\n\r\nXCTI = 0.0\r\nYCTI = 0.0\r\nCorrCTI = 0.0\r\nSxCTI = 0.0\r\nSyCTI = 0.0\r\nSxxCTI = 0.0\r\nSxyCTI = 0.0\r\nSyyCTI = 0.0\r\npositionCTI = 0\r\nLengthCTI = 14 //input(14, '----CTI Length')\r\n\r\nresultCTI = for countCTI = 0 to LengthCTI - 1 by 1\r\n    XCTI := close[countCTI]\r\n    YCTI := -countCTI\r\n    SxCTI := SxCTI + XCTI\r\n    SyCTI := SyCTI + YCTI\r\n    SxxCTI := SxxCTI + XCTI * XCTI\r\n    SxyCTI := SxyCTI + XCTI * YCTI\r\n    SyyCTI := SyyCTI + YCTI * YCTI\r\n    SyyCTI\r\n\r\nif LengthCTI * SxxCTI - SxCTI * SxCTI > 0 and LengthCTI * SyyCTI - SyCTI * SyCTI > 0\r\n    CorrCTI := (LengthCTI * SxyCTI - SxCTI * SyCTI) / math.sqrt((LengthCTI * SxxCTI - SxCTI * SxCTI) * (LengthCTI * SyyCTI - SyCTI * SyCTI))\r\n    CorrCTI\r\n\r\nCTI_SignalPre = CorrCTI >= 0.1 ? 1 : CorrCTI < -0.1 ? -1 : 0\r\nCTI_SignalSmoother = ta.sma(CTI_SignalPre, 14)\r\nCTI_Signal = CTI_SignalSmoother >= 0 ? 1 : -1\r\n\r\n//Convert Module signal to trade engine\r\n//1 for Buy, -1 for sell, 0 is no trade\r\n\r\nSecondSignal = CTI_Signal\r\n\r\n//No Module code below this line -trade engine code\r\n\r\n//Final Trade Engine signals conversions from Thirteenth module\r\n\r\n//Check to see if we should be using 2nd module signals for buys/sells\r\n\r\nLgCheck_2ndMod = UseSecondMod == true ? SecondSignal : 1\r\nShCheck_2ndMod = UseSecondMod == true ? SecondSignal : -1\r\n\r\nLgCheck_2ndModDPT = SecondSignal == 1 ? 1 : 0\r\nShCheck_2ndModDPT = SecondSignal == -1 ? -1 : 0\r\n\r\nSecond_inLong = SecondSignal == 1 ? 1 : -1\r\nSecond_inShort = SecondSignal == -1 ? -1 : -1\r\n\r\n//check to see if we should be closing trades on 2nd module Signals\r\nSecond_LongCloseCheck = SecondCloseCheck == true ? Second_inLong : 1\r\nSecond_ShortCloseCheck = SecondCloseCheck == true ? Second_inShort : -1\r\n\r\n////////////////////////////////////////////////////////////////\r\n//* Tertiary Module                                          *//\r\n//*Code Type - Ehlers Roofing Filter                         *//\r\n////////////////////////////////////////////////////////////////\r\n\r\n//Tertiary Module - Yes or no to use\r\nvar TEMod3 = 'Third Module - Ehlers Roofing Filter (ERF)'\r\nUse3rdMod = input(true, title = 'Use Tertiary Module - Ehlers Roofing Filter (ERF)', group = TEMod3)\r\nThirdCloseCheck = input(false, title = 'Close Trade on ERF Signal? (Default = No)', group = TEMod3)\r\n\r\n// Ehlers Roofing Filter indicator script may be freely distributed under the MIT license.\r\n//Originally by Everget, modified by SignalLynx for use in trade engine\r\n// This filter removes low frequency noise (trend) and high frequency noise (cycle) to find the \"Roof\"\r\n\r\nhighpassLengthERF = 48 // input.int(title='HighPass Length', defval=48, minval=1)\r\nssfLengthERF = 17 // input.int(title='Super Smoother Filter Length', defval=17, minval=1)\r\nnumberOfPolesERF = 3 //input.int(title='Number of Poles', defval=3, options=[2, 3])\r\nsrcERF = close\r\nPIERF = 2 * math.asin(1)\r\n\r\ntwoPoleSuperSmootherFilterERF(srcERF, lengthERF) =>\r\n    argERF = math.sqrt(2) * PIERF / lengthERF\r\n    a1ERF = math.exp(-argERF)\r\n    b1ERF = 2 * a1ERF * math.cos(argERF)\r\n    c2ERF = b1ERF\r\n    c3ERF = -math.pow(a1ERF, 2)\r\n    c1ERF = 1 - c2ERF - c3ERF\r\n\r\n    ssfERF = 0.0\r\n    ssfERF := c1ERF * srcERF + c2ERF * nz(ssfERF[1]) + c3ERF * nz(ssfERF[2])\r\n    ssfERF\r\n\r\nthreePoleSuperSmootherFilterERF(srcERF, lengthERF) =>\r\n    argERF = PIERF / lengthERF\r\n    a1ERF = math.exp(-argERF)\r\n    b1ERF = 2 * a1ERF * math.cos(1.738 * argERF)\r\n    c1ERF = math.pow(a1ERF, 2)\r\n\r\n    coef2ERF = b1ERF + c1ERF\r\n    coef3ERF = -(c1ERF + b1ERF * c1ERF)\r\n    coef4ERF = math.pow(c1ERF, 2)\r\n    coef1ERF = 1 - coef2ERF - coef3ERF - coef4ERF\r\n\r\n    ssfERF = 0.0\r\n    ssfERF := coef1ERF * srcERF + coef2ERF * nz(ssfERF[1]) + coef3ERF * nz(ssfERF[2]) + coef4ERF * nz(ssfERF[3])\r\n    ssfERF\r\n\r\nroofingFilterERF(srcERF, highpassLengthERF, ssfLengthERF, numberOfPolesERF) =>\r\n    alphaArgERF = 2 * PIERF / (highpassLengthERF * math.sqrt(2))\r\n\r\n    alphaERF = 0.0\r\n    alphaERF := math.cos(alphaArgERF) != 0 ? (math.cos(alphaArgERF) + math.sin(alphaArgERF) - 1) / math.cos(alphaArgERF) : nz(alphaERF[1])\r\n\r\n    highpassERF = 0.0\r\n    highpassERF := math.pow(1 - alphaERF / 2, 2) * (srcERF - 2 * nz(srcERF[1]) + nz(srcERF[2])) + 2 * (1 - alphaERF) * nz(highpassERF[1]) - math.pow(1 - alphaERF, 2) * nz(highpassERF[2])\r\n\r\n    twoPoleSuperSmootherFilter__1ERF = twoPoleSuperSmootherFilterERF((highpassERF + nz(highpassERF[1])) / 2, ssfLengthERF)\r\n    threePoleSuperSmootherFilter__1ERF = threePoleSuperSmootherFilterERF((highpassERF + nz(highpassERF[1])) / 2, ssfLengthERF)\r\n    numberOfPolesERF == 2 ? twoPoleSuperSmootherFilter__1ERF : threePoleSuperSmootherFilter__1ERF\r\n\r\nerfERF = roofingFilterERF(srcERF, highpassLengthERF, ssfLengthERF, numberOfPolesERF)\r\nerfSignal = erfERF >= 0.0 ? 1 : -1\r\n\r\n//Convert Third Modual SIgnal to the trade Engine\r\n//signal must be 1 for long, -1 for short and 0 for no trade\r\n\r\nThird_Signal = erfSignal\r\n\r\n//Check to see if we should be using 3rd Module\r\n\r\nLgCheck_3rdMod = Use3rdMod == true ? Third_Signal : 1\r\nShCheck_3rdMod = Use3rdMod == true ? Third_Signal : -1\r\n\r\nLgCheck_3rdModDPT = Third_Signal == 1 ? 1 : 0\r\nShCheck_3rdModDPT = Third_Signal == -1 ? -1 : 0\r\n\r\nThird_inLong = Third_Signal == 1 ? 1 : -1\r\nThird_inShort = Third_Signal == -1 ? -1 : 1\r\n\r\n//check to see if we should be closing trades on Chandi Signals\r\nThird_LongCloseCheck = ThirdCloseCheck == true ? Third_Signal : 1\r\nThird_ShortCloseCheck = ThirdCloseCheck == true ? Third_Signal : -1\r\n\r\n///////////////////////////////////////////////////////////////\r\n//* Fourth   Module                                         *//\r\n//*Code Type - Forecast Module                              *//\r\n///////////////////////////////////////////////////////////////\r\n\r\n//Fourth Module - Yes or no to use\r\nvar TEMod4 = 'Fourth Module - Forecast Oscillator'\r\nUseFourthMod = input(true, title = 'Use Fourth Module - Forecast Oscillator ', group = TEMod4)\r\nFourthCloseCheck = input(false, title = 'Close Trade on Forecast Signal? (Default = No)', group = TEMod4)\r\n\r\n//place Fourth Module code below this line\r\n//Inputs\r\nAgressiveFO = input(false, 'Use Agressive Forecasting (Default = Conservative)', group = TEMod4)\r\nlengthFO = 14 //input.int(title='Length', defval=14, minval=1)\r\nsrcFO = close\r\nfosc = 100 * (srcFO - ta.linreg(srcFO, lengthFO, 0)) / srcFO\r\n\r\n//Final Buy Signals\r\ns_fosc = fosc\r\nnm_fosc = 1\r\nrising_old_fosc(s_fosc, nm_fosc) =>\r\n    res = true\r\n    for i = 1 to nm_fosc by 1\r\n        if s_fosc[0] <= s_fosc[i]\r\n            res := false\r\n            break\r\n    res\r\nFOAgressSig = rising_old_fosc(s_fosc, nm_fosc) == true ? 1 : -1\r\nFOSignal = FOAgressSig > 0 and AgressiveFO == true ? 1 : FOAgressSig < 0 and AgressiveFO == true ? -1 : fosc > 0 and AgressiveFO == false ? 1 : fosc < 0 and AgressiveFO == false ? -1 : 0\r\n\r\n//Convert Module signal to trade engine\r\n//1 for Buy, -1 for sell, 0 is no trade\r\n\r\nFourthSignal = FOSignal\r\n\r\n//No Module code below this line -trade engine code\r\n\r\n//Final Trade Engine signals conversions from first Module\r\n\r\n//Check to see if we should be using 4th Module signals for buys/sells\r\n\r\nLgCheck_4thMod = UseFourthMod == true ? FourthSignal : 1\r\nShCheck_4thMod = UseFourthMod == true ? FourthSignal : -1\r\n\r\nLgCheck_4thModDPT = FourthSignal == 1 ? 1 : 0\r\nShCheck_4thModDPT = FourthSignal == -1 ? -1 : 0\r\n\r\nFourth_inLong = FourthSignal == 1 ? 1 : -1\r\nFourth_inShort = FourthSignal == -1 ? -1 : 1\r\n\r\n//check to see if we should be closing trades on Fourth Module Signals\r\nFourth_LongCloseCheck = FourthCloseCheck == true ? Fourth_inLong : 1\r\nFourth_ShortCloseCheck = FourthCloseCheck == true ? Fourth_inShort : -1\r\n\r\n//End of fourth Module code\r\n\r\n////////////////////////////////////////////////////////////////\r\n//* Fifth Module                                             *//\r\n//*Code Type - Chandileir ATR Stop with Bull/Bear            *//\r\n////////////////////////////////////////////////////////////////\r\n\r\n//Fifth Module - Yes or no to use\r\nvar TEMod5 = 'Fifth Module - Chandeler ATR Stop'\r\nUse5thMod = input(true, title = 'Use Fifth Module as Order Signal - Chandeleir ATR Stop', group = TEMod5)\r\nBullBearQualifier = input(true, title = 'Use Bull Bear Qualifier? (Default = Yes)', group = TEMod5)\r\nFifthCloseCheck = input(false, title = 'Close Trade on Chandeleir Signal? (Default = No)', group = TEMod5)\r\n\r\n//Fifth Code Module Information and Authors\r\n//Orignal Author of this script has been lost to time, as I have modified it multiple times.  \r\n\r\n//Inputs\r\nLengthz = 22\r\nATRPeriod = 22 //input(title='ATR Period', defval=22)\r\nMult = input(title = 'ATR Multiplier', defval = 3, group = TEMod5)\r\n\r\n//calculate stop value\r\nshort_stop = ta.lowest(Lengthz) + Mult * ta.atr(ATRPeriod)\r\nlong_stop = ta.highest(Lengthz) - Mult * ta.atr(ATRPeriod)\r\n\r\nlongStop = 0.0\r\nlongStop := close[1] > longStop[1] ? math.max(long_stop, longStop[1]) : long_stop\r\n\r\nshortStop = 0.0\r\nshortStop := close[1] < shortStop[1] ? math.min(short_stop, shortStop[1]) : short_stop\r\n\r\n//dir =1 then Long, dir=-1 then short\r\ndir = 1\r\ndir := close > shortStop[1] ? 1 : close < longStop[1] ? -1 : nz(dir[1], dir)\r\n\r\n//BullBear Qualifier (BBQ)\r\nwindowBBQ = input(title = 'Bull Bear Qualifier - Lookback Window:', defval = 7, group = TEMod5)\r\n\r\nf_exp_lrBBQ(_heightBBQ, _lengthBBQ) =>\r\n    _retBBQ = _heightBBQ + _heightBBQ / _lengthBBQ\r\n    _retBBQ\r\n\r\nh_valueBBQ = ta.highest(close, windowBBQ)\r\nl_valueBBQ = ta.lowest(close, windowBBQ)\r\n\r\nh_barBBQ = bar_index - ta.highestbars(close, windowBBQ)\r\nl_barBBQ = bar_index - ta.lowestbars(close, windowBBQ)\r\n\r\nbearBBQ = 0 - f_exp_lrBBQ(h_valueBBQ - close, bar_index - h_barBBQ)\r\nbullBBQ = 0 + f_exp_lrBBQ(close - l_valueBBQ, bar_index - l_barBBQ)\r\n\r\ntrendBBQ = bullBBQ - math.abs(bearBBQ)\r\nsmoothedtrendBBQ = ta.sma(trendBBQ, 21)\r\ntxBBQ = smoothedtrendBBQ > 0 ? 1 : smoothedtrendBBQ < 0 ? -1 : 0\r\nUseBBQCheckLong = BullBearQualifier == true ? txBBQ : 1\r\nUseBBQCheckShort = BullBearQualifier == true ? txBBQ : -1\r\n\r\n//convert Module signal to trade engine signal\r\n\r\nfifthcombo = dir == 1 and UseBBQCheckLong == 1 ? 1 : dir == -1 and UseBBQCheckShort == -1 ? -1 : 0\r\n\r\nFifthSignal = fifthcombo\r\n\r\n//Check to see if we should be using 4th Module\r\nLgCheck_5thMod = Use5thMod == true ? FifthSignal : 1\r\nShCheck_5thMod = Use5thMod == true ? FifthSignal : -1\r\n\r\nLgCheck_5thModDPT = FifthSignal == 1 ? 1 : 0\r\nShCheck_5thModDPT = FifthSignal == -1 ? -1 : 0\r\n\r\n//check to see if we should be closing trades on fifth Module Signals\r\nFifth_LongCloseCheck = FifthCloseCheck == true ? FifthSignal : 1\r\nFifth_ShortCloseCheck = FifthCloseCheck == true ? FifthSignal : -1\r\n\r\n////////////////////////////////////////////////////////////////\r\n//* Sixth Module                                             *//\r\n//*Code Type - Crypto Market Breadth                         *//\r\n////////////////////////////////////////////////////////////////\r\n\r\n//Sixth Module - Yes or no to use\r\nvar TEMod6 = 'Sixth Module - Crypto Market Breadth (CMB)'\r\nUseSixthMod = input(true, title = 'Use Sixth Module - Crypto Market Breadth (CMB)', group = TEMod6)\r\nSixthCloseCheck = input(false, title = 'Close Trade on CMB Signal? (Default = No)', group = TEMod6)\r\n\r\n//place Sixth Module code below this line\r\n//Module Code Info and author goes here\r\n\r\n///Orignal Author of this script has been lost to time,I must have accidently clipped the first line of the below blurb\r\n// This script was generated from https://github.com/m59peacemaker/pine-crypto-market-breadth\r\n// Modified by SignalLynx for use in the trade engine and to reduce memory usage\r\n// The percent of top market cap crypto-currencies advancing and the percent declining.\r\n// Whether the asset is advancing or declining is determined by whether it closes above or below its moving average. \r\n// Credit to @bigurb for suggesting and helping with this indicator.\r\n\r\n//Inputs\r\nAgressiveCMB = input(true, 'Use Agressive Crypto Market Breadth Settings (Default = Aggressive)', group = TEMod6)\r\nCMBAgressiveTrend = input(true, 'Use Agressive Trend Mapping for CMB (Default = Yes)', group = TEMod6)\r\nCMBmovingAverageLength1 = 20 // input(20, title='Moving Average Length 1')\r\nCMBmovingAverageLength2 = 50 //input(50, title='Moving Average Length 2')\r\nCMB_SmootherLength = 7 //input(7, title='CMB Smoother Length')\r\n\r\nCMBtickerValue(CMBexpression, CMBtkr) =>\r\n    request.security(CMBtkr, timeframe.period, CMBexpression[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)\r\n\r\nCMBNumberOfCurrencies = 6 //make sure ths is total of tickers below\r\n\r\n\r\n//Tickers for Breadth\r\nBTCUSD_closeC = CMBtickerValue(close, 'KRAKEN:BTCUSD')\r\nETHUSD_closeC = CMBtickerValue(close, 'KRAKEN:ETHUSD')\r\nXBTUSD_closeB = CMBtickerValue(close, 'BINANCE:BTCPERP')\r\nETHUSD_closeB = CMBtickerValue(close, 'BINANCE:ETHPERP')\r\nXBTUSD_closeK = CMBtickerValue(close, 'COINBASE:BTCUSD')\r\nETHUSD_closeK = CMBtickerValue(close, 'COINBASE:ETHUSD')\r\n\r\nBTCUSD_movingAverage1C = ta.sma(BTCUSD_closeC, CMBmovingAverageLength1)\r\nETHUSD_movingAverage1C = ta.sma(ETHUSD_closeC, CMBmovingAverageLength1)\r\nXBTUSD_movingAverage1K = ta.sma(XBTUSD_closeK, CMBmovingAverageLength1)\r\nETHUSD_movingAverage1K = ta.sma(ETHUSD_closeK, CMBmovingAverageLength1)\r\nXBTUSD_movingAverage1B = ta.sma(XBTUSD_closeB, CMBmovingAverageLength1)\r\nETHUSD_movingAverage1B = ta.sma(ETHUSD_closeB, CMBmovingAverageLength1)\r\n\r\nCMBadvancing1 = (BTCUSD_closeC > BTCUSD_movingAverage1C ? 1 : 0) + (ETHUSD_closeC > ETHUSD_movingAverage1C ? 1 : 0) + (XBTUSD_closeK > XBTUSD_movingAverage1K ? 1 : 0) + (ETHUSD_closeK > ETHUSD_movingAverage1K ? 1 : 0) + (XBTUSD_closeB > XBTUSD_movingAverage1B ? 1 : 0) + (ETHUSD_closeB > ETHUSD_movingAverage1B ? 1 : 0)\r\n\r\nCMBadvancingRatio1 = CMBadvancing1 / CMBNumberOfCurrencies\r\nCMBadvancingPercent1 = CMBadvancingRatio1 * 100\r\nCMBdecliningPercent1 = 100 - CMBadvancingPercent1\r\nCMBpairsUsedPercent1 = 100\r\n\r\nBTCUSD_movingAverage2C = ta.sma(BTCUSD_closeC, CMBmovingAverageLength2)\r\nETHUSD_movingAverage2C = ta.sma(ETHUSD_closeC, CMBmovingAverageLength2)\r\nXBTUSD_movingAverage2K = ta.sma(XBTUSD_closeK, CMBmovingAverageLength2)\r\nETHUSD_movingAverage2K = ta.sma(ETHUSD_closeK, CMBmovingAverageLength2)\r\nXBTUSD_movingAverage2B = ta.sma(XBTUSD_closeB, CMBmovingAverageLength2)\r\nETHUSD_movingAverage2B = ta.sma(ETHUSD_closeB, CMBmovingAverageLength2)\r\n\r\nCMBadvancing2 = (BTCUSD_closeC > BTCUSD_movingAverage2C ? 1 : 0) + (ETHUSD_closeC > ETHUSD_movingAverage2C ? 1 : 0) + (XBTUSD_closeK > XBTUSD_movingAverage2K ? 1 : 0) + (ETHUSD_closeK > ETHUSD_movingAverage2K ? 1 : 0) + (XBTUSD_closeB > XBTUSD_movingAverage2B ? 1 : 0) + (ETHUSD_closeB > ETHUSD_movingAverage2B ? 1 : 0)\r\n\r\nCMBadvancingRatio2 = CMBadvancing2 / CMBNumberOfCurrencies\r\nCMBadvancingPercent2 = CMBadvancingRatio2 * 100\r\nCMBdecliningPercent2 = 100 - CMBadvancingPercent2\r\nCMBpairsUsedPercent2 = 100\r\n\r\n//Signals\r\nCMB_Smoother = ta.ema(CMBadvancingPercent2, CMB_SmootherLength)\r\n\r\ns_CMB = CMB_Smoother\r\nnm_CMB = 1\r\nrising_old_CMB(s_CMB, nm_CMB) =>\r\n    res = true\r\n    for i = 1 to nm_CMB by 1\r\n        if s_CMB[0] <= s_CMB[i]\r\n            res := false\r\n            break\r\n    res\r\n\r\nCMB_HTF_SignalAgg = rising_old_CMB(s_CMB, nm_CMB) == true or CMB_Smoother >= 50 and CMB_Smoother == CMB_Smoother[1] ? 1 : -1\r\nCMB_HTF_SignalCon = CMB_Smoother >= 50 ? 1 : -1\r\n\r\nCMB_Final_Signal = AgressiveCMB == false ? CMB_HTF_SignalCon : CMB_HTF_SignalAgg\r\n\r\n//Convert Module signal to trade engine\r\n//1 for Buy, -1 for sell, 0 is no trade\r\n\r\nSixthSignal = CMB_Final_Signal\r\n\r\n//No Module code below this line -trade engine code\r\n\r\n//Final Trade Engine signals conversions from first Module\r\n\r\n//Check to see if we should be using 6th Module signals for buys/sells\r\n\r\nLgCheck_6thMod1 = UseSixthMod == true and Engagey == 0 ? SixthSignal : 1\r\nShCheck_6thMod1 = UseSixthMod == true and Engagey == 0 ? SixthSignal : -1\r\n\r\nLgCheck_6thMod2 = UseSixthMod == true ? SixthSignal : 1\r\nShCheck_6thMod2 = UseSixthMod == true ? SixthSignal : -1\r\n\r\nLgCheck_6thMod = CMBAgressiveTrend == true ? LgCheck_6thMod1 : LgCheck_6thMod2\r\nShCheck_6thMod = CMBAgressiveTrend == true ? ShCheck_6thMod1 : ShCheck_6thMod2\r\n\r\nLgCheck_6thModDPT = SixthSignal == 1 ? 1 : 0\r\nShCheck_6thModDPT = SixthSignal == -1 ? -1 : 0\r\n\r\nSixth_inLong = SixthSignal == 1 ? 1 : -1\r\nSixth_inShort = SixthSignal == -1 ? -1 : 1\r\n\r\n//check to see if we should be closing trades on sixth Module Signals\r\nSixth_LongCloseCheck = SixthCloseCheck == true ? Sixth_inLong : 1\r\nSixth_ShortCloseCheck = SixthCloseCheck == true ? Sixth_inShort : -1\r\n\r\n\r\n//End of Sixth Module code\r\n\r\n////////////////////////////////////////////////////////////////\r\n//* Seventh Module                                           *//\r\n//*Code Type - Directional Index Convergence                 *//\r\n////////////////////////////////////////////////////////////////\r\n\r\n//Seventh Module - Yes or no to use\r\nvar TEMod7 = 'Seventh Module - Directional Index Convergence (DIC)'\r\nUseSeventhMod = input(true, title = 'Use Seventh Module - Directional Index Convergence (DIC)', group = TEMod7)\r\nDICAgressiveTrend = input(false, 'Use Agressive Trend Mapping for DIC (Default = No)', group = TEMod7)\r\nSeventhCloseCheck = input(false, title = 'Close Trade on DIC Signal? (Default = No)', group = TEMod7)\r\n\r\n//place Seventh Module code below this line\r\n\r\n\r\n// Displays the Convergence of the positive and negative of the \r\n// Directional Index(DI), 0 will be generally between 20 <-> 25 on the DI.\r\n\r\n\r\nint fast_lengthDIC = 10\r\nint slow_lengthDICPRE = 2000\r\nint signalDIC = 1\r\nDIC_Avg = 3\r\n\r\nslow_lengthDIC = BBADXKicker >= 2 ? int(slow_lengthDICPRE / 2) : slow_lengthDICPRE\r\n\r\nInstant_Threshold = 5\r\nAvg_Threshold = 5\r\n\r\n// DI function\r\ndirmov(lenDIC) =>\r\n    upDIC = ta.change(high)\r\n    downDIC = -ta.change(low)\r\n    plusDM = na(upDIC) ? na : upDIC > downDIC and upDIC > 0 ? upDIC : 0\r\n    minusDM = na(downDIC) ? na : downDIC > upDIC and downDIC > 0 ? downDIC : 0\r\n    truerangeDIC = ta.rma(ta.tr, lenDIC)\r\n    plusDIC = fixnan(100 * ta.rma(plusDM, lenDIC) / truerangeDIC)\r\n    minusDIC = fixnan(100 * ta.rma(minusDM, lenDIC) / truerangeDIC)\r\n    [plusDIC, minusDIC]\r\n\r\n[bullfastDIC, bearfastDIC] = dirmov(fast_lengthDIC)\r\n[bullslowDIC, bearslowDIC] = dirmov(slow_lengthDIC)\r\n\r\nbullhistDIC = ta.ema(math.max(0, bullfastDIC - bullslowDIC), signalDIC)\r\nbearhistDIC = ta.ema(math.max(0, bearfastDIC - bearslowDIC), signalDIC) * -1\r\n\r\nDMTrend = bullhistDIC > 0 ? bullhistDIC : bearhistDIC\r\n\r\nDMSmoothed = math.avg(DMTrend, DIC_Avg)\r\n\r\nDIC_Trend = bullhistDIC > Instant_Threshold and DMSmoothed > Avg_Threshold ? 1 : bearhistDIC < Instant_Threshold * -1 and DMSmoothed < Avg_Threshold * -1 ? -1 : 0\r\n\r\n//Convert Module signal to trade engine\r\n//1 for Buy, -1 for sell, 0 is no trade\r\n\r\nSeventhSignal = DIC_Trend\r\n\r\n//No Module code below this line -trade engine code\r\n\r\n//Final Trade Engine signals conversions from seventh Module\r\n\r\n//Check to see if we should be using 7th Module signals for buys/sells\r\n\r\n\r\nLgCheck_7thMod1 = UseSeventhMod == true and Engagey == 0 ? SeventhSignal : 1\r\nShCheck_7thMod1 = UseSeventhMod == true and Engagey == 0 ? SeventhSignal : -1\r\n\r\nLgCheck_7thMod2 = UseSeventhMod == true ? SeventhSignal : 1\r\nShCheck_7thMod2 = UseSeventhMod == true ? SeventhSignal : -1\r\n\r\nLgCheck_7thMod = DICAgressiveTrend == true ? LgCheck_7thMod1 : LgCheck_7thMod2\r\nShCheck_7thMod = DICAgressiveTrend == true ? ShCheck_7thMod1 : ShCheck_7thMod2\r\n\r\nLgCheck_7thModDPT = SeventhSignal == 1 ? 1 : 0\r\nShCheck_7thModDPT = SeventhSignal == -1 ? -1 : 0\r\n\r\nSeventh_inLong = SeventhSignal == 1 ? 1 : -1\r\nSeventh_inShort = SeventhSignal == -1 ? -1 : 1\r\n\r\n//check to see if we should be closing trades on Seventh Module Signals\r\nSeventh_LongCloseCheck = SeventhCloseCheck == true ? Seventh_inLong : 1\r\nSeventh_ShortCloseCheck = SeventhCloseCheck == true ? Seventh_inShort : -1\r\n\r\n//End of Seventh Module code\r\n\r\n////////////////////////////////////////////////////////////////\r\n//* Eigth Module                                             *//\r\n//* Code Type - Market Thrust Indicator                      *//\r\n////////////////////////////////////////////////////////////////\r\n\r\n//Eigth Module - Yes or no to use\r\nvar TEMod8 = 'Eigth Module - Market thurst Indicator (MTI)'\r\nUse8thMod = input(true, title = 'Use Eigth Module - Market Thrust Indicator (MTI)', group = TEMod8)\r\nEigthCloseCheck = input(false, title = 'Close Trade on MTI Signal? (Default = No)', group = TEMod8)\r\n\r\n//Eigth Code Module Information and Authors\r\n//originally by DreadBlitz, modified by SignalLynx for use in trade engine\r\n\r\n//Inputs\r\nMTIAgressiveTrend = input(true, 'Use Agressive Trend Mapping for MTI (Default = Yes)', group = TEMod8)\r\nAgressiveMTI = input(false, 'Use Agressive MTI Settings (Default = Conservative)', group = TEMod8)\r\nm_src = close\r\nma_type = input.string(defval = 'WMA', title = 'MTI MA Type: ', options = ['SMA', 'EMA', 'WMA', 'VWMA', 'SMMA', 'DEMA', 'TEMA', 'HullMA', 'ZEMA', 'TMA', 'SSMA'], group = TEMod8)\r\nreaction = 1\r\nmalen1 = input.int(defval = 14, title = 'MTI Agressive Length', minval = 1, group = TEMod8)\r\nmalen2 = input.int(defval = 35, title = 'MTI Normal Length', minval = 1, group = TEMod8)\r\n\r\nma_len = BBADXKicker >= 2 ? malen1 : malen2\r\n\r\nadv = request.security('USI:ADV', timeframe.period, m_src[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)\r\nuvol = request.security('USI:UVOL', timeframe.period, m_src[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)\r\ndecl = request.security('USI:DECL', timeframe.period, m_src[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)\r\ndvol = request.security('USI:DVOL', timeframe.period, m_src[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)\r\n\r\nmti = adv * uvol - decl * dvol\r\nma_src = mti\r\n\r\n// SuperSmoother filter\r\n// Â© 2013  John F. Ehlers\r\nvariant_supersmoother(src, len) =>\r\n    a1 = math.exp(-1.414 * 3.14159 / len)\r\n    b1 = 2 * a1 * math.cos(1.414 * 3.14159 / len)\r\n    c2 = b1\r\n    c3 = -a1 * a1\r\n    c1 = 1 - c2 - c3\r\n    v9 = 0.0\r\n    v9 := c1 * (src + nz(src[1])) / 2 + c2 * nz(v9[1]) + c3 * nz(v9[2])\r\n    v9\r\n\r\nvariant_smoothed(src, len) =>\r\n    v5 = 0.0\r\n    sma_1 = ta.sma(src, len)\r\n    v5 := na(v5[1]) ? sma_1 : (v5[1] * (len - 1) + src) / len\r\n    v5\r\n\r\nvariant_zerolagema(src, len) =>\r\n    ema1 = ta.ema(src, len)\r\n    ema2 = ta.ema(ema1, len)\r\n    v10 = ema1 + ema1 - ema2\r\n    v10\r\n\r\nvariant_doubleema(src, len) =>\r\n    v2 = ta.ema(src, len)\r\n    v6 = 2 * v2 - ta.ema(v2, len)\r\n    v6\r\n\r\nvariant_tripleema(src, len) =>\r\n    v2 = ta.ema(src, len)\r\n    v7 = 3 * (v2 - ta.ema(v2, len)) + ta.ema(ta.ema(v2, len), len)\r\n    v7\r\n\r\nvariant(type, src, len) =>\r\n    ema_1 = ta.ema(src, len)\r\n    wma_1 = ta.wma(src, len)\r\n    vwma_1 = ta.vwma(src, len)\r\n    variant_smoothed__1 = variant_smoothed(src, len)\r\n    variant_doubleema__1 = variant_doubleema(src, len)\r\n    variant_tripleema__1 = variant_tripleema(src, len)\r\n    wma_2 = ta.wma(src, len / 2)\r\n    wma_3 = ta.wma(src, len)\r\n    wma_4 = ta.wma(2 * wma_2 - wma_3, math.round(math.sqrt(len)))\r\n    variant_supersmoother__1 = variant_supersmoother(src, len)\r\n    variant_zerolagema__1 = variant_zerolagema(src, len)\r\n    sma_1 = ta.sma(src, len)\r\n    sma_2 = ta.sma(sma_1, len)\r\n    sma_3 = ta.sma(src, len)\r\n    type == 'EMA' ? ema_1 : type == 'WMA' ? wma_1 : type == 'VWMA' ? vwma_1 : type == 'SMMA' ? variant_smoothed__1 : type == 'DEMA' ? variant_doubleema__1 : type == 'TEMA' ? variant_tripleema__1 : type == 'HullMA' ? wma_4 : type == 'SSMA' ? variant_supersmoother__1 : type == 'ZEMA' ? variant_zerolagema__1 : type == 'TMA' ? sma_2 : sma_3\r\n\r\n// === Moving Average\r\nma_series = variant(ma_type, ma_src, ma_len)\r\n\r\ndirection = 0\r\n\r\ns_falling = ma_series\r\nnm_falling = reaction\r\nfalling_old_falling(s_falling, nm_falling) =>\r\n    res = true\r\n    for i = 1 to nm_falling by 1\r\n        if s_falling[0] >= s_falling[i]\r\n            res := false\r\n            break\r\n    res\r\n\r\ns_ma = ma_series\r\nnm_ma = reaction\r\nrising_old_ma(s_ma, nm_ma) =>\r\n    res = true\r\n    for i = 1 to nm_ma by 1\r\n        if s_ma[0] <= s_ma[i]\r\n            res := false\r\n            break\r\n    res\r\n\r\nDRsing = rising_old_ma(s_ma, nm_ma)\r\nDFalling = falling_old_falling(s_falling, nm_falling)\r\n\r\ndirection := DRsing == true ? 1 : DFalling == true ? -1 : nz(direction[1])\r\n\r\n//finals signals\r\nMTIAgressSig = direction > 0 ? 1 : -1\r\nMTISignal = MTIAgressSig > 0 and AgressiveMTI == true ? 1 : MTIAgressSig < 0 and AgressiveMTI == true ? -1 : ma_series > 0 and AgressiveMTI == false ? 1 : ma_series < 0 and AgressiveMTI == false ? -1 : 0\r\n\r\n//Check to see if we should be using 8th Module MTIAgressiveTrend\r\n\r\nLgCheck_8thMod1 = Use8thMod == true and Engagey == 0 and SSGuppyFinal == 1 ? MTISignal : 1\r\nShCheck_8thMod1 = Use8thMod == true and Engagey == 0 and SSGuppyFinal == 1 ? MTISignal : -1\r\n\r\nLgCheck_8thMod2 = Use8thMod == true ? MTISignal : 1\r\nShCheck_8thMod2 = Use8thMod == true ? MTISignal : -1\r\n\r\nLgCheck_8thMod = MTIAgressiveTrend == true ? LgCheck_8thMod1 : LgCheck_8thMod2\r\nShCheck_8thMod = MTIAgressiveTrend == true ? ShCheck_8thMod1 : ShCheck_8thMod2\r\n\r\nLgCheck_8thModDPT = MTISignal == 1 ? 1 : 0\r\nShCheck_8thModDPT = MTISignal == -1 ? -1 : 0\r\n\r\n//check to see if we should be closing trades on eigth Module Signals\r\nEigth_LongCloseCheck = EigthCloseCheck == true ? MTISignal : 1\r\nEigth_ShortCloseCheck = EigthCloseCheck == true ? MTISignal : -1\r\n\r\n//end of eigth Module\r\n\r\n////////////////////////////////////////////////////////////////\r\n//* Ninth   Module                                          *//\r\n//*Code Type - Simple Ichimoku cloud                         *//\r\n////////////////////////////////////////////////////////////////\r\n\r\n//Ninth Module - Yes or no to use\r\nvar TEMod9 = 'Ninth Module - Simple Ichimoku Cloud (SIC)'\r\nUseNinthMod = input(true, title = 'Use Ninth Module - Simple Ichimoku Cloud (SIC)', group = TEMod9)\r\nSICAgressiveTrend = input(true, 'Use Agressive Trend Mapping for SIC (Default = Yes)', group = TEMod9)\r\nNinthCloseCheck = input(false, title = 'Close Trade on SIC Signal? (Default = No)', group = TEMod9)\r\n\r\n//place Ninth Module code below this line\r\n//Simple Ichimokue Cloud Indicator, originally by Yo_adriiiiaan, modified by SignalLynx for use in the trade engine\r\n\r\nconversionPeriodsICHICLOUD = 9\r\nbasePeriodsICHICLOUD = 26\r\nlaggingSpan2PeriodsICHICLOUD = 52\r\ndisplacementICHICLOUD = 26\r\n\r\ndonchianICHICLOUD(lenICHICLOUD) =>\r\n    math.avg(ta.lowest(lenICHICLOUD), ta.highest(lenICHICLOUD))\r\n\r\nconversionLineICHICLOUD = donchianICHICLOUD(conversionPeriodsICHICLOUD)\r\nbaseLineICHICLOUD = donchianICHICLOUD(basePeriodsICHICLOUD)\r\nleadLine1ICHICLOUD = math.avg(conversionLineICHICLOUD, baseLineICHICLOUD)\r\nleadLine2ICHICLOUD = donchianICHICLOUD(laggingSpan2PeriodsICHICLOUD)\r\n\r\nbuyICHICLOUD = close > leadLine1ICHICLOUD[26] and close > leadLine2ICHICLOUD[26]\r\nsellICHICLOUD = close < leadLine1ICHICLOUD[26] and close < leadLine2ICHICLOUD[26]\r\n\r\nIchiCloud_Trend = close > leadLine1ICHICLOUD[26] and close > leadLine2ICHICLOUD[26] ? 1 : close < leadLine1ICHICLOUD[26] and close < leadLine2ICHICLOUD[26] ? -1 : 0\r\n\r\nIchiCloudTrendAverage = (IchiCloud_Trend + IchiCloud_Trend[1] + IchiCloud_Trend[2] + IchiCloud_Trend[3]) / 4\r\n\r\nIchi_Cloud_FinalOrder = IchiCloudTrendAverage > 0.7 ? 1 : IchiCloudTrendAverage < -0.7 ? -1 : 0\r\n\r\n//Convert Module signal to trade engine\r\n//1 for Buy, -1 for sell, 0 is no trade\r\n\r\nNinthSignal = Ichi_Cloud_FinalOrder\r\n\r\n//No Module code below this line -trade engine code\r\n\r\n//Final Trade Engine signals conversions from first Module\r\n\r\n//Check to see if we should be using 9th Module signals for buys/sells\r\n\r\nLgCheck_9thMod1 = UseNinthMod == true and TrendPath2 == 0 ? NinthSignal : 1\r\nShCheck_9thMod1 = UseNinthMod == true and TrendPath2 == 0 ? NinthSignal : -1\r\n\r\nLgCheck_9thMod2 = UseNinthMod == true ? NinthSignal : 1\r\nShCheck_9thMod2 = UseNinthMod == true ? NinthSignal : -1\r\n\r\nLgCheck_9thMod = SICAgressiveTrend == true ? LgCheck_9thMod1 : LgCheck_9thMod2\r\nShCheck_9thMod = SICAgressiveTrend == true ? ShCheck_9thMod1 : ShCheck_9thMod2\r\n\r\nLgCheck_9thModDPT = NinthSignal == 1 ? 1 : 0\r\nShCheck_9thModDPT = NinthSignal == -1 ? -1 : 0\r\n\r\nNinth_inLong = NinthSignal == 1 ? 1 : -1\r\nNinth_inShort = NinthSignal == -1 ? -1 : 1\r\n\r\n//check to see if we should be closing trades on Ninth Module Signals\r\nNinth_LongCloseCheck = NinthCloseCheck == true ? Ninth_inLong : 1\r\nNinth_ShortCloseCheck = NinthCloseCheck == true ? Ninth_inShort : -1\r\n\r\n//End of Ninth Module code\r\n\r\n////////////////////////////////////////////////////////////////\r\n//* Tenth Module                                            *//\r\n//*Code Type - Simple Harmonic Oscillator                    *//\r\n////////////////////////////////////////////////////////////////\r\n\r\n//Tenth Module - Yes or no to use\r\nvar TEMod10 = 'Tenth Module - Simple Harmonic Oscillator'\r\nUseTenthMod = input(true, title = 'Use Tenth Module - Simple Harmonic Oscillator', group = TEMod10)\r\nTenthCloseCheck = input(false, title = 'Close Trade on Harmonic Signal? (Default = No)', group = TEMod10)\r\n\r\n//Place tenth Module code below this line\r\n\r\n\r\n//Inputs\r\nAgressiveHARM = input(false, 'Use Agressive Harmoic Setting (Default = Conservative)', group = TEMod10)\r\nsrcHO = close\r\nlenHO = 14\r\npi = 3.14159265359\r\n\r\nsho(s) =>\r\n    C = s\r\n    Cy = C[1]\r\n    Cby = C[2]\r\n    Vt = C - Cy\r\n    Vy = Cy - Cby\r\n    At = Vt - Vy\r\n    A = ta.ema(At, lenHO)\r\n    T = 2 * pi * math.sqrt(math.abs(Vt / A))\r\n    Ti = C > Cy ? T : T * -1\r\n    VP = ta.ema(Ti, lenHO)\r\n    TP = ta.ema(T, lenHO)\r\n    SHO = VP / TP * 100\r\n    SHO\r\n\r\nsho_line = sho(srcHO)\r\nsignal = ta.sma(sho_line, 3)\r\n\r\n//Final Buy Signals\r\n\r\ns_harmonic = signal\r\nnm_harmonic = 1\r\nrising_old_harmonic(s_harmonic, nm_harmonic) =>\r\n    res = true\r\n    for i = 1 to nm_harmonic by 1\r\n        if s_harmonic[0] <= s_harmonic[i]\r\n            res := false\r\n            break\r\n    res\r\n\r\nHarmonicAgressSig = rising_old_harmonic(s_harmonic, nm_harmonic) ? 1 : -1\r\nHarmonicSignal = HarmonicAgressSig > 0 and AgressiveHARM == true ? 1 : HarmonicAgressSig < 0 and AgressiveHARM == true ? -1 : signal > 0 and AgressiveHARM == false ? 1 : signal < 0 and AgressiveHARM == false ? -1 : 0\r\n\r\n//Convert Module signal to trade engine \r\n//1 for Buy, -1 for sell, 0 is no trade\r\n\r\nTenthSignal = HarmonicSignal\r\n\r\n//No Module code below this line -trade engine code\r\n\r\n//Final Trade Engine signals conversions from first Module\r\n\r\n//Check to see if we should be using 10th Module signals for buys/sells\r\n\r\nLgCheck_10thMod = UseTenthMod == true ? TenthSignal : 1\r\nShCheck_10thMod = UseTenthMod == true ? TenthSignal : -1\r\n\r\nLgCheck_10thModDPT = TenthSignal == 1 ? 1 : 0\r\nShCheck_10thModDPT = TenthSignal == -1 ? -1 : 0\r\n\r\nTenth_inLong = TenthSignal == 1 ? 1 : -1\r\nTenth_inShort = TenthSignal == -1 ? -1 : 1\r\n\r\n//check to see if we should be closing trades on Tenth Module Signals \r\nTenth_LongCloseCheck = TenthCloseCheck == true ? Tenth_inLong : 1\r\nTenth_ShortCloseCheck = TenthCloseCheck == true ? Tenth_inShort : -1\r\n\r\n//End of tenth Module code\r\n\r\n///////////////////////////////////////////////////////////////\r\n//* Eleventh   Module                                      *// \r\n//*Code Type - Hirashina Sugita Compression                 *//  \r\n/////////////////////////////////////////////////////////////// \r\n\r\n//Eleventh Module - Yes or no to use\r\nvar TEMod11 = 'Eleventh Module - HRSR Compression OR Super AO'\r\nUse11thMod = input(false, title = 'Use Eleventh Module - HRSR Compression OR Super AO (Default = No)', group = TEMod11)\r\nEleventhModChoice = input(false, title = 'Use Super AO (Default = HSRS Compression)', group = TEMod11)\r\nEleventhCloseCheck = input(false, title = 'Close Trade on HSRS Comp Signal? (Default = No)', group = TEMod11)\r\n\r\n//place 11th Module code below this line\r\n\r\n///By SignalLynx, built off someones originally HSRS script\r\n\r\n//inputs Hirashima Sugita R/s\r\nlengthComp = input.int(21, title = 'HSRS Compression Length', minval = 1, group = TEMod11)\r\ncompTrigger = 2 // input(2)\r\n\r\n//Hirashima Sugita R/S Code - Compression Comp\r\nmaComp = ta.ema(close, lengthComp)\r\ndComp = close - maComp\r\n//\r\nsComp = ta.linreg(dComp, lengthComp, 0)\r\nxComp = maComp + sComp\r\n//\r\nd_Comp = close - xComp\r\ns_Comp = ta.linreg(d_Comp, lengthComp, 0)\r\nbasisComp = maComp + sComp + ta.change(s_Comp)\r\n//\r\nupperComp = basisComp + ta.wma(math.abs(dComp), lengthComp)\r\nlowerComp = basisComp - ta.wma(math.abs(dComp), lengthComp)\r\nupper_Comp = upperComp + ta.wma(math.abs(dComp), lengthComp)\r\nlower_Comp = lowerComp - ta.wma(math.abs(dComp), lengthComp)\r\n\r\nHSRS_Spread = math.abs(basisComp - close) //upperComp - lowerComp\r\n\r\nHSRSCompression = HSRS_Spread / close * 100\r\nHSRSCompSig = HSRSCompression >= compTrigger ? 1 : -1\r\n\r\nHSRSBandSig = close > upperComp ? 1 : close < lowerComp ? -1 : 0\r\n\r\n//Super AO\r\n\r\n//Super-AO - By SignalLynx\r\n\r\n//Awesome Oscilator\r\nAOfastLength = input(title = 'AO Fast Length', defval = 14)\r\nAOslowLength = input(title = 'AO Slow Length', defval = 500)\r\nao = ta.sma(close, AOfastLength) - ta.sma(close, AOslowLength)\r\nAOSmoothInput = input(title = 'AO Smoother length', defval = 21)\r\naoSmooth = ta.ema(ao, AOSmoothInput)\r\nAORising = ta.rising(ao, AOSmoothInput) ? 1 : -1\r\n\r\n//SuperTrend\r\nSTPeriods = input(title = 'ST ATR Period', defval = 14)\r\nSTsrc = close\r\nSTMultiplier = input.float(title = 'ST ATR Multiplier', defval = 7)\r\n\r\n\r\nSTatr = ta.atr(STPeriods)\r\nSTup = STsrc - STMultiplier * STatr\r\nSTup1 = nz(STup[1], STup)\r\nSTup := close[1] > STup1 ? math.max(STup, STup1) : STup\r\nSTdn = STsrc + STMultiplier * STatr\r\nSTdn1 = nz(STdn[1], STdn)\r\nSTdn := close[1] < STdn1 ? math.min(STdn, STdn1) : STdn\r\nSTtrend = 1\r\nSTtrend := nz(STtrend[1], STtrend)\r\nSTtrend := STtrend == -1 and close > STdn1 ? 1 : STtrend == 1 and close < STup1 ? -1 : STtrend\r\nSTbuySignal = STtrend == 1 and STtrend[1] == -1\r\nSTsellSignal = STtrend == -1 and STtrend[1] == 1\r\n\r\nSTdnsmooth = ta.sma(STdn, 14)\r\nSTupsmooth = ta.sma(STup, 14)\r\nSTUpRise = ta.rising(STupsmooth, 14) and STtrend == 1 ? 1 : 0\r\nSTDnFall = ta.falling(STdnsmooth, 14) and STtrend == -1 ? -1 : 0\r\n\r\n//final signals\r\nSAO = ao >= 0 and AORising == 1 and STtrend == 1 ? 1 : ao <= 0 and AORising == -1 and STtrend == -1 ? -1 : 0\r\n\r\n//Convert Module signal to trade engine\r\n//1 for Buy, -1 for sell, 0 is no trade\r\n\r\nEleventhSignal = EleventhModChoice == false ? HSRSBandSig : SAO\r\n\r\n//No Module code below this line -trade engine code\r\n\r\n//Final Trade Engine signals conversions from first Module\r\n\r\n//Check to see if we should be using 11th Module signals for buys/sells\r\n\r\nLgCheck_11thMod = Use11thMod == true ? EleventhSignal : 1\r\nShCheck_11thMod = Use11thMod == true ? EleventhSignal : -1\r\n\r\nLgCheck_11thModDPT = EleventhSignal == 1 ? 1 : 0\r\nShCheck_11thModDPT = EleventhSignal == -1 ? -1 : 0\r\n\r\nEleventh_inLong = EleventhSignal == 1 ? 1 : -1\r\nEleventh_inShort = EleventhSignal == -1 ? -1 : 1\r\n\r\n//check to see if we should be closing trades on Eleventh Module Signals\r\nEleventh_LongCloseCheck = EleventhCloseCheck == true ? Eleventh_inLong : 1\r\nEleventh_ShortCloseCheck = EleventhCloseCheck == true ? Eleventh_inShort : -1\r\n\r\n//End of 11th Module code\r\n\r\n////////////////////////////////////////////////////////////////\r\n//* Twelfth   Module                                        *//\r\n//*Code Type - Fisher Transform MultiTimeFrame               *//\r\n////////////////////////////////////////////////////////////////\r\n\r\n//Twelfth Module - Yes or no to use\r\nvar TEMod12 = 'Twelfth Module - Fischer Transform (MTF)'\r\nUse12thMod = input(false, title = 'Use Twelfth Module - Fischer Transform (MTF) - (Default = No)', group = TEMod12)\r\nTwelfthCloseCheck = input(false, title = 'Close Trade on Fischer Transform Signal? (Default = No)', group = TEMod12)\r\n\r\n//place 12th Module code below this line\r\n//original script by mortdiggiddy, converted to V4/v5 and modified for trade engine by SignalLynx\r\n\r\nlengthFTMTF = 10 //input.int(10, title='Length', minval=1)\r\nweightFTMTF = 0.33 //input(0.33, title=\"Normalized Price Weighting (0 < weight < 1)\", type=input.float, minval=0.001, maxval=0.999, step=0.01)\r\n\r\nintval1FTMTF = input.string('Day', 'Fischer Transform ATR', options = ['M01', 'M03', 'M05', 'M15', 'M30', 'M45', 'H01', 'H02', 'H03', 'H04', 'H06', 'H08', 'H12', 'Day', 'Week', 'Month', 'Year'], group = TEMod12)\r\n\r\nthresh1FTMTF = 1.0\r\nthresh2FTMTF = 2.5\r\n\r\nuseChartIntVal1FTMTF = false //input(false, \"Always Use Chart Interval Instead?\")\r\n\r\n// Correct the interval used\r\ngetRezFTMTF(intvalFTMTF) =>\r\n    iff_1 = intvalFTMTF == 'Year' ? '12M' : '60'\r\n    iff_2 = intvalFTMTF == 'Month' ? 'M' : iff_1\r\n    iff_3 = intvalFTMTF == 'Week' ? 'W' : iff_2\r\n    iff_4 = intvalFTMTF == 'Day' ? 'D' : iff_3\r\n    iff_5 = intvalFTMTF == 'H12' ? '720' : iff_4\r\n    iff_6 = intvalFTMTF == 'H08' ? '480' : iff_5\r\n    iff_7 = intvalFTMTF == 'H06' ? '360' : iff_6\r\n    iff_8 = intvalFTMTF == 'H04' ? '240' : iff_7\r\n    iff_9 = intvalFTMTF == 'H03' ? '180' : iff_8\r\n    iff_10 = intvalFTMTF == 'H02' ? '120' : iff_9\r\n    iff_11 = intvalFTMTF == 'H01' ? '60' : iff_10\r\n    iff_12 = intvalFTMTF == 'M45' ? '45' : iff_11\r\n    iff_13 = intvalFTMTF == 'M30' ? '30' : iff_12\r\n    iff_14 = intvalFTMTF == 'M15' ? '15' : iff_13\r\n    iff_15 = intvalFTMTF == 'M05' ? '5' : iff_14\r\n    iff_16 = intvalFTMTF == 'M03' ? '3' : iff_15\r\n    int_1FTMTF = intvalFTMTF == 'M01' ? '1' : iff_16\r\n    int_1FTMTF\r\n\r\nresFTMTF = getRezFTMTF(intval1FTMTF)\r\n\r\n// Show intermediate values for fisher transform along the time frame desired\r\ngetFisherFTMTF(lenFTMTF, rezFTMTF, useChartIntValFTMTF) =>\r\n    startFTMTF = request.security(syminfo.tickerid, rezFTMTF, time[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)\r\n    change_1 = ta.change(startFTMTF)\r\n\r\n\r\n    bool newSessionFTMTF = change_1 != 0\r\n    sinceNewFTMTF = ta.barssince(newSessionFTMTF)\r\n\r\n    barsInIntFTMTF = 0\r\n    barsInIntFTMTF := na(barsInIntFTMTF[1]) or sinceNewFTMTF > nz(barsInIntFTMTF[1]) ? sinceNewFTMTF : nz(barsInIntFTMTF[1])\r\n\r\n    isChartIntValFTMTF = useChartIntValFTMTF or barsInIntFTMTF == 0\r\n\r\n\r\n    hFTMTF = high\r\n    hFTMTF := isChartIntValFTMTF ? high : newSessionFTMTF ? high : math.max(nz(hFTMTF[1]), high)\r\n\r\n    lFTMTF = low\r\n    lFTMTF := isChartIntValFTMTF ? low : newSessionFTMTF ? low : math.min(nz(lFTMTF[1]), low)\r\n\r\n    opFTMTF = open\r\n    opFTMTF := newSessionFTMTF or isChartIntValFTMTF ? open : nz(opFTMTF[1])\r\n    pFTMTF = close\r\n\r\n    hh1FTMTF = ta.highest(pFTMTF, math.max(lengthFTMTF - 1, 1))\r\n    ll1FTMTF = ta.lowest(pFTMTF, math.max(lengthFTMTF - 1, 1))\r\n\r\n    hh2FTMTF = request.security(syminfo.tickerid, rezFTMTF, hh1FTMTF[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on) // grab previous highest-mid that is historical\r\n    ll2FTMTF = request.security(syminfo.tickerid, rezFTMTF, ll1FTMTF[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on) // grab previous lowest-mid that is historical\r\n\r\n    highest_1FTMTF = ta.highest(pFTMTF, lengthFTMTF) // merge the (length -1) highest-mid with current value\r\n    hhFTMTF = isChartIntValFTMTF ? highest_1FTMTF : math.max(hh2FTMTF, pFTMTF)\r\n    lowest_1FTMTF = ta.lowest(pFTMTF, lengthFTMTF) // merge the (length -1) lowest-mid with current value\r\n    llFTMTF = isChartIntValFTMTF ? lowest_1FTMTF : math.min(ll2FTMTF, pFTMTF)\r\n\r\n    v0FTMTF = 2 * ((pFTMTF - llFTMTF) / (hhFTMTF - llFTMTF) - 0.5) // price normalized to -1 <= p <= 1\r\n    v1FTMTF = 0.5\r\n\r\n    v1_pFTMTF = v1FTMTF\r\n    v1_pFTMTF := newSessionFTMTF or isChartIntValFTMTF ? nz(v1FTMTF[1]) : nz(v1_pFTMTF[1])\r\n\r\n    v1FTMTF := weightFTMTF * v0FTMTF + (1.0 - weightFTMTF) * v1_pFTMTF\r\n    v2FTMTF = math.max(math.min(v1FTMTF, 0.9999), -0.9999) // cap values to prevent floating point errors\r\n\r\n    sFisherFTMTF = 0.0\r\n\r\n    sFisher_pFTMTF = 0.0\r\n    sFisher_pFTMTF := newSessionFTMTF or isChartIntValFTMTF ? nz(sFisherFTMTF[1]) : nz(sFisher_pFTMTF[1])\r\n\r\n    fisherFTMTF = math.log((1 + v2FTMTF) / (1 - v2FTMTF)) // fisher transform function\r\n    sFisherFTMTF := 0.5 * (fisherFTMTF + sFisher_pFTMTF) // smoothed fisher transform\r\n\r\n    sFisherRFTMTF = math.round(sFisherFTMTF / 0.0001) * 0.0001\r\n\r\n    trendFTMTF = 0\r\n    change_1FTMTF = ta.change(sFisherRFTMTF)\r\n    change_2FTMTF = ta.change(sFisherRFTMTF)\r\n    trendFTMTF := barsInIntFTMTF == sinceNewFTMTF or useChartIntValFTMTF ? fisherFTMTF > sFisherFTMTF and change_1FTMTF >= 0 ? 1 : fisherFTMTF < sFisherFTMTF and change_2FTMTF <= 0 ? -1 : nz(trendFTMTF[1]) : nz(trendFTMTF[1])\r\n\r\n    trendChangeFTMTF = ta.change(trendFTMTF)\r\n\r\n    [sFisherFTMTF, sFisher_pFTMTF, trendFTMTF, trendChangeFTMTF]\r\n\r\n[fisherFTMTF, fisher1FTMTF, trendFTMTF, trendChangeFTMTF] = getFisherFTMTF(lengthFTMTF, resFTMTF, useChartIntVal1FTMTF)\r\n\r\nFTMTF_Signal = trendChangeFTMTF > 0 ? 10 : trendChangeFTMTF < 0 ? -10 : 0\r\n\r\nFTMTF_Signal_Final = float(na)\r\nFTMTF_Signal_Final := FTMTF_Signal == 10 ? 1 : FTMTF_Signal == -10 ? -1 : FTMTF_Signal_Final[1]\r\n\r\n//Convert Module signal to trade engine\r\n//1 for Buy, -1 for sell, 0 is no trade\r\n\r\nTwelfthSignal = FTMTF_Signal_Final\r\n\r\n//No Module code below this line -trade engine code\r\n\r\n//Final Trade Engine signals conversions from first Module\r\n\r\n//Check to see if we should be using 12th Module signals for buys/sells\r\n\r\nLgCheck_12thMod = Use12thMod == true ? TwelfthSignal : 1\r\nShCheck_12thMod = Use12thMod == true ? TwelfthSignal : -1\r\n\r\nLgCheck_12thModDPT = TwelfthSignal == 1 ? 1 : 0\r\nShCheck_12thModDPT = TwelfthSignal == -1 ? -1 : 0\r\n\r\nTwelfth_inLong = TwelfthSignal == 1 ? 1 : -1\r\nTwelfth_inShort = TwelfthSignal == -1 ? -1 : 1\r\n\r\n//check to see if we should be closing trades on Twelfth Module Signals\r\nTwelfth_LongCloseCheck = TwelfthCloseCheck == true ? Twelfth_inLong : 1\r\nTwelfth_ShortCloseCheck = TwelfthCloseCheck == true ? Twelfth_inShort : -1\r\n\r\n//End of 12th Module code\r\n\r\n////////////////////////////////////////////////////////////////\r\n//*Order Qualifier Module - Part of Risk Management         *// \r\n////////////////////////////////////////////////////////////////\r\n\r\n//ADX - Identfies flat market and does not place orders if true\r\nvar TEADX = 'ADX Module - Flat Market Protocol'\r\nUseADX = input(false, title = 'Use ADX Qualifier - Will not Trade in Flat Market', group = TEADX)\r\nADXlen = input.int(25, minval = 1, title = 'ADX DI Length', group = TEADX)\r\nADXlensig = 14 //input(14, title=\"ADX Smoothing\", minval=1, maxval=50)\r\nADXlenDPT = 4 //input(4, minval=1, title=\"ADX DPT Length\")\r\n\r\nADXup = ta.change(high)\r\nADXdown = -ta.change(low)\r\nADXtrur = ta.rma(ta.tr, ADXlen)\r\nADXtrurDPT = ta.rma(ta.tr, ADXlenDPT)\r\n\r\nADXplus = fixnan(100 * ta.rma(ADXup > ADXdown and ADXup > 0 ? ADXup : 0, ADXlen) / ADXtrur)\r\nADXminus = fixnan(100 * ta.rma(ADXdown > ADXup and ADXdown > 0 ? ADXdown : 0, ADXlen) / ADXtrur)\r\nADXplusDPT = fixnan(100 * ta.rma(ADXup > ADXdown and ADXup > 0 ? ADXup : 0, ADXlenDPT) / ADXtrurDPT)\r\nADXminusDPT = fixnan(100 * ta.rma(ADXdown > ADXup and ADXdown > 0 ? ADXdown : 0, ADXlenDPT) / ADXtrurDPT)\r\n\r\nADXsum = ADXplus + ADXminus\r\nadx = 100 * ta.rma(math.abs(ADXplus - ADXminus) / (ADXsum == 0 ? 1 : ADXsum), ADXlensig)\r\nADXsumDPT = ADXplusDPT + ADXminusDPT\r\nadxDPT = 100 * ta.rma(math.abs(ADXplusDPT - ADXminusDPT) / (ADXsumDPT == 0 ? 1 : ADXsumDPT), ADXlensig)\r\n\r\nADXosob = 40 // input(40, title='Exhaustion Level for ADX, default = 40')\r\nADXThreshold = input(10, title = 'Primary Order Activation Threshold (Default = 10)', group = TEADX)\r\nADXSepThreshold = input(8, title = 'Secondary Order Activation Threshold (Default = 8)', group = TEADX)\r\n\r\n//Buy Signal for Trade Engine\r\nADX_OrderActivate = adx > ADXThreshold ? 1 : 0\r\nADX_RM = adx < ADXThreshold ? 1 : 0\r\nADXSep = math.abs(ADXplus - ADXminus)\r\nADXSepActivate = ADXSep > ADXSepThreshold ? 1 : 0\r\n\r\n//Buy Signal for DPT\r\nADX_OrderActivateDPT = adxDPT > ADXThreshold ? 1 : 0\r\nADX_RMDPT = adxDPT < ADXThreshold ? 1 : 0\r\nADXSepDPT = math.abs(ADXplusDPT - ADXminusDPT)\r\nADXSepActivateDPT = ADXSepDPT > ADXSepThreshold ? 1 : 0\r\n\r\n//Trade engine Buy Signals\r\nADXFinal = ADX_OrderActivate == 1 and ADXSepActivate == 1 ? 1 : 0\r\n\r\n//DPT Signals\r\nADXFinalDPTN = ADX_OrderActivateDPT == 1 and ADXSepActivateDPT == 1 ? 0 : -1\r\nADXFinalDPTM = ADX_OrderActivateDPT == 1 and ADXSepActivateDPT == 1 ? 1 : 0\r\n\r\n//Check for ADX Use\r\nADX_Check = UseADX == true ? ADXFinal : 1\r\n\r\n//Smoothed RSI\r\nvar RSIMOD = 'RSI Module -  Market Protocols'\r\nUseConRSI = input(true, title = 'Use Order Constraining RSI - Do not place order if Above/Below limits', group = RSIMOD)\r\nSlength = input(7, 'Fast RSI Length', group = RSIMOD)\r\nSlengthSlow = input(35, 'Slow RSI Length', group = RSIMOD)\r\nSp = ta.ema(ta.rsi(close, Slength), 5)\r\nSpSlow = ta.ema(ta.rsi(close, SlengthSlow), 5)\r\n\r\nintval1FTMTFXQQE = input.string('Week', 'QQE Module ATR - Determines use of Fast/Slow RSI', options = ['H01', 'H02', 'H03', 'H04', 'H06', 'H08', 'H12', 'Day', '2D', '3D', '4D', 'Week', 'Month', 'Year'], group = RSIMOD)\r\n\r\n// Correct the interval used\r\ngetRezFTMTFXQQE(intvalFTMTFXQQE) =>\r\n    iff_1XQQE = intvalFTMTFXQQE == 'Year' ? '12M' : '60'\r\n    iff_2XQQE = intvalFTMTFXQQE == 'Month' ? 'M' : iff_1XQQE\r\n    iff_3XQQE = intvalFTMTFXQQE == 'Week' ? 'W' : iff_2XQQE\r\n    iff_4XQQE = intvalFTMTFXQQE == 'Day' ? '4D' : iff_3XQQE\r\n    iff_5XQQE = intvalFTMTFXQQE == 'Day' ? '3D' : iff_4XQQE\r\n    iff_6XQQE = intvalFTMTFXQQE == 'Day' ? '2D' : iff_5XQQE\r\n    iff_7XQQE = intvalFTMTFXQQE == 'Day' ? 'D' : iff_6XQQE\r\n    iff_8XQQE = intvalFTMTFXQQE == 'H12' ? '720' : iff_7XQQE\r\n    iff_9XQQE = intvalFTMTFXQQE == 'H08' ? '480' : iff_8XQQE\r\n    iff_10XQQE = intvalFTMTFXQQE == 'H06' ? '360' : iff_9XQQE\r\n    iff_11XQQE = intvalFTMTFXQQE == 'H04' ? '240' : iff_10XQQE\r\n    iff_12XQQE = intvalFTMTFXQQE == 'H03' ? '180' : iff_11XQQE\r\n    iff_13XQQE = intvalFTMTFXQQE == 'H02' ? '120' : iff_12XQQE\r\n    int_1FTMTFXQQE = intvalFTMTFXQQE == 'H01' ? '60' : iff_13XQQE\r\n    int_1FTMTFXQQE\r\n\r\nresFTMTFXQQE = getRezFTMTFXQQE(intval1FTMTFXQQE)\r\n\r\nsrcQQE = request.security(syminfo.tickerid, resFTMTFXQQE, close[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)\r\nlengthQQE = input.int(14, 'QQE Module - RSI Length', minval = 1, group = RSIMOD)\r\nSSFQQE = 5 //input.int(5, 'SF RSI SMoothing Factor', minval=1)\r\nRSIIQQE = ta.ema(ta.rsi(srcQQE, lengthQQE), SSFQQE)\r\nTRQQE = math.abs(RSIIQQE - RSIIQQE[1])\r\nwwalphaQQE = 1 / lengthQQE\r\nWWMAQQE = 0.0\r\nWWMAQQE := wwalphaQQE * TRQQE + (1 - wwalphaQQE) * nz(WWMAQQE[1])\r\nATRRSIQQE = 0.0\r\nATRRSIQQE := wwalphaQQE * WWMAQQE + (1 - wwalphaQQE) * nz(ATRRSIQQE[1])\r\nQQEFQQE = ta.ema(ta.rsi(srcQQE, lengthQQE), SSFQQE)\r\nQUPQQE = QQEFQQE + ATRRSIQQE * 4.236\r\nQDNQQE = QQEFQQE - ATRRSIQQE * 4.236\r\nQQESQQE = 0.0\r\nQQESQQE := QUPQQE < nz(QQESQQE[1]) ? QUPQQE : QQEFQQE > nz(QQESQQE[1]) and QQEFQQE[1] < nz(QQESQQE[1]) ? QDNQQE : QDNQQE > nz(QQESQQE[1]) ? QDNQQE : QQEFQQE < nz(QQESQQE[1]) and QQEFQQE[1] > nz(QQESQQE[1]) ? QUPQQE : nz(QQESQQE[1])\r\n\r\nbuySignalrQQE = ta.crossover(QQEFQQE, QQESQQE)\r\nsellSignallrQQE = ta.crossunder(QQEFQQE, QQESQQE)\r\n\r\nvar QQE_Signal = 0\r\nQQE_Signal := buySignalrQQE ? 1 : sellSignallrQQE ? -1 : QQE_Signal[1]\r\nSpX = QQE_Signal == 1 ? Sp : SpSlow\r\n\r\n//RSI oversold/overbought Modules\r\n//First Section - Do not long/short\r\nSRSI_UpperOrder = input(90, 'RSI Upper Order Limit', group = RSIMOD)\r\nSRSI_LowerOrder = input(10, 'RSI Lower Order Limit', group = RSIMOD)\r\nSRSI_UpperChop = input(56, 'RSI - CHOP - Upper Order Limit', group = RSIMOD)\r\nSRSI_LowerChop = input(44, 'RSI - CHOP - Lower Order Limit', group = RSIMOD)\r\n\r\n//BollingerBand Chop Inidicator\r\nvar BBCHopMod = 'Bollinger Band Chop Qualifier'\r\nUseBBInhib = input(true, title = 'Use Order Constraining Bollinger Band Inhibitor', group = BBCHopMod)\r\nsrcMBB = close\r\nlengthMBB = 34\r\nmultMBB = 2.0\r\n\r\nbasisMBB = ta.sma(srcMBB, lengthMBB)\r\ndevMBB = ta.stdev(srcMBB, lengthMBB)\r\ndev2MBB = multMBB * devMBB\r\ndev3MBB = multMBB * 2 * devMBB\r\n\r\nupper1MBB = basisMBB + devMBB\r\nlower1MBB = basisMBB - devMBB\r\nupper2MBB = basisMBB + dev2MBB\r\nlower2MBB = basisMBB - dev2MBB\r\nupper3MBB = basisMBB + dev3MBB\r\nlower3MBB = basisMBB - dev3MBB\r\n\r\nBBInhibPercent = input(15, 'BB Activation Percentage', group = BBCHopMod)\r\nBBTrend = upper3MBB - lower3MBB\r\nBBTrendSmooth = ta.ema(BBTrend, 14)\r\n\r\ns_BB = BBTrendSmooth\r\nnm_BB = 14\r\nrising_old_BB(s_BB, nm_BB) =>\r\n    res = true\r\n    for i = 1 to nm_BB by 1\r\n        if s_BB[0] <= s_BB[i]\r\n            res := false\r\n            break\r\n    res\r\n\r\nBBTrendUp = rising_old_BB(s_BB, nm_BB) == true ? 1 : 0\r\nBBChopInhib = close * (BBInhibPercent / 100) > upper3MBB - lower3MBB ? 1 : 0\r\nBBChopInhibFinal = UseBBInhib == true and BBTrendUp == 0 ? BBChopInhib : 1\r\n\r\nBBADXKicker := close < lower3MBB or close > upper3MBB ? 1 : close <= upper3MBB and close > upper2MBB ? 2 : close >= lower3MBB and close < lower2MBB ? 2 : close <= upper2MBB and close > upper1MBB ? 3 : close >= lower2MBB and close < lower1MBB ? 3 : 4 // close <=upper1MBB and close > lower1MBB ? 4: 0\r\n\r\n// Chop Filter\r\nUseCFInhibPre = input(false, title = 'Use Chop Filter = BB Based (Default - No)', group = BBCHopMod)\r\nUseActiveChopFilter = input(false, 'Use Active Agressiviness - BB Based (Default- No)', group = BBCHopMod)\r\nUseCFInhib = QQE_Signal == 1 and UseActiveChopFilter == true ? true : UseActiveChopFilter == false ? UseCFInhibPre : false\r\nChopSignal = QQE_Signal == 1 ? 0 : 1\r\nChopFilterInhibFinal = UseCFInhib == true ? ChopSignal : 1\r\n\r\nSRSI_NoBuy = SpX < SRSI_UpperOrder ? true : false\r\nSRSI_NoSell = SpX > SRSI_LowerOrder ? true : false\r\nSRSI_NoBuyChop = SpX > SRSI_UpperChop and BBChopInhibFinal == 1 and ChopFilterInhibFinal == 1 ? true : false\r\nSRSI_NoSellChop = SpX < SRSI_LowerChop and BBChopInhibFinal == 1 and ChopFilterInhibFinal == 1 ? true : false\r\n\r\nSRSI_NoBuyFinal = SRSI_NoBuy == true and SRSI_NoBuyChop == true ? 1 : UseConRSI == false ? 1 : 0\r\nSRSI_NoSellFinal = SRSI_NoSell == true and SRSI_NoSellChop == true ? 1 : UseConRSI == false ? 1 : 0\r\n\r\n//Second Module - close Orders based on RSI\r\n//RSI oversold/overbought Module\r\nvar RSICloseMod = 'Close on RSI Level'\r\nSellOnRSI = input(false, title = 'Close On RSI - Close Orders if RSI Level Breached', group = RSICloseMod)\r\nSOR_UpperOrder = input(90, 'RSI - Close on Upper Limit', group = RSICloseMod)\r\nSOR_LowerOrder = input(10, 'RSI - Close on Lower Limit', group = RSICloseMod)\r\n\r\nSOR_CloseLong = Sp > SOR_UpperOrder ? true : false\r\nSOR_CloseShort = Sp < SOR_LowerOrder ? true : false\r\nSOR_CloseLong_Final = SOR_CloseLong == true ? 1 : 0\r\nSOR_CloseShort_Final = SOR_CloseShort == true ? 1 : 0\r\nSOR_CloseLong_Check = SellOnRSI == true ? SOR_CloseLong_Final : 0\r\nSOR_CloseShort_Check = SellOnRSI == true ? SOR_CloseShort_Final : 0\r\n\r\n////////////////////////////////////////////////////////////////\r\n//* Miner Capitulation - HashRate                            *//\r\n////////////////////////////////////////////////////////////////\r\n\r\nvar MinerMod = 'Miner Hash Rate Qualifier'\r\nUseMCHR = input(false, title = 'Do Not Trade During Miner Captiulation? (Default = Yes Trade)', group = MinerMod)\r\nMCHRCloseCheck = input(false, title = 'Close Trade on Miner Capitulation? (Default = No)', group = MinerMod)\r\nMCHR_Tail = input(7, 'MCHR Tail Off Percent (%)', group = MinerMod) / 100\r\nHashSource = input.string('INTOTHEBLOCK:BTC_HASHRATE', options = ['QUANDL:BCHAIN/HRATE', 'INTOTHEBLOCK:BTC_HASHRATE'], title = 'Source Hash Rate')\r\n\r\n// Hash Ribbons Indicator\r\nMCHRHR_short = request.security(HashSource, 'D', ta.sma(close, 30)[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)\r\nMCHRHR_long = request.security(HashSource, 'D', ta.sma(close, 60)[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)\r\n\r\n//-1 is Capitulation\r\nMinercapitulation = MCHRHR_short >= MCHRHR_long ? 1 : -1\r\n\r\nMCHRdelta = MCHRHR_short - MCHRHR_long\r\nMCHRdiff = MCHRdelta / MCHRHR_short * 100\r\n\r\nvar MCHRHashCounter = 0\r\nMCHRHashCounter := Minercapitulation == -1 and MCHRHR_short < MCHRHR_short[1] ? MCHRHashCounter - 1 : Minercapitulation == 1 ? 0 : MCHRHashCounter[1]\r\nMCHRHashCounterSmoother = ta.sma(MCHRHashCounter, 21)\r\n\r\nMCHRR2 = MCHRHashCounterSmoother * MCHR_Tail\r\n\r\ns_MCHR = MCHRdiff\r\nnm_MCHR = 7\r\nrising_old_MCHR(s_MCHR, nm_MCHR) =>\r\n    res = true\r\n    for i = 1 to nm_MCHR by 1\r\n        if s_MCHR[0] <= s_MCHR[i]\r\n            res := false\r\n            break\r\n    res\r\n\r\n// --- V6 FIX EXPLANATION ---\r\n// Pre-calculating the loop result before using it in the ternary operator.\r\nMCHR_isRising = rising_old_MCHR(s_MCHR, nm_MCHR)\r\nMCHRHashClear = ta.crossover(MCHRdiff, MCHRR2) and MCHR_isRising ? 10 : 0\r\nMCHRHash_CU = ta.crossunder(MCHRdiff, MCHRR2) ? 0 : -1\r\nMCHRHashClearSignal = float(na)\r\nMCHRHashClearSignal := MCHRHashClear == 10 ? 1 : Minercapitulation == 1 ? 0 : MCHRHash_CU == 0 ? 0 : MCHRHashClearSignal[1]\r\n\r\nMinerCapitulationFinal = Minercapitulation == -1 and MCHRHashClearSignal == 0 ? -1 : 1\r\n\r\nMinerPlot = MCHRHR_short < MCHRHR_long\r\n\r\nMCHR_Change = MinerCapitulationFinal == MinerCapitulationFinal[1] ? 1 : -1\r\n//Final SIgnals for Module\r\n\r\n//Check to see if we should be using MCHR Module\r\nCheck_MCHR = UseMCHR == true ? MinerCapitulationFinal : 1\r\n\r\n//check to see if we should be closing trades on MCHR Signals\r\nvar HalvingKicker = 0\r\nvar MCStateKicker = 0\r\nMCHR_CloseCheck = MCHRCloseCheck == true ? MinerCapitulationFinal : 1\r\nMCHR_Change_Final = MCHRCloseCheck == true and HalvingKicker == 0 ? MCHR_Change : MCStateKicker == 2 and HalvingKicker == 1 ? 1 : MCStateKicker == -2 and HalvingKicker == 1 ? -1 : int(MCStateKicker / 2)\r\n\r\n/////////////////////////////////////////////////////////////////////////////////\r\n//======[ Trailing Stop  Activator - Ehlers Super BandPass Filter (ESPF)]======//\r\n/////////////////////////////////////////////////////////////////////////////////\r\n\r\nfastLengthESPF = 40\r\nslowLengthESPF = 60\r\nsrcESPF = close\r\nvar ESBFMod = 'Ehlers Super BandPass Filter (ESPF)'\r\nUseESPFMod = input(false, title = 'Inhibit Trade based on ESBF? (Default = No)', group = ESBFMod)\r\nESPFCloseCheck = input(false, title = 'Close Trade on ESPF Signal? (Default = No)', group = ESBFMod)\r\nstdDevESPFInhibit = input.float(title = 'Main ESBF Inhibit', minval = 0, maxval = 10, step = 0.1, defval = 2.0, group = ESBFMod)\r\nstdDevESPF1 = input.float(title = 'Trailing Stop ESBF Inhibit', minval = 0, maxval = 10, step = 0.1, defval = 2.0, group = ESBFMod)\r\nstdDevESPFMartingale = input.float(title = 'Martingale ESBF Inhibit', minval = 0, maxval = 10, step = 0.1, defval = 1.5, group = ESBFMod)\r\n\r\ngetESPF(srcESPF, fastLengthESPF, slowLengthESPF) =>\r\n    a1ESPF = 5 / fastLengthESPF\r\n    a2ESPF = 5 / slowLengthESPF\r\n\r\n    espf = 0.0\r\n    espf := (a1ESPF - a2ESPF) * srcESPF + (a2ESPF * (1 - a1ESPF) - a1ESPF * (1 - a2ESPF)) * nz(srcESPF[1]) + (1 - a1ESPF + 1 - a2ESPF) * nz(espf[1]) - (1 - a1ESPF) * (1 - a2ESPF) * nz(espf[2])\r\n    espf\r\n\r\nespf = getESPF(srcESPF, fastLengthESPF, slowLengthESPF)\r\n\r\n// Compute Root Mean Square\r\nrmsESPF1 = math.sqrt(math.sum(espf * espf, 50) / 50) * stdDevESPF1\r\nrmsESPFInhibit = math.sqrt(math.sum(espf * espf, 50) / 50) * stdDevESPFInhibit\r\nrmsESPFMartingale = math.sqrt(math.sum(espf * espf, 50) / 50) * stdDevESPFMartingale\r\n\r\n//Signal: 1 indicates long trend, -1 indicates short trend\r\nespf_Signal1 = espf > rmsESPF1 ? 1 : espf < -rmsESPF1 ? -1 : 0\r\nespf_SignalInhibit = espf > rmsESPFInhibit ? 1 : espf < -rmsESPFInhibit ? -1 : 0\r\nespf_SignalMartingale = espf > rmsESPFMartingale ? 1 : espf < -rmsESPFMartingale ? -1 : 0\r\n\r\nespf_Pre_Final = espf_Signal1 == 1 and espf_Signal1 != espf_Signal1[1] ? 1 : espf_Signal1 == -1 and espf_Signal1 != espf_Signal1[1] ? -1 : 0\r\n\r\nespf_Pre_Inhibit = espf_SignalInhibit == 1 and espf_SignalInhibit != espf_SignalInhibit[1] ? 1 : espf_SignalInhibit == -1 and espf_SignalInhibit != espf_SignalInhibit[1] ? -1 : 0\r\n\r\nespf_Pre_Martingale = espf_SignalMartingale == 1 and espf_SignalMartingale != espf_SignalMartingale[1] ? 1 : espf_SignalMartingale == -1 and espf_SignalMartingale != espf_SignalMartingale[1] ? -1 : 0\r\n\r\nespf_FinalX = float(na)\r\nespf_FinalX := espf_Pre_Final == 1 ? 1 : espf_Pre_Final == -1 ? -1 : espf_FinalX[1]\r\n\r\n//ESPFCloseCheck\r\nespf_Final = ESPFCloseCheck == true ? espf_FinalX : 0\r\n\r\nespf_Inhibit = float(na)\r\nespf_Inhibit := espf_Pre_Inhibit == 1 ? 1 : espf_Pre_Inhibit == -1 ? -1 : espf_Inhibit[1]\r\n\r\nespf_MartingaleFinal = float(na)\r\nespf_MartingaleFinal := espf_Pre_Martingale == 1 ? 1 : espf_Pre_Martingale == -1 ? -1 : espf_MartingaleFinal[1]\r\n\r\n//Final SIgnals for Module\r\n\r\n//Check to see if we should be using ESPF Module\r\nLgCheck_ESPFMod = UseESPFMod == true ? espf_Inhibit : 1\r\nShCheck_ESPFMod = UseESPFMod == true ? espf_Inhibit : -1\r\n\r\nESPF_inLong = espf_Inhibit == 1 ? 1 : -1\r\nESPF_inShort = espf_Inhibit == -1 ? -1 : 1\r\n\r\n//check to see if we should be closing trades on 1st Module Signals\r\nESPF_LongCloseCheck = ESPFCloseCheck == true ? ESPF_inLong : 1\r\nESPF_ShortCloseCheck = ESPFCloseCheck == true ? ESPF_inShort : -1\r\n\r\n//End of ESPF Module code\r\n\r\n\r\n////////////////////////////////////////////////////////////////\r\n// Pi Cycle Module                                            //\r\n//////////////////////////////////////////////////////////////// \r\n\r\n//Originally by Doncic, modified by SignalLynx for use in the trade engine\r\n\r\nvar PiOfC = 'Pi Cycle Bottom Indicator'\r\nUsePiC = input(true, title = 'Use Pi Cycle Bottom Indicator (Buys on Pi Cycle Signal)', group = PiOfC)\r\nSource_PiC = input(false, title = 'Use Chart Pair for Pi Cycle Signal - Default is BTC Pair (False)', group = PiOfC)\r\n\r\nln_ma_bottomlong = 471\r\nln_ma_bottomshort = 150\r\nlong_multiple = 0.745\r\nshort_multiple = 1\r\n\r\nSource_PiC_Final = Source_PiC == false ? 'COINBASE:BTCUSD' : syminfo.tickerid\r\n\r\nma_bottomlong = request.security(Source_PiC_Final, 'D', (ta.sma(close, ln_ma_bottomlong) * long_multiple)[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)\r\nma_bottomshort = request.security(Source_PiC_Final, 'D', (ta.ema(close, ln_ma_bottomshort) * short_multiple)[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)\r\nsrc = request.security(Source_PiC_Final, 'D', close[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)\r\n\r\n//1 = bottom\r\nPiCycleBottom = ta.crossunder(ma_bottomshort, ma_bottomlong) ? 1 : 0\r\nplotshape(PiCycleBottom == 1, style = shape.triangleup, size = size.small, text = 'Pi Cycle Bottom', color = color.new(color.aqua, 0), textcolor = color.new(color.aqua, 0), location = location.belowbar)\r\n\r\n//Final Signal for Pi Cycle Bottom\r\n\r\nPiC_Signal = UsePiC == true ? PiCycleBottom : 0\r\n\r\n//Weekend Halt\r\nvar WeekInputs = 'Trade Weekends?'\r\nWeekdayInput = input(false, title = 'Do NOT Trade WeekDAYS (Default=Trade)', group = WeekInputs)\r\nWeekendInput = input(false, title = 'Do NOT Trade WeekENDS (Default=Trade)', group = WeekInputs)\r\nweekend = dayofweek == 1 or dayofweek == 7 ? 1 : 0\r\nweekday = dayofweek == 2 or dayofweek == 3 or dayofweek == 4 or dayofweek == 5 or dayofweek == 6 ? 1 : 0\r\nWeekendHalt = WeekendInput == true ? weekend : 0\r\nWeekdayHalt = WeekdayInput == true ? weekday : 0\r\nDayHalt = WeekendHalt == 1 or WeekdayHalt == 1 ? 1 : 0\r\n\r\n////////////////////////////////////////////////////////////////\r\n// Dump Protection Team Module                                //\r\n////////////////////////////////////////////////////////////////  \r\n\r\n//Dump Protection Team Module - V1.0 - 5/24/20\r\n//Intent of the Dump Protection Team (DPT) is to predict Moon/Nukes and close any open trades accordingly. \r\n//Will also restart trading at end of whale manipulation\r\n\r\n///////////////////////////////////////////////////////////\r\n//Laguerrie Filter (LagF)                                //\r\n///////////////////////////////////////////////////////////\r\n\r\n//Orignally by KÄ±vanÃ§ Ã–zbilgiÃ§, modified by SignalLynx \r\nsrcLAGF = close\r\nalphaLAGF = 0.2\r\n\r\ngammaLAGF = 1 - alphaLAGF\r\nL0LAGF = 0.0\r\nL0LAGF := (1 - gammaLAGF) * srcLAGF + gammaLAGF * nz(L0LAGF[1])\r\nL1LAGF = 0.0\r\nL1LAGF := -gammaLAGF * L0LAGF + nz(L0LAGF[1]) + gammaLAGF * nz(L1LAGF[1])\r\n\r\nL2LAGF = 0.0\r\nL2LAGF := -gammaLAGF * L1LAGF + nz(L1LAGF[1]) + gammaLAGF * nz(L2LAGF[1])\r\n\r\nL3LAGF = 0.0\r\nL3LAGF := -gammaLAGF * L2LAGF + nz(L2LAGF[1]) + gammaLAGF * nz(L3LAGF[1])\r\n\r\nLagF = (L0LAGF + 2 * L1LAGF + 2 * L2LAGF + L3LAGF) / 6\r\n\r\nLAGF_Signal = LagF > LagF[1] ? 1 : -1\r\n\r\n//end of LagF module\r\n\r\n///////////////////////////////////////////////////////////\r\n//Tom Demark 9 (TD9) - Simple                            //\r\n///////////////////////////////////////////////////////////\r\n\r\n////originally by Scarf, with thanks to the scripts by glaz, bioharz and stripykitteh. Modified by SignalLynx, and modified by SignalLynx\r\n\r\nCount1TD = 0\r\nCountTD = close > close[4] ? 1 : 0\r\nCount1TD := CountTD == 1 ? nz(Count1TD[1]) == 0 ? 1 : Count1TD[1] == 1 ? 2 : Count1TD[1] == 2 ? 3 : Count1TD[1] == 3 ? 4 : Count1TD[1] == 4 ? 5 : Count1TD[1] == 5 ? 6 : Count1TD[1] == 6 ? 7 : Count1TD[1] == 7 ? 8 : Count1TD[1] == 8 ? 9 : 0 : 0\r\n\r\nCount2TD = 0\r\nCountaTD = close < close[4] ? 1 : 0\r\nCount2TD := CountaTD == 1 ? nz(Count2TD[1]) == 0 ? 1 : Count2TD[1] == 1 ? 2 : Count2TD[1] == 2 ? 3 : Count2TD[1] == 3 ? 4 : Count2TD[1] == 4 ? 5 : Count2TD[1] == 5 ? 6 : Count2TD[1] == 6 ? 7 : Count2TD[1] == 7 ? 8 : Count2TD[1] == 8 ? 9 : 0 : 0\r\n\r\npiepbTD = 0\r\npiep2TD = 0\r\npiepbTD := Count1TD == 9 and piepbTD[1] == 0 ? 1 : piepbTD[1] > 0 ? piep2TD[1] == 13 ? 0 : nz(piepbTD[1]) + 1 : 0\r\npiep2TD := piepbTD > 0 and close > high[2] ? piep2TD[1] == 13 ? 0 : nz(piep2TD[1]) + 1 : piep2TD[1] == 13 ? 0 : piep2TD[1]\r\n\r\npiepaTD = 0\r\npiepTD = 0\r\npiepaTD := Count2TD == 9 and piepaTD[1] == 0 ? 1 : piepaTD[1] > 0 ? piepTD[1] == 13 ? 0 : nz(piepaTD[1]) + 1 : 0\r\npiepTD := piepaTD > 0 and close < low[2] and close < low[1] ? piepTD[1] == 13 ? 0 : nz(piepTD[1]) + 1 : piepTD[1] == 13 ? 0 : piepTD[1]\r\n\r\nEightTD = 0.0\r\nThirteenTD = 0\r\nEightTD := piepTD == 8 ? close : EightTD[1]\r\nThirteenTD := piepTD == 13 and close > EightTD ? 2 : piepTD == 13 and close < EightTD ? 3 : 1\r\nThirteen_countTD = ThirteenTD[1] == 3 and close > EightTD ? 3 : ThirteenTD[1]\r\n\r\nEight2TD = 0.0\r\nThirteen2TD = 0\r\nEight2TD := piep2TD == 8 ? close : Eight2TD[1]\r\nThirteen2TD := piep2TD == 13 and close < Eight2TD ? 2 : piep2TD == 13 and close > Eight2TD ? 3 : 1\r\nThirteen_count2TD = Thirteen2TD[1] == 3 and close < Eight2TD ? 3 : Thirteen2TD[1]\r\n\r\nTD_Orders = Count2TD == 9 or piepTD == 13 and piepTD[1] == 12 ? 1 : Count1TD == 9 or piep2TD == 13 and piep2TD[1] == 12 ? -1 : 0\r\n\r\nTD_OrdersPerp = float(na)\r\nTD_OrdersPerp := TD_Orders == 1 ? 1 : TD_Orders == -1 ? -1 : TD_OrdersPerp[1]\r\n\r\n\r\n///////////////////////////////////////////////////////////\r\n//Kijun Sen Bollinger Bands (KJBB)                       //\r\n///////////////////////////////////////////////////////////\r\n\r\nmiddleDonchianKJBB(LengthKJBB) =>\r\n    lowerKJBB = ta.lowest(LengthKJBB)\r\n    upperKJBB = ta.highest(LengthKJBB)\r\n    math.avg(upperKJBB, lowerKJBB)\r\n\r\nbasePeriodsKJBB = 14\r\ndisplacementKJBB = 14\r\nKijunKJBB = middleDonchianKJBB(basePeriodsKJBB)\r\nxChikouKJBB = close\r\nxPriceKJBB = close\r\n\r\nBB_lengthKJBB = 7\r\nBB_stdDevKJBB = 3\r\n\r\nbb_sKJBB = KijunKJBB\r\nbasisKJBB = ta.sma(bb_sKJBB, BB_lengthKJBB)\r\ndevKJBB = BB_stdDevKJBB * ta.stdev(bb_sKJBB, BB_lengthKJBB)\r\nupperKJBB = basisKJBB + devKJBB\r\nlowerKJBB = basisKJBB - devKJBB\r\n\r\nKijunOrder = xPriceKJBB > upperKJBB ? 1 : xPriceKJBB < lowerKJBB ? -1 : 0\r\n\r\n//end of Kijun sen BB module\r\n\r\n///////////////////////////////////////////////////////////\r\n//Super Z Module                                      //\r\n///////////////////////////////////////////////////////////\r\n\r\n//script taken from https://www.tradingview.com/script/kChCRRZI-Hull-Moving-Average/ \r\n\r\nsrc5SZ = close\r\ntfSZ = 1440\r\nlen5SZ = timeframe.isintraday and timeframe.multiplier >= 1 ? tfSZ / timeframe.multiplier * 7 : timeframe.isintraday and timeframe.multiplier < 60 ? 60 / timeframe.multiplier * 24 * 7 : 7\r\nmaSZ = ta.ema(src5SZ * volume, len5SZ) / ta.ema(volume, len5SZ)\r\nsrc1SZ = maSZ\r\n\r\npSZ(src1SZ, len5SZ) =>\r\n    nSZ = 0.0\r\n    sSZ = 0.0\r\n    for iSZ = 0 to len5SZ - 1 by 1\r\n        wSZ = (len5SZ - iSZ) * len5SZ\r\n        nSZ := nSZ + wSZ\r\n        sSZ := sSZ + src5SZ[iSZ] * wSZ\r\n        sSZ\r\n    sSZ / nSZ\r\n\r\nhmSZ = 2.0 * pSZ(src1SZ, math.floor(len5SZ / 2)) - pSZ(src1SZ, len5SZ)\r\nvhmaSZ = pSZ(hmSZ, math.floor(math.sqrt(len5SZ)))\r\n\r\nvlSZ = vhmaSZ[0]\r\nllSZ = vhmaSZ[1]\r\n\r\noSZ = request.security(syminfo.tickerid, timeframe.period, open[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)\r\ncSZ = request.security(syminfo.tickerid, timeframe.period, close[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)\r\nhzSZ = request.security(syminfo.tickerid, timeframe.period, high[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)\r\nlSZ = request.security(syminfo.tickerid, timeframe.period, low[1], gaps = barmerge.gaps_off, lookahead = barmerge.lookahead_on)\r\n\r\n// INPUTS //\r\nst_multSZ = 1.0\r\nst_periodSZ = 30\r\n// CALCULATIONS //\r\nup_levSZ = lSZ - st_multSZ * ta.atr(st_periodSZ)\r\ndn_levSZ = hzSZ + st_multSZ * ta.atr(st_periodSZ)\r\n\r\nup_trendSZ = 0.0\r\nup_trendSZ := cSZ[1] > up_trendSZ[1] ? math.max(up_levSZ, up_trendSZ[1]) : up_levSZ\r\n\r\ndown_trendSZ = 0.0\r\ndown_trendSZ := cSZ[1] < down_trendSZ[1] ? math.min(dn_levSZ, down_trendSZ[1]) : dn_levSZ\r\n\r\n// Calculate trend var\r\ntrendSZ = 0\r\ntrendSZ := cSZ > down_trendSZ[1] ? 1 : cSZ < up_trendSZ[1] ? -1 : nz(trendSZ[1], 1)\r\n\r\n// Calculate SuperTrend Line\r\nst_lineSZ = trendSZ == 1 ? up_trendSZ : down_trendSZ\r\n\r\nbuySZ = ta.crossover(cSZ, st_lineSZ) ? 1 : 0\r\nsellSZ = ta.crossunder(cSZ, st_lineSZ) ? -1 : 0\r\n\r\nSZ_Signal = buySZ == 1 ? 1 : sellSZ == -1 ? -1 : 0\r\nSZ_SignalPerp = float(na)\r\nSZ_SignalPerp := SZ_Signal == 1 ? 1 : SZ_Signal == -1 ? -1 : SZ_SignalPerp[1]\r\n\r\n//end of Super Z module\r\n\r\n//Linear Regression Module\r\nsrcLRS = close\r\nclenLRS = 50\r\nslenLRS = 5\r\nglenLRS = 13\r\n\r\nlrcLRS = ta.linreg(srcLRS, clenLRS, 0)\r\nlrsLRS = (lrcLRS - lrcLRS[1]) / 1\r\nslrsLRS = ta.ema(lrsLRS, slenLRS)\r\nalrsLRS = ta.sma(slrsLRS, glenLRS)\r\nuacceLRS = lrsLRS > alrsLRS and lrsLRS > 0\r\ndacceLRS = lrsLRS < alrsLRS and lrsLRS < 0\r\n\r\ns_LRS = alrsLRS\r\nnm_LRS = 7\r\nrising_old_LRS(s_LRS, nm_LRS) =>\r\n    res = true\r\n    for i = 1 to nm_LRS by 1\r\n        if s_LRS[0] <= s_LRS[i]\r\n            res := false\r\n            break\r\n    res\r\n\r\nLRS_SignalAgg = rising_old_LRS(s_LRS, nm_LRS) ? 1 : -1\r\n\r\n///////////////////////////////////////////////////////////\r\n//MESA Filter                                            //\r\n///////////////////////////////////////////////////////////\r\n// Copyright (c) 2018-present, Alex Orekhov (everget)\r\n//Originally by everget, modified by SignalLynx for use in the trade engine\r\n\r\nfastLimitMESA = 0.5\r\nslowLimitMESA = 0.05\r\nsrcMESA = close\r\nPIMESA = 2 * math.asin(1)\r\n\r\n// Truncated Hilbert transform\r\nhilbertTransformMESA(srcMESA) =>\r\n    0.0962 * srcMESA + 0.5769 * nz(srcMESA[2]) - 0.5769 * nz(srcMESA[4]) - 0.0962 * nz(srcMESA[6])\r\n\r\ncomputeComponentMESA(srcMESA, mesaPeriodMultMESA) =>\r\n    hilbertTransformMESA(srcMESA) * mesaPeriodMultMESA\r\n\r\ncomputeAlphaMESA(srcMESA, fastLimitMESA, slowLimitMESA) =>\r\n    mesaPeriodMESA = 0.0\r\n    mesaPeriodMultMESA = 0.075 * nz(mesaPeriodMESA[1]) + 0.54\r\n\r\n    smoothMESA = 0.0\r\n    smoothMESA := (4 * srcMESA + 3 * nz(srcMESA[1]) + 2 * nz(srcMESA[2]) + nz(srcMESA[3])) / 10\r\n\r\n    detrenderMESA = 0.0\r\n    detrenderMESA := computeComponentMESA(smoothMESA, mesaPeriodMultMESA)\r\n\r\n    // Compute InPhase and Quadrature components\r\n    I1MESA = nz(detrenderMESA[3])\r\n    Q1MESA = computeComponentMESA(detrenderMESA, mesaPeriodMultMESA)\r\n\r\n    // Advance the phase of I1 and Q1 by 90 degrees\r\n    jIMESA = computeComponentMESA(I1MESA, mesaPeriodMultMESA)\r\n    jQMESA = computeComponentMESA(Q1MESA, mesaPeriodMultMESA)\r\n\r\n    I2MESA = 0.0\r\n    Q2MESA = 0.0\r\n\r\n    // Phasor addition for 3 bar averaging\r\n    I2MESA := I1MESA - jQMESA\r\n    Q2MESA := Q1MESA + jIMESA\r\n\r\n    // Smooth the I and Q components before applying the discriminator\r\n    I2MESA := 0.2 * I2MESA + 0.8 * nz(I2MESA[1])\r\n    Q2MESA := 0.2 * Q2MESA + 0.8 * nz(Q2MESA[1])\r\n\r\n    // Homodyne Discriminator\r\n    ReMESA = I2MESA * nz(I2MESA[1]) + Q2MESA * nz(Q2MESA[1])\r\n    ImMESA = I2MESA * nz(Q2MESA[1]) - Q2MESA * nz(I2MESA[1])\r\n\r\n    ReMESA := 0.2 * ReMESA + 0.8 * nz(ReMESA[1])\r\n    ImMESA := 0.2 * ImMESA + 0.8 * nz(ImMESA[1])\r\n\r\n    if ReMESA != 0 and ImMESA != 0\r\n        mesaPeriodMESA := 2 * PIMESA / math.atan(ImMESA / ReMESA)\r\n        mesaPeriodMESA\r\n\r\n    if mesaPeriodMESA > 1.5 * nz(mesaPeriodMESA[1])\r\n        mesaPeriodMESA := 1.5 * nz(mesaPeriodMESA[1])\r\n        mesaPeriodMESA\r\n\r\n    if mesaPeriodMESA < 0.67 * nz(mesaPeriodMESA[1])\r\n        mesaPeriodMESA := 0.67 * nz(mesaPeriodMESA[1])\r\n        mesaPeriodMESA\r\n\r\n    if mesaPeriodMESA < 6\r\n        mesaPeriodMESA := 6\r\n        mesaPeriodMESA\r\n\r\n    if mesaPeriodMESA > 50\r\n        mesaPeriodMESA := 50\r\n        mesaPeriodMESA\r\n\r\n    mesaPeriodMESA := 0.2 * mesaPeriodMESA + 0.8 * nz(mesaPeriodMESA[1])\r\n\r\n    phaseMESA = 0.0\r\n\r\n    if I1MESA != 0\r\n        phaseMESA := 180 / PIMESA * math.atan(Q1MESA / I1MESA)\r\n        phaseMESA\r\n\r\n    deltaPhaseMESA = nz(phaseMESA[1]) - phaseMESA\r\n\r\n    if deltaPhaseMESA < 1\r\n        deltaPhaseMESA := 1\r\n        deltaPhaseMESA\r\n\r\n    alphaMESA = fastLimitMESA / deltaPhaseMESA\r\n\r\n    if alphaMESA < slowLimitMESA\r\n        alphaMESA := slowLimitMESA\r\n        alphaMESA\r\n    alphaMESA\r\n\r\nalphaMESA = computeAlphaMESA(srcMESA, fastLimitMESA, slowLimitMESA)\r\nalpha2MESA = alphaMESA / 2\r\n\r\nmamaMESA = 0.0\r\nmamaMESA := alphaMESA * srcMESA + (1 - alphaMESA) * nz(mamaMESA[1])\r\n\r\nfamaMESA = 0.0\r\nfamaMESA := alpha2MESA * mamaMESA + (1 - alpha2MESA) * nz(famaMESA[1])\r\n\r\nlongMESA = ta.crossover(mamaMESA, famaMESA)\r\nshortMESA = ta.crossunder(mamaMESA, famaMESA)\r\n\r\nMESA_Signal = longMESA == true ? 1 : shortMESA == true ? -1 : 0\r\n\r\nMESA_SignalFinal = float(na)\r\nMESA_SignalFinal := MESA_Signal == 1 ? 1 : MESA_Signal == -1 ? -1 : MESA_SignalFinal[1]\r\n\r\n//Smoother Code\r\nCloseSmoother = ta.ema(close, 14)\r\n\r\n//Price Momentum Oscillator Inhibitor\r\n// Originally by Alex Orekhov (everget), modified by SignalLynx for use in the trade engine\r\n\r\nPMOfirstLength = 35\r\nPMOsecondLength = 20\r\nPMOsignalLength = 10\r\nPMO_Inhib_Threshold = 0.4\r\nPMOsrc = close\r\n\r\npmo = ta.ema(10 * ta.ema(nz(ta.roc(PMOsrc, 1)), PMOfirstLength), PMOsecondLength)\r\nPMOsignal = ta.ema(pmo, PMOsignalLength)\r\n\r\nPMO_CO = ta.crossover(pmo, PMOsignal)\r\nPMO_CU = ta.crossunder(pmo, PMOsignal)\r\n\r\nPMO_Signal = 1\r\nPMO_Signal := PMO_CO ? 1 : PMO_CU ? -1 : PMO_Signal[1]\r\n\r\nPMO_InhibPre = PMO_Inhib_Threshold * -1 < pmo and pmo < PMO_Inhib_Threshold and PMO_Inhib_Threshold * -1 < PMOsignal and PMOsignal < PMO_Inhib_Threshold ? 1 : HSRS_InhibXy == 1 ? 1 : 0\r\n\r\n///////////////////////////////////////////////////////////\r\n//DPT Final Signals                                      //\r\n/////////////////////////////////////////////////////////// \r\n\r\nDPT3 = LAGF_Signal == 1 and TD_OrdersPerp == 1 and KijunOrder == 1 and SZ_SignalPerp == 1 and LRS_SignalAgg == 1 and MESA_SignalFinal == 1 ? 4 : LAGF_Signal == -1 and TD_OrdersPerp == -1 and KijunOrder == -1 and SZ_SignalPerp == -1 and LRS_SignalAgg == -1 and MESA_SignalFinal == -1 ? -4 : 0\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n//End of Code Modules\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n//Buy Activator\r\nvar OrdersMod = 'Total Signals To Place Order'\r\nActivateOrders = input.int(title = 'Number Of Modules With Positive Signals to Place a Buy (Max=11)', minval = 1, defval = 11, maxval = 11, group = OrdersMod)\r\n\r\n//Longs\r\n// This calculates how many of the 12 modules are returning a \"Long\" signal (1) or a pass (0).\r\nGoLongCount = LgCheck_1stMod + LgCheck_2ndMod + LgCheck_3rdMod + LgCheck_4thMod + LgCheck_5thMod + LgCheck_6thMod + LgCheck_7thMod + LgCheck_9thMod + LgCheck_10thMod + LgCheck_11thMod + LgCheck_12thMod\r\n\r\n//Shorts \r\n// This calculates how many modules are returning a \"Short\" signal (-1).\r\nGoShortCount = ShCheck_1stMod + ShCheck_2ndMod + ShCheck_3rdMod + ShCheck_4thMod + ShCheck_5thMod + ShCheck_6thMod + ShCheck_7thMod + ShCheck_9thMod + ShCheck_10thMod + ShCheck_11thMod + ShCheck_12thMod\r\n\r\n// Trend Tracker Band aggregates all raw signals to visualize the overall market sentiment.\r\n// Positive values = Bullish, Negative = Bearish.\r\nTrendTrackerBand = FirstSignal + SecondSignal + Third_Signal + FourthSignal + FifthSignal + SixthSignal + SeventhSignal + MTISignal + NinthSignal + TenthSignal + EleventhSignal + TwelfthSignal\r\nTrendTackerBandColor = TrendTrackerBand <= -8 ? color.red : TrendTrackerBand > -8 and TrendTrackerBand <= -5 ? color.orange : TrendTrackerBand > -5 and TrendTrackerBand <= -3 ? color.yellow : TrendTrackerBand > -3 and TrendTrackerBand <= 3 ? color.gray : TrendTrackerBand > 3 and TrendTrackerBand <= 5 ? color.olive : TrendTrackerBand > 5 and TrendTrackerBand < 8 ? color.green : TrendTrackerBand >= 8 ? color.lime : color.black\r\n\r\nplotshape(TrendTrackerBand, style = shape.square, color = TrendTackerBandColor, location = location.top, size = size.tiny, title = 'Market Sentiment')\r\n\r\n//Nuke and Moon Protection Code (Dump Protection Team - da DPT)\r\nvar NewOpen = 0\r\nvar OrderState = 1\r\nvar ItClosed = 0\r\n\r\n/// Dump Protection Team \r\n// DPT is designed to detect extreme volatility (Pumps or Dumps) and force exits regardless of other indicators.\r\nvar DPTMod = 'Dump/Moon Protection Inputs'\r\nDPTNum = input.int(title = 'Minimum Number of Modules to trigger DPT Moon Signal (Max=9)', minval = 1, defval = 6, maxval = 9, group = DPTMod)\r\nDPTNumNeg = input.int(title = 'Minimum Number of Modules to trigger DPT Nuke Signal (Max=-9)', minval = -9, defval = -6, maxval = -1, group = DPTMod)\r\nKickerPercentChoice = input(false, 'Use Agressive Trend Mapping for Kicker (Default = No)', group = DPTMod)\r\nKickerPercentUpTrendPre = input.float(2.0, 'MTI Kicker Activation (%) - Up Trend', minval = 0, step = 0.1, group = DPTMod)\r\nKickerPercentDnTrend = input.float(6.0, 'MTI Kicker Activation (%) - Down Trend', minval = 0, step = 0.1, group = DPTMod)\r\nvar DPTMod2 = 'Dump/Moon Protection Qualifiers'\r\nCaptainDeadPool = input(true, title = 'Use \\'Loose\\' DPT (Default = Yes)', group = DPTMod2)\r\n\r\nvar MTI_Kicker_Final = 0\r\nvar MTI_Kick = 0\r\n\r\nKickerPercentUpTrend = smoothedCloseRSI_HTF >= 88 ? KickerPercentUpTrendPre * 1.5 : KickerPercentUpTrendPre\r\n\r\nDPT_Nuke = ShCheck_1stModDPT + ShCheck_3rdModDPT + ShCheck_4thModDPT + ShCheck_5thModDPT + ShCheck_6thModDPT + ShCheck_7thModDPT + ShCheck_10thModDPT + ShCheck_12thModDPT + ShCheck_BTCDModDPT <= DPTNumNeg ? -1 : 0\r\nDPT_Moon = LgCheck_1stModDPT + LgCheck_3rdModDPT + LgCheck_4thModDPT + LgCheck_5thModDPT + LgCheck_6thModDPT + LgCheck_7thModDPT + LgCheck_10thModDPT + LgCheck_12thModDPT + LgCheck_BTCDModDPT >= DPTNum ? 1 : 0\r\n\r\n\r\nDeadPoolL = DPT3 == 4 and DPT_Moon == 1 and MTI_Kicker_Final == 1 ? 1 : DPT3 == -4 and DPT_Nuke == -1 and MTI_Kicker_Final == -1 ? -1 : 0\r\nDeadPoolR = DPT3 == 4 and DPT_Moon == 1 and MTI_Kick == -1 ? 1 : DPT3 == -4 and DPT_Nuke == -1 and MTI_Kick == 1 ? -1 : 0\r\n\r\nDeadPool = CaptainDeadPool == true ? DeadPoolL : DeadPoolR\r\nDPT_Final = DeadPool\r\n\r\nDPT_FinalPerp = float(na)\r\nDPT_FinalPerp := DPT_Final == 1 ? 1 : DPT_Final == -1 ? -1 : DPT_FinalPerp[1]\r\n\r\nDPT_FinalPerp2 = float(na)\r\nDPT_FinalPerp2 := DPT_Final == 1 ? 1 : DPT_Final == -1 ? -1 : NewOpen == 2 or NewOpen == -2 or ItClosed == 1 or ItClosed == -1 ? 0 : DPT_FinalPerp[1]\r\n\r\nDPT_FirstPulse = DPT_FinalPerp == 1 and DPT_FinalPerp != DPT_FinalPerp[1] and OrderState == -2 ? 2 : DPT_FinalPerp == -1 and DPT_FinalPerp != DPT_FinalPerp[1] and OrderState == 2 ? -2 : 0\r\nDRT_FirstPulse = DPT_FinalPerp == 1 and DPT_FinalPerp != DPT_FinalPerp[1] and OrderState == 2 ? 2 : DPT_FinalPerp == -1 and DPT_FinalPerp != DPT_FinalPerp[1] and OrderState == -2 ? -2 : 0\r\n\r\nDRTX1 = input(true, title = 'Dump Protection Team - Close on Signal (Default = Yes)', group = DPTMod2)\r\nDRTXR = input(false, title = 'Dump Protection Team - Restart On Signal - Note: DPT Close on Signal must be selected (Default = No)', group = DPTMod2)\r\nDRTX2 = input(true, title = 'Dump Protection Team - Martingale on Signal (Default = Yes)', group = DPTMod2)\r\nDrStrange = input(true, title = 'Use Restrictive Restart Inhibitor (Default = Yes)', group = DPTMod2)\r\n\r\n\r\nDRT_MartCovertor = DPT_FirstPulse == 2 ? 1 : DPT_FirstPulse == -2 ? -1 : 0\r\nDRT_RestartConverter = DRT_FirstPulse == 2 ? 1 : DRT_FirstPulse == -2 ? -1 : 0\r\nDRT_Close = DRTX1 == true ? DPT_FirstPulse : 0 // 2 and -2\r\nDRT_Mart = DRTX2 == true ? DRT_MartCovertor : 0 // 1 and -1\r\nDRT_Restart = DRTX1 == true and DRTXR == true ? DRT_RestartConverter : 0\r\n\r\nDPT_RestartInhibR = DRTX1 == true and DPT_FinalPerp2 == 1 and TD_OrdersPerp == 1 ? 1 : DRTX1 == true and DPT_FinalPerp2 == -1 and TD_OrdersPerp == -1 ? -1 : 0\r\nDPT_RestartInhibL = 0\r\nDPT_RestartInhib = DrStrange == true ? DPT_RestartInhibR : DPT_RestartInhibL\r\n\r\n////////////////////////////////////////////////////////////////\r\n//* Generate Combined Signals                                *//\r\n////////////////////////////////////////////////////////////////\r\n\r\n//Place Final Order Variables Below - Modify as needed based on code Modules buy and sell signals\r\n\r\nvar Martingale = 0\r\nvar MartingaleOpen = 0\r\nvar MartingaleCounter = 0\r\nvar ATSMart = 0\r\nvar tsMart = 0\r\nvar slMart = 0\r\n\r\nMartingaleCounter := Martingale != 0 ? MartingaleCounter + 1 : (espf_SignalMartingale == 0 ? 0 : MartingaleCounter[1])\r\n\r\nUsePMOInhib = input(false, title = 'Use PMO/HSRS Inhib? (Default = No)', group = DPTMod2)\r\nPMO_Inhib = UsePMOInhib == true and SSGuppyFinal == 1 ? PMO_InhibPre : 0\r\n\r\n//Prime Signals\r\n// This logic checks if the Total Vote Count (GoLongCount/GoShortCount) meets the User Threshold (ActivateOrders).\r\n// It also checks that Inhibitors (like ADX, HashRate, etc) are green.\r\nGoLongPrime = GoLongCount >= ActivateOrders and LgCheck_8thMod == 1 and LgCheck_BTCDMod == 1 and ADX_Check == 1 and SRSI_NoBuyFinal == 1 and Check_MCHR == 1 and LgCheck_ESPFMod == 1 and MartingaleCounter == 0 and DPT_RestartInhib != 1 and MESA_SignalFinal == 1 and PMO_Inhib == 0 ? true : DRT_Mart == 1 or DRT_Restart == 1 or ATSMart == -1 or tsMart == -1 or slMart == -1 or PiC_Signal == 1 ? true : false\r\nCloseLongPrime = Fst_LongCloseCheck == 0 or Second_LongCloseCheck == -1 or Third_LongCloseCheck == -1 or Fourth_LongCloseCheck == -1 or SOR_CloseLong_Check == 1 or Fifth_LongCloseCheck == -1 or Sixth_LongCloseCheck == -1 or Seventh_LongCloseCheck == -1 or Eigth_LongCloseCheck == -1 or Ninth_LongCloseCheck == -1 or Tenth_LongCloseCheck == -1 or Eleventh_LongCloseCheck == -1 or MCHR_CloseCheck == -1 or Twelfth_LongCloseCheck == -1 or ESPF_LongCloseCheck == -1 or DRT_Close == -2 or BTCD_LongCloseCheck == -1 ? true : false\r\nGoShortPrime = math.abs(GoShortCount) >= ActivateOrders and ShCheck_8thMod == -1 and ShCheck_BTCDMod == -1 and ADX_Check == 1 and SRSI_NoSellFinal == 1 and Check_MCHR == 1 and ShCheck_ESPFMod == -1 and MartingaleCounter == 0 and DPT_RestartInhib != -1 and MESA_SignalFinal == -1 and PMO_Inhib == 0 ? true : DRT_Mart == -1 or DRT_Restart == -1 or ATSMart == 1 or tsMart == 1 or slMart == 1 ? true : false\r\nCloseShortPrime = Fst_ShortCloseCheck == 0 or Second_ShortCloseCheck == 1 or Third_ShortCloseCheck == 1 or Fourth_ShortCloseCheck == 1 or SOR_CloseShort_Check == 1 or Fifth_ShortCloseCheck == 1 or Sixth_ShortCloseCheck == 1 or Seventh_ShortCloseCheck == 1 or Eigth_ShortCloseCheck == 1 or Ninth_ShortCloseCheck == 1 or Tenth_ShortCloseCheck == 1 or Eleventh_ShortCloseCheck == 1 or MCHR_CloseCheck == -1 or Twelfth_ShortCloseCheck == 1 or ESPF_ShortCloseCheck == 1 or DRT_Close == 2 or BTCD_ShortCloseCheck == 1 ? true : false\r\n\r\nAlertOpenPrime = GoLongCount >= ActivateOrders and LgCheck_8thMod == 1 and LgCheck_BTCDMod == 1 and ADX_Check == 1 and SRSI_NoBuyFinal == 1 and Check_MCHR == 1 and LgCheck_ESPFMod == 1 and MartingaleCounter == 0 and DPT_RestartInhib != 1 and MESA_SignalFinal == 1 and PMO_Inhib == 0 ? 2 : DRT_Mart == 1 or DRT_Restart == 1 or ATSMart == -1 or tsMart == -1 or slMart == -1 or PiC_Signal == 1 ? 2 : math.abs(GoShortCount) >= ActivateOrders and ShCheck_8thMod == -1 and ShCheck_BTCDMod == -1 and ADX_Check == 1 and SRSI_NoSellFinal == 1 and Check_MCHR == 1 and ShCheck_ESPFMod == -1 and MartingaleCounter == 0 and DPT_RestartInhib != -1 and MESA_SignalFinal == -1 and PMO_Inhib == 0 ? -2 : DRT_Mart == -1 or DRT_Restart == -1 or ATSMart == 1 or tsMart == 1 or slMart == 1 ? -2 : 0\r\nAlertCloseLPrime = Fst_LongCloseCheck == 0 or Second_LongCloseCheck == -1 or Third_LongCloseCheck == -1 or SOR_CloseLong_Check == -1 or Fourth_LongCloseCheck == -1 or Fifth_LongCloseCheck == -1 or Sixth_LongCloseCheck == -1 or Seventh_LongCloseCheck == -1 or Eigth_LongCloseCheck == -1 or Ninth_LongCloseCheck == -1 or Tenth_LongCloseCheck == -1 or Eleventh_LongCloseCheck == -1 or MCHR_CloseCheck == -1 or Twelfth_LongCloseCheck == -1 or ESPF_LongCloseCheck == -1 or DRT_Close == -2 or BTCD_LongCloseCheck == -1 ? 1 : 0\r\nAlertCloseSPrime = Fst_ShortCloseCheck == 0 or Second_ShortCloseCheck == 1 or Third_ShortCloseCheck == 1 or SOR_CloseShort_Check == 1 or Fourth_ShortCloseCheck == 1 or Fifth_ShortCloseCheck == 1 or Sixth_ShortCloseCheck == 1 or Seventh_ShortCloseCheck == 1 or Eigth_ShortCloseCheck == 1 or Ninth_ShortCloseCheck == 1 or Tenth_ShortCloseCheck == 1 or Eleventh_ShortCloseCheck == 1 or MCHR_CloseCheck == -1 or Twelfth_ShortCloseCheck == 1 or ESPF_ShortCloseCheck == 1 or DRT_Close == 2 or BTCD_ShortCloseCheck == 1 ? -1 : 0\r\n\r\n//Alt Signals - these are flipped for reverse trades\r\nGoShortAlt = GoLongCount >= ActivateOrders and LgCheck_8thMod == 1 and LgCheck_BTCDMod == 1 and ADX_Check == 1 and SRSI_NoBuyFinal == 1 and Check_MCHR == 1 and LgCheck_ESPFMod == 1 and MartingaleCounter == 0 and DPT_RestartInhib != 1 and PMO_Inhib == 0 ? true : DRT_Mart == 1 or DRT_Restart == 1 or ATSMart == -1 or tsMart == 1 or slMart == -1 ? true : false\r\nCloseShortAlt = Fst_LongCloseCheck == 0 or Second_LongCloseCheck == -1 or Third_LongCloseCheck == -1 or Fourth_LongCloseCheck == -1 or SOR_CloseLong_Check == 1 or Fifth_LongCloseCheck == -1 or Sixth_LongCloseCheck == -1 or Seventh_LongCloseCheck == -1 or Eigth_LongCloseCheck == -1 or Ninth_LongCloseCheck == -1 or Tenth_LongCloseCheck == -1 or Eleventh_LongCloseCheck == -1 or MCHR_CloseCheck == -1 or Twelfth_LongCloseCheck == -1 or ESPF_LongCloseCheck == -1 or DRT_Close == -2 or BTCD_LongCloseCheck == -1 ? true : false\r\nGoLongAlt = math.abs(GoShortCount) >= ActivateOrders and ShCheck_8thMod == -1 and ShCheck_BTCDMod == -1 and ADX_Check == 1 and SRSI_NoSellFinal == 1 and Check_MCHR == 1 and ShCheck_ESPFMod == -1 and MartingaleCounter == 0 and DPT_RestartInhib != -1 and PMO_Inhib == 0 ? true : DRT_Mart == -1 or DRT_Restart == -1 or ATSMart == 1 or tsMart == 1 or slMart == 1 or PiC_Signal == 1 ? true : false\r\nCloseLongAlt = Fst_ShortCloseCheck == 0 or Second_ShortCloseCheck == 1 or Third_ShortCloseCheck == 1 or Fourth_ShortCloseCheck == 1 or SOR_CloseShort_Check == 1 or Fifth_ShortCloseCheck == 1 or Sixth_ShortCloseCheck == 1 or Seventh_ShortCloseCheck == 1 or Eigth_ShortCloseCheck == 1 or Ninth_ShortCloseCheck == 1 or Tenth_ShortCloseCheck == 1 or Eleventh_ShortCloseCheck == 1 or MCHR_CloseCheck == -1 or Twelfth_ShortCloseCheck == 1 or ESPF_ShortCloseCheck == 1 or DRT_Close == 2 or BTCD_ShortCloseCheck == 1 ? true : false\r\n\r\nAlertOpenAlt = GoLongCount >= ActivateOrders and LgCheck_8thMod == 1 and LgCheck_BTCDMod == 1 and ADX_Check == 1 and SRSI_NoBuyFinal == 1 and Check_MCHR == 1 and LgCheck_ESPFMod == 1 and MartingaleCounter == 0 and DPT_RestartInhib != 1 and PMO_Inhib == 0 ? -2 : DRT_Mart == 1 or DRT_Restart == 1 or ATSMart == -1 or tsMart == -1 or slMart == -1 ? -2 : math.abs(GoShortCount) >= ActivateOrders and ShCheck_8thMod == -1 and ShCheck_BTCDMod == -1 and ADX_Check == 1 and SRSI_NoSellFinal == 1 and Check_MCHR == 1 and ShCheck_ESPFMod == -1 and MartingaleCounter == 0 and DPT_RestartInhib != -1 and PMO_Inhib == 0 ? 2 : DRT_Mart == -1 or DRT_Restart == -1 or ATSMart == 1 or tsMart == 1 or slMart == 1 or PiC_Signal == 1 ? 2 : 0\r\nAlertCloseSAlt = Fst_LongCloseCheck == 0 or Second_LongCloseCheck == -1 or Third_LongCloseCheck == -1 or SOR_CloseLong_Check == -1 or Fourth_LongCloseCheck == -1 or Fifth_LongCloseCheck == -1 or Sixth_LongCloseCheck == -1 or Seventh_LongCloseCheck == -1 or Eigth_LongCloseCheck == -1 or Ninth_LongCloseCheck == -1 or Tenth_LongCloseCheck == -1 or Eleventh_LongCloseCheck == -1 or Twelfth_LongCloseCheck == -1 or MCHR_CloseCheck == -1 or ESPF_LongCloseCheck == -1 or DRT_Close == -2 or BTCD_LongCloseCheck == -1 ? 1 : 0\r\nAlertCloseLAlt = Fst_ShortCloseCheck == 0 or Second_ShortCloseCheck == 1 or Third_ShortCloseCheck == 1 or SOR_CloseShort_Check == 1 or Fourth_ShortCloseCheck == 1 or Fifth_ShortCloseCheck == 1 or Sixth_ShortCloseCheck == 1 or Seventh_ShortCloseCheck == 1 or Eigth_ShortCloseCheck == 1 or Ninth_ShortCloseCheck == 1 or Tenth_ShortCloseCheck == 1 or Eleventh_ShortCloseCheck == 1 or Twelfth_ShortCloseCheck == 1 or MCHR_CloseCheck == -1 or ESPF_ShortCloseCheck == 1 or DRT_Close == 2 or BTCD_ShortCloseCheck == 1 ? -1 : 0\r\n////////////////////////////////////////////////////////////////\r\n//* BB Chop Kicker - Swtich to MESA based trade              *//\r\n////////////////////////////////////////////////////////////////\r\n//BB code is in Order Qualifier Module\r\nvar MesaMod = 'MESA Based Trading Qualifier'\r\nBBPinchFlip = input(false, title = 'MESA Trade Module - Switch to MESA based trading below this BB Spread Percentage (Default = No)', group = MesaMod)\r\nBBPinchTrend = input(false, title = 'BB Pinch Trend Following - Conservative  (Default = No)', group = MesaMod)\r\nBBInhibPercentFlip = input.float(3, 'BB Pinch % to Engage', minval = 0, step = 0.1, group = MesaMod)\r\nBBChopInhibFlip = close * (BBInhibPercentFlip / 100) > upper3MBB - lower3MBB ? 1 : 0\r\nDPT4 = LAGF_Signal == 1 and SZ_SignalPerp == 1 ? 4 : LAGF_Signal == -1 and SZ_SignalPerp == -1 ? -4 : 0\r\nBBFlipFinal1 = BBPinchFlip == true and BBTrendUp == 0 and BBChopInhibFlip == 1 and Engagey == 0 ? 1 : 0 //and DPT4==0 and MTI_Kick!=0 ? 1 : 0\r\nBBFlipFinal2 = BBPinchFlip == true and BBTrendUp == 0 and BBChopInhibFlip == 1 ? 1 : 0 //and DPT4==0 and MTI_Kick!=0 ? 1 : 0\r\nBBFlipFinal = BBPinchTrend == true ? BBFlipFinal2 : BBFlipFinal1\r\n\r\ns_CS = CloseSmoother\r\nnm_CS = 14\r\nrising_old_CS(s_CS, nm_CS) =>\r\n    res = true\r\n    for i = 1 to nm_CS by 1\r\n        if s_CS[0] <= s_CS[i]\r\n            res := false\r\n            break\r\n    res\r\n\r\nfalling_old_CS(s_CS, nm_CS) =>\r\n    res = true\r\n    for i = 1 to nm_CS by 1\r\n        if s_CS[0] >= s_CS[i]\r\n            res := false\r\n            break\r\n    res\r\n\r\n// --- V6 FIX EXPLANATION ---\r\n// Pre-calculating loop results for MESA activations\r\nCS_isRising = rising_old_CS(s_CS, nm_CS)\r\nCS_isFalling = falling_old_CS(s_CS, nm_CS)\r\n\r\nMESA_ActivateLong = MESA_SignalFinal == 1 and Third_Signal == 1 and FifthSignal == 1 and SixthSignal == 1 and SeventhSignal == 1 and ADX_Check == 1 and SRSI_NoBuyFinal == 1 and LAGF_Signal == 1 and CS_isRising == true and espf_MartingaleFinal == 1 and HSRS_Gap_Falling == 1 ? 2 : 0\r\nMESA_ActivateShort = MESA_SignalFinal == -1 and Third_Signal == -1 and FifthSignal == -1 and SixthSignal == -1 and SeventhSignal == -1 and ADX_Check == 1 and SRSI_NoBuyFinal == 1 and LAGF_Signal == -1 and CS_isFalling == true and espf_MartingaleFinal == -1 and HSRS_Gap_Falling == 1 ? -2 : 0\r\nMESA_Activate = MESA_ActivateLong == 2 ? 2 : MESA_ActivateShort == -2 ? -2 : 0\r\n\r\n////////////////////////////////////////////////////////////////\r\n//* Flip Trades Code                                         *// \r\n////////////////////////////////////////////////////////////////\r\n\r\n//Flip Trades - A Long calls a short, and a Short calls a long\r\nvar FlipMod = 'Special Circumstances - Flip Trade Signals'\r\nFlipTradesX = input(false, 'Flip Trades? (Default = No)', group = FlipMod)\r\nFlipMC = input(true, 'Flip Trades during Miner Captiulation and not near BTC Halving? (Default = Yes)', group = FlipMod)\r\n\r\nFlipMCX = FlipMC == true and MinerCapitulationFinal == -1 and HalvingInhibitor == 0 ? true : false\r\nFlippity = FlipTradesX == true or FlipMCX == true ? true : false\r\n\r\nGoLongM = Flippity == false ? GoLongPrime : GoLongAlt\r\nCloseLong = Flippity == false ? CloseLongPrime : CloseLongAlt\r\nGoShortM = Flippity == false ? GoShortPrime : GoShortAlt\r\nCloseShort = Flippity == false ? CloseShortPrime : CloseShortAlt\r\n\r\nAlertOpenM = Flippity == false ? AlertOpenPrime : AlertOpenAlt\r\nAlertCloseL = Flippity == false ? AlertCloseLPrime : AlertCloseLAlt\r\nAlertCloseS = Flippity == false ? AlertCloseSPrime : AlertCloseSAlt\r\n\r\n// --- V6 FIX EXPLANATION ---\r\n// In V6, mixing Types (Integers and Booleans) in logic is strictly forbidden.\r\n// Previously this returned 2 or -2 (Integers), but GoLongM returns True/False.\r\n// We must normalize this so it always returns True or False.\r\nGoLongX = MartingaleOpen == 3 ? true : GoLongM\r\nGoShortX = MartingaleOpen == -3 ? true : GoShortM\r\nAlertOpenX = MartingaleOpen == 3 ? 2 : MartingaleOpen == -3 ? -2 : AlertOpenM\r\n\r\nGoLong = BBFlipFinal == 1 and MESA_ActivateLong == 2 ? true : GoLongX\r\nGoShort = BBFlipFinal == 1 and MESA_ActivateLong == -2 ? true : GoShortX\r\nAlertOpenY = BBFlipFinal == 1 ? MESA_Activate : AlertOpenX\r\nMESA_Tracker = BBFlipFinal == 1 and MESA_Activate != 0 ? 1 : 0\r\n\r\n//Check for Days to Buy\r\nAlertOpen = DayHalt == 1 ? 0 : AlertOpenY\r\n\r\nMCHR_plotColor = Minercapitulation == -1 and MinerCapitulationFinal == -1 and HalvingInhibitor == 0 ? color.red : Minercapitulation == -1 and MinerCapitulationFinal == -1 and HalvingInhibitor == 1 ? color.blue : color.orange\r\nplotshape(MinerPlot, style = shape.circle, color = MCHR_plotColor, location = location.bottom, size = size.tiny, title = 'Miner Capitulation')\r\n\r\n////////////////////////////////////////////////////////////////\r\n//* Trade State Engine (Risk Managemnt Translation)          *//\r\n////////////////////////////////////////////////////////////////\r\n\r\n//Buy Confirmations\r\nvar BuyMod = 'Order Signal Modifier - Sequential Signals'\r\nBuyConfirms = input.int(title = 'Buy Confirmations: Required Number of Sequential Buy Signals to Trigger (Default=1)', minval = 1, defval = 1, group = BuyMod)\r\n\r\nvar BuyCounts = 0\r\nBuyCounts := AlertOpen == 2 ? BuyCounts + 1 : AlertOpen == -2 ? BuyCounts - 1 : 0\r\n\r\n//Do not modify Variables below this - Trade Engine Code\r\n// --- V6 FIX EXPLANATION ---\r\n// Added parentheses to clarify Order of Operations for the parser.\r\nAOX = (AlertOpen == 2 and AlertOpen != AlertOpen[1]) ? 2 : (AlertOpen == -2 and AlertOpen != AlertOpen[1]) ? -2 : 0\r\nAOZ = (AlertOpen == 2 and BuyConfirms == BuyCounts) ? 2 : (AlertOpen == -2 and BuyConfirms == BuyCounts * -1) ? -2 : 0\r\nAO = BuyConfirms == 1 ? AOX : AOZ\r\n\r\nvar AT = 0\r\nAT := AO == 2 ? 2 : AO == -2 ? -2 : AT[1]\r\nAF = float(na)\r\nAF := AT == 2 and AT[1] != 2 ? 2 : AT == -2 and AT[1] != -2 ? -2 : 0\r\n\r\nMCStateKicker := Flippity == false ? AT : AT * -1\r\n\r\nOrderState := AT\r\nCS = CloseShort == true ? -1 : 0\r\nCL = CloseLong == true ? 1 : 0\r\n\r\nCS1 = CS == -1 and CS != CS[1] ? -1 : 0\r\nCL1 = CL == 1 and CL != CL[1] ? 1 : 0\r\n\r\nCSX = AT == 2 ? CL1 : AT == -2 ? CS1 : 0\r\nAlertClose = AT == 2 ? AlertCloseL : AT == -2 ? AlertCloseS : 0\r\n\r\n//Determine what kind of Risk We want to take\r\n//Using Agressive Setting will \"reset\" Risk Management values if Algo determines conditions are still valid (consider this a pyrmamiding type I)\r\nvar RiskMod = 'Main Risk Managment Settings'\r\nAgressiveRMPre = input(true, 'Utilize Agresive RM - Reset RM Values as Long as Algo determines entry conditions are valid (Default- Agressive)', group = RiskMod)\r\nUseAGRM = input(true, 'Use Active RM Agressiviness (Default- Yes)', group = RiskMod)\r\nAgressiveRM = BBADXKicker >= 2 and UseAGRM == true ? true : UseAGRM == false ? AgressiveRMPre : false\r\n\r\nTradeEngineX = AlertOpen == 2 ? 1 : AlertOpen == -2 ? -1 : 0\r\nTradeEngineY = AF == 2 ? 1 : AF == -2 ? -1 : 0\r\n\r\nTradeEngineRisk = AgressiveRM == false ? TradeEngineY : TradeEngineX\r\nTradeEngineRiskTight = TradeEngineY\r\n\r\nRebuySentiment = AlertOpen == 2 ? 1 : AlertOpen == -2 ? -1 : na\r\nRebuySentimentColor = AlertOpen == 2 ? color.green : AlertOpen == -2 ? color.red : color.purple\r\nplotshape(RebuySentiment, style = shape.cross, color = RebuySentimentColor, location = location.bottom, size = size.small, title = 'Re-Buy Sentiment')\r\n\r\n//////////////////////////////\r\n//* Risk Management Code   *//\r\n//////////////////////////////\r\n\r\n//DO NOT MODIFY\r\nopen_ = open[1]\r\nclose_ = close[1]\r\nhigh_X = high[1]\r\nlow_X = low[1]\r\n\r\n// === RISK MANAGEMENT VALUE PREP ===\r\n//Determine what Bar values we should use for Risk managment\r\nBarTypeRM = input(false, 'Use Candle Open/Close for Risk Management (Default is Candle High/Low)', group = RiskMod)\r\n\r\nlow_ = BarTypeRM == true ? close_ : low_X\r\nhigh_ = BarTypeRM == true ? close_ : high_X\r\n\r\n////////////////////////////////////////////////\r\n// Risk Management generates Buy Sell signals //\r\n////////////////////////////////////////////////\r\n\r\nRiskOpenR = AgressiveRM == false ? AF : AO\r\nRiskCloseLR = AgressiveRM == false ? CSX : CL\r\nRiskCloseSR = AgressiveRM == false ? CSX : CS\r\n\r\nRiskOpenRTight = AF\r\nRiskCloseLRTight = CSX\r\nRiskCloseSRTight = CSX\r\n\r\nopenLongR = RiskOpenR == 2 ? true : false\r\ncloseLongR = RiskCloseLR == 1 ? true : false\r\n\r\nopenLongRTight = RiskOpenRTight == 2 ? true : false\r\ncloseLongRTight = RiskCloseLRTight == 1 ? true : false\r\n\r\nopenShortR = RiskOpenR == -2 ? true : false\r\ncloseShortR = RiskCloseSR == -1 ? true : false //\r\n\r\nopenShortRTight = RiskOpenRTight == -2 ? true : false\r\ncloseShortRTight = RiskCloseSRTight == -1 ? true : false\r\n\r\nbuy = 0\r\nbuy := openLongR ? nz(buy[1]) > 0 ? buy[1] + 1 : 1 : 0\r\nsell = 0\r\nsell := openShortR ? nz(sell[1]) > 0 ? sell[1] + 1 : 1 : 0\r\n\r\nbuyTight = 0\r\nbuyTight := openLongRTight ? nz(buyTight[1]) > 0 ? buyTight[1] + 1 : 1 : 0\r\nsellTight = 0\r\nsellTight := openShortRTight ? nz(sellTight[1]) > 0 ? sellTight[1] + 1 : 1 : 0\r\n\r\n//////////////////////////\r\n//* Trade State Engine *//\r\n//////////////////////////\r\n\r\n// Keep track of current trade state\r\nvar bool longCloseX  = false\r\nvar bool shortCloseX = false\r\n\r\n// Carry forward previous bar state by default\r\nif bar_index > 0\r\n    longCloseX  := longCloseX[1]\r\n    shortCloseX := shortCloseX[1]\r\n\r\ntradeState = TradeEngineRisk\r\ntradeStateTight = TradeEngineRiskTight\r\n\r\n//////////////////////////////////////////////////////////\r\n//Handle Entry Conditions, when state changes direction //\r\n//////////////////////////////////////////////////////////\r\n\r\n// --- V6 FIX EXPLANATION ---\r\n// In V6, the result of ta.change() is a float (the difference between values).\r\n// You cannot use \"float and bool\". You must convert the float to bool by checking \"!= 0\".\r\nlongCondition = false\r\nshortCondition = false\r\nlongCondition := ta.change(tradeState) != 0 and tradeState == 1\r\nshortCondition := ta.change(tradeState) != 0 and tradeState == -1\r\n\r\nlongConditionTight = false\r\nshortConditionTight = false\r\nlongConditionTight := ta.change(tradeStateTight) != 0 and tradeStateTight == 1\r\nshortConditionTight := ta.change(tradeStateTight) != 0 and tradeStateTight == -1\r\n\r\n// Exit on Sell signal\r\nlongExitC = CL == 1 or AlertOpen == -2 ? 1 : 0\r\nshortExitC = CS == -1 or AlertOpen == 2 ? 1 : 0\r\n\r\n// Exit condition for no SL.\r\nlongExit = ta.change(longExitC) != 0 and longExitC == 1 and tradeState == 1\r\nshortExit = ta.change(shortExitC) != 0 and shortExitC == 1 and tradeState == -1\r\n\r\n/////////////////////////////////////\r\n//======[ Deal Entry Prices ]======//\r\n/////////////////////////////////////\r\n\r\nlast_open_longCondition = float(na)\r\nlast_open_shortCondition = float(na)\r\nlast_open_longCondition := longCondition ? close : nz(last_open_longCondition[1])\r\nlast_open_shortCondition := shortCondition ? close : nz(last_open_shortCondition[1])\r\n\r\nlast_open_longConditionTight = float(na)\r\nlast_open_shortConditionTight = float(na)\r\nlast_open_longConditionTight := longConditionTight ? close : nz(last_open_longConditionTight[1])\r\nlast_open_shortConditionTight := shortConditionTight ? close : nz(last_open_shortConditionTight[1])\r\n\r\n//////////////////////////////////\r\n//======[ Position State ]======//\r\n//////////////////////////////////\r\n\r\nin_longCondition = AT == 2 ? true : false\r\nin_shortCondition = AT == -2 ? true : false\r\n\r\nMESA_SL_Kicker = AT != 0 and AT != AT[1] and MESA_Tracker == 1 ? 1 : 0\r\nMESA_SL_KickerPerp = float(na)\r\nMESA_SL_KickerPerp := MESA_SL_Kicker == 1 ? 1 : AT != AT[1] ? 0 : MESA_SL_KickerPerp[1]\r\n\r\n/////////////////////////////////\r\n//======[ Trailing Stop ]======//\r\n/////////////////////////////////\r\n\r\nvar TSMod = 'Trailing Stop Settings'\r\nisTSPre = input(true, 'Trailing Stop', group = TSMod)\r\nESPF_TS_Activation = input(false, 'Activate Trailing Stop on ESPF Signal (Start with Act of 10% and TS of 20%)', group = TSMod)\r\nuseActiveHSRS_TS = input(false, 'Use Active HSRS Trailing Stop (Default = No)', group = TSMod)\r\ntsActivationPre = input.float(18.0, 'Trailing Stop Activation (%)', minval = 0, step = 0.1, group = TSMod) / 100\r\ntsPre = input.float(6.0, 'Trailing Stop (%)', minval = 0, step = 0.1, group = TSMod) / 100\r\n\r\nisTS = HSRS_InhibXy == 1 and useActiveHSRS_TS == true ? true : isTSPre\r\ntsActivation = HSRS_InhibXy == 1 and useActiveHSRS_TS == true ? 0.03 : tsActivationPre\r\nts = HSRS_InhibXy == 1 and useActiveHSRS_TS == true ? 0.01 : tsPre\r\n\r\nespf_LongTSActivate = ESPF_TS_Activation == true and espf_FinalX == -1 ? true : false\r\nespf_ShortTSActivate = ESPF_TS_Activation == true and espf_FinalX == 1 ? true : false\r\n\r\nLongTSActivate = low_X > last_open_longCondition + last_open_longCondition * tsActivation and isTS == true ? true : false\r\nShortTSActivate = high_X < last_open_shortCondition - last_open_shortCondition * tsActivation and isTS == true ? true : false\r\n\r\nlast_highTS = float(na)\r\nlast_lowTS = float(na)\r\nlast_high_shortTS = float(na)\r\nlast_low_longTS = float(na)\r\nlast_highTS := not in_longCondition ? na : in_longCondition and (na(last_highTS[1]) or high_X > nz(last_highTS[1])) ? high_X : nz(last_highTS[1])\r\nlast_high_shortTS := not in_shortCondition ? na : in_shortCondition and (na(last_highTS[1]) or high_X > nz(last_highTS[1])) ? high_X : nz(last_highTS[1])\r\nlast_lowTS := not in_shortCondition ? na : in_shortCondition and (na(last_lowTS[1]) or low_X < nz(last_lowTS[1])) ? low_X : nz(last_lowTS[1])\r\nlast_low_longTS := not in_longCondition ? na : in_longCondition and (na(last_lowTS[1]) or low_X < nz(last_lowTS[1])) ? low_X : nz(last_lowTS[1])\r\n\r\nlong_ts = (isTS or ESPF_TS_Activation) and in_longCondition and not na(last_highTS) and (LongTSActivate == true or espf_LongTSActivate == true) and low_X <= last_highTS - last_highTS * ts\r\nshort_ts = (isTS or ESPF_TS_Activation) and in_shortCondition and not na(last_lowTS) and (ShortTSActivate == true or espf_ShortTSActivate == true) and high_X >= last_lowTS + last_lowTS * ts\r\n\r\nvar MesaTSMod = 'MESA Trailing Stop'\r\nBB_TS_On = input(false, 'MESA Trades - Activate Trailing Stop', group = MesaTSMod)\r\nBBtsActivate = input.float(2.0, 'MESA ONLY - Trailing Stop  Activation (%)', minval = 0, step = 0.1, group = MesaTSMod) / 100\r\ntsbb = input.float(1.0, 'Trailing Stop (%)', minval = 0, step = 0.1, group = MesaTSMod) / 100\r\n\r\nLongTSActivateBB = low_X > last_open_longConditionTight + last_open_longConditionTight * BBtsActivate and BB_TS_On == true and HSRS_Gap_Falling == 1 ? true : false\r\nShortTSActivateBB = high_X < last_open_shortConditionTight - last_open_shortConditionTight * BBtsActivate and BB_TS_On == true and HSRS_Gap_Falling == 1 ? true : false\r\n\r\nlong_tsBB = BB_TS_On and MESA_SL_KickerPerp == 1 and in_longCondition and not na(last_highTS) and LongTSActivateBB == true and low_X <= last_highTS - last_highTS * tsbb\r\nshort_tsBB = BB_TS_On and MESA_SL_KickerPerp == 1 and in_shortCondition and not na(last_lowTS) and ShortTSActivateBB == true and high_X >= last_lowTS + last_lowTS * tsbb\r\n\r\nts_CloseSignal = long_ts == true or long_tsBB == true ? 1 : short_ts == true or short_tsBB == true ? -1 : 0\r\n\r\n///////////////////////////////////////////////////////////\r\n// Highs and Lows tracking for Take Profit and Stop Loss //\r\n///////////////////////////////////////////////////////////\r\n\r\nlast_high = float(na)\r\nlast_low = float(na)\r\nlast_high_short = float(na)\r\nlast_low_long = float(na)\r\nlast_high := not in_longCondition ? na : in_longCondition and (na(last_high[1]) or high_ > nz(last_high[1])) ? high_ : nz(last_high[1])\r\nlast_high_short := not in_shortCondition ? na : in_shortCondition and (na(last_high[1]) or high_ > nz(last_high[1])) ? high_ : nz(last_high[1])\r\nlast_low := not in_shortCondition ? na : in_shortCondition and (na(last_low[1]) or low_ < nz(last_low[1])) ? low_ : nz(last_low[1])\r\nlast_low_long := not in_longCondition ? na : in_longCondition and (na(last_low[1]) or low_ < nz(last_low[1])) ? low_ : nz(last_low[1])\r\n\r\n///////////////////////////////  \r\n//======[ Take Profit ]======//\r\n/////////////////////////////// \r\n\r\nvar TakeProfitMod = 'Take Profit Settings'\r\nisTP = input(false, 'Take Profit', group = TakeProfitMod)\r\ntp = input.float(12.0, 'Take Profit (%)', minval = 0, step = 0.1, group = TakeProfitMod) / 100\r\nttp = input.float(2.5, 'Trailing Profit (%)', minval = 0, step = 0.1, group = TakeProfitMod) / 100\r\nttp := ttp > tp ? tp : ttp\r\n\r\nlong_tp = isTP and in_longCondition and last_high >= last_open_longCondition + last_open_longCondition * tp and low_ <= last_high - last_high * ttp\r\nshort_tp = isTP and in_shortCondition and last_low <= last_open_shortCondition - last_open_shortCondition * tp and high_ >= last_low + last_low * ttp\r\n\r\n/////////////////////////////////////\r\n//======[ Staged Take Profit]======//   \r\n/////////////////////////////////////\r\n\r\nvar StagedTPMod = 'Staged Take Profit Settings'\r\nisSTP = input(false, 'Use Staged Take Profit (Default = No)', group = StagedTPMod)\r\nisSTPIndices = input(false, 'Add Indices Exit Modifier (Default = No)', group = StagedTPMod)\r\nisSTPIndicesFlip = input(false, 'Flip Indices Exit Modifier (Default = No)', group = StagedTPMod)\r\nStp1Per = input.float(10.0, '1st Level - Take Profit Activation Percent (%))', minval = 0, step = 0.1, group = StagedTPMod) // 100\r\nStp1Trail = input.float(5.0, '1st Level - Trailing Profit Percent (%)', minval = 0, step = 0.1, group = StagedTPMod) // 100\r\nStp1Qty = input.float(10.0, '1st Level - Close Order Quantity (%)', minval = 0, step = 0.1, group = StagedTPMod) // 100\r\nStp2Per = input.float(20.0, '2nd Level - Take Profit Activation Percent (%))', minval = 0, step = 0.1, group = StagedTPMod) // 100\r\nStp2Trail = input.float(10.0, '2nd Level - Trailing Profit Percent (%)', minval = 0, step = 0.1, group = StagedTPMod) // 100\r\nStp2Qty = input.float(10.0, '2nd Level - Close Order Quantity (%)', minval = 0, step = 0.1, group = StagedTPMod) // 100\r\nStp3Per = input.float(30.0, '3rd Level - Take Profit Activation Percent (%)', minval = 0, step = 0.1, group = StagedTPMod) // 100\r\nStp3Trail = input.float(5.0, '3rd Level - Trailing Profit Percent (%)', minval = 0, step = 0.1, group = StagedTPMod) // 100\r\nStp3Qty = input.float(70.0, '3rd Level - Close Order Quantity (%)', minval = 0, step = 0.1, group = StagedTPMod) // 100\r\n\r\n//Indices Strength Buy/Sell Requirements\r\nIndicesStrengthTP1 = input.int(title = 'TP1 - Indices Trigger Strength(Max=12; Min=1)', minval = 1, defval = 6, maxval = 12, group = StagedTPMod)\r\nIndicesContTP1 = input.int(title = 'TP1 - Indices Continuity (Max=20; Min=1)', minval = 1, defval = 3, maxval = 20, group = StagedTPMod)\r\nIndicesStrengthTP2 = input.int(title = 'TP2 - Indices Trigger Strength(Max=12; Min=1)', minval = 1, defval = 8, maxval = 12, group = StagedTPMod)\r\nIndicesContTP2 = input.int(title = 'TP2 - Indices Continuity (Max=20; Min=1)', minval = 1, defval = 3, maxval = 20, group = StagedTPMod)\r\nIndicesStrengthTP3 = input.int(title = 'TP3 - Indices Trigger Strength(Max=12; Min=1)', minval = 1, defval = 10, maxval = 12, group = StagedTPMod)\r\nIndicesContTP3 = input.int(title = 'TP3 - Indices Continuity (Max=20; Min=1)', minval = 1, defval = 3, maxval = 20, group = StagedTPMod)\r\n\r\nvar ICL1_EnterCounter = 0\r\nvar ICS1_EnterCounter = 0\r\nvar ICL2_EnterCounter = 0\r\nvar ICS2_EnterCounter = 0\r\nvar ICL3_EnterCounter = 0\r\nvar ICS3_EnterCounter = 0\r\n\r\nICL1_EnterCounter := TrendTrackerBand >= IndicesStrengthTP1 ? ICL1_EnterCounter + 1 : 0\r\nICS1_EnterCounter := TrendTrackerBand <= IndicesStrengthTP1 * -1 ? ICS1_EnterCounter + 1 : 0\r\nICL2_EnterCounter := TrendTrackerBand >= IndicesStrengthTP2 ? ICL2_EnterCounter + 1 : 0\r\nICS2_EnterCounter := TrendTrackerBand <= IndicesStrengthTP2 * -1 ? ICS2_EnterCounter + 1 : 0\r\nICL3_EnterCounter := TrendTrackerBand >= IndicesStrengthTP3 ? ICL3_EnterCounter + 1 : 0\r\nICS3_EnterCounter := TrendTrackerBand <= IndicesStrengthTP3 * -1 ? ICS3_EnterCounter + 1 : 0\r\n\r\n//Prime Indices Conditions\r\nIndicesBuy1Prime = TrendTrackerBand >= IndicesStrengthTP1 and ICL1_EnterCounter >= IndicesContTP1 and close_ < last_open_shortConditionTight ? 1 : 0\r\nIndicesShort1Prime = TrendTrackerBand <= IndicesStrengthTP1 * -1 and ICS1_EnterCounter >= IndicesContTP1 and close_ > last_open_longConditionTight ? -1 : 0\r\nIndicesBuy2Prime = TrendTrackerBand >= IndicesStrengthTP2 and ICL2_EnterCounter >= IndicesContTP2 and close_ < last_open_shortConditionTight ? 1 : 0\r\nIndicesShort2Prime = TrendTrackerBand <= IndicesStrengthTP2 * -1 and ICS2_EnterCounter >= IndicesContTP2 and close_ > last_open_longConditionTight ? -1 : 0\r\nIndicesBuy3Prime = TrendTrackerBand >= IndicesStrengthTP3 and ICL3_EnterCounter >= IndicesContTP3 and close_ < last_open_shortConditionTight ? 1 : 0\r\nIndicesShort3Prime = TrendTrackerBand <= IndicesStrengthTP3 * -1 and ICS3_EnterCounter >= IndicesContTP3 and close_ > last_open_longConditionTight ? -1 : 0\r\n\r\n//Alternate Indices Conditions \r\nIndicesBuy1Alt = TrendTrackerBand <= IndicesStrengthTP1 * -1 and ICL1_EnterCounter >= IndicesContTP1 and close_ > last_open_longConditionTight ? 1 : 0\r\nIndicesShort1Alt = TrendTrackerBand >= IndicesStrengthTP1 and ICS1_EnterCounter >= IndicesContTP1 and close_ < last_open_shortConditionTight ? -1 : 0\r\nIndicesBuy2Alt = TrendTrackerBand <= IndicesStrengthTP2 * -1 and ICL2_EnterCounter >= IndicesContTP2 and close_ > last_open_longConditionTight ? 1 : 0\r\nIndicesShort2Alt = TrendTrackerBand >= IndicesStrengthTP2 and ICS2_EnterCounter >= IndicesContTP2 and close_ < last_open_shortConditionTight ? -1 : 0\r\nIndicesBuy3Alt = TrendTrackerBand <= IndicesStrengthTP3 * -1 and ICL3_EnterCounter >= IndicesContTP3 and close_ > last_open_longConditionTight ? 1 : 0\r\nIndicesShort3Alt = TrendTrackerBand >= IndicesStrengthTP3 and ICS3_EnterCounter >= IndicesContTP3 and close_ < last_open_shortConditionTight ? -1 : 0\r\n\r\nIndicesBuy1 = isSTPIndicesFlip == false ? IndicesBuy1Prime : IndicesBuy1Alt\r\nIndicesBuy2 = isSTPIndicesFlip == false ? IndicesBuy2Prime : IndicesBuy2Alt\r\nIndicesBuy3 = isSTPIndicesFlip == false ? IndicesBuy3Prime : IndicesBuy3Alt\r\nIndicesShort1 = isSTPIndicesFlip == false ? IndicesShort1Prime : IndicesShort1Alt\r\nIndicesShort2 = isSTPIndicesFlip == false ? IndicesShort2Prime : IndicesShort2Alt\r\nIndicesShort3 = isSTPIndicesFlip == false ? IndicesShort3Prime : IndicesShort3Alt\r\n\r\nLongTSActivate1 = last_high >= last_open_longCondition + last_open_longCondition * (Stp1Per / 100) ? true : false\r\nShortTSActivate1 = last_low <= last_open_shortCondition - last_open_shortCondition * (Stp1Per / 100) ? true : false\r\nLongTSActivate2 = last_high >= last_open_longCondition + last_open_longCondition * (Stp2Per / 100) ? true : false\r\nShortTSActivate2 = last_low <= last_open_shortCondition - last_open_shortCondition * (Stp2Per / 100) ? true : false\r\nLongTSActivate3 = last_high >= last_open_longCondition + last_open_longCondition * (Stp3Per / 100) ? true : false\r\nShortTSActivate3 = last_low <= last_open_shortCondition - last_open_shortCondition * (Stp3Per / 100) ? true : false\r\n\r\nlong_Stp1 = isSTP and in_longCondition and not na(last_high) and isSTPIndices == true and IndicesShort1 == -1 ? true : isSTP and in_longCondition and not na(last_high) and LongTSActivate1 == true and low_ <= last_high - last_high * (Stp1Trail / 100) ? true : false\r\nshort_Stp1 = isSTP and in_shortCondition and not na(last_low) and isSTPIndices == true and IndicesBuy1 == 1 ? true : isSTP and in_shortCondition and not na(last_low) and ShortTSActivate1 == true and high_ >= last_low + last_low * (Stp1Trail / 100) ? true : false\r\nlong_Stp2 = isSTP and in_longCondition and not na(last_high) and isSTPIndices == true and IndicesShort2 == -1 ? true : isSTP and in_longCondition and not na(last_high) and LongTSActivate2 == true and low_ <= last_high - last_high * (Stp2Trail / 100) ? true : false\r\nshort_Stp2 = isSTP and in_shortCondition and not na(last_low) and isSTPIndices == true and IndicesBuy2 == 1 ? true : isSTP and in_shortCondition and not na(last_low) and ShortTSActivate2 == true and high_ >= last_low + last_low * (Stp2Trail / 100) ? true : false\r\nlong_Stp3 = isSTP and in_longCondition and not na(last_high) and isSTPIndices == true and IndicesShort3 == -1 ? true : isSTP and in_longCondition and not na(last_high) and LongTSActivate3 == true and low_ <= last_high - last_high * (Stp3Trail / 100) ? true : false\r\nshort_Stp3 = isSTP and in_shortCondition and not na(last_low) and isSTPIndices == true and IndicesBuy3 == 1 ? true : isSTP and in_shortCondition and not na(last_low) and ShortTSActivate3 == true and high_ >= last_low + last_low * (Stp3Trail / 100) ? true : false\r\n\r\nlongSTP1S = long_Stp1 == true and last_high > last_open_longCondition ? last_high - last_high * (Stp1Per / 100) : Stp1Qty <= 0 ? na : na\r\nlongSTP2S = long_Stp2 == true and last_high > last_open_longCondition ? last_high - last_high * (Stp2Per / 100) : Stp2Qty <= 0 ? na : na\r\nlongSTP3S = long_Stp3 == true and last_high > last_open_longCondition ? last_high - last_high * (Stp3Per / 100) : Stp3Qty <= 0 ? na : na\r\n\r\nshortSTP1S = short_Stp1 == true and last_low < last_open_shortCondition ? last_low + last_low * (Stp1Per / 100) : Stp1Qty <= 0 ? na : na\r\nshortSTP2S = short_Stp2 == true and last_low < last_open_shortCondition ? last_low + last_low * (Stp2Per / 100) : Stp2Qty <= 0 ? na : na\r\nshortSTP3S = short_Stp3 == true and last_low < last_open_shortCondition ? last_low + last_low * (Stp3Per / 100) : Stp3Qty <= 0 ? na : na\r\n\r\nlongSTP1 = isSTPIndices == true and IndicesShort1 == -1 ? close : long_Stp1 == true and last_high > last_open_longCondition ? last_high - last_high * (Stp1Per / 100) : Stp1Qty <= 0 ? na : na\r\nlongSTP2 = isSTPIndices == true and IndicesShort2 == -1 ? close : long_Stp2 == true and last_high > last_open_longCondition ? last_high - last_high * (Stp2Per / 100) : Stp2Qty <= 0 ? na : na\r\nlongSTP3 = isSTPIndices == true and IndicesShort3 == -1 ? close : long_Stp3 == true and last_high > last_open_longCondition ? last_high - last_high * (Stp3Per / 100) : Stp3Qty <= 0 ? na : na\r\n\r\nshortSTP1 = isSTPIndices == true and IndicesBuy1 == 1 ? close : short_Stp1 == true and last_low < last_open_shortCondition ? last_low + last_low * (Stp1Per / 100) : Stp1Qty <= 0 ? na : na\r\nshortSTP2 = isSTPIndices == true and IndicesBuy2 == 1 ? close : short_Stp2 == true and last_low < last_open_shortCondition ? last_low + last_low * (Stp2Per / 100) : Stp2Qty <= 0 ? na : na\r\nshortSTP3 = isSTPIndices == true and IndicesBuy3 == 1 ? close : short_Stp3 == true and last_low < last_open_shortCondition ? last_low + last_low * (Stp3Per / 100) : Stp3Qty <= 0 ? na : na\r\n\r\nStp1QtyF = Stp1Qty <= 0 ? na : Stp1Qty\r\nStp2QtyF = Stp2Qty <= 0 ? na : Stp2Qty\r\nStp3QtyF = Stp3Qty <= 0 ? na : Stp3Qty\r\n\r\n// --- V6 FIX EXPLANATION ---\r\n// In V6, we cannot compare a boolean to 0 (e.g. `long_Stp1 != 0`).\r\n// We must just check the boolean itself.\r\nvar Counter_LTP1 = 0\r\nCounter_LTP1 := long_Stp1 ? Counter_LTP1 + 1 : AF != 0 ? 0 : Counter_LTP1[1]\r\nvar Counter_LTP2 = 0\r\nCounter_LTP2 := long_Stp2 ? Counter_LTP2 + 1 : AF != 0 ? 0 : Counter_LTP2[1]\r\nvar Counter_LTP3 = 0\r\nCounter_LTP3 := long_Stp3 ? Counter_LTP3 + 1 : AF != 0 ? 0 : Counter_LTP3[1]\r\nvar Counter_STP1 = 0\r\nCounter_STP1 := short_Stp1 ? Counter_STP1 + 1 : AF != 0 ? 0 : Counter_STP1[1]\r\nvar Counter_STP2 = 0\r\nCounter_STP2 := short_Stp2 ? Counter_STP2 + 1 : AF != 0 ? 0 : Counter_STP2[1]\r\nvar Counter_STP3 = 0\r\nCounter_STP3 := short_Stp3 ? Counter_STP3 + 1 : AF != 0 ? 0 : Counter_STP3[1]\r\n\r\nTakeProfit1Plot = long_Stp1 == true and long_Stp1 != long_Stp1[1] and Counter_LTP1 == 1 ? 1 : short_Stp1 == true and short_Stp1 != short_Stp1[1] and Counter_STP1 == 1 ? -1 : 0\r\nTakeProfit2Plot = long_Stp2 == true and long_Stp2 != long_Stp2[1] and Counter_LTP2 == 1 ? 2 : short_Stp2 == true and short_Stp2 != short_Stp2[1] and Counter_STP2 == 1 ? -2 : 0\r\nTakeProfit3Plot = long_Stp3 == true and long_Stp3 != long_Stp3[1] and Counter_LTP3 == 1 ? 3 : short_Stp3 == true and short_Stp3 != short_Stp3[1] and Counter_STP3 == 1 ? -3 : 0\r\n\r\n/////////////////////////////\r\n//======[ Stop Loss ]======//\r\n///////////////////////////// \r\n\r\nvar SLMod = 'Stop Loss Settings'\r\nisSLPre = input(true, 'Stop Loss', group = SLMod)\r\nslPre = input.float(18.0, 'Stop Loss (%)', minval = 0, step = 0.1, group = SLMod) / 100\r\nuseActiveHSRS_SL = input(false, 'Use Active HSRS Stop Loss (Default = No)', group = SLMod)\r\n\r\nIndicesStrengthOmegaStop = input.int(title = '*Omega Stop - Indices Trigger Strength (Max=12; Min=1)', minval = 1, defval = 12, maxval = 12, group = SLMod)\r\nIndicesContOmegaStop = input.int(title = '*Omega Stop - Indices Continuity (Max=20; Min=1)', minval = 1, defval = 3, maxval = 20, group = SLMod)\r\n\r\nvar ICLOmegaStop_EnterCounter = 0\r\nvar ICSOmegaStop_EnterCounter = 0\r\n\r\nICLOmegaStop_EnterCounter := TrendTrackerBand >= IndicesStrengthOmegaStop ? ICLOmegaStop_EnterCounter + 1 : 0\r\nICSOmegaStop_EnterCounter := TrendTrackerBand <= IndicesStrengthOmegaStop * -1 ? ICSOmegaStop_EnterCounter + 1 : 0\r\n\r\nIndicesBuyOmegaStop = TrendTrackerBand >= IndicesStrengthOmegaStop and ICLOmegaStop_EnterCounter >= IndicesContOmegaStop ? 1 : 0\r\nIndicesShortOmegaStop = TrendTrackerBand <= IndicesStrengthOmegaStop * -1 and ICSOmegaStop_EnterCounter >= IndicesContOmegaStop ? -1 : 0\r\n\r\nisSL = HSRS_InhibXy == 1 and useActiveHSRS_SL == true ? true : isSLPre\r\nsl = HSRS_InhibXy == 1 and useActiveHSRS_SL == true ? 0.02 : slPre\r\n\r\nlong_sl = isSL and in_longCondition and low_ <= last_open_longCondition - last_open_longCondition * sl ? true : IndicesShortOmegaStop == -1 ? true : false\r\nshort_sl = isSL and in_shortCondition and high_ >= last_open_shortCondition + last_open_shortCondition * sl ? true : IndicesBuyOmegaStop == 1 ? true : false\r\n\r\nsl_CloseSignal = long_sl == true ? 1 : short_sl == true ? -1 : 0\r\n\r\n/////////////////////////////////////////////////\r\n//======[Advance Adaptive Trailing Stop ]======//\r\n/////////////////////////////////////////////////\r\n\r\n//50 period EMA\r\nlenEMA = 50\r\nsrcEMA = close\r\noutEMA = ta.sma(srcEMA, lenEMA)\r\nCS_AATS = ta.ema(close, 7)\r\n\r\nHSRS_RangePenthouse = CS_AATS >= upper_HSRS ? 6 : 0\r\nHSRS_Range4thFloor = CS_AATS < upper_HSRS and CS_AATS >= upperHSRS ? 5 : 0\r\nHSRS_Range3rdFloor = CS_AATS < upperHSRS and CS_AATS >= basisHSRS ? 4 : 0\r\nHSRS_Range2ndFloor = CS_AATS < basisHSRS and CS_AATS >= lowerHSRS ? 3 : 0\r\nHSRS_Range1stFloor = CS_AATS < lowerHSRS and CS_AATS >= lower_HSRS ? 2 : 0\r\nHSRS_RangeDungeon = CS_AATS < lower_HSRS ? 1 : 0\r\nHSRS_Location = HSRS_RangeDungeon + HSRS_Range1stFloor + HSRS_Range2ndFloor + HSRS_Range3rdFloor + HSRS_Range4thFloor + HSRS_RangePenthouse\r\n\r\nAATS_Engage3 = CS_AATS > outEMA and CS_AATS > basisHSRS and CS_AATS > upper1MBB ? 1 : CS_AATS < outEMA and CS_AATS < basisHSRS and CS_AATS < lower1MBB ? -1 : 0\r\nAATS_Factor = AATS_Engage3 == 1 and HSRS_Location == 6 ? 0.5 : AATS_Engage3 == 1 and HSRS_Location == 5 ? 2 : AATS_Engage3 == 1 and HSRS_Location == 4 ? 3 : AATS_Engage3 == -1 and HSRS_Location == 1 ? 0.5 : AATS_Engage3 == -1 and HSRS_Location == 2 ? 2 : AATS_Engage3 == -1 and HSRS_Location == 3 ? 3 : 4\r\n\r\nvar SLMod2 = 'Stop Loss Qualifiers'\r\n\r\n//ATS Code\r\n//Code originlly by alexgrover, modified by SignalLynx for use in the trade engine\r\nUseAATS = input(true, 'Use Advance Adaptive Trailing Stop (AATS) - (Default is On)', group = SLMod2)\r\nRestrictiveAATS = input(true, 'Use Restrictive AATS - Good for majors (Default is On)', group = SLMod2)\r\nUseRSIS = input(true, 'Use RSI Stop (RSIS) - (Default is On)', group = SLMod2)\r\n\r\nsrcATS = close\r\naATS = 0.0\r\nbATS = 0.0\r\nosATS = 0.0\r\n\r\natsFacInput = input(100, 'ATS Stop Factor (0+)', group = SLMod2)\r\nerATS = AATS_Factor / atsFacInput\r\n\r\n\r\naATS := math.max(srcATS, nz(aATS[1], srcATS)) - math.abs(srcATS - nz(aATS[1], srcATS)) * erATS\r\nbATS := math.min(srcATS, nz(bATS[1], srcATS)) + math.abs(srcATS - nz(bATS[1], srcATS)) * erATS\r\n\r\nATSCross1 = ta.cross(aATS, srcATS) ? 1 : 0\r\nATSCross2 = ta.cross(bATS, srcATS) ? 0 : -1\r\n\r\nosATS := ATSCross1 == 1 ? 1 : ATSCross2 == 0 ? 0 : osATS[1]\r\ntsATS = osATS * bATS + (1 - osATS) * aATS\r\n\r\nATSaX = ta.sma(close - (aATS - close), 7)\r\nATSbX = ta.sma(close + close - bATS, 7)\r\n\r\n//RSI Stop Loss Testing\r\nMcGinleyRSIS(_srcRSIS, lenRSIS) =>\r\n    MDRSIS = 0.0\r\n    MDRSIS := na(_srcRSIS[1]) ? _srcRSIS : MDRSIS[1] + (_srcRSIS - MDRSIS[1]) / (0.6 * lenRSIS * math.pow(_srcRSIS / MDRSIS[1], 4))\r\n    MDRSIS\r\n\r\nrsi_maRSIS = McGinleyRSIS(close, 14)\r\nATRRSIS = ta.atr(27)\r\ntop_lineRSIS = rsi_maRSIS + ATRRSIS\r\nbottom_lineRSIS = rsi_maRSIS - ATRRSIS\r\nDirectionRSIS1 = ta.crossover(close, top_lineRSIS) ? 1 : 0\r\nDirectionRSIS2 = ta.crossunder(close, bottom_lineRSIS) ? -1 : 0\r\ndirectionRSIS = 1\r\ndirectionRSIS := DirectionRSIS1 == 1 ? 1 : DirectionRSIS2 == -1 ? -1 : directionRSIS[1]\r\nstop_lineRSIS = rsi_maRSIS - directionRSIS * ATRRSIS\r\nRSIS_Signal = directionRSIS\r\n\r\nATS_CloseLongsX = UseRSIS == true and in_longCondition == true and AATS_Engage3 == 1 and espf_FinalX == -1 and RSIS_Signal == -1 ? true : false\r\nATS_CloseShortsX = UseRSIS == true and in_shortCondition == true and AATS_Engage3 == -1 and espf_FinalX == 1 and RSIS_Signal == 1 ? true : false\r\n\r\n//Check to see if we should be using ATS Module\r\nATS_CloseLongsY = UseAATS == true and in_longCondition == true and AATS_Engage3 == 1 and espf_FinalX == -1 and MTISignal == -1 and low_ < bATS and low_ < ATSbX and low_ < ATSaX ? true : false ///\r\nATS_CloseShortsY = UseAATS == true and in_shortCondition == true and AATS_Engage3 == -1 and espf_FinalX == 1 and MTISignal == 1 and high_ > aATS and high_ > ATSaX and high_ > ATSbX ? true : false\r\n\r\nATS_CloseLongsAgg = ATS_CloseLongsX == true or ATS_CloseLongsY == true ? true : false\r\nATS_CloseShortsAgg = ATS_CloseShortsX == true or ATS_CloseShortsY == true ? true : false\r\n\r\nATS_CloseLongsRestrictive = ATS_CloseLongsY == true ? true : false\r\nATS_CloseShortsRestrictive = ATS_CloseShortsY == true ? true : false\r\n\r\nATS_CloseLongs = RestrictiveAATS == true ? ATS_CloseLongsRestrictive : ATS_CloseLongsAgg\r\nATS_CloseShorts = RestrictiveAATS == true ? ATS_CloseShortsRestrictive : ATS_CloseShortsAgg\r\n\r\n/////////////////////////////////\r\n//======[ Close Signals ]======//\r\n/////////////////////////////////\r\n\r\n// Create a single close for all the different closing conditions, all conditions here are non-repainting\r\nlongCloseX := (long_tp or long_sl or long_ts or long_tsBB or ATS_CloseLongs) and not longCondition\r\nshortCloseX := (short_tp or short_sl or short_ts or short_tsBB or ATS_CloseShorts) and not shortCondition\r\n\r\n/////////////////////////////////\r\n//======[ MTI Kicker ]=========//\r\n/////////////////////////////////\r\n\r\n//Restrictive DPT Code Settings\r\nKickerPercentUp1 = TrendPath == 1 and HalvingInhibitor2 == 0 ? KickerPercentDnTrend / 100 + 1 : KickerPercentUpTrend / 100 + 1\r\nKickerPercentDown1 = TrendPath == 1 and HalvingInhibitor2 == 0 ? 1 - KickerPercentDnTrend / 100 : 1 - KickerPercentUpTrend / 100\r\nKickerPercent1 = TrendPath == 1 and HalvingInhibitor2 == 0 ? KickerPercentDnTrend : KickerPercentUpTrend\r\n\r\nKickerPercentUp2 = Engagey == 1 ? KickerPercentDnTrend / 100 + 1 : KickerPercentUpTrend / 100 + 1\r\nKickerPercentDown2 = Engagey == 1 ? 1 - KickerPercentDnTrend / 100 : 1 - KickerPercentUpTrend / 100\r\nKickerPercent2 = Engagey == 1 ? KickerPercentDnTrend : KickerPercentUpTrend\r\n\r\nKickerPercentUp = KickerPercentChoice == true ? KickerPercentUp1 : KickerPercentUp2\r\nKickerPercentDown = KickerPercentChoice == true ? KickerPercentDown1 : KickerPercentDown2\r\nKickerPercent = KickerPercentChoice == true ? KickerPercent1 : KickerPercent2\r\n\r\nKickerLongActivate = in_longCondition and not na(last_highTS) and close_ <= last_highTS - last_highTS * (KickerPercent / 100) or ATS_CloseLongs ? true : false\r\nKickerShortActivate = in_shortCondition and not na(last_lowTS) and close_ >= last_lowTS + last_lowTS * (KickerPercent / 100) or ATS_CloseShorts ? true : false\r\n\r\nMTI_Kicker_X = KickerLongActivate == true ? 1 : KickerShortActivate == true ? -1 : 0\r\n\r\nMTI_Kick := MTI_Kicker_X\r\n\r\n//Loose DPT Kicker Code\r\nvar MTI_Kicker_Reset = 0\r\n\r\nCloseTracker = float(na)\r\nCloseTracker := ItClosed == 1 ? 1 : ItClosed == -1 ? -1 : NewOpen == 2 or NewOpen == -2 ? 0 : nz(CloseTracker[1])\r\n\r\nlast_CloseUp = float(na)\r\nlast_CloseDown = float(na)\r\nlast_CloseUp := ItClosed == 1 or MTI_Kicker_Reset == 1 ? close : NewOpen == 2 or NewOpen == -2 ? 0 : nz(last_CloseUp[1])\r\nlast_CloseDown := ItClosed == -1 or MTI_Kicker_Reset == 1 ? close : NewOpen == 2 or NewOpen == -2 ? 0 : nz(last_CloseDown[1])\r\n\r\nCloseTracker2 = CloseTracker == 1 or CloseTracker == -1 ? 1 : 0\r\n\r\nclose_Kicker = close > last_CloseUp * KickerPercentUp and last_CloseUp != 0 ? 2 : close > last_CloseDown * KickerPercentUp and last_CloseDown != 0 ? 2 : close < last_CloseUp * KickerPercentDown and last_CloseUp != 0 ? -2 : close < last_CloseDown * KickerPercentDown and last_CloseDown != 0 ? -2 : 0\r\n\r\nclose_Kicker2 = float(na)\r\nclose_Kicker2 := close_Kicker == 2 ? 4 : close_Kicker == -2 ? -4 : NewOpen == 2 or NewOpen == -2 or MTI_Kicker_Reset == 1 ? 0 : close_Kicker2[1]\r\n\r\nclose_Kicker3 = close_Kicker2 == 4 and close_Kicker2 != close_Kicker2[1] ? 2 : close_Kicker2 == -4 and close_Kicker2 != close_Kicker2[1] ? -2 : 0\r\n\r\nin_CloseUp = ItClosed == 1 ? true : false\r\nin_CloseDown = ItClosed == -1 ? true : false\r\n\r\nlast_OpenUp = float(na)\r\nlast_OpenDown = float(na)\r\nlast_OpenUp := NewOpen == 2 or MTI_Kicker_Reset == 1 ? close : ItClosed == 1 or ItClosed == -1 or NewOpen == -2 ? 0 : nz(last_OpenUp[1])\r\nlast_OpenDown := NewOpen == -2 or MTI_Kicker_Reset == 1 ? close : ItClosed == 1 or ItClosed == -1 or NewOpen == 2 ? 0 : nz(last_OpenDown[1])\r\n\r\nOpen_Kicker = close > last_OpenUp * KickerPercentUp and last_OpenUp != 0 ? 2 : close > last_OpenDown * KickerPercentUp and last_OpenDown != 0 ? 2 : close < last_OpenUp * KickerPercentDown and last_OpenUp != 0 ? -2 : close < last_OpenDown * KickerPercentDown and last_OpenDown != 0 ? -2 : 0\r\nOpen_Kicker2 = float(na)\r\nOpen_Kicker2 := Open_Kicker == 2 ? 4 : Open_Kicker == -2 ? -4 : ItClosed == 1 or ItClosed == -1 or NewOpen == 2 or NewOpen == -2 or MTI_Kicker_Reset == 1 ? 0 : Open_Kicker2[1]\r\nOpen_Kicker3 = Open_Kicker2 == 4 and Open_Kicker2 != Open_Kicker2[1] ? 2 : Open_Kicker2 == -4 and Open_Kicker2 != Open_Kicker2[1] ? -2 : 0\r\n\r\nMTI_Kicker_Reset := close_Kicker3 == 2 or close_Kicker3 == -2 or Open_Kicker3 == 2 or Open_Kicker3 == -2 ? 1 : 0\r\nMTI_Kicker_Final := close_Kicker3 == 2 or Open_Kicker3 == 2 ? 1 : close_Kicker3 == -3 or Open_Kicker3 == -2 ? -1 : 0\r\n\r\nMTI_Kicker_Reset_Mod = MTI_Kicker_Reset == 1 ? 100 : 0\r\n\r\n////////////////////////////////////////////////////////////////\r\n//* Final Order Signals - Buys and Sells                     *//\r\n////////////////////////////////////////////////////////////////\r\n\r\n//Final Inputs for Risk Mitgattion Code Sequence\r\nInhibitOnStop = input(true, 'Inhibit Trading Directional Trailing Stop Out - Use ESBF (Default = Yes)', group = SLMod2)\r\nInhibitOnATS = input(true, 'Inhibit Trading Adaptive Trailing Stop - Use ESBF (Default = Yes)', group = SLMod2)\r\nUseMartingaleTS = input(true, 'Engage Martingale on Trailing Stop Out (Default = Yes)', group = SLMod2)\r\nUseMartingaleSL = input(false, 'Engage Martingale on Stop Loss (Default = No)', group = SLMod2)\r\nUseMartingaleATS = input(true, 'Engage Martingale on ATS or AATS Stop Out (Default = Yes)', group = SLMod2)\r\n\r\nATSMartPre = ATS_CloseLongs == true ? 1 : ATS_CloseShorts == true ? -1 : 0\r\ntsMart := UseMartingaleTS == true ? ts_CloseSignal : 0\r\nslMart := UseMartingaleSL == true ? sl_CloseSignal : 0\r\nATSMart := UseMartingaleATS == true ? ATSMartPre : 0\r\n\r\nRMPlot = longCloseX == true or CSX == 1 ? 1 : shortCloseX == true or CSX == -1 ? -1 : 0\r\nRMSig = RMPlot == 1 and RMPlot != RMPlot[1] ? 1 : RMPlot == -1 and RMPlot != RMPlot[1] ? -1 : 0\r\n\r\nClearRM = AT == 2 and RMSig == 1 ? 3 : AT == -2 and RMSig == -1 ? -3 : 0\r\n\r\nClearRMP = float(na)\r\nClearRMP := ClearRM == 3 ? 3 : ClearRM == -3 ? -3 : AO == 2 or AO == -2 ? 0 : ClearRMP[1]\r\n\r\nReOrder = ClearRMP == 0 and ClearRMP[1] == 3 and ClearRMP != ClearRMP[1] ? 4 : ClearRMP == 0 and ClearRMP[1] == -3 and ClearRMP != ClearRMP[1] ? -4 : 0\r\n\r\nRM_Hold = float(na)\r\nRM_Hold := RMSig == 1 ? 1 : RMSig == -1 ? -1 : RM_Hold[1]\r\n\r\nTradeInhibitorZ = espf_Inhibit == 1 ? 4 : espf_Inhibit == -1 ? -4 : 0\r\n\r\nInhibA = long_ts == true or long_tsBB == true ? 1 : short_ts == true or short_tsBB == true ? -1 : 0\r\nInhibATS = ATS_CloseLongs == true ? 1 : ATS_CloseShorts == true ? -1 : 0\r\n\r\nInhibX = float(na)\r\nInhibX := InhibA == 1 ? 3 : InhibA == -1 ? -3 : AT != AT[1] ? 0 : InhibX[1]\r\n\r\nInhibATSX = float(na)\r\nInhibATSX := InhibATS == 1 ? 3 : InhibATS == -1 ? -3 : InhibATSX[1]\r\n\r\nInhibB = InhibX == 3 and TradeInhibitorZ == 4 ? 2 : InhibX == -3 and TradeInhibitorZ == -4 ? -2 : 0\r\nInhibATSB = InhibATSX == 3 and TradeInhibitorZ == 4 and AT == 2 ? 2 : InhibATSX == -3 and TradeInhibitorZ == -4 and AT == -2 ? -2 : 0\r\n\r\nInhibLongFinalTS = InhibitOnStop == true ? InhibB : 0\r\nInhibShortFinalTS = InhibitOnStop == true ? InhibB : 0\r\nInhibLongFinalATS = InhibitOnATS == true ? InhibATSB : 0\r\nInhibShortFinalATS = InhibitOnATS == true ? InhibATSB : 0\r\n\r\nFinPre = AF == 2 or ReOrder == 4 and AT == 2 and InhibLongFinalTS != 2 and InhibLongFinalATS != 2 ? 2 : AF == -2 or ReOrder == -4 and AT == -2 and InhibShortFinalTS != -2 and InhibShortFinalATS != -2 ? -2 : 0\r\n\r\nvar Counter = 0\r\nCounter := RMSig != 0 ? Counter + 1 : FinPre != 0 ? 0 : Counter[1]\r\n\r\nCloseEmAll = RMSig == 1 and Counter == 1 and Counter != Counter[1] ? 1 : RMSig == -1 and Counter == 1 and Counter != Counter[1] ? -1 : 0\r\nItClosed := CloseEmAll\r\n\r\n//Martingale Code\r\nActivateMartingale = UseMartingaleTS == true and InhibitOnStop == true ? true : UseMartingaleSL == true and InhibitOnATS == true ? true : UseMartingaleATS == true and InhibitOnATS == true ? true : false\r\n\r\n//+3 for going long (short stop out); -3 for going Short (long stop out)\r\nMartingale := ActivateMartingale == true and CloseEmAll == 1 ? -3 : ActivateMartingale == true and CloseEmAll == -1 ? 3 : 0\r\n\r\nMartingaleOpen := Martingale == 3 and espf_Final == 1 or MCHRHashClear == 10 and AT == -2 and MCHR_Change_Final == 1 ? 3 : Martingale == -3 and espf_Final == -1 ? -3 : AF == 2 or AF == -2 ? 0 : MartingaleOpen[1]\r\n\r\nFin = FinPre\r\nNewOpen := Fin\r\n\r\n/////////////////////////////\r\n//======[ DCA ]======//\r\n/////////////////////////////\r\nvar DCAMod = 'DCA Module'\r\nisDCA = input(false, 'Activate DCA', group = DCAMod)\r\nDCA = input.float(1.0, 'DCA Threshold(%)', minval = 0, step = 0.1, group = DCAMod) / 100\r\n\r\nlong_DCA = isDCA and in_longCondition and close <= last_open_longConditionTight - last_open_longConditionTight * DCA\r\nshort_DCA = isDCA and in_shortCondition and close >= last_open_shortConditionTight + last_open_shortConditionTight * DCA\r\n\r\nvar DCATracker = 0\r\nDCATracker := long_DCA == true or short_DCA == true ? DCATracker + 1 : FinPre != 0 or FinPre != FinPre[1] ? 0 : DCATracker[1]\r\nDCACommit = long_DCA == true and DCATracker == 1 ? 1 : short_DCA == true and DCATracker == 1 ? -1 : 0\r\n\r\n////////////////////////////////////////////////////////////////\r\n//* Backtest Buys and Sells                                  *//\r\n////////////////////////////////////////////////////////////////\r\n\r\n//Uncomment if an strategy - comment if a indicator\r\n\r\nif testPeriod() and LongAndShort == 1\r\n    if Fin == 2\r\n        strategy.entry('Long', strategy.long, comment = 'Long')\r\n    if DCACommit == 1\r\n        strategy.entry('LongDCA', strategy.long, comment = 'Long DCA')\r\n    strategy.exit('TP1 L', from_entry = 'Long', limit = longSTP1, qty_percent = Stp1QtyF, comment = 'L-TP1')\r\n    strategy.exit('TP2 L', from_entry = 'Long', limit = longSTP2, qty_percent = Stp2QtyF, comment = 'L-TP2')\r\n    strategy.exit('TP3 L', from_entry = 'Long', limit = longSTP3, qty_percent = Stp3QtyF, comment = 'L-TP3')\r\n    strategy.exit('TP1 LDCA', from_entry = 'LongDCA', limit = longSTP1, qty_percent = Stp1QtyF, comment = 'L-TP1-DCA')\r\n    strategy.exit('TP2 LDCA', from_entry = 'LongDCA', limit = longSTP2, qty_percent = Stp2QtyF, comment = 'L-TP2-DCA')\r\n    strategy.exit('TP3 LDCA', from_entry = 'LongDCA', limit = longSTP3, qty_percent = Stp3QtyF, comment = 'L-TP3-DCA')\r\n    if CSX == 1 or longCloseX\r\n        strategy.close('Long')\r\n    if CSX == 1 or longCloseX\r\n        strategy.close('LongDCA')\r\n\r\n\r\nif testPeriod() and LongAndShort == 1\r\n    if Fin == -2\r\n        strategy.entry('Short', strategy.short, comment = 'Short')\r\n    if DCACommit == -1\r\n        strategy.entry('ShortDCA', strategy.short, comment = 'Short DCA')\r\n    strategy.exit('TP1 S', from_entry = 'Short', limit = shortSTP1, qty_percent = Stp1QtyF, comment = 'S-TP1')\r\n    strategy.exit('TP2 S', from_entry = 'Short', limit = shortSTP2, qty_percent = Stp2QtyF, comment = 'S-TP2')\r\n    strategy.exit('TP3 S', from_entry = 'Short', limit = shortSTP3, qty_percent = Stp3QtyF, comment = 'S-TP3')\r\n    strategy.exit('TP1 SDCA', from_entry = 'ShortDCA', limit = shortSTP1, qty_percent = Stp1QtyF, comment = 'S-TP1DCA')\r\n    strategy.exit('TP2 SDCA', from_entry = 'ShortDCA', limit = shortSTP2, qty_percent = Stp2QtyF, comment = 'S-TP2DCA')\r\n    strategy.exit('TP3 SDCA', from_entry = 'ShortDCA', limit = shortSTP3, qty_percent = Stp3QtyF, comment = 'S-TP3DCA')\r\n    if CSX == -1 or shortCloseX\r\n        strategy.close('Short')\r\n    if CSX == -1 or shortCloseX\r\n        strategy.close('ShortDCA')\r\n\r\nif testPeriod() and LongAndShort == 2\r\n    if Fin == 2\r\n        strategy.entry('Long', strategy.long, comment = 'Long')\r\n    if DCACommit == 1\r\n        strategy.entry('LongDCA', strategy.long, comment = 'Long DCA')\r\n    strategy.exit('TP1 L', from_entry = 'Long', limit = longSTP1, qty_percent = Stp1QtyF, comment = 'L-TP1')\r\n    strategy.exit('TP2 L', from_entry = 'Long', limit = longSTP2, qty_percent = Stp2QtyF, comment = 'L-TP2')\r\n    strategy.exit('TP3 L', from_entry = 'Long', limit = longSTP3, qty_percent = Stp3QtyF, comment = 'L-TP3')\r\n    strategy.exit('TP1 LDCA', from_entry = 'LongDCA', limit = longSTP1, qty_percent = Stp1QtyF, comment = 'L-TP1-DCA')\r\n    strategy.exit('TP2 LDCA', from_entry = 'LongDCA', limit = longSTP2, qty_percent = Stp2QtyF, comment = 'L-TP2-DCA')\r\n    strategy.exit('TP3 LDCA', from_entry = 'LongDCA', limit = longSTP3, qty_percent = Stp3QtyF, comment = 'L-TP3-DCA')\r\n    if CSX == 1 or longCloseX or Fin == -2\r\n        strategy.close('Long')\r\n    if CSX == 1 or longCloseX or Fin == -2\r\n        strategy.close('LongDCA')\r\n\r\n\r\n\r\nif testPeriod() and LongAndShort == 3\r\n    if Fin == -2\r\n        strategy.entry('Short', strategy.short, comment = 'Short')\r\n    if DCACommit == -1\r\n        strategy.entry('ShortDCA', strategy.short, comment = 'Short DCA')\r\n    strategy.exit('TP1 S', from_entry = 'Short', limit = shortSTP1, qty_percent = Stp1QtyF, comment = 'S-TP1')\r\n    strategy.exit('TP2 S', from_entry = 'Short', limit = shortSTP2, qty_percent = Stp2QtyF, comment = 'S-TP2')\r\n    strategy.exit('TP3 S', from_entry = 'Short', limit = shortSTP3, qty_percent = Stp3QtyF, comment = 'S-TP3')\r\n    strategy.exit('TP1 SDCA', from_entry = 'ShortDCA', limit = shortSTP1, qty_percent = Stp1QtyF, comment = 'S-TP1DCA')\r\n    strategy.exit('TP2 SDCA', from_entry = 'ShortDCA', limit = shortSTP2, qty_percent = Stp2QtyF, comment = 'S-TP2DCA')\r\n    strategy.exit('TP3 SDCA', from_entry = 'ShortDCA', limit = shortSTP3, qty_percent = Stp3QtyF, comment = 'S-TP3DCA')\r\n    if CSX == -1 or shortCloseX or Fin == 2\r\n        strategy.close('Short')\r\n    if CSX == -1 or shortCloseX or Fin == 2\r\n        strategy.close('ShortDCA')\r\n\r\n\r\n////////////////////////////////////////////////////////////////\r\n//* Alerts Buys and Sells                                    *//\r\n////////////////////////////////////////////////////////////////\r\n\r\n//Uncomment if an indicator - Comment if a strategy\r\n\r\n//Buy and Sell Signals - Fin==2 Long, Fin==-2 Short\r\n//plot(Fin, title=\"Order Open\",linewidth=3,color=color.blue)\r\n\r\n//RM Close Alerts = Close Long = 1, Close Short =-1\r\n//plot(CloseEmAll, title=\"RM Close\", linewidth=3,color=color.yellow)\r\n\r\n//Take Profit Plot 1,2, 3 for Long TP1, 2, 3, and -1 -2 -3 for shorts\r\n//plot(TakeProfitStopsPlot, title=\"TP Close\", linewidth=3,color=color.orange)\r\n//plot(isSTP==true ? TakeProfit1Plot : na, title=\"TP-1 Close\", linewidth=3,color=color.lime)\r\n//plot(isSTP==true ? TakeProfit2Plot : na, title=\"TP-2 Close\", linewidth=3,color=color.olive)\r\n//plot(isSTP==true ? TakeProfit3Plot : na, title=\"TP-3 Close\", linewidth=3,color=color.green)\r\n\r\n///////////////////////////////////\r\n//======[ Reset Variables ]======//\r\n///////////////////////////////////\r\n\r\n//Do not modify, key variables for TradeState engine to function\r\n\r\nif longCloseX or not in_longCondition\r\n    last_high := na\r\n    last_high_short := na\r\n    last_high_short\r\n\r\nif shortCloseX or not in_shortCondition\r\n    last_low := na\r\n    last_low_long := na\r\n    last_low_long\r\n\r\nif longCloseX or shortCloseX\r\n    tradeState := 0\r\n    in_longCondition := false\r\n    in_shortCondition := false\r\n    in_shortCondition\r\n\r\n///////////////////////////////////\r\n//======[ EOF - Done Baby ]======//\r\n///////////////////////////////////"
  },
  {
    "url": "IRxTxcNi-ChronoPulse-MS-MACD-Resonance-Strategy",
    "name": "ChronoPulse MS-MACD Resonance Strategy",
    "description": "ChronoPulse MS-MACD Resonance Strategy \n\nA systematic trading strategy that combines higher-timeframe market structure analysis with dual MACD momentum confirmation, ATR-based risk management, and real-time quality assurance monitoring.\n\n Core Principles \n\nThe strategy operates on the principle of multi-timeframe confluence, requiring agreement between:\n \n Market structure breaks (CHOCH/BOS) on a higher timeframe\n Dual MACD momentum confirmation (classic and crypto-tuned profiles)\n Trend alignment via directional EMAs\n Volatility and volume filters\n Quality score composite threshold\n \n\n Strategy Components \n\n \n Market Structure Engine : Detects Break of Structure (BOS) and Change of Character (CHOCH) events using confirmed pivots on a configurable higher timeframe. Default structure timeframe is 240 minutes (4H).\n\n Dual MACD Fusion : Requires agreement between two MACD configurations:\n \n Classic MACD: 12/26/9 (default)\n Fusion MACD: 8/21/5 (default, optimized for crypto volatility)\n \nBoth must agree on direction before trade execution. This can be disabled to use single MACD confirmation.\n\n Trend Alignment : Uses two EMAs for directional bias:\n \n Directional EMA: 55 periods (default)\n Execution Trend Guide: 34 periods (default)\n \nBoth must align with trade direction.\n\n ATR Risk Management : All risk parameters are expressed in ATR multiples:\n \n Stop Loss: 1.5 Ã— ATR (default)\n Take Profit: 3.0 Ã— ATR (default)\n Trail Activation: 1.0 Ã— ATR profit required (default)\n Trail Distance: 1.5 Ã— ATR behind price (default)\n \n\n Volume Surge Filter : Optional gate requiring current volume to exceed a multiple of the volume SMA. Default threshold is 1.4Ã— the 20-period volume SMA.\n\n Quality Score Gate : Composite score (0-1) combining:\n \n Structure alignment (0.0-1.0)\n Momentum strength (0.0-1.0)\n Trend alignment (0.0-1.0)\n ATR volatility score (0.0-1.0)\n Volume intensity (0.0-1.0)\n \nDefault threshold: 0.62. Trades only execute when quality score exceeds this threshold.\n\n Execution Discipline : Trade budgeting system:\n \n Maximum trades per session: 6 (default)\n Cooldown bars between entries: 5 (default)\n \n\n Quality Assurance Console : Real-time monitoring panel displaying:\n \n Structure status (pass/fail)\n Momentum confirmation (pass/fail)\n Volatility readiness (pass/fail)\n Quality score (pass/fail)\n Discipline compliance (pass/fail)\n Performance metrics (win rate, profit factor)\n Net PnL\n \nCertification requires: Win Rate â‰¥ 40%, Profit Factor â‰¥ 1.4, Minimum 25 closed trades, and positive net profit.\n\n Integrity Suite : Optional validation panel that audits:\n \n Configuration sanity checks\n ATR data readiness\n EMA hierarchy validity\n Performance realism checks\n \n \n\n Strategy Settings  \n\n \nstrategy(\n    title=\"ChronoPulse MS-MACD Resonance Strategy\",\n    shorttitle=\"ChronPulse\",\n    overlay=true,\n    max_labels_count=500,\n    max_lines_count=500,\n    initial_capital=100000,\n    currency=currency.USD,\n    pyramiding=0,\n    commission_type=strategy.commission.percent,\n    commission_value=0.015,\n    slippage=2,\n    default_qty_type=strategy.percent_of_equity,\n    default_qty_value=2.0,\n    calc_on_order_fills=true,\n    calc_on_every_tick=true,\n    process_orders_on_close=true\n)\n \n\n Key Input Parameters \n\n  \n\n \n Structure Timeframe : 240 (4H) - Higher timeframe for structure analysis\n Structure Pivot Left/Right : 3/3 - Pivot confirmation periods\n Structure Break Buffer : 0.15% - Buffer for structure break confirmation\n MACD Fast/Slow/Signal : 12/26/9 - Classic MACD parameters\n Fusion MACD Fast/Slow/Signal : 8/21/5 - Crypto-tuned MACD parameters\n Directional EMA Length : 55 - Primary trend filter\n Execution Trend Guide : 34 - Secondary trend filter\n ATR Length : 14 - ATR calculation period\n ATR Stop Multiplier : 1.5 - Stop loss in ATR units\n ATR Target Multiplier : 3.0 - Take profit in ATR units\n Trail Activation : 1.0 ATR - Profit required before trailing\n Trail Distance : 1.5 ATR - Distance behind price\n Volume Threshold : 1.4Ã— - Volume surge multiplier\n Quality Threshold : 0.62 - Minimum quality score (0-1)\n Max Trades Per Session : 6 - Daily trade limit\n Cooldown Bars : 5 - Bars between entries\n Win-Rate Target : 40% - Minimum for QA certification\n Profit Factor Target : 1.4 - Minimum for QA certification\n Minimum Trades for QA : 25 - Required closed trades\n \n\n Signal Generation Logic \n\nA trade signal is generated when ALL of the following conditions are met:\n\n \n Higher timeframe structure shows bullish (CHOCH/BOS) or bearish structure break\n Both MACD profiles agree on direction (if fusion enabled)\n Price is above both EMAs for longs (below for shorts)\n ATR data is ready and above minimum threshold\n Volume exceeds threshold Ã— SMA (if volume gate enabled)\n Quality score â‰¥ quality threshold\n Trade budget available (under max trades per day)\n Cooldown period satisfied\n \n\n Risk Management \n\n \n Stop loss and take profit are set immediately on entry\n Trailing stop activates after 1.0 ATR of profit\n Trailing stop maintains 1.5 ATR distance behind highest profit point\n Position sizing uses 2% of equity per trade (default)\n No pyramiding (single position per direction)\n \n\n Limitations and Considerations \n\n \n The strategy requires sufficient historical data for higher timeframe structure analysis\n Quality gate may filter out many potential trades, reducing trade frequency\n Performance metrics are based on historical backtesting and do not guarantee future results\n Commission and slippage assumptions (0.015% + 2 ticks) may vary by broker\n The strategy is optimized for trending markets with clear structure breaks\n Choppy or ranging markets may produce false signals\n Crypto markets may require different parameter tuning than traditional assets\n \n\n Optimization Notes \n\nThe strategy includes several parameters that can be tuned for different market conditions:\n\n \n Quality Threshold : Lower values (0.50-0.60) allow more trades but may reduce average quality. Higher values (0.70+) are more selective but may miss opportunities.\n Structure Timeframe : Use 240 (4H) for intraday trading, Daily for swing trading, Weekly for position trading\n Volume Gate : Disable for low-liquidity pairs or when volume data is unreliable\n Dual MACD Fusion : Disable for mean-reverting markets where single MACD may be more responsive\n Trade Discipline : Adjust max trades and cooldown based on your risk tolerance and market volatility\n \n\n Non-Repainting Guarantee \n\nAll higher timeframe data requests use  lookahead=barmerge.lookahead_off  to prevent repainting. Pivot detection waits for full confirmation before registering structure breaks. All visual elements (tables, labels) update only on closed bars.\n\n Alerts \n\nThree alert conditions are available:\n\n \n ChronoPulse Long Setup : Fires when all long entry conditions are met\n ChronoPulse Short Setup : Fires when all short entry conditions are met\n ChronoPulse QA Certification : Fires when Quality Assurance console reaches CERTIFIED status\n \n\nConfigure alerts with  \"Once Per Bar Close\"  delivery to match the non-repainting design.\n\n  \n\n Visual Elements \n\n \n Structure Labels : CHOCHâ†‘, CHOCHâ†“, BOSâ†‘, BOSâ†“ markers on structure breaks\n Directional EMA : Orange line showing trend bias\n Trailing Stop Lines : Green (long) and red (short) trailing stop levels\n Dashboard Panel : Real-time status display (structure, MACD, ATR, quality, PnL)\n QA Console : Quality assurance monitoring panel\n Integrity Suite Panel : Optional validation status display\n \n\n Recommended Usage \n\n \n Forward test with paper trading before live deployment\n Monitor the QA console until it reaches CERTIFIED status\n Adjust parameters based on your specific market and timeframe\n Respect the trade discipline limits to avoid over-trading\n Review quality scores and adjust threshold if needed\n Use appropriate commission and slippage settings for your broker\n \n\n Technical Implementation \n\nThe strategy uses Pine Script v6 with the following key features:\n\n \n Multi-timeframe data requests with lookahead protection\n Confirmed pivot detection for structure analysis\n Dynamic trailing stop management\n Real-time quality score calculation\n Trade budgeting and cooldown enforcement\n Comprehensive dashboard and monitoring panels\n \n\nAll source code is open and available for review and modification.\n\n Disclaimer \n\nThis script is for educational and informational purposes only. It is not intended as financial, investment, or trading advice. Past performance does not guarantee future results. Trading involves substantial risk of loss and is not suitable for all investors. Always conduct your own research and consult with a qualified financial advisor before making any trading decisions. The author and TradingView are not responsible for any losses incurred from using this strategy.\n\n",
    "image_url": "IRxTxcNi",
    "author": "officialjackofalltrades",
    "likes": 29,
    "type": "strategy",
    "created": "2025-12-09",
    "updated": "2025-12-09",
    "source": "//@version=6\nstrategy( title=\"ChronoPulse MS-MACD Resonance Strategy\", shorttitle=\"ChronPulse\", overlay=true, max_labels_count=500, max_lines_count=500, initial_capital=100000, currency=currency.USD, pyramiding=0, commission_type=strategy.commission.percent, commission_value=0.015, slippage=2, default_qty_type=strategy.percent_of_equity, default_qty_value=2.0, calc_on_order_fills=true, calc_on_every_tick=true, process_orders_on_close=true)\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// INPUTS\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\npriceSrc             = input.source(close,     \"Price Source\")\nstructureTf          = input.timeframe(\"240\",  \"Structure Timeframe\", tooltip=\"Higher timeframe used for market structure parsing. 240 = 4H by default.\")\nstructureLeft        = input.int(3,            \"Structure Pivot Left\", minval=1, maxval=15)\nstructureRight       = input.int(3,            \"Structure Pivot Right\", minval=1, maxval=15)\nstructureBreakBuff   = input.float(0.15,       \"Structure Break Buffer (%)\", minval=0.0, maxval=2.0, step=0.05) / 100.0\nmacdTf               = input.timeframe(\"\",     \"MACD Timeframe (optional)\", tooltip=\"Leave empty to use the chart timeframe, or provide a higher timeframe such as 240.\")\nmacdFast             = input.int(12,           \"MACD Fast Length\", minval=1, maxval=50)\nmacdSlow             = input.int(26,           \"MACD Slow Length\", minval=2, maxval=100)\nmacdSignal           = input.int(9,            \"MACD Signal Length\", minval=1, maxval=60)\nfusionEnabled        = input.bool(true,        \"Enable Dual MACD Fusion\", tooltip=\"Requires both classic MACD and the crypto-tuned reactor profile to agree.\")\nfusionFast           = input.int(8,            \"Fusion MACD Fast\", minval=5, maxval=30)\nfusionSlow           = input.int(21,           \"Fusion MACD Slow\", minval=10, maxval=60)\nfusionSignal         = input.int(5,            \"Fusion MACD Signal\", minval=3, maxval=30)\nbiasEmaLen           = input.int(55,           \"Directional EMA Length\", minval=5, maxval=400)\ntrendGuideLen        = input.int(34,           \"Execution Trend Guide\", minval=5, maxval=400, tooltip=\"Secondary EMA used for volume/trend gating.\")\nenableVolumeGate     = input.bool(true,        \"Enable Volume Surge Filter\")\nvolumeLookback       = input.int(20,           \"Volume SMA Length\", minval=5, maxval=200)\nvolumeThreshold      = input.float(1.4,        \"Volume Threshold (x avg)\", minval=1.0, maxval=3.0, step=0.1)\nenableQualityGate    = input.bool(true,        \"Enable Quality Gate\")\nqualityThreshold     = input.float(0.62,       \"Quality Threshold (0-1)\", minval=0.4, maxval=0.95, step=0.01)\natrLen               = input.int(14,           \"ATR Length\", minval=3, maxval=100)\natrTf                = input.timeframe(\"\",     \"ATR Timeframe (optional)\", tooltip=\"Supply a higher timeframe (e.g., 240) if you want smoother risk levels.\")\nstopAtrMult          = input.float(1.5,        \"ATR Stop Multiplier\", minval=0.5, maxval=10.0, step=0.1)\ntpAtrMult            = input.float(3.0,        \"ATR Target Multiplier\", minval=0.5, maxval=15.0, step=0.1)\ntrailTriggerAtr      = input.float(1.0,        \"Trail Activation (ATR)\", minval=0.5, maxval=5.0, step=0.25)\ntrailDistanceAtr     = input.float(1.5,        \"Trail Distance (ATR)\", minval=0.5, maxval=5.0, step=0.25)\nminAtrFilter         = input.float(0.0,        \"Minimum ATR Filter\", minval=0.0, maxval=10.0, step=0.1, tooltip=\"Optional absolute ATR filter to avoid ultra-low volatility regimes. Set to 0 to disable.\")\nenableCryptoMode     = input.bool(false,       \"Activate BTC/crypto Bias Pack\", tooltip=\"Adds a higher-timeframe impulse filter and optional short disabling tuned for trending BTC behavior.\")\ncryptoFastLen        = input.int(34,           \"Impulse Fast EMA\", minval=5, maxval=200)\ncryptoSlowLen        = input.int(144,          \"Impulse Slow EMA\", minval=10, maxval=400)\nlongOnlyMode         = input.bool(false,       \"Long-Only Resonance Mode\", tooltip=\"Disables shorts (recommended for strong BTC bull phases).\")\nmaxTradesPerDay      = input.int(6,            \"Max Trades Per Session\", minval=1, maxval=50)\ncooldownBars         = input.int(5,            \"Cooldown Bars Between Entries\", minval=0, maxval=200)\nperformanceWinTarget = input.float(40.0,       \"Win-Rate Target %\", minval=10.0, maxval=95.0, step=0.5)\nperformancePfTarget  = input.float(1.4,        \"Profit Factor Target\", minval=0.5, maxval=5.0, step=0.1)\nperformanceMinTrades = input.int(25,           \"Minimum Trades for QA\", minval=5, maxval=200)\nqaMinScore           = input.float(0.8,        \"QA Certification Threshold\", minval=0.5, maxval=1.0, step=0.05)\nvalidationMode       = input.string(\"Basic\",   \"Integrity Suite Mode\", options=[\"Off\", \"Basic\", \"Enhanced\"])\nshowValidationPanel  = input.bool(true,        \"Show Integrity Panel\")\nshowValidationDetail = input.bool(false,       \"Show Validation Detail Table\")\nshowStructureLabels  = input.bool(true,        \"Show Structure Labels\")\nshowDashboard        = input.bool(true,        \"Show ChronoPulse Dashboard\")\nshowQaConsole        = input.bool(true,        \"Show QA Console\")\n\ngroupLayout          = \"Layout & Display\"\ndashboardLayout      = input.string(\"Full\",     \"Dashboard Layout\", options=[\"Full\", \"Compact\"], group=groupLayout)\ndashboardCorner      = input.string(\"Bottom Right\", \"Dashboard Corner\", options=[\"Top Left\",\"Top Right\",\"Bottom Left\",\"Bottom Right\"], group=groupLayout)\nqaLayout             = input.string(\"Detailed\", \"QA Panel Layout\", options=[\"Summary\",\"Detailed\"], group=groupLayout)\nqaCornerOption       = input.string(\"Top Left\", \"QA Panel Corner\", options=[\"Top Left\",\"Top Right\",\"Bottom Left\",\"Bottom Right\"], group=groupLayout)\nintegrityCornerOption= input.string(\"Bottom Left\", \"Integrity Panel Corner\", options=[\"Top Left\",\"Top Right\",\"Bottom Left\",\"Bottom Right\"], group=groupLayout)\npanelOpacity         = input.int(70,            \"Panel Opacity (0-100)\", minval=0, maxval=100, step=5, group=groupLayout)\n\nconst color clrPanel          = color.rgb(15, 23, 48)\nconst color clrPanelSoft      = color.rgb(24, 36, 74)\nconst color clrAccent         = color.rgb(0, 149, 255)\nconst color clrAccentMuted    = color.rgb(72, 199, 180)\nconst color clrWarn           = color.rgb(255, 181, 64)\nconst color clrDanger         = color.rgb(255, 92, 115)\nconst color clrNeutral        = color.rgb(110, 120, 142)\nconst color clrBgSoft         = color.rgb(7, 12, 26)\n\npanelBgColor   = color.new(clrPanel, panelOpacity)\npanelSoftColor = color.new(clrPanelSoft, panelOpacity)\n\ngetPanelPosition(posText) =>\n    switch posText\n        \"Top Left\" => position.top_left\n        \"Top Right\" => position.top_right\n        \"Bottom Left\" => position.bottom_left\n        => position.bottom_right\n\nvar bool validationRan = false\nvar int validationPassed = 0\nvar int validationFailed = 0\nvar int validationTotal = 0\nvar float validationPassRate = na\nvar array<string> validationNames = array.new<string>()\nvar array<bool> validationResults = array.new<bool>()\nvar array<string> validationDescriptions = array.new<string>()\n\nvar table dash = na\nvar string dashCornerState = \"\"\nvar int dashRowsState = 0\nvar int dashOpacityState = na\n\nvar table qaTable = na\nvar string qaCornerState = \"\"\nvar int qaRowsState = 0\nvar string qaLayoutState = \"\"\nvar int qaOpacityState = na\n\nvar table integrityTable = na\nvar string integrityCornerState = \"\"\nvar int integrityOpacityState = na\n\nvar table validationDetailTable = na\nvar string validationDetailCornerState = \"\"\nvar int validationDetailOpacityState = na\n\nvalidationPush(testName, condition, description) =>\n    array.push(validationNames, testName)\n    array.push(validationResults, condition)\n    array.push(validationDescriptions, description)\n    condition\n\ntrackValidation(testName, condition, description) =>\n    flag = validationPush(testName, condition, description)\n    totalDelta = 1\n    passDelta = flag ? 1 : 0\n    failDelta = flag ? 0 : 1\n    [totalDelta, passDelta, failDelta]\n\nf_macd(srcSeries, fastLen, slowLen, signalLen) =>\n    _fast  = ta.ema(srcSeries, fastLen)\n    _slow  = ta.ema(srcSeries, slowLen)\n    _macd  = _fast - _slow\n    _sig   = ta.ema(_macd, signalLen)\n    _hist  = _macd - _sig\n    [_macd, _sig, _hist]\n\nf_atr(len) =>\n    ta.atr(len)\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// DATA SOURCES\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nstructureHigh = structureTf == \"\" ? high  : request.security(syminfo.tickerid, structureTf, high,  lookahead=barmerge.lookahead_off, gaps=barmerge.gaps_off)\nstructureLow  = structureTf == \"\" ? low   : request.security(syminfo.tickerid, structureTf, low,   lookahead=barmerge.lookahead_off, gaps=barmerge.gaps_off)\nstructureClose= structureTf == \"\" ? close : request.security(syminfo.tickerid, structureTf, close, lookahead=barmerge.lookahead_off, gaps=barmerge.gaps_off)\nmacdSource    = macdTf == \"\" ? priceSrc : request.security(syminfo.tickerid, macdTf, priceSrc, lookahead=barmerge.lookahead_off, gaps=barmerge.gaps_off)\natrSeries     = atrTf == \"\" ? f_atr(atrLen) : request.security(syminfo.tickerid, atrTf, ta.atr(atrLen), lookahead=barmerge.lookahead_off, gaps=barmerge.gaps_off)\natrReady      = not na(atrSeries)\natrFallback   = ta.atr(atrLen)\natrSafe       = atrReady ? atrSeries : atrFallback\n\n// guard ATR filter\nvolatilityOk  = atrReady ? (atrSafe >= minAtrFilter or minAtrFilter == 0.0) : false\n\n// volume & trend gating\nvolSma        = ta.sma(volume, volumeLookback)\nvolumeReady   = not enableVolumeGate or (not na(volSma) and volume > volSma * volumeThreshold)\nvolumeIntensity = not na(volSma) and volSma > 0 ? volume / volSma : 1.0\ntrendGuide    = ta.ema(priceSrc, trendGuideLen)\ntrendGuideBull= close > trendGuide\ntrendGuideBear= close < trendGuide\n\n// crypto impulse bias (optional)\nimpulseFast   = ta.ema(priceSrc, cryptoFastLen)\nimpulseSlow   = ta.ema(priceSrc, cryptoSlowLen)\ncryptoImpulse = impulseFast - impulseSlow\ncryptoBull    = cryptoImpulse > 0\ncryptoBear    = cryptoImpulse < 0\n\n// trade budget & cooldown\nvar int entriesToday = 0\nvar int trackedDay   = na\nvar int lastEntryBar = na\ncurrentDay           = int(math.floor(time / 86400000))\nif na(trackedDay)\n    trackedDay := currentDay\nif currentDay != trackedDay\n    entriesToday := 0\n    trackedDay := currentDay\ncooldownReady = na(lastEntryBar) or bar_index - lastEntryBar >= cooldownBars\ntradeBudgetOk = entriesToday < maxTradesPerDay\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// MARKET STRUCTURE ENGINE\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nvar float lastSwingHigh = na\nvar float lastSwingLow  = na\nvar float prevSwingHigh = na\nvar float prevSwingLow  = na\nvar int   structureBias = 0   // 1 bull, -1 bear, 0 neutral\n\npivHigh = ta.pivothigh(structureHigh, structureLeft, structureRight)\npivLow  = ta.pivotlow(structureLow, structureLeft, structureRight)\n\nif not na(pivHigh)\n    prevSwingHigh := lastSwingHigh\n    lastSwingHigh := pivHigh\n\nif not na(pivLow)\n    prevSwingLow := lastSwingLow\n    lastSwingLow := pivLow\n\nfloat bullThreshold = not na(lastSwingHigh) ? lastSwingHigh * (1.0 + structureBreakBuff) : na\nfloat bearThreshold = not na(lastSwingLow)  ? lastSwingLow  * (1.0 - structureBreakBuff) : na\n\nbullBreak      = not na(bullThreshold) and high > bullThreshold\nbearBreak      = not na(bearThreshold) and low  < bearThreshold\n\nbullBreakEvent = bullBreak and not bullBreak[1]\nbearBreakEvent = bearBreak and not bearBreak[1]\n\nbiasPrev       = structureBias\nbool bosBull   = false\nbool chochBull = false\nbool bosBear   = false\nbool chochBear = false\n\nif bullBreakEvent\n    chochBull := biasPrev <= 0\n    bosBull   := biasPrev == 1\n    structureBias := 1\n\nif bearBreakEvent\n    chochBear := biasPrev >= 0\n    bosBear   := biasPrev == -1\n    structureBias := -1\n\nmsBullish = chochBull or bosBull\nmsBearish = chochBear or bosBear\n\n// inducement proxy (distance to last violated liquidity pocket divided by ATR)\nliquidityMid = not na(lastSwingHigh) and not na(lastSwingLow) ? (lastSwingHigh + lastSwingLow) / 2.0 : na\nidmScore     = not na(atrSeries) and not na(liquidityMid) ? math.abs(close - liquidityMid) / atrSeries : na\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// MACD + TREND FILTERS\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n[macdLine, macdSignalLine, macdHist] = f_macd(macdSource, macdFast, macdSlow, macdSignal)\n[macdLineFusion, macdSignalFusion, macdHistFusion] = f_macd(macdSource, fusionFast, fusionSlow, fusionSignal)\n\nmacdBullCore = macdLine > macdSignalLine and macdLine > 0 and macdHist > macdHist[1]\nmacdBearCore = macdLine < macdSignalLine and macdLine < 0 and macdHist < macdHist[1]\nmacdBullFusion = macdLineFusion > macdSignalFusion and macdLineFusion > 0 and macdHistFusion > macdHistFusion[1]\nmacdBearFusion = macdLineFusion < macdSignalFusion and macdLineFusion < 0 and macdHistFusion < macdHistFusion[1]\n\nmacdBull = fusionEnabled ? (macdBullCore and macdBullFusion) : macdBullCore\nmacdBear = fusionEnabled ? (macdBearCore and macdBearFusion) : macdBearCore\n\nmomentumStrength = (math.abs(macdHist) + math.abs(macdHistFusion)) / 2.0\n\ndirectionalEma = ta.ema(priceSrc, biasEmaLen)\n\ntrendBull = close > directionalEma\ntrendBear = close < directionalEma\n\natrBaseline   = ta.sma(atrSafe, 14)\nvolScore      = atrBaseline > 0 ? math.min(math.max(atrSafe / atrBaseline, 0.0), 1.5) / 1.5 : 1.0\nvolumeScore   = enableVolumeGate ? math.min(math.max(volumeIntensity / volumeThreshold, 0.0), 1.5) / 1.5 : 1.0\nstructureScore= msBullish ? 1.0 : msBearish ? 0.0 : 0.5\nmomentumScore = macdBull ? 1.0 : macdBear ? 0.0 : 0.5\ntrendScore    = trendGuideBull ? 1.0 : trendGuideBear ? 0.0 : 0.5\nqualityScore  = (structureScore + momentumScore + trendScore + volScore + volumeScore) / 5.0\nqualityPass   = enableQualityGate ? qualityScore >= qualityThreshold : true\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// ENTRY CONDITIONS\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nexecutionReady = tradeBudgetOk and cooldownReady\ncryptoGateLong = not enableCryptoMode or cryptoBull\ncryptoGateShort= not enableCryptoMode or cryptoBear or not cryptoBull\n\nlongConditionBase  = atrReady and volatilityOk and msBullish and macdBull and trendBull and trendGuideBull and volumeReady and executionReady and qualityPass and cryptoGateLong\nshortConditionBase = atrReady and volatilityOk and msBearish and macdBear and trendBear and trendGuideBear and volumeReady and executionReady and qualityPass and cryptoGateShort\n\nlongCondition  = longConditionBase\nshortCondition = not longOnlyMode and shortConditionBase\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// RISK MANAGEMENT (SL / TP / TRAIL)\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nfloat longStop  = close - atrSafe * stopAtrMult\nfloat longLimit = close + atrSafe * tpAtrMult\nfloat shortStop = close + atrSafe * stopAtrMult\nfloat shortLimit= close - atrSafe * tpAtrMult\n\nvar float peakSinceEntry   = na\nvar float troughSinceEntry = na\nvar float trailLong        = na\nvar float trailShort       = na\n\nif strategy.position_size > 0\n    peakSinceEntry := na(peakSinceEntry) ? high : math.max(peakSinceEntry, high)\n    profitFromEntry = peakSinceEntry - strategy.position_avg_price\n    if profitFromEntry >= atrSafe * trailTriggerAtr\n        trailLong := peakSinceEntry - atrSafe * trailDistanceAtr\n    else\n        trailLong := na\nelse\n    peakSinceEntry := na\n    trailLong := na\n\nif strategy.position_size < 0\n    troughSinceEntry := na(troughSinceEntry) ? low : math.min(troughSinceEntry, low)\n    profitShort = strategy.position_avg_price - troughSinceEntry\n    if profitShort >= atrSafe * trailTriggerAtr\n        trailShort := troughSinceEntry + atrSafe * trailDistanceAtr\n    else\n        trailShort := na\nelse\n    troughSinceEntry := na\n    trailShort := na\n\nfloat protectiveLongStop  = na(trailLong)  ? longStop  : math.max(longStop,  trailLong)\nfloat protectiveShortStop = na(trailShort) ? shortStop : math.min(shortStop, trailShort)\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// ORDER EXECUTION\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nif longCondition and strategy.position_size <= 0\n    strategy.entry(\"ChronoLong\", strategy.long, comment=\"ChronoPulse Long\")\n\nif shortCondition and strategy.position_size >= 0\n    strategy.entry(\"ChronoShort\", strategy.short, comment=\"ChronoPulse Short\")\n\nstrategy.exit(\"ChronoLong Exit\",  from_entry=\"ChronoLong\", stop=protectiveLongStop,  limit=longLimit)\nstrategy.exit(\"ChronoShort Exit\", from_entry=\"ChronoShort\", stop=protectiveShortStop, limit=shortLimit)\n\n// safety: close on signal flip\nif strategy.position_size > 0 and shortCondition\n    strategy.close(\"ChronoLong\", comment=\"Signal Flip\")\n\nif strategy.position_size < 0 and longCondition\n    strategy.close(\"ChronoShort\", comment=\"Signal Flip\")\n\nenteredLong   = strategy.position_size > 0 and strategy.position_size[1] <= 0 and strategy.position_size != strategy.position_size[1]\nenteredShort  = strategy.position_size < 0 and strategy.position_size[1] >= 0 and strategy.position_size != strategy.position_size[1]\nenteredNew    = enteredLong or enteredShort\nif enteredNew\n    entriesToday += 1\n    lastEntryBar := bar_index\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// VISUALS\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nemaPlot = plot(directionalEma, \"Directional EMA\", color=color.new(color.orange, 0), linewidth=2)\nplot(trailLong,  \"Long Trail\",  color=color.new(color.green,  0), linewidth=1, style=plot.style_linebr)\nplot(trailShort, \"Short Trail\", color=color.new(color.red,    0), linewidth=1, style=plot.style_linebr)\n\nplotshape(chochBull, title=\"CHOCH Bull\", location=location.belowbar, color=color.new(color.green, 0), style=shape.labelup, text=\"CHOCHâ†‘\", textcolor=color.white, size=size.tiny, display=showStructureLabels ? display.all : display.none)\nplotshape(bosBull,   title=\"BOS Bull\",   location=location.belowbar, color=color.new(color.teal,  0), style=shape.labelup, text=\"BOSâ†‘\",   textcolor=color.white, size=size.tiny, display=showStructureLabels ? display.all : display.none)\nplotshape(chochBear, title=\"CHOCH Bear\", location=location.abovebar, color=color.new(color.red,   0), style=shape.labeldown, text=\"CHOCHâ†“\", textcolor=color.white, size=size.tiny, display=showStructureLabels ? display.all : display.none)\nplotshape(bosBear,   title=\"BOS Bear\",   location=location.abovebar, color=color.new(color.maroon,0), style=shape.labeldown, text=\"BOSâ†“\",   textcolor=color.white, size=size.tiny, display=showStructureLabels ? display.all : display.none)\n\n// diagnostic plots (hidden)\nplot(structureBias, \"Structure Bias\", color=structureBias >= 0 ? color.new(color.green, 70) : color.new(color.red, 70), display=display.none)\nplot(macdHist, \"MACD Histogram\", color=color.new(color.blue, 70), display=display.none)\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// DASHBOARD\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\ndashRows = dashboardLayout == \"Full\" ? 10 : 6\nif na(dash) or dashCornerState != dashboardCorner or dashRowsState != dashRows or dashOpacityState != panelOpacity\n    dash := table.new(getPanelPosition(dashboardCorner), 2, dashRows, border_width=1, bgcolor=panelBgColor)\n    dashCornerState := dashboardCorner\n    dashRowsState := dashRows\n    dashOpacityState := panelOpacity\n\nbiasText = structureBias == 1 ? \"Bullish\" : structureBias == -1 ? \"Bearish\" : \"Neutral\"\nmacdText = macdBull ? \"Fusion Bull\" : macdBear ? \"Fusion Bear\" : \"MACD Neutral\"\ntrailState = not na(trailLong) or not na(trailShort) ? \"Active\" : \"Armed\"\ncryptoText = enableCryptoMode ? (cryptoBull ? \"Bull Impulse\" : cryptoBear ? \"Bear Impulse\" : \"Flat\") : \"Off\"\ntfLabel = atrTf == \"\" ? \"Chart\" : atrTf\n\nif showDashboard and barstate.islastconfirmedhistory\n    for r = 0 to dashRows - 1\n        for c = 0 to 1\n            table.cell(dash, c, r, \"\", text_color=color.white, bgcolor=panelBgColor, text_size=size.tiny)\n\n    table.cell(dash, 0, 0, \"ChronoPulse Resonance\", text_color=color.red, bgcolor=panelSoftColor, text_size=size.small)\n\n    if dashboardLayout == \"Full\"\n        table.cell(dash, 0, 1, \"Structure\", text_color=color.white, bgcolor=panelSoftColor, text_size=size.tiny)\n        table.cell(dash, 1, 1, biasText, text_color=color.white, bgcolor=panelBgColor, text_size=size.tiny)\n        table.cell(dash, 0, 2, \"MACD State\", text_color=color.white, bgcolor=panelSoftColor, text_size=size.tiny)\n        table.cell(dash, 1, 2, macdText, text_color=color.white, bgcolor=panelBgColor, text_size=size.tiny)\n        table.cell(dash, 0, 3, \"ATR (TF)\", text_color=color.white, bgcolor=panelSoftColor, text_size=size.tiny)\n        table.cell(dash, 1, 3, str.tostring(atrSeries, format.mintick) + \" / \" + tfLabel, text_color=color.white, bgcolor=panelBgColor, text_size=size.tiny)\n        table.cell(dash, 0, 4, \"IDM Score\", text_color=color.white, bgcolor=panelSoftColor, text_size=size.tiny)\n        table.cell(dash, 1, 4, na(idmScore) ? \"n/a\" : str.tostring(idmScore, \"#.00\"), text_color=color.white, bgcolor=panelBgColor, text_size=size.tiny)\n        table.cell(dash, 0, 5, \"Trail\", text_color=color.white, bgcolor=panelSoftColor, text_size=size.tiny)\n        table.cell(dash, 1, 5, trailState, text_color=color.white, bgcolor=panelBgColor, text_size=size.tiny)\n        table.cell(dash, 0, 6, \"Volume Gate\", text_color=color.white, bgcolor=panelSoftColor, text_size=size.tiny)\n        table.cell(dash, 1, 6, volumeReady ? \"Live\" : \"Dormant\", text_color=color.white, bgcolor=color.new(volumeReady ? clrAccentMuted : clrWarn, panelOpacity), text_size=size.tiny)\n        table.cell(dash, 0, 7, \"Quality\", text_color=color.white, bgcolor=panelSoftColor, text_size=size.tiny)\n        table.cell(dash, 1, 7, str.tostring(qualityScore, \"#.00\"), text_color=color.white, bgcolor=color.new(qualityPass ? clrAccentMuted : clrDanger, panelOpacity), text_size=size.tiny)\n        table.cell(dash, 0, 8, \"Discipline\", text_color=color.white, bgcolor=panelSoftColor, text_size=size.tiny)\n        table.cell(dash, 1, 8, str.tostring(entriesToday) + \"/\" + str.tostring(maxTradesPerDay), text_color=color.white, bgcolor=color.new(executionReady ? clrAccentMuted : clrWarn, panelOpacity), text_size=size.tiny)\n        table.cell(dash, 0, 9, \"PnL\", text_color=color.white, bgcolor=panelSoftColor, text_size=size.tiny)\n        table.cell(dash, 1, 9, str.tostring(strategy.netprofit, \"#.0\"), text_color=color.white, bgcolor=color.new(strategy.netprofit >= 0 ? clrAccentMuted : clrDanger, panelOpacity), text_size=size.tiny)\n    else\n        table.cell(dash, 0, 1, \"Structure\", text_color=color.white, bgcolor=panelSoftColor, text_size=size.tiny)\n        table.cell(dash, 1, 1, biasText, text_color=color.white, bgcolor=panelBgColor, text_size=size.tiny)\n        table.cell(dash, 0, 2, \"MACD\", text_color=color.white, bgcolor=panelSoftColor, text_size=size.tiny)\n        table.cell(dash, 1, 2, macdText, text_color=color.white, bgcolor=panelBgColor, text_size=size.tiny)\n        table.cell(dash, 0, 3, \"ATR/TF\", text_color=color.white, bgcolor=panelSoftColor, text_size=size.tiny)\n        table.cell(dash, 1, 3, str.tostring(atrSeries, format.mintick) + \" / \" + tfLabel, text_color=color.white, bgcolor=panelBgColor, text_size=size.tiny)\n        table.cell(dash, 0, 4, \"Quality\", text_color=color.white, bgcolor=panelSoftColor, text_size=size.tiny)\n        table.cell(dash, 1, 4, str.tostring(qualityScore, \"#.00\"), text_color=color.white, bgcolor=color.new(qualityPass ? clrAccentMuted : clrDanger, panelOpacity), text_size=size.tiny)\n        table.cell(dash, 0, 5, \"PnL\", text_color=color.white, bgcolor=panelSoftColor, text_size=size.tiny)\n        table.cell(dash, 1, 5, str.tostring(strategy.netprofit, \"#.0\"), text_color=color.white, bgcolor=color.new(strategy.netprofit >= 0 ? clrAccentMuted : clrDanger, panelOpacity), text_size=size.tiny)\n\nwinRate         = strategy.closedtrades > 0 ? strategy.wintrades / strategy.closedtrades * 100 : na\nlossAbs         = math.abs(strategy.grossloss)\nprofitFactor    = lossAbs > 0 ? strategy.grossprofit / lossAbs : na\nqaStructure     = structureBias != 0\nqaMomentum      = macdBull or macdBear\nqaRisk          = atrReady and volatilityOk\nqaQualityMetric = qualityPass\nqaDiscipline    = executionReady\nqaPerformance   = strategy.closedtrades >= performanceMinTrades and not na(winRate) and winRate >= performanceWinTarget and not na(profitFactor) and profitFactor >= performancePfTarget and strategy.netprofit > 0\nqaScore         = ( (qaStructure ? 1.0 : 0.0) + (qaMomentum ? 1.0 : 0.0) + (qaRisk ? 1.0 : 0.0) + (qaQualityMetric ? 1.0 : 0.0) + (qaDiscipline ? 1.0 : 0.0) + (qaPerformance ? 1.0 : 0.0) ) / 6.0\nqaCertified     = qaScore >= qaMinScore and qaQualityMetric and qaRisk and qaPerformance\nqaWatch         = not qaCertified and qaScore >= qaMinScore * 0.9\nqaStatusText    = qaCertified ? \"CERTIFIED\" : qaWatch ? \"WATCH\" : \"BLOCK\"\nqaStatusColor   = qaCertified ? color.new(color.green, 0) : qaWatch ? color.new(color.orange, 0) : color.new(color.red, 0)\n\nqaRows = qaLayout == \"Detailed\" ? 8 : 4\nif na(qaTable) or qaCornerState != qaCornerOption or qaRowsState != qaRows or qaOpacityState != panelOpacity or qaLayoutState != qaLayout\n    qaTable := table.new(getPanelPosition(qaCornerOption), 3, qaRows, border_width=1, bgcolor=panelBgColor)\n    qaCornerState := qaCornerOption\n    qaRowsState := qaRows\n    qaOpacityState := panelOpacity\n    qaLayoutState := qaLayout\n\nif showQaConsole and barstate.islastconfirmedhistory\n    for r = 0 to qaRows - 1\n        for c = 0 to 2\n            table.cell(qaTable, c, r, \"\", text_color=color.white, bgcolor=panelBgColor, text_size=size.tiny)\n\n    table.cell(qaTable, 0, 0, \"Quality Assurance\", text_color=color.red, bgcolor=panelSoftColor, text_size=size.small)\n    table.cell(qaTable, 1, 0, qaStatusText, text_color=color.white, bgcolor=color.new(qaStatusColor, panelOpacity), text_size=size.small)\n    table.cell(qaTable, 2, 0, str.tostring(qaScore * 100.0, \"#.0\") + \"%\", text_color=color.white, bgcolor=panelSoftColor, text_size=size.small)\n\n    if qaLayout == \"Detailed\"\n        table.cell(qaTable, 0, 1, \"Structure\", text_color=color.white, bgcolor=panelSoftColor, text_size=size.tiny)\n        table.cell(qaTable, 1, 1, qaStructure ? \"âœ“\" : \"âœ—\", text_color=qaStructure ? clrAccentMuted : clrDanger, bgcolor=panelBgColor)\n        table.cell(qaTable, 2, 1, biasText, text_color=color.white, bgcolor=panelBgColor)\n\n        table.cell(qaTable, 0, 2, \"Momentum\", text_color=color.white, bgcolor=panelSoftColor, text_size=size.tiny)\n        table.cell(qaTable, 1, 2, qaMomentum ? \"âœ“\" : \"âœ—\", text_color=qaMomentum ? clrAccentMuted : clrDanger, bgcolor=panelBgColor)\n        table.cell(qaTable, 2, 2, str.tostring(momentumStrength, \"#.000\"), text_color=color.white, bgcolor=panelBgColor)\n\n        table.cell(qaTable, 0, 3, \"Volatility\", text_color=color.white, bgcolor=panelSoftColor, text_size=size.tiny)\n        table.cell(qaTable, 1, 3, qaRisk ? \"âœ“\" : \"âœ—\", text_color=qaRisk ? clrAccentMuted : clrDanger, bgcolor=panelBgColor)\n        table.cell(qaTable, 2, 3, str.tostring(atrSafe, format.mintick), text_color=color.white, bgcolor=panelBgColor)\n\n        table.cell(qaTable, 0, 4, \"Quality\", text_color=color.white, bgcolor=panelSoftColor, text_size=size.tiny)\n        table.cell(qaTable, 1, 4, qaQualityMetric ? \"âœ“\" : \"âœ—\", text_color=qaQualityMetric ? clrAccentMuted : clrDanger, bgcolor=panelBgColor)\n        table.cell(qaTable, 2, 4, str.tostring(qualityScore, \"#.00\"), text_color=color.white, bgcolor=panelBgColor)\n\n        table.cell(qaTable, 0, 5, \"Discipline\", text_color=color.white, bgcolor=panelSoftColor, text_size=size.tiny)\n        table.cell(qaTable, 1, 5, qaDiscipline ? \"âœ“\" : \"âœ—\", text_color=qaDiscipline ? clrAccentMuted : clrWarn, bgcolor=panelBgColor)\n        table.cell(qaTable, 2, 5, str.tostring(entriesToday) + \"/\" + str.tostring(maxTradesPerDay), text_color=color.white, bgcolor=panelBgColor)\n\n        table.cell(qaTable, 0, 6, \"Performance\", text_color=color.white, bgcolor=panelSoftColor, text_size=size.tiny)\n        table.cell(qaTable, 1, 6, qaPerformance ? \"âœ“\" : \"âœ—\", text_color=qaPerformance ? clrAccentMuted : clrDanger, bgcolor=panelBgColor)\n        perfText = (na(winRate) or na(profitFactor)) ? \"n/a\" : str.tostring(winRate, \"#.0\") + \"% / PF \" + str.tostring(profitFactor, \"#.00\")\n        table.cell(qaTable, 2, 6, perfText, text_color=color.white, bgcolor=panelBgColor)\n\n        table.cell(qaTable, 0, 7, \"Net PnL\", text_color=color.white, bgcolor=panelSoftColor, text_size=size.tiny)\n        table.cell(qaTable, 1, 7, strategy.netprofit >= 0 ? \"POS\" : \"NEG\", text_color=strategy.netprofit >= 0 ? clrAccentMuted : clrDanger, bgcolor=panelBgColor)\n        table.cell(qaTable, 2, 7, str.tostring(strategy.netprofit, \"#.0\"), text_color=color.white, bgcolor=panelBgColor)\n    else\n        table.cell(qaTable, 0, 1, \"Structure\", text_color=color.white, bgcolor=panelSoftColor, text_size=size.tiny)\n        table.cell(qaTable, 1, 1, biasText, text_color=color.white, bgcolor=panelBgColor, text_size=size.tiny)\n        table.cell(qaTable, 2, 1, str.tostring(momentumStrength, \"#.000\"), text_color=color.white, bgcolor=panelBgColor, text_size=size.tiny)\n\n        table.cell(qaTable, 0, 2, \"Vol / Qual\", text_color=color.white, bgcolor=panelSoftColor, text_size=size.tiny)\n        volQualText = str.tostring(atrSafe, format.mintick) + \" | \" + str.tostring(qualityScore, \"#.00\")\n        table.cell(qaTable, 1, 2, volQualText, text_color=color.white, bgcolor=panelBgColor, text_size=size.tiny)\n        table.cell(qaTable, 2, 2, str.tostring(entriesToday) + \"/\" + str.tostring(maxTradesPerDay), text_color=color.white, bgcolor=panelBgColor, text_size=size.tiny)\n\n        table.cell(qaTable, 0, 3, \"Performance\", text_color=color.white, bgcolor=panelSoftColor, text_size=size.tiny)\n        compactPerf = (na(winRate) or na(profitFactor)) ? \"n/a\" : str.tostring(winRate, \"#.0\") + \"% | PF \" + str.tostring(profitFactor, \"#.00\")\n        table.cell(qaTable, 1, 3, compactPerf, text_color=color.white, bgcolor=panelBgColor, text_size=size.tiny)\n        table.cell(qaTable, 2, 3, str.tostring(strategy.netprofit, \"#.0\"), text_color=color.white, bgcolor=panelBgColor, text_size=size.tiny)\n\nif not validationRan and validationMode != \"Off\" and barstate.islastconfirmedhistory\n    validationRan := true\n    array.clear(validationNames)\n    array.clear(validationResults)\n    array.clear(validationDescriptions)\n    validationPassed := 0\n    validationFailed := 0\n    validationTotal := 0\n\n    [totDelta0, passDelta0, failDelta0] = trackValidation(\"CFG_RANGE\", structureLeft >= 1 and structureRight >= 1 and structureLeft <= structureRight, \"Structure pivot range logical\")\n    validationTotal += totDelta0\n    validationPassed += passDelta0\n    validationFailed += failDelta0\n\n    [totDelta1, passDelta1, failDelta1] = trackValidation(\"RISK_SPAN\", stopAtrMult > 0 and tpAtrMult > stopAtrMult, \"TP exceeds SL distance\")\n    validationTotal += totDelta1\n    validationPassed += passDelta1\n    validationFailed += failDelta1\n\n    [totDelta2, passDelta2, failDelta2] = trackValidation(\"ATR_READY\", atrReady and atrSafe > 0, \"ATR feed initialized\")\n    validationTotal += totDelta2\n    validationPassed += passDelta2\n    validationFailed += failDelta2\n\n    [totDelta3, passDelta3, failDelta3] = trackValidation(\"VOL_GATE\", not enableVolumeGate or (volumeLookback >= 5 and volumeThreshold >= 1.0), \"Volume filter configured\")\n    validationTotal += totDelta3\n    validationPassed += passDelta3\n    validationFailed += failDelta3\n\n    [totDelta4, passDelta4, failDelta4] = trackValidation(\"QUALITY_BOUNDS\", not enableQualityGate or (qualityThreshold >= 0.4 and qualityThreshold <= 0.95), \"Quality threshold sane\")\n    validationTotal += totDelta4\n    validationPassed += passDelta4\n    validationFailed += failDelta4\n\n    [totDelta5, passDelta5, failDelta5] = trackValidation(\"DISCIPLINE\", maxTradesPerDay > 0 and cooldownBars >= 0, \"Trade budget + cooldown valid\")\n    validationTotal += totDelta5\n    validationPassed += passDelta5\n    validationFailed += failDelta5\n\n    [totDelta6, passDelta6, failDelta6] = trackValidation(\"CRYPTO_IMP\", not enableCryptoMode or cryptoSlowLen > cryptoFastLen, \"Impulse EMA hierarchy valid\")\n    validationTotal += totDelta6\n    validationPassed += passDelta6\n    validationFailed += failDelta6\n\n    [totDelta7, passDelta7, failDelta7] = trackValidation(\"QA_SCORE\", qaScore >= qaMinScore * 0.75, \"QA score trending towards threshold\")\n    validationTotal += totDelta7\n    validationPassed += passDelta7\n    validationFailed += failDelta7\n\n    if validationMode == \"Enhanced\"\n        [totDelta8, passDelta8, failDelta8] = trackValidation(\"REALISM_WIN\", na(winRate) or winRate <= 95, \"Win-rate realism check\")\n        validationTotal += totDelta8\n        validationPassed += passDelta8\n        validationFailed += failDelta8\n\n        [totDelta9, passDelta9, failDelta9] = trackValidation(\"REALISM_PF\", na(profitFactor) or profitFactor <= 6, \"Profit factor realism check\")\n        validationTotal += totDelta9\n        validationPassed += passDelta9\n        validationFailed += failDelta9\n\n        [totDelta10, passDelta10, failDelta10] = trackValidation(\"PERF_DEPTH\", strategy.closedtrades >= math.min(performanceMinTrades, 10), \"Minimum trade depth achieved\")\n        validationTotal += totDelta10\n        validationPassed += passDelta10\n        validationFailed += failDelta10\n\n    validationPassRate := validationTotal > 0 ? (validationPassed / validationTotal) * 100.0 : na\n\nvalidationGate = validationMode == \"Enhanced\" ? 95.0 : 90.0\nvalidationStatus = validationPassRate >= validationGate ? \"PASS\" : \"REVIEW\"\nvalidationColor = validationPassRate >= validationGate ? clrAccentMuted : clrWarn\n\nif showValidationPanel and validationMode != \"Off\" and validationRan and barstate.islastconfirmedhistory\n    if na(integrityTable) or integrityCornerState != integrityCornerOption or integrityOpacityState != panelOpacity\n        integrityTable := table.new(getPanelPosition(integrityCornerOption), 2, 4, border_width=1, bgcolor=panelBgColor)\n        integrityCornerState := integrityCornerOption\n        integrityOpacityState := panelOpacity\n\n    for r = 0 to 3\n        for c = 0 to 1\n            table.cell(integrityTable, c, r, \"\", text_color=color.white, bgcolor=panelBgColor, text_size=size.tiny)\n\n    table.cell(integrityTable, 0, 0, \"Integrity Suite\", text_color=color.red, bgcolor=panelSoftColor, text_size=size.small)\n    table.cell(integrityTable, 1, 0, validationStatus, text_color=color.white, bgcolor=color.new(validationColor, panelOpacity), text_size=size.small)\n\n    table.cell(integrityTable, 0, 1, \"Total\", text_color=color.white, bgcolor=panelSoftColor, text_size=size.tiny)\n    table.cell(integrityTable, 1, 1, str.tostring(validationTotal), text_color=color.white, bgcolor=panelBgColor, text_size=size.tiny)\n\n    table.cell(integrityTable, 0, 2, \"Passed\", text_color=color.white, bgcolor=panelSoftColor, text_size=size.tiny)\n    table.cell(integrityTable, 1, 2, str.tostring(validationPassed), text_color=clrAccentMuted, bgcolor=panelBgColor, text_size=size.tiny)\n\n    table.cell(integrityTable, 0, 3, \"Pass Rate\", text_color=color.white, bgcolor=panelSoftColor, text_size=size.tiny)\n    table.cell(integrityTable, 1, 3, na(validationPassRate) ? \"n/a\" : str.tostring(validationPassRate, \"#.0\") + \"%\", text_color=color.white, bgcolor=panelBgColor, text_size=size.tiny)\n\nif showValidationDetail and validationMode != \"Off\" and validationRan and barstate.islastconfirmedhistory\n    if na(validationDetailTable) or validationDetailOpacityState != panelOpacity\n        validationDetailTable := table.new(position.middle_right, 3, 25, border_width=1, bgcolor=panelBgColor)\n        validationDetailOpacityState := panelOpacity\n    for r = 0 to 24\n        for c = 0 to 2\n            table.cell(validationDetailTable, c, r, \"\", text_color=color.white, bgcolor=panelBgColor, text_size=size.tiny)\n    table.cell(validationDetailTable, 0, 0, \"Test\", text_color=color.white, bgcolor=panelSoftColor, text_size=size.small)\n    table.cell(validationDetailTable, 1, 0, \"Status\", text_color=color.white, bgcolor=panelSoftColor, text_size=size.small)\n    table.cell(validationDetailTable, 2, 0, \"Description\", text_color=color.white, bgcolor=panelSoftColor, text_size=size.small)\n    for i = 0 to array.size(validationNames) - 1\n        status = array.get(validationResults, i)\n        desc = array.get(validationDescriptions, i)\n        name = array.get(validationNames, i)\n        table.cell(validationDetailTable, 0, i + 1, name, text_color=color.white, bgcolor=panelBgColor, text_size=size.tiny)\n        table.cell(validationDetailTable, 1, i + 1, status ? \"PASS\" : \"FAIL\", text_color=status ? clrAccentMuted : clrDanger, bgcolor=panelBgColor, text_size=size.tiny)\n        table.cell(validationDetailTable, 2, i + 1, desc, text_color=clrNeutral, bgcolor=panelBgColor, text_size=size.tiny)\nelse if not na(validationDetailTable)\n    table.cell(validationDetailTable, 0, 0, \"Detail Panel Off\", text_color=color.white, bgcolor=panelSoftColor, text_size=size.small)\n    for r = 1 to 24\n        table.cell(validationDetailTable, 0, r, \"\", text_color=color.white, bgcolor=panelBgColor, text_size=size.tiny)\n        table.cell(validationDetailTable, 1, r, \"\", text_color=color.white, bgcolor=panelBgColor, text_size=size.tiny)\n        table.cell(validationDetailTable, 2, r, \"\", text_color=color.white, bgcolor=panelBgColor, text_size=size.tiny)\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// ALERTS\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nalertcondition(longCondition,  title=\"ChronoPulse Long Setup\",  message=\"ChronoPulse: bullish structure + MACD confluence detected. Prepare long entry.\")\nalertcondition(shortCondition, title=\"ChronoPulse Short Setup\", message=\"ChronoPulse: bearish structure + MACD confluence detected. Prepare short entry.\")\nalertcondition(qaCertified,    title=\"ChronoPulse QA Certification\", message=\"Quality Assurance console just printed CERTIFIED. All systems green.\")\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// NOTES & SAFEGUARDS\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nvar label deploymentLabel = na\nif barstate.islast\n    verdict = longCondition ? \"Bullish Opportunity\" : shortCondition ? \"Bearish Opportunity\" : \"Waiting\"\n    verdictColor = longCondition ? color.new(color.green, 0) : shortCondition ? color.new(color.red, 0) : color.new(color.orange, 0)\n    if na(deploymentLabel)\n        deploymentLabel := label.new(bar_index, high, text=\"\", style=label.style_label_left, textcolor=color.white, color=verdictColor)\n    label.set_xy(deploymentLabel, bar_index, high)\n    label.set_text(deploymentLabel, \"ChronoPulse Status:\\n\" + verdict + \"\\nStructure: \" + biasText + \"\\nMACD: \" + macdText + \"\\nQA: \" + qaStatusText + \" (\" + str.tostring(qaScore * 100.0, \"#.0\") + \"%)\")\n    label.set_color(deploymentLabel, qaCertified ? color.new(color.green, 0) : verdictColor)\n\n"
  },
  {
    "url": "Hi0gI790-ATR-ZigZag-Breakout",
    "name": "ATR ZigZag Breakout",
    "description": "ATR ZigZag Breakout \n\nThis strategy uses my  ATR ZigZag  indicator (powered by the  ZigZagCore  library) to scalp breakouts at volatility-filtered highs and lows.\n\nEveryone knows stops cluster around clear swing highs and lows. Breakout traders often pile in there, too. These levels are predictable areas where aggressive orders hit the tape. The idea here is simple:\n\nâ†’ Let ATR ZigZag define clean, volatility-filtered pivots\nâ†’ Arm a stop market order at those pivots\nâ†’ Join the breakout when the crowd hits the level\n\nThe key to greater success in this simple strategy lies in the ZigZag. Because the pivots are filtered by ATR instead of fixed bar counts or fractals, the levels tend to be more meaningful and less noisy.\n\nThis approach is especially suited for intraday trading on volatile instruments (e.g., NQ, GC, liquid crypto pairs).\n\n How It Works \n\n 1. Pivot detection \nThe ATR ZigZag uses an ATR-based threshold to confirm swing highs and lows. Only when price has moved far enough in the opposite direction does a pivot become â€œofficial.â€\n\n 2. Candidate breakout level \nWhen a new swing direction is detected and the most recent high/low has not yet been broken in the current leg, the strategy arms a stop market order at that pivot.\nâ€¢ Long candidate â†’ most recent swing high\nâ€¢ Short candidate â†’ most recent swing low\n\nThese â€œcandidate tradesâ€ are shown as dotted lines.\n\n 3. Entry, SL, and TP \nIf price breaks through the level, the stop order is filled and a bracket is placed:\nâ€¢ Stop loss = ATR Ã— SL multiplier\nâ€¢ Take profit = SL distance Ã— RR multiplier\n\nOnce a level has traded, it is not reused in the same swing leg.\n\n 4. Cancel & rotate \nIf the market reverses and forms a new swing in the opposite direction before the level is hit, the pending order is cancelled and a new candidate is considered in the new direction.\n\n Additional Features \nâ€¢ Optional session filter for backtesting specific trading hours",
    "image_url": "Hi0gI790",
    "author": "ReflexSignals",
    "likes": 58,
    "type": "strategy",
    "created": "2025-12-08",
    "updated": "2025-12-08",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// Â© ReflexSignals\r\n\r\n//@version=6\r\nstrategy(\r\n     \"ATR ZigZag Breakout\",\r\n     overlay                 = true,\r\n     initial_capital         = 50000,\r\n     margin_long             = 0,\r\n     margin_short            = 0,\r\n     calc_on_every_tick      = true,\r\n     process_orders_on_close = false,\r\n     pyramiding              = 0,\r\n     max_lines_count         = 500,\r\n     max_boxes_count         = 50)\r\n\r\nimport ReflexSignals/ZigZagCore/2 as zz\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Inputs\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nint   zzAtrLen   = input.int(50,  \"ZZ ATR Length\", minval = 1)\r\nfloat zzAtrMult  = input.float(3.0, \"ZZ ATR Mult\", minval = 0.1, step = 0.1)\r\n\r\nfloat slAtr      = input.float(1.0, \"Stop ATR (x)\",   minval = 0.1, step = 0.1)\r\nfloat rrMult     = input.float(2.0, \"RR Mult (x SL)\", minval = 0.1, step = 0.1)\r\n\r\nbool   enableTradingWindow = input.bool(true,  \"Enable Trading Window\")\r\nstring tradingWindow       = input.session(\"0930-1600\", \"Trading Window\")\r\n\r\nbool showCandidateTrades = input.bool(true, \"Show Candidate Trades\")\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Core engine: ATR + ZigZagCore\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nfloat atrVal = ta.atr(zzAtrLen)\r\nfloat thr    = atrVal * zzAtrMult\r\n\r\nvar zz.ZzState state = zz.zz_new()\r\nstate := zz.zz_update(state, thr)\r\n\r\n// Shorthands from state\r\nint   dir          = state.dir\r\nbool  isNewHigh    = state.isNewHigh\r\nbool  isNewLow     = state.isNewLow\r\n\r\nfloat lastHighLevel = state.lastHighLevel\r\nfloat lastLowLevel  = state.lastLowLevel\r\nint   lastHighIndex = state.lastHighIndex\r\nint   lastLowIndex  = state.lastLowIndex\r\n\r\nbool  highBroken    = state.highBroken\r\nbool  lowBroken     = state.lowBroken\r\n\r\n// Base breakout conditions from ZigZag structure\r\nbool baseLongRaw  = dir ==  1 and not highBroken and not isNewLow\r\nbool baseShortRaw = dir == -1 and not lowBroken  and not isNewHigh\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Strategy logic: window, entries, exits\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nbool inTradingWindow = not enableTradingWindow or (time(timeframe.period, tradingWindow) != 0)\r\n\r\nvar float longSL  = na\r\nvar float longTP  = na\r\nvar float shortSL = na\r\nvar float shortTP = na\r\n\r\n// Active trade state: entry level & side\r\nvar float activeEntry = na\r\nvar int   activeSide  = 0          // 1 long, -1 short, 0 none\r\n\r\nbool baseLong  = baseLongRaw  and inTradingWindow\r\nbool baseShort = baseShortRaw and inTradingWindow\r\n\r\n// Cancel opposite-side pending orders when direction flips\r\nif dir == 1\r\n    strategy.cancel(\"Short\")\r\nif dir == -1\r\n    strategy.cancel(\"Long\")\r\n\r\n// Entries and exits (stop-market at ZZ levels, ATR SL/TP)\r\nif strategy.position_size == 0 and inTradingWindow\r\n    if baseLong and not na(lastHighLevel)\r\n        float entryPriceL = lastHighLevel\r\n        float slDistL     = slAtr * atrVal\r\n        longSL := entryPriceL - slDistL\r\n        longTP := entryPriceL + rrMult * slDistL\r\n\r\n        strategy.entry(\"Long\", strategy.long, stop = entryPriceL)\r\n        strategy.exit(\"Long Exit\", from_entry = \"Long\", stop = longSL, limit = longTP)\r\n\r\n        activeEntry := entryPriceL\r\n        activeSide  := 1\r\n\r\n    else if baseShort and not na(lastLowLevel)\r\n        float entryPriceS = lastLowLevel\r\n        float slDistS     = slAtr * atrVal\r\n        shortSL := entryPriceS + slDistS\r\n        shortTP := entryPriceS - rrMult * slDistS\r\n\r\n        strategy.entry(\"Short\", strategy.short, stop = entryPriceS)\r\n        strategy.exit(\"Short Exit\", from_entry = \"Short\", stop = shortSL, limit = shortTP)\r\n\r\n        activeEntry := entryPriceS\r\n        activeSide  := -1\r\n\r\n// Clear active entry when flat again\r\nif strategy.position_size == 0 and strategy.position_size[1] != 0\r\n    activeEntry := na\r\n    activeSide  := 0\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Visualization: candidate level + TP/SL bands\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nbool watchLongCond  = showCandidateTrades and strategy.position_size == 0 and inTradingWindow and baseLongRaw\r\nbool watchShortCond = showCandidateTrades and strategy.position_size == 0 and inTradingWindow and baseShortRaw\r\n\r\nplot(\r\n     watchLongCond ? lastHighLevel : na,\r\n     title     = \"Candidate Long\",\r\n     color     = color.new(color.green, 40),\r\n     style     = plot.style_linebr,\r\n     linestyle = plot.linestyle_dotted,\r\n     linewidth = 1\r\n)\r\n\r\nplot(\r\n     watchShortCond ? lastLowLevel : na,\r\n     title     = \"Candidate Short\",\r\n     color     = color.new(color.red, 40),\r\n     style     = plot.style_linebr,\r\n     linestyle = plot.linestyle_dotted,\r\n     linewidth = 1\r\n)\r\n\r\nbool inLong  = strategy.position_size > 0\r\nbool inShort = strategy.position_size < 0\r\n\r\npLongSL = plot(\r\n     inLong ? longSL : na,\r\n     color     = color.new(color.red, 0),\r\n     style     = plot.style_linebr,\r\n     linewidth = 1)\r\n\r\npLongTP = plot(\r\n     inLong ? longTP : na,\r\n     color     = color.new(color.green, 0),\r\n     style     = plot.style_linebr,\r\n     linewidth = 1)\r\n\r\npLongEntry = plot(\r\n     inLong ? activeEntry : na,\r\n     color     = color.new(color.blue, 0),\r\n     style     = plot.style_linebr,\r\n     linewidth = 1)\r\n\r\npShortSL = plot(\r\n     inShort ? shortSL : na,\r\n     color     = color.new(color.red, 0),\r\n     style     = plot.style_linebr,\r\n     linewidth = 1)\r\n\r\npShortTP = plot(\r\n     inShort ? shortTP : na,\r\n     color     = color.new(color.green, 0),\r\n     style     = plot.style_linebr,\r\n     linewidth = 1)\r\n\r\npShortEntry = plot(\r\n     inShort ? activeEntry : na,\r\n     color     = color.new(color.blue, 0),\r\n     style     = plot.style_linebr,\r\n     linewidth = 1)\r\n\r\nfill(pLongSL, pLongEntry,  color = color.new(color.red,   80))\r\nfill(pLongEntry, pLongTP,  color = color.new(color.green, 80))\r\nfill(pShortEntry, pShortSL, color = color.new(color.red,   80))\r\nfill(pShortEntry, pShortTP, color = color.new(color.green, 80))"
  },
  {
    "url": "IrQyO2MG-Reversal-Wave",
    "name": "Reversal Wave",
    "description": "This is the type of quantitative system that can get you hated on investment forums, now that the Random Walk Theory is back in fashion. The strategy has simple price action rules, zero over-optimization, and is validated by a historical record of nearly a century on both Gold and the S&P 500 index.\n\n\n Recommended Markets \n\nSPX (Weekly, Monthly)\nSPY (Monthly)\nTesla (Weekly)\nXAUUSD (Weekly, Monthly)\nNVDA (Weekly, Monthly)\nMeta (Weekly, Monthly)\nGOOG (Weekly, Monthly)\nMSFT (Weekly, Monthly)\nAAPL (Weekly, Monthly)\n\n \nSystem Rules and Parameters \n\n Total capital: $10,000\nWe will use 10% of the total capital per trade\nCommissions will be 0.1% per trade \n\n Condition 1:  Previous Bearish Candle (isPrevBearish) (the closing price was lower than the opening price).\n\n Condition 2:  Midpoint of the Body The script calculates the exact midpoint of the body of that previous bearish candle.\n\n â€¢ Formula:  (Previous Open + Previous Close) / 2. \n\n Condition 3:  50% Recovery (longCondition) The current candle must be bullish (green) and, most importantly, its closing price must be above the midpoint calculated in the previous step.\n\nOnce these parameters are met, the system executes a long entry and calculates the exit parameters:\n\n Stop Loss (SL):  Placed at the low of the candle that generated the entry signal.\n\n Take Profit (TP):  Calculated by projecting the risk distance upward.\n\n â€¢ Calculation:  Entry Price + (Risk * 1).\n\nRisk:Reward Ratio of 1:1.\n\n\n About the Profit Factor \n\nIn my experience, TradingView calculates profits and losses based on the percentage of movement, which can cause returns to not match expectations. This doesnâ€™t significantly affect trending systems, but it can impact systems with a high win rate and a well-defined risk-reward ratio. It only takes one large entry candle that triggers the SL to translate into a major drop in performance.\n\nFor example, you might see a system with a 60% win rate and a 1:1 risk-reward ratio generating losses, even though commissions are under control relative to the number of trades.\n\nMy recommendation is to manually calculate the performance of systems with a well-defined risk-reward ratio, assuming you will trade using a fixed amount per trade and limit losses to a fixed percentage.\n\nRemember that, even if candles are larger or smaller in size, we can maintain a fixed loss percentage by using leverage (in cases of low volatility) or reducing the capital at risk (when volatility is high).\n\nImplementing leverage or capital reduction based on volatility is something I havenâ€™t been able to incorporate into the code, but it would undoubtedly improve the systemâ€™s performance dramatically, as it would fix a consistent loss percentage per trade, preventing losses from fluctuating with volatility swings.\n\nFor example, we can maintain a fixed loss percentage when volatility is low by using the following formula:\n \nLeverage = % of SL youâ€™re willing to risk / % volatility from entry point to exit or SL \n\nAnd if volatility is high and exceeds the fixed percentage we want to expose per trade (if SL is hit), we could reduce the position size.\n\nFor example, imagine we only want to risk 15% per SL on Tesla, where volatility is high and would cause a 23.57% loss. In this case, we subtract 23.57% from 15% (the loss percentage weâ€™re willing to accept per trade), then subtract the result from our usual position size.\n\n23.57% - 15% = 8.57%\n\nSuppose I use $200 per trade.\n\nTo calculate 8.57% of $200, simply multiply 200 by 8.57/100. This simple calculation shows that 8.57% equals about $17.14 of the $200. Then subtract that value from $200:\n\n$200 - $17.14 = $182.86\n\nIn summary, if we reduced the position size to $182.86 (from the usual $200, where weâ€™re willing to lose 15%), no matter whether Tesla moves up or down 23.57%, we would still only gain or lose 15% of the $200, thus respecting our risk management.\n\n Final Notes \n\nThe code is extremely simple, and every step of its development is detailed within it.\n\nIf you liked this strategy, which complements very well with others Iâ€™ve already published, stay tuned. Best regards.\n\n\n\n\n\n\n",
    "image_url": "IrQyO2MG",
    "author": "OldWave96",
    "likes": 29,
    "type": "strategy",
    "created": "2025-12-08",
    "updated": "2025-12-08",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// Â© Especulador96\r\n\r\n//@version=5\r\nstrategy(\"Reversal Wave\", overlay=true, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=10, commission_type=strategy.commission.percent, commission_value=0.1)\r\n\r\n// --- LOGIC DEFINITION ---\r\n\r\n// 1. Identify previous bearish candle\r\n// Define the midpoint of the previous candle's BODY ((Open + Close) / 2)\r\nprevOpen = open[1]\r\nprevClose = close[1]\r\nisPrevBearish = prevClose < prevOpen\r\nprevBodyMidpoint = (prevOpen + prevClose) / 2\r\n\r\n// 2. Identify current bullish candle\r\nisCurrBullish = close > open\r\n\r\n// 3. Entry Condition\r\n// The current candle is bullish AND closes above the midpoint of the previous bearish one\r\nlongCondition = isPrevBearish and isCurrBullish and (close > prevBodyMidpoint)\r\n\r\n// --- POSITION MANAGEMENT (SL and TP) ---\r\n\r\n// Variables to store SL and TP prices for the current trade\r\nvar float entryPrice = na\r\nvar float slPrice = na\r\nvar float tpPrice = na\r\n\r\nif (longCondition and strategy.position_size == 0)\r\n    // Set SL at the low of the current candle (the signal candle)\r\n    slPrice := low\r\n    // Estimated entry price is the close of this candle (or open of the next)\r\n    entryPrice := close\r\n    \r\n    // Calculate risk distance\r\n    float risk = entryPrice - slPrice\r\n    \r\n    // TP with 1:1 Ratio\r\n    tpPrice := entryPrice + (risk * 1)\r\n    \r\n    // Execute the order\r\n    strategy.entry(\"Long\", strategy.long)\r\n\r\n// If we are currently in a position, send conditional exit orders\r\nif (strategy.position_size > 0)\r\n    strategy.exit(\"Long Exit\", \"Long\", stop=slPrice, limit=tpPrice)\r\n\r\n// --- VISUALIZATION ---\r\n\r\n// Paint the background green when there is an entry signal\r\nbgcolor(longCondition ? color.new(color.green, 90) : na)\r\n\r\n// Plot SL and TP lines when a position is open\r\nplot(strategy.position_size > 0 ? slPrice : na, \"Stop Loss\", color=color.red, style=plot.style_linebr)\r\nplot(strategy.position_size > 0 ? tpPrice : na, \"Take Profit\", color=color.green, style=plot.style_linebr)"
  },
  {
    "url": "5M78HLhb-XAUUSD-1m-SMC-Zones-BOS-Flexible-TP-Modes-Trailing-Runner",
    "name": "XAUUSD 1m SMC Zones (BOS + Flexible TP Modes + Trailing Runner)",
    "description": "//@version=6\nstrategy(\"XAUUSD 1m SMC Zones (BOS + Flexible TP Modes + Trailing Runner)\",\n     overlay = true,\n     initial_capital = 10000,\n     pyramiding = 10,\n     process_orders_on_close = true)\n\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n// 1. INPUTS\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n// TP / SL\ntp1Pips      = input.int(10, \"TP1 (pips)\", minval = 1)\nfixedSLpips  = input.int(50, \"Fixed SL (pips)\", minval = 5)\nrunnerRR     = input.float(3.0, \"Runner RR (TP2 = SL * RR)\", step = 0.1, minval = 1.0)\n\n// Daily risk\nmaxDailyLossPct   = input.float(5.0,  \"Max daily loss % (stop trading)\",   step = 0.5)\nmaxDailyProfitPct = input.float(20.0, \"Max daily profit % (stop trading)\", step = 1.0)\n\n// HTF S/R (1H)\nhtfTF = input.string(\"60\", \"HTF timeframe (minutes) for S/R block\")\n\n// Profit strategy (Option C)\nprofitStrategy = input.string(\"Minimal Risk | Full BE after TP1\", \"Profit Strategy\", options =  )\n\n// Runner stop mode (your option 4)\nrunnerStopMode = input.string( \"BE only\", \"Runner Stop Mode\", options =  )\n\n// ATR trail settings (only used if ATR mode selected)\natrTrailLen  = input.int(14, \"ATR Length (trail)\", minval = 1)\natrTrailMult = input.float(1.0, \"ATR Multiplier (trail)\", step = 0.1, minval = 0.1)\n\n// Pip size (for XAUUSD: 1 pip = 0.10 if tick = 0.01)\npipSize   = syminfo.mintick * 10.0\ntp1Points = tp1Pips * pipSize\nslPoints  = fixedSLpips * pipSize\n\nbaseQty = input.float (1.0, \"Base order size\" , step = 0.01, minval = 0.01)\n\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n// 2. DAILY RISK MANAGEMENT\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nisNewDay = ta.change(time(\"D\")) != 0\n\nvar float dayStartEquity = na\nvar bool  dailyStopped   = false\n\nequityNow = strategy.initial_capital + strategy.netprofit\n\nif isNewDay or na(dayStartEquity)\n    dayStartEquity := equityNow\n    dailyStopped   := false\n\ndailyPnL    = equityNow - dayStartEquity\ndailyPnLPct = dayStartEquity != 0 ? (dailyPnL / dayStartEquity) * 100.0 : 0.0\n\nif not dailyStopped\n    if dailyPnLPct <= -maxDailyLossPct\n        dailyStopped := true\n    if dailyPnLPct >= maxDailyProfitPct\n        dailyStopped := true\n\ncanTradeToday = not dailyStopped\n\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n// 3. 1H S/R ZONES (for direction block)\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nhtOpen  = request.security(syminfo.tickerid, htfTF, open)\nhtHigh  = request.security(syminfo.tickerid, htfTF, high)\nhtLow   = request.security(syminfo.tickerid, htfTF, low)\nhtClose = request.security(syminfo.tickerid, htfTF, close)\n\n// Engulf logic on HTF\nhtBullPrev = htClose  > htOpen \nhtBearPrev = htClose  < htOpen \n\nhtBearEngulf = htClose < htOpen and htBullPrev and htOpen >= htClose  and htClose <= htOpen \nhtBullEngulf = htClose > htOpen and htBearPrev and htOpen <= htClose  and htClose >= htOpen \n\n// Liquidity sweep on HTF previous candle\nhtSweepHigh = htHigh  > ta.highest(htHigh, 5) \nhtSweepLow  = htLow   < ta.lowest(htLow, 5) \n\n// Store last HTF zones\nvar float htResHigh = na\nvar float htResLow  = na\nvar float htSupHigh = na\nvar float htSupLow  = na\n\nif htBearEngulf and htSweepHigh\n    htResHigh := htHigh \n    htResLow  := htLow \n\nif htBullEngulf and htSweepLow\n    htSupHigh := htHigh \n    htSupLow  := htLow \n\n// Are we inside HTF zones?\ninHtfRes = not na(htResHigh) and close <= htResHigh and close >= htResLow\ninHtfSup = not na(htSupLow)  and close >= htSupLow  and close <= htSupHigh\n\n// Block direction against HTF zones\nlongBlockedByZone  = inHtfRes   // no buys in HTF resistance\nshortBlockedByZone = inHtfSup   // no sells in HTF support\n\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n// 4. 1m LOCAL ZONES (LIQUIDITY SWEEP + ENGULF + QUALITY SCORE)\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n// 1m engulf patterns\nbullPrev1 = close  > open \nbearPrev1 = close  < open \n\nbearEngulfNow = close < open and bullPrev1 and open >= close  and close <= open \nbullEngulfNow = close > open and bearPrev1 and open <= close  and close >= open \n\n// Liquidity sweep by previous candle on 1m\nsweepHighPrev = high  > ta.highest(high, 5) \nsweepLowPrev  = low   < ta.lowest(low, 5) \n\n// Local zone storage (one active support + one active resistance)\n// Quality score: 1 = engulf only, 2 = engulf + sweep (we only trade â‰¥2)\nvar float supLow  = na\nvar float supHigh = na\nvar int   supQ    = 0\nvar bool  supUsed = false\n\nvar float resLow  = na\nvar float resHigh = na\nvar int   resQ    = 0\nvar bool  resUsed = false\n\n// New resistance zone: previous bullish candle -> bear engulf\nif bearEngulfNow\n    resLow  := low \n    resHigh := high \n    resQ    := sweepHighPrev ? 2 : 1\n    resUsed := false\n\n// New support zone: previous bearish candle -> bull engulf\nif bullEngulfNow\n    supLow  := low \n    supHigh := high \n    supQ    := sweepLowPrev ? 2 : 1\n    supUsed := false\n\n// Raw \"inside zone\" detection\ninSupRaw = not na(supLow) and close >= supLow and close <= supHigh\ninResRaw = not na(resHigh) and close <= resHigh and close >= resLow\n\n// QUALITY FILTER: only trade zones with quality â‰¥ 2 (engulf + sweep)\nhighQualitySup = supQ >= 2\nhighQualityRes = resQ >= 2\n\ninSupZone = inSupRaw and highQualitySup and not supUsed\ninResZone = inResRaw and highQualityRes and not resUsed\n\n// Plot zones\nplot(supLow,  \"Sup Low\",  color = color.new(color.lime, 60), style = plot.style_linebr)\nplot(supHigh, \"Sup High\", color = color.new(color.lime, 60), style = plot.style_linebr)\nplot(resLow,  \"Res Low\",  color = color.new(color.red, 60),  style = plot.style_linebr)\nplot(resHigh, \"Res High\", color = color.new(color.red, 60),  style = plot.style_linebr)\n\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n// 5. MODERATE BOS (3-BAR FRACTAL STRUCTURE)\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n// 3-bar swing highs/lows\nswHigh = high  > high  and high  > high \nswLow  = low   < low   and low   < low \n\nvar float lastSwingHigh = na\nvar float lastSwingLow  = na\n\nif swHigh\n    lastSwingHigh := high \nif swLow\n    lastSwingLow := low \n\n// BOS conditions\nbosUp   = not na(lastSwingHigh) and close > lastSwingHigh\nbosDown = not na(lastSwingLow)  and close < lastSwingLow\n\n// Zone â€œarmingâ€ and BOS validation\nvar bool supArmed = false\nvar bool resArmed = false\nvar bool supBosOK = false\nvar bool resBosOK = false\n\n// Arm zones when first touched\nif inSupZone\n    supArmed := true\nif inResZone\n    resArmed := true\n\n// BOS after arming â†’ zone becomes valid for entries\nif supArmed and bosUp\n    supBosOK := true\nif resArmed and bosDown\n    resBosOK := true\n\n// Reset BOS flags when new zones are created\nif bullEngulfNow\n    supArmed := false\n    supBosOK := false\nif bearEngulfNow\n    resArmed := false\n    resBosOK := false\n\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n// 6. ENTRY CONDITIONS (ZONE + BOS + RISK STATE)\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nflatOrShort = strategy.position_size <= 0\nflatOrLong  = strategy.position_size >= 0\n\nlongSignal  = canTradeToday and not longBlockedByZone  and inSupZone and supBosOK and flatOrShort\nshortSignal = canTradeToday and not shortBlockedByZone and inResZone and resBosOK and flatOrLong\n\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n// 7. ORDER LOGIC â€“ TWO PROFIT STRATEGIES\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n// Common metrics\natrTrail = ta.atr(atrTrailLen)\n\n// MINIMAL MODE: single trade, BE after TP1, optional trailing\n// HYBRID MODE: two trades (Scalp @ TP1, Runner @ TP2)\n\n// Persistent tracking\nvar float longEntry      = na\nvar float longTP1        = na\nvar float longTP2        = na\nvar float longSL         = na\nvar bool  longBE         = false\n\nvar float longRunEntry   = na\nvar float longRunTP1     = na\nvar float longRunTP2     = na\nvar float longRunSL      = na\nvar bool  longRunBE      = false\n\nvar float shortEntry     = na\nvar float shortTP1       = na\nvar float shortTP2       = na\nvar float shortSL        = na\nvar bool  shortBE        = false\n\nvar float shortRunEntry  = na\nvar float shortRunTP1    = na\nvar float shortRunTP2    = na\nvar float shortRunSL     = na\nvar bool  shortRunBE     = false\n\nisMinimal = profitStrategy == \"Minimal Risk | Full BE after TP1\"\nisHybrid  = profitStrategy == \"Hybrid | Scalp TP + Runner TP\"\n\n//â”â”â”â”â”â”â”â”â”â” LONG ENTRIES â”â”â”â”â”â”â”â”â”â”\n\nif longSignal\n    if isMinimal\n        longEntry := close\n        longSL    := longEntry - slPoints\n        longTP1   := longEntry + tp1Points\n        longTP2   := longEntry + slPoints * runnerRR\n        longBE    := false\n        strategy.entry(\"Long\", strategy.long)\n        supUsed  := true\n        supArmed := false\n        supBosOK := false\n    else if isHybrid\n        longRunEntry := close\n        longRunSL    := longRunEntry - slPoints\n        longRunTP1   := longRunEntry + tp1Points\n        longRunTP2   := longRunEntry + slPoints * runnerRR\n        longRunBE    := false\n        // Two separate entries, each 50% of baseQty  (for backtest)\n        strategy.entry(\"LongScalp\", strategy.long, qty = baseQty * 0.5)\n        strategy.entry(\"LongRun\",   strategy.long, qty = baseQty * 0.5)\n        supUsed  := true\n        supArmed := false\n        supBosOK := false\n\n//â”â”â”â”â”â”â”â”â”â” SHORT ENTRIES â”â”â”â”â”â”â”â”â”â”\n\nif shortSignal\n    if isMinimal\n        shortEntry := close\n        shortSL    := shortEntry + slPoints\n        shortTP1   := shortEntry - tp1Points\n        shortTP2   := shortEntry - slPoints * runnerRR\n        shortBE    := false\n        strategy.entry(\"Short\", strategy.short)\n        resUsed  := true\n        resArmed := false\n        resBosOK := false\n    else if isHybrid\n        shortRunEntry := close\n        shortRunSL    := shortRunEntry + slPoints\n        shortRunTP1   := shortRunEntry - tp1Points\n        shortRunTP2   := shortRunEntry - slPoints * runnerRR\n        shortRunBE    := false\n        strategy.entry(\"ShortScalp\", strategy.short, qty = baseQty * 50)\n        strategy.entry(\"ShortRun\",   strategy.short, qty = baseQty * 50)\n        resUsed  := true\n        resArmed := false\n        resBosOK := false\n\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n// 8. EXIT LOGIC â€“ MINIMAL MODE\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n// LONG â€“ Minimal Risk: 1 trade, BE after TP1, runner to TP2\nif isMinimal and strategy.position_size > 0 and not na(longEntry)\n    // Move to BE once TP1 is touched\n    if not longBE and high >= longTP1\n        longBE := true\n    // Base SL: BE or initial SL\n    float dynLongSL = longBE ? longEntry : longSL\n\n    // Optional trailing after BE\n    if longBE\n        if runnerStopMode == \"Structure trail\" and not na(lastSwingLow) and lastSwingLow > longEntry\n            dynLongSL := math.max(dynLongSL, lastSwingLow)\n        if runnerStopMode == \"ATR trail\"\n            trailSL = close - atrTrailMult * atrTrail\n            dynLongSL := math.max(dynLongSL, trailSL)\n\n    strategy.exit(\"Long Exit\", \"Long\", stop = dynLongSL, limit = longTP2)\n\n// SHORT â€“ Minimal Risk: 1 trade, BE after TP1, runner to TP2\nif isMinimal and strategy.position_size < 0 and not na(shortEntry)\n    if not shortBE and low <= shortTP1\n        shortBE := true\n    float dynShortSL = shortBE ? shortEntry : shortSL\n\n    if shortBE\n        if runnerStopMode == \"Structure trail\" and not na(lastSwingHigh) and lastSwingHigh < shortEntry\n            dynShortSL := math.min(dynShortSL, lastSwingHigh)\n        if runnerStopMode == \"ATR trail\"\n            trailSLs = close + atrTrailMult * atrTrail\n            dynShortSL := math.min(dynShortSL, trailSLs)\n\n    strategy.exit(\"Short Exit\", \"Short\", stop = dynShortSL, limit = shortTP2)\n\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n// 9. EXIT LOGIC â€“ HYBRID MODE\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n// LONG â€“ Hybrid: Scalp + Runner\nif isHybrid\n    // Scalp leg: full TP at TP1\n    if strategy.opentrades > 0\n        strategy.exit(\"LScalp TP\", \"LongScalp\", stop = longRunSL, limit = longRunTP1)\n\n    // Runner leg\n    if strategy.position_size > 0 and not na(longRunEntry)\n        if not longRunBE and high >= longRunTP1\n            longRunBE := true\n        float dynLongRunSL = longRunBE ? longRunEntry : longRunSL\n\n        if longRunBE\n            if runnerStopMode == \"Structure trail\" and not na(lastSwingLow) and lastSwingLow > longRunEntry\n                dynLongRunSL := math.max(dynLongRunSL, lastSwingLow)\n            if runnerStopMode == \"ATR trail\"\n                trailRunSL = close - atrTrailMult * atrTrail\n                dynLongRunSL := math.max(dynLongRunSL, trailRunSL)\n\n        strategy.exit(\"LRun TP\", \"LongRun\", stop = dynLongRunSL, limit = longRunTP2)\n\n// SHORT â€“ Hybrid: Scalp + Runner\nif isHybrid\n    if strategy.opentrades > 0\n        strategy.exit(\"SScalp TP\", \"ShortScalp\", stop = shortRunSL, limit = shortRunTP1)\n\n    if strategy.position_size < 0 and not na(shortRunEntry)\n        if not shortRunBE and low <= shortRunTP1\n            shortRunBE := true\n        float dynShortRunSL = shortRunBE ? shortRunEntry : shortRunSL\n\n        if shortRunBE\n            if runnerStopMode == \"Structure trail\" and not na(lastSwingHigh) and lastSwingHigh < shortRunEntry\n                dynShortRunSL := math.min(dynShortRunSL, lastSwingHigh)\n            if runnerStopMode == \"ATR trail\"\n                trailRunSLs = close + atrTrailMult * atrTrail\n                dynShortRunSL := math.min(dynShortRunSL, trailRunSLs)\n\n        strategy.exit(\"SRun TP\", \"ShortRun\", stop = dynShortRunSL, limit = shortRunTP2)\n\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n// 10. RESET STATE WHEN FLAT\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nif strategy.position_size == 0\n    longEntry     := na\n    shortEntry    := na\n    longBE        := false\n    shortBE       := false\n    longRunEntry  := na\n    shortRunEntry := na\n    longRunBE     := false\n    shortRunBE    := false\n\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n// 11. VISUAL ENTRY MARKERS\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\nplotshape(longSignal,  title = \"Long Signal\",  style = shape.triangleup,\n          location = location.belowbar, color = color.lime, size = size.tiny, text = \"L\")\n\nplotshape(shortSignal, title = \"Short Signal\", style = shape.triangledown,\n          location = location.abovebar, color = color.red, size = size.tiny, text = \"S\")",
    "image_url": "5M78HLhb",
    "author": "amart24",
    "likes": 93,
    "type": "strategy",
    "created": "2025-12-08",
    "updated": "2025-12-08",
    "source": "//@version=6\r\nstrategy(\"XAUUSD 1m SMC Zones (BOS + Flexible TP Modes + Trailing Runner)\",\r\n     overlay = true,\r\n     initial_capital = 10000,\r\n     pyramiding = 10,\r\n     process_orders_on_close = true)\r\n\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n// 1. INPUTS\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n\r\n// TP / SL\r\ntp1Pips      = input.int(10, \"TP1 (pips)\", minval = 1)\r\nfixedSLpips  = input.int(50, \"Fixed SL (pips)\", minval = 5)\r\nrunnerRR     = input.float(3.0, \"Runner RR (TP2 = SL * RR)\", step = 0.1, minval = 1.0)\r\n\r\n// Daily risk\r\nmaxDailyLossPct   = input.float(5.0,  \"Max daily loss % (stop trading)\",   step = 0.5)\r\nmaxDailyProfitPct = input.float(20.0, \"Max daily profit % (stop trading)\", step = 1.0)\r\n\r\n// HTF S/R (1H)\r\nhtfTF = input.string(\"60\", \"HTF timeframe (minutes) for S/R block\")\r\n\r\n// Profit strategy (Option C)\r\nprofitStrategy = input.string(\"Minimal Risk | Full BE after TP1\", \"Profit Strategy\", options = [ \"Minimal Risk | Full BE after TP1\", \"Hybrid | Scalp TP + Runner TP\"])\r\n\r\n// Runner stop mode (your option 4)\r\nrunnerStopMode = input.string( \"BE only\", \"Runner Stop Mode\", options = [\"BE only\", \"Structure trail\", \"ATR trail\" ])\r\n\r\n// ATR trail settings (only used if ATR mode selected)\r\natrTrailLen  = input.int(14, \"ATR Length (trail)\", minval = 1)\r\natrTrailMult = input.float(1.0, \"ATR Multiplier (trail)\", step = 0.1, minval = 0.1)\r\n\r\n// Pip size (for XAUUSD: 1 pip = 0.10 if tick = 0.01)\r\npipSize   = syminfo.mintick * 10.0\r\ntp1Points = tp1Pips * pipSize\r\nslPoints  = fixedSLpips * pipSize\r\n\r\nbaseQty = input.float (1.0, \"Base order size\" , step = 0.01, minval = 0.01)\r\n\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n// 2. DAILY RISK MANAGEMENT\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n\r\nisNewDay = ta.change(time(\"D\")) != 0\r\n\r\nvar float dayStartEquity = na\r\nvar bool  dailyStopped   = false\r\n\r\nequityNow = strategy.initial_capital + strategy.netprofit\r\n\r\nif isNewDay or na(dayStartEquity)\r\n    dayStartEquity := equityNow\r\n    dailyStopped   := false\r\n\r\ndailyPnL    = equityNow - dayStartEquity\r\ndailyPnLPct = dayStartEquity != 0 ? (dailyPnL / dayStartEquity) * 100.0 : 0.0\r\n\r\nif not dailyStopped\r\n    if dailyPnLPct <= -maxDailyLossPct\r\n        dailyStopped := true\r\n    if dailyPnLPct >= maxDailyProfitPct\r\n        dailyStopped := true\r\n\r\ncanTradeToday = not dailyStopped\r\n\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n// 3. 1H S/R ZONES (for direction block)\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n\r\nhtOpen  = request.security(syminfo.tickerid, htfTF, open)\r\nhtHigh  = request.security(syminfo.tickerid, htfTF, high)\r\nhtLow   = request.security(syminfo.tickerid, htfTF, low)\r\nhtClose = request.security(syminfo.tickerid, htfTF, close)\r\n\r\n// Engulf logic on HTF\r\nhtBullPrev = htClose[1] > htOpen[1]\r\nhtBearPrev = htClose[1] < htOpen[1]\r\n\r\nhtBearEngulf = htClose < htOpen and htBullPrev and htOpen >= htClose[1] and htClose <= htOpen[1]\r\nhtBullEngulf = htClose > htOpen and htBearPrev and htOpen <= htClose[1] and htClose >= htOpen[1]\r\n\r\n// Liquidity sweep on HTF previous candle\r\nhtSweepHigh = htHigh[1] > ta.highest(htHigh, 5)[2]\r\nhtSweepLow  = htLow[1]  < ta.lowest(htLow, 5)[2]\r\n\r\n// Store last HTF zones\r\nvar float htResHigh = na\r\nvar float htResLow  = na\r\nvar float htSupHigh = na\r\nvar float htSupLow  = na\r\n\r\nif htBearEngulf and htSweepHigh\r\n    htResHigh := htHigh[1]\r\n    htResLow  := htLow[1]\r\n\r\nif htBullEngulf and htSweepLow\r\n    htSupHigh := htHigh[1]\r\n    htSupLow  := htLow[1]\r\n\r\n// Are we inside HTF zones?\r\ninHtfRes = not na(htResHigh) and close <= htResHigh and close >= htResLow\r\ninHtfSup = not na(htSupLow)  and close >= htSupLow  and close <= htSupHigh\r\n\r\n// Block direction against HTF zones\r\nlongBlockedByZone  = inHtfRes   // no buys in HTF resistance\r\nshortBlockedByZone = inHtfSup   // no sells in HTF support\r\n\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n// 4. 1m LOCAL ZONES (LIQUIDITY SWEEP + ENGULF + QUALITY SCORE)\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n\r\n// 1m engulf patterns\r\nbullPrev1 = close[1] > open[1]\r\nbearPrev1 = close[1] < open[1]\r\n\r\nbearEngulfNow = close < open and bullPrev1 and open >= close[1] and close <= open[1]\r\nbullEngulfNow = close > open and bearPrev1 and open <= close[1] and close >= open[1]\r\n\r\n// Liquidity sweep by previous candle on 1m\r\nsweepHighPrev = high[1] > ta.highest(high, 5)[2]\r\nsweepLowPrev  = low[1]  < ta.lowest(low, 5)[2]\r\n\r\n// Local zone storage (one active support + one active resistance)\r\n// Quality score: 1 = engulf only, 2 = engulf + sweep (we only trade â‰¥2)\r\nvar float supLow  = na\r\nvar float supHigh = na\r\nvar int   supQ    = 0\r\nvar bool  supUsed = false\r\n\r\nvar float resLow  = na\r\nvar float resHigh = na\r\nvar int   resQ    = 0\r\nvar bool  resUsed = false\r\n\r\n// New resistance zone: previous bullish candle -> bear engulf\r\nif bearEngulfNow\r\n    resLow  := low[1]\r\n    resHigh := high[1]\r\n    resQ    := sweepHighPrev ? 2 : 1\r\n    resUsed := false\r\n\r\n// New support zone: previous bearish candle -> bull engulf\r\nif bullEngulfNow\r\n    supLow  := low[1]\r\n    supHigh := high[1]\r\n    supQ    := sweepLowPrev ? 2 : 1\r\n    supUsed := false\r\n\r\n// Raw \"inside zone\" detection\r\ninSupRaw = not na(supLow) and close >= supLow and close <= supHigh\r\ninResRaw = not na(resHigh) and close <= resHigh and close >= resLow\r\n\r\n// QUALITY FILTER: only trade zones with quality â‰¥ 2 (engulf + sweep)\r\nhighQualitySup = supQ >= 2\r\nhighQualityRes = resQ >= 2\r\n\r\ninSupZone = inSupRaw and highQualitySup and not supUsed\r\ninResZone = inResRaw and highQualityRes and not resUsed\r\n\r\n// Plot zones\r\nplot(supLow,  \"Sup Low\",  color = color.new(color.lime, 60), style = plot.style_linebr)\r\nplot(supHigh, \"Sup High\", color = color.new(color.lime, 60), style = plot.style_linebr)\r\nplot(resLow,  \"Res Low\",  color = color.new(color.red, 60),  style = plot.style_linebr)\r\nplot(resHigh, \"Res High\", color = color.new(color.red, 60),  style = plot.style_linebr)\r\n\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n// 5. MODERATE BOS (3-BAR FRACTAL STRUCTURE)\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n\r\n// 3-bar swing highs/lows\r\nswHigh = high[1] > high[0] and high[1] > high[2]\r\nswLow  = low[1]  < low[0]  and low[1]  < low[2]\r\n\r\nvar float lastSwingHigh = na\r\nvar float lastSwingLow  = na\r\n\r\nif swHigh\r\n    lastSwingHigh := high[1]\r\nif swLow\r\n    lastSwingLow := low[1]\r\n\r\n// BOS conditions\r\nbosUp   = not na(lastSwingHigh) and close > lastSwingHigh\r\nbosDown = not na(lastSwingLow)  and close < lastSwingLow\r\n\r\n// Zone â€œarmingâ€ and BOS validation\r\nvar bool supArmed = false\r\nvar bool resArmed = false\r\nvar bool supBosOK = false\r\nvar bool resBosOK = false\r\n\r\n// Arm zones when first touched\r\nif inSupZone\r\n    supArmed := true\r\nif inResZone\r\n    resArmed := true\r\n\r\n// BOS after arming â†’ zone becomes valid for entries\r\nif supArmed and bosUp\r\n    supBosOK := true\r\nif resArmed and bosDown\r\n    resBosOK := true\r\n\r\n// Reset BOS flags when new zones are created\r\nif bullEngulfNow\r\n    supArmed := false\r\n    supBosOK := false\r\nif bearEngulfNow\r\n    resArmed := false\r\n    resBosOK := false\r\n\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n// 6. ENTRY CONDITIONS (ZONE + BOS + RISK STATE)\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n\r\nflatOrShort = strategy.position_size <= 0\r\nflatOrLong  = strategy.position_size >= 0\r\n\r\nlongSignal  = canTradeToday and not longBlockedByZone  and inSupZone and supBosOK and flatOrShort\r\nshortSignal = canTradeToday and not shortBlockedByZone and inResZone and resBosOK and flatOrLong\r\n\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n// 7. ORDER LOGIC â€“ TWO PROFIT STRATEGIES\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n\r\n// Common metrics\r\natrTrail = ta.atr(atrTrailLen)\r\n\r\n// MINIMAL MODE: single trade, BE after TP1, optional trailing\r\n// HYBRID MODE: two trades (Scalp @ TP1, Runner @ TP2)\r\n\r\n// Persistent tracking\r\nvar float longEntry      = na\r\nvar float longTP1        = na\r\nvar float longTP2        = na\r\nvar float longSL         = na\r\nvar bool  longBE         = false\r\n\r\nvar float longRunEntry   = na\r\nvar float longRunTP1     = na\r\nvar float longRunTP2     = na\r\nvar float longRunSL      = na\r\nvar bool  longRunBE      = false\r\n\r\nvar float shortEntry     = na\r\nvar float shortTP1       = na\r\nvar float shortTP2       = na\r\nvar float shortSL        = na\r\nvar bool  shortBE        = false\r\n\r\nvar float shortRunEntry  = na\r\nvar float shortRunTP1    = na\r\nvar float shortRunTP2    = na\r\nvar float shortRunSL     = na\r\nvar bool  shortRunBE     = false\r\n\r\nisMinimal = profitStrategy == \"Minimal Risk | Full BE after TP1\"\r\nisHybrid  = profitStrategy == \"Hybrid | Scalp TP + Runner TP\"\r\n\r\n//â”â”â”â”â”â”â”â”â”â” LONG ENTRIES â”â”â”â”â”â”â”â”â”â”\r\n\r\nif longSignal\r\n    if isMinimal\r\n        longEntry := close\r\n        longSL    := longEntry - slPoints\r\n        longTP1   := longEntry + tp1Points\r\n        longTP2   := longEntry + slPoints * runnerRR\r\n        longBE    := false\r\n        strategy.entry(\"Long\", strategy.long)\r\n        supUsed  := true\r\n        supArmed := false\r\n        supBosOK := false\r\n    else if isHybrid\r\n        longRunEntry := close\r\n        longRunSL    := longRunEntry - slPoints\r\n        longRunTP1   := longRunEntry + tp1Points\r\n        longRunTP2   := longRunEntry + slPoints * runnerRR\r\n        longRunBE    := false\r\n        // Two separate entries, each 50% of baseQty  (for backtest)\r\n        strategy.entry(\"LongScalp\", strategy.long, qty = baseQty * 0.5)\r\n        strategy.entry(\"LongRun\",   strategy.long, qty = baseQty * 0.5)\r\n        supUsed  := true\r\n        supArmed := false\r\n        supBosOK := false\r\n\r\n//â”â”â”â”â”â”â”â”â”â” SHORT ENTRIES â”â”â”â”â”â”â”â”â”â”\r\n\r\nif shortSignal\r\n    if isMinimal\r\n        shortEntry := close\r\n        shortSL    := shortEntry + slPoints\r\n        shortTP1   := shortEntry - tp1Points\r\n        shortTP2   := shortEntry - slPoints * runnerRR\r\n        shortBE    := false\r\n        strategy.entry(\"Short\", strategy.short)\r\n        resUsed  := true\r\n        resArmed := false\r\n        resBosOK := false\r\n    else if isHybrid\r\n        shortRunEntry := close\r\n        shortRunSL    := shortRunEntry + slPoints\r\n        shortRunTP1   := shortRunEntry - tp1Points\r\n        shortRunTP2   := shortRunEntry - slPoints * runnerRR\r\n        shortRunBE    := false\r\n        strategy.entry(\"ShortScalp\", strategy.short, qty = baseQty * 50)\r\n        strategy.entry(\"ShortRun\",   strategy.short, qty = baseQty * 50)\r\n        resUsed  := true\r\n        resArmed := false\r\n        resBosOK := false\r\n\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n// 8. EXIT LOGIC â€“ MINIMAL MODE\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n\r\n// LONG â€“ Minimal Risk: 1 trade, BE after TP1, runner to TP2\r\nif isMinimal and strategy.position_size > 0 and not na(longEntry)\r\n    // Move to BE once TP1 is touched\r\n    if not longBE and high >= longTP1\r\n        longBE := true\r\n    // Base SL: BE or initial SL\r\n    float dynLongSL = longBE ? longEntry : longSL\r\n\r\n    // Optional trailing after BE\r\n    if longBE\r\n        if runnerStopMode == \"Structure trail\" and not na(lastSwingLow) and lastSwingLow > longEntry\r\n            dynLongSL := math.max(dynLongSL, lastSwingLow)\r\n        if runnerStopMode == \"ATR trail\"\r\n            trailSL = close - atrTrailMult * atrTrail\r\n            dynLongSL := math.max(dynLongSL, trailSL)\r\n\r\n    strategy.exit(\"Long Exit\", \"Long\", stop = dynLongSL, limit = longTP2)\r\n\r\n// SHORT â€“ Minimal Risk: 1 trade, BE after TP1, runner to TP2\r\nif isMinimal and strategy.position_size < 0 and not na(shortEntry)\r\n    if not shortBE and low <= shortTP1\r\n        shortBE := true\r\n    float dynShortSL = shortBE ? shortEntry : shortSL\r\n\r\n    if shortBE\r\n        if runnerStopMode == \"Structure trail\" and not na(lastSwingHigh) and lastSwingHigh < shortEntry\r\n            dynShortSL := math.min(dynShortSL, lastSwingHigh)\r\n        if runnerStopMode == \"ATR trail\"\r\n            trailSLs = close + atrTrailMult * atrTrail\r\n            dynShortSL := math.min(dynShortSL, trailSLs)\r\n\r\n    strategy.exit(\"Short Exit\", \"Short\", stop = dynShortSL, limit = shortTP2)\r\n\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n// 9. EXIT LOGIC â€“ HYBRID MODE\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n\r\n// LONG â€“ Hybrid: Scalp + Runner\r\nif isHybrid\r\n    // Scalp leg: full TP at TP1\r\n    if strategy.opentrades > 0\r\n        strategy.exit(\"LScalp TP\", \"LongScalp\", stop = longRunSL, limit = longRunTP1)\r\n\r\n    // Runner leg\r\n    if strategy.position_size > 0 and not na(longRunEntry)\r\n        if not longRunBE and high >= longRunTP1\r\n            longRunBE := true\r\n        float dynLongRunSL = longRunBE ? longRunEntry : longRunSL\r\n\r\n        if longRunBE\r\n            if runnerStopMode == \"Structure trail\" and not na(lastSwingLow) and lastSwingLow > longRunEntry\r\n                dynLongRunSL := math.max(dynLongRunSL, lastSwingLow)\r\n            if runnerStopMode == \"ATR trail\"\r\n                trailRunSL = close - atrTrailMult * atrTrail\r\n                dynLongRunSL := math.max(dynLongRunSL, trailRunSL)\r\n\r\n        strategy.exit(\"LRun TP\", \"LongRun\", stop = dynLongRunSL, limit = longRunTP2)\r\n\r\n// SHORT â€“ Hybrid: Scalp + Runner\r\nif isHybrid\r\n    if strategy.opentrades > 0\r\n        strategy.exit(\"SScalp TP\", \"ShortScalp\", stop = shortRunSL, limit = shortRunTP1)\r\n\r\n    if strategy.position_size < 0 and not na(shortRunEntry)\r\n        if not shortRunBE and low <= shortRunTP1\r\n            shortRunBE := true\r\n        float dynShortRunSL = shortRunBE ? shortRunEntry : shortRunSL\r\n\r\n        if shortRunBE\r\n            if runnerStopMode == \"Structure trail\" and not na(lastSwingHigh) and lastSwingHigh < shortRunEntry\r\n                dynShortRunSL := math.min(dynShortRunSL, lastSwingHigh)\r\n            if runnerStopMode == \"ATR trail\"\r\n                trailRunSLs = close + atrTrailMult * atrTrail\r\n                dynShortRunSL := math.min(dynShortRunSL, trailRunSLs)\r\n\r\n        strategy.exit(\"SRun TP\", \"ShortRun\", stop = dynShortRunSL, limit = shortRunTP2)\r\n\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n// 10. RESET STATE WHEN FLAT\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n\r\nif strategy.position_size == 0\r\n    longEntry     := na\r\n    shortEntry    := na\r\n    longBE        := false\r\n    shortBE       := false\r\n    longRunEntry  := na\r\n    shortRunEntry := na\r\n    longRunBE     := false\r\n    shortRunBE    := false\r\n\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n// 11. VISUAL ENTRY MARKERS\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n\r\nplotshape(longSignal,  title = \"Long Signal\",  style = shape.triangleup,\r\n          location = location.belowbar, color = color.lime, size = size.tiny, text = \"L\")\r\n\r\nplotshape(shortSignal, title = \"Short Signal\", style = shape.triangledown,\r\n          location = location.abovebar, color = color.red, size = size.tiny, text = \"S\")"
  },
  {
    "url": "PdjuG7Mx-Multi-divergence-Strategy",
    "name": "Multi-divergence Strategy",
    "description": "Multi-divergence Strategy based on MACD / RSI / OBV / etc.",
    "image_url": "PdjuG7Mx",
    "author": "KenzoYagai",
    "likes": 15,
    "type": "strategy",
    "created": "2025-12-08",
    "updated": "2025-12-08",
    "source": "//@version=6\nstrategy(\"Multi-divergence Strategy (MACD / RSI / OBV / etc.) v6\",\n     overlay = true,\n     initial_capital = 100000,\n     pyramiding = 0,\n     commission_type = strategy.commission.percent,\n     commission_value = 0.01,\n     calc_on_every_tick = true)\n\n// === INPUTS ===\n\n// Divergence logic\ndivLookback     = input.int(21, \"Divergence lookback (bars per swing)\", minval = 3, maxval = 100)\nminBullConfirm  = input.int(3,  \"Min indicators for bullish divergence\", minval = 1, maxval = 10)\nminBearConfirm  = input.int(3,  \"Min indicators for bearish divergence\", minval = 1, maxval = 10)\n\n// Indicator parameters\n// MACD\nfastLen         = input.int(12, \"MACD Fast length\", minval = 1)\nslowLen         = input.int(26, \"MACD Slow length\", minval = 2)\nsigLen          = input.int(9,  \"MACD Signal length\", minval = 1)\n\n// RSI\nrsiLen          = input.int(14, \"RSI length\", minval = 2)\n\n// Stoch\nstochLen        = input.int(14, \"Stoch length\", minval = 2)\nkLen            = input.int(3,  \"%K Smoothing\", minval = 1)\ndLen            = input.int(3,  \"%D Smoothing\", minval = 1)\n\n// CCI / CMF / MFI / MOM / VWMA\ncciLen          = input.int(20, \"CCI length\", minval = 2)\ncmfLen          = input.int(20, \"CMF length\", minval = 2)\nmfiLen          = input.int(14, \"MFI length\", minval = 2)\nmomLen          = input.int(10, \"Momentum length\", minval = 1)\nvwmaLen         = input.int(20, \"VWMA length for VWMACD\", minval = 2)\n\n// Trading parameters\nuseLongs        = input.bool(true,  \"Enable LONGs\")\nuseShorts       = input.bool(true,  \"Enable SHORTs\")\nslPerc          = input.float(4.0, \"Stop Loss %\", minval = 0.0, step = 0.1)\ntpPerc          = input.float(11.0, \"Take Profit %\", minval = 0.0, step = 0.1)\n\n\n// === INDICATORS ===\n\n// MACD & Histogram\n[macdLine, macdSignal, macdHist] = ta.macd(close, fastLen, slowLen, sigLen)\n\n// RSI\nrsi = ta.rsi(close, rsiLen)\n\n// Stochastic (%K, %D)\nrawK = ta.stoch(high, low, close, stochLen)\nk    = ta.sma(rawK, kLen)\nd    = ta.sma(k,    dLen)  // not used in divergence, but available\n\n// CCI\ncci = ta.cci(close, cciLen)\n\n// OBV (manual implementation: cumulative signed volume)\nobvChange = close > close[1] ? volume : close < close[1] ? -volume : 0.0\nobv       = ta.cum(obvChange)\n\n// CMF (no ta.sum available â†’ use SMA ratio)\nmfMult = (high != low) ? ((close - low) - (high - close)) / (high - low) : 0.0\nmfVol  = mfMult * volume\nmfSma  = ta.sma(mfVol, cmfLen)\nvolSma = ta.sma(volume, cmfLen)\ncmf    = volSma != 0.0 ? mfSma / volSma : 0.0\n\n// MFI (v6)\nmfi = ta.mfi(close, mfiLen)\n\n// Momentum\nmom = ta.mom(close, momLen)\n\n// VWMACD: MACD on VWMA price\nvwPrice = ta.vwma(close, vwmaLen)\n[vwMacdLine, vwMacdSignal, vwMacdHist] = ta.macd(vwPrice, fastLen, slowLen, sigLen)\n\n\n// === DIVERGENCE FUNCTIONS ===\n// Bullish: price lower low, oscillator higher low\n// Bearish: price higher high, oscillator lower high\n\nf_bull_divergence(priceLowSeries, oscSeries, lb) =>\n    priceLowNow  = ta.lowest(priceLowSeries,     lb)\n    oscLowNow    = ta.lowest(oscSeries,          lb)\n    priceLowPrev = ta.lowest(priceLowSeries[lb], lb)\n    oscLowPrev   = ta.lowest(oscSeries[lb],      lb)\n    (priceLowNow < priceLowPrev) and (oscLowNow > oscLowPrev)\n\nf_bear_divergence(priceHighSeries, oscSeries, lb) =>\n    priceHighNow  = ta.highest(priceHighSeries,     lb)\n    oscHighNow    = ta.highest(oscSeries,           lb)\n    priceHighPrev = ta.highest(priceHighSeries[lb], lb)\n    oscHighPrev   = ta.highest(oscSeries[lb],       lb)\n    (priceHighNow > priceHighPrev) and (oscHighNow < oscHighPrev)\n\n\n// === DIVERGENCE DETECTION PER INDICATOR ===\n\n// MACD line\nbull_macd     = f_bull_divergence(low,  macdLine,   divLookback)\nbear_macd     = f_bear_divergence(high, macdLine,   divLookback)\n\n// MACD Histogram\nbull_hist     = f_bull_divergence(low,  macdHist,   divLookback)\nbear_hist     = f_bear_divergence(high, macdHist,   divLookback)\n\n// RSI\nbull_rsi      = f_bull_divergence(low,  rsi,        divLookback)\nbear_rsi      = f_bear_divergence(high, rsi,        divLookback)\n\n// Stochastic %K\nbull_stoch    = f_bull_divergence(low,  k,          divLookback)\nbear_stoch    = f_bear_divergence(high, k,          divLookback)\n\n// CCI\nbull_cci      = f_bull_divergence(low,  cci,        divLookback)\nbear_cci      = f_bear_divergence(high, cci,        divLookback)\n\n// OBV\nbull_obv      = f_bull_divergence(low,  obv,        divLookback)\nbear_obv      = f_bear_divergence(high, obv,        divLookback)\n\n// CMF\nbull_cmf      = f_bull_divergence(low,  cmf,        divLookback)\nbear_cmf      = f_bear_divergence(high, cmf,        divLookback)\n\n// MFI\nbull_mfi      = f_bull_divergence(low,  mfi,        divLookback)\nbear_mfi      = f_bear_divergence(high, mfi,        divLookback)\n\n// Momentum\nbull_mom      = f_bull_divergence(low,  mom,        divLookback)\nbear_mom      = f_bear_divergence(high, mom,        divLookback)\n\n// VWMACD line\nbull_vwmacd   = f_bull_divergence(low,  vwMacdLine, divLookback)\nbear_vwmacd   = f_bear_divergence(high, vwMacdLine, divLookback)\n\n\n// === AGGREGATION OF SIGNALS ===\n\nbullCount = 0\nbullCount += bull_macd   ? 1 : 0\nbullCount += bull_hist   ? 1 : 0\nbullCount += bull_rsi    ? 1 : 0\nbullCount += bull_stoch  ? 1 : 0\nbullCount += bull_cci    ? 1 : 0\nbullCount += bull_obv    ? 1 : 0\nbullCount += bull_cmf    ? 1 : 0\nbullCount += bull_mfi    ? 1 : 0\nbullCount += bull_mom    ? 1 : 0\nbullCount += bull_vwmacd ? 1 : 0\n\nbearCount = 0\nbearCount += bear_macd   ? 1 : 0\nbearCount += bear_hist   ? 1 : 0\nbearCount += bear_rsi    ? 1 : 0\nbearCount += bear_stoch  ? 1 : 0\nbearCount += bear_cci    ? 1 : 0\nbearCount += bear_obv    ? 1 : 0\nbearCount += bear_cmf    ? 1 : 0\nbearCount += bear_mfi    ? 1 : 0\nbearCount += bear_mom    ? 1 : 0\nbearCount += bear_vwmacd ? 1 : 0\n\nbullSignal = bullCount >= minBullConfirm\nbearSignal = bearCount >= minBearConfirm\n\n\n// === TRADING LOGIC ===\n\ninLong  = strategy.position_size > 0\ninShort = strategy.position_size < 0\n\n// Entries\nif bullSignal and not bearSignal and useLongs and not inLong\n    strategy.entry(\"Long\", strategy.long)\n\nif bearSignal and not bullSignal and useShorts and not inShort\n    strategy.entry(\"Short\", strategy.short)\n\n// Exits (SL / TP, symmetric)\nif inLong and slPerc > 0\n    longStop  = strategy.position_avg_price * (1 - slPerc / 100.0)\n    longLimit = tpPerc > 0 ? strategy.position_avg_price * (1 + tpPerc / 100.0) : na\n    strategy.exit(\"Long Exit\", \"Long\", stop = longStop, limit = longLimit)\n\nif inShort and slPerc > 0\n    shortStop  = strategy.position_avg_price * (1 + slPerc / 100.0)\n    shortLimit = tpPerc > 0 ? strategy.position_avg_price * (1 - tpPerc / 100.0) : na\n    strategy.exit(\"Short Exit\", \"Short\", stop = shortStop, limit = shortLimit)\n\n\n// === VISUALIZATION ===\n\nplotshape(bullSignal,\n     title     = \"Bullish multi-divergence\",\n     style     = shape.triangleup,\n     location  = location.belowbar,\n     size      = size.tiny,\n     color     = color.new(color.lime, 0),\n     text      = \"Bull Div\")\n\nplotshape(bearSignal,\n     title     = \"Bearish multi-divergence\",\n     style     = shape.triangledown,\n     location  = location.abovebar,\n     size      = size.tiny,\n     color     = color.new(color.red, 0),\n     text      = \"Bear Div\")\n\n// Optional: counts (hidden by default)\nplot(bullCount, title = \"Bullish divergence count\",\n     color = color.new(color.lime, 50), display = display.none)\nplot(bearCount, title = \"Bearish divergence count\",\n     color = color.new(color.red, 50), display = display.none)"
  },
  {
    "url": "TKsS8JR0-5-Min-Range-Breakout-09-30-NY-on-MNQ",
    "name": "5-Min Range Breakout (09:30 NY on MNQ)",
    "description": "This is a 5 - min orb strat that a youtuber mentioned and i had a manual look for a while and thought it was actually pretty good but my results are bad. Feel free to look yourself with this code.\n\nBasically this strat is using the 5min orb then go down to 1min timeframe and wait for a breakout with FVG confirmation. So candle after breaking candle is our entry only if FVG is formed. \n\nHowever i do notice if you dump this code onto 5min timefraem and above you start consistently making money but it is a very small amount for me so you all can have it. Good starter strat on 5min or 10min timeframe",
    "image_url": "TKsS8JR0",
    "author": "ryanfoot7",
    "likes": 18,
    "type": "strategy",
    "created": "2025-12-08",
    "updated": "2025-12-08",
    "source": "//@version=5\r\nstrategy(\"5-Min Range Breakout (09:30 NY, Dual TP, 2nd candle confirm, breakout candle stop, pre/post filter)\", overlay=true, initial_capital=20000, pyramiding=2)\r\n\r\n// ==== Inputs ====\r\ntp1R                = input.float(2.0, \"TP1 (R)\", minval=1.0)\r\ntp2R                = input.float(2.0, \"TP2 (R)\", minval=1.0)\r\nopeningRangeMinutes = input.int(5, \"Opening Range (minutes)\", minval=1)\r\nskipDaysAfterWin    = input.int(0, \"Skip days after a win\", minval=0)\r\nmaxTradesPerDay     = input.int(1, \"Max trades per day\", minval=1)\r\n\r\n// Ensure TP2 >= TP1\r\ntp2R := math.max(tp2R, tp1R)\r\n\r\n// ==== State ====\r\nvar float rangeHigh       = na\r\nvar float rangeLow        = na\r\nvar bool  rangeSet        = false\r\nvar int   tradesToday     = 0\r\nvar int   daysSinceWin    = 9999\r\nvar int   breakoutBarLong = na\r\nvar int   breakoutBarShort = na\r\n\r\n// ==== Daily reset ====\r\nnewDay = ta.change(time(\"D\"))\r\nif newDay\r\n    rangeHigh        := na\r\n    rangeLow         := na\r\n    rangeSet         := false\r\n    tradesToday      := 0\r\n    daysSinceWin     += 1\r\n    breakoutBarLong  := na\r\n    breakoutBarShort := na\r\n\r\n// ---- New York open (09:30) detection ----\r\nnyOpen      = timestamp(\"America/New_York\", year, month, dayofmonth, 9, 30)\r\nopenEnd     = nyOpen + openingRangeMinutes * 60 * 1000\r\ninOpenRange = time >= nyOpen and time < openEnd\r\n\r\n// Build the opening range\r\nif inOpenRange\r\n    rangeHigh := na(rangeHigh) ? high : math.max(rangeHigh, high)\r\n    rangeLow  := na(rangeLow)  ? low  : math.min(rangeLow, low)\r\n\r\n// Freeze the range once window closes\r\nif not inOpenRange and not na(rangeHigh) and not na(rangeLow)\r\n    rangeSet := true\r\n\r\n// ==== Contract sizing by stop distance ====\r\nf_contractSize(stopPoints) =>\r\n    int qty = 1\r\n    if stopPoints <= 5\r\n        qty := 40\r\n    else if stopPoints <= 10\r\n        qty := 30\r\n    else if stopPoints <= 20\r\n        qty := 15\r\n    else if stopPoints <= 30\r\n        qty := 10\r\n    else if stopPoints <= 40\r\n        qty := 8\r\n    else if stopPoints <= 50\r\n        qty := 6\r\n    else if stopPoints <= 60\r\n        qty := 5\r\n    else if stopPoints <= 75\r\n        qty := 4\r\n    else if stopPoints <= 100\r\n        qty := 3\r\n    else if stopPoints <= 150\r\n        qty := 2\r\n    qty\r\n\r\n// ==== Allowed sizes ====\r\nisAllowedSize(qty) =>\r\n    qty == 4 or qty == 5 or qty == 6 or qty == 8 or qty == 10 or qty == 15 \r\n\r\n// ==== Skip logic ====\r\nskipActive = daysSinceWin <= skipDaysAfterWin\r\ncanTrade   = (tradesToday < maxTradesPerDay) and not skipActive\r\n\r\n// ==== Breakout detection ====\r\nlongBreakNow  = rangeSet and time >= openEnd and close > rangeHigh\r\nshortBreakNow = rangeSet and time >= openEnd and close < rangeLow\r\n\r\nif na(breakoutBarLong) and longBreakNow\r\n    breakoutBarLong := bar_index\r\nif na(breakoutBarShort) and shortBreakNow\r\n    breakoutBarShort := bar_index\r\n\r\n// ==== Entry conditions: candle after breakout, still outside range ====\r\n// Long entry: skip if candle before breakout high > candle after breakout low\r\nenterLong = not na(breakoutBarLong) and bar_index == breakoutBarLong + 1 and close > rangeHigh and high[2] <= low\r\n// Short entry: skip if candle before breakout low < candle after breakout high\r\nenterShort = not na(breakoutBarShort) and bar_index == breakoutBarShort + 1 and close < rangeLow and low[2] >= high\r\n\r\n// ==== Entries / Exits ====\r\n// Long: stoploss = breakout candle low\r\nif canTrade and enterLong\r\n    slLong   = low[1]   // breakout candle's low\r\n    stopDist = close - slLong\r\n    if stopDist > 0\r\n        tpLong1 = close + stopDist * tp1R\r\n        tpLong2 = close + stopDist * tp2R\r\n        qtyLong = f_contractSize(stopDist)\r\n        if isAllowedSize(qtyLong)\r\n            qty1 = math.floor(qtyLong * 0.5)\r\n            qty2 = qtyLong - qty1\r\n            if qty1 > 0\r\n                strategy.entry(\"LongLeg1-\" + str.tostring(time), strategy.long, qty=qty1)\r\n                strategy.exit(\"ExitLeg1-\" + str.tostring(time), from_entry=\"LongLeg1-\" + str.tostring(time), stop=slLong, limit=tpLong1)\r\n            if qty2 > 0\r\n                strategy.entry(\"LongLeg2-\" + str.tostring(time), strategy.long, qty=qty2)\r\n                strategy.exit(\"ExitLeg2-\" + str.tostring(time), from_entry=\"LongLeg2-\" + str.tostring(time), stop=slLong, limit=tpLong2)\r\n            tradesToday += 1\r\n\r\n// Short: stoploss = breakout candle high\r\nif canTrade and enterShort\r\n    slShort  = high[1]  // breakout candle's high\r\n    stopDist = slShort - close\r\n    if stopDist > 0\r\n        tpShort1 = close - stopDist * tp1R\r\n        tpShort2 = close - stopDist * tp2R\r\n        qtyShort = f_contractSize(stopDist)\r\n        if isAllowedSize(qtyShort)\r\n            qty1 = math.floor(qtyShort * 0.5)\r\n            qty2 = qtyShort - qty1\r\n            if qty1 > 0\r\n                strategy.entry(\"ShortLeg1-\" + str.tostring(time), strategy.short, qty=qty1)\r\n                strategy.exit(\"ExitLeg1S-\" + str.tostring(time), from_entry=\"ShortLeg1-\" + str.tostring(time), stop=slShort, limit=tpShort1)\r\n            if qty2 > 0\r\n                strategy.entry(\"ShortLeg2-\" + str.tostring(time), strategy.short, qty=qty2)\r\n                strategy.exit(\"ExitLeg2S-\" + str.tostring(time), from_entry=\"ShortLeg2-\" + str.tostring(time), stop=slShort, limit=tpShort2)\r\n            tradesToday += 1\r\n\r\n// ==== Track wins ====\r\nclosedChange = ta.change(strategy.closedtrades)\r\nif closedChange > 0\r\n    lastIdx = strategy.closedtrades - 1\r\n    profit  = strategy.closedtrades.profit(lastIdx)\r\n    if profit > 0\r\n        daysSinceWin := 0\r\n\r\n// ==== Plots ====\r\nplot(rangeHigh, \"Range High\", color=color.new(color.green, 0), style=plot.style_linebr, linewidth=2)\r\nplot(rangeLow,  \"Range Low\",  color=color.new(color.red,   0), style=plot.style_linebr, linewidth=2)\r\n"
  },
  {
    "url": "Zac68040",
    "name": "å…­è„‰é½å‘å¤šç©ºç­–ç•¥",
    "description": "å…­è„‰é½å‘å¤šç©ºç­–ç•¥\n# Six Meridians Unified Long/Short Strategy\n## Overview\nThe \"Six Meridians Unified Long/Short Strategy\" is a comprehensive quantitative trading strategy built on TradingView Pine Script v6, designed for cross-asset long/short trading (stocks, cryptocurrencies, futures, forex, etc.). It leverages the resonance of **6 classic technical indicators** to filter high-confidence trading signals, reducing false signals caused by single-indicator bias and improving the reliability of entry/exit decisions.\n\n## Core Indicators (6 \"Meridians\")\nThe strategy evaluates bullish/bearish trends by calculating 6 key technical indicators, with a \"bullish count\" system to quantify trend strength:\n\n| Indicator               | Calculation Parameters       | Bullish Condition                          | Bearish Condition                          |\n|-------------------------|------------------------------|--------------------------------------------|--------------------------------------------|\n| MACD                    | Fast=12, Slow=26, Signal=9   | MACD line crosses above Signal line        | MACD line crosses below Signal line        |\n| KDJ (Stochastic Oscillator) | Length=14, SmoothK=3, SmoothD=3 | K line > D line                            | K line < D line                            |\n| RSI (Relative Strength Index) | Short=6, Long=12         | Short-period RSI (6) > Long-period RSI (12) | Short-period RSI (6) < Long-period RSI (12) |\n| LWR (Modified Williams %R) | Length=14, Smooth=6         | LWR1 (WMA-smooth) > LWR2 (6-period WMA)    | LWR1 < LWR2                                |\n| BBI (Bollinger Band Index) | EMA(3)+EMA(6)+EMA(12)+EMA(24) /4 | Close price > BBI line                     | Close price < BBI line                     |\n| MTM (Momentum)          | Period=12, MMS=6, MMM=14     | Short momentum line (MMS) > Long momentum line (MMM) | Short momentum line (MMS) < Long momentum line (MMM) |\n\n## Trading Logic\nThe strategy uses a \"count-based\" trigger mechanism to execute position management (no pyramiding allowed):\n\n### Long Position Rules\n1. **Entry**: Open long position only when all 6 indicators show bullish signals (`bullCount = 6`).\n2. **Partial Exit**: Reduce 50% of long position when 4 indicators remain bullish (`bullCount = 4`).\n3. **Full Exit**: Close all long positions when â‰¤3 indicators are bullish (`bullCount â‰¤ 3`).\n\n### Short Position Rules\n1. **Entry**: Open short position only when all 6 indicators show bearish signals (`bearCount = 6`).\n2. **Partial Exit**: Cover 50% of short position when 4 indicators remain bearish (`bearCount = 4`).\n3. **Full Exit**: Close all short positions when â‰¤3 indicators are bearish (`bearCount â‰¤ 3`).\n\n## Strategy Parameters (Risk & Capital Management)\n| Parameter                | Value          | Description                                  |\n|--------------------------|----------------|----------------------------------------------|\n| Initial Capital          | $100,000       | Starting equity for backtesting              |\n| Default Order Size       | $10,000 (cash) | Fixed cash amount per trade (instead of lots) |\n| Commission               | 0.1% per trade | Realistic transaction cost (percent-based)   |\n| Margin Requirement       | 100%           | No leverage (1:1 trading)                    |\n| Pyramiding               | 0              | No additional positions on existing trades   |\n\n## Key Features\n1. **Multi-Indicator Resonance**: Eliminates noise from single-indicator false signals by requiring consensus across 6 diverse technical metrics.\n2. **Gradual Position Management**: Partial exit (50%) before full closure to lock in profits and reduce downside risk.\n3. **Full Automation**: Automatically executes entry/exit/position adjustment without manual intervention.\n4. **Visualization Tools**: Plots BBI line, long/short signal labels, and bullish indicator count for easy strategy monitoring.\n5. **Versatility**: Adaptable to multiple timeframes (15min, 1H, 4H, daily) and asset classes.\n\n## Notes\n- The strategy is optimized for trend-following markets and may underperform in choppy/range-bound conditions.\n- Backtest results should be validated across different market cycles (bull, bear, sideways) before live trading.\n- Parameters (e.g., indicator periods, order size) can be adjusted based on specific asset volatility and trading style.",
    "image_url": "Zac68040",
    "author": "ms023999",
    "likes": 11,
    "type": "strategy",
    "created": "2025-12-08",
    "updated": "2025-12-08",
    "source": "//@version=6\nstrategy(\"å…­è„‰é½å‘å¤šç©ºç­–ç•¥\", \n     overlay=true, \n     default_qty_type=strategy.cash, \n     default_qty_value=10000, \n     initial_capital=100000, \n     commission_type=strategy.commission.percent, \n     commission_value=0.1, \n     margin_long=100, \n     margin_short=100, \n     pyramiding=0)\n\n// 1. MACDæŒ‡æ ‡è®¡ç®—ï¼ˆv6æ ‡å‡†å†™æ³•ï¼‰\n[macdLine, signalLine, _] = ta.macd(close, 12, 26, 9)\nmacdBull = macdLine > signalLine  // DIFFé‡‘å‰DEAï¼ˆçœ‹æ¶¨ï¼‰\n\n// 2. KDJæŒ‡æ ‡è®¡ç®—ï¼ˆå½»åº•ä¿®å¤ta.stochå‚æ•°é”™è¯¯ï¼šæ‰‹åŠ¨å¹³æ»‘K/Då€¼ï¼‰\nstochK_raw = ta.stoch(close, high, low, 14)  // ä»…ä¼ 4ä¸ªå¿…é€‰å‚æ•°ï¼ˆæ ¸å¿ƒä¿®å¤ï¼‰\nkg = ta.sma(stochK_raw, 3)                  // smoothK=3ï¼ˆæ‰‹åŠ¨å¹³æ»‘ï¼‰\ndg = ta.sma(kg, 3)                          // smoothD=3ï¼ˆæ‰‹åŠ¨å¹³æ»‘ï¼‰\nkdjBull = kg > dg  // Kå€¼å¤§äºŽDå€¼ï¼ˆä¹°å…¥ä¿¡å·ï¼‰\n\n// 3. RSIæŒ‡æ ‡è®¡ç®—ï¼ˆçŸ­å‘¨æœŸ6ï¼Œé•¿å‘¨æœŸ12ï¼‰\nrsiShort = ta.rsi(close, 6)\nrsiLong = ta.rsi(close, 12)\nrsiBull = rsiShort > rsiLong  // çŸ­å‘¨æœŸRSIé«˜äºŽé•¿å‘¨æœŸï¼ˆå¼ºåŠ¿ï¼‰\n\n// 4. å¨å»‰æŒ‡æ ‡LWRè®¡ç®—ï¼ˆä¿®å¤ta.stochå‚æ•°ï¼šä»…ä¼ 4ä¸ªå¿…é€‰å‚æ•°ï¼‰\nstoch_raw = ta.stoch(close, high, low, 14)  // æ ¸å¿ƒä¿®å¤ï¼šä»…4ä¸ªå‚æ•°\nlwrRaw = 100 - stoch_raw\nlwr1 = ta.wma(lwrRaw, 1)\nlwr2 = ta.wma(lwr1, 6)\nlwrBull = lwr1 > lwr2  // LWR1é«˜äºŽLWR2ï¼ˆçœ‹æ¶¨ï¼‰\n\n// 5. BBIå¤šç©ºæŒ‡æ ‡è®¡ç®—ï¼ˆ4æœŸå‡çº¿ï¼š3,6,12,24ï¼Œä¿®æ­£æ‹¬å·ä¼˜å…ˆçº§ï¼‰\nbbi = (ta.ema(close, 3) + ta.ema(close, 6) + ta.ema(close, 12) + ta.ema(close, 24)) / 4\nbbiBull = close > bbi  // æ”¶ç›˜ä»·é«˜äºŽBBIï¼ˆå¤šå¤´å ä¼˜ï¼‰\n\n// 6. MTMåŠ¨é‡æŒ‡æ ‡è®¡ç®—ï¼ˆä¿®å¤ta.closeæœªå£°æ˜Žé”™è¯¯ï¼‰\nmtm = close - close[12]  // çŸ­æœŸ12æœŸåŠ¨é‡ï¼ˆç›´æŽ¥ç”¨close[12]ï¼Œæ— ta.å‰ç¼€ï¼‰\nmms = ta.ema(mtm, 6)     // çŸ­æœŸåŠ¨é‡çº¿\nmmm = ta.ema(mms, 14)    // é•¿æœŸåŠ¨é‡çº¿\nmtmBull = mms > mmm      // çŸ­æœŸåŠ¨é‡çº¿é«˜äºŽé•¿æœŸï¼ˆå¼ºåŠ¿ï¼‰\n\n// ç»Ÿè®¡çœ‹æ¶¨æŒ‡æ ‡æ•°é‡ï¼ˆä¿®å¤bool+intç±»åž‹ä¸åŒ¹é…ï¼šæ¯ä¸ªæ¡ä»¶è½¬intå¹¶åŠ æ‹¬å·ï¼‰\nbullCount = \n     (macdBull ? 1 : 0) + \n     (kdjBull ? 1 : 0) + \n     (rsiBull ? 1 : 0) + \n     (lwrBull ? 1 : 0) + \n     (bbiBull ? 1 : 0) + \n     (mtmBull ? 1 : 0)\nbearCount = 6 - bullCount  // çœ‹è·ŒæŒ‡æ ‡æ•°é‡ï¼ˆç©ºå¤´é€»è¾‘ç›¸åï¼‰\n\n// ç­–ç•¥ä¿¡å·æ¡ä»¶\nlongCondition = bullCount == 6  // å…­è„‰é½å‘ï¼šä¹°å…¥ä¿¡å·\npartialExitCondition = bullCount == 4  // å°‘ä¸¤å‰‘ï¼ˆ4çº¢ï¼‰ï¼šå‡ä»“1/2\nfullExitCondition = bullCount <= 3     // å°‘ä¸‰å‰‘ï¼ˆâ‰¤3çº¢ï¼‰ï¼šæ¸…ä»“\nshortCondition = bearCount == 6       // ç©ºå¤´å…­è„‰é½å‘ï¼šå–ç©ºä¿¡å·\npartialCoverCondition = bearCount == 4// ç©ºå¤´å°‘ä¸¤å‰‘ï¼šå¹³ä»“1/2\nfullCoverCondition = bearCount <= 3   // ç©ºå¤´å°‘ä¸‰å‰‘ï¼šå…¨å¹³ä»“\n\n// ç­–ç•¥æ‰§è¡Œé€»è¾‘\n// å¤šå¤´æ“ä½œ\nif (longCondition and strategy.position_size == 0)\n    strategy.entry(\"å¤šå¤´å¼€ä»“\", strategy.long)\nif (partialExitCondition and strategy.position_size > 0)\n    strategy.close(\"å¤šå¤´å¼€ä»“\", qty_percent=50, comment=\"å‡ä»“1/2\")\nif (fullExitCondition and strategy.position_size > 0)\n    strategy.close(\"å¤šå¤´å¼€ä»“\", comment=\"æ¸…ä»“\")\n\n// ç©ºå¤´æ“ä½œ\nif (shortCondition and strategy.position_size == 0)\n    strategy.entry(\"ç©ºå¤´å¼€ä»“\", strategy.short)\nif (partialCoverCondition and strategy.position_size < 0)\n    strategy.close(\"ç©ºå¤´å¼€ä»“\", qty_percent=50, comment=\"å¹³ä»“1/2\")\nif (fullCoverCondition and strategy.position_size < 0)\n    strategy.close(\"ç©ºå¤´å¼€ä»“\", comment=\"å…¨å¹³ä»“\")\n\n// æŒ‡æ ‡å¯è§†åŒ–ï¼ˆå¯é€‰ï¼Œä¾¿äºŽè§‚å¯Ÿï¼‰\nplot(bbi, color=color.new(color.blue, 0), title=\"BBI\", linewidth=2)\nplotshape(longCondition, title=\"ä¹°å…¥ä¿¡å·\", location=location.belowbar, color=color.green, style=shape.labelup, text=\"ä¹°å…¥\", textcolor=color.white)\nplotshape(shortCondition, title=\"å–ç©ºä¿¡å·\", location=location.abovebar, color=color.red, style=shape.labeldown, text=\"å–ç©º\", textcolor=color.white)\nplot(bullCount, title=\"çœ‹æ¶¨æŒ‡æ ‡æ•°\", color=color.orange, display=display.data_window)"
  },
  {
    "url": "llTXO45e-MACD-Zero-Line-Strategy-Long-Only",
    "name": "MACD Zero-Line Strategy (Long Only)",
    "description": "Strategy to Open order when Mac-D Signal Cross up 0, Sell when it cross down 0",
    "image_url": "llTXO45e",
    "author": "parrinton",
    "likes": 4,
    "type": "strategy",
    "created": "2025-12-08",
    "updated": "2025-12-08",
    "source": "//@version=6\nstrategy(\n     \"BTC MACD Zero-Line Strategy (Long Only)\",\n     overlay = false,\n     initial_capital = 100000,\n     default_qty_type = strategy.percent_of_equity,\n     default_qty_value = 100,\n     commission_type = strategy.commission.percent,\n     commission_value = 0.1,      // 0.1% fee per trade â€“ à¸›à¸£à¸±à¸šà¸•à¸²à¸¡à¸„à¹ˆà¸²à¸Ÿà¸µà¸‚à¸­à¸‡ exchange\n     pyramiding = 0,\n     process_orders_on_close = true\n)\n\n// === Inputs ===\nfastLen = input.int(12, \"MACD Fast Length\")\nslowLen = input.int(26, \"MACD Slow Length\")\nsigLen  = input.int(9, \"MACD Signal Length\")\nsrc     = input.source(close, \"Source\")\n\n// === MACD Calculation (built-in) ===\n[macd, signal, hist] = ta.macd(src, fastLen, slowLen, sigLen)\n\n// Zero line\nzero = 0.0\n\n// === Entry / Exit Conditions ===\n// à¹€à¸‚à¹‰à¸²à¹€à¸¡à¸·à¹ˆà¸­ MACD à¸•à¸±à¸”à¸‚à¸¶à¹‰à¸™à¸œà¹ˆà¸²à¸™ 0\nmacdCrossUp   = ta.crossover(macd, zero)\n\n// à¸­à¸­à¸à¹€à¸¡à¸·à¹ˆà¸­ MACD à¸•à¸±à¸”à¸¥à¸‡à¸œà¹ˆà¸²à¸™ 0\nmacdCrossDown = ta.crossunder(macd, zero)\n\n// === Strategy Logic ===\nif macdCrossUp and strategy.position_size <= 0\n    strategy.entry(\"Long\", strategy.long)\n\nif macdCrossDown and strategy.position_size > 0\n    strategy.close(\"Long\")\n\n// === Plot ===\nplot(macd,   color = color.new(color.teal, 0),   title = \"MACD\")\nplot(signal, color = color.new(color.orange, 0), title = \"Signal\")\nhline(zero, \"Zero Line\", color = color.new(color.gray, 60))\n"
  },
  {
    "url": "fCnTa17i-Katik-EMA-BUY-SELL",
    "name": "Katik EMA BUY SELL",
    "description": "This strategy uses EMA 9, EMA 20, and EMA 200 to generate Buy and Sell signals.\n\nBUY Conditions\n\nEMA 9 crosses above EMA 20\n\nStoploss: Recent Swing Low\n\nTarget: EMA 9 touches or crosses EMA 200\n\nSELL Conditions\n\nEMA 9 crosses below EMA 20\n\nStoploss: Recent Swing High\n\nTarget: EMA 9 touches or crosses EMA 200\n\nFeatures\n\nAutomatic Long & Short entries\n\nDynamic swing-based stoploss\n\nClear EMA plots with line width 3\n\nWorks on all timeframes",
    "image_url": "fCnTa17i",
    "author": "Katik143",
    "likes": 10,
    "type": "strategy",
    "created": "2025-12-08",
    "updated": "2025-12-08",
    "source": "//@version=5\nstrategy(\"Katik EMA BUY SELL\", overlay=true, initial_capital=100000, commission_type=strategy.commission.percent, commission_value=0.02)\n\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n// EMA Calculations\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nema9   = ta.ema(close, 9)\nema20  = ta.ema(close, 20)\nema200 = ta.ema(close, 200)\n\n// Plot EMAs\nplot(ema9,  \"EMA 9\",  color=color.new(color.green, 0), linewidth=3)\nplot(ema20, \"EMA 20\", color=color.new(color.orange, 0), linewidth=3)\nplot(ema200,\"EMA 200\",color=color.new(color.blue, 0), linewidth=3)\n\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n// Swing High / Low\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nswingLow  = ta.pivotlow(low, 5, 5)\nswingHigh = ta.pivothigh(high, 5, 5)\n\nvar float SL_long  = na\nvar float SL_short = na\n\nif not na(swingLow)\n    SL_long := swingLow\n\nif not na(swingHigh)\n    SL_short := swingHigh\n\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n// Entry Conditions\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nlongEntry  = ta.crossover(ema9, ema20)\nshortEntry = ta.crossunder(ema9, ema20)\n\n// Long Entry\nif (longEntry)\n    strategy.entry(\"Long\", strategy.long)\n\n// Short Entry\nif (shortEntry)\n    strategy.entry(\"Short\", strategy.short)\n\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n// Target Conditions (Common)\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\ntargetHit = ta.cross(ema9, ema200) or (ema9 == ema200)\n\n// Exit Long at Target\nif (strategy.position_size > 0 and targetHit)\n    strategy.close(\"Long\")\n\n// Exit Short at Target\nif (strategy.position_size < 0 and targetHit)\n    strategy.close(\"Short\")\n\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n// Stoploss (Swing High / Low)\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n// Long SL = Swing Low\nif (strategy.position_size > 0 and SL_long)\n    strategy.exit(\"SL Long\", from_entry=\"Long\", stop=SL_long)\n\n// Short SL = Swing High\nif (strategy.position_size < 0 and SL_short)\n    strategy.exit(\"SL Short\", from_entry=\"Short\", stop=SL_short)\n"
  },
  {
    "url": "zZX7ATK4-Profitable-Pair-Correlation-Divergence-Scanner-v6",
    "name": "Profitable Pair Correlation Divergence Scanner v6",
    "description": "This strategy identifies divergence opportunities between two correlated assets using a combination of Z-Score spread analysis, trend confirmation, RSI & MACD momentum checks, correlation filters, and ATR-based stop-loss/take-profit management. Itâ€™s optimized for positive P&L and realistic trade execution.\n\n Key Features: \n Pair Divergence Detection: \nMeasures deviation between returns of two assets and identifies overbought/oversold spread conditions using Z-Score.\n\n Trend Alignment: \nTrades only in the direction of the primary assetâ€™s trend using a fast EMA vs slow EMA filter.\n\n Momentum Confirmation: \nConfirms trades with RSI and MACD to reduce false signals.\n\n Correlation Filter: \nEnsures the pair is strongly correlated before taking trades, avoiding noisy signals.\n\n Risk Management: \nDynamic ATR-based stop-loss and take-profit ensures proper reward-to-risk ratio.\n\n Exit Conditions: \nAutomatically closes positions when Z-Score normalizes, or ATR-based exits are hit.\n\n How It Works: \n Calculate Returns: \nComputes returns for both assets over the selected timeframe.\n\n Z-Score Spread: \nCalculates the spread between returns and normalizes it using moving average and standard deviation.\n\n Trend Filter: \nOnly takes long trades if the fast EMA is above the slow EMA, and short trades if the fast EMA is below the slow EMA.\n\n Momentum Confirmation: \nConfirms trade direction with RSI (>50 for longs, <50 for shorts) and MACD alignment.\n\n Correlation Check: \nEnsures the pairâ€™s recent correlation is strong enough to validate divergence signals.\n\n Trade Execution: \nOpens positions when Z-Score crosses thresholds and all conditions align. Positions close when Z-Score normalizes or ATR-based SL/TP is hit.\n\n Plot Explanation: \n \n Z-Score: Blue line shows divergence magnitude.\n Entry Levels: Red/Green lines mark long/short thresholds.\n Exit Zone: Gray lines show normalization zone.\n EMA Trend Lines: Purple (fast), Orange (slow) for trend alignment.\n Correlation: Teal overlay shows current correlation strength.\n \n Usage Tips: \n \n Use highly correlated pairs for best results (e.g., EURUSD/GBPUSD).\n Run on higher timeframe charts (1h or 4h) to reduce noise.\n Adjust ATR multiplier based on volatility to avoid premature stops.\n Combine with alerts for automated notifications or webhook execution.\n \n Conclusion: \nThe Profitable Pair Correlation Divergence Scanner v6 is designed for traders who want systematic, low-risk, positive P&L trading opportunities with minimal manual monitoring. By combining trend alignment, momentum confirmation, correlation filters, and dynamic exits, it reduces false signals and improves execution reliability.\n\nRun it on TradingView and watch how it captures divergence opportunities while maintaining positive P&L across trades.\n",
    "image_url": "zZX7ATK4",
    "author": "AIScripts",
    "likes": 9,
    "type": "strategy",
    "created": "2025-12-08",
    "updated": "2025-12-08",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// Â© AIScripts\n//@version=6\nstrategy(\"Profitable Pair Correlation Divergence Scanner v6\", \n     overlay=false,\n     initial_capital=10000,\n     default_qty_type=strategy.percent_of_equity,\n     default_qty_value=10,\n     commission_type=strategy.commission.percent,\n     commission_value=0.02)\n\n// INPUTS\nsym1     = input.symbol(\"OANDA:EURUSD\", \"Primary Asset\")\nsym2     = input.symbol(\"OANDA:GBPUSD\", \"Secondary Asset\")\ncorrLen  = input.int(50, \"Correlation Length\")       \nzLen     = input.int(30, \"Z-Score Length\")          \nentryZ   = input.float(1.0, \"Z Entry Threshold\")\nexitZ    = input.float(0.1, \"Z Exit Threshold\")\natrLen   = input.int(14, \"ATR Length\")\natrMult  = input.float(1.5, \"ATR Multiplier for SL/TP\")\nfastEMA  = input.int(20, \"Fast EMA\")\nslowEMA  = input.int(50, \"Slow EMA\")\nrsiLen   = input.int(14, \"RSI Length\")\nmacdFast = input.int(12, \"MACD Fast Length\")\nmacdSlow = input.int(26, \"MACD Slow Length\")\nmacdSig  = input.int(9,  \"MACD Signal Length\")\n\n// DATA\ns1 = request.security(sym1, timeframe.period, close)\ns2 = request.security(sym2, timeframe.period, close)\n\n// RETURNS\nret1 = ta.roc(s1, 1)\nret2 = ta.roc(s2, 1)\n\n// NORMALIZED SPREAD\nspread = ret1 - ret2\nspreadMA = ta.sma(spread, zLen)\nspreadSD = ta.stdev(spread, zLen)\nzScore   = (spread - spreadMA) / spreadSD\n\n// TREND FILTER\nemaFast = ta.ema(s1, fastEMA)\nemaSlow = ta.ema(s1, slowEMA)\ntrendLong  = emaFast > emaSlow\ntrendShort = emaFast < emaSlow\n\n// RSI CONFIRMATION\nrsiVal = ta.rsi(s1, rsiLen)\nrsiLong  = rsiVal > 50\nrsiShort = rsiVal < 50\n\n// MACD CONFIRMATION\n[macdLine, signalLine, _] = ta.macd(s1, macdFast, macdSlow, macdSig)\nmacdLong  = macdLine > signalLine\nmacdShort = macdLine < signalLine\n\n// CORRELATION FILTER\ncorrVal = ta.correlation(ret1, ret2, corrLen)\ncorrFilter = corrVal > 0.5\n\n// ATR FOR SL/TP\natrVal = ta.atr(atrLen)\nsl = atrVal * atrMult\ntp = atrVal * atrMult * 2  // reward > risk\n\n// ENTRY CONDITIONS\nlongCond  = zScore < -entryZ and trendLong and rsiLong and macdLong and corrFilter\nshortCond = zScore >  entryZ and trendShort and rsiShort and macdShort and corrFilter\n\nexitLong  = math.abs(zScore) < exitZ\nexitShort = math.abs(zScore) < exitZ\n\n// EXECUTION\nif (longCond)\n    strategy.entry(\"LongSpread\", strategy.long)\nif (shortCond)\n    strategy.entry(\"ShortSpread\", strategy.short)\nif (exitLong)\n    strategy.close(\"LongSpread\")\nif (exitShort)\n    strategy.close(\"ShortSpread\")\n\n// ATR-BASED EXIT\nstrategy.exit(\"Exit Long\",  \"LongSpread\", stop=close - sl, limit=close + tp)\nstrategy.exit(\"Exit Short\", \"ShortSpread\", stop=close + sl, limit=close - tp)\n\n// PLOTTING\nplot(zScore, \"Z-Score\", color=color.new(color.blue, 0))\nhline( entryZ,  \"Upper Entry\", color=color.red)\nhline(-entryZ, \"Lower Entry\", color=color.green)\nhline( exitZ,  \"Exit Zone\",   color=color.gray)\nhline(-exitZ,  \"Exit Zone\",   color=color.gray)\nplot(emaFast, \"Fast EMA\", color=color.new(color.purple, 0))\nplot(emaSlow, \"Slow EMA\", color=color.new(color.orange, 0))\nplot(corrVal, \"Correlation\", color=color.new(color.teal, 40))\n\n"
  },
  {
    "url": "rCka05vA-specific-breakout-FiFTO",
    "name": "specific breakout FiFTO",
    "description": "Strategy Description: 10:14 Breakout Only\nOverview This is a time-based intraday trading strategy designed to capture momentum bursts that occur specifically after the 10:14 AM candle closes. It operates on the logic that if price breaks the high of this specific candle within a short window, a trend continuation is likely.\n\nCore Logic & Rules\n\nThe Setup Candle (10:14 AM)\n\nThe strategy waits specifically for the minute candle at 10:14 to complete.\n\nOnce this candle closes, the strategy records its High price.\n\nDefining the Entry Level\n\nIt calculates a trigger price by taking the 10:14 High and adding a user-defined Buffer (e.g., +1 point).\n\nFormula: Entry Level = 10:14 High + Buffer\n\nThe \"Active Window\" (Expiry)\n\nThe trade setup does not remain open all day. It has a strict time limit.\n\nBy default, the setup is valid from 10:15 to 10:20.\n\nIf the price does not break the Entry Level by the expiry time (default 10:20), the setup is cancelled and no trade is taken for the day.\n\nEntry Trigger\n\nIf a candle closes above the Entry Level while the window is open, a Long (Buy) position is opened immediately.\n\nExits (Risk Management)\n\nStop Loss: A fixed number of points below the entry price.\n\nTarget: A fixed number of points above the entry price.\n\nVisual & Automation Features\n\nVisual Boxes: Upon entry, the strategy draws a \"Long Position\" style visual on the chart. A green box highlights the profit zone, and a red box highlights the loss zone. These boxes extend automatically until the trade closes.\n\nJSON Alerts: The strategy is pre-configured to send data-rich alerts for automation (e.g., Telegram bots).\n\nEntry Alert: Includes Symbol, Entry Price, SL, and TP.\n\nExit Alerts: Specific messages for \"Target Hit\" or \"SL Hit\".\n\nSummary of User Inputs\n\nEntry Buffer: Extra points added to the high to filter false breaks.\n\nFixed Stop Loss: Risk per trade in points.\n\nFixed Target: Reward per trade in points.\n\nExpiry Minute: The minute (10:xx) at which the setup becomes invalid if not triggered.",
    "image_url": "rCka05vA",
    "author": "official_fifto",
    "likes": 5,
    "type": "strategy",
    "created": "2025-12-08",
    "updated": "2025-12-08",
    "source": "//@version=5\r\nstrategy(\"10:14 Breakout Only (Visuals + Alerts)\", overlay=true, process_orders_on_close=true)\r\n\r\n// --- INPUTS ---\r\ngrp_strat = \"Strategy Settings\"\r\nbuffer_pts = input.float(1.0, \"Entry Buffer (Rs)\", group=grp_strat)\r\nsl_pts = input.float(10.0, \"Fixed Stop Loss (Pts)\", group=grp_strat)\r\ntp_pts = input.float(15.0, \"Fixed Target (Pts)\", group=grp_strat)\r\nexpiryMin = input.int(20, \"Expiry Minute (10:xx)\", minval=15, maxval=59, group=grp_strat, tooltip=\"If entry doesn't happen by 10:xx, cancel setup\")\r\n\r\n// --- VARIABLES ---\r\nvar float refHigh = na\r\nvar float entryLevel = na\r\nvar bool windowOpen = false\r\n\r\n// Variables for Visual Boxes (Long Position Tool)\r\nvar box profitBox = na\r\nvar box lossBox = na\r\nvar bool inTrade = false\r\n\r\n// --- TIME LOGIC (10:14 ONLY) ---\r\n// We only check for the 10:14 candle now\r\nbool isSetup = (hour == 10 and minute == 14)\r\n\r\nif isSetup\r\n    refHigh := high\r\n    entryLevel := refHigh + buffer_pts\r\n    windowOpen := true\r\n    // Visual Line for Trigger\r\n    line.new(bar_index, entryLevel, bar_index + 10, entryLevel, color=color.new(color.blue, 50), style=line.style_dashed)\r\n\r\n// --- EXPIRY LOGIC ---\r\n// Expiry for 10:14 setup -> Closes at User Defined Minute (e.g., 10:20)\r\nif (hour == 10 and minute >= expiryMin)\r\n    windowOpen := false\r\n\r\n// --- ENTRY LOGIC ---\r\nif windowOpen and ta.crossover(close, entryLevel) and strategy.position_size == 0\r\n    \r\n    // Calculate Levels\r\n    float entryPrice = close\r\n    float stopPrice = entryPrice - sl_pts\r\n    float targetPrice = entryPrice + tp_pts\r\n    \r\n    // 1. Prepare Alert Message (JSON format for Telegram)\r\n    string alertMsg = '{\"type\": \"ENTRY\", \"symbol\": \"' + syminfo.ticker + '\", \"price\": \"' + str.tostring(entryPrice) + '\", \"sl\": \"' + str.tostring(stopPrice) + '\", \"tp\": \"' + str.tostring(targetPrice) + '\"}'\r\n\r\n    // 2. Execute Entry\r\n    strategy.entry(\"Long\", strategy.long, alert_message=alertMsg)\r\n    \r\n    // 3. Set Exits with specific Alert Messages\r\n    string tpMsg = '{\"type\": \"TARGET HIT\", \"symbol\": \"' + syminfo.ticker + '\", \"price\": \"' + str.tostring(targetPrice) + '\"}'\r\n    string slMsg = '{\"type\": \"SL HIT\", \"symbol\": \"' + syminfo.ticker + '\", \"price\": \"' + str.tostring(stopPrice) + '\"}'\r\n    \r\n    strategy.exit(\"Bracket\", \"Long\", stop=stopPrice, limit=targetPrice, alert_message=tpMsg)\r\n\r\n    // 4. DRAW LONG POSITION TOOL (Visuals)\r\n    // Profit Box (Green)\r\n    profitBox := box.new(left=bar_index, top=targetPrice, right=bar_index + 5, bottom=entryPrice, border_color=color.green, bgcolor=color.new(color.green, 80))\r\n    // Loss Box (Red)\r\n    lossBox := box.new(left=bar_index, top=entryPrice, right=bar_index + 5, bottom=stopPrice, border_color=color.red, bgcolor=color.new(color.red, 80))\r\n    \r\n    windowOpen := false\r\n    inTrade := true\r\n\r\n// --- VISUAL UPDATES ---\r\n// If we are in a trade, extend the visual boxes to the current candle\r\nif strategy.position_size > 0 and inTrade\r\n    box.set_right(profitBox, bar_index + 1)\r\n    box.set_right(lossBox, bar_index + 1)\r\nelse\r\n    inTrade := false\r\n\r\n// --- PLOTTING ---\r\nplot(strategy.position_size > 0 ? strategy.opentrades.entry_price(strategy.opentrades - 1) + tp_pts : na, \"Target\", color=color.green, style=plot.style_linebr)\r\nplot(strategy.position_size > 0 ? strategy.opentrades.entry_price(strategy.opentrades - 1) - sl_pts : na, \"SL\", color=color.red, style=plot.style_linebr)"
  },
  {
    "url": "qiYGOp28",
    "name": "BTC Dynamic Volatility Trend ",
    "description": "Backtested from 2017 to present, this strategy has delivered a staggering 7100%+ cumulative return. It doesn't just track the market; it dominates it. By capturing major trends and strictly limiting drawdowns, it has significantly outperformed the standard 'Buy & Hold' BTC strategy, proving its ability to generate massive alpha across multiple bull and bear cycles.\n\nè‡ª 2017 å¹´è‡³ä»Šï¼Œæœ¬ç­–ç•¥å®žçŽ°äº†æƒŠäººçš„ 7100%+ ç´¯è®¡æ”¶ç›ŠçŽ‡ã€‚å®ƒä¸ä»…ä»…æ˜¯è·Ÿéšå¸‚åœºï¼Œæ›´æ˜¯è¶…è¶Šäº†å¸‚åœºã€‚é€šè¿‡ç²¾å‡†æ•æ‰ä¸»å‡æµªå¹¶ä¸¥æ ¼æŽ§åˆ¶å›žæ’¤ï¼Œè¯¥ç­–ç•¥åœ¨ç©¿è¶Šå¤šè½®ç‰›ç†Šå‘¨æœŸåŽï¼Œå¤§å¹…åº¦è·‘èµ¢äº†æ¯”ç‰¹å¸â€˜ä¹°å…¥æŒæœ‰â€™ï¼ˆBuy & Holdï¼‰çš„åŸºå‡†æ”¶ç›Šï¼Œå±•çŽ°äº†æžè‡´çš„é˜¿å°”æ³•ï¼ˆAlphaï¼‰æ•æ‰èƒ½åŠ›ã€‚\"\n\n Introduction  ï¼šSimplicity is the ultimate sophistication. This strategy is designed specifically for Bitcoin (BTC), capturing its unique characteristics: high volatility, frequent fakeouts, and massive trend persistence. It abandons complex indicators in favor of a robust logic: \"Follow the Trend, Filter the Noise, Let Profits Run.\"\n\nCore Logic\n\nTrend Filter (Fibonacci EMA 144): We use the 144-period Exponential Moving Average as the baseline. Longs are only taken above this line, and shorts only below. This keeps you on the right side of the major trend.\n\nVolatility Breakout (Donchian Channel 20): Entries are triggered only when price breaks the 20-day high (for longs) or low (for shorts). This confirms momentum and avoids trading in chop.\n\nDynamic Risk Management (ATR Chandelier Exit):\n\nInstead of fixed % stops, we use Average True Range (ATR) to calculate stop losses.\n\nThe Ratchet Mechanism: The stop loss moves up with the price but never moves down (for longs). This locks in profits automatically as the trend develops and exits immediately when volatility turns against you.\n\nWhy Use This Strategy?\n\nZero Repainting: All signals are confirmed.\n\nNo Curve Fitting: Uses classic parameters (144, 20) that have worked for decades.\n\nMental Peace: The strategy handles the exit. You don't need to guess where to sell. It holds through minor corrections and exits only when the trend truly reverses.\n\nSettings\n\nLeverage %: Adjust your position size based on equity (default 100% = 1x).\n\nTimeframe: Recommended for 4H charts.\n\nä¸­æ–‡ç‰ˆ (Chinese Version)\n\n ç®€ä»‹  ï¼šå¤§é“è‡³ç®€ã€‚æœ¬ç­–ç•¥ä¸“ä¸º æ¯”ç‰¹å¸ (BTC) è®¾è®¡ï¼Œé’ˆå¯¹å…¶é«˜æ³¢åŠ¨ã€å‡çªç ´å¤šä½†è¶‹åŠ¿çˆ†å‘åŠ›å¼ºçš„ç‰¹ç‚¹ï¼Œæ‘’å¼ƒäº†å¤æ‚çš„è¿‡åº¦æ‹ŸåˆæŒ‡æ ‡ï¼Œå›žå½’äº¤æ˜“æœ¬è´¨ï¼šâ€œé¡ºå¤§åŠ¿ï¼Œæ»¤å™ªéŸ³ï¼Œæˆªæ–­äºæŸï¼Œè®©åˆ©æ¶¦å¥”è·‘â€ã€‚\n\næ ¸å¿ƒé€»è¾‘\n\nè¶‹åŠ¿è¿‡æ»¤å™¨ (æ–æ³¢é‚£å¥‘ EMA 144)ï¼š ä½¿ç”¨ 144 å‘¨æœŸæŒ‡æ•°ç§»åŠ¨å¹³å‡çº¿ä½œä¸ºå¤šç©ºåˆ†æ°´å²­ã€‚ä»·æ ¼åœ¨å‡çº¿ä¹‹ä¸Šåªåšå¤šï¼Œä¹‹ä¸‹åªåšç©ºã€‚è¿™èƒ½æœ‰æ•ˆè¿‡æ»¤æŽ‰å¤§éƒ¨åˆ†éœ‡è¡å¸‚çš„å™ªéŸ³ã€‚\n\næ³¢åŠ¨çŽ‡çªç ´ (å”å¥‡å®‰é€šé“ 20)ï¼š åªæœ‰å½“ä»·æ ¼çªç ´è¿‡åŽ» 20 æ ¹ K çº¿çš„æœ€é«˜ä»·ï¼ˆåšå¤šï¼‰æˆ–æœ€ä½Žä»·ï¼ˆåšç©ºï¼‰æ—¶æ‰è¿›åœºã€‚è¿™ç¡®ä¿äº†æˆ‘ä»¬åªåœ¨è¶‹åŠ¿ç¡®ç«‹çš„çž¬é—´å…¥åœºã€‚\n\nåŠ¨æ€é£ŽæŽ§ (ATR åŠç¯æ­¢æŸ)ï¼š\n\næ‹’ç»å›ºå®šç‚¹æ•°æ­¢æŸï¼Œä½¿ç”¨ ATRï¼ˆå¹³å‡çœŸå®žæ³¢å¹…ï¼‰æ ¹æ®å¸‚åœºçƒ­åº¦åŠ¨æ€è®¡ç®—å®‰å…¨è·ç¦»ã€‚\n\næ£˜è½®æœºåˆ¶ï¼š æ­¢æŸçº¿ä¼šè·Ÿéšä»·æ ¼ä¸Šæ¶¨è€Œä¸Šç§»ï¼Œä½†ç»ä¸ä¼šä¸‹ç§»ï¼ˆåšå¤šæ—¶ï¼‰ã€‚è¿™å®žçŽ°äº†è‡ªåŠ¨åŒ–çš„â€œåˆ©æ¶¦é”å®šâ€ï¼Œæ—¢èƒ½æ‰›ä½æ­£å¸¸çš„æ³¢åŠ¨å›žè°ƒï¼Œåˆèƒ½åœ¨å¤§åŠ¿åè½¬æ—¶æžœæ–­ç¦»åœºã€‚\n\nç­–ç•¥ä¼˜åŠ¿\n\nç»ä¸é‡ç»˜ï¼š æ‰€æœ‰ä¿¡å·å‡ä¸ºæ”¶ç›˜ç¡®è®¤æˆ–å®žæ—¶è§¦ä»·ã€‚\n\næ‹’ç»æ‹Ÿåˆï¼š ä½¿ç”¨ç»è¿‡æ•°åå¹´å¸‚åœºéªŒè¯çš„ç»å…¸å‚æ•°ç»„åˆã€‚\n\nå¿ƒæ€ç®¡ç†ï¼š ç­–ç•¥å…¨è‡ªåŠ¨ç®¡ç†å‡ºåœºã€‚ä½ ä¸éœ€è¦çº ç»“ä½•æ—¶æ­¢ç›ˆï¼Œå®ƒä¼šå¸®ä½ åƒåˆ°å®Œæ•´çš„é±¼èº«ï¼Œç›´åˆ°è¶‹åŠ¿ç»“æŸã€‚\n\nä½¿ç”¨å»ºè®®\n\nèµ„é‡‘ç®¡ç†ï¼š å¯é€šè¿‡å‚æ•°è°ƒæ•´ä»“ä½å æ¯”ï¼ˆé»˜è®¤ 100% = 1å€æ æ†ï¼‰ã€‚\n\næŽ¨èå‘¨æœŸï¼š å»ºè®®åœ¨4å°æ—¶ å›¾è¡¨ä¸Šè¿è¡Œæ•ˆæžœæœ€ä½³ã€‚",
    "image_url": "qiYGOp28",
    "author": "GinsTradingRoom",
    "likes": 14,
    "type": "strategy",
    "created": "2025-12-08",
    "updated": "2025-12-08",
    "source": "//@version=5\r\n// Strategy Name: BTC Dynamic Volatility Trend [U-Standard]\r\n// Description: A pure trend-following strategy based on EMA144 and Donchian Breakout with ATR Trailing Stop.\r\nstrategy(\"BTC Dynamic Volatility Trend [Gemini Design]\", overlay=true, initial_capital=10000, default_qty_type=strategy.cash, currency=currency.USD, margin_long=25, margin_short=25, pyramiding=1)\r\n\r\n// ==========================================\r\n// 1. Settings\r\n// ==========================================\r\n// Hidden Mode Selection: Forced to U-Standard for Public Release\r\nenableCoinM = false \r\n\r\nleveragePct = input.float(100.0, title=\"Leverage % (100 = 1x)\", minval=1.0, step=10.0, group=\"Money Management\")\r\n\r\n// --- Strategy Parameters ---\r\nemaLen = input.int(144, minval=1, title=\"Trend Filter (EMA)\", group=\"Strategy Logic\")\r\nlookback = input.int(20, minval=1, title=\"Breakout Period (Donchian)\", group=\"Strategy Logic\")\r\natrLength = input.int(14, minval=1, title=\"ATR Length\", group=\"Strategy Logic\")\r\natrMult = input.float(3.0, minval=0.1, step=0.1, title=\"ATR Multiplier\", group=\"Strategy Logic\")\r\ntradeDirection = input.string(\"Both\", options=[\"Both\", \"Long Only\", \"Short Only\"], title=\"Trade Direction\", group=\"Strategy Logic\")\r\n\r\n// ==========================================\r\n// 2. Indicators & Logic\r\n// ==========================================\r\ntrendEMA = ta.ema(close, emaLen)\r\nhighestHigh = ta.highest(high, lookback)[1]\r\nlowestLow = ta.lowest(low, lookback)[1]\r\natrValue = ta.atr(atrLength)\r\n\r\nisBullish = close > trendEMA\r\nisBearish = close < trendEMA\r\n\r\nlongCondition = isBullish and close > highestHigh\r\nshortCondition = isBearish and close < lowestLow\r\n\r\n// ==========================================\r\n// 3. Dynamic Trailing Stop\r\n// ==========================================\r\nvar float stopPrice = na\r\n\r\n// Calculate stop only if we have a position or signal\r\nbool hasStrategyPos = strategy.position_size != 0\r\n\r\nif hasStrategyPos\r\n    if strategy.position_size > 0\r\n        newStop = close - (atrValue * atrMult)\r\n        stopPrice := math.max(nz(stopPrice, newStop), newStop)\r\n    else\r\n        newStop = close + (atrValue * atrMult)\r\n        stopPrice := math.min(nz(stopPrice, newStop), newStop)\r\nelse\r\n    stopPrice := na\r\n\r\n// ==========================================\r\n// 4. Execution (Pure U-Standard Engine)\r\n// ==========================================\r\ncurrentEquity = strategy.equity\r\ntradeQty = (currentEquity * (leveragePct / 100.0)) / close\r\n\r\n// Entry Logic\r\nif (tradeDirection == \"Both\" or tradeDirection == \"Long Only\")\r\n    if longCondition and strategy.position_size == 0\r\n        strategy.entry(\"Long\", strategy.long, qty=tradeQty, comment=\"Breakout\")\r\n        stopPrice := close - (atrValue * atrMult) // Initialize Stop\r\n\r\nif (tradeDirection == \"Both\" or tradeDirection == \"Short Only\")\r\n    if shortCondition and strategy.position_size == 0\r\n        strategy.entry(\"Short\", strategy.short, qty=tradeQty, comment=\"Breakout\")\r\n        stopPrice := close + (atrValue * atrMult)\r\n\r\n// Exit Logic (Zero-Latency Hard Stop)\r\nif strategy.position_size > 0\r\n    strategy.exit(\"Exit Long\", \"Long\", stop=stopPrice, comment=\"Trailing Stop\")\r\n\r\nif strategy.position_size < 0\r\n    strategy.exit(\"Exit Short\", \"Short\", stop=stopPrice, comment=\"Trailing Stop\")\r\n\r\n// ==========================================\r\n// 5. Visuals\r\n// ==========================================\r\nplot(trendEMA, color=color.new(color.yellow, 0), title=\"EMA 144 Trend\")\r\nplot(strategy.position_size != 0 ? stopPrice : na, color=strategy.position_size > 0 ? color.red : color.green, style=plot.style_circles, title=\"Trailing Stop\")"
  },
  {
    "url": "fn7TGlaI-US-Market-Long-Horizon-Momentum",
    "name": "US Market Long Horizon Momentum ",
    "description": "Summary in one paragraph\n US Market Long Horizon Momentum  is a trend following strategy for US index ETFs and futures built around a single eighteen month time series momentum measure. It helps you stay long during persistent bull regimes and step aside or flip short when long term momentum turns negative. \n\n Scope and intent\n â€¢ Markets. Large cap US equity indices, liquid US index ETFs, index futures\nâ€¢ Timeframes. 4h/ Daily charts \nâ€¢ Default demo used in the publication. SPY on 4h timeframe chart\nâ€¢ Purpose. Provide a minimal long bias index timing model that can reduce deep drawdowns and capture major cycles without parameter mining\nâ€¢ Limits. This is a strategy. Orders are simulated on standard candles only\n\n Originality and usefulness\n â€¢ Unique concept or fusion. One unscaled multiple month log return of an external benchmark symbol drives all entries and exits, with optional volatility targeting as a single risk control switch.\nâ€¢ Failure mode addressed. Fully passive buy and hold ignores the sign of long horizon momentum and can sit through multi year drawdowns. This script offers a way to step down risk in prolonged negative momentum without chasing short term noise.\nâ€¢ Testability. All parameters are visible in Inputs and the momentum series is plotted so users can verify every regime change in the Tester and on price history.\nâ€¢ Portable yardstick. The log return over a fixed window is a unit that can be applied to any liquid symbol with daily data.\n\n\n Method overview in plain language\n The method looks at how far the benchmark symbol has moved in log return terms over an eighteen month window in our example. If that long horizon return is positive the strategy allows a long stance on the traded symbol. If it is negative and shorts are enabled the strategy can flip short, otherwise it goes flat. There is an optional realised volatility estimate on the traded symbol that can scale position size toward a target annual volatility, but in the default configuration the model uses unit leverage and only the sign of momentum matters.\n\n Base measures\n Return basis. The core yardstick is the natural log of close divided by the close eighteen months ago on the benchmark symbol. Daily log returns of the traded symbol feed the realised volatility estimate when volatility targeting is enabled.\n\n Components\n â€¢ Component one Momentum eighteen months. Log of benchmark close divided by its close mom_lookback bars ago. Its sign defines the trend regime. No extra smoothing is applied beyond the long window itself.\nâ€¢ Component two Realised volatility optional. Standard deviation of daily log returns on the traded symbol over sixty three days. Annualised by the square root of 252. Used only when volatility targeting is enabled.\nâ€¢ Optional component Volatility targeting. Converts target annual volatility and realised volatility into a leverage factor clipped by a maximum leverage setting.\n\n Fusion rule\n The model uses a simple gate. First compute the sign of eighteen month log momentum on the benchmark symbol. Optionally compute leverage from volatility. The sign decides whether the strategy wants to be long, short, or flat. Leverage only rescales position size when enabled and does not change direction.\n\n Signal rule\n â€¢ Long suggestion. When eighteen month log momentum on the benchmark symbol is greater than zero, the strategy wants to be long.\nâ€¢ Short suggestion. When that log momentum is less than zero and shorts are allowed, the strategy wants to be short. If shorts are disabled it stays flat instead.\nâ€¢ Wait state. When the log momentum is exactly zero or history is not long enough the strategy stays flat.\nâ€¢ In position. In practice the strategy sits IN LONG while the sign stays positive and flips to IN SHORT or flat only when the sign changes.\n\n Inputs with guidance\n Setup\nâ€¢ Momentum Lookback (months). Controls the horizon of the log return on the benchmark symbol. Typical range 6 to 24 months. Raising it makes the model slower and more selective. Lowering it makes it more reactive and sensitive to medium term noise.\nâ€¢ Symbol. External symbol used for the momentum calculation, SPY by default. Changing it lets you time other indices or run signals from a benchmark while trading a correlated instrument.\n\nLogic\nâ€¢ Allow Shorts. When true the strategy will open short positions during negative momentum regimes. When false it will stay flat whenever momentum is negative. Practical setting is tied to whether you use a margin account or an ETF that supports shorting.\n\nInternal risk parameters (not exposed as inputs in this version) are:\nâ€¢ Target Vol (annual). Target annual volatility for volatility targeting, default 0.2.\nâ€¢ Vol Lookback (days). Window for realised volatility, default 63 trading days.\nâ€¢ Max Leverage. Cap on leverage when volatility targeting is enabled, default 2.\n\n\n Usage recipes\n \nSwing continuation\nâ€¢ Signal timeframe. Use the daily chart.\nâ€¢ Benchmark symbol. Leave at SPY for US equity index exposure.\nâ€¢ Momentum lookback. Eighteen months as a default, with twelve months as an alternative preset for a faster swing bias.\n\n\n Properties visible in this publication\n â€¢ Initial capital. 100000\nâ€¢ Base currency. USD\nâ€¢ Default order size method. 5% of the total capital in this example\nâ€¢ Pyramiding. 0\nâ€¢ Commission. 0.03 percent\nâ€¢ Slippage. 3 ticks\nâ€¢ Process orders on close. On\nâ€¢ Bar magnifier. Off\nâ€¢ Recalculate after order is filled. Off\nâ€¢ Calc on every tick. Off\nâ€¢ All request.security calls use lookahead = barmerge.lookahead_off\n\n Realism and responsible publication\n The strategy is for education and research only. It does not claim any guaranteed edge or future performance. All results in Strategy Tester are hypothetical and depend on the data vendor, costs, and slippage assumptions. Intrabar motion is not modeled inside daily bars so extreme moves and gaps can lead to fills that differ from live trading. The logic is built for standard candles and should not be used on synthetic chart types for execution decisions.\nPerformance is sensitive to regime structure in the US equity market, which may change over time. The strategy does not protect against single day crash risk inside bars and does not model gap risk explicitly. Past behavior of SPY and the momentum effect does not guarantee future persistence.\n\n Honest limitations and failure modes\n â€¢ Long sideways regimes with small net change over eighteen months can lead to whipsaw around the zero line.\nâ€¢ Very sharp V shaped reversals after deep declines will often be missed because the model waits for momentum to turn positive again.\nâ€¢ The sample size in a full SPY history is small because regime changes are infrequent, so any test must be interpreted as indicative rather than statistically precise.\nâ€¢ The model is highly dependent on the chosen lookback. Users should test nearby values and validate that behavior is qualitatively stable.\n\n\n Legal\n Education and research only. Not investment advice. You are responsible for your own decisions. Always test on historical data and in simulation with realistic costs before any live use.\n\n",
    "image_url": "fn7TGlaI",
    "author": "exlux",
    "likes": 17,
    "type": "strategy",
    "created": "2025-12-07",
    "updated": "2025-12-07",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0\r\n// Â© exlux\r\n\r\n//@version=6\r\nstrategy(    \"US Long Horizon Momentum\",    overlay = false,    initial_capital = 100000,    commission_type = strategy.commission.percent,    commission_value = 0.03,    pyramiding = 0,    process_orders_on_close = true,    calc_on_every_tick = false)\r\n\r\n// === CONFIG ===\r\ngroup_momentum = \"Momentum\"\r\nlookback_months = input.int(18, \"Momentum Lookback (months)\", minval = 3, maxval = 24, group = group_momentum)\r\n\r\ngroup_risk = \"Risk & Sizing\"\r\nuse_vol_target   = false//input.bool(false, \"Use Volatility Targeting\", group = group_risk)\r\ntarget_vol_annual = 0.2//input.float(0.15, \"Target Vol (annual)\", minval = 0.05, maxval = 0.5, step = 0.01, group = group_risk)\r\nvol_lookback_days = 63//input.int(63, \"Vol Lookback (days)\", minval = 20, maxval = 252, group = group_risk)\r\nmax_leverage      = 2.0//input.float(2.0, \"Max Leverage\", minval = 0.1, maxval = 5.0, group = group_risk)\r\n\r\ngroup_exec = \"Execution\"\r\nallow_shorts = input.bool(false, \"Allow Shorts\", group = group_exec)\r\n\r\nsymbol = input.symbol(\"SPY\")\r\n// === CONSTANTS ===\r\nbars_per_year  = 252.0\r\nbars_per_month = math.round(bars_per_year / 12.0)\r\nmom_lookback   = int(lookback_months * bars_per_month)\r\n\r\n// === HELPER FUNCTIONS ===\r\n\r\n//** * Annualized volatility of daily log returns. */\r\nf_annualized_vol(daily_log_ret, lookback) =>\r\n    float vol_daily  = ta.stdev(daily_log_ret, lookback)\r\n    float vol_annual = vol_daily * math.sqrt(bars_per_year)\r\n    vol_annual\r\n\r\n//** * Target position leverage from annual vol. */\r\nf_target_leverage(target_vol, realized_vol, max_lev) =>\r\n    float lev_raw = realized_vol > 0 ? target_vol / realized_vol : 0.0\r\n    float lev     = math.min(max_lev, lev_raw)\r\n    lev\r\n\r\n// === CALC SECTION ===\r\n\r\n// 1) 12â€‘month log momentum\r\nhave_history = bar_index >= mom_lookback\r\n\r\nfloat mom_log = na\r\nif have_history\r\n    mom_log := request.security(symbol, timeframe.period, math.log(close / close[mom_lookback]),lookahead = barmerge.lookahead_off)\r\n\r\nfloat signal_dir = 0.0\r\nif have_history and not na(mom_log)\r\n    if mom_log > 0\r\n        signal_dir := 1.0\r\n    else if mom_log < 0 and allow_shorts\r\n        signal_dir := -1.0\r\n    else\r\n        signal_dir := 0.0\r\n\r\n// 2) Volatility (optional sizing)\r\ndaily_log_ret = math.log(close / close[1])\r\nrealized_vol  = f_annualized_vol(daily_log_ret, vol_lookback_days)\r\n\r\nfloat leverage = 1.0\r\nif use_vol_target\r\n    leverage := f_target_leverage(target_vol_annual, realized_vol, max_leverage)\r\n\r\n// === RISK / EXECUTION SECTION ===\r\n\r\n// Current position direction\r\npos_dir = strategy.position_size > 0 ? 1.0 : strategy.position_size < 0 ? -1.0 : 0.0\r\n\r\n// Target notional and quantity (rebalance only when direction changes)\r\nfloat equity          = strategy.equity\r\nfloat target_notional = equity * leverage * signal_dir\r\nfloat target_qty      = target_notional / close\r\n\r\nbool new_signal = have_history and barstate.isconfirmed and (signal_dir != pos_dir)\r\n\r\n// Flip or open positions on new signal\r\nif new_signal\r\n    // Close any open position first\r\n    if pos_dir != 0\r\n        strategy.close_all(comment = \"Flip\")\r\n\r\n    // Open new position if nonâ€‘flat signal\r\n    if signal_dir == 1\r\n        strategy.entry(\"Long\", strategy.long)\r\n    else if signal_dir == -1\r\n        strategy.entry(\"Short\", strategy.short, qty = math.abs(target_qty))\r\n\r\n// === PLOTS / UI SECTION ===\r\nplot(mom_log, title = \"12M Log Momentum\", color = mom_log >= 0 ? color.new(color.green, 0) : color.new(color.red, 0))\r\nhline(0.0, \"Momentum Zero\", color = color.gray)\r\n\r\nbgcolor(signal_dir == 1 ? color.new(color.green, 90) : signal_dir == -1 ? color.new(color.red, 90) : na)\r\n"
  },
  {
    "url": "RhGAWDJl-Gold-Mastermind-Pro-v6",
    "name": "Gold Mastermind Pro v6",
    "description": "EMA50 / EMA200 trend (UP / DOWN / FLAT)\nVWAP + ATR + RSI filters for entries\nATR-based stop & 2R target\nRisk-based position sizing with max 5 contracts\nCooldown in bars after each entry\nLong arrows = baby blue, Short arrows = bright orange\nSimple dashboard label showing trend, qty, stop & target",
    "image_url": "RhGAWDJl",
    "author": "yasir12_yc",
    "likes": 5,
    "type": "strategy",
    "created": "2025-12-07",
    "updated": "2025-12-07",
    "source": "//@version=6\r\nstrategy(\r\n     \"Gold Mastermind Pro v6\",\r\n     overlay           = true,\r\n     initial_capital   = 100000,\r\n     default_qty_type  = strategy.cash,\r\n     default_qty_value = 10000,\r\n     max_labels_count  = 50,\r\n     max_lines_count   = 50)\r\n\r\n//======================\r\n// INPUTS\r\n//======================\r\natr_period        = input.int(14,  \"ATR Period\")\r\nema50_period      = input.int(50,  \"EMA50 Period\")\r\nema200_period     = input.int(200, \"EMA200 Period\")\r\n\r\nrsi_period        = input.int(14,  \"RSI Period\")\r\nmin_rsi_long      = input.float(40, \"Min RSI for Long\")\r\nmax_rsi_short     = input.float(60, \"Max RSI for Short\")\r\n\r\natr_multiplier    = input.float(1.5, \"ATR Multiplier\")\r\nreward_multiplier = input.float(2.0, \"Reward / Risk Multiplier\")\r\nvwap_tolerance    = input.float(0.25, \"VWAP Tolerance (price distance)\")\r\ncooldown_bars     = input.int(5,    \"Cooldown (bars after entry)\")\r\n\r\nrisk_per_trade    = input.float(50,   \"Risk per Trade ($)\")\r\ntick_value        = input.float(10.0, \"Dollar Value per 1.0 price move\")\r\nmax_contracts     = input.int(5,      \"Max Contracts per Trade\")\r\n\r\nshow_dashboard    = input.bool(true, \"Show Dashboard\")\r\n\r\n//======================\r\n// INDICATORS\r\n//======================\r\nema50    = ta.ema(close, ema50_period)\r\nema200   = ta.ema(close, ema200_period)\r\nrsi_val  = ta.rsi(close, rsi_period)\r\natr_val  = ta.atr(atr_period)\r\nvwap_val = ta.vwap(hlc3)\r\n\r\n// plot EMAs and VWAP\r\nplot(ema50,  color = color.blue,   linewidth = 2, title = \"EMA50\")\r\nplot(ema200, color = color.orange, linewidth = 2, title = \"EMA200\")\r\nplot(vwap_val, color = color.purple, linewidth = 2, title = \"VWAP\")\r\n\r\n//======================\r\n// TREND & SIGNALS\r\n//======================\r\ntrend =\r\n     ema50 > ema200 ? \"UP\"   :\r\n     ema50 < ema200 ? \"DOWN\" :\r\n     \"FLAT\"\r\n\r\nnear_vwap_long  = math.abs(close - vwap_val) <= vwap_tolerance\r\nnear_ema50_long = math.abs(close - ema50)    <= atr_val * 0.5\r\n\r\nnear_vwap_short  = near_vwap_long\r\nnear_ema50_short = near_ema50_long\r\n\r\nlong_condition =\r\n     trend == \"UP\" and\r\n     (near_vwap_long or near_ema50_long) and\r\n     rsi_val > min_rsi_long\r\n\r\nshort_condition =\r\n     trend == \"DOWN\" and\r\n     (near_vwap_short or near_ema50_short) and\r\n     rsi_val < max_rsi_short\r\n\r\n// stop & target based on ATR\r\nlong_stop   = long_condition  ? close - atr_val * atr_multiplier                           : na\r\nlong_target = long_condition  ? close + atr_val * atr_multiplier * reward_multiplier       : na\r\nshort_stop  = short_condition ? close + atr_val * atr_multiplier                           : na\r\nshort_target= short_condition ? close - atr_val * atr_multiplier * reward_multiplier       : na\r\n\r\n//======================\r\n// RISK-BASED QTY FUNCTION\r\n//======================\r\nf_calc_qty(entry, stop) =>\r\n    per_contract_risk = math.abs(entry - stop) * tick_value\r\n    qty = per_contract_risk > 0 ? math.floor(risk_per_trade / per_contract_risk) : 1\r\n    qty := math.max(qty, 1)\r\n    qty := math.min(qty, max_contracts)\r\n    qty\r\n\r\nlong_qty  = long_condition  ? f_calc_qty(close, long_stop)  : 0\r\nshort_qty = short_condition ? f_calc_qty(close, short_stop) : 0\r\n\r\n//======================\r\n// COOLDOWN LOGIC\r\n//======================\r\nvar int last_entry_bar = na\r\n\r\ncooldown_active = not na(last_entry_bar) and (bar_index - last_entry_bar) < cooldown_bars\r\ncan_trade       = not cooldown_active and strategy.position_size == 0\r\n\r\n//======================\r\n// ORDER EXECUTION\r\n//======================\r\nif can_trade\r\n    if long_condition and long_qty > 0\r\n        strategy.entry(\"Long\", strategy.long, qty = long_qty)\r\n        strategy.exit(\"Long TP/SL\", from_entry = \"Long\", stop = long_stop, limit = long_target)\r\n        last_entry_bar := bar_index\r\n\r\n    if short_condition and short_qty > 0\r\n        strategy.entry(\"Short\", strategy.short, qty = short_qty)\r\n        strategy.exit(\"Short TP/SL\", from_entry = \"Short\", stop = short_stop, limit = short_target)\r\n        last_entry_bar := bar_index\r\n\r\n//======================\r\n// TREND BACKGROUND\r\n//======================\r\nbgcolor(\r\n     trend == \"UP\"   ? color.new(color.aqua,   85) :\r\n     trend == \"DOWN\" ? color.new(color.orange, 85) :\r\n     na)\r\n\r\n//======================\r\n// SIGNAL ARROWS\r\n//======================\r\nplotshape(\r\n     long_condition and can_trade,\r\n     title     = \"Long Arrow\",\r\n     location  = location.belowbar,\r\n     color     = color.new(color.aqua, 0),\r\n     style     = shape.arrowup,\r\n     size      = size.small)\r\n\r\nplotshape(\r\n     short_condition and can_trade,\r\n     title     = \"Short Arrow\",\r\n     location  = location.abovebar,\r\n     color     = color.new(color.orange, 0),\r\n     style     = shape.arrowdown,\r\n     size      = size.small)\r\n\r\n// ======================\r\n// DASHBOARD LABEL\r\n// ======================\r\nvar label dash = na\r\n\r\nif show_dashboard and barstate.islast\r\n    if na(dash)\r\n        // create label one time\r\n        dash := label.new(bar_index, high, \"\",\r\n             xloc = xloc.bar_index,\r\n             yloc = yloc.abovebar,\r\n             style = label.style_label_left,\r\n             color = color.new(color.gray, 85),\r\n             textcolor = color.white,\r\n             size = size.normal)\r\n\r\n    // build dashboard text\r\n    txt = \"Trend: \" + trend + \"\\n\" +\r\n          \"Long Qty: \"  + str.tostring(long_qty)  + \" | SL/TP: \" + (long_condition  ? str.tostring(long_stop)  + \" / \" + str.tostring(long_target)  : \"N/A\") + \"\\n\" +\r\n          \"Short Qty: \" + str.tostring(short_qty) + \" | SL/TP: \" + (short_condition ? str.tostring(short_stop) + \" / \" + str.tostring(short_target) : \"N/A\") + \"\\n\" +\r\n          \"Cooldown: \"  + (cooldown_active ? \"ON\" : \"OFF\")\r\n\r\n    label.set_text(dash, txt)\r\n    label.set_xy(dash, bar_index, high)\r\n"
  },
  {
    "url": "KQnZkLDq-Indian-Scalper-2025-PSAR-SMA50-RSI-50-High-Volume-75",
    "name": "Indian Scalper 2025 â€“ PSAR + SMA50 + RSIâ‰¤50 + High Volume (75%)",
    "description": "Best 1-min / 2-min scalping strategy for NIFTY, BANKNIFTY, FINNIFTY & liquid stocks in 2025\nâœ“ PSAR flip + SMA-50 trend filter\nâœ“ RSI â‰¤50 (avoids chasing)\nâœ“ Only high-volume candles (bright colour)\nâœ“ Loud mobile alerts with price & SL\nâœ“ 1:2+ RR with PSAR trailing\nWorks like magic 9:15â€“11:30 AM and 2â€“3:20 PM\nMade with love for the Indian trading community â™¥",
    "image_url": "KQnZkLDq",
    "author": "keerthanamurugesan",
    "likes": 24,
    "type": "strategy",
    "created": "2025-12-07",
    "updated": "2025-12-07",
    "source": "//@version=5\nstrategy(\"Indian Scalper 2025 â€“ PSAR + SMA50 + RSIâ‰¤50 + High Volume\", \n         overlay=true, \n         commission_value=0.025, \n         default_qty_type=strategy.percent_of_equity, \n         default_qty_value=100, \n         pyramiding=0)\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ INPUTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\npsarStep = input.float(0.02,  \"PSAR Step\",          step=0.001)\npsarMax  = input.float(0.20,  \"PSAR Max\",           step=0.01)\nvolMult  = input.float(1.5,   \"Volume Multiplier\",  minval=1.0, step=0.1)\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ INDICATORS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nsma50    = ta.sma(close, 50)\npsar     = ta.sar(psarStep, psarStep, psarMax)\nrsi      = ta.rsi(close, 14)\navgVol   = ta.sma(volume, 20)\nhighVol  = volume > avgVol * volMult\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ PLOTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nplot(sma50, color=color.orange, linewidth=2, title=\"SMA 50\")\nplot(psar, style=plot.style_circles, linewidth=3, \n     color=psar < close ? color.green : color.red, title=\"Parabolic SAR\")\nbarcolor(highVol ? (close > open ? #00ff00 : #ff0066) : na, title=\"High Volume Candle\")\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ENTRY CONDITIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nlongCondition  = close > sma50 and ta.crossover(psar, close) and rsi <= 50 and highVol\nshortCondition = close < sma50 and ta.crossunder(psar, close) and rsi >= 50 and highVol\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ENTRIES WITH MOBILE ALERTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nif longCondition\n    strategy.entry(\"Long\", strategy.long,\n         alert_message=\"BUY {{ticker}} @ {{close}} | HIGH VOL | SL â‰ˆ{{close - ta.atr(14)*1.2}} | Target 1:2+\")\n\nif shortCondition\n    strategy.entry(\"Short\", strategy.short,\n         alert_message=\"SELL {{ticker}} @ {{close}} | HIGH VOL | SL â‰ˆ{{close + ta.atr(14)*1.2}} | Target 1:2+\")\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ EXITS (2R profit + 1.2Ã—ATR stop + PSAR trail) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\natr14 = ta.atr(14)\nstrategy.exit(\"XL\", \"Long\",  profit=atr14*2, loss=atr14*1.2, trail_points=psar)\nstrategy.exit(\"XS\", \"Short\", profit=atr14*2, loss=atr14*1.2, trail_points=psar)\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ BIG ARROWS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nplotshape(longCondition,  title=\"BUY\",  location=location.belowbar, color=color.new(color.lime,0),\n          style=shape.triangleup, size=size.large, text=\"BUY\\nVOL\", textcolor=color.black)\n\nplotshape(shortCondition, title=\"SELL\", location=location.abovebar, color=color.new(color.red,0),\n          style=shape.triangledown, size=size.large, text=\"SELL\\nVOL\", textcolor=color.white)"
  },
  {
    "url": "uwTtGSAR-Momentum-Reversal-Dip-Buyer-Score-Based",
    "name": "Momentum Reversal / Dip Buyer [Score Based]",
    "description": "Strategy Overview\nMomentum Reversal / Dip Buyer   is a quantitative reversal engine designed to fade stretched moves and buy dips / sell rallies when multiple momentum and context factors line up. Itâ€™s built for liquid instruments especially for ticker  CME_MINI:ES1!  and works best on intraday timeframes like the 5-minute or 1-minute chart.\n\n Core Logic \nThis strategy builds a composite Momentum Score by combining:\n\n \n Price Location: Relative to 100 SMA, 1000 EMA, and VWAP (trend / regime filter).\n RSI: Overbought/oversold and mid-zone strength.\n VWMO (Volume-Weighted Momentum): Direction and strength of volume-weighted price drift.\n ADX: Trend strength filter (high vs low trend environment).\n Full Stoch (%K): Short-term exhaustion and mean-reversion context.\n CCI: Overbought/oversold turns (key trigger).\n MFI: Volume-confirmed buying/selling pressure.\n ATR Regime: High vs low volatility environment.\n Cumulative Delta: Whether net aggressor flow is rising or falling.\n \n\n From this, a single Momentum Score is computed each bar: \n \n Longs: Taken when the score is depressed (scoreLow) and CCI crosses up from oversold.\n Shorts: Taken when the score is elevated (scoreHigh) and CCI crosses down from overbought.\n \n\n Risk Management & Trade Logic \n \n Max Daily Trades: Hard cap on entries per day.\n Hard Stop: Fixed % stop based on entry price.\n Profit Target: Target ATR Multiplier Ã— main ATR from entry.\n Breakeven Logic: Optional; moves stop to breakeven (plus optional offset) after price moves a configurable multiple of the main ATR in your favor.\n Trailing Stop (Separate ATR): Optional; uses its own ATR length and ATR-based trigger and distance. This lets you run slower ATR for targets while using a tighter, more reactive ATR for the trail.\n \n\n Session Control \n \n Trading Window: Optional session filter (e.g., 09:30â€“16:00). Entries are only allowed inside the defined window.\n Force Flat at Session End: Option to automatically close all open positions when the session ends.\n \n\n Visuals \n \n The script plots entry arrows and a compact dashboard displaying: current Momentum Score, daily trade usage, and CCI status.\n \n\n Disclaimer: \n This script is for educational and research purposes only and is not financial advice. Past performance does not guarantee future results. Always forward-test and adjust parameters to your own risk tolerance and market. \n\nShoutout and all credit goes to  AuclairsCapital  for building the base foundation of this strategy on ThinkScript \n",
    "image_url": "uwTtGSAR",
    "author": "TheTRADRS",
    "likes": 776,
    "type": "strategy",
    "created": "2025-12-07",
    "updated": "2025-12-07",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// Â© AndersonWin\r\n\r\n//@version=5\r\nstrategy(\"Momentum Reversal / Dip Buyer [Score Based]\", shorttitle=\"Rev Score Strat\", overlay=true, initial_capital=10000, default_qty_type=strategy.fixed, default_qty_value=1, currency=currency.USD)\r\n\r\n// ==============================================\r\n// INPUTS\r\n// ==============================================\r\n\r\n// Group labels\r\ngrp_risk      = \"Risk & Limits\"\r\ngrp_advStops  = \"Advanced Stops (Breakeven & Trailing)\"\r\ngrp_session   = \"Trading Window\"\r\ngrp_ind       = \"Indicator Settings\"\r\n\r\n// --- Trade Limits ---\r\nmaxDailyTrades    = input.int(3, \"Max Daily Trades\", group=grp_risk)\r\nhardStopPercent   = input.float(0.3, \"Hard Stop %\", step=0.1, group=grp_risk) / 100\r\ntargetATR         = input.float(8.0, \"Target ATR Multiplier\", group=grp_risk)\r\natrLength         = input.int(14, \"Main ATR Length\", group=grp_risk)\r\n\r\n// --- Advanced Stops: Breakeven & Trailing ---\r\nenableBE          = input.bool(true,  \"Enable Breakeven Stop\", group=grp_advStops)\r\nbeTriggerATR      = input.float(1.0,  \"Breakeven Trigger (x Main ATR)\", step=0.1, group=grp_advStops)\r\nbeOffsetATR       = input.float(0.0,  \"Breakeven Offset (x Main ATR)\",  step=0.1, group=grp_advStops)\r\n\r\nenableTrail       = input.bool(true,  \"Enable Trailing Stop\", group=grp_advStops)\r\ntrailAtrLength    = input.int(14,     \"Trailing ATR Length\", group=grp_advStops)\r\ntrailTriggerATR   = input.float(2.0,  \"Trail Start (x Trail ATR)\",    step=0.1, group=grp_advStops)\r\ntrailDistanceATR  = input.float(1.0,  \"Trail Distance (x Trail ATR)\", step=0.1, group=grp_advStops)\r\n\r\n// --- Trading Window ---\r\nuseSession        = input.bool(false, \"Enable Trading Window\", group=grp_session)\r\nsessionStr        = input.session(\"0930-1600\", \"Session (Exchange Time)\", group=grp_session)\r\nforceFlatAtEnd    = input.bool(true, \"Force Close At Session End\", group=grp_session)\r\n\r\n// --- Indicator Settings ---\r\nsmaLength         = input.int(100, \"SMA Length\", group=grp_ind)\r\nemaLength         = input.int(1000, \"EMA Length\", group=grp_ind)\r\nrsiLength         = input.int(14, \"RSI Length\", group=grp_ind)\r\nrsiOverbought     = input.int(70, \"RSI OB\", group=grp_ind)\r\nrsiOversold       = input.int(30, \"RSI OS\", group=grp_ind)\r\nvwmoLength        = input.int(20, \"VWMO Length\", group=grp_ind)\r\nadxLength         = input.int(14, \"ADX Length\", group=grp_ind)\r\nstochLength       = input.int(14, \"Stoch Length\", group=grp_ind)\r\nstochD            = input.int(3, \"Stoch D\", group=grp_ind)\r\nstochOverbought   = input.int(80, \"Stoch OB\", group=grp_ind)\r\nstochOversold     = input.int(20, \"Stoch OS\", group=grp_ind)\r\ncciLength         = input.int(14, \"CCI Length\", group=grp_ind)\r\ncciOverbought     = input.int(100, \"CCI OB\", group=grp_ind)\r\ncciOversold       = input.int(-100, \"CCI OS\", group=grp_ind)\r\nmfiLength         = input.int(14, \"MFI Length\", group=grp_ind)\r\nvolSmaLength      = input.int(20, \"Vol SMA Length\", group=grp_ind)\r\n\r\n// ==============================================\r\n// CALCULATIONS\r\n// ==============================================\r\n\r\n// Moving Averages\r\nsma100   = ta.sma(close, smaLength)\r\nema1000  = ta.ema(close, emaLength)\r\nvwapVal  = ta.vwap(close) // Standard Session VWAP\r\n\r\n// ATRs\r\natr      = ta.atr(atrLength)          // main ATR (targets, BE)\r\ntrailAtr = ta.atr(trailAtrLength)     // trailing ATR (trail logic)\r\n\r\n// RSI\r\nrsi      = ta.rsi(close, rsiLength)\r\n\r\n// VWMO (Volume Weighted Momentum Oscillator)\r\nvwmaCurrent = ta.vwma(close, vwmoLength)\r\nvwmaPast    = vwmaCurrent[vwmoLength]\r\nvwmo        = (vwmaPast != 0) ? (vwmaCurrent - vwmaPast) / vwmaPast * 100 : 0\r\n\r\n// ADX\r\n[diPlus, diMinus, adx] = ta.dmi(adxLength, adxLength)\r\n\r\n// Cumulative Delta\r\ndelta = 0.0\r\nif close > close[1]\r\n    delta := volume\r\nelse if close < close[1]\r\n    delta := -volume\r\nelse\r\n    delta := 0.0\r\n\r\ncumDelta        = ta.cum(delta)\r\ncumDeltaRising  = cumDelta > cumDelta[1]\r\ncumDeltaFalling = cumDelta < cumDelta[1]\r\n\r\n// Stochastic\r\nk           = ta.stoch(close, high, low, stochLength)\r\nd           = ta.sma(k, stochD)\r\nstochFullK  = k\r\n\r\n// CCI\r\ncci         = ta.cci(close, cciLength)\r\n\r\n// MFI\r\nmfi         = ta.mfi(close, mfiLength)\r\n\r\n// Volatility & Volume\r\natrAvg         = ta.sma(atr, 20)\r\nhighVolatility = atr > atrAvg * 1.5\r\nlowVolatility  = atr < atrAvg * 0.5\r\n\r\nvolSma         = ta.sma(volume, volSmaLength)\r\n\r\n// ==============================================\r\n// TRADING WINDOW LOGIC\r\n// ==============================================\r\n\r\n// rawInSession: true only when current bar is inside defined session\r\nrawInSession = not na(time(timeframe.period, sessionStr))\r\n// inSession: if trading window disabled, always true; else use session membership\r\ninSession    = useSession ? rawInSession : true\r\n// Detect the bar right after session ends\r\nsessionJustEnded = useSession and rawInSession[1] and not rawInSession\r\n\r\n// ==============================================\r\n// SCORING SYSTEM\r\n// ==============================================\r\n\r\n// Price Location\r\npriceAboveAll = close > sma100 and close > ema1000 and close > vwapVal\r\npriceBelowAll = close < sma100 and close < ema1000 and close < vwapVal\r\n\r\npriceScore = priceAboveAll ? 50 : (priceBelowAll ? 0 : 25)\r\n\r\n// RSI Score\r\nrsiScore = 0\r\nif rsi > rsiOverbought\r\n    rsiScore := 25\r\nelse if rsi < rsiOversold\r\n    rsiScore := 0\r\nelse if rsi > 50\r\n    rsiScore := 15\r\nelse\r\n    rsiScore := 5\r\n\r\n// VWMO Score\r\nvwmoScore = 0\r\nif vwmo > 1\r\n    vwmoScore := 25\r\nelse if vwmo < -1\r\n    vwmoScore := 0\r\nelse if vwmo > 0\r\n    vwmoScore := 15\r\nelse\r\n    vwmoScore := 5\r\n\r\n// ADX Score\r\nadxScore = 0\r\nif adx > 40\r\n    adxScore := 20\r\nelse if adx > 25\r\n    adxScore := 10\r\nelse\r\n    adxScore := 0\r\n\r\n// Stoch Score\r\nstochScore = 0\r\nif stochFullK > stochOverbought\r\n    stochScore := 20\r\nelse if stochFullK < stochOversold\r\n    stochScore := 0\r\nelse if stochFullK > 50\r\n    stochScore := 12\r\nelse\r\n    stochScore := 4\r\n\r\n// CCI Score\r\ncciScore = 0\r\nif cci > cciOverbought\r\n    cciScore := 20\r\nelse if cci < cciOversold\r\n    cciScore := 0\r\nelse if cci > 0\r\n    cciScore := 12\r\nelse\r\n    cciScore := 4\r\n\r\n// MFI Score\r\nmfiScore = 0\r\nif mfi > 80\r\n    mfiScore := 15\r\nelse if mfi < 20\r\n    mfiScore := 0\r\nelse if mfi > 50\r\n    mfiScore := 10\r\nelse\r\n    mfiScore := 3\r\n\r\n// Volatility Score\r\nvolScore       = highVolatility ? 10 : (lowVolatility ? 0 : 5)\r\n\r\n// Cum Delta Score\r\ncumDeltaScore  = cumDeltaRising ? 15 : (cumDeltaFalling ? 0 : 8)\r\n\r\n// TOTAL MOMENTUM SCORE\r\nmomentumScore  = priceScore + rsiScore + vwmoScore + adxScore + stochScore + cciScore + mfiScore + volScore + cumDeltaScore\r\n\r\n// ==============================================\r\n// STRATEGY TRIGGERS\r\n// ==============================================\r\n\r\n// 1. Setup Conditions\r\nscoreLow  = momentumScore < 70\r\nscoreHigh = momentumScore > 130 and momentumScore < 190\r\n\r\n// 2. Trigger Events\r\ncciBuySignal  = ta.crossover(cci, -100)\r\ncciSellSignal = ta.crossunder(cci, 100)\r\n\r\n// 3. Daily Limit Logic\r\nvar int dailyTradeCount = 0\r\nvar int lastTradeDay    = 0\r\n\r\nif dayofmonth(time) != lastTradeDay\r\n    dailyTradeCount := 0\r\n    lastTradeDay    := dayofmonth(time)\r\n\r\ncanTrade = dailyTradeCount < maxDailyTrades\r\n\r\n// 4. Final Signals (SESSION FILTER APPLIED HERE)\r\nLongSignal  = canTrade and inSession and scoreLow  and cciBuySignal\r\nShortSignal = canTrade and inSession and scoreHigh and cciSellSignal\r\n\r\n// ==============================================\r\n// EXECUTION\r\n// ==============================================\r\n\r\nif LongSignal\r\n    strategy.entry(\"REV_LONG\", strategy.long, comment=\"Score: \" + str.tostring(momentumScore))\r\n    dailyTradeCount += 1\r\n\r\nif ShortSignal\r\n    strategy.entry(\"REV_SHORT\", strategy.short, comment=\"Score: \" + str.tostring(momentumScore))\r\n    dailyTradeCount += 1\r\n\r\n// ==============================================\r\n// EXITS (ATR + Breakeven + Trailing)\r\n// ==============================================\r\n\r\n// Base stops/targets from original logic (always defined off current avg price, using MAIN ATR)\r\nlongStopBase     = strategy.position_avg_price * (1 - hardStopPercent)\r\nlongTargetPrice  = strategy.position_avg_price + (atr * targetATR)\r\n\r\nshortStopBase    = strategy.position_avg_price * (1 + hardStopPercent)\r\nshortTargetPrice = strategy.position_avg_price - (atr * targetATR)\r\n\r\n// Dynamic versions that will be adjusted by BE / trailing logic\r\nlongStopDynamic  = longStopBase\r\nshortStopDynamic = shortStopBase\r\n\r\n// LONG MANAGEMENT\r\nif strategy.position_size > 0\r\n    entryPrice = strategy.position_avg_price\r\n    profit     = close - entryPrice         // > 0 when long is green\r\n\r\n    // --- Breakeven: move stop to entry (optional small offset) after X * MAIN ATR in profit\r\n    if enableBE and profit >= atr * beTriggerATR\r\n        bePrice         = entryPrice + atr * beOffsetATR\r\n        longStopDynamic := math.max(longStopDynamic, bePrice)\r\n\r\n    // --- Trailing: once profit exceeds trigger, trail by N * TRAIL ATR from current price\r\n    if enableTrail and profit >= trailAtr * trailTriggerATR\r\n        trailStop       = close - trailAtr * trailDistanceATR\r\n        longStopDynamic := math.max(longStopDynamic, trailStop)\r\n\r\n    strategy.exit(\"Exit Long\", \"REV_LONG\", stop=longStopDynamic, limit=longTargetPrice)\r\n\r\n// SHORT MANAGEMENT\r\nif strategy.position_size < 0\r\n    entryPrice = strategy.position_avg_price\r\n    profit     = entryPrice - close        // > 0 when short is green\r\n\r\n    // --- Breakeven for shorts (MAIN ATR)\r\n    if enableBE and profit >= atr * beTriggerATR\r\n        bePrice           = entryPrice - atr * beOffsetATR\r\n        shortStopDynamic := math.min(shortStopDynamic, bePrice)\r\n\r\n    // --- Trailing for shorts (TRAIL ATR)\r\n    if enableTrail and profit >= trailAtr * trailTriggerATR\r\n        trailStop         = close + trailAtr * trailDistanceATR\r\n        shortStopDynamic  = math.min(shortStopDynamic, trailStop)\r\n\r\n    strategy.exit(\"Exit Short\", \"REV_SHORT\", stop=shortStopDynamic, limit=shortTargetPrice)\r\n\r\n// ==============================================\r\n// FORCE CLOSE AT SESSION END\r\n// ==============================================\r\n\r\nif forceFlatAtEnd and sessionJustEnded and strategy.position_size != 0\r\n    strategy.close(\"REV_LONG\")\r\n    strategy.close(\"REV_SHORT\")\r\n\r\n// ==============================================\r\n// VISUALS & DASHBOARD\r\n// ==============================================\r\n\r\n// Plot Arrows\r\nplotshape(LongSignal,  title=\"Long Signal\",  location=location.belowbar, color=color.green, style=shape.arrowup,   size=size.small)\r\nplotshape(ShortSignal, title=\"Short Signal\", location=location.abovebar, color=color.red,   style=shape.arrowdown, size=size.small)\r\n\r\n// Optional: show session on chart (helpful for debugging)\r\nbgcolor(useSession and not inSession ? color.new(color.red, 95) : na)\r\n\r\n// Dashboard Table\r\nvar table dashTable = table.new(position.top_right, 2, 4, bgcolor=color.new(color.black, 50), border_width=1)\r\n\r\nif barstate.islast\r\n    // Header\r\n    table.cell(dashTable, 0, 0, \"Metric\", text_color=color.white, text_size=size.small)\r\n    table.cell(dashTable, 1, 0, \"Value\",  text_color=color.white, text_size=size.small)\r\n\r\n    // Score\r\n    ColorScore = momentumScore > 130 ? color.red : (momentumScore < 70 ? color.green : color.gray)\r\n    table.cell(dashTable, 0, 1, \"Momentum Score\", text_color=color.white, text_size=size.small)\r\n    table.cell(dashTable, 1, 1, str.tostring(momentumScore, \"#\"), text_color=ColorScore, text_size=size.small)\r\n\r\n    // Daily Trades\r\n    ColorTrades = dailyTradeCount >= maxDailyTrades ? color.red : color.white\r\n    table.cell(dashTable, 0, 2, \"Daily Trades\", text_color=color.white, text_size=size.small)\r\n    table.cell(dashTable, 1, 2, str.tostring(dailyTradeCount) + \"/\" + str.tostring(maxDailyTrades), text_color=ColorTrades, text_size=size.small)\r\n\r\n    // CCI Status\r\n    ColorCCI = cci > 100 ? color.red : (cci < -100 ? color.green : color.yellow)\r\n    table.cell(dashTable, 0, 3, \"CCI\", text_color=color.white, text_size=size.small)\r\n    table.cell(dashTable, 1, 3, str.tostring(cci, \"#.##\"), text_color=ColorCCI, text_size=size.small)\r\n"
  },
  {
    "url": "44B4W97k-Ashok-07-Dec-25-updated-",
    "name": "Ashok 07 Dec 25 updated script",
    "description": "Tried to fix the bugs in previous script. Even now improvements are needed, but for now it looks reasonably profiting.",
    "image_url": "44B4W97k",
    "author": "ashokkkkkk",
    "likes": 9,
    "type": "strategy",
    "created": "2025-12-07",
    "updated": "2025-12-07",
    "source": "//@version=5\nstrategy(\"Nifty Options MACD + EMA Strategy with SL/TP - FIXED\", overlay=true, default_qty_type=strategy.percent_of_equity, default_qty_value=10)\n\n// Inputs\nfastLength = input.int(12, \"MACD Fast Length\")\nslowLength = input.int(26, \"MACD Slow Length\") \nsignalLength = input.int(9, \"MACD Signal Length\")\nstopLossPercent = input.float(10.0, \"Stop Loss %\", minval=0.1, step=0.1)\ntakeProfitPercent = input.float(20.0, \"Take Profit %\", minval=0.1, step=0.1)\nminDiff = input.float(50.0, \"Min EMA Gap (Points)\", minval=1.0)  // Nifty scale\n\n// Calculate indicators\n[macdLine, signalLine, histLine] = ta.macd(close, fastLength, slowLength, signalLength)\nema20 = ta.ema(close, 20)\nema50 = ta.ema(close, 50)\nema100 = ta.ema(close, 100)\nema200 = ta.ema(close, 200)\n\n// EMA sequence condition (strict gaps for Nifty)\nemaSeqCondition = ema20 > ema50 and ema50 > ema100 and ema100 > ema200 and\n                  (ema20 - ema50) > minDiff and (ema50 - ema100) > minDiff and (ema100 - ema200) > minDiff\n\n// Buy signals\nbuyCondition1 = ta.crossover(macdLine, 0)\nbuyCondition2 = emaSeqCondition and not emaSeqCondition[1]  // Only on NEW sequence\nbuySignal = buyCondition1 or buyCondition2\n\n// FIXED: Position-aware sell signal (ONLY when in trade)\nsellSignal = strategy.position_size > 0 and ta.crossunder(macdLine, signalLine)\n\n// Track entry price\nvar float entryPrice = na\n\n// Entry - only when no position\nif buySignal and strategy.position_size == 0\n    strategy.entry(\"Long\", strategy.long)\n    entryPrice := close  // Capture entry price\n\n// Position management\nif strategy.position_size > 0\n    // Calculate SL/TP from actual entry price\n    slPrice = entryPrice * (1 - stopLossPercent / 100)\n    tpPrice = entryPrice * (1 + takeProfitPercent / 100)\n    \n    // Set SL/TP orders\n    strategy.exit(\"SL/TP\", from_entry=\"Long\", stop=slPrice, limit=tpPrice)\n    \n    // Manual sell signal (overrides SL/TP if triggered)\n    if sellSignal\n        strategy.close(\"Long\", comment=\"Sell Signal\")\n        entryPrice := na  // Reset for next trade\n\n// Reset entry price on position close (handles SL/TP exits)\nif strategy.position_size == 0 and not na(entryPrice)\n    entryPrice := na\n\n// Visual signals - POSITION AWARE\nplotshape(buySignal and strategy.position_size == 0, title=\"BUY\", style=shape.labelup, \n          location=location.belowbar, color=color.green, size=size.normal, text=\"BUY\")\n\nplotshape(sellSignal, title=\"SELL\", style=shape.labeldown, \n          location=location.abovebar, color=color.red, size=size.normal, text=\"SELL\")\n\n// Plot EMAs\nplot(ema20, \"EMA 20\", color=color.yellow, linewidth=2)\nplot(ema50, \"EMA 50\", color=color.red, linewidth=2)\nplot(ema100, \"EMA 100\", color=color.purple, linewidth=1)\nplot(ema200, \"EMA 200\", color=color.green, linewidth=1)\n\n// Background highlight for EMA sequence\nbgcolor(emaSeqCondition ? color.new(color.blue, 90) : na, title=\"EMA Bull Sequence\")\n\n// SL/TP levels visualization\nplot(strategy.position_size > 0 ? entryPrice * (1 - stopLossPercent / 100) : na, \n     \"Stop Loss\", color=color.red, style=plot.style_linebr, linewidth=2)\nplot(strategy.position_size > 0 ? entryPrice * (1 + takeProfitPercent / 100) : na, \n     \"Take Profit\", color=color.green, style=plot.style_linebr, linewidth=2)\n\n// Alerts - position aware\nalertcondition(buySignal and strategy.position_size == 0, \"NIFTY BUY\", \"ðŸš€ NIFTY Options BUY Signal\")\nalertcondition(sellSignal, \"NIFTY SELL\", \"âŒ NIFTY Options SELL Signal - MACD Crossunder\")"
  },
  {
    "url": "2IiL72Xl-CPR-EMA-20-50-200-Strategy-5m-NIFTY-style",
    "name": "CPR + EMA(20/50/200) Strategy (5m) - NIFTY style",
    "description": "indicator best suited for nifty for 5 minute time frame.",
    "image_url": "2IiL72Xl",
    "author": "raghvende",
    "likes": 5,
    "type": "strategy",
    "created": "2025-12-07",
    "updated": "2025-12-07",
    "source": "//@version=5\nstrategy(\"CPR + EMA(20/50/200) Strategy (5m) - NIFTY style\", overlay=true, default_qty_type=strategy.fixed, default_qty_value=1)\n\n// === INPUTS\nemaFastLen = input.int(20, \"EMA Fast (20)\", minval=1)\nemaSlowLen = input.int(50, \"EMA Slow (50)\", minval=1)\nemaLongLen = input.int(200, \"EMA Long (200)\", minval=1)\n\nminGapPoints = input.float(2.0, \"Min gap (points) for EMA widening\", step=0.1)\nrequireCrossover = input.bool(true, \"Require EMA crossover for initial entry\")\ngapMustBeIncreasing = input.bool(true, \"Require gap increasing (momentum)\")\nusePrevDailyForCPR = input.bool(true, \"Use previous daily H/L/C for CPR (recommended)\", inline=\"a\")\n\n// Risk/exit inputs\ntpRR = input.float(2.0, \"Take Profit: Risk:Reward\", step=0.1)\nuseSLAs = input.string(\"belowEMA20\", \"Stop loss method\", options=[\"belowEMA20\",\"belowBC\",\"ATR\"])\natrLen = input.int(14, \"ATR length (if using ATR SL)\")\natrMult = input.float(1.5, \"ATR multiplier (if using ATR SL)\", step=0.1)\nqtyContracts = input.int(1, \"Contracts / Lots (fixed size)\")\n\n// === DAILY CPR (use previous day)\nget_daily(x) =>\n    request.security(syminfo.tickerid, \"D\", x)\n\n// get previous day values\ndH = get_daily(high[1])\ndL = get_daily(low[1])\ndC = get_daily(close[1])\n\npivot = (dH + dL + dC) / 3.0\nbc = (dH + dL) / 2.0\ntc = 2.0 * pivot - bc\n\n// plot CPR\nplot(tc, title=\"CPR - Top (TC)\", color=color.green, linewidth=2)\nplot(pivot, title=\"CPR - Pivot\", color=color.gray, linewidth=1)\nplot(bc, title=\"CPR - Bottom (BC)\", color=color.red, linewidth=2)\n\n// === EMA calculations\nema20 = ta.ema(close, emaFastLen)\nema50 = ta.ema(close, emaSlowLen)\nema200 = ta.ema(close, emaLongLen)\n\nplot(ema20, color=color.green, linewidth=2, title=\"EMA 20\")\nplot(ema50, color=color.red, linewidth=2, title=\"EMA 50\")\nplot(ema200, color=color.black, linewidth=2, title=\"EMA 200\")\n\n// === Gap and slope logic\ngap = ema20 - ema50\ngapPrev = gap[1]\ngapIncreasing = gap > gapPrev and gap > minGapPoints\ngapDecreasing = gap < gapPrev and gap < -minGapPoints  // for shorts\n\n// crossover / crossunder\nfastAboveSlow = ema20 > ema50\nfastBelowSlow = ema20 < ema50\ncrossoverEvent = ta.crossover(ema20, ema50)\ncrossunderEvent = ta.crossunder(ema20, ema50)\n\n// Price vs CPR and 200ema\npriceAboveTC = close > tc\npriceBelowBC = close < bc\npriceAbove200 = close > ema200\npriceBelow200 = close < ema200\n\n// LONG condition\nlongCond = false\nif requireCrossover\n    longCond := crossoverEvent and fastAboveSlow and priceAboveTC and priceAbove200 and (not gapMustBeIncreasing or gapIncreasing)\nelse\n    longCond := fastAboveSlow and priceAboveTC and priceAbove200 and (not gapMustBeIncreasing or gapIncreasing)\n\n// SHORT condition\nshortCond = false\nif requireCrossover\n    shortCond := crossunderEvent and fastBelowSlow and priceBelowBC and priceBelow200 and (not gapMustBeIncreasing or gapDecreasing)\nelse\n    shortCond := fastBelowSlow and priceBelowBC and priceBelow200 and (not gapMustBeIncreasing or gapDecreasing)\n\n// === Stop Loss calculation\nslBuffer = syminfo.mintick * 1.0\nlongStop = switch useSLAs\n    \"belowEMA20\" => math.min(ema20, bc) - slBuffer\n    \"belowBC\"     => bc - slBuffer\n    \"ATR\"         => close - ta.atr(atrLen) * atrMult\n\nshortStop = switch useSLAs\n    \"belowEMA20\" => math.max(ema20, bc) + slBuffer\n    \"belowBC\"     => bc + slBuffer\n    \"ATR\"         => close + ta.atr(atrLen) * atrMult\n\n// Ensure stop is sensible relative to entry (only used after entry is placed)\ncalcLongTarget(stop) =>\n    risk = math.abs(close - stop)\n    target = close + risk * tpRR\n    target\n\ncalcShortTarget(stop) =>\n    risk = math.abs(close - stop)\n    target = close - risk * tpRR\n    target\n\n// === Entries and Exits\nif (longCond)\n    entryPrice = close\n    stopPrice = longStop\n    // ensure stop < entry\n    if stopPrice < entryPrice\n        tpPrice = calcLongTarget(stopPrice)\n        strategy.entry(\"Long\", strategy.long, qtyContracts)\n        strategy.exit(\"Long TP/SL\", from_entry=\"Long\", limit=tpPrice, stop=stopPrice)\n\nif (shortCond)\n    entryPrice = close\n    stopPrice = shortStop\n    if stopPrice > entryPrice\n        tpPrice = calcShortTarget(stopPrice)\n        strategy.entry(\"Short\", strategy.short, qtyContracts)\n        strategy.exit(\"Short TP/SL\", from_entry=\"Short\", limit=tpPrice, stop=stopPrice)\n\n// === Plot signals on chart\nplotshape(longCond, title=\"LongSignal\", style=shape.triangleup, location=location.belowbar, color=color.lime, size=size.small, text=\"BUY\")\nplotshape(shortCond, title=\"ShortSignal\", style=shape.triangledown, location=location.abovebar, color=color.red, size=size.small, text=\"SELL\")\n\n// Alerts\nalertcondition(longCond, title=\"Long Signal\", message=\"CPR+EMA Long Signal on {{ticker}}\")\nalertcondition(shortCond, title=\"Short Signal\", message=\"CPR+EMA Short Signal on {{ticker}}\")\n\n// Debug prints (optional)\nvar table dbg = table.new(position.top_right, 1, 4)\nif barstate.islast\n    table.cell(dbg, 0, 0, \"EMA20-EMA50 gap: \" + str.tostring(gap, format.mintick))\n    table.cell(dbg, 0, 1, \"GapIncreasing: \" + str.tostring(gapIncreasing))\n    table.cell(dbg, 0, 2, \"Price>TC: \" + str.tostring(priceAboveTC))\n    table.cell(dbg, 0, 3, \"Price>200: \" + str.tostring(priceAbove200))\n"
  },
  {
    "url": "CudtIDlS-Inyerneck-Quiet-Bottom-Hunter-v36-Last-Sorta-Working-Version",
    "name": "Inyerneck Quiet Bottom Hunter v36 â€” Last Sorta-Working Version",
    "description": "Quiet Bottom Hunter v36 â€” Accurate Description (the sorta-working version that fires signals)\nOverview\nA mean-reversion bottom-hunting strategy for small-cap stocks (<$2B market cap). Designed to catch slow-bleed stocks that quietly bottom out and rebound 20â€“60%+. Good for beginners because signals are infrequent and the setup is easy to understand.\nTimeframe\nDaily (D) â€” best results on 1-day charts. Works on weekly too, but signals are rarer.\nTriggers / Conditions (all must be true at bar close)\n\nDrop from high â‰¥ 25% from the highest high in the last 100 bars (previous bars only â€” no repainting)\nVolume â‰¤ 80% of the 50-day average (quiet accumulation, no panic selling left)\nRSI(14) â‰¤ 38 (oversold territory)\nGreen/flat streak â‰¥ 2 consecutive days where close â‰¥ open (shows sellers are exhausted)\n\nWhen all four line up â†’ tiny green â€œQBâ€ triangle below the bar \nFiring Frequency\n1â€“4 signals per month on an average small-cap stock (depends on market conditions). Some months zero, some months a handful. Not spammy, but not ultra-rare either.\nUsage Parameters\n\nPosition size: 10% of equity per trade (default â€” change to 5â€“20% depending on risk tolerance)\nProfit target: 40%\nStop loss: 12%\nHold time: usually 2â€“8 weeks\nBest on low-float, high-volatility small caps (TLRY, SNDL, MVIS, SOUN, INHD, etc.)\n\nExpected Performance (backtested on 2025 small caps)\n\nWin rate: ~80â€“85%\nAverage rebound on winners: +30â€“40%\nSome losers when the bottom isn't \"quiet\" enough\n\nHow to use\n\nAdd to daily charts of your small-cap watchlist\nWhen â€œQBâ€ arrow appears, buy at next open or market\nSet 40% target / 12% stop or trail it\nWait for the rebound â€” no day-trading needed",
    "image_url": "CudtIDlS",
    "author": "oogabooger",
    "likes": 5,
    "type": "strategy",
    "created": "2025-12-07",
    "updated": "2025-12-07",
    "source": "//@version=5\r\nstrategy(\"Quiet Bottom Hunter v36 â€” Last Sorta-Working Version\", overlay=true,\r\n         default_qty_type=strategy.percent_of_equity, default_qty_value=10)\r\n\r\n// SETTINGS â€” this is the version that gave you signals\r\nlookback     = input.int(100, \"Lookback bars for high\")\r\nminDrop      = input.float(-25.0, \"Min % drop from high\")\r\nvolMax       = input.float(0.8, \"Max volume vs 50-day avg\")\r\nrsiMax       = input.int(38, \"RSI max\")\r\ngreenMin     = input.int(2, \"Min green/flat days\")\r\n\r\n// DROP FROM HIGH\r\nhighPrev = ta.highest(high[1], lookback)\r\ndrop     = (close - highPrev) / highPrev * 100\r\nisDown   = drop <= minDrop\r\n\r\n// VOLUME\r\nvolDry   = volume <= ta.sma(volume, 50) * volMax\r\n\r\n// RSI\r\nrsiOk    = ta.rsi(close, 14) <= rsiMax\r\n\r\n// GREEN STREAK â€” FIXED\r\nstreak = 0\r\nstreak := close >= open ? streak[1] + 1 : 0\r\nbottomOk = streak >= greenMin\r\n\r\n// TRIGGER\r\nqbLong = isDown and volDry and rsiOk and bottomOk\r\n\r\nif (qbLong)\r\n    strategy.entry(\"QB\", strategy.long)\r\n\r\nstrategy.exit(\"QB Exit\", \"QB\", profit=40, loss=12)\r\n\r\n// TINY ARROW\r\nplotshape(qbLong, location=location.belowbar, color=#00ff9d, style=shape.triangleup, size=size.tiny, text=\"QB\")\r\n\r\nalertcondition(qbLong, title=\"Quiet Bottom\", message=\"{\\\"content\\\":\\\"â™»ï¸ QUIET BOTTOM {{ticker}} @ {{close}} | {{interval}}\\\"}\")"
  },
  {
    "url": "7nQqBF9B-Neon-Simple-Trend-Sniper",
    "name": "Neon Simple Trend Sniper",
    "description": "she a nice buys rt on time sells rt on time works off of RSI",
    "image_url": "7nQqBF9B",
    "author": "OneGoogle",
    "likes": 7,
    "type": "strategy",
    "created": "2025-12-07",
    "updated": "2025-12-07",
    "source": "//@version=5\r\nstrategy(\"Neon Simple Trend Sniper\",\r\n     overlay = true,\r\n     initial_capital = 10000,\r\n     pyramiding = 10,\r\n     default_qty_type  = strategy.percent_of_equity,\r\n     default_qty_value = 10)\r\n\r\n//â€“â€“â€“â€“â€“ INPUTS\r\nlenFast  = input.int(21,  \"Fast EMA\")\r\nlenSlow  = input.int(55,  \"Slow EMA\")\r\nrsiLen   = input.int(14,  \"RSI Length\")\r\nrsiBuy   = input.int(55,  \"RSI Buy Level\",  minval = 1, maxval = 99)\r\nrsiSell  = input.int(45,  \"RSI Sell Level\", minval = 1, maxval = 99)\r\n\r\n//â€“â€“â€“â€“â€“ CALCULATIONS\r\nfastEMA  = ta.ema(close, lenFast)\r\nslowEMA  = ta.ema(close, lenSlow)\r\nrsiVal   = ta.rsi(close, rsiLen)\r\n\r\n// Trend direction\r\nbull = fastEMA > slowEMA\r\nbear = fastEMA < slowEMA\r\n\r\n//â€“â€“â€“â€“â€“ ENTRY CONDITIONS\r\n// More buys as price keeps moving in trend (pyramiding enabled)\r\nlongCond  = bull and ta.crossover(close, fastEMA)  and rsiVal > rsiBuy\r\nshortCond = bear and ta.crossunder(close, fastEMA) and rsiVal < rsiSell\r\n\r\n//â€“â€“â€“â€“â€“ EXIT CONDITIONS\r\nexitLong  = ta.crossunder(close, fastEMA)  or rsiVal < rsiSell\r\nexitShort = ta.crossover(close, fastEMA)   or rsiVal > rsiBuy\r\n\r\n//â€“â€“â€“â€“â€“ ORDERS\r\nif longCond\r\n    strategy.entry(\"Long\", strategy.long)\r\n\r\nif shortCond\r\n    strategy.entry(\"Short\", strategy.short)\r\n\r\nif exitLong\r\n    strategy.close(\"Long\")\r\n\r\nif exitShort\r\n    strategy.close(\"Short\")\r\n\r\n//â€“â€“â€“â€“â€“ VISUALS\r\nplot(fastEMA, title = \"Fast EMA\", color = color.new(color.green, 0), linewidth = 2)\r\nplot(slowEMA, title = \"Slow EMA\", color = color.new(color.red,   0))\r\n"
  },
  {
    "url": "xxujGqx9-The-Flody-Sniper",
    "name": "The Flody Sniper",
    "description": "A trend-following sniper strategy that uses two EMAs (21/55) and RSI to confirm momentum.\nIt enters long when price crosses above the fast EMA during an uptrend and RSI shows strength.\nIt enters short when price crosses below the fast EMA during a downtrend and RSI shows weakness.\nPyramiding is enabled so the strategy can add more positions as the trend continues.\nPositions close when momentum weakens or price breaks back through the fast EMA.",
    "image_url": "xxujGqx9",
    "author": "OneGoogle",
    "likes": 12,
    "type": "strategy",
    "created": "2025-12-07",
    "updated": "2025-12-07",
    "source": "//@version=5\r\nstrategy(\"Neon Simple Trend Sniper\",\r\n     overlay = true,\r\n     initial_capital = 10000,\r\n     pyramiding = 10,\r\n     default_qty_type  = strategy.percent_of_equity,\r\n     default_qty_value = 10)\r\n\r\n//â€“â€“â€“â€“â€“ INPUTS\r\nlenFast  = input.int(21,  \"Fast EMA\")\r\nlenSlow  = input.int(55,  \"Slow EMA\")\r\nrsiLen   = input.int(14,  \"RSI Length\")\r\nrsiBuy   = input.int(55,  \"RSI Buy Level\",  minval = 1, maxval = 99)\r\nrsiSell  = input.int(45,  \"RSI Sell Level\", minval = 1, maxval = 99)\r\n\r\n//â€“â€“â€“â€“â€“ CALCULATIONS\r\nfastEMA  = ta.ema(close, lenFast)\r\nslowEMA  = ta.ema(close, lenSlow)\r\nrsiVal   = ta.rsi(close, rsiLen)\r\n\r\n// Trend direction\r\nbull = fastEMA > slowEMA\r\nbear = fastEMA < slowEMA\r\n\r\n//â€“â€“â€“â€“â€“ ENTRY CONDITIONS\r\n// More buys as price keeps moving in trend (pyramiding enabled)\r\nlongCond  = bull and ta.crossover(close, fastEMA)  and rsiVal > rsiBuy\r\nshortCond = bear and ta.crossunder(close, fastEMA) and rsiVal < rsiSell\r\n\r\n//â€“â€“â€“â€“â€“ EXIT CONDITIONS\r\nexitLong  = ta.crossunder(close, fastEMA)  or rsiVal < rsiSell\r\nexitShort = ta.crossover(close, fastEMA)   or rsiVal > rsiBuy\r\n\r\n//â€“â€“â€“â€“â€“ ORDERS\r\nif longCond\r\n    strategy.entry(\"Long\", strategy.long)\r\n\r\nif shortCond\r\n    strategy.entry(\"Short\", strategy.short)\r\n\r\nif exitLong\r\n    strategy.close(\"Long\")\r\n\r\nif exitShort\r\n    strategy.close(\"Short\")\r\n\r\n//â€“â€“â€“â€“â€“ VISUALS\r\nplot(fastEMA, title = \"Fast EMA\", color = color.new(color.green, 0), linewidth = 2)\r\nplot(slowEMA, title = \"Slow EMA\", color = color.new(color.red,   0))\r\n"
  },
  {
    "url": "XRPeqEdA-Bollinger-Bands-Mean-Reversion-using-RSI-Krishna-Peri",
    "name": "Bollinger Bands Mean Reversion using RSI [Krishna Peri]",
    "description": "How it Works \n\nLong entries trigger when:\n- RSI reaches oversold levels, and\n- At least one bullish candle closes inside the lower Bollinger Band\n\nShort entries trigger when:\n- RSI reaches overbought levels, and\n- At least one bearish candle closes inside the upper Bollinger Band\n\nThis approach aims to capture exhaustion moves where price pushes into extreme deviation from its mean and then snaps back toward the middle band.\n\n Important Disclaimer \n\nThis is a mean-reversion strategy, which means it performs best in sideways, ranging, or slowly oscillating market conditions. When markets shift into strong trends, Bollinger Bands expand and volatility increases, which may cause some signals to become inaccurate or fail altogether.\n\nFor best results, combine this script with:\n\n- Price action\n- Market structure\n- Higher-timeframe trend context\n- Previous day/week/month highs & lows\n- Untested liquidity levels or imbalance zones\n- Session timing (Asia, London, NY)\n\nUsing these confluences helps filter out low-probability trades and significantly improves consistency and precision.",
    "image_url": "XRPeqEdA",
    "author": "krishnaperi95",
    "likes": 461,
    "type": "strategy",
    "created": "2025-12-06",
    "updated": "2025-12-06",
    "source": "//@version=6\nstrategy(\"Peri Bollinger Mean Reversion V2\", overlay = true)\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// Inputs\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nsource         = input.source(close,  \"Source\")\nlength         = input.int(20,        \"BB Length\",          minval = 1)\nmult           = input.float(2.0,     \"BB Multiplier\",      minval = 0.001, maxval = 50.0)\nrsiOversold    = input.int(30,        \"RSI Oversold Level\", minval = 1,     maxval = 50)\nrsiOverbought  = input.int(70,        \"RSI Overbought Level\", minval = 50,  maxval = 99)\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// Bollinger Bands\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nbasis = ta.sma(source, length)\ndev   = mult * ta.stdev(source, length)\nupper = basis + dev\nlower = basis - dev\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// RSI\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nstrength = ta.rsi(close, 14)\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// Plots (default colors)\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\npbasis = plot(basis, \"Middle BB\")          // default color\np1     = plot(upper, \"Upper BB\")           // default color\np2     = plot(lower, \"Lower BB\")           // default color\nfill(p1, p2)                               // default fill color\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// Position sizing\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\namount = 0.1 * (strategy.initial_capital + strategy.netprofit)\nunits  = math.floor(amount / close)\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// Entry / Exit Logic\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n// LONG: price below lower band AND RSI in oversold zone\nif (close < lower and strength < rsiOversold and strategy.position_size < units * 5)\n    strategy.order(\"Long\", strategy.long, units)\n\n// CLOSE LONG: price above upper band AND RSI recovered above 50\nif (close > upper and strength > 50 and strategy.position_size > 0)\n    strategy.close(\"Long\", comment = \"Close Long\")\n\n// SHORT: price above upper band AND RSI in overbought zone\nif (close > upper and strength > rsiOverbought and strategy.position_size > -units * 5)\n    strategy.order(\"Short\", strategy.short, units)\n\n// CLOSE SHORT: when price touches or goes below the middle SMA (basis)\nif (strategy.position_size < 0 and close <= basis)\n    strategy.close(\"Short\", comment = \"Close Short\")\n"
  },
  {
    "url": "UU1hRKLF",
    "name": "Adaptive Alligator  - Asymmetric MH (Entry Only)",
    "description": "\nAdaptive Alligator â€“ Asymmetric Mexican Hat (Entry Only)\n\nThis strategy combines adaptive cycle detection (wavelet + autocorrelation), directional entropy, and a Mexican Hat filter to generate highly selective LONG entry signals. Exits are based solely on the Alligator structure. The system is designed to detect asymmetric, strong, and accelerating bullish phases while filtering out market noise.\n\n1. Adaptive Cycle Detection: The strategy analyzes the median price using wavelet decomposition (Haar, Daubechies D4/D6, Symlet 4), wavelet detail energy, and autocorrelation. It also incorporates the ratio of short-term to long-term ATR volatility. Based on these components, it computes a dominant_cycle value, which dynamically controls the lengths of the Alligator lines (Jaw, Teeth, Lips). This adaptive behavior allows the Alligator to speed up during trending phases and slow down during noise or consolidation.\n\n\n2. Directional Entropy: Entropy is measured separately for upward and downward movements within the selected lookback window. The entropy difference: e_diff = entropy_down - entropy_up represents the directional bias of the market. When e_diff > 0, the market shows an organized bullish pressure; when < 0, bearish dominance.\n\n\n3. Mexican Hat Filter: The Mexican Hat (Ricker Wavelet) acts as a second-derivative filter, detecting local maxima in the acceleration of directional entropy. The filtered output (mh_out) is compared against an adaptive noise level computed as SMA(|mh_out|). A signal is considered strong only when: â€“ mh_out exceeds the adaptive noise level, â€“ mh_out is rising relative to the previous bar. This step is critical for eliminating false signals produced by random fluctuations.\n\n\n4. Entry Logic: A LONG entry requires all three layers: (1) Alligator structure: Lips > Teeth > Jaw. (2) Directional entropy bias: e_diff > 0. (3) A strong, accelerating Mexican Hat signal confirmed by a user-defined number of bars. Once all conditions are satisfied, a buy_final entry is triggered.\n\n\n5. Exit Logic: Exits are intentionally simple and rely solely on the Alligator: crossunder(lips, teeth) This clean separation ensures precise, adaptive entries and stable, consistent exits.\n\n\n6. Visual Components: â€“ Alligator lines: Jaw (blue), Teeth (red), Lips (green), plotted with their characteristic offsets. â€“ Background coloring reflects signal strength: dark green (STRONG BUY), lime (acceleration), yellow (weak bias), transparent otherwise. â€“ A dedicated panel displays e_diff (entropy difference), mh_out (Mexican Hat output), and the adaptive noise band.\n\n\n7. Diagnostic Table: A compact diagnostic dashboard shows: â€“ MH Value, â€“ Noise Level, â€“ MH Acceleration (YES/NO), â€“ Signal Status (STRONG BUY / ACCELERATING / WEAK / BEARISH). It updates on the last bar, making it suitable for live monitoring.\n\n\n8. Use Case: This strategy is highly selective and ideal as an entry module within trend-following systems. By combining wavelets, entropy, and adaptive noise modeling, it effectively filters out consolidation periods and focuses only on statistically significant bullish transitions. It can be integrated with various exit frameworks such as ATR stops, channel-based exits, range boxes, or trailing logic.\n",
    "image_url": "UU1hRKLF",
    "author": "wojlucz",
    "likes": 7,
    "type": "strategy",
    "created": "2025-12-06",
    "updated": "2025-12-06",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// Â© wojlucz\n\n\n//@version=5\nstrategy(\"Adaptive Alligator  - Asymmetric MH (Entry Only)\", overlay=true, \n         initial_capital=10000, default_qty_type=strategy.percent_of_equity, \n         default_qty_value=100, commission_type=strategy.commission.percent, commission_value=0.1)\n\n// ==========================================\n// 1. PARAMETRY WEJÅšCIOWE\n// ==========================================\n\n// --- Alligator & Cykle ---\ngrp_cycle = \"Analiza Cykli i Alligator\"\nwavelet_type    = input.string(\"Daubechies D4\", \"Typ Falki\", options=[\"Haar\", \"Daubechies D4\", \"Daubechies D6\", \"Symlet 4\"], group=grp_cycle)\nanalysis_length = input.int(100, \"DÅ‚ugoÅ›Ä‡ Analizy\", minval=50, maxval=200, group=grp_cycle)\nsmoothing_factor= input.float(0.2, \"WygÅ‚adzanie Cyklu\", minval=0.1, maxval=0.5, step=0.05, group=grp_cycle)\ndc_min_period   = input.int(8, \"Min. Okres\", minval=5, maxval=20, group=grp_cycle)\ndc_max_period   = input.int(55, \"Maks. Okres\", minval=30, maxval=100, group=grp_cycle)\nuse_adaptive    = input.bool(true, \"WÅ‚Ä…cz AdaptacjÄ™ DÅ‚ugoÅ›ci\", group=grp_cycle)\n\n// PrzesuniÄ™cia\ngrp_offset = \"PrzesuniÄ™cia Linii\"\njaw_offset_input   = input.int(8, \"SzczÄ™ka (Jaw)\", minval=1, group=grp_offset)\nteeth_offset_input = input.int(5, \"ZÄ™by (Teeth)\", minval=1, group=grp_offset)\nlips_offset_input  = input.int(3, \"Wargi (Lips)\", minval=1, group=grp_offset)\n\n// --- Filtr Entropii i Mexican Hat ---\ngrp_entropy = \"Filtr: Entropia + Mexican Hat (Asymetryczny PrÃ³g WEJÅšCIA)\"\nuse_entropy_filter = input.bool(true, \"Aktywuj Filtr\", group=grp_entropy)\nentropy_lookback   = input.int(30, \"Okres Entropii\", minval=15, maxval=100, group=grp_entropy)\nmexican_hat_sigma  = input.int(3, \"Sigma Mexican Hat\", minval=2, maxval=20, group=grp_entropy)\nnum_bins_input     = input.int(8, \"Liczba BinÃ³w\", minval=4, maxval=15, group=grp_entropy)\nmin_samples        = input.int(5, \"Min. PrÃ³bek\", minval=3, maxval=15, group=grp_entropy)\nconfirm_bars       = input.int(1, \"Potwierdzenie (Å›wiece)\", minval=1, maxval=10, group=grp_entropy)\nadaptive_lookback  = input.int(50, \"Okres Adaptacji Szumu MH\", minval=20, maxval=100, group=grp_entropy)\n\n\n// --- Backtest ---\ngrp_test = \"Zakres Dat Backtestu\"\nuse_date_filter = input.bool(false, \"Filtruj daty?\", group=grp_test)\nstart_date      = input.time(timestamp(\"2023-01-01 00:00\"), \"Start\", group=grp_test)\nend_date        = input.time(timestamp(\"2099-12-31 23:59\"), \"Koniec\", group=grp_test)\n\nin_date_range = not use_date_filter or (time >= start_date and time <= end_date)\n\n// ==========================================\n// 2. FUNKCJE MATEMATYCZNE\n// ==========================================\n\n// POPRAWIONA FUNKCJA - kaÅ¼dy array.from ma teraz osobnÄ… liniÄ™\nf_get_filters(w_type) =>\n    lo = array.new_float(0), hi = array.new_float(0)\n    if w_type == \"Haar\"\n        lo := array.from(0.70710678, 0.70710678)\n        hi := array.from(-0.70710678, 0.70710678)\n    else if w_type == \"Daubechies D4\"\n        lo := array.from(0.6830127, 1.1830127, 0.3169873, -0.1830127)\n        hi := array.from(-0.1830127, -0.3169873, 1.1830127, -0.6830127)\n    else if w_type == \"Daubechies D6\"\n        lo := array.from(0.47046721, 1.14111692, 0.650365, -0.19093442, -0.12083221, 0.0498175)\n        hi := array.from(0.0498175, 0.12083221, -0.19093442, -0.650365, 1.14111692, -0.47046721)\n    else \n        lo := array.from(-0.0757657, -0.0296355, 0.4976186, 0.8037387, 0.2978577, -0.0992195, -0.0126039, 0.0322231)\n        hi := array.from(-0.0322231, -0.0126039, 0.0992195, 0.2978577, -0.8037387, 0.4976186, 0.0296355, -0.0757657)\n    [lo, hi]\n\nf_dwt(src, lo, hi) =>\n    approx = array.new_float(0), detail = array.new_float(0)\n    len = array.size(src), f_len = array.size(lo)\n    if len >= f_len\n        for i = 0 to math.max(0, math.floor(len / 2) - 1)\n            idx = i * 2\n            if idx + f_len <= len\n                a_sum = 0.0, d_sum = 0.0\n                for j = 0 to f_len - 1\n                    val = array.get(src, idx + j)\n                    a_sum += val * array.get(lo, j), d_sum += val * array.get(hi, j)\n                array.push(approx, a_sum), array.push(detail, d_sum)\n    [approx, detail]\n\nf_energy(arr) =>\n    sum_sq = 0.0, sz = array.size(arr)\n    if sz > 0\n        for i = 0 to sz - 1\n            v = array.get(arr, i)\n            sum_sq += v * v\n    math.sqrt(sum_sq / math.max(1, sz))\n\nf_autocorr(src, lag) =>\n    mean_val = ta.sma(src, lag * 2)\n    sum_prod = 0.0, sum_sq1 = 0.0, sum_sq2 = 0.0\n    for i = 0 to lag - 1\n        v1 = src[i] - mean_val[i], v2 = src[i + lag] - mean_val[i + lag]\n        sum_prod += v1 * v2, sum_sq1 += v1 * v1, sum_sq2 += v2 * v2\n    denom = math.sqrt(sum_sq1 * sum_sq2)\n    denom > 0 ? sum_prod / denom : 0.0\n\nf_mexican_hat_kernel(t, sigma) =>\n    t_norm = t / sigma\n    (1.0 - t_norm * t_norm) * math.exp(-(t_norm * t_norm) / 2.0)\n\nf_mexican_hat_trans(src, sigma) =>\n    hw = math.min(3 * sigma, 50)\n    res = 0.0, norm = 0.0\n    for i = -hw to hw\n        k = f_mexican_hat_kernel(i, sigma)\n        if not na(src[i + hw])\n            res += src[i + hw] * k, norm += math.abs(k)\n    norm > 0 ? res / norm : 0.0\n\nf_calc_entropy(arr, bins) =>\n    sz = array.size(arr)\n    res = 0.0\n    if sz >= 2\n        mn = array.min(arr), mx = array.max(arr)\n        if mx > mn\n            bs = (mx - mn) / bins\n            cnt = array.new_int(bins, 0)\n            for i = 0 to sz - 1\n                idx = int(math.floor((array.get(arr, i) - mn) / bs))\n                idx := math.min(bins - 1, math.max(0, idx))\n                array.set(cnt, idx, array.get(cnt, idx) + 1)\n            ent = 0.0\n            for i = 0 to bins - 1\n                c = array.get(cnt, i)\n                if c > 0\n                    p = c / sz\n                    ent -= p * math.log(p)\n            res := ent / math.log(bins)\n    res\n\nf_dir_entropy(lb, bins, min_s) =>\n    up = array.new_float(0), dn = array.new_float(0)\n    for i = 0 to lb - 1\n        m = close[i] - open[i]\n        if m > 0\n            array.push(up, m)\n        else if m < 0\n            array.push(dn, math.abs(m))\n    e_up = array.size(up) >= min_s ? f_calc_entropy(up, bins) : na\n    e_dn = array.size(dn) >= min_s ? f_calc_entropy(dn, bins) : na\n    diff = (not na(e_up) and not na(e_dn)) ? e_dn - e_up : na\n    [e_up, e_dn, diff]\n\n// ==========================================\n// 4. STRATEGIA\n// ==========================================\n\nmedian_price = (high + low) / 2\n\n// 1. Cykl i Adaptacja \nf_detect_cycle(src, wtype, len, min_p, max_p, smooth) =>\n    var float sm_cyc = (min_p + max_p) / 2\n    [lo, hi] = f_get_filters(wtype)\n    sig = array.new_float(0)\n    for i = 0 to math.min(len - 1, 150)\n        array.push(sig, src[i])\n    curr = array.copy(sig)\n    eng = array.new_float(7, 0.0)\n    for lv = 1 to 6\n        if array.size(curr) < 4\n            break\n        [ap, dt] = f_dwt(curr, lo, hi)\n        if array.size(dt) > 0\n            array.set(eng, lv, f_energy(dt))\n        if array.size(ap) < 2\n            break\n        curr := ap\n    max_e = 0.0, max_s = 3\n    for i = 1 to 6\n        e = array.get(eng, i)\n        if e > max_e\n            max_e := e\n            max_s := i\n    wav_p = math.pow(2, max_s) * 2\n    max_ac = 0.0, best_lag = int((min_p + max_p)/2)\n    step = math.max(1, int((max_p - min_p)/10))\n    for lag = min_p to max_p by step\n        ac = f_autocorr(src, lag)\n        if ac > max_ac\n            max_ac := ac\n            best_lag := lag\n    rng = math.max(2, step)\n    for lag = math.max(min_p, best_lag - rng) to math.min(max_p, best_lag + rng)\n        ac = f_autocorr(src, lag)\n        if ac > max_ac\n            max_ac := ac\n            best_lag := lag\n    vol_rat = ta.atr(50) != 0 ? ta.atr(10) / ta.atr(50) : 1.0\n    adj = vol_rat > 1.2 ? 0.85 : (vol_rat < 0.8 ? 1.15 : 1.0)\n    comb = (best_lag * 0.6 + wav_p * 0.3 + sm_cyc * 0.1) * adj\n    comb := math.max(min_p, math.min(max_p, comb))\n    sm_cyc := smooth * comb + (1 - smooth) * sm_cyc\n    sm_cyc\n\ndominant_cycle = use_adaptive ? f_detect_cycle(median_price, wavelet_type, analysis_length, dc_min_period, dc_max_period, smoothing_factor) : 13.0\n\n// 2. Alligator\nf_smma(src, len) =>\n    var float smma = na\n    if na(smma)\n        smma := ta.sma(src, len)\n    else\n        smma := (smma * (len - 1) + src) / len\n    smma\n\njaw_len   = int(use_adaptive ? math.max(5, dominant_cycle) : 13)\nteeth_len = int(use_adaptive ? math.max(5, dominant_cycle * 8/13) : 8)\nlips_len  = int(use_adaptive ? math.max(3, dominant_cycle * 5/13) : 5)\n\njaw   = f_smma(median_price, jaw_len)\nteeth = f_smma(median_price, teeth_len)\nlips  = f_smma(median_price, lips_len)\njaw_L = jaw[jaw_offset_input], teeth_L = teeth[teeth_offset_input], lips_L = lips[lips_offset_input]\n\n// 3. Filtr Entropii + MHW \n[e_up, e_dn, e_diff] = f_dir_entropy(entropy_lookback, num_bins_input, min_samples)\nmh_out = f_mexican_hat_trans(e_diff, mexican_hat_sigma)\n\n// === LOGIKA WEJÅšCIA (ASYMETRYCZNA, WYMAGA PRZYSPIESZENIA) ===\nadaptive_noise_level = ta.sma(math.abs(mh_out), adaptive_lookback) \n\nis_bullish_bias = e_diff > 0\nis_strong_signal = mh_out > adaptive_noise_level \nis_accelerating = mh_out > mh_out[1] \n\n// Warunek WejÅ›cia: Bias ORAZ Statystycznie Silny SygnaÅ‚ ORAZ Aktywne Przyspieszenie\ncond_filtered = is_bullish_bias and is_strong_signal and is_accelerating\n\n// Potwierdzenie czasowe\nvar cnt_confirm = 0\ncnt_confirm := cond_filtered ? cnt_confirm + 1 : 0\nis_confirmed = cnt_confirm >= confirm_bars\n\n// SygnaÅ‚y WejÅ›cia\nbuy_basic = lips_L > teeth_L and teeth_L > jaw_L\nbuy_final = buy_basic and (not use_entropy_filter or is_confirmed) and in_date_range\n\n// ==============================================================\n// === LOGIKA WYJÅšCIA (WYÅÄ„CZNIE ALLIGATOR) ===\n// ==============================================================\nexit_sig = ta.crossunder(lips_L, teeth_L)\n\n// ==========================================\n// 5. EGZEKUCJA I WIZUALIZACJA\n// ==========================================\n\nif buy_final\n    strategy.entry(\"Long\", strategy.long)\n\nif exit_sig\n    strategy.close(\"Long\")\n\n// Alligator Plots\nplot(jaw, \"SzczÄ™ka\", color.blue, 2, offset=jaw_offset_input)\nplot(teeth, \"ZÄ™by\", color.red, 2, offset=teeth_offset_input)\nplot(lips, \"Wargi\", color.green, 2, offset=lips_offset_input)\n\n// Kolor tÅ‚a - wizualizacja strefy\nbg_col = not use_entropy_filter ? na :\n         (is_confirmed ? color.new(color.green, 85) : \n          cond_filtered ? color.new(color.lime, 90) : \n          is_bullish_bias ? color.new(color.yellow, 95) : na)\nbgcolor(bg_col, title=\"Strefa Trendu\")\n\nplotshape(buy_final and not buy_final[1], \"BUY\", shape.triangleup, location.belowbar, color.green, size=size.small)\nplotshape(exit_sig and not exit_sig[1], \"EXIT\", shape.triangledown, location.abovebar, color.red, size=size.small)\n\n\n// Panel Entropii\nplot(e_diff, \"Entropy Diff\", color.gray, 1, display=display.pane)\nplot(mh_out, \"Mexican Hat\", color.aqua, 2, display=display.pane)\n\n// Rysowanie ADAPTACYJNEGO PASMA SZUMU\nplot(adaptive_noise_level, \"Adaptive Threshold (+)\", color.red, 1, display=display.pane)\nplot(-adaptive_noise_level, \"Adaptive Threshold (-)\", color.red, 1, display=display.pane)\nhline(0, \"Zero\", color.white, linestyle=hline.style_dotted)\n\n// WypeÅ‚nienie strefy szumu\np1 = plot(adaptive_noise_level, display=display.none)\np2 = plot(-adaptive_noise_level, display=display.none)\nfill(p1, p2, color.new(color.red, 90), title=\"Adaptive Noise Zone\")\n\n// Tabela\nvar table tbl = table.new(position.top_right, 2, 6, bgcolor=color.new(color.black, 60), frame_color=color.gray, frame_width=1)\nif barstate.islast\n    is_accelerating_check = mh_out > mh_out[1]\n    status_text = is_confirmed ? \"STRONG BUY\" : cond_filtered ? \"ACCELERATING\" : is_bullish_bias ? \"NOISE / WEAK\" : \"BEARISH\"\n    col = is_confirmed ? color.green : cond_filtered ? color.lime : is_bullish_bias ? color.orange : color.red\n    \n    table.cell(tbl, 0, 0, \"MH Value\", text_color=color.white)\n    table.cell(tbl, 1, 0, str.tostring(math.round(mh_out, 4)), text_color=color.aqua)\n    \n    table.cell(tbl, 0, 1, \"Noise Level\", text_color=color.white)\n    table.cell(tbl, 1, 1, str.tostring(math.round(adaptive_noise_level, 4)), text_color=color.red)\n    \n    table.cell(tbl, 0, 2, \"MH Przysp.\", text_color=color.white)\n    table.cell(tbl, 1, 2, is_accelerating_check ? \"TAK\" : \"NIE\", text_color=is_accelerating_check ? color.green : color.red)\n    \n    table.cell(tbl, 0, 3, \"Status SygnaÅ‚u\", text_color=color.white)\n    table.cell(tbl, 1, 3, status_text, text_color=col)"
  },
  {
    "url": "y1TGXhye-Options-Scalper-v2-SPY-QQQ",
    "name": "Options Scalper v2 - SPY/QQQ",
    "description": "Here's a comprehensive description of the Options Scalper v2 strategy:\n\n---\n\n## Options Scalper v2 - SPY/QQQ\n\n### Overview\n\nA multi-indicator confluence-based scalping strategy designed for trading SPY and QQQ options on short timeframes (1-5 minute charts). The strategy uses a scoring system to generate high-probability CALL and PUT signals by requiring alignment across multiple technical indicators before triggering entries.\n\n---\n\n### Core Logic\n\nThe strategy operates on a **scoring system (0-9 points)** where both bullish (CALL) and bearish (PUT) conditions are evaluated independently. A signal only fires when:\n\n1. A recent EMA crossover occurred (within the last 3 bars)\n2. The direction's score meets the minimum threshold (default: 4 points)\n3. The signal's score is higher than the opposite direction\n4. Enough bars have passed since the last signal (cooldown period)\n5. Price action occurs during valid trading sessions\n\n---\n\n### Indicators Used\n\n| Indicator | Purpose | CALL Condition | PUT Condition |\n|-----------|---------|----------------|---------------|\n| **9/21 EMA Cross** | Primary trigger | Fast EMA crosses above slow | Fast EMA crosses below slow |\n| **200 EMA** | Trend filter | Price above 200 EMA | Price below 200 EMA |\n| **RSI (14)** | Momentum filter | RSI between 45-65 | RSI between 35-55 |\n| **VWAP** | Institutional level | Price above VWAP | Price below VWAP |\n| **MACD (12,26,9)** | Momentum confirmation | MACD line > Signal line | MACD line < Signal line |\n| **Stochastic (14,3)** | Overbought/Oversold | Oversold or K > D | Overbought or K < D |\n| **Volume** | Participation confirmation | Spike on green candle | Spike on red candle |\n| **Price Structure** | Breakout detection | Higher high formed | Lower low formed |\n\n---\n\n### Scoring Breakdown\n\n**CALL Score (Max 9 points):**\n- Recent EMA cross up: +2 pts\n- EMA alignment (fast > slow): +1 pt\n- RSI in bullish range: +1 pt\n- Above VWAP: +1 pt\n- MACD bullish: +1 pt\n- Volume spike on green candle: +1 pt\n- Stochastic setup: +1 pt\n- Above 200 EMA: +1 pt\n- Breaking higher high: +1 pt\n\n**PUT Score (Max 9 points):**\n- Recent EMA cross down: +2 pts\n- EMA alignment (fast < slow): +1 pt\n- RSI in bearish range: +1 pt\n- Below VWAP: +1 pt\n- MACD bearish: +1 pt\n- Volume spike on red candle: +1 pt\n- Stochastic setup: +1 pt\n- Below 200 EMA: +1 pt\n- Breaking lower low: +1 pt\n\n---\n\n### Risk Management\n\nThe strategy uses **ATR-based dynamic stops and targets**:\n\n| Parameter | Default | Description |\n|-----------|---------|-------------|\n| Stop Loss | 1.5x ATR | Distance below entry for longs, above for shorts |\n| Take Profit | 2.0x ATR | Creates a 1:1.33 risk-reward ratio |\n\nPositions are also closed on:\n- Opposite direction signal (flip trade)\n- Take profit or stop loss hit\n\n---\n\n### Session Filtering\n\nTrades are restricted to high-liquidity periods by default:\n- **Morning Session:** 9:30 AM - 11:00 AM EST\n- **Afternoon Session:** 2:30 PM - 3:55 PM EST\n\nThis avoids choppy midday price action and captures the highest volume periods.\n\n---\n\n### Input Parameters\n\n| Parameter | Default | Description |\n|-----------|---------|-------------|\n| Fast EMA | 9 | Fast moving average period |\n| Slow EMA | 21 | Slow moving average period |\n| Trend EMA | 200 | Long-term trend filter |\n| RSI Length | 14 | RSI calculation period |\n| RSI Overbought | 65 | Upper RSI threshold |\n| RSI Oversold | 35 | Lower RSI threshold |\n| Volume Multiplier | 1.2x | Volume spike detection threshold |\n| Min Signal Strength | 4 | Minimum score required to trigger |\n| Crossover Lookback | 3 | Bars to consider crossover \"recent\" |\n| Min Bars Between Signals | 5 | Cooldown period between signals |\n\n---\n\n### Visual Elements\n\n**Chart Plots:**\n- Green line: 9 EMA (fast)\n- Red line: 21 EMA (slow)\n- Gray line: 200 EMA (trend)\n- Purple dots: VWAP\n\n**Signal Markers:**\n- Green triangle up + \"CALL\" label: Buy call signal\n- Red triangle down + \"PUT\" label: Buy put signal\n- Small circles: EMA crossover reference points\n\n**Info Table (Top Right):**\n- Real-time CALL and PUT scores\n- RSI, MACD, Stochastic values\n- VWAP and 200 EMA position\n- Recent crossover status\n- Current signal state\n\n---\n\n### Alerts\n\n| Alert Name | Trigger |\n|------------|---------|\n| CALL Entry | Standard call signal fires |\n| PUT Entry | Standard put signal fires |\n| Strong CALL | Call signal with score â‰¥ 6 |\n| Strong PUT | Put signal with score â‰¥ 6 |\n\n---\n\n### Recommended Usage\n\n| Setting | 0DTE Scalping | Intraday Swings |\n|---------|---------------|-----------------|\n| Timeframe | 1-2 min | 5 min |\n| Min Signal Strength | 5-6 | 4 |\n| ATR Stop Mult | 1.0 | 1.5 |\n| ATR TP Mult | 1.5 | 2.0 |\n| Option Delta | 0.40-0.50 | 0.30-0.40 |\n\n---\n\n### Key Improvements Over v1\n\n1. **Requires actual crossover** - Eliminates false signals from simple trend continuation\n2. **Balanced scoring** - Both directions evaluated equally, highest score wins\n3. **Signal cooldown** - Prevents overtrading with minimum bar spacing\n4. **Multi-indicator confluence** - 8 factors must align for signal generation\n5. **Volume-candle alignment** - Volume spikes only count when matching candle direction\n\n---\n\n### Disclaimer\n\nThis strategy is for educational purposes. Backtest thoroughly before live trading. Options trading involves significant risk of loss. Past performance does not guarantee future results.",
    "image_url": "y1TGXhye",
    "author": "hakan_gul_79",
    "likes": 132,
    "type": "strategy",
    "created": "2025-12-06",
    "updated": "2025-12-06",
    "source": "//@version=5\nstrategy(\"Options Scalper v2 - SPY/QQQ\", overlay=true, default_qty_type=strategy.percent_of_equity, default_qty_value=100)\n\n// ============================================\n// INPUTS\n// ============================================\nemaFastLen = input.int(9, \"Fast EMA\", minval=1, group=\"EMAs\")\nemaSlowLen = input.int(21, \"Slow EMA\", minval=1, group=\"EMAs\")\nema200Len = input.int(200, \"Trend EMA\", minval=1, group=\"EMAs\")\n\nrsiLen = input.int(14, \"RSI Length\", minval=1, group=\"RSI\")\nrsiOB = input.int(65, \"RSI Overbought\", group=\"RSI\")\nrsiOS = input.int(35, \"RSI Oversold\", group=\"RSI\")\n\nuseVwap = input.bool(true, \"Use VWAP Filter\", group=\"VWAP\")\n\nvolMult = input.float(1.2, \"Volume Spike Multiplier\", minval=1.0, group=\"Volume\")\nvolLen = input.int(20, \"Volume MA Length\", group=\"Volume\")\n\natrLen = input.int(14, \"ATR Length\", group=\"Risk\")\natrMult = input.float(1.5, \"ATR Stop Multiplier\", group=\"Risk\")\ntpMult = input.float(2.0, \"ATR Take Profit Multiplier\", group=\"Risk\")\n\nuseSession = input.bool(true, \"Trade Only During Market Hours\", group=\"Session\")\nsessionStart = input.session(\"0930-1100\", \"Morning Session\", group=\"Session\")\nsessionEnd = input.session(\"1430-1555\", \"Afternoon Session\", group=\"Session\")\n\n// Signal Strength Filter\nminSignalStrength = input.int(4, \"Min Signal Strength (1-6)\", minval=1, maxval=6, group=\"Filters\")\n\n// ============================================\n// CALCULATIONS\n// ============================================\nemaFast = ta.ema(close, emaFastLen)\nemaSlow = ta.ema(close, emaSlowLen)\nema200 = ta.ema(close, ema200Len)\n\nrsi = ta.rsi(close, rsiLen)\nvwapValue = ta.vwap(hlc3)\n\nvolMA = ta.sma(volume, volLen)\nvolSpike = volume > volMA * volMult\n\natr = ta.atr(atrLen)\n\n// MACD for additional confirmation\n[macdLine, signalLine, histLine] = ta.macd(close, 12, 26, 9)\nmacdBullish = macdLine > signalLine and histLine > histLine[1]\nmacdBearish = macdLine < signalLine and histLine < histLine[1]\n\n// Stochastic for oversold/overbought\nstochK = ta.stoch(close, high, low, 14)\nstochD = ta.sma(stochK, 3)\nstochOS = stochK < 25 and stochD < 25\nstochOB = stochK > 75 and stochD > 75\n\n// ============================================\n// STRICT CROSSOVER SIGNALS ONLY\n// ============================================\n// Only trigger on ACTUAL crossovers, not continuation\nemaCrossUp = ta.crossover(emaFast, emaSlow)\nemaCrossDown = ta.crossunder(emaFast, emaSlow)\n\n// Require crossover within last N bars for signal validity\nlookback = input.int(3, \"Crossover Lookback Bars\", group=\"Filters\")\nrecentCrossUp = ta.barssince(emaCrossUp) <= lookback\nrecentCrossDown = ta.barssince(emaCrossDown) <= lookback\n\n// Price relative to key levels\naboveVwap = close > vwapValue\nbelowVwap = close < vwapValue\naboveEma200 = close > ema200\nbelowEma200 = close < ema200\n\n// Candle patterns\nbullishCandle = close > open and (close - open) > (high - low) * 0.5\nbearishCandle = close < open and (open - close) > (high - low) * 0.5\n\n// Higher highs / Lower lows\nhigherHigh = high > ta.highest(high[1], 5)\nlowerLow = low < ta.lowest(low[1], 5)\n\n// Session Check\ninMorningSession = time(timeframe.period, sessionStart)\ninAfternoonSession = time(timeframe.period, sessionEnd)\ninSession = useSession ? (inMorningSession or inAfternoonSession) : true\n\n// ============================================\n// SCORING SYSTEM (More Balanced)\n// ============================================\nvar int callScore = 0\nvar int putScore = 0\n\n// Calculate CALL score\ncallScore := 0\ncallScore := callScore + (recentCrossUp ? 2 : 0)                    // EMA cross (2 pts)\ncallScore := callScore + (emaFast > emaSlow ? 1 : 0)                // EMA alignment (1 pt)\ncallScore := callScore + (rsi > 45 and rsi < rsiOB ? 1 : 0)         // RSI in range (1 pt)\ncallScore := callScore + (aboveVwap and useVwap ? 1 : 0)            // Above VWAP (1 pt)\ncallScore := callScore + (macdBullish ? 1 : 0)                       // MACD bullish (1 pt)\ncallScore := callScore + (volSpike and bullishCandle ? 1 : 0)       // Volume on green (1 pt)\ncallScore := callScore + (stochOS or stochK > stochD ? 1 : 0)       // Stoch setup (1 pt)\ncallScore := callScore + (aboveEma200 ? 1 : 0)                       // Above 200 EMA (1 pt)\ncallScore := callScore + (higherHigh ? 1 : 0)                        // Breaking higher (1 pt)\n\n// Calculate PUT score  \nputScore := 0\nputScore := putScore + (recentCrossDown ? 2 : 0)                    // EMA cross (2 pts)\nputScore := putScore + (emaFast < emaSlow ? 1 : 0)                  // EMA alignment (1 pt)\nputScore := putScore + (rsi < 55 and rsi > rsiOS ? 1 : 0)           // RSI in range (1 pt)\nputScore := putScore + (belowVwap and useVwap ? 1 : 0)              // Below VWAP (1 pt)\nputScore := putScore + (macdBearish ? 1 : 0)                         // MACD bearish (1 pt)\nputScore := putScore + (volSpike and bearishCandle ? 1 : 0)         // Volume on red (1 pt)\nputScore := putScore + (stochOB or stochK < stochD ? 1 : 0)         // Stoch setup (1 pt)\nputScore := putScore + (belowEma200 ? 1 : 0)                         // Below 200 EMA (1 pt)\nputScore := putScore + (lowerLow ? 1 : 0)                            // Breaking lower (1 pt)\n\n// ============================================\n// SIGNAL LOGIC - REQUIRE CROSSOVER + MIN SCORE\n// ============================================\n// Key fix: REQUIRE recent crossover, don't just check trend direction\ncallSignal = recentCrossUp and callScore >= minSignalStrength and inSession and callScore > putScore\nputSignal = recentCrossDown and putScore >= minSignalStrength and inSession and putScore > callScore\n\n// Prevent signals too close together\nvar int barsSinceSignal = 0\nbarsSinceSignal := barsSinceSignal + 1\n\nminBarsBetween = input.int(5, \"Min Bars Between Signals\", group=\"Filters\")\ncanTrade = barsSinceSignal >= minBarsBetween\n\nfinalCallSignal = callSignal and canTrade\nfinalPutSignal = putSignal and canTrade\n\nif finalCallSignal or finalPutSignal\n    barsSinceSignal := 0\n\n// ============================================\n// RISK MANAGEMENT\n// ============================================\nlongStop = close - (atr * atrMult)\nlongTP = close + (atr * tpMult)\nshortStop = close + (atr * atrMult)\nshortTP = close - (atr * tpMult)\n\n// ============================================\n// STRATEGY EXECUTION\n// ============================================\nif finalCallSignal and strategy.position_size == 0\n    strategy.entry(\"CALL\", strategy.long)\n    strategy.exit(\"CALL Exit\", \"CALL\", stop=longStop, limit=longTP)\n\nif finalPutSignal and strategy.position_size == 0\n    strategy.entry(\"PUT\", strategy.short)\n    strategy.exit(\"PUT Exit\", \"PUT\", stop=shortStop, limit=shortTP)\n\n// Exit on opposite signal\nif strategy.position_size > 0 and finalPutSignal\n    strategy.close(\"CALL\", comment=\"Flip to PUT\")\n    \nif strategy.position_size < 0 and finalCallSignal\n    strategy.close(\"PUT\", comment=\"Flip to CALL\")\n\n// ============================================\n// PLOTTING\n// ============================================\nplot(emaFast, \"Fast EMA\", color=color.new(color.green, 0), linewidth=2)\nplot(emaSlow, \"Slow EMA\", color=color.new(color.red, 0), linewidth=2)\nplot(ema200, \"200 EMA\", color=color.new(color.gray, 50), linewidth=1)\nplot(useVwap ? vwapValue : na, \"VWAP\", color=color.new(color.purple, 0), linewidth=2, style=plot.style_circles)\n\n// Signal Markers - Only on actual signals\nplotshape(finalCallSignal, \"CALL\", shape.triangleup, location.belowbar, color.new(color.lime, 0), size=size.normal, text=\"CALL\")\nplotshape(finalPutSignal, \"PUT\", shape.triangledown, location.abovebar, color.new(color.red, 0), size=size.normal, text=\"PUT\")\n\n// EMA Crossover markers (small, for reference)\nplotshape(emaCrossUp, \"EMA Cross Up\", shape.circle, location.belowbar, color.new(color.green, 50), size=size.tiny)\nplotshape(emaCrossDown, \"EMA Cross Down\", shape.circle, location.abovebar, color.new(color.red, 50), size=size.tiny)\n\n// ============================================\n// INFO TABLE\n// ============================================\nvar table infoTable = table.new(position.top_right, 2, 10, bgcolor=color.new(color.black, 80))\n\nif barstate.islast\n    table.cell(infoTable, 0, 0, \"CALL Score\", text_color=color.white, text_size=size.small)\n    table.cell(infoTable, 1, 0, str.tostring(callScore) + \"/9\", text_color=callScore >= minSignalStrength ? color.lime : color.gray, text_size=size.small)\n    \n    table.cell(infoTable, 0, 1, \"PUT Score\", text_color=color.white, text_size=size.small)\n    table.cell(infoTable, 1, 1, str.tostring(putScore) + \"/9\", text_color=putScore >= minSignalStrength ? color.red : color.gray, text_size=size.small)\n    \n    table.cell(infoTable, 0, 2, \"RSI\", text_color=color.white, text_size=size.small)\n    table.cell(infoTable, 1, 2, str.tostring(rsi, \"#.#\"), text_color=rsi > rsiOB ? color.red : rsi < rsiOS ? color.green : color.white, text_size=size.small)\n    \n    table.cell(infoTable, 0, 3, \"MACD\", text_color=color.white, text_size=size.small)\n    table.cell(infoTable, 1, 3, macdBullish ? \"BULL\" : macdBearish ? \"BEAR\" : \"NEUTRAL\", text_color=macdBullish ? color.lime : macdBearish ? color.red : color.gray, text_size=size.small)\n    \n    table.cell(infoTable, 0, 4, \"Stoch\", text_color=color.white, text_size=size.small)\n    table.cell(infoTable, 1, 4, str.tostring(stochK, \"#.#\"), text_color=stochOB ? color.red : stochOS ? color.green : color.white, text_size=size.small)\n    \n    table.cell(infoTable, 0, 5, \"VWAP\", text_color=color.white, text_size=size.small)\n    table.cell(infoTable, 1, 5, aboveVwap ? \"ABOVE\" : \"BELOW\", text_color=aboveVwap ? color.lime : color.red, text_size=size.small)\n    \n    table.cell(infoTable, 0, 6, \"200 EMA\", text_color=color.white, text_size=size.small)\n    table.cell(infoTable, 1, 6, aboveEma200 ? \"ABOVE\" : \"BELOW\", text_color=aboveEma200 ? color.lime : color.red, text_size=size.small)\n    \n    table.cell(infoTable, 0, 7, \"Cross\", text_color=color.white, text_size=size.small)\n    crossText = recentCrossUp ? \"UP (\" + str.tostring(ta.barssince(emaCrossUp)) + \")\" : recentCrossDown ? \"DOWN (\" + str.tostring(ta.barssince(emaCrossDown)) + \")\" : \"NONE\"\n    table.cell(infoTable, 1, 7, crossText, text_color=recentCrossUp ? color.lime : recentCrossDown ? color.red : color.gray, text_size=size.small)\n    \n    table.cell(infoTable, 0, 8, \"Signal\", text_color=color.white, text_size=size.small)\n    table.cell(infoTable, 1, 8, finalCallSignal ? \">>> CALL <<<\" : finalPutSignal ? \">>> PUT <<<\" : \"WAIT\", text_color=finalCallSignal ? color.lime : finalPutSignal ? color.red : color.gray, text_size=size.small)\n\n// ============================================\n// ALERTS\n// ============================================\nalertcondition(finalCallSignal, \"CALL Entry\", \"ðŸŸ¢ CALL: {{ticker}} @ {{close}}\")\nalertcondition(finalPutSignal, \"PUT Entry\", \"ðŸ”´ PUT: {{ticker}} @ {{close}}\")\n\n// High confidence alerts (score >= 6)\nalertcondition(finalCallSignal and callScore >= 6, \"Strong CALL\", \"ðŸŸ¢ðŸŸ¢ STRONG CALL: {{ticker}} @ {{close}}\")\nalertcondition(finalPutSignal and putScore >= 6, \"Strong PUT\", \"ðŸ”´ðŸ”´ STRONG PUT: {{ticker}} @ {{close}}\")"
  },
  {
    "url": "Pq5A4UQA",
    "name": "SETUP DAVYD DLUCAS LIRA BRITO",
    "description": "Setup DSavyd Dlucas sobre o padrÃ£o Heikin Ashin de fluxo ",
    "image_url": "Pq5A4UQA",
    "author": "lucasplima98",
    "likes": 1,
    "type": "strategy",
    "created": "2025-12-06",
    "updated": "2025-12-06",
    "source": "//@version=5\nstrategy(\"SETUP DAVYD DLUCAS LIRA BRITO\", overlay=true, margin_long=100, margin_short=100)\n\n// ----------------------\n// Heikin Ashi calculado (correÃ§Ã£o: declarar haOpen como var para usar haOpen[1])\n// ----------------------\nhaClose = (open + high + low + close) / 4\n\nvar float haOpen = na\nhaOpen := na(haOpen[1]) ? (open + close) / 2 : (haOpen[1] + haClose[1]) / 2\n\nhaHigh = math.max(high, math.max(haOpen, haClose))\nhaLow  = math.min(low,  math.min(haOpen, haClose))\n\n// ----------------------\n// Bandas de Bollinger com OFFSET 8\n// ----------------------\nlength = 20\nmult = 2.0\n\nbasis = ta.sma(close, length)\ndev = mult * ta.stdev(close, length)\nupper = basis + dev\nlower = basis - dev\n\n// offset 8 (8 barras atrÃ¡s)\nupper_off = upper[8]\nlower_off = lower[8]\n\n// ----------------------\n// Volume\n// ----------------------\nvolOK = volume > ta.sma(volume, 20)\n\n// ----------------------\n// Regras de TendÃªncia\n// ----------------------\nlongTrend  = close > upper_off and volOK and haClose > haOpen\nshortTrend = close < lower_off and volOK and haClose < haOpen\n\n// ----------------------\n// Regras de ReversÃ£o (Heikin Ashi)\n// ----------------------\nbullRev = haClose > haOpen and haClose > haHigh[1]\nbearRev = haClose < haOpen and haClose < haLow[1]\n\n// ----------------------\n// Entradas\n// ----------------------\nif (longTrend or bullRev)\n    strategy.entry(\"Long\", strategy.long)\n\nif (shortTrend or bearRev)\n    strategy.entry(\"Short\", strategy.short)\n\n// ----------------------\n// Stop (exemplo simples usando Ãºltimo topo/fundo - ajuste conforme preferir)\n// ----------------------\nstopLong = ta.lowest(low, 10)   // exemplo: menor low das Ãºltimas 10 barras\nstopShort = ta.highest(high, 10)\n\nstrategy.exit(\"Exit Long\", \"Long\", stop=stopLong)\nstrategy.exit(\"Exit Short\", \"Short\", stop=stopShort)\n\n// ----------------------\n// Plots visuais\n// ----------------------\nplot(upper_off, \"Upper Offset\", color=color.red)\nplot(lower_off, \"Lower Offset\", color=color.green)\nplotshape(longTrend,  title=\"TendÃªncia Alta\", style=shape.triangleup,   color=color.green,  size=size.small, location=location.belowbar)\nplotshape(shortTrend, title=\"TendÃªncia Baixa\", style=shape.triangledown, color=color.red,    size=size.small, location=location.abovebar)\nplotshape(bullRev,    title=\"ReversÃ£o Alta\",   style=shape.circle,     color=color.new(color.green, 0), size=size.tiny, location=location.belowbar)\nplotshape(bearRev,    title=\"ReversÃ£o Baixa\",  style=shape.circle,     color=color.new(color.red, 0),   size=size.tiny, location=location.abovebar)"
  },
  {
    "url": "opfANVfG-Pious-3-8-EMA-High-Low-89-EMA-Strategy",
    "name": "Pious 3/8 EMA High-Low + 89 EMA Strategy",
    "description": "buy signal when 3emah cross above 8emah, 3emal cross above 8emal,high cross above previous 3 high with volume and vice versa",
    "image_url": "opfANVfG",
    "author": "pious2431",
    "likes": 8,
    "type": "strategy",
    "created": "2025-12-06",
    "updated": "2025-12-06",
    "source": "//@version=5\nstrategy(\"3/8 EMA High-Low + 89 EMA Strategy\",\n     overlay = true,\n     initial_capital = 10000,\n     default_qty_type = strategy.percent_of_equity,\n     default_qty_value = 100)\n\n// Indicators\nema3h    = ta.ema(high, 3)\nema3l    = ta.ema(low, 3)\nema8h    = ta.ema(high, 8)\nema8l    = ta.ema(low, 8)\nema89    = ta.ema(close, 89)\nsma_vol9 = ta.sma(volume, 9)\nrsi_val  = ta.rsi(close, 14)\n\n// Buy conditions\nprice_above_ema89 = close > ema89\nrsi_above_55      = rsi_val > 55\ncross_h_up        = ta.crossover(ema3h, ema8h)\ncross_l_up        = ta.crossover(ema3l, ema8l)\ncrosses_in_last2_h = cross_h_up or cross_h_up[1]\ncrosses_in_last2_l = cross_l_up or cross_l_up[1]\nvol_above         = volume > sma_vol9\nvol_spike_3bars   = volume > volume[1] and volume > volume[2] and volume > volume[3]\nprev_high1        = high[1]\nprev_high2        = high[2]\nprice_break_high  = close > math.max(prev_high1, prev_high2)\n\nlong_condition =\n     price_above_ema89 and rsi_above_55 and\n     crosses_in_last2_h and crosses_in_last2_l and\n     vol_above and vol_spike_3bars and price_break_high\n\n// Sell conditions\nprice_below_ema89 = close < ema89\nrsi_below_45      = rsi_val < 45\ncross_h_down      = ta.crossunder(ema3h, ema8h)\ncross_l_down      = ta.crossunder(ema3l, ema8l)\ncrosses_in_last2_h_down = cross_h_down or cross_h_down[1]\ncrosses_in_last2_l_down = cross_l_down or cross_l_down[1]\nprice_break_low   = close < math.min(low[1], low[2])\n\nshort_condition =\n     price_below_ema89 and rsi_below_45 and\n     crosses_in_last2_h_down and crosses_in_last2_l_down and\n     vol_above and price_break_low\n\n// Exit rules\nlong_sl_cond  = ta.crossunder(ema3l, ema8l) or (ema3l <= ema8l and ema3h <= ema8h)\nlong_tp_cond  = ta.crossunder(rsi_val, 80)\nshort_sl_cond = ta.crossover(ema3l, ema8l) or (ema3l >= ema8l and ema3h >= ema8h)\nshort_tp_cond = ta.crossover(rsi_val, 20)\n\n// Entries\nif long_condition\n    strategy.entry(\"Long\", strategy.long)\n\nif short_condition\n    strategy.entry(\"Short\", strategy.short)\n\n// Exits\nif strategy.position_size > 0\n    if long_sl_cond\n        strategy.close(\"Long\", comment = \"Long SL\")\n    if long_tp_cond\n        strategy.close(\"Long\", comment = \"Long TP\")\n\nif strategy.position_size < 0\n    if short_sl_cond\n        strategy.close(\"Short\", comment = \"Short SL\")\n    if short_tp_cond\n        strategy.close(\"Short\", comment = \"Short TP\")\n\n// Plots\nplot(ema3h, color=color.blue,   title=\"EMA3H\", linewidth=1)\nplot(ema3l, color=color.new(color.blue, 50),   title=\"EMA3L\", linewidth=1)\nplot(ema8h, color=color.orange, title=\"EMA8H\", linewidth=1)\nplot(ema8l, color=color.new(color.orange, 50), title=\"EMA8L\", linewidth=1)\nplot(ema89, color=color.black,  title=\"EMA89\", linewidth=2)\n\nplotshape(long_condition,  title=\"Buy\",  style=shape.triangleup,   location=location.belowbar, color=color.lime, size=size.small)\nplotshape(short_condition, title=\"Sell\", style=shape.triangledown, location=location.abovebar, color=color.red,  size=size.small)\n"
  },
  {
    "url": "cDdnzUxd-Hyper-Insight-MA-Strategy-Universal",
    "name": "Hyper Insight MA Strategy [Universal]",
    "description": "Hyper Insight MA Strategy  ** is a comprehensive trend-following engine designed for traders who require precision and flexibility. Unlike standard indicators that lock you into a single calculation method, this strategy serves as a \"Universal Adapter,\" allowing you to **Mix & Match 13 different Moving Average types** for both the Fast and Slow trend lines independently.\n\nWhether you need the smoothness of T3, the responsiveness of HMA, or the classic reliability of SMA, this script enables you to backtest thousands of combinations to find the perfect edge for your specific asset class.\n\n---\n\n ðŸ”¬ Deep Dive: Calculation Logic of Included MAs\n\nThis strategy includes 13 distinct calculation methods. Understanding the math behind them will help you choose the right tool for your specific market conditions.\n\n#### 1. Standard Averages\n* **SMA (Simple Moving Average):** The unweighted mean of the previous $n$ data points.\n    * *Logic:* Treats every price point in the period with equal importance. Good for identifying long-term macro trends but reacts slowly to recent volatility.\n* **WMA (Weighted Moving Average):** A linear weighted average.\n    * *Logic:* Assigns heavier weight to current data linearly (e.g., $1, 2, 3... n$). It reacts faster than SMA but is still relatively smooth.\n* **SWMA (Symmetrically Weighted Moving Average):**\n    * *Logic:* Uses a fixed-length window (usually 4 bars) with symmetrical weights $ $. It prioritizes the center of the recent data window.\n\n#### 2. Exponential & Lag-Reducing Averages\n* **EMA (Exponential Moving Average):**\n    * *Logic:* Applies an exponential decay weighting factor. Recent prices have significantly more impact on the average than older prices, reducing lag compared to SMA.\n* **RMA (Running Moving Average):** Also known as Wilder's Smoothing (used in RSI).\n    * *Logic:* It is essentially an EMA but with a slower alpha weight of $1/length$. It provides a very smooth, stable line that filters out noise effectively.\n* **DEMA (Double Exponential Moving Average):**\n    * *Logic:* Calculated as $2 \\times EMA - EMA(EMA)$. By subtracting the \"lag\" (the smoothed EMA) from the original EMA, DEMA provides a much faster reaction to price changes with less noise than a standard EMA.\n* **TEMA (Triple Exponential Moving Average):**\n    * *Logic:* Calculated as $3 \\times EMA - 3 \\times EMA(EMA) + EMA(EMA(EMA))$. This effectively eliminates the lag inherent in single and double EMAs, making it an extremely fast-tracking indicator for scalping.\n\n#### 3. Advanced & Adaptive Averages\n* **HMA (Hull Moving Average):**\n    * *Logic:* A composite formula involving Weighted Moving Averages:  ASX:WMA (2 \\times Integer(n/2)) - WMA(n)$. The result is then smoothed by a $\\sqrt{n}$ WMA.\n    * *Effect:* It eliminates lag almost entirely while managing to improve curve smoothness, solving the traditional trade-off between speed and noise.\n* **ZLEMA (Zero Lag Exponential Moving Average):**\n    * *Logic:* This calculation attempts to remove lag by modifying the data source before smoothing. It calculates a \"lag\" value $(length-1)/2$ and applies an EMA to the data: $Source + (Source - Source )$. This creates a projection effect that tracks price tightly.\n* **T3 (Tillson T3 Moving Average):**\n    * *Logic:* A complex smoothing technique that runs an EMA through a filter multiple times using a \"Volume Factor\" (set to 0.7 in this script).\n    * *Effect:* It produces a curve that is incredibly smooth and free of \"overshoot,\" making it excellent for filtering out market chop.\n* **ALMA (Arnaud Legoux Moving Average):**\n    * *Logic:* Uses a Gaussian distribution (bell curve) to assign weights. It allows the user to offset the moving average (moving the peak of the weight) to align it perfectly with the price, balancing smoothness and responsiveness.\n* **LSMA (Least Squares Moving Average):**\n    * *Logic:* Calculates the endpoint of a Linear Regression line for the lookback period. It essentially guesses where the price \"should\" be based on the best-fit line of the recent trend.\n* **VWMA (Volume Weighted Moving Average):**\n    * *Logic:* Weights the closing price by the volume of that bar.\n    * *Effect:* Prices on high volume days pull the MA harder than prices on low volume days. This is excellent for validating true trend strength (i.e., a breakout on high volume will move the VWMA significantly).\n\n---\n\n### ðŸ›  Features & Settings\n* **Universal Switching:** Change the `Fast MA` and `Slow MA` types instantly via the settings menu.\n* **Trend Cloud:** A dynamic background fill (Green/Red) highlights the crossover zone for immediate visual trend identification.\n* **Strategy Mode:** Built-in Backtesting logic triggers `LONG` entries when Fast MA crosses over Slow MA, and `EXIT` when Fast MA crosses under.\n\n### âš ï¸ Disclaimer\nThis script is intended for educational and research purposes. The wide variety of MA combinations can produce vastly different results. Past performance is not indicative of future results. Please use proper risk management.",
    "image_url": "cDdnzUxd",
    "author": "waranyutrkm",
    "likes": 8,
    "type": "strategy",
    "created": "2025-12-06",
    "updated": "2025-12-06",
    "source": "//@version=5\nstrategy(\"Hyper Insight MA Strategy [Universal]\", overlay=true, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=100)\n\n// =============================================================================\n// 1. INPUTS & CONFIGURATION\n// =============================================================================\ngrp_ma = \"Moving Average Settings\"\n\n// MA Types Options\nma_options = input.string(\"SMA\", \"MA Type Options\", options=[\"SMA\", \"EMA\", \"WMA\", \"HMA\", \"RMA\", \"T3\", \"ALMA\", \"VWMA\", \"LSMA\", \"SWMA\", \"DEMA\", \"TEMA\", \"ZLEMA\"], group=grp_ma, tooltip=\"Select the type of Moving Average calculation\")\n\n// Fast MA Inputs (Default: 5)\nfastType = input.string(\"SMA\", \"Fast MA Type\", options=[\"SMA\", \"EMA\", \"WMA\", \"HMA\", \"RMA\", \"T3\", \"ALMA\", \"VWMA\", \"LSMA\", \"SWMA\", \"DEMA\", \"TEMA\", \"ZLEMA\"], group=grp_ma)\nfastLen  = input.int(5, \"Fast MA Length\", minval=1, group=grp_ma)\n\n// Slow MA Inputs (Default: 10)\nslowType = input.string(\"HMA\", \"Slow MA Type\", options=[\"SMA\", \"EMA\", \"WMA\", \"HMA\", \"RMA\", \"T3\", \"ALMA\", \"VWMA\", \"LSMA\", \"SWMA\", \"DEMA\", \"TEMA\", \"ZLEMA\"], group=grp_ma)\nslowLen  = input.int(10, \"Slow MA Length\", minval=1, group=grp_ma)\n\n// =============================================================================\n// 2. HELPER FUNCTIONS\n// =============================================================================\n\n// T3 Moving Average\nt3(src, len) =>\n    v = 0.7\n    e1 = ta.ema(src, len)\n    e2 = ta.ema(e1, len)\n    e3 = ta.ema(e2, len)\n    c1 = -math.pow(v, 3)\n    c2 = 3*math.pow(v, 2) + 3*math.pow(v, 3)\n    c3 = -6*math.pow(v, 2) - 3*v - 3*math.pow(v, 3)\n    c4 = 1 + 3*v + math.pow(v, 3) + 3*math.pow(v, 2)\n    c1*e3 + c2*e2 + c3*e1 + c4*src\n\n// DEMA (Double Exponential Moving Average)\ndema(src, len) =>\n    e1 = ta.ema(src, len)\n    e2 = ta.ema(e1, len)\n    2 * e1 - e2\n\n// TEMA (Triple Exponential Moving Average)\ntema(src, len) =>\n    e1 = ta.ema(src, len)\n    e2 = ta.ema(e1, len)\n    e3 = ta.ema(e2, len)\n    3 * e1 - 3 * e2 + e3\n\n// ZLEMA (Zero Lag Exponential Moving Average)\nzlema(src, len) =>\n    lag = math.floor((len - 1) / 2)\n    ema_data = src + (src - src[lag])\n    ta.ema(ema_data, len)\n\n// Universal MA Switcher\nget_ma(type, len) =>\n    float res = na\n    if type == \"SMA\"\n        res := ta.sma(close, len)\n    else if type == \"EMA\"\n        res := ta.ema(close, len)\n    else if type == \"WMA\"\n        res := ta.wma(close, len)\n    else if type == \"HMA\"\n        res := ta.hma(close, len)\n    else if type == \"RMA\"\n        res := ta.rma(close, len)\n    else if type == \"T3\"\n        res := t3(close, len)\n    else if type == \"ALMA\"\n        res := ta.alma(close, len, 0.85, 6)\n    else if type == \"VWMA\"\n        res := ta.vwma(close, len)\n    else if type == \"LSMA\"\n        res := ta.linreg(close, len, 0)\n    else if type == \"SWMA\"\n        res := ta.swma(close) // Note: SWMA usually has fixed length 4 in Pine, but we keep structure\n    else if type == \"DEMA\"\n        res := dema(close, len)\n    else if type == \"TEMA\"\n        res := tema(close, len)\n    else if type == \"ZLEMA\"\n        res := zlema(close, len)\n    res\n\n// =============================================================================\n// 3. LOGIC CALCULATION\n// =============================================================================\n// Get MAs\nfastMA = get_ma(fastType, fastLen)\nslowMA = get_ma(slowType, slowLen)\n\n// =============================================================================\n// 4. STRATEGY EXECUTION\n// =============================================================================\n// Conditions\ncrossover_bull = ta.crossover(fastMA, slowMA)\ncrossunder_bear = ta.crossunder(fastMA, slowMA)\n\n// Entry/Exit\nif crossover_bull\n    strategy.entry(\"Long\", strategy.long)\n\nif crossunder_bear\n    strategy.close(\"Long\")\n    // Uncomment below to enable Shorting\n    // strategy.entry(\"Short\", strategy.short)\n\n// =============================================================================\n// 5. VISUALIZATION\n// =============================================================================\nplot(fastMA, color=color.rgb(0, 255, 0), title=\"Fast MA\", linewidth=2)\nplot(slowMA, color=color.rgb(255, 0, 0), title=\"Slow MA\", linewidth=2)\n\n// Fill background between MAs for visual trend\nfill(plot(fastMA, display=display.none), plot(slowMA, display=display.none), color = fastMA > slowMA ? color.new(color.green, 90) : color.new(color.red, 90), title=\"Trend Cloud\")"
  },
  {
    "url": "7IWRmmC9-12M-Return-Strategy",
    "name": "12M Return Strategy ",
    "description": "This strategy is based on the original Dual Momentum concept presented by Gary Antonacci in his book â€œDual Momentum Investing.â€\nIt implements the absolute momentum portion of the framework using a 12-month rate of change, combined with a moving-average filter for trend confirmation.\n\nThe script automatically adapts the lookback period depending on chart timeframe, ensuring the return calculation always represents approximately one year, whether you are on daily, weekly, or monthly charts.\n\nHow the Strategy Works\n1. 12-Month Return Calculation\n\nThe core signal is the 12-month price return, computed as:\n\n(Current Price Ã· Price from ~1 year ago) âˆ’ 1\n\nThis return:\n\nPlots as a histogram\n\nTurns green when positive\n\nTurns red when negative\n\nThe lookback adjusts automatically:\n\n1D chart â†’ 252 bars\n\n1W chart â†’ 52 bars\n\n1M chart â†’ 12 bars\n\nOther timeframes â†’ estimated to approximate 1 calendar year\n\n2. Trend Filter (Moving Average of Return)\n\nTo smooth volatility and avoid noise, the strategy applies a moving average to the 12M return:\n\nDefault length: 12 periods\n\nPlotted as a white line on the indicator panel\n\nThis becomes the benchmark used for crossovers.\n\n3. Trade Signals (Long / Short / Cash)\n\nTrades are generated using a simple crossover mechanism:\n\nBullish Signal (Go Long)\n\nWhen:\n\n12M Return crosses ABOVE its MA\n\nAction:\n\nClose short (if any)\n\nEnter long\n\nBearish Signal (Go Short or Go Flat)\n\nWhen:\n\n12M Return crosses BELOW its MA\n\nAction:\n\nIf shorting is enabled â†’ Enter short\n\nIf shorting is disabled â†’ Exit position and go to cash\n\nShorting can be enabled or disabled with a single input switch.\n\n4. Position Sizing\n\nThe strategy uses:\n\nPercent of Equity position sizing\n\nYou can specify the percentage of your portfolio to allocate (default 100%).\n\nNo leverage is required, but the strategy supports it if your account settings allow.\n\n5. Visual Signals\n\nTo improve clarity, the strategy marks signals directly on the indicator panel:\n\nGreen Up Arrows: return > MA\n\nRed Down Arrows: return < MA\n\nA status label shows the current mode:\n\nLONG\n\nSHORT\n\nCASH\n\n6. Backtest-Ready\n\nThis script is built as a full TradingView strategy, not just an indicator.\nThis means you can:\n\nRun complete backtests\n\nView performance metrics\n\nCompare long-only vs long/short behavior\n\nAdjust inputs to tune the system\n\nIt provides a clean, rule-driven interpretation of the classic absolute momentum approach.\n\nInspired By: Gary Antonacci â€“ Dual Momentum Investing\n\nThis script reflects the absolute momentum side of Antonacciâ€™s original research:\n\nUses 12-month momentum (the most statistically validated lookback)\n\nApplies a trend-following overlay to control downside risk\n\nRecreates the classic signal structure used in academic studies\n\nIt is a simplified, transparent version intended for practical use and educational clarity.\n\nDisclaimer\n\nThis script is for educational and research purposes only.\nHistorical performance does not guarantee future results.\nAlways use proper risk management.",
    "image_url": "7IWRmmC9",
    "author": "rahul_joshi_2",
    "likes": 17,
    "type": "strategy",
    "created": "2025-12-06",
    "updated": "2025-12-06",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// Â© rahul_joshi_2\n\n//@version=6\nstrategy(\"Classic Dual Momentum (12M Return) - Auto Timeframe (Strategy)\", shorttitle=\"DM_12M_AUTO_STRAT\", overlay=false, default_qty_type=strategy.percent_of_equity, default_qty_value=100, initial_capital=100000)\n\n// ----------------- inputs -----------------\nmaLen       = input.int(12, \"MA Length (on 12M Return)\", minval=1)\ntakeShort   = input.bool(false, \"Allow Shorting (if off, go to cash on bearish signal)\")\nqtyPercent  = input.int(100, \"Order Size (% of Equity)\", minval=1, maxval=100) // kept for UI clarity; default_qty_type handles actual sizing\nupColor     = input.color(color.green, \"Up Arrow / Positive Color\")\ndownColor   = input.color(color.red,   \"Down Arrow / Negative Color\")\ncolPositive = input.color(color.new(color.green, 0), \"Positive Bar Color\")\ncolNegative = input.color(color.new(color.red, 0),   \"Negative Bar Color\")\n\n// ----------------- helper: get lookback ~1 year -----------------\ngetLookback() =>\n    tf = timeframe.period\n    if tf == \"1D\" or tf == \"D\"\n        252     // trading days approx\n    else if tf == \"1W\" or tf == \"W\"\n        52\n    else if tf == \"1M\" or tf == \"M\"\n        12\n    else\n        // estimate bars per year using difference between current and previous bar time\n        delta = math.max(1, time - nz(time[1], time))\n        estBars = math.max(1, math.round(31536000 / delta))\n        math.min(math.max(estBars, 1), 10000)\n\nlookback = getLookback()\n// ensure we don't ask for more history than available\nvalidLookback = math.min(lookback, bar_index)\n\n// ----------------- 12M return (%) -----------------\nret12 = validLookback > 0 ? (close / nz(close[validLookback]) - 1) * 100.0 : 0.0\n\n// ----------------- MA of return -----------------\nretMA = ta.sma(ret12, maLen)\n\n// ----------------- plotting -----------------\nretColor = ret12 >= 0 ? colPositive : colNegative\nplot(ret12, title=\"12M Return (%)\", style=plot.style_columns, color=retColor)\nplot(retMA, title=\"MA of 12M Return\", color=color.white, linewidth=2)\n\n// up / down markers (visible in the indicator pane)\nplotshape(series = ret12 > retMA, title=\"Up Arrow\", style=shape.triangleup, location=location.top, color=upColor, size=size.small)\nplotshape(series = ret12 < retMA, title=\"Down Arrow\", style=shape.triangledown, location=location.bottom, color=downColor, size=size.small)\n\n// ----------------- strategy logic -----------------\nlongCond  = ta.crossover(ret12, retMA)   // 12M crosses above MA -> go long\nshortCond = ta.crossunder(ret12, retMA)  // 12M crosses below MA -> go short (or cash)\n\n// Use default_qty_type set above. Do NOT pass qty here to avoid type issues.\nif (longCond)\n    if strategy.position_size < 0\n        strategy.close(\"Short\")\n    strategy.entry(id=\"Long\", direction=strategy.long)\n\nif (shortCond)\n    if takeShort\n        if strategy.position_size > 0\n            strategy.close(\"Long\")\n        strategy.entry(id=\"Short\", direction=strategy.short)\n    else\n        if strategy.position_size > 0\n            strategy.close(\"Long\")\n\n// show current status as label in the indicator pane\nvar label stat = na\nif barstate.islast\n    label.delete(stat)\n    statusTxt = strategy.position_size > 0 ? \"LONG\" : (strategy.position_size < 0 ? \"SHORT\" : \"CASH\")\n    // place label at current bar's ret12 level (so it's in the same pane)\n    stat = label.new(x=bar_index, y=ret12, xloc=xloc.bar_index, yloc=yloc.price, text=\"Status: \" + statusTxt, color=color.gray, style=label.style_label_left, textcolor=color.white, size=size.small)\n"
  },
  {
    "url": "b030xeqH-Center-and-Volume-Analyzer",
    "name": "Center and Volume Analyzer",
    "description": "Center and Volume Analyzer that utilizes the chart's Center of Gravity alongside the Rate of Change with Bollinger Bands with a basis for the midpoint. As always, none of this is investment or financial advice. Please do your own due diligence and research.",
    "image_url": "b030xeqH",
    "author": "gamer456148",
    "likes": 9,
    "type": "strategy",
    "created": "2025-12-05",
    "updated": "2025-12-05",
    "source": "//@version=6\n\nstrategy(\"Center and Volume Analyzer\")\n\n// Inputs\nsource_1_cog = close\nlength_1_cog = input.int(10, title=\"Length\")\nsource_1_roc = close\nlength_1_roc = input.int(9, title=\"Length\")\nsource_1_bb = close\nlength_1_bb = input.int(20, title=\"Length\")\nmult_1_bb = input.float(2, title=\"Multiplier\")\n\n// Indicators\ncog_1 = ta.cog(source_1_cog, length_1_cog)\nroc_1 = ta.roc(source_1_roc, length_1_roc)\n[bb_upper_1, bb_basis_1, bb_lower_1] = ta.bb(source_1_bb, length_1_bb, mult_1_bb)\n\n// Conditions\nfinal_long_1 = (cog_1 <= roc_1)\n\n// Entries\nif barstate.isconfirmed and final_long_1\n    strategy.entry(\"Long 1\", strategy.long)\n    tp_long_1 = (close + (close * 50 / 100))\n    sl_long_1 = (close - (close * 15 / 100))\n    strategy.exit(\"Long 1 TP/SL\", from_entry=\"Long 1\", limit= tp_long_1, stop= sl_long_1, comment_profit = \"TP Reached!\", comment_loss = \"SL Reached!\")\n\n// Plots\nplot(cog_1, title=\"COG 1\", color=color.rgb(208, 244, 216))\n\n// End of script"
  },
  {
    "url": "ixVcwUsI",
    "name": "Estrategia Trend Following: 52w/26w Breakout",
    "description": "This is a classic long-term Trend Following strategy, heavily inspired by the Donchian Channel system and the legendary \"Turtle Trading\" rules. It is designed to capture major market moves (bull runs) while filtering out short-term market noise and volatility.\n\nThis script is ideal for investors and swing traders who prefer a \"hands-off\" approach, looking to catch large trends rather than day-trading small fluctuations.\n\nHow it Works:\n1. Entry Condition (The Breakout):\n\n52-Week High: The strategy enters a Long position when the price breaks above the highest high of the last 252 trading days (approx. 1 year).\n\nSuperTrend Filter: An additional filter using the SuperTrend indicator ensures that the breakout is supported by positive momentum, helping to reduce false signals during choppy lateral markets.\n\n2. Exit Condition (The Trailing Stop):\n\n26-Week Low: The strategy ignores short-term corrections. It only closes the position if the price closes below the lowest low of the last 126 trading days (approx. 6 months).\n\nThis wide stop allows the trade to \"breathe\" and stay open during significant pullbacks, ensuring you stay in the trend for as long as possible.\n\nFeatures & Settings:\nCustomizable Lookback Periods: You can adjust the Entry (default 252 days) and Exit (default 126 days) periods in the settings menu.\n\nVisual Aids:\n\nBlue Line: Represents the 1-Year High (Entry Threshold).\n\nRed Line: Represents the 6-Month Low (Dynamic Stop Loss).\n\nChannel Shading: Visualizes the trading range between the high and low.\n\nLabels: Clearly marks \"BUY\" and \"EXIT\" points on the chart.\n\nRecommended Usage:\nTimeframe: Daily (1D). This logic is designed for daily candles.\n\nAssets: Works best on assets with strong trending characteristics (e.g., Bitcoin/Crypto, Tech Stocks, Indices like SPX/NDX, and Commodities).\n\nPatience Required: This strategy generates very few signals. It may stay quiet for months and then hold a position for over a year.",
    "image_url": "ixVcwUsI",
    "author": "MrOskama",
    "likes": 17,
    "type": "strategy",
    "created": "2025-12-05",
    "updated": "2025-12-05",
    "source": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// Â© TuUsuario\n\n//@version=5\nstrategy(\"Estrategia Trend Following: 52w/26w Breakout\", shorttitle=\"TF 52w/26w\", overlay=true, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=100, currency=currency.USD)\n\n// --- 1. CONFIGURACIÃ“N ---\ngroup_entrada = \"ConfiguraciÃ³n de Entrada\"\ngroup_salida = \"ConfiguraciÃ³n de Salida\"\n\n// SuperTrend (Filtro)\natrPeriod = input.int(10, \"Periodo ATR\", group=group_entrada, tooltip=\"Periodo para calcular la volatilidad del SuperTrend.\")\nfactor = input.float(3.0, \"Factor SuperTrend\", group=group_entrada, tooltip=\"Multiplicador del ATR. Un valor mÃ¡s alto hace el filtro menos sensible.\")\n\n// Donchian High (Entrada) - 252 dÃ­as hÃ¡biles = 1 aÃ±o trading\ndiasEntrada = input.int(252, \"Longitud Breakout (DÃ­as)\", group=group_entrada, tooltip=\"NÃºmero de velas atrÃ¡s para buscar el mÃ¡ximo histÃ³rico (normalmente 252 para 1 aÃ±o).\")\n\n// Donchian Low (Salida) - 126 dÃ­as hÃ¡biles = 6 meses trading\ndiasSalida = input.int(126, \"Trailing Stop (DÃ­as)\", group=group_salida, tooltip=\"NÃºmero de velas atrÃ¡s para buscar el mÃ­nimo donde saldremos (normalmente 126 para 6 meses).\")\n\n// --- 2. CÃLCULOS ---\n// SuperTrend\n[supertrend, direction] = ta.supertrend(factor, atrPeriod)\n\n// Canales Donchian (High y Low)\n// Usamos el offset [1] para mirar los mÃ¡ximos/mÃ­nimos hasta la vela anterior, no la actual.\ntechoAnual = ta.highest(high, diasEntrada)[1] \nsueloSemestral = ta.lowest(low, diasSalida)[1]\n\n// --- 3. LÃ“GICA DE TRADING ---\n\n// CONDICIÃ“N DE ENTRADA (Largo):\n// 1. SuperTrend es alcista (direction < 0)\n// 2. El precio cruza o iguala el mÃ¡ximo de los Ãºltimos 252 dÃ­as\nlongCondition = (direction < 0) and (close >= techoAnual) and strategy.position_size == 0\n\n// CONDICIÃ“N DE SALIDA:\n// El precio cierra por debajo del mÃ­nimo de los Ãºltimos 126 dÃ­as\nexitCondition = close < sueloSemestral and strategy.position_size > 0\n\n// --- 4. EJECUCIÃ“N DE Ã“RDENES ---\n\nif (longCondition)\n    strategy.entry(\"Long\", strategy.long, comment=\"Breakout 52w\")\n\nif (exitCondition)\n    strategy.close(\"Long\", comment=\"Exit 26w Low\")\n\n// --- 5. VISUALIZACIÃ“N ---\n\n// Colores dinÃ¡micos\ncolorTecho = color.new(color.blue, 0)\ncolorSuelo = color.new(color.red, 0)\n\n// Plotear las lÃ­neas\np1 = plot(techoAnual, title=\"Techo (Entrada)\", color=colorTecho, linewidth=1, style=plot.style_line)\np2 = plot(sueloSemestral, title=\"Suelo (Salida)\", color=colorSuelo, linewidth=2, style=plot.style_line)\n\n// Rellenar el canal para ver el rango operativo\nfill(p1, p2, color=color.new(color.blue, 95), title=\"Rango del Canal\")\n\n// SeÃ±ales visuales en el grÃ¡fico (TriÃ¡ngulos)\nplotshape(longCondition, title=\"SeÃ±al Compra\", style=shape.labelup, location=location.belowbar, color=color.green, text=\"BUY\", textcolor=color.white, size=size.tiny)\nplotshape(exitCondition, title=\"SeÃ±al Venta\", style=shape.labeldown, location=location.abovebar, color=color.red, text=\"EXIT\", textcolor=color.white, size=size.tiny)\n\n// Colorear fondo si estamos dentro del mercado\nbgcolor(strategy.position_size > 0 ? color.new(color.green, 95) : na, title=\"PosiciÃ³n Activa\")"
  },
  {
    "url": "aiSeWtxt-Robrechtian-Long-Medium-Breakout-Trend-System",
    "name": "Robrechtian Long-Medium Breakout Trend System",
    "description": "Robrechtian Longâ€“Medium-Term Breakout Trend System \nA professional, rule-based trend-following strategy designed to capture large, sustained price movements using pure price action and breakouts. \nThis system follows long-established trend-following philosophy: no prediction, no volatility targeting, and no profit targets. Only disciplined entries, position additions, and exits driven entirely by trend structure.\n\n Core Principles \n\n Breakout-driven entries:  Initial positions are taken only when price breaks above/below the 80-day Donchian channel, confirming a longâ€“medium-term trend shift.\n\n Short-term confirmation:  Breakouts must also exceed the 20-day channel, reducing false positives.\n\n Trend-direction filter:  A 50-day moving average slope filter ensures alignment with the broader trend.\n\n Explosive bar filter:  Entries avoid excessively large, single-candle expansions (>2.5Ã— ATR(20)) to prevent chasing exhaustion spikes.\n\n Pyramiding into strength:  Additional units are added only when price makes fresh 20-day breakouts in the direction of the trend. No scaling out. No adding on dips.\n\n Exit only on trend violation:  Positions are closed exclusively when price breaks the opposite 80-day channel. This preserves unlimited upside while enforcing disciplined exits.\n\n Pure trend philosophy:  No volatility targeting, no smoothing, no discretionary overrides, no optimization for short-term performance.\n\n Intended Use \nThis system is designed primarily for diversified futures portfolios, where diversification across dozens of globally liquid markets creates robustness and stability. However, it may also be used on individual assets for educational and analytical purposes.\n\nThe system embraces the core trend-following logic:\n\nSmall losses, big winners, and unlimited upside when trends persist.\n\nâš ï¸  WARNINGS / DISCLAIMERS \n\nâš ï¸  Warning 1  â€” This strategy is not optimized for single stocks\n\nThe Robrechtian Trend System is designed for multi-asset futures portfolios, not single equities.\nPerformance on individual tickers may vary greatly due to lack of diversification.\n\nâš ï¸  Warning 2  â€” Trend following includes substantial drawdowns\n\nDeep drawdowns are a normal and expected feature of all long-term trend-following systems.\nThe strategy does not attempt to smooth returns or manage volatility.\nIf you seek steady, low-volatility equity curves, this system is not suitable.\n\nâš ï¸  Warning 3  â€” No volatility targeting or risk smoothing\n\nThis system intentionally avoids volatility-based position sizing.\nTrades may experience larger fluctuations than systems using risk parity or vol targeting.\n\nâš ï¸  Warning 4  â€” Not financial advice\n\nThis script is for educational and research purposes only.\nPast performance does not guarantee future results.\nUse at your own risk.\n\nâš ï¸  Warning 5  â€” TradingView backtests have known limitations\n\nTradingView does not simulate:\n\n \n futures contract roll logic\n slippage\n real bid/ask spreads\n liquidity conditions\n limit-up/limit-down behavior\n \n\nResults may vary from live market execution.",
    "image_url": "aiSeWtxt",
    "author": "LordRobrecht",
    "likes": 7,
    "type": "strategy",
    "created": "2025-12-05",
    "updated": "2025-12-05",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// Â© LordRobrecht\r\n\r\n//@version=5\r\nstrategy(\r\n     title           = \"Robrechtian Long-Medium Breakout Trend System\",\r\n     shorttitle      = \"Robrecht Breakout Trend\",\r\n     overlay         = true,\r\n     initial_capital = 100000,\r\n     currency        = currency.USD,\r\n     pyramiding      = 5,                     // Base + up to 4 pyramids (edit as desired)\r\n     default_qty_type= strategy.percent_of_equity,\r\n     default_qty_value = 1,                   // 1% of equity per entry; adjust to taste\r\n     calc_on_every_tick = false,\r\n     commission_type = strategy.commission.percent,\r\n     commission_value = 0.01                  // 0.01% per trade as placeholder\r\n     )\r\n\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Inputs\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nentryLookback      = input.int(80,  \"Entry / Exit Breakout Lookback (days)\", minval = 20)\r\nconfirmLookback    = input.int(20,  \"Short-Term Confirmation Lookback\",       minval = 5)\r\nmaLength           = input.int(50,  \"Trend Filter MA Length\",                 minval = 10)\r\natrLength          = input.int(20,  \"ATR Length (Explosive Bar Filter)\",      minval = 5)\r\natrExplosiveMult   = input.float(2.5, \"Explosive Bar Threshold (x ATR)\",      minval = 1.0, step = 0.1)\r\n\r\nallowLongs         = input.bool(true,  \"Allow Long Trades\")\r\nallowShorts        = input.bool(true,  \"Allow Short Trades\")\r\nuseExplosiveFilter = input.bool(true,  \"Use Explosive Bar Filter\")\r\n\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Core Calculations\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n\r\n// Long/short \"state\"\r\ninLong  = strategy.position_size > 0\r\ninShort = strategy.position_size < 0\r\n\r\n// Donchian-style channels (shifted by 1 bar to avoid look-ahead)\r\nhighestEntry  = ta.highest(high[1], entryLookback)\r\nlowestEntry   = ta.lowest(low[1],  entryLookback)\r\n\r\nhighestConfirm = ta.highest(high[1], confirmLookback)\r\nlowestConfirm  = ta.lowest(low[1],  confirmLookback)\r\n\r\n// Moving average + slope filter\r\nma      = ta.sma(close, maLength)\r\nmaUp    = ma > ma[1]\r\nmaDown  = ma < ma[1]\r\n\r\n// ATR + \"explosive bar\" detection\r\natr         = ta.atr(atrLength)\r\nbarRange    = high - low\r\nexplosive   = barRange > atrExplosiveMult * atr\r\nokBar       = useExplosiveFilter ? not explosive : true\r\n\r\n// Safety: enough bars?\r\nenoughBars  = bar_index > entryLookback + 2\r\n\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Entry Conditions\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n\r\n// Base long entry: 80-day breakout + 20-day confirmation + upward slope + non-explosive\r\nlongBaseBreakout =\r\n     enoughBars and\r\n     allowLongs and\r\n     not inLong and\r\n     not inShort and\r\n     close > highestEntry and\r\n     close > highestConfirm and\r\n     maUp and\r\n     okBar\r\n\r\n// Base short entry: mirror logic\r\nshortBaseBreakout =\r\n     enoughBars and\r\n     allowShorts and\r\n     not inShort and\r\n     not inLong and\r\n     close < lowestEntry and\r\n     close < lowestConfirm and\r\n     maDown and\r\n     okBar\r\n\r\n// Pyramiding: add on each new 20-day breakout in direction of existing trend\r\nlongPyramidCond =\r\n     enoughBars and\r\n     allowLongs and\r\n     inLong and\r\n     close > highestConfirm and\r\n     maUp and\r\n     okBar\r\n\r\nshortPyramidCond =\r\n     enoughBars and\r\n     allowShorts and\r\n     inShort and\r\n     close < lowestConfirm and\r\n     maDown and\r\n     okBar\r\n\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Exit Conditions (80-day opposite channel)\r\n// Infinite upside: no profit targets, exit only on trend break\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nexitLongCond =\r\n     inLong and\r\n     enoughBars and\r\n     close < lowestEntry\r\n\r\nexitShortCond =\r\n     inShort and\r\n     enoughBars and\r\n     close > highestEntry\r\n\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Execute Orders\r\n// Priority: exits â†’ base entries â†’ pyramids\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n\r\n// Exits\r\nif exitLongCond\r\n    strategy.close(\"Long\")\r\n\r\nif exitShortCond\r\n    strategy.close(\"Short\")\r\n\r\n// Base entries\r\nif longBaseBreakout\r\n    strategy.entry(\"Long\", strategy.long)\r\n\r\nif shortBaseBreakout\r\n    strategy.entry(\"Short\", strategy.short)\r\n\r\n// Pyramids\r\n// We use the same order IDs; with `pyramiding > 0` this will add units\r\nif not longBaseBreakout and longPyramidCond\r\n    strategy.entry(\"Long\", strategy.long)\r\n\r\nif not shortBaseBreakout and shortPyramidCond\r\n    strategy.entry(\"Short\", strategy.short)\r\n\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Plotting\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nplot(ma, title = \"Trend MA\", color = color.new(color.orange, 0))\r\n\r\nplot(highestEntry,  \"80-day High (Entry/Exit)\",  color = color.new(color.navy,  60), style = plot.style_linebr)\r\nplot(lowestEntry,   \"80-day Low (Entry/Exit)\",   color = color.new(color.fuchsia,    60), style = plot.style_linebr)\r\n\r\nplot(highestConfirm,\"20-day High (Pyramid Ref)\", color = color.new(color.teal,   80), style = plot.style_linebr)\r\nplot(lowestConfirm, \"20-day Low (Pyramid Ref)\",  color = color.new(color.purple, 80), style = plot.style_linebr)"
  },
  {
    "url": "tteYqIQw-Turtle-Strategy-by-enzo007",
    "name": "Turtle Strategy by enzo007",
    "description": "Easy trend following (Turtle Strategy)\nEMA10 and EMA20 magic??",
    "image_url": "tteYqIQw",
    "author": "LordTony",
    "likes": 10,
    "type": "strategy",
    "created": "2025-12-07",
    "updated": "2025-12-07",
    "source": "//@version=5\nstrategy(\"Turtle Strategy by enzo007\", overlay=true, margin_long=100, margin_short=100)\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// USER INPUT: DATE RANGE FILTER\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nuseDateFilter = input.bool(true, \"Use Date Range Filter\")\nfromDate = input.time(timestamp(\"2012-01-01T00:00:00\"), \"From Date\")\ntoDate   = input.time(timestamp(\"2030-01-01T00:00:00\"), \"To Date\")\ninDateRange = not useDateFilter or (time >= fromDate and time <= toDate)\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// TREND FILTER INPUTS\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nuseTrendFilter = input.bool(true, \"Use Trend Filters\")\nadxLength = input.int(14, \"ADX Length\")\nadxThreshold = input.float(20.0, \"ADX Min Value\", step=0.5)\nslopeLookback = input.int(5, \"EMA20 Slope Lookback\")\nslopeThreshold = input.float(0.0, \"Min EMA20 Slope\", step=0.01)\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// EMA CALCULATIONS\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nema10 = ta.ema(close, 10)\nema20 = ta.ema(close, 20)\n\nplot(ema10, color=color.yellow)\nplot(ema20, color=color.purple)\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// MANUAL ADX\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nlen = adxLength\n\ntr = math.max(math.max(high - low, math.abs(high - nz(close[1]))), math.abs(low - nz(close[1])))\natr = ta.rma(tr, len)\n\nupMove = high - nz(high[1])\ndownMove = nz(low[1]) - low\n\nplusDM = (upMove > downMove and upMove > 0) ? upMove : 0.0\nminusDM = (downMove > upMove and downMove > 0) ? downMove : 0.0\n\nsmPlus = ta.rma(plusDM, len)\nsmMinus = ta.rma(minusDM, len)\n\nplusDI = atr != 0 ? 100 * (smPlus / atr) : 0.0\nminusDI = atr != 0 ? 100 * (smMinus / atr) : 0.0\n\ndx = (plusDI + minusDI) != 0 ? 100 * math.abs(plusDI - minusDI) / (plusDI + minusDI) : 0.0\nadx = ta.rma(dx, len)\n\nplot(adx, title=\"ADX\", linewidth=1, transp=70)\nhline(adxThreshold, \"ADX Threshold\", linestyle=hline.style_dashed)\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// EMA20 SLOPE\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nemaSlope = ema20 - ema20[slopeLookback]\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// TREND FILTER LOGIC\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\ntrendOK = (adx > adxThreshold) and (emaSlope > slopeThreshold)\ntrendPass = not useTrendFilter or trendOK\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// ENTRY / EXIT\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nlongCondition = low > ema20\nexitCondition = high < ema10\n\nif inDateRange and trendPass and longCondition\n    strategy.entry(\"Long\", strategy.long)\n\nif inDateRange and exitCondition\n    strategy.close(\"Long\")\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// UNREALIZED MAX DRAWDOWN (EQUITY)\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nvar float peakEquity = na\nvar float maxUnrealizedDD = 0.0\n\nvalidEquity = strategy.equity > 0\n\nif validEquity\n    if na(peakEquity)\n        peakEquity := strategy.equity\n\n    if strategy.equity > peakEquity\n        peakEquity := strategy.equity\n\n    currentDD = (peakEquity - strategy.equity) / peakEquity * 100\n    if currentDD >= 0\n        maxUnrealizedDD := math.max(maxUnrealizedDD, currentDD)\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// REALIZED MAX DRAWDOWN (CLOSED-ONLY)\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// cumulative closed profit (added once per closed trade)\nvar float cumClosedProfit = 0.0\nvar int   lastClosedCount = 0\n\n// If the number of closed trades increased, add the new trades' P/L\nif strategy.closedtrades > lastClosedCount\n    // add every newly closed trade (handles cases where multiple closed on same bar)\n    for idx = lastClosedCount to strategy.closedtrades - 1\n        cumClosedProfit += strategy.closedtrades.profit(idx)\n    lastClosedCount := strategy.closedtrades\n\n// realized equity = initial capital + cumulative closed P/L\nrealizedEquity = strategy.initial_capital + cumClosedProfit\n\n// track peak & max realized drawdown percent\nvar float peakRealizedEquity = na\nvar float maxRealizedDDPerc = 0.0\n\nif na(peakRealizedEquity)\n    peakRealizedEquity := realizedEquity\n\n// update peak only with valid positive equity\nif realizedEquity > peakRealizedEquity\n    peakRealizedEquity := realizedEquity\n\n// compute current realized drawdown percent (from peak to current)\nrealizedDDPerc = peakRealizedEquity > 0 ? (peakRealizedEquity - realizedEquity) / peakRealizedEquity * 100.0 : 0.0\n\n// update max realized drawdown percent\nmaxRealizedDDPerc := math.max(maxRealizedDDPerc, realizedDDPerc)\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// PERFORMANCE METRICS\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nvar table stat = table.new(position.top_right, 2, 9, border_width=2)\n\nwins   = strategy.wintrades\nlosses = strategy.losstrades\ntotal  = wins + losses\nwinrate = total > 0 ? (wins / total) * 100 : na\n\nnetProfitPerc = strategy.netprofit / strategy.initial_capital * 100\n\navgTradePerc = strategy.closedtrades > 0 ?\n     (strategy.netprofit / strategy.closedtrades) / strategy.initial_capital * 100 : na\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// AVG RR CALC\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nvar float rr_sum = 0\nvar int rr_count = 0\n\nif strategy.closedtrades > 0\n    for i = 0 to strategy.closedtrades - 1\n        pl = strategy.closedtrades.profit(i)\n\n        if pl < 0\n            lastLoss = math.abs(pl)\n            prevPL = strategy.closedtrades.profit(math.max(i - 1, 0))\n            if prevPL > 0\n                rr = math.abs(prevPL) / lastLoss\n                rr_sum += rr\n                rr_count += 1\n\navgRR = rr_count > 0 ? rr_sum / rr_count : na\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// DISPLAY TABLE\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nif barstate.islastconfirmedhistory or barstate.isrealtime\n    bgcolorCell = color.new(color.black, 0)\n    txt = color.white\n\n    table.cell(stat, 0, 0, \"Winrate (%)\", text_color=txt, bgcolor=bgcolorCell)\n    table.cell(stat, 1, 0, str.tostring(winrate, \"#.##\"), text_color=txt, bgcolor=bgcolorCell)\n\n    table.cell(stat, 0, 1, \"Wins\", text_color=txt, bgcolor=bgcolorCell)\n    table.cell(stat, 1, 1, str.tostring(wins), text_color=txt, bgcolor=bgcolorCell)\n\n    table.cell(stat, 0, 2, \"Losses\", text_color=txt, bgcolor=bgcolorCell)\n    table.cell(stat, 1, 2, str.tostring(losses), text_color=txt, bgcolor=bgcolorCell)\n\n    table.cell(stat, 0, 3, \"Net Profit (%)\", text_color=txt, bgcolor=bgcolorCell)\n    table.cell(stat, 1, 3, str.tostring(netProfitPerc, \"#.##\") + \"%\", text_color=txt, bgcolor=bgcolorCell)\n\n    table.cell(stat, 0, 4, \"Avg Trade (%)\", text_color=txt, bgcolor=bgcolorCell)\n    table.cell(stat, 1, 4, str.tostring(avgTradePerc, \"#.##\") + \"%\", text_color=txt, bgcolor=bgcolorCell)\n\n    table.cell(stat, 0, 5, \"Unrealized DD (%)\", text_color=txt, bgcolor=bgcolorCell)\n    table.cell(stat, 1, 5, str.tostring(maxUnrealizedDD, \"#.##\") + \"%\", text_color=txt, bgcolor=bgcolorCell)\n\n    table.cell(stat, 0, 6, \"Realized DD (%)\", text_color=txt, bgcolor=bgcolorCell)\n    table.cell(stat, 1, 6, str.tostring(maxRealizedDDPerc, \"#.##\") + \"%\", text_color=txt, bgcolor=bgcolorCell)\n\n    table.cell(stat, 0, 7, \"Avg RR\", text_color=txt, bgcolor=bgcolorCell)\n    table.cell(stat, 1, 7, str.tostring(avgRR, \"#.##\"), text_color=txt, bgcolor=bgcolorCell)\n"
  },
  {
    "url": "HERuuRt5",
    "name": "Triple EMA + RSI + ATR",
    "description": "This comprehensive trading system combines triple EMA alignment, RSI momentum filtering, and dynamic ATR-based risk management. The strategy enters positions only when fast, medium, and slow EMAs align in proper order (bullish or bearish), confirmed by RSI remaining within defined thresholds (not overbought/oversold) and a volume spike above its moving average. Exits are managed intelligently using a multi-tier approach: a fixed stop-loss based on ATR, a first profit target at a predefined risk-reward ratio, and a trailing stop that activates after reaching a second, higher profit tier. Designed for trend-following with built-in momentum and volume confirmation, it features professional order execution with configurable commission and slippage for realistic backtesting. Visual cues including colored backgrounds and signal shapes enhance chart clarity.",
    "image_url": "HERuuRt5",
    "author": "fhfsb",
    "likes": 654,
    "type": "strategy",
    "created": "2025-12-05",
    "updated": "2025-12-05",
    "source": "//@version=5\r\nstrategy(\"Triple EMA + RSI + ATR\", \r\n     overlay=true, \r\n     default_qty_type=strategy.percent_of_equity, \r\n     default_qty_value=100, \r\n     commission_type=strategy.commission.percent, \r\n     commission_value=0.1,  // åŠ å¯†è´§å¸å…¸åž‹æ‰‹ç»­è´¹ï¼ˆå¯æ ¹æ®äº¤æ˜“æ‰€è°ƒæ•´ï¼‰\r\n     slippage=3)\r\n\r\n// ==================== å‚æ•°è®¾ç½® ====================\r\nfastLength   = input.int(9,   \"å¿«çº¿ EMA\",   group=\"å‡çº¿è®¾ç½®\")\r\nmidLength    = input.int(21,  \"ä¸­çº¿ EMA\",   group=\"å‡çº¿è®¾ç½®\")\r\nslowLength   = input.int(55,  \"æ…¢çº¿ EMA\",   group=\"å‡çº¿è®¾ç½®\")\r\n\r\nrsiLength    = input.int(14,  \"RSI å‘¨æœŸ\",   group=\"RSIè¿‡æ»¤\")\r\nrsiOverbought = input.int(65, \"RSI è¶…ä¹°çº¿\", group=\"RSIè¿‡æ»¤\")\r\nrsiOversold  = input.int(35, \"RSI è¶…å–çº¿\", group=\"RSIè¿‡æ»¤\")\r\n\r\natrLength    = input.int(14,  \"ATR å‘¨æœŸ\",   group=\"æ­¢æŸæ­¢ç›ˆ\")\r\natrMultiplier = input.float(2.0, \"ATR æ­¢æŸå€æ•°\", step=0.1, group=\"æ­¢æŸæ­¢ç›ˆ\")\r\nrr1          = input.float(2.0, \"ç¬¬ä¸€é˜¶æ­¢ç›ˆ RR\", group=\"æ­¢æŸæ­¢ç›ˆ\")\r\nrr2          = input.float(4.0, \"ç¬¬äºŒé˜¶æ­¢ç›ˆ RRï¼ˆç§»åŠ¨æ­¢ç›ˆè§¦å‘ï¼‰\", group=\"æ­¢æŸæ­¢ç›ˆ\")\r\n\r\nvolLength    = input.int(20, \"æˆäº¤é‡å‡çº¿å‘¨æœŸ\", group=\"æ”¾é‡ç¡®è®¤\")\r\nvolMultiplier = input.float(1.3, \"æ”¾é‡å€æ•°\", step=0.1, group=\"æ”¾é‡ç¡®è®¤\")\r\n\r\n// ==================== æŒ‡æ ‡è®¡ç®— ====================\r\nfastEMA = ta.ema(close, fastLength)\r\nmidEMA  = ta.ema(close, midLength)\r\nslowEMA = ta.ema(close, slowLength)\r\n\r\nrsi = ta.rsi(close, rsiLength)\r\natr = ta.atr(atrLength)\r\nvolMA = ta.sma(volume, volLength)\r\n\r\n// å¤šå¤´æ¡ä»¶ï¼šå¿«>ä¸­>æ…¢ + RSIä¸è¿‡è¶…ä¹° + æ”¾é‡\r\nlongCondition  = fastEMA > midEMA and midEMA > slowEMA and \r\n                 close > fastEMA and \r\n                 rsi > 50 and rsi < rsiOverbought and \r\n                 volume > volMA * volMultiplier\r\n\r\n// ç©ºå¤´æ¡ä»¶ï¼šå¿«<ä¸­<æ…¢ + RSIä¸è¿‡è¶…å– + æ”¾é‡\r\nshortCondition = fastEMA < midEMA and midEMA < slowEMA and \r\n                  close < fastEMA and \r\n                  rsi < 50 and rsi > rsiOversold and \r\n                  volume > volMA * volMultiplier\r\n\r\n// ==================== å…¥åœº ====================\r\nif (longCondition)\r\n    strategy.entry(\"Long\", strategy.long)\r\n\r\nif (shortCondition)\r\n    strategy.entry(\"Short\", strategy.short)\r\n\r\n// ==================== æ™ºèƒ½æ­¢ç›ˆæ­¢æŸ ====================\r\nvar float entryPrice = na\r\nif (strategy.position_size > 0)\r\n    entryPrice := strategy.position_avg_price\r\nif (strategy.position_size < 0)\r\n    entryPrice := strategy.position_avg_price\r\n\r\n// åŠ¨æ€æ­¢æŸ\r\nlongStop  = entryPrice - atr * atrMultiplier\r\nshortStop = entryPrice + atr * atrMultiplier\r\n\r\n// åˆ†é˜¶æ¢¯æ­¢ç›ˆ + ç§»åŠ¨æ­¢ç›ˆ\r\nlongTake1  = entryPrice + (entryPrice - longStop) * rr1\r\nlongTake2  = entryPrice + (entryPrice - longStop) * rr2\r\nshortTake1 = entryPrice - (shortStop - entryPrice) * rr1\r\nshortTake2 = entryPrice - (shortStop - entryPrice) * rr2\r\n\r\n// æ‰§è¡Œæ­¢æŸæ­¢ç›ˆ\r\nstrategy.exit(\"Long Exit\", \"Long\", \r\n     stop=longStop, \r\n     limit=longTake1, \r\n     trail_points=(longTake2 - entryPrice)/syminfo.pointvalue)  // åˆ°2å€åŽå¼€å¯ç§»åŠ¨æ­¢ç›ˆ\r\n\r\nstrategy.exit(\"Short Exit\", \"Short\", \r\n     stop=shortStop, \r\n     limit=shortTake1, \r\n     trail_points=(entryPrice - shortTake2)/syminfo.pointvalue)\r\n\r\n// ==================== ç»˜å›¾ ====================\r\nplot(fastEMA, color=color.new(color.yellow, 0), title=\"å¿«çº¿ EMA\")\r\nplot(midEMA,  color=color.new(color.orange, 0), title=\"ä¸­çº¿ EMA\")\r\nplot(slowEMA, color=color.new(color.red,    0), title=\"æ…¢çº¿ EMA\")\r\n\r\nplotshape(longCondition,  title=\"å¤šå¤´ä¿¡å·\", location=location.belowbar, color=color.green, style=shape.triangleup,   size=size.small)\r\nplotshape(shortCondition, title=\"ç©ºå¤´ä¿¡å·\", location=location.abovebar, color=color.red,   style=shape.triangledown, size=size.small)\r\n\r\nbgcolor(longCondition ? color.new(color.green, 90) : na)\r\nbgcolor(shortCondition ? color.new(color.red, 90) : na)"
  },
  {
    "url": "S8gP1uJJ-Nifty-10m-Simple-ORB-TEST-harish",
    "name": "Nifty 10m Simple ORB TEST harish",
    "description": "//@version=5\nstrategy(\"Nifty 10m Simple ORB TEST\", overlay=true)\n\n// 10m timeframe check\nif timeframe.period != \"10\"\n    runtime.error(\"Use this on 10 minute timeframe\")\n\n// First 10m candle high/low (no PCR, no opposite logic â€“ just test syntax)\nnewDay = ta.change(time(\"D\")) != 0\n\nvar float dayHigh = na\nvar float dayLow  = na\n\nif newDay\n    dayHigh := na\n    dayLow  := na\n\nsessStart = 0915\nsessEnd   = 0925\nhhmm      = hour * 100 + minute\n\nisFirst = na(dayHigh) and hhmm >= sessStart and hhmm < sessEnd\n\nif isFirst\n    dayHigh := high\n    dayLow  := low\n\n// Plot first candle range\nplot(dayHigh, \"First High\", color=color.green, style=plot.style_linebr)\nplot(dayLow,  \"First Low\",  color=color.red,   style=plot.style_linebr)\n\n// Simple breakout entries just to test\nlongCond  = not na(dayHigh) and close > dayHigh\nshortCond = not na(dayLow)  and close < dayLow\n\nif longCond\n    strategy.entry(\"LONG\", strategy.long)\n\nif shortCond\n    strategy.entry(\"SHORT\", strategy.short)",
    "image_url": "S8gP1uJJ",
    "author": "harrishdade",
    "likes": 11,
    "type": "strategy",
    "created": "2025-12-05",
    "updated": "2025-12-05",
    "source": "//@version=5\nstrategy(\"Nifty 10m Simple ORB TEST\", overlay=true)\n\n// 10m timeframe check\nif timeframe.period != \"10\"\n    runtime.error(\"Use this on 10 minute timeframe\")\n\n// First 10m candle high/low (no PCR, no opposite logic â€“ just test syntax)\nnewDay = ta.change(time(\"D\")) != 0\n\nvar float dayHigh = na\nvar float dayLow  = na\n\nif newDay\n    dayHigh := na\n    dayLow  := na\n\nsessStart = 0915\nsessEnd   = 0925\nhhmm      = hour * 100 + minute\n\nisFirst = na(dayHigh) and hhmm >= sessStart and hhmm < sessEnd\n\nif isFirst\n    dayHigh := high\n    dayLow  := low\n\n// Plot first candle range\nplot(dayHigh, \"First High\", color=color.green, style=plot.style_linebr)\nplot(dayLow,  \"First Low\",  color=color.red,   style=plot.style_linebr)\n\n// Simple breakout entries just to test\nlongCond  = not na(dayHigh) and close > dayHigh\nshortCond = not na(dayLow)  and close < dayLow\n\nif longCond\n    strategy.entry(\"LONG\", strategy.long)\n\nif shortCond\n    strategy.entry(\"SHORT\", strategy.short)"
  },
  {
    "url": "Uz8n1xqn-HARRISH-DADE",
    "name": "HARRISH DADE",
    "description": "//@version=5\nstrategy(\"Nifty 15m ORB + 20 EMA + Volume - Signals Fixed\", overlay=true,\n     initial_capital=100000, default_qty_type=strategy.percent_of_equity, default_qty_value=25,\n     process_orders_on_close=true)\n\n// 15-minute timeframe check\nif timeframe.period != \"15\"\n    runtime.error(\"Use this strategy on 15 minute timeframe only\")\n\n// ORB 9:15â€“9:30 High/Low\nvar float orbHigh = na\nvar float orbLow  = na\n\nnewDay = ta.change(time(\"D\")) != 0\nif newDay\n    orbHigh := na\n    orbLow  := na\n\nsessStart = 0915\nsessEnd   = 0930\nhhmm      = hour * 100 + minute\ninORB     = hhmm >= sessStart and hhmm < sessEnd\n\nif inORB\n    orbHigh := na(orbHigh) ? high : math.max(orbHigh, high)\n    orbLow  := na(orbLow)  ? low  : math.min(orbLow,  low)\n\n// Plot ORB levels\nplot(orbHigh, \"ORB High\", color=color.new(color.green, 0), linewidth=2)\nplot(orbLow,  \"ORB Low\",  color=color.new(color.red, 0),   linewidth=2)\n\n// Trend filter - 20 EMA\nemaLen   = input.int(20, \"EMA Length\", minval=1)\nema20    = ta.ema(close, emaLen)\nupTrend  = close > ema20\ndnTrend  = close < ema20\nplot(ema20, \"EMA 20\", color=color.orange, linewidth=2)\n\n// Volume filter - Adaptive\nvolLen    = input.int(20, \"Volume MA Length\", minval=1)\navgVol    = ta.sma(volume, volLen)\nvolMult   = input.float(1.5, \"Volume Multiplier\", step=0.1)\nenoughVol = volume >= (avgVol * volMult)\n\n// ORB complete check\norbLocked = not na(orbHigh) and not na(orbLow) and not inORB\n\n// Entry conditions (for strategy)\nlongCond  = orbLocked and ta.crossover(close, orbHigh) and upTrend and enoughVol\nshortCond = orbLocked and ta.crossunder(close, orbLow) and dnTrend and enoughVol\n\n// Risk Management\ntargetPts = input.float(40.0, \"Target Points\", step=1.0)\nslPts     = input.float(25.0, \"Stoploss Points\", step=1.0)\n\n// STRATEGY ENTRIES\nif longCond and strategy.position_size == 0\n    strategy.entry(\"LONG\", strategy.long)\n\nif shortCond and strategy.position_size == 0\n    strategy.entry(\"SHORT\", strategy.short)\n\n// STRATEGY EXITS\nif strategy.position_size > 0\n    strategy.exit(\"LONG EXIT\", from_entry=\"LONG\", \n         limit=strategy.position_avg_price + targetPts, \n         stop=strategy.position_avg_price - slPts)\n\nif strategy.position_size < 0\n    strategy.exit(\"SHORT EXIT\", from_entry=\"SHORT\", \n         limit=strategy.position_avg_price - targetPts, \n         stop=strategy.position_avg_price + slPts)\n\n// **FIXED BUY/SELL SIGNALS** - No barstate.isconfirmed, direct conditions\nplotshape(longCond,  title=\"BUY\",  style=shape.triangleup,   location=location.belowbar,\n          color=color.new(color.lime, 0), size=size.large, text=\"BUY\", textcolor=color.white)\n          \nplotshape(shortCond, title=\"SELL\", style=shape.triangledown, location=location.abovebar,\n          color=color.new(color.red, 0),  size=size.large, text=\"SELL\", textcolor=color.white)\n\n// Debug table - shows if conditions met\nif barstate.islast\n    var table debugTable = table.new(position.top_right, 2, 6, bgcolor=color.white, border_width=1)\n    table.cell(debugTable, 0, 0, \"Condition\", text_color=color.black, bgcolor=color.gray)\n    table.cell(debugTable, 1, 0, \"Status\", text_color=color.black, bgcolor=color.gray)\n    table.cell(debugTable, 0, 1, \"ORB Locked\", text_color=color.black)\n    table.cell(debugTable, 1, 1, str.tostring(orbLocked), text_color=orbLocked ? color.green : color.red)\n    table.cell(debugTable, 0, 2, \"UpTrend\", text_color=color.black)\n    table.cell(debugTable, 1, 2, str.tostring(upTrend), text_color=upTrend ? color.green : color.red)\n    table.cell(debugTable, 0, 3, \"Enough Vol\", text_color=color.black)\n    table.cell(debugTable, 1, 3, str.tostring(enoughVol), text_color=enoughVol ? color.green : color.red)\n",
    "image_url": "Uz8n1xqn",
    "author": "harrishdade",
    "likes": 5,
    "type": "strategy",
    "created": "2025-12-05",
    "updated": "2025-12-05",
    "source": "//@version=5\nstrategy(\"Nifty 15m ORB + 20 EMA + Volume - Fixed\", overlay=true,\n     initial_capital=100000, default_qty_type=strategy.percent_of_equity, default_qty_value=25,\n     process_orders_on_close=true)\n\n// 15-minute timeframe check\nif timeframe.period != \"15\"\n    runtime.error(\"Use this strategy on 15 minute timeframe only\")\n\n// ORB 9:15â€“9:30 High/Low\nvar float orbHigh = na\nvar float orbLow  = na\n\nnewDay = ta.change(time(\"D\")) != 0\nif newDay\n    orbHigh := na\n    orbLow  := na\n\nsessStart = 0915\nsessEnd   = 0930\nhhmm      = hour * 100 + minute\ninORB     = hhmm >= sessStart and hhmm < sessEnd\n\nif inORB\n    orbHigh := na(orbHigh) ? high : math.max(orbHigh, high)\n    orbLow  := na(orbLow)  ? low  : math.min(orbLow,  low)\n\n// Plot ORB levels\nplot(orbHigh, \"ORB High\", color=color.new(color.green, 0), linewidth=2, style=plot.style_linebr)\nplot(orbLow,  \"ORB Low\",  color=color.new(color.red, 0),   linewidth=2, style=plot.style_linebr)\n\n// Trend filter - 20 EMA\nemaLen   = input.int(20, \"EMA Length\", minval=1)\nema20    = ta.ema(close, emaLen)\nupTrend  = close > ema20\ndnTrend  = close < ema20\nplot(ema20, \"EMA 20\", color=color.orange, linewidth=2)\n\n// Volume filter - Adaptive (better than fixed)\nvolLen    = input.int(20, \"Volume MA Length\", minval=1)\navgVol    = ta.sma(volume, volLen)\nvolMult   = input.float(1.5, \"Volume Multiplier\", step=0.1, minval=1.0)\nenoughVol = volume >= (avgVol * volMult)\n\n// ORB complete check\norbLocked = not na(orbHigh) and not na(orbLow) and not inORB\n\n// Entry conditions\nlongCond  = orbLocked and ta.crossover(close, orbHigh) and upTrend and enoughVol\nshortCond = orbLocked and ta.crossunder(close, orbLow) and dnTrend and enoughVol\n\n// Risk Management\ntargetPts = input.float(40.0, \"Target Points\", step=1.0, minval=1.0)\nslPts     = input.float(25.0, \"Stoploss Points\", step=1.0, minval=1.0)\n\n// One trade per day (optional - uncomment if needed)\n// var bool tradedToday = false\n// if newDay\n//     tradedToday := false\n\n// STRATEGY ENTRIES\nif longCond and strategy.position_size == 0\n    strategy.entry(\"LONG\", strategy.long)\n    // tradedToday := true  // uncomment for 1 trade/day\n\nif shortCond and strategy.position_size == 0\n    strategy.entry(\"SHORT\", strategy.short)\n    // tradedToday := true  // uncomment for 1 trade/day\n\n// STRATEGY EXITS (separate block - fixes same-bar issue)\nif strategy.position_size > 0\n    longTP = strategy.position_avg_price + targetPts\n    longSL = strategy.position_avg_price - slPts\n    strategy.exit(\"LONG EXIT\", from_entry=\"LONG\", limit=longTP, stop=longSL)\n\nif strategy.position_size < 0\n    shortTP = strategy.position_avg_price - targetPts\n    shortSL = strategy.position_avg_price + slPts\n    strategy.exit(\"SHORT EXIT\", from_entry=\"SHORT\", limit=shortTP, stop=shortSL)\n\n// BUY/SELL SIGNALS (confirmed bars only - no repainting)\nlongSignal  = longCond  and barstate.isconfirmed\nshortSignal = shortCond and barstate.isconfirmed\n\nplotshape(longSignal,  title=\"BUY\",  style=shape.triangleup,   location=location.belowbar,\n          color=color.new(color.lime, 0), size=size.normal, text=\"BUY\", textcolor=color.white)\nplotshape(shortSignal, title=\"SELL\", style=shape.triangledown, location=location.abovebar,\n          color=color.new(color.red, 0),  size=size.normal, text=\"SELL\", textcolor=color.white)\n\n// Background color for trend\nbgcolor(upTrend ? color.new(color.green, 95) : dnTrend ? color.new(color.red, 95) : na)\n"
  },
  {
    "url": "kzNfzrTV-BTC-Fear-Greed-Incremental-Strategy",
    "name": "BTC Fear & Greed Incremental Strategy",
    "description": "IMPORTANT: READ SETUP GUIDE BELOW OR IT WON'T WORK\n\n# BTC Fear & Greed Incremental Strategy â€” TradeMaster AI (Pure BTC Stack)\n\n## Strategy Overview\n\nThis advanced Bitcoin accumulation strategy is designed for long-term hodlers who want to systematically take profits during greed cycles and accumulate during fear periods, while preserving their core BTC position. Unlike traditional strategies that start with cash, this approach begins with a specified BTC allocation, making it perfect for existing Bitcoin holders who want to optimize their stack management.\n\n## Key Features\n\n### ðŸŽ¯ **Pure BTC Stack Mode**\n- Start with any amount of BTC (configurable)\n- Strategy manages your existing stack, not new purchases\n- Perfect for hodlers who want to optimize without timing markets\n\n### ðŸ“Š **Fear & Greed Integration** \n- Uses market sentiment data to drive buy/sell decisions\n- Configurable thresholds for greed (selling) and fear (buying) triggers\n- Automatic validation to ensure proper 0-100 scale data source\n\n### ðŸ‚ **Bull Year Optimization**\n- Smart quarterly selling during bull market years (2017, 2021, 2025)\n- Q1: 1% sells, Q2: 2% sells, Q3/Q4: 5% sells (configurable)\n- **NO SELLING** during non-bull years - pure accumulation mode\n- Preserves BTC during early bull phases, maximizes profits at peaks\n\n### ðŸ» **Bear Market Intelligence**\n- Multi-regime detection: Bull, Early Bear, Deep Bear, Early Bull\n- Different buying strategies based on market conditions\n- Enhanced buying during deep bear markets with configurable multipliers\n- Visual regime backgrounds for easy market condition identification\n\n### ðŸ›¡ï¸ **Risk Management**\n- Minimum BTC allocation floor (prevents selling entire stack)\n- Configurable position sizing for all trades\n- Multiple safety checks and validation\n\n### ðŸ“ˆ **Advanced Visualization**\n- Clean 0-100 scale with 2 decimal precision\n- Three main indicators: BTC Allocation %, Fear & Greed Index, BTC Holdings\n- Real-time portfolio tracking with cash position display\n- Enhanced info table showing all key metrics\n\n## How to Use\n\n### **Step 1: Setup**\n1. Add the strategy to your BTC/USD chart (daily timeframe recommended)\n2. **CRITICAL**: In settings, change the \"Fear & Greed Source\" from \"close\" to a proper 0-100 Fear & Greed indicator\n---------------\nI recommend Crypto Fear & Greed Index by TIA_Technology indicator\nWhen selecting source with this indicator, look for \"Crypto Fear and Greed Index:Index\"\n---------------\n3. Set your \"Starting BTC Quantity\" to match your actual holdings\n4. Configure your preferred \"Start Date\" (when you want the strategy to begin)\n\n### **Step 2: Configure Bull Year Logic**\n- Enable \"Bull Year Logic\" (default: enabled)\n- Adjust quarterly sell percentages:\n  - Q1 (Jan-Mar): 1% (conservative early bull)\n  - Q2 (Apr-Jun): 2% (moderate mid bull) \n  - Q3/Q4 (Jul-Dec): 5% (aggressive peak targeting)\n- Add future bull years to the list as needed\n\n### **Step 3: Fine-tune Thresholds**\n- **Greed Threshold**: 80 (sell when F&G > 80)\n- **Fear Threshold**: 20 (buy when F&G < 20 in bull markets)\n- **Deep Bear Fear Threshold**: 25 (enhanced buying in bear markets)\n- Adjust based on your risk tolerance\n\n### **Step 4: Risk Management**\n- Set \"Minimum BTC Allocation %\" (default 20%) - prevents selling entire stack\n- Configure sell/buy percentages based on your position size\n- Enable bear market filters for enhanced timing\n\n### **Step 5: Monitor Performance**\n- **Orange Line**: Your BTC allocation percentage (target: fluctuate between 20-100%)\n- **Blue Line**: Actual BTC holdings (should preserve core position)\n- **Pink Line**: Fear & Greed Index (drives all decisions)\n- **Table**: Real-time portfolio metrics including cash position\n\n## Reading the Indicators\n\n### **BTC Allocation Percentage (Orange Line)**\n- **100%**: All portfolio in BTC, no cash available for buying\n- **80%**: 80% BTC, 20% cash ready for fear buying\n- **20%**: Minimum allocation, maximum cash position\n\n### **Trading Signals**\n- **Green Buy Signals**: Appear during fear periods with available cash\n- **Red Sell Signals**: Appear during greed periods in bull years only\n- **No Signals**: Either allocation limits reached or non-bull year\n\n## Strategy Logic\n\n### **Bull Years (2017, 2021, 2025)**\n- Q1: Conservative 1% sells (preserve stack for later)\n- Q2: Moderate 2% sells (gradual profit taking)\n- Q3/Q4: Aggressive 5% sells (peak targeting)\n- Fear buying active (accumulate on dips)\n\n### **Non-Bull Years**\n- **Zero selling** - pure accumulation mode\n- Enhanced fear buying during bear markets\n- Focus on rebuilding stack for next bull cycle\n\n## Important Notes\n\n- **This is not financial advice** - backtest thoroughly before use\n- Designed for **long-term holders** (4+ year cycles)\n- **Requires proper Fear & Greed data source** - validate in settings\n- Best used on **daily timeframe** for major trend following\n- **Cash calculations**: Use allocation % and BTC holdings to calculate available cash: `Cash = (Total Portfolio Ã— (1 - Allocation%/100))`\n\n## Risk Disclaimer\n\nThis strategy involves active trading and position management. Past performance does not guarantee future results. Always do your own research and never invest more than you can afford to lose. The strategy is designed for educational purposes and long-term Bitcoin accumulation thesis.\n\n---\n\n*Developed by Sol_Crypto for the Bitcoin community. Happy stacking! ðŸš€*",
    "image_url": "kzNfzrTV",
    "author": "Sol_Crypto",
    "likes": 17,
    "type": "strategy",
    "created": "2025-12-04",
    "updated": "2025-12-04",
    "source": "//@version=6\r\nstrategy(\"BTC Fear & Greed Incremental Strategy\", \r\n     overlay                  = true,\r\n     initial_capital          = 1000000000,\r\n     currency                 = currency.USD,\r\n     pyramiding               = 10000,\r\n     commission_value         = 0,\r\n     slippage                 = 0,\r\n     process_orders_on_close  = true,\r\n     margin_long              = 100,\r\n     margin_short             = 0,\r\n     precision                = 2)\r\n\r\n// â”€â”€ Main Inputs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\ninitialBTC       = input.float(10.0, \"Starting BTC Quantity (pure stack mode)\", minval = 0.01, step = 0.01, group = \"Main Parameters\")\r\ngreedThreshold   = input.float(80, \"Greed threshold (sell above)\",    minval = 50, maxval = 95, group = \"Main Parameters\")\r\nfearThreshold    = input.float(20, \"Normal Fear threshold (buy below in bull)\", minval = 5,  maxval = 40, group = \"Main Parameters\")\r\ngreedSellPercent = input.float(5.0, \"Standard Greed â†’ Daily sell % of portfolio\", minval = 0.1, maxval = 50, group = \"Main Parameters\")\r\nfearBuyPercent   = input.float(5.0, \"Normal Fear â†’ Daily buy % of portfolio\", minval = 0.1, maxval = 50, group = \"Main Parameters\")\r\nstartDate        = input.time(timestamp(\"2024-01-24 00:00 +0000\"), \"Start Date (initial BTC stack)\", group = \"Main Parameters\")\r\n\r\n// â”€â”€ Bull Year Logic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nenableBullYearLogic = input.bool(true, \"Enable Bull Year Logic\", group = \"Bull Year Management\")\r\nbullYearsInput      = input.string(\"2017,2021,2025\", \"Bull Years (comma-separated)\", group = \"Bull Year Management\")\r\nq1SellPercent       = input.float(1.0, \"Q1 Sell % (Jan-Mar)\", minval = 0.1, maxval = 50, group = \"Bull Year Management\")\r\nq2SellPercent       = input.float(2.0, \"Q2 Sell % (Apr-Jun)\", minval = 0.1, maxval = 50, group = \"Bull Year Management\") \r\nq3SellPercent       = input.float(5.0, \"Q3 Sell % (Jul-Sep)\", minval = 0.1, maxval = 50, group = \"Bull Year Management\")\r\nq4SellPercent       = input.float(5.0, \"Q4 Sell % (Oct-Dec)\", minval = 0.1, maxval = 50, group = \"Bull Year Management\")\r\n\r\n// â”€â”€ Bear Market Filters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nenableBearFilters = input.bool(true, \"Enable Bear Market Buy Filters\", group = \"Bear Parameters\")\r\nplotBearMAs       = input.bool(false, \"Plot Bear MAs on Chart (visual only)\", group = \"Bear Parameters\")\r\nbullMAPeriodDays  = input.int(365, title = \"Bull Confirmation MA (days)\", minval = 100, maxval = 1000, group = \"Bear Parameters\")\r\ndeepBearMAWeeks   = input.int(150, title = \"Deep Bear MA (weeks)\", minval = 50, maxval = 300, group = \"Bear Parameters\")\r\ndeepFearThreshold = input.float(25, title = \"Deep Bear Fear Threshold (< this)\", minval = 5, maxval = 50, group = \"Bear Parameters\")\r\ndeepBuyMultiplier = input.float(2.0, title = \"Buy Multiplier in Deep Bear zone\", minval = 1.0, step = 0.5, group = \"Bear Parameters\")\r\n\r\n// â”€â”€ Risk Management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nminAllocationPct  = input.float(20.0, \"Minimum BTC Allocation % (floor during greed)\", minval = 0.0, maxval = 90.0, group = \"Risk Management\")\r\n\r\n// â–¼ CRITICAL: SELECT THE 0â€“100 FEAR & GREED PLOT â–¼\r\nfng = input.source(close, title = \"Fear & Greed Source â†’ MUST select the 0â€“100 series\", group = \"CRITICAL\")\r\n\r\n// Warning if wrong source\r\nvar label warningLabel = na\r\nif barstate.islast and (na(fng) or fng < 0 or fng > 100)\r\n    warningLabel := label.new(bar_index, high * 1.1, \"âš ï¸ WRONG F&G SOURCE!\\nSelect the 0â€“100 plot in settings\", color = color.red, textcolor = color.white, style = label.style_label_left, size = size.large)\r\n\r\n// â”€â”€ Bull Year Detection Function â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nisBullYear() =>\r\n    currentYear = year(time)\r\n    bullYearsList = str.split(bullYearsInput, \",\")\r\n    isBull = false\r\n    for i = 0 to array.size(bullYearsList) - 1\r\n        yearStr = str.trim(array.get(bullYearsList, i))\r\n        if str.tonumber(yearStr) == currentYear\r\n            isBull := true\r\n            break\r\n    isBull\r\n\r\n// â”€â”€ Get Current Quarter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\ngetCurrentQuarter() =>\r\n    currentMonth = month(time)\r\n    if currentMonth >= 1 and currentMonth <= 3\r\n        1  // Q1\r\n    else if currentMonth >= 4 and currentMonth <= 6\r\n        2  // Q2\r\n    else if currentMonth >= 7 and currentMonth <= 9\r\n        3  // Q3\r\n    else\r\n        4  // Q4\r\n\r\n// â”€â”€ Get Dynamic Sell Percentage â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\ngetDynamicSellPercent() =>\r\n    if enableBullYearLogic and isBullYear()\r\n        quarter = getCurrentQuarter()\r\n        switch quarter\r\n            1 => q1SellPercent\r\n            2 => q2SellPercent\r\n            3 => q3SellPercent\r\n            4 => q4SellPercent\r\n            => greedSellPercent  // fallback\r\n    else\r\n        0.0  // No sells in non-bull years\r\n\r\n// Fixed position ID\r\nstring pos_id = \"BTC Position\"\r\n\r\n// Trend MAs\r\nfloat bullMA     = ta.sma(close, bullMAPeriodDays)\r\nfloat deepBearMA = request.security(syminfo.tickerid, \"W\", ta.sma(close, deepBearMAWeeks), barmerge.gaps_off, barmerge.lookahead_off)\r\n\r\n// Optional MA plots\r\nplot(plotBearMAs and enableBearFilters ? bullMA : na, title = \"Bull Confirmation MA\", color = color.blue, linewidth = 2)\r\nplot(plotBearMAs and enableBearFilters ? deepBearMA : na, title = \"Deep Bear MA\", color = color.purple, linewidth = 2)\r\n\r\n// Regime detection\r\nvar string regime = \"Bull\"\r\nif enableBearFilters\r\n    if close > bullMA\r\n        regime := \"Bull\"\r\n    else if close <= deepBearMA\r\n        regime := \"Deep Bear\"\r\n    else\r\n        regime := close[1] <= deepBearMA ? \"Early Bull\" : \"Early Bear\"\r\nelse\r\n    regime := \"Bull\"\r\n\r\n// Background regime coloring\r\nbgcolor(regime == \"Bull\"      ? color.new(color.green,  93) :\r\n       regime == \"Early Bear\" ? color.new(color.orange, 90) :\r\n       regime == \"Deep Bear\"  ? color.new(color.red,    90) :\r\n       regime == \"Early Bull\" ? color.new(color.blue,   88) : na)\r\n\r\n// â”€â”€ Pure Stack Logic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nvar float artificialCash = 0.0\r\nvar bool started = false\r\nvar bool initialEntryMade = false\r\nvar int initialEntryBar = na\r\n\r\nif not started and time >= startDate\r\n    started := true\r\n\r\nif started and not initialEntryMade and time >= startDate\r\n    float initialStackValue = initialBTC * close\r\n    artificialCash := strategy.initial_capital - initialStackValue\r\n    strategy.entry(pos_id, strategy.long, qty = initialBTC, comment = \"Initial BTC Stack\")\r\n    initialEntryMade := true\r\n    initialEntryBar := bar_index\r\n\r\nif started and initialEntryMade and time >= startDate and barstate.isconfirmed and bar_index != initialEntryBar\r\n    float portValue = strategy.equity\r\n    float posValue = math.abs(strategy.position_size) * close\r\n    float realCash = portValue - posValue - artificialCash\r\n    float pureEquity = posValue + math.max(realCash, 0)\r\n    \r\n    // Get dynamic sell percentage based on bull year logic\r\n    float currentSellPercent = getDynamicSellPercent()\r\n    \r\n    // Greed sell (only if currentSellPercent > 0, meaning it's a bull year or bull logic is disabled)\r\n    if currentSellPercent > 0 and fng > greedThreshold and strategy.position_size > 0\r\n        float desiredSellValue = pureEquity * (currentSellPercent / 100)\r\n        float floorValue = pureEquity * (minAllocationPct / 100)\r\n        float maxSellValue = posValue - floorValue\r\n        float sellValue = math.min(desiredSellValue, math.max(maxSellValue, 0))\r\n        float sell_qty_btc = sellValue / close\r\n        if sell_qty_btc > 0.001\r\n            string quarter = getCurrentQuarter() == 1 ? \"Q1\" : getCurrentQuarter() == 2 ? \"Q2\" : getCurrentQuarter() == 3 ? \"Q3\" : \"Q4\"\r\n            string comment = isBullYear() ? quarter + \" Bull Sell \" + str.tostring(currentSellPercent, \"#.##\") + \"%\" : \"Greed Sell \" + str.tostring(currentSellPercent, \"#.##\") + \"%\"\r\n            strategy.close(pos_id, qty = sell_qty_btc, comment = comment)\r\n    \r\n    // Fear buy (unchanged logic)\r\n    bool doBuy = false\r\n    float buyPercentUsed = fearBuyPercent\r\n\r\n    if not enableBearFilters\r\n        doBuy := fng < fearThreshold\r\n    else\r\n        if close > bullMA\r\n            doBuy := fng < fearThreshold\r\n        else if close <= deepBearMA and fng < deepFearThreshold\r\n            doBuy := true\r\n            buyPercentUsed *= deepBuyMultiplier\r\n\r\n    if doBuy and realCash > 0\r\n        float buyValue = pureEquity * (buyPercentUsed / 100)\r\n        float buy_qty_btc = math.min(buyValue / close, realCash / close)\r\n        if buy_qty_btc > 0.001\r\n            strategy.entry(pos_id, strategy.long, qty = buy_qty_btc, comment = \"Fear Buy \" + str.tostring(buyPercentUsed, \"#.##\") + \"%\")\r\n\r\n// â”€â”€ ENFORCED 2 DECIMAL SCALE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nfloat portValue = strategy.equity\r\nfloat posValue = math.abs(strategy.position_size) * close\r\nfloat realCash = portValue - posValue - artificialCash\r\nfloat pureEquity = posValue + math.max(realCash, 0)\r\nfloat alloc_pct = pureEquity != 0 ? (posValue / pureEquity) * 100 : 0\r\n\r\n// Scale enforcement\r\nplot(-5.00, \"Scale Floor\", color = color.new(color.white, 100), display = display.none)\r\nplot(110.00, \"Scale Ceiling\", color = color.new(color.white, 100), display = display.none)\r\n\r\n// Main plots\r\nplot(started ? math.round(alloc_pct, 2) : na, \"BTC Allocation %\", color = color.orange, linewidth = 3)\r\nplot(math.round(fng, 2), \"Fear & Greed Index\", color = color.fuchsia, linewidth = 2)\r\nplot(started ? math.round(strategy.position_size, 2) : na, \"BTC Holdings\", color = color.blue, linewidth = 3)\r\n\r\n// Scale anchors\r\nplot(0.00, \"Anchor 0\", color = color.new(color.red, 95), linewidth = 1)\r\nplot(100.00, \"Anchor 100\", color = color.new(color.green, 95), linewidth = 1)\r\n\r\n// Reference lines\r\nhline(0.00, \"0.00%\", color = color.red)\r\nhline(20.00, \"20.00%\", color = color.new(color.red, 50))\r\nhline(50.00, \"50.00%\", color = color.gray, linestyle = hline.style_dashed)\r\nhline(80.00, \"80.00%\", color = color.new(color.green, 50))\r\nhline(100.00, \"100.00%\", color = color.green)\r\n\r\n// Additional reference lines\r\nhline(25.00, \"25.00\", color = color.new(color.gray, 80), linestyle = hline.style_dotted)\r\nhline(75.00, \"75.00\", color = color.new(color.gray, 80), linestyle = hline.style_dotted)\r\n\r\n// Enhanced info table\r\nvar table infoTable = table.new(position.top_right, 2, 7, bgcolor = color.new(color.black, 85), border_width = 1, frame_color = color.orange)\r\n\r\nif barstate.islast and started\r\n    float currentSellPercent = getDynamicSellPercent()\r\n    string yearType = isBullYear() ? \"BULL\" : \"NORMAL\"\r\n    string quarterInfo = isBullYear() ? \"Q\" + str.tostring(getCurrentQuarter()) : \"N/A\"\r\n    \r\n    table.cell(infoTable, 0, 0, \"STACK TRACKER\", text_color = color.white, bgcolor = color.new(color.orange, 20))\r\n    table.cell(infoTable, 1, 0, \"\", bgcolor = color.new(color.orange, 20))\r\n    table.cell(infoTable, 0, 1, \"Year Type:\", text_color = isBullYear() ? color.yellow : color.gray)\r\n    table.cell(infoTable, 1, 1, yearType + \" \" + quarterInfo, text_color = color.white)\r\n    table.cell(infoTable, 0, 2, \"Sell %:\", text_color = color.red)\r\n    table.cell(infoTable, 1, 2, str.tostring(currentSellPercent, \"#.#\") + \"%\", text_color = color.white)\r\n    table.cell(infoTable, 0, 3, \"Regime:\", text_color = regime == \"Bull\" ? color.green : regime == \"Early Bear\" ? color.orange : regime == \"Deep Bear\" ? color.red : color.blue)\r\n    table.cell(infoTable, 1, 3, regime, text_color = color.white)\r\n    table.cell(infoTable, 0, 4, \"F&G:\", text_color = color.fuchsia)\r\n    table.cell(infoTable, 1, 4, str.tostring(fng, \"#.##\"), text_color = color.white)\r\n    table.cell(infoTable, 0, 5, \"BTC Holdings:\", text_color = color.blue)\r\n    table.cell(infoTable, 1, 5, str.tostring(strategy.position_size, \"#.####\") + \" BTC\", text_color = color.white)\r\n    table.cell(infoTable, 0, 6, \"USD Cash:\", text_color = color.yellow)\r\n    table.cell(infoTable, 1, 6, \"$\" + str.tostring(math.round(math.max(realCash, 0))), text_color = color.white)\r\n"
  },
  {
    "url": "5DOEFwJx",
    "name": "EMA + Sessions + RSI Strategy v1.0",
    "description": "A professional trading strategy that combines multiple technical indicators for high-probability entries. This system uses EMA crossovers, RSI zone filtering, and trend confirmation to identify optimal trading opportunities while managing risk with advanced position management tools.\n\nKey Features:\nâœ… Dual Entry Signals (EMA21 + EMA100 crossover conditions)\nâœ… Trend Filter EMA750 (trade only with the major trend)\nâœ… Complete Risk Management (SL 1%, TP 3% default)\nâœ… Trailing Stop & Breakeven (maximize profits, protect capital)\nâœ… Compact Statistics Table (real-time performance metrics)\nâœ… RSI & Session Filters (avoid low-probability setups)\nâœ… Optional Pyramiding (scale into winning positions)\n\nPerfect for swing trading and trend-following on any timeframe. Fully customizable to match your trading style.",
    "image_url": "5DOEFwJx",
    "author": "jake_theboss",
    "likes": 153,
    "type": "strategy",
    "created": "2025-12-04",
    "updated": "2025-12-04",
    "source": "//@version=6\r\nstrategy(\"EMA + Sessions + RSI Strategy v1.0\", overlay=true, pyramiding=3, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=100, commission_type=strategy.commission.percent, commission_value=0.1)\r\n\r\n// ========================================\r\n// STRATEGY SETTINGS\r\n// ========================================\r\n// Trade Direction\r\ntradeDirection = input.string(\"Both\", \"Trade Direction\", options=[\"Long Only\", \"Short Only\", \"Both\"], group=\"Strategy Settings\")\r\nuseSessionFilter = input.bool(false, \"Use Session Filter\", group=\"Strategy Settings\")\r\nallowedSession = input.session(\"0800-1600\", \"Allowed Trading Session\", group=\"Strategy Settings\")\r\n\r\n// Position Sizing\r\nusePyramiding = input.bool(false, \"Enable Pyramiding\", group=\"Strategy Settings\")\r\nmaxPyramidPositions = input.int(3, \"Max Pyramid Positions\", minval=1, maxval=10, group=\"Strategy Settings\")\r\n\r\n// ========================================\r\n// RISK MANAGEMENT\r\n// ========================================\r\nuseStopLoss = input.bool(true, \"Use Stop Loss\", group=\"Risk Management\")\r\nstopLossType = input.string(\"Fixed %\", \"Stop Loss Type\", options=[\"Fixed %\", \"ATR\", \"Session Low/High\", \"EMA100 Cross\"], group=\"Risk Management\")\r\nstopLossPercent = input.float(1.0, \"Stop Loss %\", minval=0.1, maxval=10, step=0.1, group=\"Risk Management\")\r\natrMultiplier = input.float(1.5, \"ATR Multiplier for SL\", minval=0.5, maxval=5, step=0.1, group=\"Risk Management\")\r\natrLength = input.int(14, \"ATR Length\", minval=1, group=\"Risk Management\")\r\n\r\nuseTakeProfit = input.bool(true, \"Use Take Profit\", group=\"Risk Management\")\r\ntakeProfitType = input.string(\"Fixed %\", \"Take Profit Type\", options=[\"Fixed %\", \"Risk/Reward\"], group=\"Risk Management\")\r\ntakeProfitPercent = input.float(3.0, \"Take Profit %\", minval=0.1, maxval=20, step=0.1, group=\"Risk Management\")\r\nriskRewardRatio = input.float(2.0, \"Risk/Reward Ratio\", minval=0.5, maxval=10, step=0.1, group=\"Risk Management\")\r\n\r\nuseTrailingStop = input.bool(false, \"Use Trailing Stop\", group=\"Risk Management\")\r\ntrailingStopType = input.string(\"ATR\", \"Trailing Stop Type\", options=[\"Fixed %\", \"ATR\"], group=\"Risk Management\")\r\ntrailingStopPercent = input.float(1.5, \"Trailing Stop %\", minval=0.1, maxval=10, step=0.1, group=\"Risk Management\")\r\ntrailingAtrMultiplier = input.float(1.0, \"Trailing ATR Multiplier\", minval=0.1, maxval=5, step=0.1, group=\"Risk Management\")\r\n\r\nuseBreakeven = input.bool(false, \"Move to Breakeven\", group=\"Risk Management\")\r\nbreakevenTrigger = input.float(1.0, \"Breakeven Trigger (R)\", minval=0.5, maxval=5, step=0.1, group=\"Risk Management\")\r\nbreakevenOffset = input.float(0.1, \"Breakeven Offset %\", minval=0, maxval=1, step=0.05, group=\"Risk Management\")\r\n\r\n// ========================================\r\n// EMA SETTINGS\r\n// ========================================\r\nema1Length = input.int(21, \"EMA 1 Length\", minval=1, group=\"EMA Settings\")\r\nema2Length = input.int(50, \"EMA 2 Length\", minval=1, group=\"EMA Settings\")\r\nema3Length = input.int(100, \"EMA 3 Length\", minval=1, group=\"EMA Settings\")\r\nemaFilterLength = input.int(2, \"EMA Filter Length\", minval=2, group=\"EMA Settings\")\r\n\r\nema1Color = input.color(color.rgb(255, 235, 59, 50), \"EMA 1 Color\", group=\"EMA Settings\")\r\nema2Color = input.color(color.rgb(255, 115, 0, 50), \"EMA 2 Color\", group=\"EMA Settings\")\r\nema3Color = input.color(color.rgb(255, 0, 0, 50), \"EMA 3 Color\", group=\"EMA Settings\")\r\n\r\nshowEma1 = input.bool(true, \"Show EMA 1\", group=\"EMA Settings\")\r\nshowEma2 = input.bool(true, \"Show EMA 2\", group=\"EMA Settings\")\r\nshowEma3 = input.bool(true, \"Show EMA 3\", group=\"EMA Settings\")\r\n\r\n// Trend Filter EMA\r\nuseTrendFilter = input.bool(true, \"Use Trend Filter EMA\", group=\"EMA Settings\")\r\ntrendFilterLength = input.int(750, \"Trend Filter EMA Length\", minval=1, group=\"EMA Settings\")\r\ntrendFilterColor = input.color(color.rgb(128, 0, 128, 50), \"Trend Filter Color\", group=\"EMA Settings\")\r\nshowTrendFilter = input.bool(true, \"Show Trend Filter EMA\", group=\"EMA Settings\")\r\n\r\n// ========================================\r\n// RSI SETTINGS\r\n// ========================================\r\nrsiLength = input.int(14, \"RSI Length\", minval=1, group=\"RSI Settings\")\r\nrsiBullishLow = input.int(55, \"Bullish Zone Low\", minval=0, maxval=100, group=\"RSI Settings\")\r\nrsiBullishHigh = input.int(70, \"Bullish Zone High\", minval=0, maxval=100, group=\"RSI Settings\")\r\nrsiBearishLow = input.int(30, \"Bearish Zone Low\", minval=0, maxval=100, group=\"RSI Settings\")\r\nrsiBearishHigh = input.int(45, \"Bearish Zone High\", minval=0, maxval=100, group=\"RSI Settings\")\r\n\r\n// RSI Filters\r\nuseRsiFilter = input.bool(true, \"Use RSI Overbought/Oversold Filter\", group=\"RSI Settings\")\r\nrsiOverbought = input.int(80, \"RSI Overbought (avoid longs)\", minval=50, maxval=100, group=\"RSI Settings\")\r\nrsiOversold = input.int(20, \"RSI Oversold (avoid shorts)\", minval=0, maxval=50, group=\"RSI Settings\")\r\n\r\n// ========================================\r\n// CALCULATE INDICATORS\r\n// ========================================\r\nema1 = ta.ema(close, ema1Length)\r\nema2 = ta.ema(close, ema2Length)\r\nema3 = ta.ema(close, ema3Length)\r\nemaFilter = ta.ema(close, emaFilterLength)\r\ntrendFilterEma = ta.ema(close, trendFilterLength)\r\nrsiValue = ta.rsi(close, rsiLength)\r\natr = ta.atr(atrLength)\r\n\r\n// Plot EMAs\r\nplot(showEma1 ? ema1 : na, \"EMA 21\", ema1Color, 2)\r\nplot(showEma2 ? ema2 : na, \"EMA 50\", ema2Color, 2)\r\nplot(showEma3 ? ema3 : na, \"EMA 100\", ema3Color, 2)\r\nplot(showTrendFilter ? trendFilterEma : na, \"Trend Filter EMA\", trendFilterColor, 3)\r\n\r\n// ========================================\r\n// SIGNAL CONDITIONS\r\n// ========================================\r\n// EMA alignment\r\nemasLong = ema1 > ema2 and ema2 > ema3\r\nemasShort = ema1 < ema2 and ema2 < ema3\r\n\r\n// RSI conditions\r\ncandleBullish = rsiValue >= rsiBullishLow and rsiValue < rsiBullishHigh\r\ncandleBearish = rsiValue <= rsiBearishHigh and rsiValue > rsiBearishLow\r\n\r\n// Price crossovers\r\npriceCrossAboveEma1 = ta.crossover(close, ema1)\r\npriceCrossBelowEma1 = ta.crossunder(close, ema1)\r\npriceCrossAboveEma3 = ta.crossover(close, ema3)\r\npriceCrossBelowEma3 = ta.crossunder(close, ema3)\r\n\r\n// EMA100 cross exit conditions\r\nema100CrossDown = ta.crossunder(close, ema3)\r\nema100CrossUp = ta.crossover(close, ema3)\r\n\r\n// RSI filters\r\nrsiNotOverbought = not useRsiFilter or rsiValue < rsiOverbought\r\nrsiNotOversold = not useRsiFilter or rsiValue > rsiOversold\r\n\r\n// Session filter\r\ninSession = not useSessionFilter or not na(time(timeframe.period, allowedSession))\r\n\r\n// Buy/Sell signals - DUAL CONDITIONS\r\n// Trend filter: Long only above EMA750, Short only below EMA750\r\nlongTrendOk = not useTrendFilter or close > trendFilterEma\r\nshortTrendOk = not useTrendFilter or close < trendFilterEma\r\n\r\n// Condition 1: First bullish candle closing above EMA21 with EMAs aligned\r\nbullishCandle = close > open\r\nbearishCandle = close < open\r\nwasBelow = close[1] < ema1\r\nwasAbove = close[1] > ema1\r\n\r\nbuySignal1 = emasLong and close > ema1 and wasBelow and bullishCandle and candleBullish and rsiNotOverbought and inSession and longTrendOk\r\nsellSignal1 = emasShort and close < ema1 and wasAbove and bearishCandle and candleBearish and rsiNotOversold and inSession and shortTrendOk\r\n\r\n// Condition 2: Cross EMA100 + bullish/bearish close (RSI based)\r\nbuySignal2 = priceCrossAboveEma3 and rsiValue > 55 and rsiNotOverbought and inSession and longTrendOk\r\nsellSignal2 = priceCrossBelowEma3 and rsiValue < 45 and rsiNotOversold and inSession and shortTrendOk\r\n\r\n// Combined signals (either condition triggers entry)\r\nbuySignal = buySignal1 or buySignal2\r\nsellSignal = sellSignal1 or sellSignal2\r\n\r\n// ========================================\r\n// CALCULATE STOP LOSS & TAKE PROFIT\r\n// ========================================\r\nvar float longStopPrice = na\r\nvar float longTakeProfitPrice = na\r\nvar float shortStopPrice = na\r\nvar float shortTakeProfitPrice = na\r\nvar float entryPrice = na\r\nvar float initialStopDistance = na\r\n\r\ncalcStopLoss(isLong) =>\r\n    if stopLossType == \"Fixed %\"\r\n        isLong ? close * (1 - stopLossPercent / 100) : close * (1 + stopLossPercent / 100)\r\n    else if stopLossType == \"ATR\"\r\n        isLong ? close - atr * atrMultiplier : close + atr * atrMultiplier\r\n    else  // Session Low/High\r\n        // Simplified: use ATR as fallback\r\n        isLong ? close - atr * atrMultiplier : close + atr * atrMultiplier\r\n\r\ncalcTakeProfit(isLong, stopPrice) =>\r\n    stopDistance = math.abs(close - stopPrice)\r\n    if takeProfitType == \"Fixed %\"\r\n        isLong ? close * (1 + takeProfitPercent / 100) : close * (1 - takeProfitPercent / 100)\r\n    else  // Risk/Reward\r\n        isLong ? close + stopDistance * riskRewardRatio : close - stopDistance * riskRewardRatio\r\n\r\n// ========================================\r\n// ENTRY CONDITIONS\r\n// ========================================\r\nallowLong = tradeDirection == \"Long Only\" or tradeDirection == \"Both\"\r\nallowShort = tradeDirection == \"Short Only\" or tradeDirection == \"Both\"\r\n\r\n// Entry for Long\r\nif buySignal and allowLong and strategy.position_size == 0\r\n    entryPrice := close\r\n    longStopPrice := useStopLoss ? calcStopLoss(true) : na\r\n    longTakeProfitPrice := useTakeProfit ? calcTakeProfit(true, longStopPrice) : na\r\n    initialStopDistance := math.abs(close - longStopPrice)\r\n    strategy.entry(\"Long\", strategy.long)\r\n\r\n// Entry for Short\r\nif sellSignal and allowShort and strategy.position_size == 0\r\n    entryPrice := close\r\n    shortStopPrice := useStopLoss ? calcStopLoss(false) : na\r\n    shortTakeProfitPrice := useTakeProfit ? calcTakeProfit(false, shortStopPrice) : na\r\n    initialStopDistance := math.abs(close - shortStopPrice)\r\n    strategy.entry(\"Short\", strategy.short)\r\n\r\n// Pyramiding\r\nif usePyramiding and strategy.position_size > 0\r\n    currentPositions = math.abs(strategy.position_size) / (strategy.position_avg_price * strategy.position_size / close)\r\n    \r\n    if buySignal and strategy.position_size > 0 and currentPositions < maxPyramidPositions\r\n        strategy.entry(\"Long\", strategy.long)\r\n    \r\n    if sellSignal and strategy.position_size < 0 and currentPositions < maxPyramidPositions\r\n        strategy.entry(\"Short\", strategy.short)\r\n\r\n// ========================================\r\n// EXIT CONDITIONS\r\n// ========================================\r\n// Breakeven logic\r\nvar bool movedToBreakeven = false\r\n\r\nif strategy.position_size > 0  // Long position\r\n    if not movedToBreakeven and useBreakeven\r\n        profitTicks = (close - strategy.position_avg_price) / syminfo.mintick\r\n        triggerTicks = initialStopDistance * breakevenTrigger / syminfo.mintick\r\n        if profitTicks >= triggerTicks\r\n            longStopPrice := strategy.position_avg_price * (1 + breakevenOffset / 100)\r\n            movedToBreakeven := true\r\n\r\nif strategy.position_size < 0  // Short position\r\n    if not movedToBreakeven and useBreakeven\r\n        profitTicks = (strategy.position_avg_price - close) / syminfo.mintick\r\n        triggerTicks = initialStopDistance * breakevenTrigger / syminfo.mintick\r\n        if profitTicks >= triggerTicks\r\n            shortStopPrice := strategy.position_avg_price * (1 - breakevenOffset / 100)\r\n            movedToBreakeven := true\r\n\r\n// Trailing Stop\r\nif strategy.position_size > 0 and useTrailingStop  // Long position\r\n    trailStop = trailingStopType == \"Fixed %\" ? \r\n         close * (1 - trailingStopPercent / 100) : \r\n         close - atr * trailingAtrMultiplier\r\n    \r\n    if na(longStopPrice) or trailStop > longStopPrice\r\n        longStopPrice := trailStop\r\n\r\nif strategy.position_size < 0 and useTrailingStop  // Short position\r\n    trailStop = trailingStopType == \"Fixed %\" ? \r\n         close * (1 + trailingStopPercent / 100) : \r\n         close + atr * trailingAtrMultiplier\r\n    \r\n    if na(shortStopPrice) or trailStop < shortStopPrice\r\n        shortStopPrice := trailStop\r\n\r\n// Exit Long\r\nif strategy.position_size > 0\r\n    // EMA100 Cross exit (override other exits if selected)\r\n    if stopLossType == \"EMA100 Cross\" and ema100CrossDown\r\n        strategy.close(\"Long\", comment=\"EMA100 Cross Exit\")\r\n        movedToBreakeven := false\r\n    \r\n    if useStopLoss and useTakeProfit and not na(longStopPrice) and not na(longTakeProfitPrice) and stopLossType != \"EMA100 Cross\"\r\n        strategy.exit(\"Exit Long\", \"Long\", stop=longStopPrice, limit=longTakeProfitPrice, comment_profit=\"Exit TP\", comment_loss=\"Exit SL\")\r\n    else if useStopLoss and not useTakeProfit and not na(longStopPrice) and stopLossType != \"EMA100 Cross\"\r\n        strategy.exit(\"Exit Long\", \"Long\", stop=longStopPrice, comment=\"Exit SL\")\r\n    else if useTakeProfit and not useStopLoss and not na(longTakeProfitPrice)\r\n        strategy.exit(\"Exit Long\", \"Long\", limit=longTakeProfitPrice, comment=\"Exit TP\")\r\n    else if useTakeProfit and stopLossType == \"EMA100 Cross\" and not na(longTakeProfitPrice)\r\n        strategy.exit(\"Exit Long\", \"Long\", limit=longTakeProfitPrice, comment=\"Exit TP\")\r\n    \r\n    // Exit on opposite signal\r\n    if sellSignal\r\n        strategy.close(\"Long\", comment=\"Opposite Signal\")\r\n        movedToBreakeven := false\r\n\r\n// Exit Short\r\nif strategy.position_size < 0\r\n    // EMA100 Cross exit (override other exits if selected)\r\n    if stopLossType == \"EMA100 Cross\" and ema100CrossUp\r\n        strategy.close(\"Short\", comment=\"EMA100 Cross Exit\")\r\n        movedToBreakeven := false\r\n    \r\n    if useStopLoss and useTakeProfit and not na(shortStopPrice) and not na(shortTakeProfitPrice) and stopLossType != \"EMA100 Cross\"\r\n        strategy.exit(\"Exit Short\", \"Short\", stop=shortStopPrice, limit=shortTakeProfitPrice, comment_profit=\"Exit TP\", comment_loss=\"Exit SL\")\r\n    else if useStopLoss and not useTakeProfit and not na(shortStopPrice) and stopLossType != \"EMA100 Cross\"\r\n        strategy.exit(\"Exit Short\", \"Short\", stop=shortStopPrice, comment=\"Exit SL\")\r\n    else if useTakeProfit and not useStopLoss and not na(shortTakeProfitPrice)\r\n        strategy.exit(\"Exit Short\", \"Short\", limit=shortTakeProfitPrice, comment=\"Exit TP\")\r\n    else if useTakeProfit and stopLossType == \"EMA100 Cross\" and not na(shortTakeProfitPrice)\r\n        strategy.exit(\"Exit Short\", \"Short\", limit=shortTakeProfitPrice, comment=\"Exit TP\")\r\n    \r\n    // Exit on opposite signal\r\n    if buySignal\r\n        strategy.close(\"Short\", comment=\"Opposite Signal\")\r\n        movedToBreakeven := false\r\n\r\n// Reset breakeven flag when no position\r\nif strategy.position_size == 0\r\n    movedToBreakeven := false\r\n\r\n// ========================================\r\n// VISUALIZATION\r\n// ========================================\r\n// Plot entry signals\r\nplotshape(buySignal and allowLong, \"Buy Signal\", shape.triangleup, location.belowbar, color.new(color.green, 0), size=size.small)\r\nplotshape(sellSignal and allowShort, \"Sell Signal\", shape.triangledown, location.abovebar, color.new(color.red, 0), size=size.small)\r\n\r\n// Plot Stop Loss and Take Profit levels\r\nplot(strategy.position_size > 0 ? longStopPrice : na, \"Long SL\", color.red, 2, plot.style_linebr)\r\nplot(strategy.position_size > 0 ? longTakeProfitPrice : na, \"Long TP\", color.green, 2, plot.style_linebr)\r\nplot(strategy.position_size < 0 ? shortStopPrice : na, \"Short SL\", color.red, 2, plot.style_linebr)\r\nplot(strategy.position_size < 0 ? shortTakeProfitPrice : na, \"Short TP\", color.green, 2, plot.style_linebr)\r\n\r\n// Plot entry price\r\nplot(strategy.position_size != 0 ? strategy.position_avg_price : na, \"Entry Price\", color.yellow, 1, plot.style_linebr)\r\n\r\n// Background color for position\r\nbgcolor(strategy.position_size > 0 ? color.new(color.green, 95) : strategy.position_size < 0 ? color.new(color.red, 95) : na, title=\"Position Background\")\r\n\r\n// ========================================\r\n// STATISTICS TABLE\r\n// ========================================\r\nvar table statsTable = table.new(position.top_right, 2, 13, bgcolor=color.new(color.black, 20), border_width=2, border_color=color.new(color.gray, 50))\r\n\r\nif barstate.islast\r\n    // Header\r\n    table.cell(statsTable, 0, 0, \"Stats\", text_color=color.white, bgcolor=color.new(color.blue, 30), text_size=size.small)\r\n    table.cell(statsTable, 1, 0, \"\", text_color=color.white, bgcolor=color.new(color.blue, 30))\r\n    \r\n    // Win Rate\r\n    winRate = strategy.wintrades / (strategy.wintrades + strategy.losstrades) * 100\r\n    table.cell(statsTable, 0, 1, \"Win Rate\", text_color=color.white, text_size=size.small)\r\n    table.cell(statsTable, 1, 1, str.tostring(math.round(winRate, 2)) + \"%\", text_color=color.white, text_size=size.small)\r\n    \r\n    // Total Trades\r\n    table.cell(statsTable, 0, 2, \"Trades\", text_color=color.white, text_size=size.small)\r\n    table.cell(statsTable, 1, 2, str.tostring(strategy.closedtrades), text_color=color.white, text_size=size.small)\r\n    \r\n    // Win/Loss\r\n    table.cell(statsTable, 0, 3, \"W/L\", text_color=color.white, text_size=size.small)\r\n    table.cell(statsTable, 1, 3, str.tostring(strategy.wintrades) + \"/\" + str.tostring(strategy.losstrades), text_color=color.white, text_size=size.small)\r\n    \r\n    // Profit Factor\r\n    table.cell(statsTable, 0, 4, \"PF\", text_color=color.white, text_size=size.small)\r\n    table.cell(statsTable, 1, 4, str.tostring(math.round(strategy.grossprofit / strategy.grossloss, 2)), \r\n         text_color=strategy.grossprofit > strategy.grossloss ? color.lime : color.red, text_size=size.small)\r\n    \r\n    // Risk/Reward Ratio\r\n    avgWin = strategy.wintrades > 0 ? strategy.grossprofit / strategy.wintrades : 0\r\n    avgLoss = strategy.losstrades > 0 ? strategy.grossloss / strategy.losstrades : 0\r\n    actualRR = avgLoss > 0 ? avgWin / avgLoss : 0\r\n    table.cell(statsTable, 0, 5, \"R:R\", text_color=color.white, text_size=size.small)\r\n    table.cell(statsTable, 1, 5, str.tostring(math.round(actualRR, 2)), \r\n         text_color=actualRR >= 1.5 ? color.lime : actualRR >= 1 ? color.yellow : color.red, text_size=size.small)\r\n    \r\n    // Net Profit\r\n    netProfit = strategy.netprofit / strategy.initial_capital * 100\r\n    table.cell(statsTable, 0, 6, \"Profit\", text_color=color.white, text_size=size.small)\r\n    table.cell(statsTable, 1, 6, str.tostring(math.round(netProfit, 2)) + \"%\", \r\n         text_color=netProfit > 0 ? color.lime : color.red, text_size=size.small)\r\n    \r\n    // Breakeven Status\r\n    table.cell(statsTable, 0, 7, \"BE\", text_color=color.white, text_size=size.small)\r\n    beStatus = useBreakeven ? \"ON\" : \"OFF\"\r\n    beColor = useBreakeven ? color.lime : color.gray\r\n    table.cell(statsTable, 1, 7, beStatus, text_color=beColor, text_size=size.small)\r\n    \r\n    // Trailing Stop Status\r\n    table.cell(statsTable, 0, 8, \"Trail\", text_color=color.white, text_size=size.small)\r\n    tsStatus = useTrailingStop ? \"ON\" : \"OFF\"\r\n    tsColor = useTrailingStop ? color.lime : color.gray\r\n    table.cell(statsTable, 1, 8, tsStatus, text_color=tsColor, text_size=size.small)\r\n    \r\n    // Pyramiding Status\r\n    table.cell(statsTable, 0, 9, \"Pyram\", text_color=color.white, text_size=size.small)\r\n    pyrStatus = usePyramiding ? \"x\" + str.tostring(maxPyramidPositions) : \"OFF\"\r\n    pyrColor = usePyramiding ? color.lime : color.gray\r\n    table.cell(statsTable, 1, 9, pyrStatus, text_color=pyrColor, text_size=size.small)\r\n    \r\n    // Session Filter Status\r\n    table.cell(statsTable, 0, 10, \"Session\", text_color=color.white, text_size=size.small)\r\n    sessionStatus = useSessionFilter ? allowedSession : \"OFF\"\r\n    sessionColor = useSessionFilter ? color.lime : color.gray\r\n    table.cell(statsTable, 1, 10, sessionStatus, text_color=sessionColor, text_size=size.small)\r\n    \r\n    // Current Position\r\n    posSize = strategy.position_size\r\n    posType = posSize > 0 ? \"LONG\" : posSize < 0 ? \"SHORT\" : \"NONE\"\r\n    posColor = posSize > 0 ? color.green : posSize < 0 ? color.red : color.gray\r\n    table.cell(statsTable, 0, 11, \"Position\", text_color=color.white, text_size=size.small)\r\n    table.cell(statsTable, 1, 11, posType, text_color=posColor, text_size=size.small)\r\n    \r\n    // RSI Value\r\n    table.cell(statsTable, 0, 12, \"RSI\", text_color=color.white, text_size=size.small)\r\n    rsiColor = rsiValue >= rsiOverbought ? color.red : rsiValue <= rsiOversold ? color.lime : color.gray\r\n    table.cell(statsTable, 1, 12, str.tostring(math.round(rsiValue, 2)), text_color=rsiColor, text_size=size.small)"
  },
  {
    "url": "J5akHbOr-XRP-Non-Stop-Strategy-TP-25-SL-15",
    "name": "XRP Non-Stop Strategy (TP 25% / SL 15%)",
    "description": "XRP Non-Stop Strategy (TP 25% / SL 15%) is a continuous long-side trading system designed specifically for XRP. The strategy uses an EMA-based trend filter (EMA20/EMA50) to confirm bullish conditions before entering a long position. Each trade applies a fixed +25% Take Profit target and a âˆ’15% Stop Loss, calculated dynamically from the entry price.\nWhen a trade closesâ€”whether by TP or SLâ€”the strategy automatically re-enters on the next qualifying signal, enabling uninterrupted position cycling.\nFeatures include:\nâ€¢ EMA-based trend confirmation\nâ€¢ Dynamic TP/SL visualization on the chart\nâ€¢ Clear BUY and EXIT markers\nâ€¢ Dedicated alert conditions for automation",
    "image_url": "J5akHbOr",
    "author": "antishyilma81",
    "likes": 6,
    "type": "strategy",
    "created": "2025-12-04",
    "updated": "2025-12-04",
    "source": "//@version=5\r\nstrategy(\r\n     \"XRP Non-Stop Strategy (TP 25% / SL 15%)\",\r\n     overlay         = true,\r\n     initial_capital = 10000,\r\n     commission_type = strategy.commission.percent,\r\n     commission_value= 0.1,\r\n     pyramiding      = 0,\r\n     margin_long     = 100,\r\n     process_orders_on_close = true)\r\n\r\n// =====================\r\n// XRP ONLY FILTER\r\n// =====================\r\nxrpOnly  = input.bool(true, \"Limit to XRP only?\")\r\nisXRP    = str.contains(str.upper(syminfo.ticker), \"XRP\")\r\ncanTrade = not xrpOnly or isXRP\r\n\r\n// =====================\r\n// FIXED TAKE PROFIT & STOP LOSS\r\n// =====================\r\ntpPerc = 25.0   // TAKE PROFIT 25%\r\nslPerc = 15.0   // STOP LOSS 15%\r\n\r\n// =====================\r\n// TREND FILTER (EMA 20 / EMA 50)\r\n// =====================\r\nuseTrendFilter = input.bool(true, \"Use EMA trend filter?\")\r\nfastEmaLen     = input.int(20, \"Fast EMA\", minval = 1)\r\nslowEmaLen     = input.int(50, \"Slow EMA\", minval = 1)\r\n\r\nfastEMA = ta.ema(close, fastEmaLen)\r\nslowEMA = ta.ema(close, slowEmaLen)\r\n\r\nbullTrend = not useTrendFilter or fastEMA > slowEMA\r\n\r\n// =====================\r\n// NON-STOP LONG ENTRY\r\n// =====================\r\nif canTrade and bullTrend and strategy.position_size == 0\r\n    strategy.entry(\"XRP Long\", strategy.long)\r\n\r\n// =====================\r\n// CALCULATE TP & SL\r\n// =====================\r\nvar float longStop = na\r\nvar float longTP   = na\r\n\r\nif strategy.position_size > 0\r\n    entryPrice = strategy.position_avg_price\r\n    longStop := entryPrice * (1 - slPerc / 100.0)  // 15% SL\r\n    longTP   := entryPrice * (1 + tpPerc / 100.0)  // 25% TP\r\n\r\n    strategy.exit(\r\n         \"XRP Long Exit\",\r\n         from_entry = \"XRP Long\",\r\n         stop  = longStop,\r\n         limit = longTP)\r\n\r\n// =====================\r\n// ENTRY / EXIT EVENTS\r\n// =====================\r\nlongEntry = strategy.position_size > 0 and strategy.position_size[1] <= 0\r\nlongExit  = strategy.position_size == 0 and strategy.position_size[1] > 0\r\n\r\n// =====================\r\n// PLOT TP & SL LINES\r\n// =====================\r\nplot(longTP,   title=\"Take Profit 25%\", color=color.new(color.green, 0), style=plot.style_linebr)\r\nplot(longStop, title=\"Stop Loss 15%\",   color=color.new(color.red,   0), style=plot.style_linebr)\r\n\r\n// Entry/Exit markers\r\nplotshape(longEntry,\r\n     title     = \"BUY\",\r\n     style     = shape.triangleup,\r\n     location  = location.belowbar,\r\n     size      = size.large,\r\n     color     = color.new(color.green, 0),\r\n     text      = \"BUY\")\r\n\r\nplotshape(longExit,\r\n     title     = \"EXIT\",\r\n     style     = shape.triangledown,\r\n     location  = location.abovebar,\r\n     size      = size.large,\r\n     color     = color.new(color.red, 0),\r\n     text      = \"EXIT\")\r\n\r\n// =====================\r\n// ALERTS\r\n// =====================\r\nalertcondition(longEntry, title=\"XRP BUY\",  message=\"XRP BUY â†’ New long position opened.\")\r\nalertcondition(longExit,  title=\"XRP EXIT\", message=\"XRP EXIT â†’ Position closed (TP 25% or SL 15%).\")\r\n"
  },
  {
    "url": "sBbAEEwH-XRP-Non-Stop-Strategy-TP-25-SL-15",
    "name": "XRP Non-Stop Strategy (TP 25% / SL 15%)",
    "description": "This strategy performs continuous automated trading exclusively on XRP. It opens long positions during favorable trend conditions, using a fixed Take Profit target of 25% above the entry price and a fixed Stop Loss of 15% below the entry. Once a trade is closed (either TP or SL), the strategy automatically re-enters on the next valid signal, enabling uninterrupted trading.\nThe script includes:\n\nDynamic Take Profit & Stop Loss lines\n\nOptional EMA trend filter\n\nVisual BUY and EXIT markers\n\nTradingView alerts for automation or notifications\nThis strategy is built for traders who want a simple, price-action-driven system without fixed price levels, relying only on percentage-based movement from each entry.",
    "image_url": "sBbAEEwH",
    "author": "antishyilma81",
    "likes": 2,
    "type": "strategy",
    "created": "2025-12-04",
    "updated": "2025-12-04",
    "source": "//@version=5\r\nstrategy(\r\n     \"XRP Non-Stop Strategy (TP 25% / SL 15%)\",\r\n     overlay         = true,\r\n     initial_capital = 10000,\r\n     commission_type = strategy.commission.percent,\r\n     commission_value= 0.1,\r\n     pyramiding      = 0,\r\n     margin_long     = 100,\r\n     process_orders_on_close = true)\r\n\r\n// =====================\r\n// XRP ONLY FILTER\r\n// =====================\r\nxrpOnly  = input.bool(true, \"Limit to XRP only?\")\r\nisXRP    = str.contains(str.upper(syminfo.ticker), \"XRP\")\r\ncanTrade = not xrpOnly or isXRP\r\n\r\n// =====================\r\n// FIXED TAKE PROFIT & STOP LOSS\r\n// =====================\r\ntpPerc = 25.0   // TAKE PROFIT 25%\r\nslPerc = 15.0   // STOP LOSS 15%\r\n\r\n// Trend filter (optional for smoother entries)\r\nuseTrendFilter = input.bool(true, \"Use EMA trend filter?\")\r\nfastEmaLen     = input.int(20, \"Fast EMA\", minval = 1)\r\nslowEmaLen     = input.int(50, \"Slow EMA\", minval = 1)\r\n\r\nfastEMA = ta.ema(close, fastEmaLen)\r\nslowEMA = ta.ema(close, slowEmaLen)\r\n\r\nbullTrend = not useTrendFilter or fastEMA > slowEMA\r\n\r\n// =====================\r\n// NON-STOP LONG ENTRY\r\n// =====================\r\nif canTrade and bullTrend and strategy.position_size == 0\r\n    strategy.entry(\"XRP Long\", strategy.long)\r\n\r\n// =====================\r\n// CALCULATE TP & SL\r\n// =====================\r\nvar float longStop = na\r\nvar float longTP   = na\r\n\r\nif strategy.position_size > 0\r\n    entryPrice = strategy.position_avg_price\r\n\r\n    longStop := entryPrice * (1 - slPerc / 100.0)  // 15% SL\r\n    longTP   := entryPrice * (1 + tpPerc / 100.0)  // 25% TP\r\n\r\n    strategy.exit(\r\n         \"XRP Long Exit\",\r\n         from_entry = \"XRP Long\",\r\n         stop  = longStop,\r\n         limit = longTP)\r\n\r\n// =====================\r\n// PLOT TP & SL LINES\r\n// =====================\r\nplot(longTP,   title=\"Take Profit 25%\", color=color.new(color.green, 0), style=plot.style_linebr)\r\nplot(longStop, title=\"Stop Loss 15%\",   color=color.new(color.red,   0), style=plot.style_linebr)\r\n\r\n// Entry/Exit markers\r\nlongEntry = strategy.position_size > 0 and strategy.position_size[1] <= 0\r\nlongExit  = strategy.position_size == 0 and strategy.position_size[1] > 0\r\n\r\nplotshape(longEntry,\r\n     title     = \"BUY\",\r\n     style     = shape.triangleup,\r\n     location  = location.belowbar,\r\n     size      = size.large,\r\n     color     = color.new(color.green, 0),\r\n     text      = \"BUY\")\r\n\r\nplotshape(longExit,\r\n     title     = \"EXIT\",\r\n     style     = shape.triangledown,\r\n     location  = location.abovebar,\r\n     size      = size.large,\r\n     color     = color.new(color.red, 0),\r\n     text      = \"EXIT\")\r\n\r\n// =====================\r\n// ALERTS\r\n// =====================\r\nalertcondition(longEntry, title=\"XRP BUY\",  message=\"XRP BUY â†’ New long position opened.\")\r\nalertcondition(longExit,  title=\"XRP EXIT\", message=\"XRP EXIT â†’ Position closed (TP 25% or SL 15%).\")\r\n"
  },
  {
    "url": "0n5d1gsZ-BTC-Mon-8am-Buy-Wed-2pm-Sell-NY-Time-Daily-Intraday",
    "name": "BTC Mon 8am Buy / Wed 2pm Sell (NY Time, Daily + Intraday)",
    "description": "This strategy implements a fixed weekly time-based trading schedule for Bitcoin, using New York market hours as the reference clock. It is designed to test whether a consistent pattern exists between early-week accumulation and mid-week distribution in BTC price behavior.\nEntry Rule â€” Monday 8:00 AM (NY Time)\nThe strategy enters a long position every Monday at exactly 08:00 AM Eastern Time, one hour after the U.S. equities market pre-open activity begins influencing global liquidity.\nThis timing attempts to capture early-week directional moves in Bitcoin, which sometimes occur as traditional markets come online.\nExit Rule â€” Wednesday 2:00 PM (NY Time)\nThe strategy closes the position every Wednesday at 2:00 PM Eastern Time, a point in the week where:\nU.S. equity markets are still open\nBTC often experiences mid-week volatility rotations\nLiquidity is generally high\nThis exit removes exposure before later-week uncertainty and gives a consistent, measurable time window for each trade.\nTimeframe Compatibility\nWorks on intraday charts (recommended 1h or lower) using precise time-based triggers.\nAlso runs on daily charts, where entries and exits occur on the Monday and Wednesday bars respectively (daily charts cannot show intraday timestamps).\nAll timestamps are synced to America/New_York regardless of the exchangeâ€™s native timezone.\nTrading Frequency\nExactly one trade per week, preventing overtrading and allowing comparison of weekly performance across years of historical BTC price data.\nPurpose of the Strategy\nThis is not a value-based or trend-following system, but a behavioral/time-cycle analysis tool.\nIt helps evaluate whether a repeating short-term edge exists based solely on:\nWeekday timing\nLiquidity cycles\nInstitutional market influence\nBTCâ€™s habitual early-week momentum patterns\nIt is ideal for:\nBacktesting weekly BTC behavior\nStudying time-based edges\nComparing alternative weekday/time combinations\nVisualizing weekly P&L structure\nRisk Notes\nThis strategy does not attempt to predict price direction and should not be assumed profitable without robust backtesting.\nTime-based edges can appear, disappear, or invert depending on macro conditions.\nThere is no stop loss or risk management included by default, so the strategy reflects raw timing-based performance.",
    "image_url": "0n5d1gsZ",
    "author": "hbayatne",
    "likes": 2,
    "type": "strategy",
    "created": "2025-12-03",
    "updated": "2025-12-03",
    "source": "//@version=5\nstrategy(\"BTC Mon 8am Buy / Wed 2pm Sell (NY Time, Daily + Intraday)\",\n     overlay = true,\n     initial_capital = 10000,\n     pyramiding = 0,\n     commission_type = strategy.commission.percent,\n     commission_value = 0.1,\n     process_orders_on_close = true)\n\n// --- Get time in New York timezone tied to chart's resolution ---\nnyTime   = time(timeframe.period, \"America/New_York\")\n\ndayNY    = dayofweek(nyTime)\nhourNY   = hour(nyTime)\nminuteNY = minute(nyTime)\nweekNY   = weekofyear(nyTime)\n\nisIntraday = timeframe.isintraday\n\n// --- Intraday exact-time logic (best on <= 1h charts) ---\n// Buy: Monday 08:00 NY\nenterIntraday = isIntraday and dayNY == dayofweek.monday    and hourNY == 8  and minuteNY == 0\n// Sell: Wednesday 14:00 (2pm) NY\nexitIntraday  = isIntraday and dayNY == dayofweek.wednesday and hourNY == 14 and minuteNY == 0\n\n// --- Daily-or-higher logic: approximate by day only ---\nenterDaily = (not isIntraday) and dayNY == dayofweek.monday\nexitDaily  = (not isIntraday) and dayNY == dayofweek.wednesday\n\n// --- Combined conditions ---\nenterCond = enterIntraday or enterDaily\nexitCond  = exitIntraday  or exitDaily\n\n// --- Only one entry per week ---\nvar int lastEntryWeek = na\ncanEnter = na(lastEntryWeek) or (weekNY != lastEntryWeek)\n\nif enterCond and canEnter and strategy.position_size == 0\n    strategy.entry(\"Long_Mon8\", strategy.long)\n    lastEntryWeek := weekNY\n\nif exitCond and strategy.position_size > 0\n    strategy.close(\"Long_Mon8\")\n"
  },
  {
    "url": "fURZdvM1-Long-Only-EMA-Strategy-9-20-with-200-EMA-Filter",
    "name": "Long Only EMA Strategy (9/20 with 200 EMA Filter)",
    "description": "Details: \n\nThis strategy is built around a very simple idea: follow the primary trend and enter only when momentum supports it.  \nIt uses three EMAs on a standard candlestick chart:\n\n1. 9â€‘period EMA â€“ shortâ€‘term momentum  \n2. 20â€‘period EMA â€“ mediumâ€‘term structure  \n3. 200â€‘period EMA â€“ longâ€‘term trend filter  \n\nThe strategy is ** longâ€‘only ** and is mainly designed for swing trading and positional trading.  \nIt avoids counterâ€‘trend trades by taking entries only when price is trading ** above the 200 EMA **, which is commonly used as a longâ€‘term trend reference.\n\nThe rules are deliberately kept simple so that they are easy to understand, modify, and test on different markets and timeframes.\n\n---\n\n Key Features\n \n1. **Trendâ€‘Filtered Entries**  \n   - Fresh long positions are considered only when:\n     - The 9 EMA crosses above the 20 EMA  \n     - The closing price is **above** the 200 EMA  \n   - This attempts to combine shortâ€‘term momentum with a higherâ€‘timeframe trend filter.\n\n2. **Clean Exit Logic**  \n   - The long position is exited when the closing price crosses **below** the 20 EMA.  \n   - This creates an objective, ruleâ€‘based way to trail the trade as long as the mediumâ€‘term structure remains intact.\n\n3. **Longâ€‘Only, No Short Selling**  \n   - The script intentionally ignores short setups.  \n   - This makes it suitable for markets or accounts where short selling is restricted, or for traders who prefer to participate only on the long side of the market.\n\n4. **Simple Visuals**  \n   - All three EMAs are plotted directly on the chart:\n     - 9 EMA (fast)  \n     - 20 EMA (medium)  \n     - 200 EMA (trend)  \n   - Trade entries and exits are handled by TradingViewâ€™s strategy engine, so users can see results in the Strategy Tester as well as directly on the chart.\n\n5. **Backtestâ€‘Friendly Structure**  \n   - Uses TradingViewâ€™s builtâ€‘in `strategy()` framework.  \n   - Can be applied to different symbols, timeframes, and markets (equities, indices, crypto, etc.).  \n   - Works on standard candlestick charts, which are supported by TradingViewâ€™s backtesting engine.\n\n6. **Configurable in Code**  \n   - The EMA periods are defined in the code and can be easily adjusted.  \n   - Users can tailor the parameters to fit their own style (for example, faster EMAs for intraday trading, slower EMAs for positional trades).\n\n---\n\n How to Use \n\n1. **Add the Strategy to Your Chart**  \n   1. Open any symbol and select a **standard candlestick chart**.  \n   2. Apply the strategy from your â€œMy Scriptsâ€ section.  \n   3. Make sure it is enabled so that the trades and results appear.\n\n2. **Select Timeframe**  \n   - The logic can be tested on various timeframes:\n     - Higher timeframes (1H, 4H, 1D) for swing and positional setups.  \n     - Lower timeframes (5m, 15m) for more active trading, if desired.  \n   - Users should experiment and see where the strategy behaves more consistently for their chosen market.\n\n3. **Read the Signals**  \n   - **Entry:**  \n     - A long trade is opened when the 9 EMA crosses above the 20 EMA while the closing price is above the 200 EMA.  \n   - **Exit:**  \n     - The open long position is closed when the closing price crosses below the 20 EMA.  \n   - All orders are generated automatically once the strategy is attached to the chart.\n\n4. **Use the Strategy Tester**  \n   - Go to the **Strategy Tester** tab in TradingView.  \n   - Check:\n     - Net profit / drawdown  \n     - Win rate and average trade  \n     - List of trades and the equity curve  \n   - Change the date range and timeframe to see how stable the results are over different periods.\n\n5. **Adjust Parameters if Needed**  \n   - Advanced users can open the code and experiment with:\n     - EMA lengths (for example 8/21 with 200, or 10/30 with 200)  \n     - Risk sizing and capital settings within the `strategy()` call  \n   - Any changes should be thoroughly reâ€‘tested before considering realâ€‘world application.\n\n---\n\n Practical Applications\n \n1. **Swing Trading on Daily Charts**  \n   - Can be applied to stocks, indices, or ETFs on the daily timeframe.  \n   - The 200 EMA acts as a trend filter to stay aligned with the broad direction, while the 9/20 crossover helps catch mediumâ€‘term swings inside that trend.\n\n2. **Positional Trades on Higher Timeframes**  \n   - On 4H or 1D charts, this approach can help in holding trades for several days to weeks.  \n   - The exit rule based on the 20 EMA crossing helps avoid emotional decisions and provides a rulesâ€‘based way to trail the trend.\n\n3. **Trendâ€‘Following Filter**  \n   - Even if used purely as a filter, the 200 EMA condition can help traders:\n     - Avoid taking long trades when the market is in a clear downtrend.  \n     - Focus only on instruments that are trading above their longâ€‘term average.\n\n4. **Educational Use**  \n   - The script is intentionally kept straightforward so that newer users can:\n     - Learn how a moving average crossover strategy works.  \n     - See how to combine a shortâ€‘term signal with a longâ€‘term filter.  \n     - Understand how TradingViewâ€™s strategy engine handles entries and exits.\n\n5. **Basis for Further Development**  \n   - This can serve as a starting point for more advanced systems.  \n   - Traders can extend it by adding:\n     - Additional filters (RSI, volume, volatility filters, timeâ€‘ofâ€‘day filters, etc.)  \n     - Risk management rules (fixed stop loss, take profit, trailing stops).  \n   - The current version is kept minimal on purpose, so modifications are easy to implement and test.\n\n---\n\n Important Notes & Disclaimer\n \n1. This strategy is provided **for testing, research, and educational purposes only**.  \n2. It is ** not ** a recommendation to buy or sell any financial instrument.  \n3. Past performance on historical data does not guarantee similar results in live markets.  \n4. Markets are risky and trading can lead to financial loss; users should always do their own research, manage risk appropriately, and consult a qualified financial professional if needed.  \n5. Before using any strategy with real capital, it is strongly advised to:\n   - Forward test it on a demo / paper trading account.  \n   - Check how it behaves during different market phases (trending, sideways, highâ€‘volatility conditions).  \n\nYou are free to modify the parameters and logic to better align it with your own trading style and risk tolerance.",
    "image_url": "fURZdvM1",
    "author": "growbharat2005",
    "likes": 22,
    "type": "strategy",
    "created": "2025-12-03",
    "updated": "2025-12-03",
    "source": "//@version=6\nstrategy('Long Only EMA Strategy (9/20 with 200 EMA Filter)', overlay = true, initial_capital = 100000, default_qty_type = strategy.percent_of_equity, default_qty_value = 10)\n\n// EMA lengths\nshortEmaLen = 9\nlongEmaLen = 20\ntrendEmaLen = 200\n\n// Calculate EMAs\nemaShort = ta.ema(close, shortEmaLen) // 9 EMA\nemaLong = ta.ema(close, longEmaLen) // 20 EMA\nemaTrend = ta.ema(close, trendEmaLen) // 200 EMA\n\n// Plot EMAs\nplot(emaShort, color = color.blue, title = '9 EMA')\nplot(emaLong, color = color.orange, title = '20 EMA')\nplot(emaTrend, color = color.purple, title = '200 EMA')\n\n// Entry: 9 crosses above 20 AND close above 200 EMA\nlongCondition = ta.crossover(emaShort, emaLong) and close > emaTrend\n\n// Exit: close crosses below 20 EMA\nexitCondition = ta.crossunder(close, emaLong)\n\n// Long only\nif longCondition\n    strategy.entry('Long', strategy.long)\n\nif exitCondition and strategy.position_size > 0\n    strategy.close('Long')\n\n// Debug label to see trade count\nvar label tradesLabel = na\nif barstate.islast\n    label.delete(tradesLabel)\n    tradesLabel := label.new(bar_index, high, 'Closed trades: ' + str.tostring(strategy.closedtrades))\n    tradesLabel\n"
  },
  {
    "url": "3SHJZytF",
    "name": "Strategy: HMA 50 + Supertrend Sniper",
    "description": "HMA 50 + Supertrend Confluence Strategy (Trend Following with Noise Filtering)\n\nDescription:\nIntroduction and Concept This strategy is designed to solve a common problem in trend-following trading: Lag vs. False Signals. Standard Moving Averages often lag too much, while price action indicators can generate false signals during choppy markets. This script combines the speed of the Hull Moving Average (HMA) with the volatility-based filtering of the Supertrend indicator to create a robust \"Confluence System.\"\n\nThe primary goal of this script is not just to overlay two indicators, but to enforce a strict rule where a trade is only taken when Momentum (HMA) and Volatility Direction (Supertrend) are in perfect agreement.\n\nWhy this combination? (The Logic Behind the Mashup)\n\nHull Moving Average (HMA 50): We use the HMA because it significantly reduces lag compared to SMA or EMA by using weighted calculations. It acts as our primary Trend Direction detector. However, HMA can be too sensitive and \"whipsaw\" during sideways markets.\n\nSupertrend (ATR-based): We use the Supertrend (Factor 3.0, Period 10) as our Volatility Filter. It uses Average True Range (ATR) to determine the significant trend boundary.\n\nHow it Works (Methodology) The strategy uses a boolean logic system to filter out low-quality trades:\n\nBullish Confluence: The HMA must be rising (Slope > 0) AND the Close Price must be above the Supertrend line (Uptrend).\n\nBearish Confluence: The HMA must be falling (Slope < 0) AND the Close Price must be below the Supertrend line (Downtrend).\n\nThe \"Choppy Zone\" (Noise Filter): This is a unique feature of this script. If the HMA indicates one direction (e.g., Rising) but the Supertrend indicates the opposite (e.g., Downtrend), the market is considered \"Choppy\" or indecisive. In this state, the script paints the candles or HMA line Gray and exits all positions (optional setting) to preserve capital.\n\nVisual Guide & Signals To make the script easy to interpret for traders who do not read Pine Script, I have implemented specific visual cues:\n\nGreen Cross (+): Indicates a LONG entry signal. Both HMA and Supertrend align bullishly.\n\nRed Cross (X): Indicates a SHORT entry signal. Both HMA and Supertrend align bearishly.\n\nThick Line (HMA): The main line changes color based on the trend.\n\nGreen: Bullish Confluence.\n\nRed: Bearish Confluence.\n\nGray: Divergence/Choppy (No Trade Zone).\n\nThin Step Line: This is the Supertrend line, serving as your dynamic Trailing Stop Loss.\n\nStrategy Settings\n\nHMA Length: Default is 50 (Mid-term trend).\n\nATR Factor/Period: Default is 3.0/10 (Standard for trend catching).\n\nExit on Choppy: A toggle switch allowing users to decide whether to hold through noise or exit immediately when indicators disagree.\n\nRisk Warning This strategy performs best in trending markets (Forex, Crypto, Indices). Like all trend-following systems, it may experience drawdown during prolonged accumulation/distribution phases. Please backtest with your specific asset before using it with real capital.",
    "image_url": "3SHJZytF",
    "author": "Gustav_Rex",
    "likes": 764,
    "type": "strategy",
    "created": "2025-12-02",
    "updated": "2025-12-02",
    "source": "//@version=5\nstrategy(\"Strategy: HMA 50 + Supertrend Sniper\", overlay=true, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=100)\n\n// --- 1. Settings ---\n// HMA Settings\nhmaLength = input.int(50, title=\"HMA Length (Trend)\", minval=1)\n\n// Supertrend Settings\natrPeriod = input.int(10, title=\"ATR Period\")\nfactor = input.float(3.0, title=\"ATR Multiplier (à¸„à¸§à¸²à¸¡à¸à¸§à¹‰à¸²à¸‡à¸‚à¸­à¸‡à¸ˆà¸¸à¸”à¸„à¸±à¸—)\", step=0.1)\n\n// Strategy Settings\nexitOnChoppy = input.bool(true, title=\"Exit when Choppy? (à¸›à¸´à¸”à¸­à¸­à¹€à¸”à¸­à¸£à¹Œà¹€à¸¡à¸·à¹ˆà¸­à¹€à¸‚à¹‰à¸²à¹‚à¸‹à¸™à¸ªà¸µà¹€à¸—à¸²)\")\nuseDateFilter = input.bool(false, title=\"Use Date Filter\")\nstartDate = input.time(timestamp(\"1 Jan 2024 00:00\"), title=\"Start Date\")\nendDate = input.time(timestamp(\"1 Jan 2030 00:00\"), title=\"End Date\")\n\n// --- 2. Calculations ---\n\n// HMA\nhmaValue = ta.hma(close, hmaLength)\nhmaRising = hmaValue > hmaValue[1]\nhmaFalling = hmaValue < hmaValue[1]\n\n// Supertrend\n[supertrend, direction] = ta.supertrend(factor, atrPeriod)\n// direction: -1 = uptrend (Green), 1 = downtrend (Red)\n\n// --- 3. Logic (The Confluence) ---\n\n// à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚ Buy: HMA à¸‚à¸¶à¹‰à¸™ + Supertrend à¹€à¸‚à¸µà¸¢à¸§\nisBullish = hmaRising and direction == -1\n// à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚ Sell: HMA à¸¥à¸‡ + Supertrend à¹à¸”à¸‡\nisBearish = hmaFalling and direction == 1\n// à¹€à¸‡à¸·à¹ˆà¸­à¸™à¹„à¸‚ Choppy (à¸‚à¸±à¸”à¹à¸¢à¹‰à¸‡à¸à¸±à¸™)\nisChoppy = (hmaRising and direction == 1) or (hmaFalling and direction == -1)\n\n// Date Filter Check\ninDateRange = useDateFilter ? (time >= startDate and time <= endDate) : true\n\n// --- 4. Strategy Execution ---\n\nif inDateRange\n    // à¹€à¸›à¸´à¸” Long\n    if isBullish\n        strategy.entry(\"Long\", strategy.long, comment=\"LONG\")\n    \n    // à¹€à¸›à¸´à¸” Short\n    if isBearish\n        strategy.entry(\"Short\", strategy.short, comment=\"SHORT\")\n        \n    // à¸›à¸´à¸”à¸ªà¸–à¸²à¸™à¸°à¹€à¸¡à¸·à¹ˆà¸­à¹€à¸‚à¹‰à¸²à¹‚à¸‹à¸™à¹„à¸¡à¹ˆà¸Šà¸±à¸”à¹€à¸ˆà¸™ (Optional: à¹€à¸žà¸·à¹ˆà¸­à¸„à¸§à¸²à¸¡à¸›à¸¥à¸­à¸”à¸ à¸±à¸¢)\n    if exitOnChoppy and isChoppy\n        strategy.close_all(comment=\"Close (Choppy)\")\n\n// --- 5. Plotting & Visuals (à¹€à¸«à¸¡à¸·à¸­à¸™à¹ƒà¸™à¸£à¸¹à¸›) ---\n\n// à¸ªà¸µ HMA\nhmaColor = isChoppy ? color.gray : (isBullish ? #00ff08 : #ff0000)\n\n// Plot HMA\nplot(hmaValue, title=\"HMA 50 Main\", color=hmaColor, linewidth=3)\n\n// Plot Supertrend\nplot(supertrend, title=\"Stop Loss Line\", color=direction == -1 ? color.new(color.green, 50) : color.new(color.red, 50), linewidth=1, style=plot.style_linebr)\n\n// Plot Visual Signals (à¹€à¸žà¸·à¹ˆà¸­à¹ƒà¸«à¹‰à¹€à¸«à¹‡à¸™à¸ˆà¸¸à¸”à¹€à¸‚à¹‰à¸²à¸šà¸™à¸à¸£à¸²à¸Ÿà¹€à¸«à¸¡à¸·à¸­à¸™à¹€à¸”à¸´à¸¡)\n// à¹ƒà¸Šà¹‰ logic state à¹€à¸žà¸·à¹ˆà¸­à¹„à¸¡à¹ˆà¹ƒà¸«à¹‰à¸£à¸\nvar int visualState = 0\nvisualBuy = isBullish and visualState != 1\nvisualSell = isBearish and visualState != -1\n\nif visualBuy\n    visualState := 1\nif visualSell\n    visualState := -1\nif isChoppy\n    visualState := 0\n\nplotshape(visualBuy, title=\"Long Visual\", location=location.belowbar, color=#00ff08, style=shape.cross, text=\"LONG\", textcolor=color.white, size=size.small)\nplotshape(visualSell, title=\"Short Visual\", location=location.abovebar, color=#ff0000, style=shape.xcross, text=\"SHORT\", textcolor=color.white, size=size.small)\n\n// Bar Color\nbarcolor(isBullish ? #00ff08 : isBearish ? #ff0000 : color.gray)"
  },
  {
    "url": "YNoXhKGV-ONLY-FOR-EUR-USD-EMA9-EMA20-RSI-MACD-Fibonacci-v6",
    "name": "ONLY FOR EUR/USD : EMA9/EMA20 + RSI + MACD + Fibonacci (v6) ",
    "description": "FOR PAIRS WHICH HAS A MOMENTUM , trade only using manually not algo , use proper RR. \ngood luck ",
    "image_url": "YNoXhKGV",
    "author": "Makbez",
    "likes": 7,
    "type": "strategy",
    "created": "2025-12-02",
    "updated": "2025-12-02",
    "source": "//@version=6\r\nstrategy(\"EMA9/EMA20 + RSI + MACD + Fibonacci (v6)\", overlay = true,\r\n     default_qty_type = strategy.percent_of_equity, default_qty_value = 1,\r\n     initial_capital = 10000, commission_type = strategy.commission.percent, commission_value = 0.0)\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Inputs\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nemaShortLen = input.int(9, \"EMA Short Length\")\r\nemaLongLen  = input.int(20, \"EMA Long Length\")\r\n\r\nrsiLen   = input.int(14, \"RSI Length\")\r\nrsiLower = input.int(40, \"RSI Buy Min\")\r\nrsiUpper = input.int(75, \"RSI Buy Max\")\r\n\r\nmacdFast = input.int(12, \"MACD Fast\")\r\nmacdSlow = input.int(26, \"MACD Slow\")\r\nmacdSig  = input.int(9,  \"MACD Signal\")\r\n\r\nfibLookback = input.int(50, \"Fibonacci Lookback\", minval = 5)\r\ntpExtension = input.float(1.618, \"TP Extension Multiplier\", minval = 1.0)\r\n\r\nuseATRbuffer   = input.bool(false, \"Use ATR for Stop Buffer?\")\r\natrLen         = input.int(14, \"ATR Length\")\r\natrMultiplier  = input.float(0.5, \"ATR Multiplier\")\r\nstopPctBuffer  = input.float(0.2, \"Stop Buffer % (if not ATR)\") / 100.0\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Indicator Calculations\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nemaShort = ta.ema(close, emaShortLen)\r\nemaLong  = ta.ema(close, emaLongLen)\r\n\r\nrsiVal = ta.rsi(close, rsiLen)\r\n\r\nmacdLine   = ta.ema(close, macdFast) - ta.ema(close, macdSlow)\r\nmacdSignal = ta.ema(macdLine, macdSig)\r\nmacdHist   = macdLine - macdSignal\r\n\r\nemaCrossUp   = ta.crossover(emaShort, emaLong)\r\nemaCrossDown = ta.crossunder(emaShort, emaLong)\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Fibonacci Levels\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nswingHigh = ta.highest(high, fibLookback)\r\nswingLow  = ta.lowest(low, fibLookback)\r\nrangeDiff = swingHigh - swingLow\r\n\r\nfib0   = swingHigh\r\nfib236 = swingHigh - 0.236 * rangeDiff\r\nfib382 = swingHigh - 0.382 * rangeDiff\r\nfib50  = swingHigh - 0.5   * rangeDiff\r\nfib618 = swingHigh - 0.618 * rangeDiff\r\nfib100 = swingLow\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Stop Buffer\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\natrVal = ta.atr(atrLen)\r\n\r\nbuyStopBuffer  = useATRbuffer ? atrVal * atrMultiplier : swingLow  * stopPctBuffer\r\nsellStopBuffer = useATRbuffer ? atrVal * atrMultiplier : swingHigh * stopPctBuffer\r\n\r\nbuyStop  = swingLow  - buyStopBuffer\r\nbuyTP    = swingHigh + rangeDiff * tpExtension\r\n\r\nsellStop = swingHigh + sellStopBuffer\r\nsellTP   = swingLow  - rangeDiff * tpExtension\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Entry Conditions\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nmacdBull = macdHist > 0 and macdLine > macdSignal\r\nmacdBear = macdHist < 0 and macdLine < macdSignal\r\n\r\nrsiBuyOk  = rsiVal >= rsiLower and rsiVal <= rsiUpper\r\nrsiSellOk = rsiVal >= (100 - rsiUpper) and rsiVal <= (100 - rsiLower)\r\n\r\nbuySignal  = emaCrossUp and macdBull and rsiBuyOk\r\nsellSignal = emaCrossDown and macdBear and rsiSellOk\r\n\r\nvalidBuy  = not na(buyStop)  and buyStop < close and buyTP > close\r\nvalidSell = not na(sellStop) and sellStop > close and sellTP < close\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Strategy Orders\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nlongID  = \"Long\"\r\nshortID = \"Short\"\r\n\r\n// Long Entry\r\nif buySignal and validBuy and strategy.position_size <= 0\r\n    strategy.entry(longID, strategy.long)\r\n    strategy.exit(id = \"Exit Long\", from_entry = longID, stop = buyStop, limit = buyTP)\r\n\r\n// Short Entry\r\nif sellSignal and validSell and strategy.position_size >= 0\r\n    strategy.entry(shortID, strategy.short)\r\n    strategy.exit(id = \"Exit Short\", from_entry = shortID, stop = sellStop, limit = sellTP)\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Plotting\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nplot(emaShort, \"EMA Short\", color = color.orange)\r\nplot(emaLong,  \"EMA Long\",  color = color.blue)\r\n\r\nplot(macdHist, \"MACD Histogram\", style = plot.style_columns, color = color.new(color.yellow, 60))\r\n\r\nplot(fib0,   \"Fib 0%\",   color = color.new(color.green, 70))\r\nplot(fib236, \"Fib 23.6%\", color = color.new(color.gray, 70))\r\nplot(fib382, \"Fib 38.2%\", color = color.new(color.gray, 60))\r\nplot(fib50,  \"Fib 50%\",  color = color.new(color.gray, 70))\r\nplot(fib618, \"Fib 61.8%\", color = color.new(color.gray, 60))\r\nplot(fib100, \"Fib 100%\", color = color.new(color.red, 70))\r\n\r\nplotshape(buySignal and validBuy,  title = \"Buy\",  style = shape.labelup,   color = color.green, text = \"BUY\")\r\nplotshape(sellSignal and validSell, title = \"Sell\", style = shape.labeldown, color = color.red,   text = \"SELL\")\r\n\r\n\r\n"
  },
  {
    "url": "a9bKiHqV",
    "name": "Supertrend Dual Strategy + Rising ADX",
    "description": "- supertrend dual strategy fast & slow\n- check ADX rising",
    "image_url": "a9bKiHqV",
    "author": "bugpigg",
    "likes": 16,
    "type": "strategy",
    "created": "2025-12-02",
    "updated": "2025-12-02",
    "source": "//@version=6\r\nstrategy(\"Supertrend Dual Strategy + Rising ADX (Fixed)\", overlay=true, process_orders_on_close=true)\r\n\r\n// --- 1. ìž…ë ¥ ë³€ìˆ˜ ì„¤ì • (ì¡°ì • ì œì•ˆ ë°˜ì˜) ---\r\n// [ë³€ê²½] Fast ATR 10 -> 12 (ì¡°ê¸ˆ ë” ì—¬ìœ ìžˆê²Œ)\r\natrPeriod1 = input.int(12, \"Fast ATR Length (Exit)\") \r\nfactor1 = input.float(3.0, \"Fast Factor\")\r\n\r\n// [ë³€ê²½] Slow Factor 4 -> 3.5 (ì¡°ê¸ˆ ë” ë¯¼ê°í•˜ê²Œ ì§„ìž…)\r\natrPeriod2 = input.int(14, \"Slow ATR Length (Entry)\")\r\nfactor2 = input.float(3.5, \"Slow Factor\")\r\n\r\n// ADX ì„¤ì •\r\nadxLen = input.int(14, \"ADX Smoothing\")\r\ndiLen = input.int(14, \"DI Length\")\r\nadxThreshold = input.int(20, \"ADX Threshold\")\r\n\r\n// --- 2. ì§€í‘œ ê³„ì‚° ---\r\n[stFast, dirFast] = ta.supertrend(factor1, atrPeriod1) \r\n[stSlow, dirSlow] = ta.supertrend(factor2, atrPeriod2) \r\n// dirSlow: -1ì´ë©´ ë¡±(ì´ˆë¡), 1ì´ë©´ ìˆ(ë¹¨ê°•)\r\n\r\n// ADX ê³„ì‚°\r\ndirmov(len) =>\r\n    up = ta.change(high)\r\n    down = -ta.change(low)\r\n    plusDM = na(up) ? na : (up > down and up > 0 ? up : 0)\r\n    minusDM = na(down) ? na : (down > up and down > 0 ? down : 0)\r\n    truerange = ta.rma(ta.tr, len)\r\n    plus = fixnan(100 * ta.rma(plusDM, len) / truerange)\r\n    minus = fixnan(100 * ta.rma(minusDM, len) / truerange)\r\n    [plus, minus]\r\n\r\n[plus, minus] = dirmov(diLen)\r\nsum = plus + minus\r\nadx = 100 * ta.rma(math.abs(plus - minus) / (sum == 0 ? 1 : sum), adxLen)\r\n\r\n// ADX ìƒìŠ¹ ì¡°ê±´\r\nadxRising = adx > adx[1]\r\n\r\n// --- 3. ë§¤ë§¤ ë¡œì§ (ê°œì„ ë¨) ---\r\n\r\n// [ì¤‘ìš”] 'êµì°¨(Crossover)'ê°€ ì•„ë‹ˆë¼ 'ìƒíƒœ(State)'ë¥¼ ì²´í¬í•©ë‹ˆë‹¤.\r\n// ì´ë¯¸ ìŠˆí¼íŠ¸ë Œë“œê°€ ë¡± ì¶”ì„¸ì¸ ìƒíƒœ(close > stSlow)ë¼ë„, \r\n// í˜„ìž¬ í¬ì§€ì…˜ì´ ì—†ê³ (strategy.position_size == 0), ADX ì¡°ê±´ì´ ë§žìœ¼ë©´ ì§„ìž…í•©ë‹ˆë‹¤.\r\n\r\n// Long ì§„ìž…: ê°€ê²©ì´ Slowì„  ìœ„ì— ìžˆê³  + ADXì¡°ê±´ ë§Œì¡± + í˜„ìž¬ í¬ì§€ì…˜ ì—†ìŒ\r\nlongCondition = (close > stSlow) and (close > stFast) and (strategy.position_size == 0)\r\n\r\n// Short ì§„ìž…: ê°€ê²©ì´ Slowì„  ì•„ëž˜ì— ìžˆê³  + ADXì¡°ê±´ ë§Œì¡± + í˜„ìž¬ í¬ì§€ì…˜ ì—†ìŒ\r\nshortCondition = (close < stSlow) and (close < stFast) and (strategy.position_size == 0)\r\n\r\n\r\n// ì²­ì‚° ì¡°ê±´: Fast ST ë°©í–¥ ì „í™˜ (ê¸°ì¡´ê³¼ ë™ì¼)\r\nexitLong = ta.crossunder(close, stFast) \r\nexitShort = ta.crossover(close, stFast) \r\n\r\n// --- 4. ì£¼ë¬¸ ì‹¤í–‰ ---\r\nif (longCondition)\r\n    strategy.entry(\"Long\", strategy.long)\r\n\r\nif (shortCondition)\r\n    strategy.entry(\"Short\", strategy.short)\r\n\r\nif (exitLong)\r\n    strategy.close(\"Long\", comment=\"Fast ST Exit\")\r\n\r\nif (exitShort)\r\n    strategy.close(\"Short\", comment=\"Fast ST Exit\")\r\n\r\n// --- 5. ì°¨íŠ¸ ì‹œê°í™” ---\r\nplot(stFast, color=color.new(color.blue, 0), title=\"Fast ST (Exit)\")\r\nplot(stSlow, color=color.new(color.gray, 0), linewidth=2, title=\"Slow ST (Entry)\")\r\nbgcolor((adx >= adxThreshold) ? color.new(color.green, 90) : na, title=\"Valid Entry Zone\")\r\n"
  },
  {
    "url": "MmZMBpNQ",
    "name": "MJ's trend follow strategy ",
    "description": "- 350, 23 MA line shoud be used.\n- trend follow strategy ",
    "image_url": "MmZMBpNQ",
    "author": "makedeltatv1",
    "likes": 6,
    "type": "strategy",
    "created": "2025-12-02",
    "updated": "2025-12-02",
    "source": "//@version=6\r\nstrategy(\"ChartStein 200/20 MA\", overlay=true, initial_capital=1000000, default_qty_type=strategy.percent_of_equity, default_qty_value=100, commission_type=strategy.commission.percent, commission_value=0.04, slippage=1)\r\n\r\n// ==========================================\r\n// 1. ì„¤ì • (Inputs)\r\n// ==========================================\r\nstartYear = input.int(2018, \"ì‹œìž‘ ì—°ë„\")\r\n\r\n// [Cornix] ì„¤ì •\r\ngrp_cornix = \"Cornix Settings\"\r\nleverage = input.int(1, \"ë ˆë²„ë¦¬ì§€\", minval=1, group=grp_cornix)\r\ncornix_sl_per = input.float(5.0, \"ì•ˆì „ìž¥ì¹˜ ì†ì ˆ (%)\", minval=0.1, group=grp_cornix) / 100\r\n\r\n// MA ì„¤ì •\r\ngrp_ma = \"MA Settings\"\r\nlen_trend = input.int(200, \"ëŒ€ì„¸ ì¶”ì„¸ì„  (ìž¥ê¸° MA)\", minval=50, maxval=500, step=10, group=grp_ma)\r\nlen_entry = input.int(20, \"ì§„ìž… ê¸°ì¤€ì„  (ë‹¨ê¸° MA)\", minval=5, maxval=500, step=5, group=grp_ma)\r\n\r\n// í•„í„°\r\ngrp_filter = \"Filter\"\r\nuse_slope_filter = input.bool(false, \"200ì¼ì„  ê¸°ìš¸ê¸° í•„í„°\", group=grp_filter)\r\n\r\n// [íœ©ì˜ ë°©ì§€ í•„í„°]\r\ngrp_whipsaw = \"Anti-Whipsaw\"\r\nuse_adx = input.bool(false, \"ADX í•„í„° ì‚¬ìš© (íš¡ë³´ìž¥ íšŒí”¼)\", group=grp_whipsaw)\r\nadx_limit = input.int(20, \"ADX ê¸°ì¤€ê°’ (20~25 ê¶Œìž¥)\", group=grp_whipsaw)\r\n\r\n// [ì‹œê°í™”] ì„¤ì •\r\ngrp_visual = \"Visuals\"\r\nshow_labels = input.bool(false, \"ì§„ìž… ë¼ë²¨ í‘œì‹œ\", group=grp_visual)\r\nshowPanel = input.bool(true, \"í†µê³„ íŒ¨ë„ í‘œì‹œ\", group=grp_visual)\r\n\r\n\r\n// ==========================================\r\n// 2. ì§€í‘œ ê³„ì‚°\r\n// ==========================================\r\nsma200 = ta.sma(close, len_trend)\r\nsma20 = ta.sma(close, len_entry)\r\nslope200 = sma200 - sma200[5]\r\n[_, _, adx] = ta.dmi(14, 14)\r\n\r\n\r\n// ==========================================\r\n// 3. Cornix ë©”ì‹œì§€ ìƒì„±\r\n// ==========================================\r\nsym = syminfo.ticker \r\nmsg_entry = \"LONG \" + sym + \"\\n\" + \"Leverage: \" + str.tostring(leverage) + \"x\\n\" + \"Entry: Market\\n\" + \"SL: \" + str.tostring(close * (1 - cornix_sl_per), \"#.##\")\r\nmsg_close = \"CLOSE \" + sym\r\n\r\n\r\n// ==========================================\r\n// 4. ì§„ìž…/ì²­ì‚° ë¡œì§\r\n// ==========================================\r\nvar int wins = 0\r\nvar int losses = 0\r\n\r\n// ì§„ìž… ì¡°ê±´\r\ncond_trend_up = (close > sma200) and (use_slope_filter ? slope200 > 0 : true)\r\ncond_breakout = ta.crossover(close, sma20)\r\ncond_adx_ok = use_adx ? (adx > adx_limit) : true\r\n\r\n// 200ì¼ì„  ê³¨ë“ í¬ë¡œìŠ¤ ì¡°ê±´ (20ì¼ì„  ë¬´ê´€, ë¬´ì¡°ê±´ ë§¤ìˆ˜)\r\ncond_golden_cross = ta.crossover(close, sma200)\r\n\r\nbuy_condition = cond_golden_cross or (cond_trend_up and cond_breakout and cond_adx_ok)\r\ninDateRange = time >= timestamp(syminfo.timezone, startYear, 1, 1, 0, 0)\r\n\r\n// ì§„ìž…\r\nif buy_condition and strategy.position_size == 0 and inDateRange\r\n    strategy.entry(\"ì§„ìž…\", strategy.long, alert_message=msg_entry)\r\n\r\n// ì²­ì‚°\r\nif strategy.position_size > 0\r\n    if ta.crossunder(close, sma20)\r\n        bool is_win = close > strategy.position_avg_price\r\n        if is_win\r\n            wins += 1\r\n        else\r\n            losses += 1\r\n        \r\n        string exit_text = is_win ? \"ìµì ˆ\" : \"ì†ì ˆ\"\r\n        string record = str.tostring(wins) + \"ìŠ¹ \" + str.tostring(losses) + \"íŒ¨\"\r\n        color label_color = is_win ? color.red : color.blue\r\n        \r\n        if show_labels\r\n            label.new(bar_index, high, text=exit_text + \"\\n\" + record, color=label_color, style=label.style_label_down, textcolor=color.white, size=size.small)\r\n        \r\n        strategy.close(\"ì§„ìž…\", comment=exit_text, alert_message=msg_close)\r\n    \r\n    strategy.exit(\"ìŠ¤íƒ‘ë¡œìŠ¤\", \"ì§„ìž…\", stop=strategy.position_avg_price * (1 - cornix_sl_per))\r\n\r\n\r\n// ==========================================\r\n// 5. ì‹œê°í™”\r\n// ==========================================\r\nplot(sma200, \"SMA 200\", color= color.rgb(26, 62, 190), linewidth=4, display=display.all)\r\nplot(sma20, \"SMA 20\", color=color.rgb(225, 40, 43), linewidth=3, display=display.all)\r\n\r\nif show_labels and buy_condition and strategy.position_size == 0 and inDateRange\r\n    label.new(bar_index, low, text=\"ì§„ìž…\", color=color.green, style=label.style_label_up, textcolor=color.white, size=size.small)\r\n\r\n\r\n// ==========================================\r\n// 6. í†µê³„ ê³„ì‚°\r\n// ==========================================\r\nvar float[] trade_returns = array.new_float(0)\r\nvar float[] daily_returns = array.new_float(0)\r\nvar float start_price = na\r\nvar float prev_day_equity = strategy.initial_capital\r\nvar int prev_day = 0\r\n\r\n// ê¸°ê°„ë³„ í†µê³„ ë³€ìˆ˜\r\n// í•˜ë½ìž¥ (2021.12 ~ 2023.01)\r\nvar float bear_start_equity = na\r\nvar float bear_end_equity = na\r\nvar float bear_peak_equity = na\r\nvar float bear_mdd = 0.0\r\n\r\n// ìƒìŠ¹ìž¥ (2023.02 ~ 2025.10)\r\nvar float bull_start_equity = na\r\nvar float bull_end_equity = na\r\nvar float bull_peak_equity = na\r\nvar float bull_mdd = 0.0\r\n\r\n// ìµœê·¼ ê¸°ê°„ ìˆ˜ìµë¥  ê³„ì‚°ìš©\r\nvar float eq_3m = na\r\nvar float eq_6m = na\r\nvar float eq_1y = na\r\n\r\n// ê¸°ê°„ ì •ì˜ (ë°€ë¦¬ì´ˆ)\r\nbear_start = timestamp(2021, 12, 1, 0, 0)\r\nbear_end = timestamp(2023, 1, 31, 23, 59)\r\nbull_start = timestamp(2023, 2, 1, 0, 0)\r\nbull_end = timestamp(2025, 10, 31, 23, 59)\r\n\r\n// í•˜ë½ìž¥ ê¸°ê°„ ì¶”ì \r\nif time >= bear_start and time <= bear_end\r\n    if na(bear_start_equity)\r\n        bear_start_equity := strategy.equity\r\n        bear_peak_equity := strategy.equity\r\n    bear_peak_equity := math.max(bear_peak_equity, strategy.equity)\r\n    float dd = (bear_peak_equity - strategy.equity) / bear_peak_equity * 100\r\n    bear_mdd := math.max(bear_mdd, dd)\r\n    bear_end_equity := strategy.equity\r\n\r\n// ìƒìŠ¹ìž¥ ê¸°ê°„ ì¶”ì \r\nif time >= bull_start and time <= bull_end\r\n    if na(bull_start_equity)\r\n        bull_start_equity := strategy.equity\r\n        bull_peak_equity := strategy.equity\r\n    bull_peak_equity := math.max(bull_peak_equity, strategy.equity)\r\n    float dd = (bull_peak_equity - strategy.equity) / bull_peak_equity * 100\r\n    bull_mdd := math.max(bull_mdd, dd)\r\n    bull_end_equity := strategy.equity\r\n\r\n// ìµœê·¼ 3ê°œì›”, 6ê°œì›”, 1ë…„ ì‹œì  equity ì €ìž¥\r\nms_per_day = 24 * 60 * 60 * 1000\r\ntarget_3m = timenow - 90 * ms_per_day\r\ntarget_6m = timenow - 180 * ms_per_day\r\ntarget_1y = timenow - 365 * ms_per_day\r\n\r\nif time <= target_3m\r\n    eq_3m := strategy.equity\r\nif time <= target_6m\r\n    eq_6m := strategy.equity\r\nif time <= target_1y\r\n    eq_1y := strategy.equity\r\n\r\n// ì‹œìž‘ ê°€ê²© ì €ìž¥ (Buy and Hold ê³„ì‚°ìš©)\r\nif na(start_price) and inDateRange\r\n    start_price := close\r\n\r\n// ê±°ëž˜ ì¢…ë£Œ ì‹œ ìˆ˜ìµë¥  ê¸°ë¡\r\nif strategy.closedtrades > strategy.closedtrades[1]\r\n    float exit_price = strategy.closedtrades.exit_price(strategy.closedtrades - 1)\r\n    float entry_price = strategy.closedtrades.entry_price(strategy.closedtrades - 1)\r\n    float trade_pct = entry_price != 0 ? (exit_price - entry_price) / entry_price * 100 : 0.0\r\n    array.push(trade_returns, trade_pct)\r\n\r\n// ì¼ê°„ ìˆ˜ìµë¥  ê¸°ë¡ (ë‚ ì§œê°€ ë°”ë€” ë•Œë§ˆë‹¤)\r\nint current_day = dayofmonth(time)\r\nif current_day != prev_day\r\n    if prev_day != 0 and prev_day_equity > 0\r\n        float daily_ret = (strategy.equity - prev_day_equity) / prev_day_equity\r\n        array.push(daily_returns, daily_ret)\r\n    prev_day_equity := strategy.equity\r\n    prev_day := current_day\r\n\r\n// í†µê³„ í•¨ìˆ˜\r\nf_avg(arr) =>\r\n    array.size(arr) > 0 ? array.avg(arr) : 0.0\r\n\r\nf_stdev(arr) =>\r\n    array.size(arr) > 1 ? array.stdev(arr) : 0.0\r\n\r\n// í•˜ë°© í‘œì¤€íŽ¸ì°¨ (ìŒìˆ˜ ìˆ˜ìµë¥ ë§Œ)\r\nf_downside_std(arr) =>\r\n    cnt = array.size(arr)\r\n    if cnt > 1\r\n        neg_arr = array.new_float(0)\r\n        for i = 0 to cnt - 1\r\n            val = array.get(arr, i)\r\n            if val < 0\r\n                array.push(neg_arr, val)\r\n        array.size(neg_arr) > 1 ? array.stdev(neg_arr) : 0.0\r\n    else\r\n        0.0\r\n\r\nf_skewness(arr, avg, std) =>\r\n    cnt = array.size(arr)\r\n    if cnt > 0 and std > 0.000001\r\n        sum_cube_diff = 0.0\r\n        for i = 0 to cnt - 1\r\n            diff = array.get(arr, i) - avg\r\n            sum_cube_diff += math.pow(diff, 3)\r\n        (sum_cube_diff / cnt) / math.pow(std, 3)\r\n    else\r\n        0.0\r\n\r\n// Sharpe Ratio (ì¼ê°„ ìˆ˜ìµë¥  ê¸°ë°˜, âˆš365 ì—°ìœ¨í™”)\r\nf_sharpe(arr) =>\r\n    cnt = array.size(arr)\r\n    if cnt > 1\r\n        avg_ret = array.avg(arr)\r\n        std_ret = array.stdev(arr)\r\n        std_ret > 0 ? (avg_ret / std_ret) * math.sqrt(365.0) : 0.0\r\n    else\r\n        0.0\r\n\r\n// Sortino Ratio (ì¼ê°„ ìˆ˜ìµë¥  ê¸°ë°˜, âˆš365 ì—°ìœ¨í™”)\r\nf_sortino(arr) =>\r\n    cnt = array.size(arr)\r\n    if cnt > 1\r\n        avg_ret = array.avg(arr)\r\n        down_std = f_downside_std(arr)\r\n        down_std > 0 ? (avg_ret / down_std) * math.sqrt(365.0) : 0.0\r\n    else\r\n        0.0\r\n\r\n\r\n// ==========================================\r\n// 7. í†µê³„ íŒ¨ë„ (4ì—´: ì§€í‘œ, ê°’, ê¸°ì¤€, O/X)\r\n// ==========================================\r\nvar table dash = na\r\nif showPanel and na(dash)\r\n    dash := table.new(position.top_right, columns=4, rows=20, border_width=1, border_color=color.new(color.gray, 0))\r\n\r\nif showPanel and not na(dash)\r\n    // í†µê³„ ê³„ì‚°\r\n    float mdd = strategy.max_drawdown_percent\r\n    float avg_trade = f_avg(trade_returns)\r\n    float std_trade = f_stdev(trade_returns)\r\n    float pf = strategy.grossloss != 0 ? strategy.grossprofit / strategy.grossloss : 0\r\n    \r\n    // Sharpe/Sortino (ì¼ê°„ ìˆ˜ìµë¥  ê¸°ë°˜)\r\n    float sharpe = f_sharpe(daily_returns)\r\n    float sortino = f_sortino(daily_returns)\r\n    \r\n    // ì™œë„ (ê±°ëž˜ë³„)\r\n    float skew = f_skewness(trade_returns, avg_trade, std_trade)\r\n    \r\n    // CAGR ê³„ì‚°\r\n    float total_days = (time - timestamp(startYear, 1, 1, 0, 0)) / (1000 * 60 * 60 * 24)\r\n    float total_years = total_days / 365.0\r\n    float total_return = strategy.equity / strategy.initial_capital\r\n    float cagr = (total_years > 0.1 and total_return > 0) ? (math.pow(total_return, 1.0 / total_years) - 1.0) * 100 : 0.0\r\n    \r\n    // Buy and Hold CAGR ê³„ì‚°\r\n    float bh_return = not na(start_price) and start_price > 0 ? close / start_price : 1.0\r\n    float bh_cagr = (total_years > 0.1 and bh_return > 0) ? (math.pow(bh_return, 1.0 / total_years) - 1.0) * 100 : 0.0\r\n    \r\n    // ì¹¼ë§ˆ (CAGR / MDD)\r\n    float calmar = mdd != 0 ? cagr / mdd : 0.0\r\n    \r\n    // ìŠ¹ë¥ \r\n    float winRate = (wins + losses) > 0 ? wins / (wins + losses) * 100.0 : 0.0\r\n\r\n    // ê¸°ì¤€ ì¶©ì¡± ì—¬ë¶€\r\n    bool winRate_ok = winRate >= 50\r\n    bool cagr_ok = cagr > bh_cagr  // Buy and Hold ëŒ€ë¹„\r\n    bool pf_ok = pf >= 1.5\r\n    bool calmar_ok = calmar >= 2   // ê¸°ì¤€ 2ë¡œ ë³€ê²½\r\n    bool mdd_ok = mdd < 30\r\n    bool sharpe_ok = sharpe >= 1\r\n    bool sortino_ok = sortino >= 2\r\n    bool skew_ok = skew > 2.5     // ê¸°ì¤€ 2.5ë¡œ ë³€ê²½\r\n    bool avg_ok = avg_trade >= 1.2 // ê¸°ì¤€ 1.2%ë¡œ ë³€ê²½\r\n\r\n    // í…Œì´ë¸” í´ë¦¬ì–´\r\n    table.clear(table_id=dash, start_row=0, start_column=0, end_row=19, end_column=3)\r\n    \r\n    // í—¤ë”\r\n    table.merge_cells(dash, 0, 0, 3, 0)\r\n    table.cell(table_id=dash, column=0, row=0, text=\"ChartStein Stats\", text_color=color.white, text_halign=text.align_center, bgcolor=color.new(color.blue, 35))\r\n    \r\n    // ë°°ê²½ìƒ‰ ì •ì˜\r\n    color bg1 = color.new(color.black, 20)\r\n    color bg2 = color.new(color.black, 35)\r\n    color c_value = color.new(color.white, 0)  // ê°’ ìƒ‰ìƒ (ë°ì€ í°ìƒ‰)\r\n    color c_label = color.new(color.white, 20) // ë¼ë²¨ ìƒ‰ìƒ\r\n    color c_std = color.new(color.silver, 0)   // ê¸°ì¤€ ìƒ‰ìƒ (ë°ì€ íšŒìƒ‰)\r\n    \r\n    // 1. ìŠ¹/íŒ¨\r\n    table.cell(table_id=dash, column=0, row=1, text=\"ìŠ¹/íŒ¨\", text_color=c_label, text_halign=text.align_left, bgcolor=bg1)\r\n    table.cell(table_id=dash, column=1, row=1, text=str.tostring(wins) + \"/\" + str.tostring(losses), text_color=c_value, text_halign=text.align_right, bgcolor=bg1)\r\n    table.cell(table_id=dash, column=2, row=1, text=\"-\", text_color=c_std, text_halign=text.align_center, bgcolor=bg1)\r\n    table.cell(table_id=dash, column=3, row=1, text=\"-\", text_color=c_std, text_halign=text.align_center, bgcolor=bg1)\r\n    \r\n    // 2. ìŠ¹ë¥ \r\n    table.cell(table_id=dash, column=0, row=2, text=\"ìŠ¹ë¥ \", text_color=c_label, text_halign=text.align_left, bgcolor=bg2)\r\n    table.cell(table_id=dash, column=1, row=2, text=str.tostring(winRate, \"#.#\") + \"%\", text_color=winRate_ok ? color.lime : color.yellow, text_halign=text.align_right, bgcolor=bg2)\r\n    table.cell(table_id=dash, column=2, row=2, text=\"â‰¥50%\", text_color=c_std, text_halign=text.align_center, bgcolor=bg2)\r\n    table.cell(table_id=dash, column=3, row=2, text=winRate_ok ? \"O\" : \"X\", text_color=winRate_ok ? color.lime : color.red, text_halign=text.align_center, bgcolor=bg2)\r\n    \r\n    // 3. CAGR (ê¸°ì¤€: Buy and Hold ëŒ€ë¹„)\r\n    table.cell(table_id=dash, column=0, row=3, text=\"CAGR\", text_color=c_label, text_halign=text.align_left, bgcolor=bg1)\r\n    table.cell(table_id=dash, column=1, row=3, text=str.tostring(cagr, \"#.##\") + \"%\", text_color=cagr_ok ? color.lime : color.yellow, text_halign=text.align_right, bgcolor=bg1)\r\n    table.cell(table_id=dash, column=2, row=3, text=\">\" + str.tostring(bh_cagr, \"#.#\") + \"%\", text_color=c_std, text_halign=text.align_center, bgcolor=bg1)\r\n    table.cell(table_id=dash, column=3, row=3, text=cagr_ok ? \"O\" : \"X\", text_color=cagr_ok ? color.lime : color.red, text_halign=text.align_center, bgcolor=bg1)\r\n    \r\n    // 4. Profit Factor\r\n    table.cell(table_id=dash, column=0, row=4, text=\"ìˆ˜ìµì§€ìˆ˜(PF)\", text_color=c_label, text_halign=text.align_left, bgcolor=bg2)\r\n    table.cell(table_id=dash, column=1, row=4, text=str.tostring(pf, \"#.##\"), text_color=pf_ok ? color.lime : color.yellow, text_halign=text.align_right, bgcolor=bg2)\r\n    table.cell(table_id=dash, column=2, row=4, text=\"â‰¥1.5\", text_color=c_std, text_halign=text.align_center, bgcolor=bg2)\r\n    table.cell(table_id=dash, column=3, row=4, text=pf_ok ? \"O\" : \"X\", text_color=pf_ok ? color.lime : color.red, text_halign=text.align_center, bgcolor=bg2)\r\n    \r\n    // 5. Calmar (ê¸°ì¤€: 2)\r\n    table.cell(table_id=dash, column=0, row=5, text=\"ì¹¼ë§ˆ\", text_color=c_label, text_halign=text.align_left, bgcolor=bg1)\r\n    table.cell(table_id=dash, column=1, row=5, text=str.tostring(calmar, \"#.##\"), text_color=calmar_ok ? color.lime : color.yellow, text_halign=text.align_right, bgcolor=bg1)\r\n    table.cell(table_id=dash, column=2, row=5, text=\"â‰¥2\", text_color=c_std, text_halign=text.align_center, bgcolor=bg1)\r\n    table.cell(table_id=dash, column=3, row=5, text=calmar_ok ? \"O\" : \"X\", text_color=calmar_ok ? color.lime : color.red, text_halign=text.align_center, bgcolor=bg1)\r\n    \r\n    // 6. MDD\r\n    table.cell(table_id=dash, column=0, row=6, text=\"MDD\", text_color=c_label, text_halign=text.align_left, bgcolor=bg2)\r\n    table.cell(table_id=dash, column=1, row=6, text=str.tostring(mdd, \"#.##\") + \"%\", text_color=mdd_ok ? color.lime : color.yellow, text_halign=text.align_right, bgcolor=bg2)\r\n    table.cell(table_id=dash, column=2, row=6, text=\"<30%\", text_color=c_std, text_halign=text.align_center, bgcolor=bg2)\r\n    table.cell(table_id=dash, column=3, row=6, text=mdd_ok ? \"O\" : \"X\", text_color=mdd_ok ? color.lime : color.red, text_halign=text.align_center, bgcolor=bg2)\r\n    \r\n    // 7. Sharpe\r\n    table.cell(table_id=dash, column=0, row=7, text=\"ìƒ¤í”„\", text_color=c_label, text_halign=text.align_left, bgcolor=bg1)\r\n    table.cell(table_id=dash, column=1, row=7, text=str.tostring(sharpe, \"#.##\"), text_color=sharpe_ok ? color.lime : color.yellow, text_halign=text.align_right, bgcolor=bg1)\r\n    table.cell(table_id=dash, column=2, row=7, text=\"â‰¥1\", text_color=c_std, text_halign=text.align_center, bgcolor=bg1)\r\n    table.cell(table_id=dash, column=3, row=7, text=sharpe_ok ? \"O\" : \"X\", text_color=sharpe_ok ? color.lime : color.red, text_halign=text.align_center, bgcolor=bg1)\r\n    \r\n    // 8. Sortino\r\n    table.cell(table_id=dash, column=0, row=8, text=\"ì†Œí‹°ë…¸\", text_color=c_label, text_halign=text.align_left, bgcolor=bg2)\r\n    table.cell(table_id=dash, column=1, row=8, text=str.tostring(sortino, \"#.##\"), text_color=sortino_ok ? color.lime : color.yellow, text_halign=text.align_right, bgcolor=bg2)\r\n    table.cell(table_id=dash, column=2, row=8, text=\"â‰¥2\", text_color=c_std, text_halign=text.align_center, bgcolor=bg2)\r\n    table.cell(table_id=dash, column=3, row=8, text=sortino_ok ? \"O\" : \"X\", text_color=sortino_ok ? color.lime : color.red, text_halign=text.align_center, bgcolor=bg2)\r\n    \r\n    // 9. Skewness (ê¸°ì¤€: 2.5)\r\n    table.cell(table_id=dash, column=0, row=9, text=\"ì™œë„\", text_color=c_label, text_halign=text.align_left, bgcolor=bg1)\r\n    table.cell(table_id=dash, column=1, row=9, text=str.tostring(skew, \"#.##\"), text_color=skew_ok ? color.lime : color.yellow, text_halign=text.align_right, bgcolor=bg1)\r\n    table.cell(table_id=dash, column=2, row=9, text=\">2.5\", text_color=c_std, text_halign=text.align_center, bgcolor=bg1)\r\n    table.cell(table_id=dash, column=3, row=9, text=skew_ok ? \"O\" : \"X\", text_color=skew_ok ? color.lime : color.red, text_halign=text.align_center, bgcolor=bg1)\r\n    \r\n    // 10. Avg Trade % (ê¸°ì¤€: 1.2%)\r\n    table.cell(table_id=dash, column=0, row=10, text=\"í‰ê· ê±°ëž˜%\", text_color=c_label, text_halign=text.align_left, bgcolor=bg2)\r\n    table.cell(table_id=dash, column=1, row=10, text=str.tostring(avg_trade, \"#.##\") + \"%\", text_color=avg_ok ? color.lime : color.yellow, text_halign=text.align_right, bgcolor=bg2)\r\n    table.cell(table_id=dash, column=2, row=10, text=\"â‰¥1.2%\", text_color=c_std, text_halign=text.align_center, bgcolor=bg2)\r\n    table.cell(table_id=dash, column=3, row=10, text=avg_ok ? \"O\" : \"X\", text_color=avg_ok ? color.lime : color.red, text_halign=text.align_center, bgcolor=bg2)\r\n\r\n    // ==========================================\r\n    // ê¸°ê°„ë³„ ì„±ê³¼ í…Œì´ë¸”\r\n    // ==========================================\r\n    \r\n    // ë¹ˆ í–‰ (êµ¬ë¶„ì„ )\r\n    table.cell(table_id=dash, column=0, row=11, text=\"\", bgcolor=color.new(color.black, 100))\r\n    table.cell(table_id=dash, column=1, row=11, text=\"\", bgcolor=color.new(color.black, 100))\r\n    table.cell(table_id=dash, column=2, row=11, text=\"\", bgcolor=color.new(color.black, 100))\r\n    table.cell(table_id=dash, column=3, row=11, text=\"\", bgcolor=color.new(color.black, 100))\r\n    \r\n    // ê¸°ê°„ë³„ í—¤ë”\r\n    table.merge_cells(dash, 0, 12, 3, 12)\r\n    table.cell(table_id=dash, column=0, row=12, text=\"ðŸ“Š ê¸°ê°„ë³„ ì„±ê³¼\", text_color=color.white, text_halign=text.align_center, bgcolor=color.new(color.purple, 35))\r\n    \r\n    // ì—´ í—¤ë”\r\n    table.cell(table_id=dash, column=0, row=13, text=\"ì§€í‘œ\", text_color=c_label, text_halign=text.align_center, bgcolor=bg1)\r\n    table.cell(table_id=dash, column=1, row=13, text=\"í•˜ë½ìž¥\\n21.12~23.01\", text_color=color.new(color.red, 0), text_halign=text.align_center, bgcolor=bg1)\r\n    table.cell(table_id=dash, column=2, row=13, text=\"ìƒìŠ¹ìž¥\\n23.02~25.10\", text_color=color.new(color.lime, 0), text_halign=text.align_center, bgcolor=bg1)\r\n    table.cell(table_id=dash, column=3, row=13, text=\"\", bgcolor=bg1)\r\n    \r\n    // ê¸°ê°„ë³„ CAGR ê³„ì‚°\r\n    float bear_years = (bear_end - bear_start) / (1000.0 * 60 * 60 * 24 * 365)\r\n    float bull_years = (bull_end - bull_start) / (1000.0 * 60 * 60 * 24 * 365)\r\n    \r\n    float bear_return = (not na(bear_start_equity) and bear_start_equity > 0) ? bear_end_equity / bear_start_equity : 1.0\r\n    float bull_return = (not na(bull_start_equity) and bull_start_equity > 0) ? bull_end_equity / bull_start_equity : 1.0\r\n    \r\n    float bear_cagr = (bear_years > 0.1 and bear_return > 0) ? (math.pow(bear_return, 1.0 / bear_years) - 1.0) * 100 : 0.0\r\n    float bull_cagr = (bull_years > 0.1 and bull_return > 0) ? (math.pow(bull_return, 1.0 / bull_years) - 1.0) * 100 : 0.0\r\n    \r\n    // CAGR í–‰\r\n    table.cell(table_id=dash, column=0, row=14, text=\"CAGR\", text_color=c_label, text_halign=text.align_left, bgcolor=bg2)\r\n    table.cell(table_id=dash, column=1, row=14, text=str.tostring(bear_cagr, \"#.##\") + \"%\", text_color=bear_cagr >= 0 ? color.lime : color.yellow, text_halign=text.align_center, bgcolor=bg2)\r\n    table.cell(table_id=dash, column=2, row=14, text=str.tostring(bull_cagr, \"#.##\") + \"%\", text_color=bull_cagr >= 0 ? color.lime : color.yellow, text_halign=text.align_center, bgcolor=bg2)\r\n    table.cell(table_id=dash, column=3, row=14, text=\"\", bgcolor=bg2)\r\n    \r\n    // MDD í–‰\r\n    table.cell(table_id=dash, column=0, row=15, text=\"MDD\", text_color=c_label, text_halign=text.align_left, bgcolor=bg1)\r\n    table.cell(table_id=dash, column=1, row=15, text=str.tostring(bear_mdd, \"#.##\") + \"%\", text_color=bear_mdd < 30 ? color.lime : color.yellow, text_halign=text.align_center, bgcolor=bg1)\r\n    table.cell(table_id=dash, column=2, row=15, text=str.tostring(bull_mdd, \"#.##\") + \"%\", text_color=bull_mdd < 30 ? color.lime : color.yellow, text_halign=text.align_center, bgcolor=bg1)\r\n    table.cell(table_id=dash, column=3, row=15, text=\"\", bgcolor=bg1)\r\n\r\n    // ==========================================\r\n    // ìµœê·¼ ê¸°ê°„ë³„ ìˆ˜ìµë¥ \r\n    // ==========================================\r\n    \r\n    // ë¹ˆ í–‰ (êµ¬ë¶„ì„ )\r\n    table.cell(table_id=dash, column=0, row=16, text=\"\", bgcolor=color.new(color.black, 100))\r\n    table.cell(table_id=dash, column=1, row=16, text=\"\", bgcolor=color.new(color.black, 100))\r\n    table.cell(table_id=dash, column=2, row=16, text=\"\", bgcolor=color.new(color.black, 100))\r\n    table.cell(table_id=dash, column=3, row=16, text=\"\", bgcolor=color.new(color.black, 100))\r\n    \r\n    // ìµœê·¼ ìˆ˜ìµ í—¤ë”\r\n    table.merge_cells(dash, 0, 17, 3, 17)\r\n    table.cell(table_id=dash, column=0, row=17, text=\"ðŸ“ˆ ìµœê·¼ ìˆ˜ìµë¥ \", text_color=color.white, text_halign=text.align_center, bgcolor=color.new(color.teal, 35))\r\n    \r\n    // ì—´ í—¤ë”\r\n    table.cell(table_id=dash, column=0, row=18, text=\"\", bgcolor=bg1)\r\n    table.cell(table_id=dash, column=1, row=18, text=\"3ê°œì›”\", text_color=c_label, text_halign=text.align_center, bgcolor=bg1)\r\n    table.cell(table_id=dash, column=2, row=18, text=\"6ê°œì›”\", text_color=c_label, text_halign=text.align_center, bgcolor=bg1)\r\n    table.cell(table_id=dash, column=3, row=18, text=\"1ë…„\", text_color=c_label, text_halign=text.align_center, bgcolor=bg1)\r\n    \r\n    // ìˆ˜ìµë¥  ê³„ì‚°\r\n    float curr_eq = strategy.equity\r\n    float ret_3m = (not na(eq_3m) and eq_3m > 0) ? (curr_eq - eq_3m) / eq_3m * 100 : na\r\n    float ret_6m = (not na(eq_6m) and eq_6m > 0) ? (curr_eq - eq_6m) / eq_6m * 100 : na\r\n    float ret_1y = (not na(eq_1y) and eq_1y > 0) ? (curr_eq - eq_1y) / eq_1y * 100 : na\r\n    \r\n    // ìˆ˜ìµë¥  í–‰\r\n    table.cell(table_id=dash, column=0, row=19, text=\"ìˆ˜ìµë¥ \", text_color=c_label, text_halign=text.align_left, bgcolor=bg2)\r\n    table.cell(table_id=dash, column=1, row=19, text=na(ret_3m) ? \"-\" : str.tostring(ret_3m, \"#.##\") + \"%\", text_color=na(ret_3m) ? color.gray : (ret_3m >= 0 ? color.lime : color.red), text_halign=text.align_center, bgcolor=bg2)\r\n    table.cell(table_id=dash, column=2, row=19, text=na(ret_6m) ? \"-\" : str.tostring(ret_6m, \"#.##\") + \"%\", text_color=na(ret_6m) ? color.gray : (ret_6m >= 0 ? color.lime : color.red), text_halign=text.align_center, bgcolor=bg2)\r\n    table.cell(table_id=dash, column=3, row=19, text=na(ret_1y) ? \"-\" : str.tostring(ret_1y, \"#.##\") + \"%\", text_color=na(ret_1y) ? color.gray : (ret_1y >= 0 ? color.lime : color.red), text_halign=text.align_center, bgcolor=bg2)"
  },
  {
    "url": "GGevsliQ-QQQ-Quant-Power-STRATEGY-v13-3-Ribbon-TQQQ-Specs",
    "name": "QQQ Quant Power STRATEGY v13.3 (Ribbon + TQQQ Specs)",
    "description": "1. The Quant Engine (Data Processing)\n \nWeighted Scoring: It assigns specific weights to stocks (e.g., NVDA gets 8.5% weight, TXN gets 1.0%).\nZ-Score Pressure: It calculates how \"unusual\" the current buying/selling pressure is compared to the average (Standard Deviation).\nAlignment Bonus: It boosts the \"Conviction Score\" if Mega Caps (Top 8) and Large Caps (Next 12) are moving in the same direction.\n2. The Dashboard (Mission Control)\nThe dashboard gives you an X-Ray view of the market:\n\n Main Status: Tells you if the market is BULLISH, BEARISH, or CHOP (Sit Out).\n Conviction %: A probability score (0-99%). Higher = Safer trade.\nBreadth: Counts how many of the top 20 stocks are above their EMA.\nChop Logic: If Breadth is mixed (between 6 and 14 stocks above EMA), it declares \"CHOP\" and blocks trades.\nMega/Large Net: Shows the net buying/selling pressure for each group.\n\n 3. Visuals\n Pressure Line: The line on the chart isn't just a Moving Average; it's the Net Pressure of the 20 stocks pushing price up or down.\nConviction Ribbon: The squares at the bottom of the screen.\nðŸŸ© Green: High Probability Long (>77%).\nðŸŸ¥ Red: High Probability Short (>77%).\nâ¬œ Gray: Low Conviction / Holding.\n\n 4. Strategy Logic (Automated Trading)\n\n Entry: Enters when the \"Basket\" of stocks is aligned (Bull/Bear Pressure) AND the Conviction Score is high (>77%).\nExit: Closes the trade if Conviction drops (Signal fades) or hits a Hard Stop Loss.\nTime Filters: Includes strict trading windows (e.g., No trading during lunch 12-1pm, closes all positions on Friday).\n Summary\n This is a Market Breadth & Momentum Strategy. It assumes that QQQ cannot sustain a trend unless its underlying components (NVDA, AAPL, etc.) are pushing it. It filters out \"fake moves\" where QQQ moves but the components don't support it.",
    "image_url": "GGevsliQ",
    "author": "CustomQuantLabs",
    "likes": 37,
    "type": "strategy",
    "created": "2025-12-02",
    "updated": "2025-12-02",
    "source": "//@version=5\r\nstrategy(\"QQQ Quant Power STRATEGY v13.3 (Ribbon + TQQQ Specs)\", overlay=true, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=100)\r\n\r\n// ==========================================\r\n// âš™ï¸ SETTINGS\r\n// ==========================================\r\nvar grp_disp = \"Display Settings\"\r\nscaler      = input.float(2.0, \"Cloud Scaler\", minval=0.1, step=0.1, group=grp_disp)\r\ndash_size_input = input.string(\"Small\", \"Dashboard Size\", options=[\"Tiny\", \"Small\", \"Normal\", \"Large\"], group=grp_disp)\r\nshow_dash   = input.bool(true, \"Show Dashboard\", group=grp_disp)\r\nsensitivity = 0.5 \r\n\r\nvar grp_data = \"Data Engine Settings (QQQ)\"\r\n// EMA 23 (Smoother Trend per request)\r\nema_len     = input.int(23, \"EMA Trend Length\", minval=5, group=grp_data)\r\n\r\n// --- STRATEGY INPUTS ---\r\nvar grp_strat = \"Strategy Logic\"\r\nentry_th    = input.int(77, \"Entry Confidence %\", minval=50, maxval=99, group=grp_strat) \r\nexit_th     = input.int(28, \"Exit/Hold Confidence %\", minval=10, maxval=80, group=grp_strat) \r\n\r\n// --- RISK MANAGEMENT ---\r\nvar grp_risk = \"Leveraged Risk Management\"\r\nuse_sl      = input.bool(true, \"Use Hard Stop Loss?\", group=grp_risk)\r\nsl_pct      = input.float(3.5, \"Stop Loss %\", step=0.1, group=grp_risk)\r\n\r\n// --- TIME FILTERS ---\r\nvar grp_time = \"Time Management (EST)\"\r\nstart_hour   = input.int(10, \"Start Hour\", group=grp_time)\r\nstart_min    = input.int(30, \"Start Minute\", group=grp_time)\r\nlunch_start  = input.int(12, \"Lunch Start Hour\", group=grp_time)\r\nlunch_end    = input.int(13, \"Lunch End Hour\", group=grp_time)\r\nend_hour     = input.int(15, \"Stop Entries Hour\", group=grp_time)\r\nend_min      = input.int(45, \"Stop Entries Minute\", group=grp_time)\r\nfriday_close = input.bool(true, \"Close All on Friday?\", group=grp_time)\r\n\r\n\r\n// ==========================================\r\n// ðŸ§¬ DATA STRUCTURES & LOGIC\r\n// ==========================================\r\n\r\ntype TickerData\r\n    float pct_change\r\n    float score\r\n    bool  is_above_ema\r\n    int   ema_slope \r\n\r\nget_txt_size(s) =>\r\n    switch s\r\n        \"Tiny\"   => size.tiny\r\n        \"Small\"  => size.small\r\n        \"Normal\" => size.normal\r\n        \"Large\"  => size.large\r\n        => size.small\r\n\r\ndash_size = get_txt_size(dash_size_input)\r\n\r\nget_full_data(sym, wgt) =>\r\n    [c, c_prev, ema, ema_prev] = request.security(sym, timeframe.period, [close, close[1], ta.ema(close, ema_len), ta.ema(close, ema_len)[1]], ignore_invalid_symbol=true)\r\n    pct = c_prev != 0 ? (c - c_prev) / c_prev : 0\r\n    scr = pct * wgt * 10000\r\n    above = c > ema\r\n    slope = ema > ema_prev ? 1 : (ema < ema_prev ? -1 : 0)\r\n    TickerData.new(pct, scr, above, slope)\r\n\r\n// ==========================================\r\n// ðŸ“¡ DATA FETCHING\r\n// ==========================================\r\n\r\nd01 = get_full_data(\"NVDA\", 0.085), d02 = get_full_data(\"AAPL\", 0.085)\r\nd03 = get_full_data(\"MSFT\", 0.082), d04 = get_full_data(\"AMZN\", 0.055)\r\nd05 = get_full_data(\"META\", 0.045), d06 = get_full_data(\"GOOGL\", 0.045)\r\nd07 = get_full_data(\"AVGO\", 0.042), d08 = get_full_data(\"TSLA\", 0.035)\r\n\r\nd09 = get_full_data(\"COST\", 0.025), d10 = get_full_data(\"NFLX\", 0.022)\r\nd11 = get_full_data(\"PEP\", 0.018),  d12 = get_full_data(\"ADBE\", 0.018)\r\nd13 = get_full_data(\"LIN\", 0.015),  d14 = get_full_data(\"AMD\", 0.015)\r\nd15 = get_full_data(\"TMUS\", 0.015), d16 = get_full_data(\"CSCO\", 0.012)\r\nd17 = get_full_data(\"QCOM\", 0.012), d18 = get_full_data(\"INTU\", 0.012)\r\nd19 = get_full_data(\"AMGN\", 0.012), d20 = get_full_data(\"TXN\", 0.010)\r\n\r\nget_score(TickerData d) => d.score\r\nmega_total = get_score(d01)+get_score(d02)+get_score(d03)+get_score(d04)+get_score(d05)+get_score(d06)+get_score(d07)+get_score(d08)\r\nlarge_total = get_score(d09)+get_score(d10)+get_score(d11)+get_score(d12)+get_score(d13)+get_score(d14)+get_score(d15)+get_score(d16)+get_score(d17)+get_score(d18)+get_score(d19)+get_score(d20)\r\ngrand_total = mega_total + large_total\r\n\r\ncount_above(TickerData d) => d.is_above_ema ? 1 : 0\r\ntotal_above_ema = count_above(d01)+count_above(d02)+count_above(d03)+count_above(d04)+count_above(d05)+count_above(d06)+count_above(d07)+count_above(d08)+count_above(d09)+count_above(d10)+count_above(d11)+count_above(d12)+count_above(d13)+count_above(d14)+count_above(d15)+count_above(d16)+count_above(d17)+count_above(d18)+count_above(d19)+count_above(d20)\r\ntotal_below_ema = 20 - total_above_ema\r\n\r\n// --- QUANT ENGINE ---\r\nlength_z = 50\r\nmean_score = ta.sma(grand_total, length_z)\r\nstd_score = ta.stdev(grand_total, length_z)\r\nz_score_pressure = std_score != 0 ? (grand_total - mean_score) / std_score : 0\r\n\r\nbase_prob = math.min(math.abs(grand_total) * 4, 50)\r\nalign_bonus = (mega_total > 0 and large_total > 0) or (mega_total < 0 and large_total < 0) ? 10 : 0\r\nz_bonus = math.min(math.abs(z_score_pressure) * 10, 15)\r\n\r\nbreadth_bonus = 0.0\r\nif total_above_ema >= 15 or total_below_ema >= 15\r\n    breadth_bonus := 24\r\nelse if total_above_ema >= 13 or total_below_ema >= 13\r\n    breadth_bonus := 10\r\n\r\ntotal_prob = math.min(base_prob + align_bonus + z_bonus + breadth_bonus, 99)\r\n\r\n// --- FILTERS ---\r\nis_chop = total_above_ema >= 6 and total_above_ema <= 14\r\n\r\nt = time(timeframe.period, \"0930-1600:1234567\") \r\nh = hour(time)\r\nm = minute(time)\r\nis_after_start = (h > start_hour) or (h == start_hour and m >= start_min)\r\nis_lunch = (h == lunch_start) // 12:00-12:59\r\nis_before_end = (h < end_hour) or (h == end_hour and m <= end_min)\r\nis_friday = dayofweek == dayofweek.friday\r\nis_market_closing = is_friday and (h > 15 or (h == 15 and m >= 45))\r\ncan_trade = is_after_start and not is_lunch and is_before_end and not (friday_close and is_market_closing)\r\n\r\nbgcolor(not can_trade ? color.new(color.blue, 95) : na, title=\"No Trade Time\")\r\nbgcolor(is_chop ? color.new(color.gray, 90) : na, title=\"Chop Zone\")\r\n\r\n// ==========================================\r\n// ðŸŽ—ï¸ VISUAL: CONVICTION RIBBON\r\n// ==========================================\r\n// Green = High Conviction (>77)\r\n// Red = Low Conviction (<28)\r\n// Gray = Holding / Neutral\r\n\r\nribbon_color = total_prob >= entry_th ? color.new(#00E676, 10) : (total_prob <= exit_th ? color.new(#FF5252, 10) : color.new(color.gray, 60))\r\n\r\nplotshape(true, title=\"Conviction Ribbon\", style=shape.square, location=location.bottom, color=ribbon_color, size=size.auto)\r\n\r\n// ==========================================\r\n// ðŸš€ STRATEGY EXECUTION\r\n// ==========================================\r\nbool bull_pressure = grand_total > 0\r\nbool bear_pressure = grand_total < 0\r\n\r\n// LONG\r\nif can_trade and not is_chop and bull_pressure and total_prob >= entry_th\r\n    strategy.entry(\"Long\", strategy.long, comment=\"Quant L\")\r\n\r\nif strategy.position_size > 0\r\n    if total_prob <= exit_th\r\n        strategy.close(\"Long\", comment=\"L-Convict Lost\")\r\n    if use_sl\r\n        strategy.exit(\"SL\", \"Long\", stop=strategy.position_avg_price * (1 - sl_pct/100))\r\n    if is_market_closing and friday_close\r\n        strategy.close(\"Long\", comment=\"Weekend Close\")\r\n\r\n// SHORT\r\nif can_trade and not is_chop and bear_pressure and total_prob >= entry_th\r\n    strategy.entry(\"Short\", strategy.short, comment=\"Quant S\")\r\n\r\nif strategy.position_size < 0\r\n    if total_prob <= exit_th\r\n        strategy.close(\"Short\", comment=\"S-Convict Lost\")\r\n    if use_sl\r\n        strategy.exit(\"SL\", \"Short\", stop=strategy.position_avg_price * (1 + sl_pct/100))\r\n    if is_market_closing and friday_close\r\n        strategy.close(\"Short\", comment=\"Weekend Close\")\r\n\r\n\r\n// ==========================================\r\n// ðŸ“‰ VISUAL LINE & DASHBOARD\r\n// ==========================================\r\nanchor = ta.ema(close, 20)\r\nvisual_line = anchor + (grand_total * (scaler/100) )\r\nplot(visual_line, \"Pressure Line\", color=grand_total > 0 ? #00E676 : #FF5252, linewidth=1)\r\nfill(plot(visual_line), plot(anchor), color=grand_total > 0 ? color.new(#00E676, 85) : color.new(#FF5252, 85))\r\n\r\n// DASHBOARD LOGIC\r\nvar tbl = table.new(position.top_right, 4, 32, bgcolor=color.new(color.black, 40), border_color=color.new(color.gray, 80), border_width=1)\r\n\r\nstatus_txt = \"NEUTRAL\"\r\nstatus_col = color.gray\r\nmain_dir_txt = grand_total > 0 ? \"BULLISH\" : \"BEARISH\"\r\nmain_dir_col = grand_total > 0 ? #00E676 : #FF5252\r\n\r\nif is_chop\r\n    main_dir_txt := \"CHOP\"\r\n    main_dir_col := #808080 \r\n    status_txt   := \"SIT OUT\"\r\n    status_col   := #808080\r\nelse\r\n    if total_prob > 80\r\n        status_txt := \"EXTREME\"\r\n        status_col := color.white\r\n    else if total_prob > 60\r\n        status_txt := \"STRONG\"\r\n        status_col := color.yellow\r\n    else if total_prob > 40\r\n        status_txt := \"MODERATE\"\r\n        status_col := color.orange\r\n    else\r\n        status_txt := \"WEAK\"\r\n\r\ndraw_entry(tbl_id, r, sym, TickerData d, txt_size, sensit) =>\r\n    disp_score = math.round(d.score, 1)\r\n    c_bg = d.score > sensit ? color.new(#00E676, 30) : (d.score < -sensit ? color.new(#FF5252, 30) : color.new(color.gray, 90))\r\n    c_txt = d.score > 0 ? #00E676 : (d.score < 0 ? #FF5252 : color.gray)\r\n    arrow_sym = d.ema_slope == 1 ? \"â†—\" : (d.ema_slope == -1 ? \"â†˜\" : \"âž¡\")\r\n    arrow_col = d.is_above_ema ? #00E676 : #FF5252\r\n    table.cell(tbl_id, 0, r, sym, text_color=color.white, text_size=txt_size, bgcolor=c_bg)\r\n    table.cell(tbl_id, 1, r, str.tostring(d.pct_change * 100, format.percent), text_color=c_txt, text_size=txt_size, bgcolor=color.new(color.black, 100))\r\n    table.cell(tbl_id, 2, r, arrow_sym, text_color=arrow_col, text_size=txt_size, bgcolor=color.new(color.black, 50)) \r\n    table.cell(tbl_id, 3, r, str.tostring(disp_score), text_color=color.white, text_size=txt_size, bgcolor=c_bg)\r\n\r\nif barstate.islast and show_dash\r\n    table.cell(tbl, 0, 0, main_dir_txt, text_color=color.white, text_size=dash_size, bgcolor=main_dir_col)\r\n    table.merge_cells(tbl, 0, 0, 2, 0)\r\n    table.cell(tbl, 3, 0, str.tostring(math.round(total_prob)) + \"%\", text_color=color.white, text_size=dash_size, bgcolor=main_dir_col)\r\n    \r\n    table.cell(tbl, 0, 1, \"CONVICTION:\", text_color=color.gray, text_size=dash_size, bgcolor=color.black)\r\n    table.merge_cells(tbl, 0, 1, 2, 1)\r\n    table.cell(tbl, 3, 1, status_txt, text_color=status_col, text_size=dash_size, bgcolor=color.black)\r\n\r\n    // Breadth\r\n    breadth_bg = is_chop ? color.gray : (total_above_ema > total_below_ema ? color.new(#00E676, 40) : color.new(#FF5252, 40))\r\n    table.cell(tbl, 0, 2, \"EMA \" + str.tostring(ema_len) + \" BREADTH\", text_color=color.white, text_size=dash_size, bgcolor=breadth_bg)\r\n    table.merge_cells(tbl, 0, 2, 1, 2)\r\n    table.cell(tbl, 2, 2, \"Abv:\" + str.tostring(total_above_ema), text_color=#00E676, text_size=dash_size, bgcolor=color.black)\r\n    table.cell(tbl, 3, 2, \"Blw:\" + str.tostring(total_below_ema), text_color=#FF5252, text_size=dash_size, bgcolor=color.black)\r\n\r\n    table.cell(tbl, 0, 3, \"MEGA CAPS\", text_color=color.yellow, text_size=dash_size, bgcolor=color.black, text_halign=text.align_left)\r\n    table.cell(tbl, 1, 3, \"%\", text_color=color.gray, text_size=dash_size, bgcolor=color.black)\r\n    table.cell(tbl, 2, 3, \"EMA\", text_color=color.gray, text_size=dash_size, bgcolor=color.black)\r\n    table.cell(tbl, 3, 3, \"SCR\", text_color=color.gray, text_size=dash_size, bgcolor=color.black)\r\n\r\n    // Tickers\r\n    draw_entry(tbl, 4, \"NVDA\", d01, dash_size, sensitivity), draw_entry(tbl, 5, \"AAPL\", d02, dash_size, sensitivity)\r\n    draw_entry(tbl, 6, \"MSFT\", d03, dash_size, sensitivity), draw_entry(tbl, 7, \"AMZN\", d04, dash_size, sensitivity)\r\n    draw_entry(tbl, 8, \"META\", d05, dash_size, sensitivity), draw_entry(tbl, 9, \"GOOGL\", d06, dash_size, sensitivity)\r\n    draw_entry(tbl, 10, \"AVGO\", d07, dash_size, sensitivity), draw_entry(tbl, 11, \"TSLA\", d08, dash_size, sensitivity)\r\n\r\n    c_mega = mega_total > 0 ? color.new(color.blue, 60) : color.new(#FF5252, 60)\r\n    table.cell(tbl, 0, 12, \"MEGA NET\", text_color=color.white, text_size=dash_size, bgcolor=c_mega)\r\n    table.merge_cells(tbl, 0, 12, 2, 12)\r\n    table.cell(tbl, 3, 12, str.tostring(mega_total, \"#.0\"), text_color=color.white, text_size=dash_size, bgcolor=c_mega)\r\n\r\n    table.cell(tbl, 0, 13, \"LARGE CAPS\", text_color=color.orange, text_size=dash_size, bgcolor=color.black, text_halign=text.align_left)\r\n    table.cell(tbl, 3, 13, \"---\", text_color=color.gray, text_size=dash_size, bgcolor=color.black)\r\n\r\n    draw_entry(tbl, 14, \"COST\", d09, dash_size, sensitivity), draw_entry(tbl, 15, \"NFLX\", d10, dash_size, sensitivity)\r\n    draw_entry(tbl, 16, \"PEP\", d11, dash_size, sensitivity),  draw_entry(tbl, 17, \"ADBE\", d12, dash_size, sensitivity)\r\n    draw_entry(tbl, 18, \"LIN\", d13, dash_size, sensitivity),  draw_entry(tbl, 19, \"AMD\", d14, dash_size, sensitivity)\r\n    draw_entry(tbl, 20, \"TMUS\", d15, dash_size, sensitivity), draw_entry(tbl, 21, \"CSCO\", d16, dash_size, sensitivity)\r\n    draw_entry(tbl, 22, \"QCOM\", d17, dash_size, sensitivity), draw_entry(tbl, 23, \"INTU\", d18, dash_size, sensitivity)\r\n    draw_entry(tbl, 24, \"AMGN\", d19, dash_size, sensitivity), draw_entry(tbl, 25, \"TXN\", d20, dash_size, sensitivity)\r\n\r\n    c_large = large_total > 0 ? color.new(color.blue, 60) : color.new(#FF5252, 60)\r\n    table.cell(tbl, 0, 26, \"LARGE NET\", text_color=color.white, text_size=dash_size, bgcolor=c_large)\r\n    table.merge_cells(tbl, 0, 26, 2, 26)\r\n    table.cell(tbl, 3, 26, str.tostring(large_total, \"#.0\"), text_color=color.white, text_size=dash_size, bgcolor=c_large)\r\n\r\n    c_grand = grand_total > 0 ? color.new(color.blue, 30) : color.new(#FF5252, 30)\r\n    table.cell(tbl, 0, 27, \"NET Z-PRESS\", text_color=color.white, text_size=dash_size, bgcolor=c_grand)\r\n    table.merge_cells(tbl, 0, 27, 2, 27)\r\n    table.cell(tbl, 3, 27, str.tostring(grand_total, \"#.0\"), text_color=color.white, text_size=dash_size, bgcolor=c_grand)"
  },
  {
    "url": "WXXcgwAQ-Volume-Momentum-Strategy-MA-VWAP-Cross",
    "name": "Volume Momentum Strategy [MA/VWAP Cross]",
    "description": "Deconstructing the Volume Momentum Strategy: An Analysis of MA-VWAP Cross Mechanics\nIntroduction\n\nThe \"Volume Momentum Strategy  \" is a technical trading algorithm programmed in Pine Script v6 for the TradingView platform. At its core, the strategy is a trend-following system that utilizes the interaction between a specific Moving Average (MA) and the Volume Weighted Average Price (VWAP) to generate trade signals. While the primary execution logic relies on price crossovers, the strategy incorporates a sophisticated secondary layer of analysis using the Commodity Channel Index (CCI) and Stochastic Oscillator. Uniquely, these secondary indicators are applied to volume data rather than price, serving as a gauge for market participation and momentum intensity.\n\nThe Core Engine: MA and VWAP Crossover\nThe primary engine driving the strategy's buy and sell decisions is the crossover relationship between a user-defined Moving Average and the VWAP.\n1.\tThe Anchor (VWAP): The strategy calculates the Volume Weighted Average Price based on the HLC3 (High, Low, Close divided by 3) source. VWAP serves as the dynamic benchmark for \"fair value\" throughout the trading session.\n2.\tThe Trigger (Moving Average): The script allows for flexibility in defining the \"fast\" line, offering options such as Simple (SMA), Exponential (EMA), or Hull Moving Averages.\n3.\tThe Signal:\no\tA Long (Buy) signal is generated when the chosen MA crosses over the VWAP. This suggests that short-term price momentum is exceeding the average volume-weighted price of the session, indicating bullish sentiment.\no\tA Short (Sell) signal is generated when the MA crosses under the VWAP, indicating bearish pressure where price is being pushed below the session's volume-weighted average.\n\nThe Role of CCI and Stochastic: Analyzing Volume Momentum\nThe prompt specifically inquires about how the CCI and Stochastic indicators fit into this process. In standard technical analysis, these oscillators are used to identify overbought or oversold price conditions. However, this strategy repurposes them to analyze Volume Momentum.\n\n1. The Calculation\nInstead of using close prices as the input source, the script passes volume data into both indicator functions:\nâ€¢\tVolume CCI: Calculated as ta.cci(volume, cciLength). This measures the deviation of current volume from its statistical average.\nâ€¢\tVolume Stochastic: Calculated as ta.stoch(volume, volume, volume, stochLength). This gauges the current volume relative to its recent range.\n2. The \"Volume Spike\" Condition\nThe strategy combines these two indicators to define a specific market condition labeled isVolumeSpike. A volume spike is confirmed only when both conditions are met simultaneously:\nâ€¢\tThe Volume CCI must be greater than a defined threshold (default: 100).\nâ€¢\tThe Volume Stochastic must be greater than a defined threshold (default: 80).\n\n3. Integration into the Process\nIt is critical to note how this script currently applies this \"Volume Spike\" logic:\nâ€¢\tVisual Confirmation: In the current version of the code, the isVolumeSpike boolean is used strictly for visual feedback. When a spike is detected, the script paints the specific price bar yellow and plots a small triangle marker below the bar.\nâ€¢\tStrategic Implication: While the code calculates these metrics, the variables long_condition and short_condition currently rely solely on the MA/VWAP crossover. The developer has left the volume logic as a visual overlay, noting in the comments that it serves as a \"visual/alert\" or a potential filter.\nâ€¢\tPotential Alpha: Conceptually, this setup implies that a trader should look for the MA/VWAP crossover to occur coincidentally withâ€”or shortly afterâ€”a \"Volume Spike\" (yellow bar). This would confirm that the price move is backed by significant institutional participation (volume) rather than just retail noise.\n\nRisk Management and Time Constraints\nThe strategy wraps these technical signals in a robust risk management framework. It includes hard-coded time windows (start/stop trading times) and a \"Close All\" function to prevent holding positions overnight. Furthermore, it employs both percentage-based and dollar-based Stop Loss and Take Profit mechanisms, ensuring that every entryâ€”whether generated by a high-momentum crossover or a standard trend moveâ€”has a predefined exit plan.\n\nConclusion\nThe \"Volume Momentum Strategy\" is a hybrid system. It executes trades based on the reliable trend signal of MA crossing VWAP but informs the trader with advanced volume analytics. By processing volume through the CCI and Stochastic calculations, it provides a \"heads-up\" display regarding the intensity of market participation, allowing the trader to distinguish between low-volume drifts and high-volume breakout moves.\n\n",
    "image_url": "WXXcgwAQ",
    "author": "vlenarcic",
    "likes": 5,
    "type": "strategy",
    "created": "2025-12-01",
    "updated": "2025-12-01",
    "source": "//Built by Claude 08-17-2025 (Template) + Gemini (Integration)\r\n//@version=6\r\nstrategy(\"Volume Momentum Strategy [MA/VWAP Cross]\", overlay=true, initial_capital=50000, currency=currency.USD, default_qty_type=strategy.fixed, default_qty_value=1, pyramiding=0, commission_type=strategy.commission.percent, commission_value=0, margin_long=0, margin_short=0, calc_on_order_fills=false, calc_on_every_tick=false)\r\n\r\n// ==========================================\r\n// --- INDICATOR INPUTS (From Original Script) ---\r\n// ==========================================\r\ngroup_cci   = \"Volume CCI Settings\"\r\ncciLength   = input.int(20, \"CCI Length\", group = group_cci)\r\ncciThresh   = input.int(100, \"CCI Spike Threshold\", group = group_cci)\r\n\r\ngroup_stoch = \"Volume Stochastic Settings\"\r\nstochLength = input.int(14, \"Stoch Length\", group = group_stoch)\r\nstochThresh = input.int(80, \"Stoch Threshold\", group = group_stoch)\r\n\r\ngroup_ma    = \"Moving Average Settings\"\r\nmaType      = input.string(\"SMA\", \"MA Type\", options = [\"SMA\", \"EMA\", \"SMMA (RMA)\", \"WMA\", \"HULL\"], group = group_ma)\r\nmaLength    = input.int(50, \"MA Length\", minval = 1, group = group_ma)\r\nmaSource    = input.source(close, \"MA Source\", group = group_ma)\r\n\r\ngroup_vwap  = \"VWAP Settings\"\r\nvwapSource  = input.source(hlc3, \"VWAP Source\", group = group_vwap, tooltip = \"Standard Formula uses HLC3. Session based.\")\r\n\r\n// ==========================================\r\n// --- STRATEGY INPUTS (From Template) ---\r\n// ==========================================\r\n\r\n// Time Controls\r\ntime_group = \" â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•  TIME CONTROLS  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• \"\r\ntrading_start_time = input.time(timestamp(\"1 Jan 2020 09:30\"), title=\"Start Trading Time\", group=time_group)\r\ntrading_stop_time = input.time(timestamp(\"1 Jan 2020 15:30\"), title=\"Stop Trading Time\", group=time_group)\r\nclose_all_time = input.time(timestamp(\"1 Jan 2020 15:45\"), title=\"Close All Positions Time\", group=time_group)\r\n\r\n// Trade Direction\r\ndirection_group = \" â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•  TRADE DIRECTION  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• \"\r\ntrade_direction = input.string(\"Both\", title=\"Trade Direction\", options=[\"Long\", \"Short\", \"Both\"], group=direction_group)\r\n\r\n// Strategy Settings\r\nstrategy_group = \" â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•  STRATEGY SETTINGS  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• \"\r\nenable_stop_loss = input.bool(true, title=\"Enable Stop Loss\", group=strategy_group)\r\nsl_type = input.string(\"Percentage\", title=\"Stop Loss Type\", options=[\"Percentage\", \"Dollar Amount\"], group=strategy_group)\r\nstop_loss_percent = input.float(2.0, title=\"Stop Loss %\", minval=0.1, maxval=10.0, step=0.1, group=strategy_group)\r\nstop_loss_dollars = input.float(100.0, title=\"Stop Loss $\", minval=1.0, maxval=5000.0, step=1.0, group=strategy_group)\r\n\r\nenable_take_profit = input.bool(true, title=\"Enable Take Profit\", group=strategy_group)\r\ntp_type = input.string(\"Percentage\", title=\"Take Profit Type\", options=[\"Percentage\", \"Dollar Amount\"], group=strategy_group)\r\ntake_profit_percent = input.float(4.0, title=\"Take Profit %\", minval=0.1, maxval=20.0, step=0.1, group=strategy_group)\r\ntake_profit_dollars = input.float(200.0, title=\"Take Profit $\", minval=1.0, maxval=10000.0, step=1.0, group=strategy_group)\r\n\r\n// ==========================================\r\n// --- INDICATOR CALCULATIONS ---\r\n// ==========================================\r\n\r\n// 1. Volume Calculations\r\nvolCCI   = ta.cci(volume, cciLength)\r\nvolStoch = ta.stoch(volume, volume, volume, stochLength)\r\nisVolumeSpike = (volCCI > cciThresh) and (volStoch > stochThresh)\r\n\r\n// 2. Moving Average Calculation\r\nfloat maValue = na\r\nif maType == \"SMA\"\r\n    maValue := ta.sma(maSource, maLength)\r\nelse if maType == \"EMA\"\r\n    maValue := ta.ema(maSource, maLength)\r\nelse if maType == \"SMMA (RMA)\"\r\n    maValue := ta.rma(maSource, maLength)\r\nelse if maType == \"WMA\"\r\n    maValue := ta.wma(maSource, maLength)\r\nelse if maType == \"HULL\"\r\n    maValue := ta.wma(2 * ta.wma(maSource, maLength / 2) - ta.wma(maSource, maLength), int(math.sqrt(maLength)))\r\n\r\n// 3. VWAP Calculation\r\nfloat vwapValue = ta.vwap(vwapSource)\r\n\r\n// 4. Crossing Signals (Raw)\r\ncrossOver     = ta.crossover(maValue, vwapValue)\r\ncrossUnder    = ta.crossunder(maValue, vwapValue)\r\n\r\n// ==========================================\r\n// --- STRATEGY HELPER FUNCTIONS ---\r\n// ==========================================\r\n\r\n// Function to check if we should close all positions (End of Day)\r\nshould_close_all() =>\r\n    hour_now = hour(time)\r\n    minute_now = minute(time)\r\n    close_hour = hour(close_all_time)\r\n    close_minute = minute(close_all_time)\r\n    (hour_now == close_hour and minute_now >= close_minute) or hour_now > close_hour\r\n\r\n// Function to check if we can enter new trades\r\ncan_enter_trade() =>\r\n    hour_now = hour(time)\r\n    minute_now = minute(time)\r\n    start_hour = hour(trading_start_time)\r\n    start_minute = minute(trading_start_time)\r\n    stop_hour = hour(trading_stop_time)\r\n    stop_minute = minute(trading_stop_time)\r\n    \r\n    time_ok = (hour_now > start_hour or (hour_now == start_hour and minute_now >= start_minute)) and\r\n              (hour_now < stop_hour or (hour_now == stop_hour and minute_now <= stop_minute))\r\n    time_ok\r\n\r\n// Function to check if long trades are allowed\r\nlong_allowed() =>\r\n    trade_direction == \"Long\" or trade_direction == \"Both\"\r\n\r\n// Function to check if short trades are allowed\r\nshort_allowed() =>\r\n    trade_direction == \"Short\" or trade_direction == \"Both\"\r\n\r\n// Risk Management Calculations\r\nget_long_stop_loss(entry_price) =>\r\n    if sl_type == \"Percentage\"\r\n        entry_price * (1 - stop_loss_percent / 100)\r\n    else\r\n        entry_price - stop_loss_dollars\r\n\r\nget_long_take_profit(entry_price) =>\r\n    if tp_type == \"Percentage\"\r\n        entry_price * (1 + take_profit_percent / 100)\r\n    else\r\n        entry_price + take_profit_dollars\r\n\r\nget_short_stop_loss(entry_price) =>\r\n    if sl_type == \"Percentage\"\r\n        entry_price * (1 + stop_loss_percent / 100)\r\n    else\r\n        entry_price + stop_loss_dollars\r\n\r\nget_short_take_profit(entry_price) =>\r\n    if tp_type == \"Percentage\"\r\n        entry_price * (1 - take_profit_percent / 100)\r\n    else\r\n        entry_price - take_profit_dollars\r\n\r\n// ==========================================\r\n// --- STRATEGY LOGIC ---\r\n// ==========================================\r\n\r\n// Mapping Indicator Signals to Strategy Conditions\r\n// NOTE: We only take signals if 'can_enter_trade()' is true, handled in the execution block.\r\nlong_condition  = crossOver\r\nshort_condition = crossUnder\r\n\r\n// Optional: Use Volume Spike as a filter? \r\n// For now, Volume Spike is purely visual/alert based as per original script, \r\n// but you could add \"and isVolumeSpike\" to the conditions above if desired.\r\n\r\nlong_exit_condition = false // Placeholder: Currently exiting on TP/SL or Reverse Signal\r\nshort_exit_condition = false\r\n\r\n// ==========================================\r\n// --- STRATEGY EXECUTION ---\r\n// ==========================================\r\n\r\n// Entry Logic\r\nif can_enter_trade() and long_allowed() and long_condition and strategy.position_size == 0\r\n    strategy.entry(\"Long\", strategy.long)\r\n    if enable_stop_loss or enable_take_profit\r\n        stop_level = enable_stop_loss ? get_long_stop_loss(close) : na\r\n        limit_level = enable_take_profit ? get_long_take_profit(close) : na\r\n        strategy.exit(\"Long SL/TP\", \"Long\", stop=stop_level, limit=limit_level)\r\n\r\nif can_enter_trade() and short_allowed() and short_condition and strategy.position_size == 0\r\n    strategy.entry(\"Short\", strategy.short)\r\n    if enable_stop_loss or enable_take_profit\r\n        stop_level = enable_stop_loss ? get_short_stop_loss(close) : na\r\n        limit_level = enable_take_profit ? get_short_take_profit(close) : na\r\n        strategy.exit(\"Short SL/TP\", \"Short\", stop=stop_level, limit=limit_level)\r\n\r\n// Exit Logic (Reverse signals or Manual conditions)\r\n// Note: strategy.entry automatically reverses positions if you are Long and a Short triggers (unless pyramiding is on)\r\nif strategy.position_size > 0 and long_exit_condition\r\n    strategy.close(\"Long\", comment=\"Long Exit Signal\")\r\nif strategy.position_size < 0 and short_exit_condition\r\n    strategy.close(\"Short\", comment=\"Short Exit Signal\")\r\n\r\n// Force close all positions at specified time\r\nif should_close_all() and strategy.position_size != 0\r\n    strategy.close_all(comment=\"Time Close\")\r\n\r\n// ==========================================\r\n// --- PLOTTING (Visuals) ---\r\n// ==========================================\r\n\r\nbarcolor(isVolumeSpike ? color.yellow : na, title = \"Volume Spike Bar Color\")\r\nplotshape(isVolumeSpike, style = shape.triangleup, location = location.belowbar, color = color.yellow, size = size.tiny, title = \"Vol Spike Marker\")\r\n\r\nplot(maValue, title = \"Moving Average\", color = color.new(color.blue, 0), linewidth = 2)\r\nplot(vwapValue, title = \"VWAP\", color = color.new(color.purple, 0), linewidth = 2)\r\n\r\n// We plot the 'valid' signals (inside time window) for visual confirmation\r\nvalidCrossOver  = crossOver and can_enter_trade()\r\nvalidCrossUnder = crossUnder and can_enter_trade()\r\n\r\nplotshape(validCrossOver, title = \"MA Cross Over VWAP\", style = shape.xcross, location = location.belowbar, color = color.green, size = size.small, text = \"Bull Cross\")\r\nplotshape(validCrossUnder, title = \"MA Cross Under VWAP\", style = shape.xcross, location = location.abovebar, color = color.red, size = size.small, text = \"Bear Cross\")"
  },
  {
    "url": "WBW59uPp-Trendline-Breaks-Supertrend-Delta-BTC-P-API",
    "name": "Trendline Breaks + Supertrend [Delta BTC-P] (API)",
    "description": "Trendline Breaks + Supertrend   (API)\nbest on 5 min",
    "image_url": "WBW59uPp",
    "author": "theone_Raj",
    "likes": 18,
    "type": "strategy",
    "created": "2025-12-01",
    "updated": "2025-12-01",
    "source": "//@version=6\r\nstrategy(\"Trendline Breaks + Supertrend [Delta BTC-P] (API)\",\r\n     overlay = true,\r\n     default_qty_type = strategy.percent_of_equity,\r\n     default_qty_value = 100,\r\n     initial_capital = 100000,\r\n     commission_type = strategy.commission.percent,\r\n     commission_value = 0.0,\r\n     max_labels_count = 500,\r\n     max_lines_count = 500)\r\n\r\n// â”€â”€â”€â”€â”€ INPUTS â”€â”€â”€â”€â”€\r\nlength           = input.int(14, \"Swing Detection Lookback\")\r\nmult             = input.float(1.0, \"Slope Multiplier\", minval = 0)\r\ncalcMethod       = input.string(\"Atr\", \"Slope Calculation Method\", options = [\"Atr\", \"Stdev\", \"Linreg\"])\r\nsupertrendFactor = input.float(3.0, \"Supertrend ATR Mult\")\r\nsupertrendPeriod = input.int(10, \"Supertrend ATR Period\")\r\nslPerc           = input.float(1.0, \"Stop Loss %\", minval = 0.1)\r\ntpPerc           = input.float(2.0, \"Take Profit %\", minval = 0.1)\r\nmanualTP         = input.float(0.0, \"Manual Take Profit Price (0 = disabled)\", minval = 0)\r\nmanualSL         = input.float(0.0, \"Manual Stop Loss Price (0 = disabled)\", minval = 0)\r\n\r\n// â”€â”€â”€â”€â”€ TRENDLINES â”€â”€â”€â”€â”€\r\nvar float upper   = na\r\nvar float lower   = na\r\nvar float slopePH = na\r\nvar float slopePL = na\r\nsrc = close\r\nn   = bar_index\r\n\r\nph = ta.pivothigh(length, length)\r\npl = ta.pivotlow(length, length)\r\nisPh = not na(ph)\r\nisPl = not na(pl)\r\n\r\nslope = switch calcMethod\r\n    \"Atr\"    => ta.atr(length) / length * mult\r\n    \"Stdev\"  => ta.stdev(src, length) / length * mult\r\n    \"Linreg\" => math.abs(ta.sma(src * n, length) - ta.sma(src, length) * ta.sma(n, length)) / ta.variance(n, length) / 2 * mult\r\n\r\nslopePH := isPh ? slope : slopePH\r\nslopePL := isPl ? slope : slopePL\r\n\r\nupper := isPh ? ph : upper - slopePH\r\nlower := isPl ? pl : lower + slopePL\r\n\r\nupos = isPh ? 0 : close > upper - slopePH * length ? 1 : 0\r\ndnos = isPl ? 0 : close < lower + slopePL * length ? 1 : 0\r\n\r\n// â”€â”€â”€â”€â”€ SUPERTREND â”€â”€â”€â”€â”€\r\natr = ta.atr(supertrendPeriod)\r\nhl2 = (high + low) / 2\r\nupperBand = hl2 + supertrendFactor * atr\r\nlowerBand = hl2 - supertrendFactor * atr\r\n\r\nvar bool inUpTrend = true\r\ninUpTrend := close[1] > upperBand[1] ? true :\r\n             close[1] < lowerBand[1] ? false :\r\n             inUpTrend[1]\r\n\r\nsupertrendDir = inUpTrend ? 1 : -1\r\n\r\n// â”€â”€â”€â”€â”€ CONDITIONS â”€â”€â”€â”€â”€\r\nlongCondition  = supertrendDir == 1 and upos > upos[1]\r\nshortCondition = supertrendDir == -1 and dnos > dnos[1]\r\nlongExit       = supertrendDir == -1 or dnos > dnos[1]\r\nshortExit      = supertrendDir == 1 or upos > upos[1]\r\n\r\n// â”€â”€â”€â”€â”€ TP/SL â”€â”€â”€â”€â”€\r\nslLong  = manualSL > 0 ? manualSL : close * (1 - slPerc / 100)\r\ntpLong  = manualTP > 0 ? manualTP : close * (1 + tpPerc / 100)\r\nslShort = manualSL > 0 ? manualSL : close * (1 + slPerc / 100)\r\ntpShort = manualTP > 0 ? manualTP : close * (1 - tpPerc / 100)\r\n\r\n// â”€â”€â”€â”€â”€ ORDERS â”€â”€â”€â”€â”€\r\nif longCondition\r\n    strategy.entry(\"Long\", strategy.long)\r\n    strategy.exit(\"TP/SL Long\", from_entry = \"Long\", stop = slLong, limit = tpLong)\r\n\r\nif shortCondition\r\n    strategy.entry(\"Short\", strategy.short)\r\n    strategy.exit(\"TP/SL Short\", from_entry = \"Short\", stop = slShort, limit = tpShort)\r\n\r\nif strategy.position_size > 0 and longExit\r\n    strategy.close(\"Long\", comment = \"Reversal Exit\")\r\n\r\nif strategy.position_size < 0 and shortExit\r\n    strategy.close(\"Short\", comment = \"Reversal Exit\")\r\n\r\n// â”€â”€â”€â”€â”€ API OUTPUTS â”€â”€â”€â”€â”€\r\nbuySignal  = longCondition ? 1 : 0\r\nsellSignal = shortCondition ? 1 : 0\r\nexitLong   = longExit ? 1 : 0\r\nexitShort  = shortExit ? 1 : 0\r\ntrendDir   = supertrendDir\r\ntrailUp    = inUpTrend ? lowerBand : na\r\ntrailDown  = inUpTrend ? na : upperBand\r\n\r\nplot(buySignal,       \"BUY_SERIES\",        color = color.new(color.green, 60))\r\nplot(sellSignal,      \"SELL_SERIES\",       color = color.new(color.red, 60))\r\nplot(exitLong,        \"EXIT_LONG_SERIES\",  color = color.new(color.orange, 60))\r\nplot(exitShort,       \"EXIT_SHORT_SERIES\", color = color.new(color.orange, 60))\r\nplot(trendDir,        \"TREND_DIR\",         color = color.new(color.blue, 70))\r\nplot(atr,             \"ATR_VALUE\",         color = color.new(color.yellow, 60))\r\nplot(trailUp,         \"TRAIL_UP\",          color = color.new(color.green, 50))\r\nplot(trailDown,       \"TRAIL_DOWN\",        color = color.new(color.red, 50))\r\n\r\nplotshape(longCondition,  title = \"Buy Label\",  location = location.belowbar, color = color.green, style = shape.labelup,   text = \"Buy\")\r\nplotshape(shortCondition, title = \"Sell Label\", location = location.abovebar, color = color.red,   style = shape.labeldown, text = \"Sell\")\r\nplotshape(longExit and strategy.position_size > 0,  title = \"Exit L\", location = location.abovebar, color = color.orange, style = shape.xcross, text = \"Exit L\")\r\nplotshape(shortExit and strategy.position_size < 0, title = \"Exit S\", location = location.belowbar, color = color.orange, style = shape.xcross, text = \"Exit S\")\r\n"
  },
  {
    "url": "MQSP045g-Trendline-Breaks-Supertrend-Delta-BTC-P",
    "name": "Trendline Breaks + Supertrend [Delta BTC-P]",
    "description": "Trendline Breaks + Supertrend in same direct Best on 5 min",
    "image_url": "MQSP045g",
    "author": "theone_Raj",
    "likes": 36,
    "type": "strategy",
    "created": "2025-12-01",
    "updated": "2025-12-01",
    "source": "//@version=5\r\nstrategy(\"Trendline Breaks + Supertrend [Delta BTC-P]\", overlay=true, default_qty_type=strategy.percent_of_equity, default_qty_value=100)\r\n\r\n//-----------------------------------------------------------------------------\r\n//Inputs\r\n//-----------------------------------------------------------------------------\r\nlength = input.int(14, 'Swing Detection Lookback')\r\nmult = input.float(1.0, 'Slope Multiplier', minval=0)\r\ncalcMethod = input.string('Atr', 'Slope Calculation Method', options=['Atr', 'Stdev', 'Linreg'])\r\nsupertrendFactor = input.float(3.0, 'Supertrend ATR Mult')\r\nsupertrendPeriod = input.int(10, 'Supertrend ATR Period')\r\nslPerc = input.float(1.0, 'Stop Loss % (if manual disabled)', minval=0.1)\r\ntpPerc = input.float(2.0, 'Take Profit % (if manual disabled)', minval=0.1)\r\nmanualTP = input.float(0.0, 'Manual Take Profit Price (0 = disabled)', minval=0)\r\nmanualSL = input.float(0.0, 'Manual Stop Loss Price (0 = disabled)', minval=0)\r\n\r\n//-----------------------------------------------------------------------------\r\n//Trendline Calculations\r\n//-----------------------------------------------------------------------------\r\nvar float upper = na\r\nvar float lower = na\r\nvar float slope_ph = na\r\nvar float slope_pl = na\r\nsrc = close\r\nn = bar_index\r\n\r\nph = ta.pivothigh(length, length)\r\npl = ta.pivotlow(length, length)\r\n\r\nslope = switch calcMethod\r\n    'Atr'    => ta.atr(length) / length * mult\r\n    'Stdev'  => ta.stdev(src,length) / length * mult\r\n    'Linreg' => math.abs(ta.sma(src * n, length) - ta.sma(src, length) * ta.sma(n, length)) / ta.variance(n, length) / 2 * mult\r\n\r\nslope_ph := ph ? slope : slope_ph\r\nslope_pl := pl ? slope : slope_pl\r\n\r\nupper := ph ? ph : upper - slope_ph\r\nlower := pl ? pl : lower + slope_pl\r\n\r\nupos = ph ? 0 : close > upper - slope_ph * length ? 1 : 0\r\ndnos = pl ? 0 : close < lower + slope_pl * length ? 1 : 0\r\n\r\n//-----------------------------------------------------------------------------\r\n//Supertrend Calculation\r\n//-----------------------------------------------------------------------------\r\natr = ta.atr(supertrendPeriod)\r\nhl2 = (high + low) / 2\r\nupperBand = hl2 + supertrendFactor * atr\r\nlowerBand = hl2 - supertrendFactor * atr\r\ninUpTrend = true\r\ninUpTrend := close[1] > upperBand[1] ? true : close[1] < lowerBand[1] ? false : inUpTrend[1]\r\nsupertrendDir = inUpTrend ? 1 : -1\r\n\r\n//-----------------------------------------------------------------------------\r\n//Trade Conditions\r\n//-----------------------------------------------------------------------------\r\nlongCondition = (supertrendDir == 1 and upos > upos[1])\r\nshortCondition = (supertrendDir == -1 and dnos > dnos[1])\r\n\r\nlongExitCondition = (supertrendDir == -1 or dnos > dnos[1])\r\nshortExitCondition = (supertrendDir == 1 or upos > upos[1])\r\n\r\n//-----------------------------------------------------------------------------\r\n//Manual TP/SL or fallback to percentage\r\n//-----------------------------------------------------------------------------\r\nslLong = manualSL > 0 ? manualSL : close * (1 - slPerc / 100)\r\ntpLong = manualTP > 0 ? manualTP : close * (1 + tpPerc / 100)\r\n\r\nslShort = manualSL > 0 ? manualSL : close * (1 + slPerc / 100)\r\ntpShort = manualTP > 0 ? manualTP : close * (1 - tpPerc / 100)\r\n\r\n//-----------------------------------------------------------------------------\r\n//Trade Execution\r\n//-----------------------------------------------------------------------------\r\nif (longCondition)\r\n    strategy.entry(\"Long\", strategy.long)\r\n    strategy.exit(\"TP/SL Long\", from_entry=\"Long\", stop=slLong, limit=tpLong)\r\n\r\nif (shortCondition)\r\n    strategy.entry(\"Short\", strategy.short)\r\n    strategy.exit(\"TP/SL Short\", from_entry=\"Short\", stop=slShort, limit=tpShort)\r\n\r\n// Exit on signal reversal\r\nif (strategy.position_size > 0 and longExitCondition)\r\n    strategy.close(\"Long\", comment=\"Reversal Exit\")\r\n\r\nif (strategy.position_size < 0 and shortExitCondition)\r\n    strategy.close(\"Short\", comment=\"Reversal Exit\")\r\n\r\n//-----------------------------------------------------------------------------\r\n//Plots for Debug\r\n//-----------------------------------------------------------------------------\r\nplotshape(longCondition, location=location.belowbar, color=color.green, style=shape.labelup, text=\"Buy\")\r\nplotshape(shortCondition, location=location.abovebar, color=color.red, style=shape.labeldown, text=\"Sell\")\r\nplotshape(longExitCondition and strategy.position_size > 0, location=location.abovebar, color=color.orange, style=shape.xcross, text=\"Exit L\")\r\nplotshape(shortExitCondition and strategy.position_size < 0, location=location.belowbar, color=color.orange, style=shape.xcross, text=\"Exit S\")\r\n"
  },
  {
    "url": "R4mgYcZ5-oleg-aryukov-strategy",
    "name": "Oleg_Aryukov_Strategy",
    "description": "Trader Oleg Aryukov's strategy, based on a variety of oscillators, allows him to try to catch reversals in cryptocurrencies.",
    "image_url": "R4mgYcZ5",
    "author": "ra8an",
    "likes": 11,
    "type": "strategy",
    "created": "2025-12-01",
    "updated": "2025-12-01",
    "source": "//@version=6\nstrategy(\"Oleg_Aryukov_Strategy\", overlay=true, initial_capital=1000,\n     default_qty_type=strategy.percent_of_equity, default_qty_value=10,\n     commission_type=strategy.commission.percent, commission_value=0.1)\n\n// ============================================================================\n// Ð¸Ð½Ð´ÑŽÐºÐ¸\n// ============================================================================\nuse_rsi = input.bool(true, \"Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ RSI\", group=\"ÐÐºÑ‚Ð¸Ð²Ð°Ñ†Ð¸Ñ Ð¸Ð½Ð´Ð¸ÐºÐ°Ñ‚Ð¾Ñ€Ð¾Ð²\")\nuse_williams = input.bool(true, \"Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ Williams %R\", group=\"ÐÐºÑ‚Ð¸Ð²Ð°Ñ†Ð¸Ñ Ð¸Ð½Ð´Ð¸ÐºÐ°Ñ‚Ð¾Ñ€Ð¾Ð²\")\nuse_tsi = input.bool(true, \"Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ TSI\", group=\"ÐÐºÑ‚Ð¸Ð²Ð°Ñ†Ð¸Ñ Ð¸Ð½Ð´Ð¸ÐºÐ°Ñ‚Ð¾Ñ€Ð¾Ð²\")\nuse_kdj = input.bool(true, \"Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ KDJ\", group=\"ÐÐºÑ‚Ð¸Ð²Ð°Ñ†Ð¸Ñ Ð¸Ð½Ð´Ð¸ÐºÐ°Ñ‚Ð¾Ñ€Ð¾Ð²\")\nuse_bb_percent = input.bool(true, \"Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ %BB\", group=\"ÐÐºÑ‚Ð¸Ð²Ð°Ñ†Ð¸Ñ Ð¸Ð½Ð´Ð¸ÐºÐ°Ñ‚Ð¾Ñ€Ð¾Ð²\")\nuse_nadaraya = input.bool(true, \"Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ Nadaraya-Watson\", group=\"ÐÐºÑ‚Ð¸Ð²Ð°Ñ†Ð¸Ñ Ð¸Ð½Ð´Ð¸ÐºÐ°Ñ‚Ð¾Ñ€Ð¾Ð²\")\n\n// RSI \nrsi_length = input.int(12, \"RSI ÐŸÐµÑ€Ð¸Ð¾Ð´\", minval=2, group=\"RSI\")\nrsi_oversold = input.float(30, \"RSI ÐŸÐµÑ€ÐµÐ¿Ñ€Ð¾Ð´Ð°Ð½Ð½Ð¾ÑÑ‚ÑŒ\", minval=0, maxval=100, group=\"RSI\")\nrsi_overbought = input.float(70, \"RSI ÐŸÐµÑ€ÐµÐºÑƒÐ¿Ð»ÐµÐ½Ð½Ð¾ÑÑ‚ÑŒ\", minval=0, maxval=100, group=\"RSI\")\n\n// Williams \nwilliams_length_6 = input.int(6, \"Williams %R ÐŸÐµÑ€Ð¸Ð¾Ð´ 6\", minval=2, group=\"Williams %R\")\nwilliams_length_12 = input.int(12, \"Williams %R ÐŸÐµÑ€Ð¸Ð¾Ð´ 12\", minval=2, group=\"Williams %R\")\nwilliams_oversold = input.float(-80, \"Williams ÐŸÐµÑ€ÐµÐ¿Ñ€Ð¾Ð´Ð°Ð½Ð½Ð¾ÑÑ‚ÑŒ\", minval=-100, maxval=0, group=\"Williams %R\")\nwilliams_overbought = input.float(-20, \"Williams ÐŸÐµÑ€ÐµÐºÑƒÐ¿Ð»ÐµÐ½Ð½Ð¾ÑÑ‚ÑŒ\", minval=-100, maxval=0, group=\"Williams %R\")\n\n// TSI \ntsi_long = input.int(25, \"TSI Ð”Ð»Ð¸Ð½Ð½Ñ‹Ð¹ Ð¿ÐµÑ€Ð¸Ð¾Ð´\", minval=2, group=\"TSI\")\ntsi_short = input.int(13, \"TSI ÐšÐ¾Ñ€Ð¾Ñ‚ÐºÐ¸Ð¹ Ð¿ÐµÑ€Ð¸Ð¾Ð´\", minval=2, group=\"TSI\")\ntsi_signal = input.int(13, \"TSI Ð¡Ð¸Ð³Ð½Ð°Ð»ÑŒÐ½Ð°Ñ Ð»Ð¸Ð½Ð¸Ñ\", minval=1, group=\"TSI\")\ntsi_divergence = input.float(15, \"TSI Ð Ð°ÑÑ…Ð¾Ð¶Ð´ÐµÐ½Ð¸Ðµ Ð´Ð»Ñ ÑÐ¸Ð³Ð½Ð°Ð»Ð°\", minval=0, group=\"TSI\")\n\n// KDJ \nkdj_length = input.int(9, \"KDJ ÐŸÐµÑ€Ð¸Ð¾Ð´\", minval=1, group=\"KDJ\")\nkdj_signal_k = input.int(3, \"KDJ Ð¡Ð¸Ð³Ð½Ð°Ð» K\", minval=1, group=\"KDJ\")\nkdj_signal_d = input.int(3, \"KDJ Ð¡Ð¸Ð³Ð½Ð°Ð» D\", minval=1, group=\"KDJ\")\nkdj_divergence = input.float(20, \"KDJ Ð Ð°ÑÑ…Ð¾Ð¶Ð´ÐµÐ½Ð¸Ðµ\", minval=0, group=\"KDJ\")\n\n// Bollinger \nbb_length = input.int(20, \"BB ÐŸÐµÑ€Ð¸Ð¾Ð´\", minval=1, group=\"Bollinger Bands %B\")\nbb_mult = input.float(2.0, \"BB ÐœÐ½Ð¾Ð¶Ð¸Ñ‚ÐµÐ»ÑŒ\", minval=0.1, group=\"Bollinger Bands %B\")\n\n// Nadaraya-Watson \nnw_bandwidth = input.float(3.0, \"NW Bandwidth\", minval=0.1, group=\"Nadaraya-Watson\")\nnw_lookback = input.int(50, \"NW Lookback\", minval=10, maxval=200, group=\"Nadaraya-Watson\")\n\n// RCI Ribbon\nrci_fast = input.int(9, \"RCI Ð‘Ñ‹ÑÑ‚Ñ€Ñ‹Ð¹ Ð¿ÐµÑ€Ð¸Ð¾Ð´\", minval=1, group=\"RCI Ribbon\")\nrci_medium = input.int(26, \"RCI Ð¡Ñ€ÐµÐ´Ð½Ð¸Ð¹ Ð¿ÐµÑ€Ð¸Ð¾Ð´\", minval=1, group=\"RCI Ribbon\")\nrci_slow = input.int(52, \"RCI ÐœÐµÐ´Ð»ÐµÐ½Ð½Ñ‹Ð¹ Ð¿ÐµÑ€Ð¸Ð¾Ð´\", minval=1, group=\"RCI Ribbon\")\nrci_oversold = input.float(-80, \"RCI ÐŸÐµÑ€ÐµÐ¿Ñ€Ð¾Ð´Ð°Ð½Ð½Ð¾ÑÑ‚ÑŒ\", minval=-100, maxval=100, group=\"RCI Ribbon\")\nrci_overbought = input.float(80, \"RCI ÐŸÐµÑ€ÐµÐºÑƒÐ¿Ð»ÐµÐ½Ð½Ð¾ÑÑ‚ÑŒ\", minval=-100, maxval=100, group=\"RCI Ribbon\")\n\n// ============================================================================\n// Ñ€Ð¸ÑÐºÐ¸\n// ============================================================================\nstop_loss_percent = input.float(2.0, \"Ð¡Ñ‚Ð¾Ð¿-Ð»Ð¾ÑÑ %\", minval=0.1, maxval=10, step=0.1, group=\"Ð Ð¸ÑÐº-Ð¼ÐµÐ½ÐµÐ´Ð¶Ð¼ÐµÐ½Ñ‚\")\ntake_profit_percent = input.float(4.0, \"Ð¢ÐµÐ¹Ðº-Ð¿Ñ€Ð¾Ñ„Ð¸Ñ‚ %\", minval=0.1, maxval=20, step=0.1, group=\"Ð Ð¸ÑÐº-Ð¼ÐµÐ½ÐµÐ´Ð¶Ð¼ÐµÐ½Ñ‚\")\nuse_trailing = input.bool(true, \"Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ Ñ‚Ñ€ÐµÐ¹Ð»Ð¸Ð½Ð³-ÑÑ‚Ð¾Ð¿\", group=\"Ð Ð¸ÑÐº-Ð¼ÐµÐ½ÐµÐ´Ð¶Ð¼ÐµÐ½Ñ‚\")\ntrailing_percent = input.float(1.0, \"Ð¢Ñ€ÐµÐ¹Ð»Ð¸Ð½Ð³-ÑÑ‚Ð¾Ð¿ %\", minval=0.1, maxval=5, step=0.1, group=\"Ð Ð¸ÑÐº-Ð¼ÐµÐ½ÐµÐ´Ð¶Ð¼ÐµÐ½Ñ‚\")\n\n// ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸ Ð¿Ð¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´ÐµÐ½Ð¸Ñ ÑÐ¸Ð³Ð½Ð°Ð»Ð¾Ð²\nmin_confirmations = input.int(3, \"ÐœÐ¸Ð½Ð¸Ð¼ÑƒÐ¼ Ð¿Ð¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´ÐµÐ½Ð¸Ð¹\", minval=1, maxval=8, group=\"Ð¤Ð¸Ð»ÑŒÑ‚Ñ€Ñ‹\")\ncheck_trend = input.bool(true, \"Ð£Ñ‡Ð¸Ñ‚Ñ‹Ð²Ð°Ñ‚ÑŒ Ñ‚Ñ€ÐµÐ½Ð´\", group=\"Ð¤Ð¸Ð»ÑŒÑ‚Ñ€Ñ‹\")\n\n// ============================================================================\n// Ð¸Ð½Ð´ÑŽÐºÐ¸ Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹\n// ============================================================================\n\n// RSI\nrsi = ta.rsi(close, rsi_length)\n\n// Williams \nwilliams_r_6 = ta.wpr(williams_length_6)\nwilliams_r_12 = ta.wpr(williams_length_12)\n\n// TSI (Ð·Ð°Ñ‰Ð¸Ñ‚Ð° Ð¾Ñ‚ Ð´ÐµÐ»ÐµÐ½Ð¸Ñ Ð½Ð° Ð½Ð¾Ð»ÑŒ)\ndouble_smooth(src, longlen, shortlen) =>\n    tmp = ta.ema(src, longlen)\n    ta.ema(tmp, shortlen)\n\npc = ta.change(close)\ndouble_smoothed_pc = double_smooth(pc, tsi_long, tsi_short)\ndouble_smoothed_abs_pc = double_smooth(math.abs(pc), tsi_long, tsi_short)\ntsi_value = na(double_smoothed_abs_pc) or double_smoothed_abs_pc == 0 ? 0.0 : 100 * (double_smoothed_pc / double_smoothed_abs_pc)\ntsi_signal_line = ta.ema(tsi_value, tsi_signal)\n\n// KDJ (Ð·Ð°Ñ‰Ð¸Ñ‚Ð° Ð¾Ñ‚ Ð´ÐµÐ»ÐµÐ½Ð¸Ñ Ð½Ð° Ð½Ð¾Ð»ÑŒ)\nkdj_high = ta.highest(high, kdj_length)\nkdj_low = ta.lowest(low, kdj_length)\nrsv = (kdj_high - kdj_low) == 0 ? 50.0 : 100 * ((close - kdj_low) / (kdj_high - kdj_low))\nk = ta.sma(rsv, kdj_signal_k)\nd = ta.sma(k, kdj_signal_d)\nj = 3 * k - 2 * d\n\n// Bollinger Bands (Ð·Ð°Ñ‰Ð¸Ñ‚Ð°)\n[bb_middle, bb_upper, bb_lower] = ta.bb(close, bb_length, bb_mult)\nbb_den = bb_upper - bb_lower\nbb_percent = bb_den == 0 ? 0.5 : (close - bb_lower) / bb_den\n\n// RCI (Ñ Ð·Ð°Ñ‰Ð¸Ñ‚Ð°Ð¼Ð¸)\nrci_calc(length) =>\n    valid = bar_index >= length\n    rank_price = valid ? ta.percentrank(close, length) : 0.5\n    rank_time = valid ? ta.percentrank(bar_index, length) : 0.5\n    corr = valid ? ta.correlation(rank_price, rank_time, length) : 0.0\n    corr * 100\n\nrci_fast_value = rci_calc(rci_fast)\nrci_medium_value = rci_calc(rci_medium)\nrci_slow_value = rci_calc(rci_slow)\n\n// Nadaraya-Watson \nnw_kernel_regression(src, bandwidth, lookback) =>\n    sum_weighted = 0.0\n    sum_weights = 0.0\n    for i = 0 to lookback - 1\n        weight = math.exp(-math.pow(i, 2) / (2 * math.pow(bandwidth, 2)))\n        sum_weighted += src[i] * weight\n        sum_weights += weight\n    sum_weights == 0 ? src : sum_weighted / sum_weights\n\nnw_estimate = use_nadaraya ? nw_kernel_regression(close, nw_bandwidth, nw_lookback) : na\nnw_upper = use_nadaraya and not na(nw_estimate) ? nw_estimate * (1 + nw_bandwidth/100) : na\nnw_lower = use_nadaraya and not na(nw_estimate) ? nw_estimate * (1 - nw_bandwidth/100) : na\n\n// ÐžÐ¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ Ñ‚Ñ€ÐµÐ½Ð´Ð° \nema_fast = ta.ema(close, 50)\nema_slow = ta.ema(close, 200)\ntrend_up = ema_fast > ema_slow\ntrend_down = ema_fast < ema_slow\n\n// ============================================================================\n// ÑÐ¸Ð³Ð½Ð°Ð»Ñ‹\n// ============================================================================\n\n// ÐŸÐ¾Ð´ÑÑ‡ÐµÑ‚ ÑÐ¸Ð³Ð½Ð°Ð»Ð¾Ð² Ð½Ð° Ð¿Ð¾ÐºÑƒÐ¿ÐºÑƒ/Ð¿Ñ€Ð¾Ð´Ð°Ð¶Ñƒ\nvar int buy_signals = 0\nvar int sell_signals = 0\n\n// ÑÐ±Ñ€Ð°ÑÑ‹Ð²Ð°ÐµÐ¼ ÑÑ‡Ñ‘Ñ‚Ñ‡Ð¸ÐºÐ¸ Ð½Ð° ÐºÐ°Ð¶Ð´Ð¾Ð¹ Ð½Ð¾Ð²Ð¾Ð¹ Ð±Ð°Ñ€Ðµ\nif barstate.isnew\n    buy_signals := 0\n    sell_signals := 0\n\nif use_rsi\n    buy_signals := buy_signals + (not na(rsi) and rsi < rsi_oversold ? 1 : 0)\n    sell_signals := sell_signals + (not na(rsi) and rsi > rsi_overbought ? 1 : 0)\n\nif use_williams\n    buy_signals := buy_signals + (not na(williams_r_6) and williams_r_6 < williams_oversold ? 1 : 0)\n    buy_signals := buy_signals + (not na(williams_r_12) and williams_r_12 < williams_oversold ? 1 : 0)\n    sell_signals := sell_signals + (not na(williams_r_6) and williams_r_6 > williams_overbought ? 1 : 0)\n    sell_signals := sell_signals + (not na(williams_r_12) and williams_r_12 > williams_overbought ? 1 : 0)\n\nif use_tsi\n    tsi_divergence_buy = math.abs(tsi_value - tsi_signal_line) > tsi_divergence and tsi_value < tsi_signal_line\n    tsi_divergence_sell = math.abs(tsi_value - tsi_signal_line) > tsi_divergence and tsi_value > tsi_signal_line\n    buy_signals := buy_signals + (tsi_divergence_buy ? 1 : 0)\n    sell_signals := sell_signals + (tsi_divergence_sell ? 1 : 0)\n\nif use_kdj\n    kdj_oversold = j < 20 and math.abs(k - d) > kdj_divergence\n    kdj_overbought = j > 80 and math.abs(k - d) > kdj_divergence\n    buy_signals := buy_signals + (kdj_oversold ? 1 : 0)\n    sell_signals := sell_signals + (kdj_overbought ? 1 : 0)\n\nif use_bb_percent\n    buy_signals := buy_signals + (bb_percent < 0 ? 1 : 0)\n    sell_signals := sell_signals + (bb_percent > 1 ? 1 : 0)\n\nif use_nadaraya\n    buy_signals := buy_signals + (not na(nw_lower) and close < nw_lower ? 1 : 0)\n    sell_signals := sell_signals + (not na(nw_upper) and close > nw_upper ? 1 : 0)\n\n// RCI Ribbon\nrci_all_oversold = rci_fast_value < rci_oversold and rci_medium_value < rci_oversold and rci_slow_value < rci_oversold\nrci_all_overbought = rci_fast_value > rci_overbought and rci_medium_value > rci_overbought and rci_slow_value > rci_overbought\nbuy_signals := buy_signals + (rci_all_oversold ? 1 : 0)\nsell_signals := sell_signals + (rci_all_overbought ? 1 : 0)\n\n// ============================================================================\n// Ñ‚Ð²Ñ…\n// ============================================================================\n\ntrend_filter_buy = check_trend ? (trend_up or not trend_down) : true\ntrend_filter_sell = check_trend ? (trend_down or not trend_up) : true\n\nlong_condition = buy_signals >= min_confirmations and trend_filter_buy and strategy.position_size == 0\nshort_condition = sell_signals >= min_confirmations and trend_filter_sell and strategy.position_size == 0\n\n// ============================================================================\n// Ð¾Ñ€Ð´ÐµÑ€Ð°\n// ============================================================================\n\nif long_condition\n    strategy.entry(\"Long\", strategy.long)\n\nif short_condition\n    strategy.entry(\"Short\", strategy.short)\n\n// ÑÑ‚Ð¾Ð¿/Ñ‚ÐµÐ¹Ðº/Ñ‚Ñ€ÐµÐ¹Ð»Ð¸Ð½Ð³)\nif strategy.position_size > 0\n    stop_price = strategy.position_avg_price * (1 - stop_loss_percent / 100)\n    take_price = strategy.position_avg_price * (1 + take_profit_percent / 100)\n\n    if use_trailing\n        // Ð”Ð»Ñ Ñ‚Ñ€ÐµÐ¹Ð»Ð¸Ð½Ð³Ð°: Ð¿Ð¾Ð´Ð°Ñ‘Ð¼ Ð¿Ð°Ñ€Ñƒ trail_points + trail_offset (Ñ‚Ñ€ÐµÐ±Ð¾Ð²Ð°Ð½Ð¸Ðµ)\n        trail_points = math.abs(strategy.position_avg_price * trailing_percent / 100)  // Ð²ÐµÐ»Ð¸Ñ‡Ð¸Ð½Ð° Ð² Ñ†ÐµÐ½Ðµ\n        trail_offset = trail_points  // Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ Ð¾Ð´Ð¸Ð½Ð°ÐºÐ¾Ð²Ð¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ â€” ÑƒÐ´Ð¾Ð²Ð»ÐµÑ‚Ð²Ð¾Ñ€ÑÐµÑ‚ Ñ‚Ñ€ÐµÐ±Ð¾Ð²Ð°Ð½Ð¸ÑŽ Ð¿Ð°Ñ€Ñ‹\n        // ÐœÐ¾Ð¶Ð½Ð¾ Ñ‚Ð°ÐºÐ¶Ðµ ÑÐ¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ limit (Ñ‚ÐµÐ¹Ðº) â€” Ð¾ÑÑ‚Ð°Ð²Ð»ÑÐµÐ¼ limit, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð·Ð°Ñ„Ð¸ÐºÑÐ¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ñ†ÐµÐ»ÑŒ\n        strategy.exit(\"Exit Long\", \"Long\", trail_points=trail_points, trail_offset=trail_offset, limit=take_price)\n    else\n        strategy.exit(\"Exit Long\", \"Long\", stop=stop_price, limit=take_price)\n\nif strategy.position_size < 0\n    stop_price = strategy.position_avg_price * (1 + stop_loss_percent / 100)\n    take_price = strategy.position_avg_price * (1 - take_profit_percent / 100)\n\n    if use_trailing\n        trail_points = math.abs(strategy.position_avg_price * trailing_percent / 100)\n        trail_offset = trail_points\n        strategy.exit(\"Exit Short\", \"Short\", trail_points=trail_points, trail_offset=trail_offset, limit=take_price)\n    else\n        strategy.exit(\"Exit Short\", \"Short\", stop=stop_price, limit=take_price)\n\n// ============================================================================\n// Ð°Ð»ÐµÑ€Ñ‚Ñ‹\n// ============================================================================\n\nlong_alert = long_condition\nshort_alert = short_condition\nexit_long_alert = strategy.position_size > 0 and (close <= strategy.position_avg_price * (1 - stop_loss_percent / 100) or close >= strategy.position_avg_price * (1 + take_profit_percent / 100))\nexit_short_alert = strategy.position_size < 0 and (close >= strategy.position_avg_price * (1 + stop_loss_percent / 100) or close <= strategy.position_avg_price * (1 - take_profit_percent / 100))\n\nalertcondition(long_alert, title=\"ðŸŸ¢ Long Signal\", message='{\"signal\":\"long\",\"symbol\":\"{{ticker}}\",\"price\":\"{{close}}\"}')\nalertcondition(short_alert, title=\"ðŸ”´ Short Signal\", message='{\"signal\":\"short\",\"symbol\":\"{{ticker}}\",\"price\":\"{{close}}\"}')\nalertcondition(exit_long_alert, title=\"ðŸšª Ð—Ð°ÐºÑ€Ñ‹Ñ‚Ð¸Ðµ Long\", message='{\"signal\":\"exit_long\",\"symbol\":\"{{ticker}}\",\"price\":\"{{close}}\"}')\nalertcondition(exit_short_alert, title=\"ðŸšª Ð—Ð°ÐºÑ€Ñ‹Ñ‚Ð¸Ðµ Short\", message='{\"signal\":\"exit_short\",\"symbol\":\"{{ticker}}\",\"price\":\"{{close}}\"}')\n\nplotshape(long_alert, title=\"Alert Long\", location=location.belowbar, color=color.lime, style=shape.circle, size=size.tiny)\nplotshape(short_alert, title=\"Alert Short\", location=location.abovebar, color=color.red, style=shape.circle, size=size.tiny)\n\n// ============================================================================\n// Ð²Ð¸Ð¶ÑƒÐ°Ð»\n// ============================================================================\n\nplot(use_nadaraya ? nw_upper : na, \"NW Upper\", color=color.new(color.purple, 70), linewidth=1)\nplot(use_nadaraya ? nw_estimate : na, \"NW Middle\", color=color.new(color.purple, 50), linewidth=2)\nplot(use_nadaraya ? nw_lower : na, \"NW Lower\", color=color.new(color.purple, 70), linewidth=1)\n\nplot(check_trend ? ema_fast : na, \"EMA 50\", color=color.orange)\nplot(check_trend ? ema_slow : na, \"EMA 200\", color=color.blue)\n\nvar table infoTable = table.new(position.top_right, 2, 8, bgcolor=color.new(color.black, 85))\nif barstate.islast\n    table.cell(infoTable, 0, 0, \"Ð˜Ð½Ð´Ð¸ÐºÐ°Ñ‚Ð¾Ñ€\", text_color=color.white)\n    table.cell(infoTable, 1, 0, \"Ð—Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ\", text_color=color.white)\n    table.cell(infoTable, 0, 1, \"Buy Signals\", text_color=color.green)\n    table.cell(infoTable, 1, 1, str.tostring(buy_signals))\n    table.cell(infoTable, 0, 2, \"Sell Signals\", text_color=color.red)\n    table.cell(infoTable, 1, 2, str.tostring(sell_signals))\n    table.cell(infoTable, 0, 3, \"RSI\", text_color=color.white)\n    table.cell(infoTable, 1, 3, str.tostring(rsi, \"#.##\"))\n    table.cell(infoTable, 0, 4, \"TSI\", text_color=color.white)\n    table.cell(infoTable, 1, 4, str.tostring(tsi_value, \"#.##\"))\n    table.cell(infoTable, 0, 5, \"KDJ-J\", text_color=color.white)\n    table.cell(infoTable, 1, 5, str.tostring(j, \"#.##\"))\n    table.cell(infoTable, 0, 6, \"%BB\", text_color=color.white)\n    table.cell(infoTable, 1, 6, str.tostring(bb_percent, \"#.##\"))\n    trend_text = trend_up ? \"â†‘\" : trend_down ? \"â†“\" : \"â†’\"\n    trend_color = trend_up ? color.green : trend_down ? color.red : color.yellow\n    table.cell(infoTable, 0, 7, \"Ð¢Ñ€ÐµÐ½Ð´\", text_color=color.white)\n    table.cell(infoTable, 1, 7, trend_text, text_color=trend_color)\n"
  },
  {
    "url": "YukBF5FO-NIFTY-5m-15m-Smart-Money-CE-PE-High-WinRate",
    "name": "NIFTY 5m/15m Smart Money CE/PE â€“ High WinRate",
    "description": "nice strategy for intraday NIFTY option trading.  It works best on 5 minute time frame on NIFTY Index Chart \n",
    "image_url": "YukBF5FO",
    "author": "yaduvanshipravesh",
    "likes": 28,
    "type": "strategy",
    "created": "2025-12-01",
    "updated": "2025-12-01",
    "source": "//@version=6\r\nstrategy(\"NIFTY 5m/15m Smart Money CE/PE â€“ High WinRate\",\r\n     shorttitle = \"NIFTY_SMV_HW\",\r\n     overlay = true,\r\n     pyramiding = 0,\r\n     initial_capital = 100000,\r\n     default_qty_type = strategy.percent_of_equity,\r\n     default_qty_value = 100,\r\n     process_orders_on_close = true)\r\n\r\n//==================== 1. TIMEFRAME-AWARE TUNING ====================//\r\n\r\nint tfMult = timeframe.isminutes ? timeframe.multiplier : 5\r\n\r\n// Auto-tuned parameters for 5m vs 15m\r\nint   swingLen     = tfMult <= 5 ? 10 : 6          // swing window in bars\r\nfloat rrMultiple   = tfMult <= 5 ? 1.8 : 2.0       // TP = RR * swing\r\nint   volLookback  = tfMult <= 5 ? 80 : 60         // SMV lookback\r\nfloat buyFactor    = tfMult <= 5 ? 2.2 : 2.0       // stricter on 5m\r\nfloat sellFactor   = tfMult <= 5 ? 2.2 : 2.0\r\nfloat minAtrPoints = tfMult <= 5 ? 8.0 : 12.0      // skip dead volatility\r\n\r\n// Trend & filters (work well for both TFs)\r\nint   emaFastLen   = 50\r\nint   emaSlowLen   = tfMult <= 5 ? 200 : 150\r\nint   rsiLength    = 14\r\nint   volSmaLen    = 20\r\nfloat minVolFac    = 1.0\r\n\r\n// Trade control\r\nint   maxTradesPerDay = input.int(5, \"Max Trades Per Day\", minval = 1)\r\n\r\n// Session window\r\nstring sessionTF = input.session(\"0915-1530\", \"Trading Session (Exchange Time)\")\r\n\r\n//==================== 2. TIME / SESSION LOGIC ====================//\r\n\r\nbool inSession = not na(time(timeframe.period, sessionTF))\r\n\r\nint h = hour(time)\r\nint m = minute(time)\r\n\r\n// avoid first 5m & last 20m\r\nbool afterOpen    = h > 9 or (h == 9 and m >= 20)\r\nbool beforeClose  = h < 15 or (h == 15 and m <= 10)\r\nbool canTradeTime = inSession and afterOpen and beforeClose\r\n\r\n// trade counter\r\nint  curDay  = dayofmonth(time)\r\nint  prevDay = dayofmonth(time[1])\r\nbool newDay  = curDay != prevDay\r\n\r\nvar int tradesToday = 0\r\nif newDay\r\n    tradesToday := 0\r\n\r\nbool canTradeCount = tradesToday < maxTradesPerDay\r\n\r\n//==================== 3. CORE INDICATORS ====================//\r\n\r\nfloat emaFast = ta.ema(close, emaFastLen)\r\nfloat emaSlow = ta.ema(close, emaSlowLen)\r\n\r\nbool trendUp   = emaFast > emaSlow and close > emaFast\r\nbool trendDown = emaFast < emaSlow and close < emaFast\r\n\r\nfloat rsiVal  = ta.rsi(close, rsiLength)\r\nfloat volSma  = ta.sma(volume, volSmaLen)\r\nbool  highVol = volume > volSma * minVolFac\r\n\r\nfloat atrVal  = ta.atr(14)\r\nbool  atrOK   = atrVal >= minAtrPoints\r\n\r\n// Candle quality: avoid dojis & crazy exhaustion bars\r\nfloat barRange   = high - low\r\nfloat body       = math.abs(close - open)\r\nfloat bodyRatio  = barRange > 0 ? body / barRange : 0.0\r\nfloat minBodyRat = 0.30\r\nbool  goodBody   = bodyRatio >= minBodyRat\r\n\r\nfloat maxRangeAtrMult = 3.0\r\nbool  notExhaustion   = atrVal > 0 ? barRange <= maxRangeAtrMult * atrVal : true\r\n\r\n//==================== 4. SMART MONEY VOLUME SPLIT ====================//\r\n\r\nfloat range_i = high - low\r\nfloat buyVol  = range_i == 0.0 ? volume * 0.5 : volume * ((close - low) / range_i)\r\nfloat sellVol = range_i == 0.0 ? volume * 0.5 : volume * ((high - close) / range_i)\r\n\r\nfloat buySma  = ta.sma(buyVol,  volLookback)\r\nfloat sellSma = ta.sma(sellVol, volLookback)\r\n\r\nbool highBuy  = buyVol  > buySma  * buyFactor\r\nbool highSell = sellVol > sellSma * sellFactor\r\n\r\nbool bullCandle = close > open\r\nbool bearCandle = close < open\r\n\r\nbool isAbsorption   = highBuy  and bullCandle   and buyVol  > sellVol\r\nbool isDistribution = highSell and bearCandle   and sellVol > buyVol\r\n\r\n//==================== 5. ENTRY CONDITIONS ====================//\r\n\r\n// RSI regime: long only with bullish RSI, short only with bearish RSI\r\nbool longRegime  = rsiVal > 50 and rsiVal < 70\r\nbool shortRegime = rsiVal < 50 and rsiVal > 30\r\n\r\nbool rawLong  = trendUp   and longRegime  and highVol and atrOK and goodBody and notExhaustion and isAbsorption\r\nbool rawShort = trendDown and shortRegime and highVol and atrOK and goodBody and notExhaustion and isDistribution\r\n\r\nbool longSignal  = canTradeTime and canTradeCount and rawLong  and strategy.position_size == 0\r\nbool shortSignal = canTradeTime and canTradeCount and rawShort and strategy.position_size == 0\r\n\r\n//==================== 6. SWING-BASED EXIT ENGINE ====================//\r\n\r\nfloat swingLow  = ta.lowest(low,  swingLen)\r\nfloat swingHigh = ta.highest(high, swingLen)\r\n\r\n// Long entries\r\nif longSignal\r\n    float slL  = swingLow\r\n    float riskL = close - slL\r\n    float tpL  = close + riskL * rrMultiple\r\n    if riskL > 0\r\n        strategy.entry(\"Long\", strategy.long)\r\n        strategy.exit(\"L-Exit\", from_entry = \"Long\", stop = slL, limit = tpL)\r\n        tradesToday += 1\r\n\r\n// Short entries\r\nif shortSignal\r\n    float slS   = swingHigh\r\n    float riskS = slS - close\r\n    float tpS   = close - riskS * rrMultiple\r\n    if riskS > 0\r\n        strategy.entry(\"Short\", strategy.short)\r\n        strategy.exit(\"S-Exit\", from_entry = \"Short\", stop = slS, limit = tpS)\r\n        tradesToday += 1\r\n\r\n// Momentum early exit for safety\r\nif strategy.position_size > 0\r\n    // lock in profit / cut if momentum fades\r\n    if ta.crossunder(rsiVal, 55)\r\n        strategy.close(\"Long\")\r\n\r\nif strategy.position_size < 0\r\n    if ta.crossover(rsiVal, 45)\r\n        strategy.close(\"Short\")\r\n\r\n// Hard exit shortly before close\r\nbool flattenNow = h == 15 and m >= 10 and inSession\r\nif flattenNow and strategy.position_size != 0\r\n    strategy.close(\"Long\")\r\n    strategy.close(\"Short\")\r\n\r\n//==================== 7. VISUALS & ALERTS ====================//\r\n\r\nplot(emaFast, color = color.orange, title = \"EMA Fast (50)\")\r\nplot(emaSlow, color = color.blue,   title = \"EMA Slow\")\r\n\r\nplotshape(longSignal,  title=\"Buy CE\", style=shape.labelup,   location=location.belowbar,\r\n          color=color.green, text=\"Buy CE\", textcolor=color.white, size=size.tiny)\r\nplotshape(shortSignal, title=\"Buy PE\", style=shape.labeldown, location=location.abovebar,\r\n          color=color.red,   text=\"Buy PE\", textcolor=color.white, size=size.tiny)\r\n\r\nalertcondition(longSignal,  title=\"Buy CE Signal\", message=\"Buy NIFTY CE (SMV High WinRate)\")\r\nalertcondition(shortSignal, title=\"Buy PE Signal\", message=\"Buy NIFTY PE (SMV High WinRate)\")\r\n"
  },
  {
    "url": "Y6cGGA73-Session-Opening-Range-Breakout-ORBO",
    "name": "Session Opening Range Breakout (ORBO)",
    "description": "This strategy automates a classic Opening Range Breakout (ORBO) approach: it builds a price range for the first minutes after the market opens, then looks for strong breakouts above or below that range to catch early directional moves.\n\n Concept \nThe idea behind ORBO is simple:\n \n The first minutes after the session open are often highly informative.\n Price forms an â€œopening rangeâ€ that acts as a mini support/resistance zone.\n A clean breakout beyond this zone can lead to high-momentum moves.\n \nThis script turns that logic into a fully backtestable strategy in TradingView.\n\n How the strategy works \n Opening Range Session \n \n Default session: 09:30â€“09:50 (exchange time)\n During this window, the script tracks:\n \n \n orHigh â†’ highest high within the session\n orLow â†’ lowest low within the session\n \nThis forms your Opening Range for the day.\n\n Breakout Logic (after the window ends) \nOnce the defined session ends:\n Long Entry: \nIf the close crosses above the Opening Range High (orHigh),\n  â†’ strategy.entry(\"OR Long\", strategy.long) is triggered. \n Short Entry: \nIf the close crosses below the Opening Range Low (orLow),\n  â†’ strategy.entry(\"OR Short\", strategy.short) is triggered. \nOnly one opening range per day is considered, which keeps the logic clean and easy to interpret.\n\n Daily Reset \n \n At the start of a new trading day, the script resets:\n \n \n orHigh := na\n orLow := na\n \n \n A fresh Opening Range is then built using the next sessionâ€™s 09:30â€“09:50 candles.\n \nThis ensures entries are always based on todayâ€™s structure, not yesterdayâ€™s.\n\n Visuals & Inputs \n Inputs: \n \n Opening range session â†’ default: \"0930-0950\"\n Show OR levels â†’ toggle visibility of OR High / Low lines\n Fill range body â†’ optional shaded zone between OR High and OR Low\n \n Chart visuals: \n \n A green line marks the Opening Range High.\n A red line marks the Opening Range Low.\n Optional yellow fill highlights the entire OR zone.\n Background shading during the session shows when the range is currently being built.\n \nThese visuals make it easy to see:\n \n Where the OR sits relative to current price\n How clean / noisy the breakout was\n How often price respects or rejects the opening zone\n \n Backtesting & Optimization \nBecause this is written as a strategy():\nYou can use TradingViewâ€™s Strategy Tester to view:\n \n Win rate\n Net profit\n Drawdown\n Profit factor\n Equity curve\n \n Ideas to experiment with: \n \n Change the session window (e.g., 09:15â€“09:45, 10:00â€“10:30)\n Apply to different:\n Markets: indices, FX, crypto, stocks\n Timeframes: 1m / 5m / 15m\n \n Add your own: \n \n Stop Loss & Take Profit levels\n Time filters (only trade certain days / times)\n Volatility filters (e.g., ATR, range size thresholds)\n Higher-timeframe trend filter (e.g., only take longs above 200 EMA)\n",
    "image_url": "Y6cGGA73",
    "author": "AIScripts",
    "likes": 49,
    "type": "strategy",
    "created": "2025-12-01",
    "updated": "2025-12-01",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// Â© AIScripts\n\n//@version=6\nstrategy(\"Session Opening Range Breakout (ORBO)\",\n     overlay           = true,\n     initial_capital   = 100000,\n     default_qty_type  = strategy.percent_of_equity,\n     default_qty_value = 10,\n     commission_type   = strategy.commission.percent,\n     commission_value  = 0.01)\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// Inputs\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\norSession = input.session(\"0930-0950\", \"Opening range session\")\nshowRange = input.bool(true, \"Show OR levels\")\nfillRange = input.bool(true, \"Fill range body\")\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// Session & day detection\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\ninSession = not na(time(timeframe.period, orSession))\nisNewDay  = ta.change(time(\"D\")) != 0\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// Track Opening Range High / Low\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nvar float orHigh = na\nvar float orLow  = na\n\n// Reset OR levels at the start of a new day\nif isNewDay\n    orHigh := na\n    orLow  := na\n\n// Build opening range during the session\nif inSession\n    orHigh := na(orHigh) ? high : math.max(orHigh, high)\n    orLow  := na(orLow)  ? low  : math.min(orLow, low)\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// Breakout logic (after OR session ends)\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nsessionFinished = not inSession and not na(orHigh) and not na(orLow)\n\nlongBreak  = sessionFinished and ta.crossover(close, orHigh)\nshortBreak = sessionFinished and ta.crossunder(close, orLow)\n\nif longBreak\n    strategy.entry(\"OR Long\", strategy.long)\n\nif shortBreak\n    strategy.entry(\"OR Short\", strategy.short)\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// Visuals\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nplotOrHigh = plot(\n     showRange ? orHigh : na,\n     title = \"OR High\",\n     color = color.new(color.green, 0),\n     style = plot.style_linebr)\n\nplotOrLow = plot(\n     showRange ? orLow : na,\n     title = \"OR Low\",\n     color = color.new(color.red, 0),\n     style = plot.style_linebr)\n\n// Global-scope fill (required in Pine)\nfillColor = showRange and fillRange ? color.new(color.yellow, 90) : na\nfill(plotOrHigh, plotOrLow, fillColor)\n\n// Highlight while OR is being built\nbgcolor(inSession ? color.new(color.yellow, 92) : na)\n"
  },
  {
    "url": "6I0p6rPM-AliceTears-Grid",
    "name": "AliceTears Grid",
    "description": "AliceTears Grid is a customizable Mean Reversion system designed to capitalize on market volatility during specific trading sessions. Unlike standard grid bots that place blind limit orders, this strategy establishes a daily or session-based \"Baseline\" and looks for price over-extensions to fade the move back to the mean.\n\nThis strategy is best suited for ranging markets (sideways accumulation) or specific forex sessions (e.g., Asian Session or NY/London overlap) where price tends to revert to the opening price.\n\nðŸ›  How It Works\n1. The Baseline & Grid Generation At the start of every session (or the daily open), the script records the Open price. It then projects visual grid lines above and below this price based on your Step % input.\n\nExample: If the Open is $100 and Step is 1%, lines are drawn at $101, $102, $99, $98, etc.\n\n2. Entry Logic: Reversal Mode This script features a \"Reversal Mode\" (enabled by default) to filter out \"falling knives.\"\n\nStandard Grid: Buys immediately when price touches the line.\n\nAliceTears Logic: Waits for the price to breach a grid level and then close back inside towards the mean. This confirms a potential rejection of that level before entering.\n\n3. Exit Logic\n\nTarget Profit: The primary target is the previous grid level (Mean Reversion).\n\nTrailing Stop: If the price continues moving in your favor, a trailing stop activates to maximize the run.\n\nStop Loss: A manual percentage-based stop loss is available to prevent deep drawdowns in trending markets.\n\nâš™ï¸ Key Features\nVisual Grid: Automatically draws entry levels on the chart for the current session, helping you visualize where the \"math\" is waiting for price.\n\nTimezone & Session Control: Includes a custom Timezone Offset tool. You can trade specific hours (e.g., 09:30â€“16:00) regardless of your chart's UTC setting.\n\nGrid Management: Independent logic for Long and Short grids with pyramiding capabilities.\n\nSafety Filters: Options to force-close trades at the end of the session to avoid overnight gaps.\n\nâš ï¸ Risk Warning\nPlease Read Before Using: This is a Counter-Trend / Grid Strategy.\n\nPros: High win rate in sideways/ranging markets.\n\nCons: In strong trending markets (parabolic pumps or crashes), this strategy will add to losing positions (\"catch a falling knife\").\n\nRecommendation: Always use the Stop Loss and Date Filter inputs. Do not run this on highly volatile assets without strict risk management parameters.\n\nSettings Guide\nEntry Reversal Mode: Keep checked for safer entries. Uncheck for aggressive limit-order style execution.\n\nGrid Step (%): The distance between lines. For Forex, use lower values (0.1% - 0.5%). For Crypto, use higher values (1.0% - 3.0%).\n\nUTC Offset: Adjust this to align the Session Hours with your target market (e.g., -5 for New York).\n\nThis script is open source. Feel free to use it for educational purposes or modify it to fit your trading style.",
    "image_url": "6I0p6rPM",
    "author": "AliceTears",
    "likes": 14,
    "type": "strategy",
    "created": "2025-12-02",
    "updated": "2025-12-02",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// Â© AliceTears\r\n\r\n//@version=6\r\nstrategy('AliceTears Grid', overlay = true, process_orders_on_close = true, pyramiding = 100, initial_capital = 1000, commission_value = 0.025, default_qty_type = strategy.cash, default_qty_value = 10)\r\n\r\n// ==========================\r\n// ======= INPUTS ===========\r\n// ==========================\r\ngrp_strat = 'Strategy Settings'\r\ni_reversalMode = input.bool(true, 'Entry Reversal Mode', group = grp_strat)\r\ni_stepPercent = input.float(1.0, 'Grid Step (%)', minval = 0.1, step = 0.1, group = grp_strat)\r\ni_maxSteps = input.int(20, 'Max Grid Lines per Side', group = grp_strat)\r\n\r\ngrp_exit = 'Exit Logic'\r\ni_tpReversal = input.bool(true, 'TP Reversal Mode', group = grp_exit)\r\ni_useTrailing = input.bool(true, 'Use Trailing TP', group = grp_exit)\r\ni_trailOffset = input.float(1, 'Trailing Offset (%)', step = 0.1, group = grp_exit)\r\n\r\ngrp_safe = 'Safety'\r\ni_useStopLoss = input.bool(false, 'Use Manual Stop Loss', group = grp_safe)\r\ni_slMultiplier = input.float(2.0, 'Stop Loss Multiplier', group = grp_safe)\r\ni_closeEOD = input.bool(false, 'Force Close at End of Session', group = grp_safe)\r\n\r\ngrp_time = 'Session & Timezone'\r\ni_useDateFilter = input.bool(false, 'Use Date Range', group = grp_time)\r\ni_startDate = input.time(timestamp('01 Jan 2024 00:00 +0000'), 'Start Date', group = grp_time)\r\ni_endDate = input.time(timestamp('01 Jan 2030 00:00 +0000'), 'End Date', group = grp_time)\r\n\r\ni_useSession = input.bool(false, 'Use Custom Session', group = grp_time)\r\ni_marketSession = input.session('0930-1600', 'Session Hours', group = grp_time, tooltip = 'Format: HHMM-HHMM')\r\n// UPDATED: Float input for Timezone\r\ni_utcOffset = input.float(0.0, 'UTC Timezone Offset', minval = -12.0, maxval = 14.0, step = 0.25, group = grp_time, tooltip = 'Example: New York = -5 (or -4 DST), India = 5.5, Thailand = 7')\r\n\r\n\r\n// ==========================\r\n// ====== CALCULATIONS ======\r\n// ==========================\r\n[dOpen, dHigh, dLow, dTime] = request.security(syminfo.tickerid, 'D', [open, high, low, time], lookahead = barmerge.lookahead_on)\r\n\r\n// --- 1. TIMEZONE HELPER ---\r\n// Converts float (e.g., 5.5) to GMT String (\"GMT+0530\")\r\noffsetToZone(off) =>\r\n    hrs = math.floor(math.abs(off))\r\n    mins = math.round((math.abs(off) - hrs) * 60)\r\n    sign = off >= 0 ? '+' : '-'\r\n    // Manual zero padding\r\n    hStr = str.tostring(hrs)\r\n    hStr := str.length(hStr) < 2 ? '0' + hStr : hStr\r\n    mStr = str.tostring(mins)\r\n    mStr := str.length(mStr) < 2 ? '0' + mStr : mStr\r\n    'GMT' + sign + hStr + mStr\r\n\r\n// Get the formatted Timezone String\r\ntzString = offsetToZone(i_utcOffset)\r\n\r\n// --- 2. SESSION STATE LOGIC ---\r\n// We pass the calculated Timezone String to the time() function\r\ninSessionString = time(timeframe.period, i_marketSession, tzString)\r\nisInSession = i_useSession ? not na(inSessionString) : true\r\n\r\n// Detect Start of Session\r\nisSessionStart = false\r\nif i_useSession\r\n    isSessionStart := isInSession and (na(inSessionString[1]) or dayofmonth(time) != dayofmonth(time[1]))\r\n    isSessionStart\r\nelse\r\n    isSessionStart := dayofmonth(time) != dayofmonth(time[1])\r\n    isSessionStart\r\n\r\n// --- 3. CALCULATE SESSION DURATION (For Drawing) ---\r\n// Instead of guessing the timestamp, we calculate length in ms: (EndHour - StartHour)\r\ngetSessionDuration() =>\r\n    int dur = 86400000 // Default 24h\r\n    if i_useSession\r\n        array<string> parts = str.split(i_marketSession, '-')\r\n        if array.size(parts) >= 2\r\n            // Parse Start\r\n            sStr = array.get(parts, 0)\r\n            sH = str.tonumber(str.substring(sStr, 0, 2))\r\n            sM = str.tonumber(str.substring(sStr, 2, 4))\r\n            startMins = sH * 60 + sM\r\n\r\n            // Parse End\r\n            eStr = array.get(parts, 1)\r\n            eH = str.tonumber(str.substring(eStr, 0, 2))\r\n            eM = str.tonumber(str.substring(eStr, 2, 4))\r\n            endMins = eH * 60 + eM\r\n\r\n            // Calculate Diff\r\n            diffMins = 0\r\n            if endMins >= startMins\r\n                diffMins := int(endMins - startMins)\r\n                diffMins\r\n            else // Overnight session (e.g. 2200 to 0200)\r\n                diffMins := int(1440 - startMins + endMins)\r\n                diffMins\r\n\r\n            dur := diffMins * 60 * 1000\r\n            dur\r\n    dur\r\n\r\n// --- 4. STORE SESSION VARIABLES ---\r\nvar float sessionBasePrice = na\r\nvar int sessionStartTime = na\r\nvar int sessionEndTime = na\r\nvar int sessionLen = na\r\n\r\nif isSessionStart\r\n    sessionBasePrice := i_useSession ? open : dOpen\r\n    sessionStartTime := time\r\n    sessionLen := getSessionDuration()\r\n    sessionEndTime := sessionStartTime + sessionLen\r\n    sessionEndTime\r\n\r\n// ==========================\r\n// ======= DRAWING ==========\r\n// ==========================\r\nvar array<line> gridLines = array.new_line()\r\ndrawLine(t1, p1, t2, p2, col) =>\r\n    l = line.new(x1 = t1, y1 = p1, x2 = t2, y2 = p2, xloc = xloc.bar_time, color = col, width = 3)\r\n    array.push(gridLines, l)\r\n\r\nif array.size(gridLines) > 400\r\n    for i = 0 to 50 by 1\r\n        line.delete(array.shift(gridLines))\r\n\r\nif isSessionStart\r\n    // Draw Base (Blue)\r\n    drawLine(sessionStartTime, sessionBasePrice, sessionEndTime, sessionBasePrice, color.blue)\r\n\r\n    // Draw UP Grid\r\n    for i = 1 to i_maxSteps by 1\r\n        p = sessionBasePrice * (1 + i_stepPercent / 100 * i)\r\n        drawLine(sessionStartTime, p, sessionEndTime, p, color.new(color.teal, 50))\r\n        if p > dHigh\r\n            break\r\n\r\n    // Draw DOWN Grid\r\n    for i = 1 to i_maxSteps by 1\r\n        p = sessionBasePrice * (1 - i_stepPercent / 100 * i)\r\n        drawLine(sessionStartTime, p, sessionEndTime, p, color.new(color.red, 50))\r\n        if p < dLow\r\n            break\r\n\r\n// ==========================\r\n// ====== TRADING LOGIC =====\r\n// ==========================\r\ninDateRange = i_useDateFilter ? time >= i_startDate and time <= i_endDate : true\r\ncanTrade = inDateRange and isInSession\r\n\r\n// Reset Arrays\r\nvar array<bool> triggeredShorts = array.new_bool(i_maxSteps + 1, false)\r\nvar array<bool> triggeredLongs = array.new_bool(i_maxSteps + 1, false)\r\nvar array<bool> breachedShorts = array.new_bool(i_maxSteps + 1, false)\r\nvar array<bool> breachedLongs = array.new_bool(i_maxSteps + 1, false)\r\n\r\nif isSessionStart\r\n    array.fill(triggeredShorts, false)\r\n    array.fill(triggeredLongs, false)\r\n    array.fill(breachedShorts, false)\r\n    array.fill(breachedLongs, false)\r\n\r\ncalcStop(isLong, price) =>\r\n    float sl = na\r\n    if i_useStopLoss\r\n        dist = price * i_stepPercent / 100 * i_slMultiplier\r\n        sl := isLong ? price - dist : price + dist\r\n        sl\r\n    sl\r\n\r\n// ------------------------------------\r\n// 1. SHORT SIDE\r\n// ------------------------------------\r\nfor i = 1 to i_maxSteps by 1\r\n    entryPrice = sessionBasePrice * (1 + i_stepPercent / 100 * i)\r\n    targetPrice = sessionBasePrice * (1 + i_stepPercent / 100 * (i - 1))\r\n    slPrice = calcStop(false, entryPrice)\r\n\r\n    idShort = 'Short_' + str.tostring(i)\r\n    bool hasTraded = array.get(triggeredShorts, i)\r\n    bool entryTriggered = false\r\n\r\n    if not hasTraded and canTrade\r\n        if i_reversalMode\r\n            if close[1] > entryPrice\r\n                array.set(breachedShorts, i, true)\r\n            if array.get(breachedShorts, i) and close < entryPrice\r\n                strategy.entry(idShort, strategy.short, comment = 'RevSell ' + str.tostring(i) + '%')\r\n                array.set(triggeredShorts, i, true)\r\n                entryTriggered := true\r\n                entryTriggered\r\n        else\r\n            if ta.crossover(close, entryPrice)\r\n                strategy.entry(idShort, strategy.short, comment = 'Sell ' + str.tostring(i) + '%')\r\n                array.set(triggeredShorts, i, true)\r\n                entryTriggered := true\r\n                entryTriggered\r\n\r\n    if strategy.position_size < 0\r\n        offsetTicks = close * (i_trailOffset / 100) / syminfo.mintick\r\n        if i_tpReversal\r\n            bool reversalTriggered = close[1] < targetPrice and close > targetPrice\r\n            if reversalTriggered\r\n                if i_useTrailing\r\n                    strategy.exit('TrailS_Rev_' + str.tostring(i), from_entry = idShort, trail_price = close, trail_offset = offsetTicks, stop = slPrice, comment = 'RevTrail')\r\n                else\r\n                    strategy.close(idShort, comment = 'RevTP')\r\n        else\r\n            if i_useTrailing\r\n                strategy.exit('TrailS_Std_' + str.tostring(i), from_entry = idShort, trail_price = targetPrice, trail_offset = offsetTicks, stop = slPrice, comment = 'StdTrail')\r\n            else\r\n                if close <= targetPrice\r\n                    strategy.close(idShort, comment = 'TP')\r\n\r\n    if i_useStopLoss and close >= slPrice\r\n        strategy.close(idShort, comment = 'SL')\r\n\r\n// ------------------------------------\r\n// 2. LONG SIDE\r\n// ------------------------------------\r\nfor i = 1 to i_maxSteps by 1\r\n    entryPrice = sessionBasePrice * (1 - i_stepPercent / 100 * i)\r\n    targetPrice = sessionBasePrice * (1 - i_stepPercent / 100 * (i - 1))\r\n    slPrice = calcStop(true, entryPrice)\r\n\r\n    idLong = 'Long_' + str.tostring(i)\r\n    bool hasTraded = array.get(triggeredLongs, i)\r\n    bool entryTriggered = false\r\n\r\n    if not hasTraded and canTrade\r\n        if i_reversalMode\r\n            if close[1] < entryPrice\r\n                array.set(breachedLongs, i, true)\r\n            if array.get(breachedLongs, i) and close > entryPrice\r\n                strategy.entry(idLong, strategy.long, comment = 'RevBuy -' + str.tostring(i) + '%')\r\n                array.set(triggeredLongs, i, true)\r\n                entryTriggered := true\r\n                entryTriggered\r\n        else\r\n            if ta.crossunder(close, entryPrice)\r\n                strategy.entry(idLong, strategy.long, comment = 'Buy -' + str.tostring(i) + '%')\r\n                array.set(triggeredLongs, i, true)\r\n                entryTriggered := true\r\n                entryTriggered\r\n\r\n    if strategy.position_size > 0\r\n        offsetTicks = close * (i_trailOffset / 100) / syminfo.mintick\r\n        if i_tpReversal\r\n            bool reversalTriggered = close[1] > targetPrice and close < targetPrice\r\n            if reversalTriggered\r\n                if i_useTrailing\r\n                    strategy.exit('TrailL_Rev_' + str.tostring(i), from_entry = idLong, trail_price = close, trail_offset = offsetTicks, stop = slPrice, comment = 'RevTrail')\r\n                else\r\n                    strategy.close(idLong, comment = 'RevTP')\r\n        else\r\n            if i_useTrailing\r\n                strategy.exit('TrailL_Std_' + str.tostring(i), from_entry = idLong, trail_price = targetPrice, trail_offset = offsetTicks, stop = slPrice, comment = 'StdTrail')\r\n            else\r\n                if close >= targetPrice\r\n                    strategy.close(idLong, comment = 'TP')\r\n\r\n    if i_useStopLoss and close <= slPrice\r\n        strategy.close(idLong, comment = 'SL')\r\n\r\n\r\n// ==========================\r\n// ==== END OF SESSION EXIT =\r\n// ==========================\r\nsessionExited = i_useSession and isInSession[1] and not isInSession\r\nif i_closeEOD and sessionExited\r\n    strategy.close_all(comment = 'Session Close')\r\n\r\n// ==========================\r\n// ====== STAT TRACKER ======\r\n// ==========================\r\n// We use 'var' to keep these values persistent across the whole history\r\nvar int maxLongStack  = 0\r\nvar int maxShortStack = 0\r\n\r\n// Check current active trades\r\nint currentTrades = strategy.opentrades\r\n\r\n// Update Peak Counts\r\nif strategy.position_size > 0\r\n    // If we are Long, check if this is a new record for Longs\r\n    maxLongStack := math.max(maxLongStack, currentTrades)\r\nelse if strategy.position_size < 0\r\n    // If we are Short, check if this is a new record for Shorts\r\n    maxShortStack := math.max(maxShortStack, currentTrades)\r\n    \r\n// ==========================\r\n// ====== DASHBOARD =========\r\n// ==========================\r\nvar table infoTable = table.new(position.bottom_right, 2, 7, border_width=1) // Increased rows to 6\r\n\r\n// -- Header --\r\ntable.cell(infoTable, 0, 0, \"AliceTears Grid\", bgcolor=color.new(color.blue, 20), text_color=color.white)\r\ntable.cell(infoTable, 1, 0, \"Stats\", bgcolor=color.new(color.blue, 20), text_color=color.white)\r\n\r\n// -- Row 1: Current Open Trades --\r\ntable.cell(infoTable, 0, 1, \"Active Trades\", bgcolor=color.black, text_color=color.white)\r\ntable.cell(infoTable, 1, 1, str.tostring(strategy.opentrades), bgcolor=color.black, text_color=color.white)\r\n\r\n// -- Row 2: Current Open Trades --\r\ntable.cell(infoTable, 0, 2, \"AVG Price\", bgcolor=color.black, text_color=color.white)\r\ntable.cell(infoTable, 1, 2, str.tostring(strategy.position_avg_price), bgcolor=color.black, text_color=color.white)\r\n\r\n// -- Row 3: Max Simultaneous LONGS --\r\n// We color this RED if it gets too high (e.g., > 10) as a warning\r\ncolor longWarn = maxLongStack > 10 ? color.red : color.black\r\ntable.cell(infoTable, 0, 3, \"Max Long Stack\", bgcolor=longWarn, text_color=color.white)\r\ntable.cell(infoTable, 1, 3, str.tostring(maxLongStack), bgcolor=longWarn, text_color=color.white)\r\n\r\n// -- Row 4: Max Simultaneous SHORTS --\r\ncolor shortWarn = maxShortStack > 10 ? color.red : color.black\r\ntable.cell(infoTable, 0, 4, \"Max Short Stack\", bgcolor=shortWarn, text_color=color.white)\r\ntable.cell(infoTable, 1, 4, str.tostring(maxShortStack), bgcolor=shortWarn, text_color=color.white)\r\n\r\n// -- Row 5: Net Profit --\r\nc_pnl = strategy.netprofit\r\nc_col = c_pnl >= 0 ? color.teal : color.red\r\ntable.cell(infoTable, 0, 5, \"Total Profit\", bgcolor=color.black, text_color=color.white)\r\ntable.cell(infoTable, 1, 5, str.tostring(c_pnl, format.mintick), bgcolor=c_col, text_color=color.white)\r\n\r\n// -- Row 6: Drawdown Warning --\r\n// Showing Max Drawdown is also very useful for Grid users\r\nmax_dd = strategy.max_drawdown\r\ntable.cell(infoTable, 0, 6, \"Max Drawdown\", bgcolor=color.maroon, text_color=color.white)\r\ntable.cell(infoTable, 1, 6, str.tostring(max_dd, format.mintick), bgcolor=color.maroon, text_color=color.white)"
  },
  {
    "url": "bt8HJINE",
    "name": "Vinz Win BTC â€“ STRATEGY AUTO 1m",
    "description": "ðŸš€  VinzWin BTC Strategy â€“ BTC Scalping AUTO 1 min \n\nThe VinzWin strategy is based on a simple and highly effective price action pattern:\n\nâœ… 2 red candles followed by 1 green candle\nâœ… Doji filter set to 0\nâœ… Trading exclusively on BTC\nâœ… Session from 12:00 to 12:00 (24/7)\nâœ… Fixed Risk/Reward at 1:2\nâœ… Stop Loss set in fixed â‚¬ amount\nâœ… Automatic risk management based on the Stop Loss\n\n On every trade: \nThe Stop Loss is defined in fixed euros,\nThe Take Profit is always set at twice the risk,\nThe lot size is automatically adjusted to market conditions,\nensuring clean, stable, and fully controlled risk management.\n\nðŸ“Š Multi-year backtests are available and show truly outstanding results, with strong consistency and an excellent profit/loss ratio.\n\nðŸ‘‰ A simple, mechanical strategy with no over-optimization, perfectly suited for BTC scalping with fully controlled capital management in euros.\n",
    "image_url": "bt8HJINE",
    "author": "Vincent-Aina",
    "likes": 117,
    "type": "strategy",
    "created": "2025-12-01",
    "updated": "2025-12-01",
    "source": "//@version=5\nstrategy(\"Vinz Win â€“ STRATEGY 1m AUTO\", \n     overlay=true, \n     initial_capital=100000,\n     default_qty_type=strategy.fixed,\n     currency=currency.EUR)\n\n// ==============================\n// PARAMÃˆTRES STRATÃ‰GIE\n// ==============================\nsessionTime   = input.session(\"0000-0900\", \"Session Asiatique\")\nslBufferPips  = input.float(5.0, \"Buffer SL (pips)\", step=0.1)\nminBodyRatio  = input.float(0.4, \"Filtre Anti-Doji\")\n\nriskEUR       = input.float(500, \"Risque par trade (â‚¬)\", step=10)\n\n// âœ… RR LIBRE (1.2 / 2 / 3 / 4 / 6.7 etc.)\nrrMult        = input.float(2.0, \"Risk / Reward (Libre)\", step=0.1)\n\n// ==============================\n// SESSION\n// ==============================\ninSession = not na(time(timeframe.period, sessionTime))\n\n// ==============================\n// LOGIQUE BOUGIES (IDENTIQUE)\n// ==============================\nisRed(i)   => close[i] < open[i]\nisGreen(i) => close[i] > open[i]\n\nbodySize  = math.abs(close - open)\nrangeSize = high - low\nbodyRatio = rangeSize > 0 ? bodySize / rangeSize : 0\n\nisValidGreen = isGreen(0) and bodyRatio >= minBodyRatio\ntwoReds      = isRed(1) and isRed(2)\nsignalBuy    = inSession and twoReds and isValidGreen\n\n// ==============================\n// CALCUL PRIX\n// ==============================\npipValue   = syminfo.mintick * 10\nentryPrice = close\nslPrice    = low - (slBufferPips * pipValue)\nriskPoints = entryPrice - slPrice\n\n// ==============================\n// ADAPTATION AUTOMATIQUE DES LOTS\n// (Risque en euros inchangÃ©)\n// ==============================\nvaluePerPoint = syminfo.pointvalue\nriskEURperLot = riskPoints * valuePerPoint\npositionSize  = riskEURperLot > 0 ? riskEUR / riskEURperLot : 0.01\n\n// ==============================\n// TP BASÃ‰ SUR RR LIBRE\n// (SL inchangÃ©, TP en fonction du RR)\n// ==============================\ntpPoints = (riskEUR * rrMult) / (valuePerPoint * positionSize)\ntpPrice  = entryPrice + tpPoints\n\n// ==============================\n// 1 SEUL TRADE Ã€ LA FOIS\n// ==============================\ncanTrade = strategy.position_size == 0\n\n// ==============================\n// ENTRÃ‰E AUTOMATIQUE\n// ==============================\nif signalBuy and canTrade\n    strategy.entry(\"BUY\", strategy.long, qty=positionSize)\n    strategy.exit(\"TP/SL\", \"BUY\", stop=slPrice, limit=tpPrice)\n"
  },
  {
    "url": "Mvzuufcb-inyerneck-Quiet-Bottom-Hunter-v1-5-VERIFIED-SIGNALS",
    "name": "inyerneck Quiet Bottom Hunter v1.5 â€” VERIFIED SIGNALS",
    "description": "Quiet Bottom Hunter v1.5 â€” 85%+ Rebound Setup\n\nDesigned for new traders who want the highest-probability, lowest-stress small-cap entries.\n\nTriggers only when ALL of these line up:\nâ€¢ â€“20% to â€“80% from 90-day high (slow bleed, not crash)\nâ€¢ Volume â‰¤80% of 50-day average (dry, no panic selling left)\nâ€¢ RSI(14) â‰¤35 (deep oversold)\nâ€¢ 2+ consecutive green or flat days at the low (quiet bottom confirmed)\n\nFires roughly 1â€“3 times per month on most small caps (<$2B).\nBacktested 2024â€“2025: 85% win rate, avg +32% rebound, max DD ~11%.\n\nTiny green â€œQBâ€ arrow = entry signal.\nUse 10â€“20% position size. Works best on daily charts.\n\nPublic script â€” code visible.\nuse on 1 day or 4 hr chart. mid term swings, NOT day trades\nNo spam. No chasing. Just big, calm rebounds.",
    "image_url": "Mvzuufcb",
    "author": "oogabooger",
    "likes": 15,
    "type": "strategy",
    "created": "2025-11-30",
    "updated": "2025-11-30",
    "source": "//@version=5\nstrategy(\"Quiet Bottom Hunter v1.5 â€” VERIFIED SIGNALS\", overlay=true,\n         default_qty_type=strategy.percent_of_equity, default_qty_value=10)\n\n// SETTINGS (balanced for 2â€“3 signals/month, 85% win rate)\nlookbackHigh = input.int(90, \"Days to measure drop from high\")\nminDropPct   = input.float(-20.0, \"Min % drop from high\", step=1.0)\nmaxDropPct   = input.float(-80.0, \"Max % drop\", step=1.0)\nvolDry       = input.float(0.8, \"Volume â‰¤ x of 50-day avg\", step=0.1)\nrsiLevel     = input.int(35, \"RSI oversold level\")\ngreenStreak  = input.int(2, \"Consecutive green/flat days\")\n\n// CORE LOGIC\nhigh90      = ta.highest(high, lookbackHigh)\ndropPct     = (close - high90) / high90 * 100\nisBleeding  = dropPct <= minDropPct and dropPct >= maxDropPct\n\nvolRatio    = volume / ta.sma(volume, 50)\nisDry       = volRatio <= volDry\n\nrsiBottom   = ta.rsi(close, 14) <= rsiLevel\n\n// FIXED GREEN STREAK (uses current open)\nstreak = 0\nstreak := close >= open ? streak[1] + 1 : 0\nbottomConfirmed = streak >= greenStreak\n\nlongCondition = isBleeding and isDry and rsiBottom and bottomConfirmed and barstate.isconfirmed\n\nif (longCondition)\n    strategy.entry(\"QuietBottom\", strategy.long)\n\nstrategy.exit(\"QB Exit\", \"QuietBottom\", profit=40, loss=12)\n\n// TINY ARROW\nplotshape(longCondition, location=location.belowbar, color=#00ff9d, style=shape.triangleup, size=size.tiny, text=\"QB\")\n\nalertcondition(longCondition, title=\"Quiet Bottom Found\", \n     message=\"{\\\"content\\\":\\\"â™»ï¸ QUIET BOTTOM {{ticker}} @ {{close}} | {{interval}} â€” 85% rebound setup\\\"}\")\n"
  },
  {
    "url": "gvWKYJnN-The-Oracle-Dip-Top-Adaptive-Sniper-Hakan-Yorganci",
    "name": "The Oracle: Dip & Top Adaptive Sniper [Hakan Yorganci]",
    "description": "â–ˆ OVERVIEW\nThe Oracle: Dip & Top Adaptive Sniper is a precision-focused trend trading strategy designed to solve the biggest problem in swing trading: Timing.\nMost trend-following strategies chase price (\"FOMO\"), buying when the asset is already overextended. The Oracle takes a different approach. It adopts a \"Sniper\" mentality: it identifies a strong macro trend but patiently waits for a Mean Reversion (pullback) to execute an entry at a discounted price.\nBy combining the structural strength of Moving Averages (SMA 50/200) with the momentum precision of RSI and the volatility filtering of ADX, this script filters out noise and targets high-probability setups.\n\nâ–ˆ HOW IT WORKS\nThis strategy operates on a strictly algorithmic protocol known as \"The Yorganci Protocol,\" which involves three distinct phases: Filter, Target, and Execute.\n1. The Macro Filter (Trend Identification)\n * SMA 200 Rule: By default, the strategy only scans for buy signals when the price is trading above the 200-period Simple Moving Average. This ensures we are always trading in the direction of the long-term bull market.\n * Adaptive Switch: A new feature allows users to toggle the Only Buy Above SMA 200? filter OFF. This enables the strategy to hunt for oversold bounces (dead cat bounces) even during bearish or neutral market structures.\n2. The Volatility Filter (ADX Integration)\n * Sideways Protection: One of the main weaknesses of moving average strategies is \"whipsaw\" losses during choppy, ranging markets.\n * Solution: The Oracle utilizes the ADX (Average Directional Index). It will BLOCK any trade entry if the ADX is below the threshold (Default: 20). This ensures capital is only deployed when a genuine trend is present.\n3. The Sniper Entry (Buying the Dip)\n * Instead of buying on breakout strength (e.g., RSI > 60), The Oracle waits for the RSI Moving Average to dip into the \"Value Zone\" (Default: 45) and cross back up. This technique allows for tighter stops and higher Risk/Reward ratios compared to traditional breakout systems.\n\nâ–ˆ EXIT STRATEGY\nThe Oracle employs a dynamic dual-exit mechanism to maximize gains and protect capital:\n * Take Profit (The Peak): The strategy monitors RSI heat. When the RSI Moving Average breaches the Overbought Threshold (Default: 75), it signals a \"Take Profit\", securing gains near the local top before a potential reversal.\n * Stop Loss (Trend Invalidated): If the market structure fails and the price closes below the 50-period SMA, the position is immediately closed to prevent deep drawdowns.\n\nâ–ˆ SETTINGS & CONFIGURATION\n * Moving Averages: Fully customizable lengths for Support (SMA 50) and Trend (SMA 200).\n * Trend Filter: Checkbox to enable/disable the \"Bull Market Only\" rule.\n * RSI Thresholds:\n   * Sniper Buy Level: Adjustable (Default: 45). Lower values = Deeper dips, fewer trades.\n   * Peak Sell Level: Adjustable (Default: 75). Higher values = Longer holds, potentially higher profit.\n * ADX Filter: Checkbox to enable/disable volatility filtering.\n\nâ–ˆ BEST PRACTICES\n * Timeframe: Designed primarily for 4H (4-Hour) charts for swing trading. It can also be used on 1H for more frequent signals.\n * Assets: Highly effective on trending assets such as Bitcoin (BTC), Ethereum (ETH), and high-volume Altcoins.\n * Risk Warning: This strategy is designed for \"Long Only\" spot or leverage trading. Always use proper risk management.\n\nâ–ˆ CREDITS\n * Original Concept: Inspired by the foundational work of Murat Besiroglu (@muratkbesiroglu).\n * Algorithm Development & Enhancements: Developed by Hakan Yorganci (@hknyrgnc).\n   * Modifications include: Integration of ADX filters, Mean Reversion entry logic (RSI Dip), and Dynamic Peak Profit taking.",
    "image_url": "gvWKYJnN",
    "author": "hknyrgnc",
    "likes": 25,
    "type": "strategy",
    "created": "2025-11-30",
    "updated": "2025-11-30",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// Â© hknyrgnc\r\n\r\n//@version=6\r\n// This script is an enhanced version of the original strategy.\r\n// Developer: Hakan Yorganci\r\n// Strategy Name: The Yorganci Protocol\r\n\r\nstrategy(\"The Oracle: Dip & Top Adaptive Sniper [Hakan Yorganci]\", \r\n     overlay           = true, \r\n     initial_capital   = 1000, \r\n     pyramiding        = 0, \r\n     default_qty_type  = strategy.percent_of_equity, \r\n     default_qty_value = 100)\r\n\r\n//=== INPUTS (SETTINGS) ===//\r\n// SMA Settings\r\nsmaLenShort  = input.int(50,  \"Support SMA (50)\", group=\"Moving Averages\")\r\nsmaLenLong   = input.int(200, \"Main Trend SMA (200)\", group=\"Moving Averages\")\r\n\r\n// NEW: Trend Filter Switch\r\nuseTrendFilter = input.bool(true, \"Only Buy Above SMA 200?\", group=\"Filters\", tooltip=\"Uncheck this to trade RSI dips even in a downtrend.\")\r\n\r\n// RSI Settings\r\nrsiLen       = input.int(14,  \"RSI Length\", group=\"Oscillators\")\r\nrsiMaLen     = input.int(9,   \"RSI Moving Average\", group=\"Oscillators\")\r\n\r\n// Sniper Entry/Exit Settings\r\nbuyRsiDipLvl   = input.float(45.0, \"Sniper Buy Level (RSI MA)\", tooltip=\"Buys when RSI MA crosses over this level.\")\r\nsellRsiPeakLvl = input.float(75.0, \"Profit Take Level (RSI MA)\", tooltip=\"Takes profit when RSI MA reaches this level.\")\r\n\r\n// ADX Settings (Sideways Market Filter)\r\nuseAdx       = input.bool(true, \"Use ADX Power Filter?\", group=\"Filters\")\r\nadxThreshold = input.int(20, \"ADX Threshold (Min Strength)\", group=\"Filters\")\r\n\r\n//=== CALCULATIONS ===//\r\n// SMA\r\nsma50  = ta.sma(close, smaLenShort)\r\nsma200 = ta.sma(close, smaLenLong)\r\n\r\n// RSI and RSI MA\r\nrsiVal   = ta.rsi(close, rsiLen)\r\nrsiMaVal = ta.sma(rsiVal, rsiMaLen)\r\n\r\n// ADX\r\n[diplus, diminus, adxVal] = ta.dmi(14, 14)\r\nadxCondition = useAdx ? (adxVal > adxThreshold) : true\r\n\r\n//=== POSITION CHECK ===//\r\ninLong = strategy.position_size > 0\r\n\r\n//=== STRATEGY LOGIC ===//\r\n\r\n// FIX: Calculate crossover independently\r\nrsiCrossUp = ta.crossover(rsiMaVal, buyRsiDipLvl)\r\n\r\n// 1. LONG ENTRY (SNIPER ENTRY)\r\n// Condition A: Trend Filter (Optional). If unchecked, we ignore the SMA 200 rule.\r\ntrendCondition = useTrendFilter ? (close > sma200) : true\r\n\r\n// Full Entry Logic\r\nlongEntryCond = trendCondition and adxCondition and rsiCrossUp and not inLong\r\n\r\n// 2. EXIT CONDITIONS\r\n// Scenario A: TAKE PROFIT\r\ntakeProfitCond = rsiMaVal > sellRsiPeakLvl\r\n\r\n// Scenario B: STOP LOSS\r\nstopLossCond = close < sma50\r\n\r\n// Exit Trigger\r\nlongExitCond = (takeProfitCond or stopLossCond) and inLong\r\n\r\n//=== ORDER EXECUTION ===//\r\nif longEntryCond\r\n    strategy.entry(\"HY Sniper\", strategy.long, comment=\"Sniper Entry\")\r\n\r\nif longExitCond\r\n    exitReason = takeProfitCond ? \"Profit (Peak)\" : \"Stop (SMA 50)\"\r\n    strategy.close(\"HY Sniper\", comment=exitReason)\r\n\r\n//=== VISUALIZATION ===//\r\n// Plotting the SMAs\r\nplot(sma50,  title = \"Support Line (50)\",    color = color.orange,   linewidth = 2)\r\nplot(sma200, title = \"Trend Line (200)\",     color = color.blue, linewidth = 3)\r\n\r\n// Visual Signals\r\nplotshape(longEntryCond, title=\"Sniper Signal\", style=shape.labelup, location=location.belowbar, color=color.green, text=\"BUY\", textcolor=color.white)\r\nplotshape(takeProfitCond and inLong, title=\"Take Profit\", style=shape.labeldown, location=location.abovebar, color=color.purple, text=\"TP\", textcolor=color.white)\r\nplotshape(stopLossCond and inLong and not takeProfitCond, title=\"Stop Loss\", style=shape.labeldown, location=location.abovebar, color=color.red, text=\"SELL\", textcolor=color.white)"
  },
  {
    "url": "g1QEIDEt-AB-CD-Fibonacci-Strategy-One-Trade-at-a-Time",
    "name": "AB=CD Fibonacci Strategy (One Trade at a Time)",
    "description": "\nAB=CD Fibonacci Strategy - Harmonic Pattern Trading Bot\nDescription\nAn automated trading strategy that identifies and trades the classic AB=CD harmonic pattern, one of the most reliable geometric price formations in technical analysis. This strategy detects perfectly proportioned Fibonacci retracement setups and executes trades with precise risk-reward management.\nHow It Works\nThe indicator scans for the AB=CD pattern structure:\n\nLeg AB: Initial swing from pivot point A to pivot point B\nLeg BC: Retracement to point C (customizable Fibonacci levels)\nLeg CD: Mirror projection equal to the AB leg length\n\nWhen price touches point D, the strategy automatically enters a position with predefined take-profit and stop-loss levels based on your risk-reward ratio.\nKey Features\n\nOne Trade at a Time: Ensures disciplined position management by allowing only one active trade per pattern\nCustomizable Fibonacci Retracement: Set your preferred retracement range for point C (default 50% - 78.6%)\nRisk-Reward Control: Adjust stop-loss and take-profit multiples to match your trading plan\nVisual Pattern Display: Clear labeling of A, B, C, D points with pattern lines for easy identification\nBoth Directions: Identifies bullish and bearish AB=CD patterns automatically\n\nIdeal For\n\nSwing traders on higher timeframes (4H, Daily, Weekly)\nHarmonic pattern traders seeking automation\nTraders wanting precise entry and exit rules based on Fibonacci geometry\nThose looking to reduce emotional trading and increase consistency\n\nDefault Settings Optimized For\n\nNASDAQ futures and currency pairs\nMedium timeframe analysis\nConservative risk management (10% position size per trade)",
    "image_url": "g1QEIDEt",
    "author": "julioperez75955",
    "likes": 18,
    "type": "strategy",
    "created": "2025-11-30",
    "updated": "2025-11-30",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// Â© julioperez75955\r\n\r\n//@version=5\r\nstrategy(\"AB=CD Fibonacci Strategy (One Trade at a Time)\", overlay=true, margin_long=100, margin_short=100, default_qty_type=strategy.percent_of_equity, default_qty_value=10)\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Inputs\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nswingLen = input.int(5, \"Pivot Strength\", minval=2)\r\nfibRetraceMin = input.float(0.5, \"Min Retracement (C)\", step=0.01)\r\nfibRetraceMax = input.float(0.786, \"Max Retracement (C)\", step=0.01)\r\ntpRR = input.float(1.5, \"Take Profit (R multiple)\", step=0.1)\r\nslRR = input.float(0.75, \"Stop Loss (R multiple)\", step=0.1)\r\nshowLines = input.bool(true, \"Show ABCD Lines\")\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Pivots\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\npivotHigh = ta.pivothigh(high, swingLen, swingLen)\r\npivotLow = ta.pivotlow(low, swingLen, swingLen)\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Variables persistentes\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nvar float A = na\r\nvar float B = na\r\nvar float C = na\r\nvar float D = na\r\nvar int A_bar = na\r\nvar int B_bar = na\r\nvar int C_bar = na\r\nvar int D_bar = na\r\nvar string pattern = na\r\nvar bool patternFound = false\r\nvar bool tradeActive = false  // ðŸ”’ Controla una operaciÃ³n a la vez\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// DetecciÃ³n de patrÃ³n AB=CD (solo si no hay operaciÃ³n abierta)\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nif not tradeActive\r\n    if not na(pivotHigh)\r\n        A := high[swingLen]\r\n        A_bar := bar_index[swingLen]\r\n    if not na(pivotLow)\r\n        B := low[swingLen]\r\n        B_bar := bar_index[swingLen]\r\n\r\n    if not na(A) and not na(B)\r\n        abRange = math.abs(A - B)\r\n\r\n        // ðŸ”¹ Bullish\r\n        if A > B\r\n            retrace = (high - B) / abRange\r\n            if retrace >= fibRetraceMin and retrace <= fibRetraceMax\r\n                C := high\r\n                C_bar := bar_index\r\n                D := C - abRange\r\n                D_bar := bar_index\r\n                pattern := \"bullish\"\r\n                patternFound := true\r\n\r\n        // ðŸ”¸ Bearish\r\n        if B > A\r\n            retrace = (B - low) / abRange\r\n            if retrace >= fibRetraceMin and retrace <= fibRetraceMax\r\n                C := low\r\n                C_bar := bar_index\r\n                D := C + abRange\r\n                D_bar := bar_index\r\n                pattern := \"bearish\"\r\n                patternFound := true\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Dibujar el patrÃ³n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nif showLines and patternFound\r\n    line.new(A_bar, A, B_bar, B, color=color.new(color.blue, 0))\r\n    line.new(B_bar, B, C_bar, C, color=color.new(color.blue, 0))\r\n    line.new(C_bar, C, D_bar, D, color=color.new(color.purple, 0), style=line.style_dotted)\r\n    label.new(A_bar, A, \"A\", style=label.style_label_left)\r\n    label.new(B_bar, B, \"B\", style=label.style_label_left)\r\n    label.new(C_bar, C, \"C\", style=label.style_label_left)\r\n    label.new(D_bar, D, \"D\", style=label.style_label_left, color=color.new(color.purple, 0))\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Entrada al tocar D (solo si no hay operaciÃ³n abierta)\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nif not tradeActive and patternFound\r\n    if pattern == \"bullish\" and close <= D\r\n        strategy.entry(\"Long AB=CD\", strategy.long)\r\n        tradeActive := true\r\n    if pattern == \"bearish\" and close >= D\r\n        strategy.entry(\"Short AB=CD\", strategy.short)\r\n        tradeActive := true\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// TP/SL y reinicio tras cierre\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nif tradeActive\r\n    if strategy.position_size > 0\r\n        strategy.exit(\"Exit Long\", \"Long AB=CD\", profit=tpRR * slRR * 100, loss=slRR * 100)\r\n    if strategy.position_size < 0\r\n        strategy.exit(\"Exit Short\", \"Short AB=CD\", profit=tpRR * slRR * 100, loss=slRR * 100)\r\n\r\n    // Cuando se cierra la operaciÃ³n, reiniciar todo\r\n    if strategy.position_size == 0 and strategy.closedtrades > 0\r\n        A := na\r\n        B := na\r\n        C := na\r\n        D := na\r\n        pattern := na\r\n        patternFound := false\r\n        tradeActive := false\r\n"
  },
  {
    "url": "XkjJJIJ2-Mean-Reversion-BB-Z-Score-RSI-EMA200-TP-at-Opposite-Z",
    "name": "Mean Reversion â€” BB + Z-Score + RSI + EMA200 (TP at Opposite Z)",
    "description": "This is a systematic mean-reversion framework for index futures and other liquid assets.\nThis strategy combines Bollinger Bands, Z-Score dislocation, RSI extremes, and a trend-filtering EMA200 to capture short-term mean-reversion inefficiencies in NQ1!. It is designed for high-volatility conditions and uses a precise exit model based on opposite-side Z-Score targets and dynamic mid-band failure detection.\nðŸ” Entry Logic (Mean Reversion) : \nThe strategy enters trades only when multiple confluence signals align:\nLong Setup\nPrice at or below the lower Bollinger Band\nZ-Score â‰¤ â€“Threshold (deep statistical deviation)\nRSI â‰¤ oversold level\nPrice below the EMA-200 (countertrend mean-reversion only)\nCooldown must be completed\nNo open position\nShort Setup\nPrice at or above the upper Bollinger Band\nZ-Score â‰¥ Threshold\nRSI â‰¥ overbought level\nPrice above the EMA-200\nCooldown complete\nNo open position\nThis multi-signal gate filters out weak reversions and focuses on mature dislocations.\nðŸŽ¯ Take-Profit Model: Opposite-Side Z-Score Target : \nOnce in a trade, take-profit is set by solving for the price where the Z-Score reaches the opposite side:\nLong TP = Z = +Threshold\nShort TP = Z = â€“Threshold\nThis creates a symmetric statistical exit based on reverting to equilibrium plus overshoot.\nðŸ›¡ï¸ Stop-Loss System (Volatility-Aware) : \nStop losses combine:\nA fixed base stop (points)\nA standard-deviation volatility component\nThis adapts the SL to regime changes and avoids being shaken out during rare volatility spikes.\nâ³ Half-Life Exit : \nIf a trade has not reverted within a fixed number of bars, it automatically closes.\nThis prevents â€œmean-reversion trapsâ€ during trending periods.\nðŸ“‰ Advanced Mid-Band Exit Logic (BB Basis Failure) : \nThis is the unique feature of the system.\nAfter entry:\nWait for price to cross the Bollinger Basis (middle band) in the direction of the mean.\nStart a 5-bar delay timer.\nAfter 5 bars, the strategy becomes â€œarmed.â€\nOnce armed:\nIf price fails back through the mean, exit immediately.\nIntrabar exits trigger precisely (with tick-level precision if Bar Magnifier is enabled).\nThis protects profits and exits trades at the first sign of mean-failure.\nâ±ï¸ Cooldown System : \nAfter each closed trade, a cooldown period prevents immediate re-entry.\nThis avoids clustering and improves statistical independence of trades.\nðŸ–¥ï¸ What This Strategy Is Best For : \nHigh-volatility intraday NQ conditions\nStatistical mean reversion with structured confluence\nTraders who want clean, rule-based entries\nAvoiding trend-day traps using EMA and half-life logic\nðŸ“Š Included Visual Elements : \nBollinger Bands (Upper, Basis, Lower)\nBUY/SELL markers at signal generation\nOptional alerts for automated monitoring\nðŸš€ Summary : \nThis is a precision mean-reversion system built around volatility bands, statistical dislocation, and price-behavior confirmation. By combining Z-Score, RSI, EMA200 filtering, and a sophisticated mid-band failure exit, this model captures high-probability reversions while avoiding the common pitfalls of naive band-touch systems.",
    "image_url": "XkjJJIJ2",
    "author": "spyqdia",
    "likes": 7,
    "type": "strategy",
    "created": "2025-11-30",
    "updated": "2025-11-30",
    "source": "//@version=6\nstrategy(\"NQ1! Mean Reversion â€” BB + Z-Score + RSI + EMA200 (TP at Opposite Z)\",\n     overlay=true,\n     initial_capital=100000,\n     default_qty_type=strategy.fixed,\n     default_qty_value=1,\n     calc_on_order_fills=true,\n     calc_on_every_tick=true)\n\n// === INPUTS ===\nbbLength      = input.int(25, \"Bollinger Band Length\")\nbbMult        = input.float(2.0, \"BB Multiplier\")\nzThreshold    = input.float(2.25, \"Z-Score Threshold\")\nrsiPeriod     = input.int(14, \"RSI Period\")\nrsiLongMax    = input.int(30, \"RSI Oversold Threshold\")\nrsiShortMin   = input.int(70, \"RSI Overbought Threshold\")\nemaLen        = input.int(200, \"EMA Length (trend filter)\")\ncooldownBars  = input.int(12, \"Cooldown Bars After Exit\")\nslBase        = input.float(75, \"Base Stop Loss (points)\")\nslMult        = input.float(2.25, \"Stop Loss Multiplier (Ïƒ)\")\nhalfLifeBars  = input.int(35, \"Max Bars to Hold\")\n\n// === INDICATORS ===\nbbBasis = ta.sma(close, bbLength)\nbbStd   = ta.stdev(close, bbLength)\nbbUpper = bbBasis + bbMult * bbStd\nbbLower = bbBasis - bbMult * bbStd\nzScore  = (close - bbBasis) / bbStd\n\n// Volatility-based stop loss with base + volatility component\nsl_points = slBase + (slMult * bbStd)\n\nrsi = ta.rsi(close, rsiPeriod)\nemaFilter = ta.ema(close, emaLen)\n\n// === COOLDOWN LOGIC ===\nvar int lastExitBar = na\nif (strategy.closedtrades > 0)\n    lastExitBar := strategy.closedtrades.exit_bar_index(strategy.closedtrades - 1)\ncooldownActive = (bar_index - nz(lastExitBar, -cooldownBars) < cooldownBars)\n\n// === ENTRY CONDITIONS (Mean Reversion) ===\n// LONG: oversold, below lower BB, negative Z, below EMA\nlongCondition = not cooldownActive and close <= bbLower and zScore <= -zThreshold and rsi <= rsiLongMax and close < emaFilter and strategy.position_size == 0\n\n// SHORT: overbought, above upper BB, positive Z, above EMA\nshortCondition = not cooldownActive and close >= bbUpper and zScore >= zThreshold and rsi >= rsiShortMin and close > emaFilter and strategy.position_size == 0\n\n// === TARGET PRICES FROM OPPOSITE Z-SCORE ===\n// Solve (price - bbBasis) / bbStd = targetZ  =>  price = bbBasis + targetZ * bbStd\nlongTP  = bbBasis + zThreshold * bbStd   // opposite of -zThreshold\nshortTP = bbBasis - zThreshold * bbStd   // opposite of +zThreshold\n\n// === TRADE EXECUTION ===\n// Note: TP/SL are set using values from the signal bar (static like original).\nif (longCondition)\n    strategy.entry(\"Long\", strategy.long)\n    strategy.exit(\"Long Exit\", \"Long\", stop=close - sl_points, limit=longTP)\n\nif (shortCondition)\n    strategy.entry(\"Short\", strategy.short)\n    strategy.exit(\"Short Exit\", \"Short\", stop=close + sl_points, limit=shortTP)\n\n// === TIME-BASED EXIT (Half-Life) ===\n// Close position if it hasn't reverted after halfLifeBars\nif strategy.position_size != 0 and (bar_index - strategy.opentrades.entry_bar_index(strategy.opentrades - 1)) > halfLifeBars\n    strategy.close(\"Long\")\n    strategy.close(\"Short\")\n\n// === BB MIDDLE CROSS 5-BAR EXIT LOGIC ===\n// After entry, once price crosses the EXACT BB middle line (bbBasis), wait 5 bars, then exit exactly on mean failure\nvar int crossAfterEntryBar = na\nvar bool exitMonitorActive = false\nentryBarIdx = strategy.opentrades > 0 ? strategy.opentrades.entry_bar_index(strategy.opentrades - 1) : na\n\n// Directional cross of bbBasis (BB middle)\nlongCrossNow = ta.crossover(close, bbBasis)   // Price crosses UP through middle\nshortCrossNow = ta.crossunder(close, bbBasis) // Price crosses DOWN through middle\n\n// Reset when flat\nif strategy.position_size == 0\n    crossAfterEntryBar := na\n    exitMonitorActive := false\n\n// Record first qualifying cross after entry\nif strategy.position_size > 0 and not na(entryBarIdx) and bar_index > entryBarIdx and na(crossAfterEntryBar) and longCrossNow\n    crossAfterEntryBar := bar_index\nif strategy.position_size < 0 and not na(entryBarIdx) and bar_index > entryBarIdx and na(crossAfterEntryBar) and shortCrossNow\n    crossAfterEntryBar := bar_index\n\n// Arm exactly on the 6th candle (i.e., 5 full bars after the cross bar)\nbarsSinceCross = not na(crossAfterEntryBar) ? (bar_index - crossAfterEntryBar) : na\narmNow = not na(barsSinceCross) and barsSinceCross == 5\nif armNow\n    exitMonitorActive := true\n\n// Exact exits at the mean re-test (bar-close precision)\nif strategy.position_size > 0 and exitMonitorActive and ta.crossunder(close, bbBasis)\n    strategy.close(\"Long\", comment=\"BB Middle crossunder exit (long)\")\nif strategy.position_size < 0 and exitMonitorActive and ta.crossover(close, bbBasis)\n    strategy.close(\"Short\", comment=\"BB Middle crossover exit (short)\")\n\n// Intrabar-precise exits: place a dynamic stop at the mean once armed.\n// With calc_on_every_tick and Bar Magnifier enabled, this triggers exactly when price trades through the mean.\nif strategy.position_size > 0 and exitMonitorActive\n    strategy.exit(\"Long Mean Exit\", \"Long\", stop=bbBasis)\nif strategy.position_size < 0 and exitMonitorActive\n    strategy.exit(\"Short Mean Exit\", \"Short\", stop=bbBasis)\n\n// === PLOTS ===\n// Bollinger Bands\nplot(bbUpper, \"BB Upper\", color=color.new(color.red, 0), linewidth=2)\nplot(bbBasis, \"BB Basis\", color=color.new(color.gray, 0), linewidth=2)\nplot(bbLower, \"BB Lower\", color=color.new(color.green, 0), linewidth=2)\n\n// Entry Signals\nplotshape(longCondition, title=\"Long Signal\", location=location.belowbar, color=color.new(color.green, 0), style=shape.labelup, text=\"BUY\", size=size.normal)\nplotshape(shortCondition, title=\"Short Signal\", location=location.abovebar, color=color.new(color.red, 0), style=shape.labeldown, text=\"SELL\", size=size.normal)\n// === ALERTS ===\nalertcondition(longCondition, title=\"Mean Reversion Long\", message=\"Mean Reversion Long setup\")\nalertcondition(shortCondition, title=\"Mean Reversion Short\", message=\"Mean Reversion Short setup\")"
  },
  {
    "url": "2JdMHxRQ-SSL-ST-Strategy-Accuracy-Enhanced-v2-0-Parser-Safe",
    "name": "SSL ST Strategy â€“ Accuracy Enhanced v2.0 (Parser Safe)",
    "description": "This  strategy is built to identify high-probability trend breakouts using a combination of SSL Channel, Baseline, Hull / EMA signals, and Candle-based confirmations.\nThe goal is to filter noise, avoid false breakouts, and enter only when the trend is truly shifting.\n\nThis strategy identifies high-probability trend breakouts using SSL Channel, Baseline, Hull/EMA, and candle\nconfirmations. \n1. SSL shows trend shift when price breaks high/low levels. \n2. Baseline filters direction (price above = buy bias, below = sell bias). \n3. Hull/EMA gives early momentum confirmation. \n4. Candle breakout ensures real momentum (breaks previous high/low). \n5. Optional filters: ATR, reversal logic, continuation entries. \n6. Exits occur on SSL flip, baseline cross, or weakness\n\nDisclaimer\n\nThis strategy is provided strictly for educational and informational purposes only. It does not guarantee any profit, nor does it protect against losses of any kind. Financial markets are inherently unpredictable, and any market movement can only be assumed or estimated with a probability that is never guaranteed and can often be no better than a 50/50 chance.\n\nBy using this strategy, you acknowledge that all trading decisions are made solely at your own risk. I am not liable for any profits, losses, or financial consequences incurred by anyone using or relying on this strategy. Always perform your own research, manage your risk responsibly, and consult with a qualified financial advisor before trading.\n",
    "image_url": "2JdMHxRQ",
    "author": "vinodkummarnair",
    "likes": 13,
    "type": "strategy",
    "created": "2025-11-30",
    "updated": "2025-11-30",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// Â© vinodkummarnair\n\n//@version=6\nstrategy(\"SSL ST Strategy â€“ Accuracy Enhanced v2.0 (Parser Safe)\", overlay=true, default_qty_type=strategy.percent_of_equity, default_qty_value=10)\n\n// -----------------------------\n// INPUTS\n// -----------------------------\nmaType        = input.string(\"HMA\", \"Baseline/SSL MA Type\", options=[\"SMA\",\"EMA\",\"DEMA\",\"TEMA\",\"WMA\",\"LSMA\",\"HMA\"])\nlen           = input.int(60, \"SSL / Baseline Length\", minval=1)\natrLen        = input.int(14, \"ATR Length\", minval=1)\natrSLmult     = input.float(1.8, \"ATR Stop-Loss Multiplier\", minval=0.1)\nexitPoints    = input.float(25, \"Fixed Target (Points)\", minval=0.0)\nexitMode      = input.string(\"Both\", \"Exit Mode\", options=[\"Crossover Only\",\"Points Only\",\"Both\"])\nuseHTFfilter  = input.bool(true, \"Use Higher-Timeframe Trend Filter?\")\nhtf           = input.timeframe(\"240\", \"Higher Timeframe (Trend Filter)\")\ninvert        = input.bool(false, \"Invert Buy/Sell Signals?\")\nshowBaseline  = input.bool(true, \"Show Baseline?\")\nshowSSL       = input.bool(true, \"Show SSL1?\")\n\n// -----------------------------\n// MA ENGINE (function)\n// -----------------------------\nma_func(src, length, type) =>\n    if type == \"SMA\"\n        ta.sma(src, length)\n    else if type == \"EMA\"\n        ta.ema(src, length)\n    else if type == \"DEMA\"\n        2 * ta.ema(src, length) - ta.ema(ta.ema(src, length), length)\n    else if type == \"TEMA\"\n        3 * (ta.ema(src, length) - ta.ema(ta.ema(src, length), length)) + ta.ema(ta.ema(ta.ema(src, length), length), length)\n    else if type == \"WMA\"\n        ta.wma(src, length)\n    else if type == \"LSMA\"\n        ta.linreg(src, length, 0)\n    else\n        // HMA: ensure integer args\n        intLenHalf = int(length / 2)\n        intSqrtLen = int(math.sqrt(math.max(length, 1)))\n        ta.wma(2 * ta.wma(src, intLenHalf) - ta.wma(src, length), intSqrtLen)\n\n// -----------------------------\n// SSL CALC\n// -----------------------------\nmaHigh   = ma_func(high, len, maType)\nmaLow    = ma_func(low, len, maType)\nbaseline = ma_func(close, len, maType)\n\nvar int hlv = 1\nhlv := close > maHigh ? 1 : close < maLow ? -1 : nz(hlv[1], 1)\nssl1 = hlv < 0 ? maHigh : maLow\nsslSmooth = ta.ema(ssl1, 2)  // small smoothing to reduce tiny flips\n\n// -----------------------------\n// HIGHER-TF TREND FILTER\n// -----------------------------\n// Request HTF baseline from higher timeframe\nhtfBaseline = request.security(syminfo.tickerid, htf, ma_func(close, len, maType))\nbullHTF = close > htfBaseline\nbearHTF = close < htfBaseline\n\n// -----------------------------\n// SIGNALS\n// -----------------------------\nbuySignalBase  = ta.crossunder(sslSmooth, baseline)\nsellSignalBase = ta.crossover(sslSmooth, baseline)\n\nbuySignal  = invert ? ta.crossover(sslSmooth, baseline) : buySignalBase\nsellSignal = invert ? ta.crossunder(sslSmooth, baseline) : sellSignalBase\n\nfilteredBuy  = useHTFfilter ? (buySignal and bullHTF) : buySignal\nfilteredSell = useHTFfilter ? (sellSignal and bearHTF) : sellSignal\n\n// -----------------------------\n// ATR SL & POINT TARGETS\n// -----------------------------\natr = ta.atr(atrLen)\n\n// compute point-exit using symbol tick size\nlongPointExit  = strategy.position_size > 0 and (close - strategy.position_avg_price) >= exitPoints * syminfo.mintick\nshortPointExit = strategy.position_size < 0 and (strategy.position_avg_price - close) >= exitPoints * syminfo.mintick\n\n// compute dynamic SL only when in position to avoid NaNs\nlongSL_calc  = strategy.position_size > 0 ? (strategy.position_avg_price - atrSLmult * atr) : na\nshortSL_calc = strategy.position_size < 0 ? (strategy.position_avg_price + atrSLmult * atr) : na\n\n// -----------------------------\n// ENTRIES\n// -----------------------------\nif filteredBuy\n    strategy.close(\"Short\")\n    strategy.entry(\"Long\", strategy.long)\n\nif filteredSell\n    strategy.close(\"Long\")\n    strategy.entry(\"Short\", strategy.short)\n\n// -----------------------------\n// EXITS\n// -----------------------------\n// Determine crossover exits\nlongExitCross  = ta.crossover(sslSmooth, baseline)\nshortExitCross = ta.crossunder(sslSmooth, baseline)\n\n// Build exit booleans in parser-safe way\nexitLong = false\nexitShort = false\n\n// Long exit logic\nif strategy.position_size > 0\n    // Crossover condition\n    cond1 = exitMode == \"Crossover Only\" and longExitCross\n    // Points condition\n    cond2 = exitMode == \"Points Only\" and longPointExit\n    // Both mode: either crossover or points\n    cond3 = exitMode == \"Both\" and (longExitCross or longPointExit)\n    // ATR SL condition\n    cond4 = not na(longSL_calc) and close <= longSL_calc\n    if cond1 or cond2 or cond3 or cond4\n        exitLong := true\n\n// Short exit logic\nif strategy.position_size < 0\n    cond1s = exitMode == \"Crossover Only\" and shortExitCross\n    cond2s = exitMode == \"Points Only\" and shortPointExit\n    cond3s = exitMode == \"Both\" and (shortExitCross or shortPointExit)\n    cond4s = not na(shortSL_calc) and close >= shortSL_calc\n    if cond1s or cond2s or cond3s or cond4s\n        exitShort := true\n\nif exitLong\n    strategy.close(\"Long\")\n\nif exitShort\n    strategy.close(\"Short\")\n\n// -----------------------------\n// PLOTS\n// -----------------------------\nplot(showBaseline ? baseline : na, \"Baseline\", color=color.new(color.orange, 0), linewidth=2)\nplot(showSSL ? ssl1 : na, \"SSL1\", color=color.new(color.blue, 0), linewidth=2)\nplot(strategy.position_size > 0 ? longSL_calc : na, \"Long SL\", color=color.new(color.red, 0), style=plot.style_line)\nplot(strategy.position_size < 0 ? shortSL_calc : na, \"Short SL\", color=color.new(color.red, 0), style=plot.style_line)\nplotshape(filteredBuy, title=\"BUY\", style=shape.triangleup, location=location.belowbar, color=color.green, size=size.small, text=\"BUY\")\nplotshape(filteredSell, title=\"SELL\", style=shape.triangledown, location=location.abovebar, color=color.red, size=size.small, text=\"SELL\")\n"
  },
  {
    "url": "bsI0LsNi",
    "name": "Ultra Reversion DCA Strategy with Manual Leverage - V.1",
    "description": "Ultra Reversion DCA Strategy with Manual Leverage - V.1\n\n2025-10-27",
    "image_url": "bsI0LsNi",
    "author": "TraderCloud_135",
    "likes": 72,
    "type": "strategy",
    "created": "2025-11-30",
    "updated": "2025-11-30",
    "source": "//@version=5\r\nstrategy(\"Ultra Reversion DCA Strategy with Manual Leverage - V.1\", shorttitle=\"Ultra Reversion DCA Strategy - V.1\", overlay=true, pyramiding=100)\r\n\r\n// --------------------------------------------------------------------------------------------------------------------}\r\n// í¬ì§€ì…˜ ì‚¬ì´ì§• ë°©ì‹ ì„¤ì •\r\n// --------------------------------------------------------------------------------------------------------------------{\r\nposition_sizing_mode = input.string(\"Martingale\", \"Position Sizing Mode\", options=[\"Martingale\", \"Equal Split\"], group=\"Position Sizing\")\r\ninitial_position_size = input.float(1.0, \"Initial Position Size\", minval=0.01, step=0.01, group=\"Position Sizing\")\r\n\r\n// --------------------------------------------------------------------------------------------------------------------}\r\n// ìˆ˜ë™ ë ˆë²„ë¦¬ì§€ ì„¤ì •\r\n// --------------------------------------------------------------------------------------------------------------------{\r\nmanual_leverage = input.float(1.0, \"Leverage\", minval=1.0, maxval=125.0, step=0.1, group=\"Leverage Settings\")\r\n\r\n// í˜„ìž¬ ì‚¬ìš© ë ˆë²„ë¦¬ì§€\r\ncurrent_leverage = manual_leverage\r\n\r\n// --------------------------------------------------------------------------------------------------------------------}\r\n// ê°•ì œ ì²­ì‚° ê°€ê²© ê³„ì‚° (ìžë™)\r\n// --------------------------------------------------------------------------------------------------------------------{\r\nvar float long_liquidation_price = na\r\nvar float short_liquidation_price = na\r\n\r\n// ê°•ì œ ì²­ì‚° ê°€ê²© ê³„ì‚° í•¨ìˆ˜ (ë ˆë²„ë¦¬ì§€ì— ë”°ë¥¸ ìžë™ ê³„ì‚°)\r\n// ì¼ë°˜ì ìœ¼ë¡œ ì„ ë¬¼ê±°ëž˜ì†Œì—ì„œëŠ” ë ˆë²„ë¦¬ì§€ ëŒ€ë¹„ ì•½ 95-98% ì§€ì ì—ì„œ ê°•ì œì²­ì‚°\r\ncalc_liquidation_price(entry_price, leverage, is_long) =>\r\n    liquidation_threshold = 0.95 // 95% ì§€ì ì—ì„œ ê°•ì œì²­ì‚° (5% ë§ˆì§„)\r\n    if is_long\r\n        entry_price * (1 - liquidation_threshold / leverage)\r\n    else\r\n        entry_price * (1 + liquidation_threshold / leverage)\r\n\r\n// --------------------------------------------------------------------------------------------------------------------}\r\n// Donchian Channels ì„¤ì •\r\n// --------------------------------------------------------------------------------------------------------------------{\r\ndc_length = input.int(240, minval=1, title=\"Donchian Length\")\r\ndc_offset = input.int(14, title=\"Donchian Offset\")\r\n\r\n// Donchian ì±„ë„ ê³„ì‚°\r\ndc_lower_raw = ta.lowest(dc_length)\r\ndc_upper_raw = ta.highest(dc_length)\r\n\r\n// ì˜¤í”„ì…‹ ì ìš©\r\ndc_lower = ta.valuewhen(bar_index, dc_lower_raw, dc_offset)\r\ndc_upper = ta.valuewhen(bar_index, dc_upper_raw, dc_offset)\r\ndc_basis = math.avg(dc_upper, dc_lower)\r\n\r\n// Donchian í”Œë¡¯\r\nplot(dc_basis, \"Basis\", color=color.rgb(255, 255, 255))\r\ndc_u = plot(dc_upper, \"Upper\", color=#f1ff29e5)\r\ndc_l = plot(dc_lower, \"Lower\", color=#f1ff29e5)\r\nfill(dc_u, dc_l, color=#f3f0210d, title=\"Background\")\r\n\r\ndc_is_below_lower = open < dc_lower\r\ndc_is_above_upper = open > dc_upper\r\n// ìº”ë“¤ ìƒ‰ìƒ ì„¤ì •\r\nbarcolor(dc_is_below_lower ? color.green : dc_is_above_upper ? color.red : na)\r\n\r\n// --------------------------------------------------------------------------------------------------------------------}\r\n// Parabolic RSI ì„¤ì •\r\n// --------------------------------------------------------------------------------------------------------------------{\r\nrsi_len = input.int(14, \"RSI Length\", group=\"RSI\")\r\nrsi_upper = input.int(75, \"Overbought Threshold\", inline=\"Threshold\", group=\"RSI\")\r\nrsi_lower = input.int(25, \"Oversold Threshold\", inline=\"Threshold\", group=\"RSI\")\r\n\r\ndisplay_sar = input.bool(true, \"SAR\", group=\"SAR\")\r\nsar_start = input.float(0.02, \"Start\", step=0.01, inline=\"sar\", group=\"SAR\")\r\nsar_inc = input.float(0.022, \"Increment\", step=0.01, inline=\"sar\", group=\"SAR\")\r\nsar_max = input.float(0.2, \"Maximum\", step=0.01, inline=\"sar\", group=\"SAR\")\r\ncolor_up = input.color(#EEA47F, \"\", inline=\"c\", group=\"SAR\")\r\ncolor_dn = input.color(#00539C, \"\", inline=\"c\", group=\"SAR\")\r\n\r\n// RSI ê³„ì‚°\r\nrsi = ta.rsi(close, rsi_len)\r\n\r\n// Parabolic SAR í•¨ìˆ˜\r\npine_sar(src, start, inc, max) =>\r\n    src_high = src + 1\r\n    src_low = src - 1\r\n    var float result = na\r\n    var float maxMin = na\r\n    var float acceleration = na\r\n    var bool isBelow = false\r\n    bool isFirstTrendBar = false\r\n    \r\n    if bar_index <= rsi_len + 2\r\n        if src > src[1]\r\n            isBelow := true\r\n            maxMin := src_high\r\n            result := src_low[1]\r\n        else\r\n            isBelow := false\r\n            maxMin := src_low\r\n            result := src_high[1]\r\n        isFirstTrendBar := true\r\n        acceleration := start\r\n    \r\n    result := nz(result[1], result) + acceleration * (maxMin - nz(result[1], result))\r\n    \r\n    if isBelow\r\n        if result > src_low\r\n            isFirstTrendBar := true\r\n            isBelow := false\r\n            result := math.max(src_high, maxMin)\r\n            maxMin := src_low\r\n            acceleration := start\r\n    else\r\n        if result < src_high\r\n            isFirstTrendBar := true\r\n            isBelow := true\r\n            result := math.min(src_low, maxMin)\r\n            maxMin := src_high\r\n            acceleration := start\r\n    \r\n    if not isFirstTrendBar\r\n        if isBelow\r\n            if src_high > maxMin\r\n                maxMin := src_high\r\n                acceleration := math.min(acceleration + inc, max)\r\n        else\r\n            if src_low < maxMin\r\n                maxMin := src_low\r\n                acceleration := math.min(acceleration + inc, max)\r\n    \r\n    if isBelow\r\n        result := math.min(result, src_low[1])\r\n        if bar_index > 1\r\n            result := math.min(result, src_low[2])\r\n    else\r\n        result := math.max(result, src_high[1])\r\n        if bar_index > 1\r\n            result := math.max(result, src_high[2])\r\n    \r\n    [result, isBelow]\r\n\r\n// Parabolic RSI ê³„ì‚°\r\n[sar_rsi, isBelow] = pine_sar(rsi, sar_start, sar_inc, sar_max)\r\n\r\n// ì‹ í˜¸ ê³„ì‚°\r\nsig_up = isBelow != isBelow[1] and isBelow and barstate.isconfirmed\r\nsig_dn = isBelow != isBelow[1] and not isBelow and barstate.isconfirmed\r\ns_sig_up = sig_up and sar_rsi <= rsi_lower\r\ns_sig_dn = sig_dn and sar_rsi >= rsi_upper\r\n\r\n// SAR ì‹œê°í™”\r\nvar sar = float(na)\r\nif display_sar\r\n    sar := isBelow != isBelow[1] ? na : sar_rsi\r\nsar_col = isBelow ? color_up : color_dn\r\n\r\n// RSI ì‹œê°í™”\r\nplotshape(s_sig_up, \"Chart Strong RSI Up\", shape.diamond, location.belowbar, size=size.small, color=sar_col, force_overlay=true)\r\nplotshape(s_sig_dn, \"Chart Strong RSI Down\", shape.diamond, location.abovebar, size=size.small, color=sar_col, force_overlay=true)\r\n\r\n// --------------------------------------------------------------------------------------------------------------------}\r\n// ì–‘ë°©í–¥ ë¶„í•  ë§¤ìˆ˜/ê³µë§¤ë„ ì „ëžµ (ë ˆë²„ë¦¬ì§€ & ê°•ì œì²­ì‚° ì ìš©)\r\n// --------------------------------------------------------------------------------------------------------------------{\r\n// í”¼ë¼ë¯¸ë”© ì œí•œ ì„¤ì •\r\nMAX_PYRAMID = input.int(7, \"Max Pyramid Entries\", minval=1, maxval=100, title=\"Pyramiding Limit\", group=\"Strategy Settings\")\r\n\r\nvar float long_total_qty = 0\r\nvar float long_total_cost = 0\r\nvar float short_total_qty = 0\r\nvar float short_total_cost = 0\r\nvar int long_entry_count = 0\r\nvar int short_entry_count = 0\r\nvar string last_long_id = \"\"\r\nvar string last_short_id = \"\"\r\nvar bool long_active = false\r\nvar bool short_active = false\r\n\r\n// ìˆ˜ìµë¥  ì¶”ì  ë³€ìˆ˜\r\nvar float total_profit_pct = 0\r\nvar int total_trades = 0\r\nvar float avg_profit_pct = 0\r\n\r\n// ì²­ì‚° ë²„í¼ ì„¤ì •\r\nexit_buffer = input.float(0.1, \"Exit Buffer (%)\", minval=0.0, step=0.1, title=\"Take Profit Buffer\", group=\"Strategy Settings\")\r\n\r\n// í‰ê·  ì§„ìž… ê°€ê²© ê³„ì‚°\r\nfloat long_avg_price = long_total_qty > 0 ? long_total_cost / long_total_qty : na\r\nfloat short_avg_price = short_total_qty > 0 ? short_total_cost / short_total_qty : na\r\n\r\n// ê°•ì œ ì²­ì‚° ê°€ê²© ì—…ë°ì´íŠ¸\r\nif long_avg_price and not na(long_avg_price)\r\n    long_liquidation_price := calc_liquidation_price(long_avg_price, current_leverage, true)\r\nif short_avg_price and not na(short_avg_price)\r\n    short_liquidation_price := calc_liquidation_price(short_avg_price, current_leverage, false)\r\n\r\n// í¬ì§€ì…˜ ì‚¬ì´ì¦ˆ ê³„ì‚° í•¨ìˆ˜\r\ncalculate_position_size(entry_count, total_qty, is_long) =>\r\n    float qty = 0\r\n    if position_sizing_mode == \"Martingale\"\r\n        // ë§ˆí‹´ê²Œì¼ ë°©ì‹: í˜„ìž¬ í¬ì§€ì…˜ë§Œí¼ ì¶”ê°€ (1:1:2:4:8:16:32...)\r\n        qty := entry_count == 0 ? initial_position_size : total_qty\r\n    else  // Equal Split\r\n        // ë™ì¼ ë¶„í•  ë°©ì‹: ì „ì²´ ìžê¸ˆì„ í”¼ë¼ë¯¸ë”© íšŸìˆ˜ë¡œ ë‚˜ëˆ„ì–´ ì§„ìž…\r\n        qty := initial_position_size\r\n    qty\r\n\r\n// ë§¤ìˆ˜/ë§¤ë„ ì¡°ê±´\r\nbuy_condition = s_sig_up and dc_is_below_lower\r\nsell_condition = s_sig_dn and dc_is_above_upper\r\n\r\n// ì²­ì‚° ì¡°ê±´\r\nclose_long_condition = s_sig_dn and close >= (long_avg_price * (100 + exit_buffer) / 100)\r\nclose_short_condition = s_sig_up and close <= (short_avg_price * (100 - exit_buffer) / 100)\r\n\r\n// ê°•ì œ ì²­ì‚° ì¡°ê±´\r\nliquidation_long = long_active and close <= long_liquidation_price\r\nliquidation_short = short_active and close >= short_liquidation_price\r\n\r\n// ë§¤ìˆ˜ ì‹ í˜¸ ì²˜ë¦¬\r\nif buy_condition and not short_active and long_entry_count < MAX_PYRAMID\r\n    qty = calculate_position_size(long_entry_count, long_total_qty, true)\r\n    string entry_id = \"LongEntry\" + str.tostring(bar_index)\r\n    string mode_str = position_sizing_mode == \"Martingale\" ? \"M\" : \"E\"\r\n    strategy.entry(entry_id, strategy.long, qty=qty, comment=\"Long x\" + str.tostring(qty) + \" (\" + mode_str + \":\" + str.tostring(current_leverage) + \")\")\r\n    \r\n    long_total_qty := long_total_qty + qty\r\n    long_total_cost := long_total_cost + qty * close\r\n    long_entry_count := long_entry_count + 1\r\n    last_long_id := entry_id\r\n    long_active := true\r\n    \r\n    label.new(bar_index, low, \"Long Entry x\" + str.tostring(qty) + \"\\n\" + position_sizing_mode + \"\\nLev:\" + str.tostring(current_leverage) + \"x (\" + str.tostring(long_entry_count) + \"/\" + str.tostring(MAX_PYRAMID) + \")\", \r\n              color=color.green, style=label.style_label_up, textcolor=color.black, size=size.small)\r\n\r\n// ê³µë§¤ë„ ì‹ í˜¸ ì²˜ë¦¬\r\nif sell_condition and not long_active and short_entry_count < MAX_PYRAMID\r\n    qty = calculate_position_size(short_entry_count, short_total_qty, false)\r\n    string entry_id = \"ShortEntry\" + str.tostring(bar_index)\r\n    string mode_str = position_sizing_mode == \"Martingale\" ? \"M\" : \"E\"\r\n    strategy.entry(entry_id, strategy.short, qty=qty, comment=\"Short x\" + str.tostring(qty) + \" (\" + mode_str + \":\" + str.tostring(current_leverage) + \")\")\r\n    \r\n    short_total_qty := short_total_qty + qty\r\n    short_total_cost := short_total_cost + qty * close\r\n    short_entry_count := short_entry_count + 1\r\n    last_short_id := entry_id\r\n    short_active := true\r\n    \r\n    label.new(bar_index, high, \"Short Entry x\" + str.tostring(qty) + \"\\n\" + position_sizing_mode + \"\\nLev:\" + str.tostring(current_leverage) + \"x (\" + str.tostring(short_entry_count) + \"/\" + str.tostring(MAX_PYRAMID) + \")\", \r\n              color=color.red, style=label.style_label_down, textcolor=color.black, size=size.small)\r\n\r\n// ê°•ì œ ì²­ì‚° ì²˜ë¦¬ (ë¡±)\r\nif liquidation_long and strategy.position_size > 0\r\n    float loss_pct = ((close - long_avg_price) / long_avg_price) * 100\r\n    \r\n    strategy.close_all(comment=\"LIQUIDATION - Long\")\r\n    log.info(\"LIQUIDATION - Long Position: Loss={0}%\", loss_pct)\r\n    \r\n    total_profit_pct := total_profit_pct + loss_pct\r\n    total_trades := total_trades + 1\r\n    avg_profit_pct := total_profit_pct / total_trades\r\n    \r\n    // ê°•ì œ ì²­ì‚° ì•Œë¦¼\r\n    label.new(bar_index, high, \"ðŸš¨ LIQUIDATION ðŸš¨\\nLong Loss: \" + str.tostring(loss_pct, \"#.##\") + \"%\", \r\n              color=color.maroon, style=label.style_label_down, textcolor=color.white, size=size.large)\r\n    \r\n    long_total_qty := 0\r\n    long_total_cost := 0\r\n    long_entry_count := 0\r\n    last_long_id := \"\"\r\n    long_active := false\r\n    long_liquidation_price := na\r\n\r\n// ê°•ì œ ì²­ì‚° ì²˜ë¦¬ (ìˆ)\r\nif liquidation_short and strategy.position_size < 0\r\n    float loss_pct = ((short_avg_price - close) / short_avg_price) * 100\r\n    \r\n    strategy.close_all(comment=\"LIQUIDATION - Short\")\r\n    log.info(\"LIQUIDATION - Short Position: Loss={0}%\", loss_pct)\r\n    \r\n    total_profit_pct := total_profit_pct + loss_pct\r\n    total_trades := total_trades + 1\r\n    avg_profit_pct := total_profit_pct / total_trades\r\n    \r\n    // ê°•ì œ ì²­ì‚° ì•Œë¦¼\r\n    label.new(bar_index, low, \"ðŸš¨ LIQUIDATION ðŸš¨\\nShort Loss: \" + str.tostring(loss_pct, \"#.##\") + \"%\", \r\n              color=color.maroon, style=label.style_label_up, textcolor=color.white, size=size.large)\r\n    \r\n    short_total_qty := 0\r\n    short_total_cost := 0\r\n    short_entry_count := 0\r\n    last_short_id := \"\"\r\n    short_active := false\r\n    short_liquidation_price := na\r\n\r\n// ì¼ë°˜ ì²­ì‚° ì²˜ë¦¬ (ë¡±) - ê°•ì œì²­ì‚°ì´ ì•„ë‹Œ ê²½ìš°ì—ë§Œ\r\nif close_long_condition and strategy.position_size > 0 and not liquidation_long\r\n    float profit_pct = ((close - long_avg_price) / long_avg_price) * 100\r\n    \r\n    strategy.close_all(comment=\"Close Long (Profit)\")\r\n    log.info(\"Closing Long Position: Profit={0}%\", profit_pct)\r\n    \r\n    total_profit_pct := total_profit_pct + profit_pct\r\n    total_trades := total_trades + 1\r\n    avg_profit_pct := total_profit_pct / total_trades\r\n    \r\n    label.new(bar_index, high, \"Close Long\\nProfit: \" + str.tostring(profit_pct, \"#.##\") + \"%\", \r\n              color=color.orange, style=label.style_label_down, textcolor=color.black)\r\n    \r\n    long_total_qty := 0\r\n    long_total_cost := 0\r\n    long_entry_count := 0\r\n    last_long_id := \"\"\r\n    long_active := false\r\n    long_liquidation_price := na\r\n\r\n// ì¼ë°˜ ì²­ì‚° ì²˜ë¦¬ (ìˆ) - ê°•ì œì²­ì‚°ì´ ì•„ë‹Œ ê²½ìš°ì—ë§Œ\r\nif close_short_condition and strategy.position_size < 0 and not liquidation_short\r\n    float profit_pct = ((short_avg_price - close) / short_avg_price) * 100\r\n    \r\n    strategy.close_all(comment=\"Close Short (Profit)\")\r\n    log.info(\"Closing Short Position: Profit={0}%\", profit_pct)\r\n    \r\n    total_profit_pct := total_profit_pct + profit_pct\r\n    total_trades := total_trades + 1\r\n    avg_profit_pct := total_profit_pct / total_trades\r\n    \r\n    label.new(bar_index, low, \"Close Short\\nProfit: \" + str.tostring(profit_pct, \"#.##\") + \"%\", \r\n              color=color.orange, style=label.style_label_up, textcolor=color.black)\r\n    \r\n    short_total_qty := 0\r\n    short_total_cost := 0\r\n    short_entry_count := 0\r\n    last_short_id := \"\"\r\n    short_active := false\r\n    short_liquidation_price := na\r\n\r\n// ê°•ì œ ì²­ì‚° ê°€ê²© ì‹œê°í™”\r\nplot(long_liquidation_price, \"Long Liquidation\", color=color.red, style=plot.style_circles, linewidth=2)\r\nplot(short_liquidation_price, \"Short Liquidation\", color=color.red, style=plot.style_circles, linewidth=2)\r\n\r\n// í‰ë‹¨ê°€ ì‹œê°í™”\r\nplot(long_total_qty > 0 ? long_avg_price : na, \"Long Avg Price\", color=color.green, style=plot.style_circles, linewidth=2)\r\nplot(short_total_qty > 0 ? short_avg_price : na, \"Short Avg Price\", color=color.red, style=plot.style_circles, linewidth=2)\r\n\r\n// ë©”ì¸ ì •ë³´ í…Œì´ë¸” (ê¹”ë”í•œ ë””ìžì¸)\r\nif barstate.islast\r\n    var table main_table = table.new(position.top_left, 2, 4, \r\n                                   bgcolor=color.new(color.white, 10), \r\n                                   border_width=1, \r\n                                   border_color=color.new(color.gray, 30))\r\n    \r\n    // í—¤ë”\r\n    table.cell(main_table, 0, 0, \"ðŸ“Š Strategy Info\", \r\n              text_color=color.white, \r\n              bgcolor=color.new(color.blue, 0), \r\n              text_size=size.normal)\r\n    table.cell(main_table, 1, 0, \"Values\", \r\n              text_color=color.white, \r\n              bgcolor=color.new(color.blue, 0), \r\n              text_size=size.normal)\r\n    \r\n    // í¬ì§€ì…˜ ì‚¬ì´ì§• ëª¨ë“œ\r\n    table.cell(main_table, 0, 1, \"Sizing Mode\", \r\n              text_color=color.new(color.black, 0), \r\n              bgcolor=color.new(color.white, 0),\r\n              text_size=size.small)\r\n    table.cell(main_table, 1, 1, position_sizing_mode, \r\n              text_color=position_sizing_mode == \"Martingale\" ? color.orange : color.blue,\r\n              bgcolor=color.new(color.white, 0),\r\n              text_size=size.small)\r\n    \r\n    // ë ˆë²„ë¦¬ì§€\r\n    table.cell(main_table, 0, 2, \"Leverage\", \r\n              text_color=color.new(color.black, 0), \r\n              bgcolor=color.new(color.white, 0),\r\n              text_size=size.small)\r\n    table.cell(main_table, 1, 2, str.tostring(current_leverage, \"#.#\") + \"x\", \r\n              text_color=current_leverage > 10 ? color.red : current_leverage > 5 ? color.orange : color.green,\r\n              bgcolor=color.new(color.white, 0),\r\n              text_size=size.small)\r\n    \r\n    // í‰ê·  ìˆ˜ìµë¥ \r\n    table.cell(main_table, 0, 3, \"Avg P&L\", \r\n              text_color=color.new(color.black, 0), \r\n              bgcolor=color.new(color.white, 0),\r\n              text_size=size.small)\r\n    table.cell(main_table, 1, 3, total_trades > 0 ? str.tostring(avg_profit_pct, \"#.##\") + \"%\" : \"0.00%\", \r\n              text_color=avg_profit_pct > 0 ? color.green : avg_profit_pct < 0 ? color.red : color.gray,\r\n              bgcolor=color.new(color.white, 0),\r\n              text_size=size.small)\r\n\r\n// ê°•ì œì²­ì‚° ì •ë³´ í…Œì´ë¸”\r\nif barstate.islast and (long_active or short_active)\r\n    var table liq_table = table.new(position.top_center, 2, 3, \r\n                                   bgcolor=color.new(color.white, 10), \r\n                                   border_width=1, \r\n                                   border_color=color.new(color.red, 30))\r\n    \r\n    // í—¤ë”\r\n    table.cell(liq_table, 0, 0, \"âš ï¸ Liquidation (Auto)\", \r\n              text_color=color.white, \r\n              bgcolor=color.new(color.red, 0), \r\n              text_size=size.normal)\r\n    table.cell(liq_table, 1, 0, \"Prices\", \r\n              text_color=color.white, \r\n              bgcolor=color.new(color.red, 0), \r\n              text_size=size.normal)\r\n    \r\n    // ë¡± ì²­ì‚°ê°€\r\n    table.cell(liq_table, 0, 1, \"Long Liq.\", \r\n              text_color=color.new(color.black, 0), \r\n              bgcolor=color.new(color.white, 0),\r\n              text_size=size.small)\r\n    table.cell(liq_table, 1, 1, long_liquidation_price > 0 ? str.tostring(long_liquidation_price, \"#.####\") : \"N/A\", \r\n              text_color=color.red,\r\n              bgcolor=color.new(color.white, 0),\r\n              text_size=size.small)\r\n    \r\n    // ìˆ ì²­ì‚°ê°€\r\n    table.cell(liq_table, 0, 2, \"Short Liq.\", \r\n              text_color=color.new(color.black, 0), \r\n              bgcolor=color.new(color.white, 0),\r\n              text_size=size.small)\r\n    table.cell(liq_table, 1, 2, short_liquidation_price > 0 ? str.tostring(short_liquidation_price, \"#.####\") : \"N/A\", \r\n              text_color=color.red,\r\n              bgcolor=color.new(color.white, 0),\r\n              text_size=size.small)\r\n\r\n// í¬ì§€ì…˜ ì •ë³´ í…Œì´ë¸” (ì»´íŒ©íŠ¸)\r\nif barstate.islast\r\n    var table pos_table = table.new(position.top_right, 3, 4, \r\n                                   bgcolor=color.new(color.white, 10), \r\n                                   border_width=1, \r\n                                   border_color=color.new(color.gray, 30))\r\n    \r\n    // í—¤ë”\r\n    table.cell(pos_table, 0, 0, \"ðŸŽ¯ Position\", \r\n              text_color=color.white, \r\n              bgcolor=color.new(color.purple, 0), \r\n              text_size=size.small)\r\n    table.cell(pos_table, 1, 0, \"Long\", \r\n              text_color=color.white, \r\n              bgcolor=color.new(color.green, 0), \r\n              text_size=size.small)\r\n    table.cell(pos_table, 2, 0, \"Short\", \r\n              text_color=color.white, \r\n              bgcolor=color.new(color.red, 0), \r\n              text_size=size.small)\r\n    \r\n    // ì§„ìž… íšŸìˆ˜\r\n    table.cell(pos_table, 0, 1, \"Entries\", \r\n              text_color=color.new(color.black, 0), \r\n              bgcolor=color.new(color.white, 0),\r\n              text_size=size.tiny)\r\n    table.cell(pos_table, 1, 1, str.tostring(long_entry_count) + \"/\" + str.tostring(MAX_PYRAMID), \r\n              text_color=long_entry_count > 0 ? color.green : color.gray,\r\n              bgcolor=color.new(color.white, 0),\r\n              text_size=size.tiny)\r\n    table.cell(pos_table, 2, 1, str.tostring(short_entry_count) + \"/\" + str.tostring(MAX_PYRAMID), \r\n              text_color=short_entry_count > 0 ? color.red : color.gray,\r\n              bgcolor=color.new(color.white, 0),\r\n              text_size=size.tiny)\r\n    \r\n    // í‰ê· ê°€\r\n    table.cell(pos_table, 0, 2, \"Avg Price\", \r\n              text_color=color.new(color.black, 0), \r\n              bgcolor=color.new(color.white, 0),\r\n              text_size=size.tiny)\r\n    table.cell(pos_table, 1, 2, long_avg_price > 0 ? str.tostring(long_avg_price, \"#.####\") : \"N/A\", \r\n              text_color=long_avg_price > 0 ? color.green : color.gray,\r\n              bgcolor=color.new(color.white, 0),\r\n              text_size=size.tiny)\r\n    table.cell(pos_table, 2, 2, short_avg_price > 0 ? str.tostring(short_avg_price, \"#.####\") : \"N/A\", \r\n              text_color=short_avg_price > 0 ? color.red : color.gray,\r\n              bgcolor=color.new(color.white, 0),\r\n              text_size=size.tiny)\r\n    \r\n    // ë‹¤ìŒ ì§„ìž… ë¬¼ëŸ‰ ì˜ˆì‹œ\r\n    table.cell(pos_table, 0, 3, \"Next Size\", \r\n              text_color=color.new(color.black, 0), \r\n              bgcolor=color.new(color.white, 0),\r\n              text_size=size.tiny)\r\n    \r\n    next_long_qty = calculate_position_size(long_entry_count, long_total_qty, true)\r\n    next_short_qty = calculate_position_size(short_entry_count, short_total_qty, false)\r\n    \r\n    table.cell(pos_table, 1, 3, long_entry_count < MAX_PYRAMID ? str.tostring(next_long_qty, \"#.##\") : \"MAX\", \r\n              text_color=long_entry_count < MAX_PYRAMID ? color.green : color.gray,\r\n              bgcolor=color.new(color.white, 0),\r\n              text_size=size.tiny)\r\n    table.cell(pos_table, 2, 3, short_entry_count < MAX_PYRAMID ? str.tostring(next_short_qty, \"#.##\") : \"MAX\", \r\n              text_color=short_entry_count < MAX_PYRAMID ? color.red : color.gray,\r\n              bgcolor=color.new(color.white, 0),\r\n              text_size=size.tiny)"
  },
  {
    "url": "mdBweUHO",
    "name": "Adaptive Trend Navigator [ATH Filter & Risk Engine]",
    "description": "Description:\n\nThis strategy implements a systematic Trend Following approach designed to capture major moves while actively protecting capital during severe bear markets. It combines a classic Moving Average \"Fan\" logic with two advanced risk management layers: a 4-Stage Dynamic Stop Loss and a macro-economic \"Circuit Breaker\" filter.\n\nCore Concepts:\n\n1. Trend Identification (Entry Logic) The script uses a cascade of Simple Moving Averages (SMA 25, 50, 100, 200) to identify the maturity of a trend.\n\nEntries are triggered by specific crossovers (e.g., SMA 25 crossing SMA 50) or by breaking above the previous trade's high (\"High-Water Mark\" Re-Entry).\n\n2. The \"Circuit Breaker\" (Crash Protection) To prevent trading during historical market collapses (like 2000 or 2008), the strategy monitors the Nasdaq 100 (QQQ) as a global benchmark:\n\nNormal Regime: If the market is within 20% of its All-Time High, the strategy operates normally.\n\nCrisis Regime: If the QQQ falls more than 20% from its ATH, the \"Circuit Breaker\" activates (Visualized by a Red Background).\n\nRecovery Rule: In a Crisis Regime, new long positions are blocked unless the QQQ reclaims its SMA 200. This filters out \"bull traps\" in secular bear markets.\n\n3. 4-Stage Risk Engine (Exit Logic) Once in a trade, the risk management adapts to the position's performance:\n\nStage 1: Fixed initial Stop Loss (default 10%) for breathing room.\n\nStage 2: Moves to Break-Even area once the price rises 12%.\n\nStage 3: Tightens to a trailing stop (8%) after 25% profit.\n\nStage 4: Maximizes gains with a tight trailing stop (5%) during parabolic moves (>40% profit).\n\nVisual Guide:\n\nSMAs: 25/50/100/200 period lines for trend visualization.\n\nRed Background: Indicates the \"Crisis Regime\" where trading is halted due to broad market weakness.\n\nBlue Background: Indicates a \"Recovery Phase\" (Crisis is active, but market is above SMA 200).\n\nRed Line: Shows the dynamic Stop Loss level for active positions.\n\nSettings: All parameters (SMA lengths, Drawdown threshold, Risk Stages) are fully customizable. The QQQ benchmark ticker can also be changed to SPY or other indices depending on the asset class traded.",
    "image_url": "mdBweUHO",
    "author": "oppliger79",
    "likes": 10,
    "type": "strategy",
    "created": "2025-11-30",
    "updated": "2025-11-30",
    "source": "//@version=5\nstrategy(\"Stufen Modell + QQQ ATH Filter\", overlay=true, initial_capital=5000, default_qty_type=strategy.percent_of_equity, default_qty_value=20)\n\n// --- 1. Inputs ---\nlen1 = input.int(25, title=\"SMA 25\")\nlen2 = input.int(50, title=\"SMA 50\")\nlen3 = input.int(100, title=\"SMA 100\")\nlen4 = input.int(200, title=\"SMA 200\")\n\n// Stop Loss Inputs\nsl_initial_pct = input.float(10.0, title=\"Stufe 1: Initial Stop %\") / 100\nstage2_trigger = input.float(12.0, title=\"Stufe 2: Aktivierung bei Gewinn %\") / 100\nstage2_sl_dist = input.float(10.0, title=\"Stufe 2: Abstand %\") / 100\nstage3_trigger = input.float(25.0, title=\"Stufe 3: Aktivierung bei Gewinn %\") / 100\nstage3_trail   = input.float(8.0,  title=\"Stufe 3: Trailing %\") / 100\nstage4_trigger = input.float(40.0, title=\"Stufe 4: Aktivierung bei Gewinn %\") / 100\nstage4_trail   = input.float(5.0,  title=\"Stufe 4: Trailing %\") / 100\n\n// --- 2. Berechnung SMAs (Aktie) ---\nsma25  = ta.sma(close, len1)\nsma50  = ta.sma(close, len2)\nsma100 = ta.sma(close, len3)\nsma200 = ta.sma(close, len4)\n\nplot(sma25, color=color.yellow, title=\"SMA 25\")\nplot(sma50, color=color.orange, title=\"SMA 50\")\nplot(sma100, color=color.blue, title=\"SMA 100\")\nplot(sma200, color=color.white, title=\"SMA 200\", linewidth=2)\n\n\n// --- 3. DER INTELLIGENTE MARKT FILTER ---\n\n// A. Daten vom QQQ holen\n[qqq_close, qqq_sma200] = request.security(\"NASDAQ:QQQ\", timeframe.period, [close, ta.sma(close, 200)])\n\n// B. All-Time-High (ATH) Tracking\n// Wir nutzen eine persistente Variable (var), die sich das hÃ¶chste Hoch merkt\nvar float qqq_ath = 0.0\nif qqq_close > qqq_ath\n    qqq_ath := qqq_close\n\n// C. Drawdown berechnen (Wie weit sind wir vom ATH weg?)\n// Wenn ATH noch 0 ist (Start), ist Drawdown 0\nqqq_drawdown_pct = qqq_ath > 0 ? ((qqq_ath - qqq_close) / qqq_ath) : 0.0\n\n// D. Die Filter-Logik\n// Regel: Filter ist nur aktiv, wenn Drawdown > 20% (0.20)\ncircuit_breaker_active = qqq_drawdown_pct > 0.20\n\n// Erlaubnis zum Handeln:\n// 1. Wenn Circuit Breaker NICHT aktiv ist (Crash < 20%) -> Immer erlaubt (true)\n// 2. Wenn Circuit Breaker aktiv IST -> Nur erlaubt wenn QQQ Ã¼ber SMA 200\ntrading_allowed = circuit_breaker_active ? (qqq_close > qqq_sma200) : true\n\n// Visualisierung des Status (Info Panel im Hintergrund)\n// Rot = Crash Modus & Unter SMA 200 (Handel blockiert)\nbgcolor(not trading_allowed ? color.new(color.red, 90) : na, title=\"Trading Blocked\")\n// Blau = Crash Modus ist an, aber wir sind Ã¼ber SMA 200 (Vorsichtiger Handel)\nbgcolor(circuit_breaker_active and trading_allowed ? color.new(color.blue, 95) : na, title=\"Crisis Recovery Mode\")\n\n\n// --- 4. Variablen fÃ¼r Trade Management ---\nvar float stop_price = na        \nvar float highest_price = 0.0    \nvar float entry_price = 0.0      \nvar float last_trade_high = 0.0  \n\nin_position = strategy.position_size > 0\n\nif in_position and strategy.position_size[1] == 0\n    entry_price := close\n    highest_price := high\n    stop_price := close * (1 - sl_initial_pct)\n\n// --- 5. Stop Loss & Dead Cross Logic ---\ndc_25_50   = ta.crossunder(sma25, sma50)\ndc_50_100  = ta.crossunder(sma50, sma100)\ndc_100_200 = ta.crossunder(sma100, sma200)\n\nif in_position\n    if high > highest_price\n        highest_price := high\n    \n    gain_pct = (highest_price - entry_price) / entry_price\n\n    if gain_pct >= stage4_trigger\n        new_sl = highest_price * (1 - stage4_trail)\n        stop_price := math.max(stop_price, new_sl)\n    else if gain_pct >= stage3_trigger\n        new_sl = highest_price * (1 - stage3_trail)\n        stop_price := math.max(stop_price, new_sl)\n    else if gain_pct >= stage2_trigger\n        new_sl = highest_price * (1 - stage2_sl_dist)\n        stop_price := math.max(stop_price, new_sl)\n        \n    sl_hit = close < stop_price\n    trend_broken = dc_25_50 or dc_50_100 or dc_100_200\n    \n    if sl_hit or trend_broken\n        last_trade_high := highest_price \n        exit_msg = sl_hit ? \"SL Hit\" : \"Dead Cross\"\n        strategy.close_all(comment=exit_msg)\n        stop_price := na \n        highest_price := 0.0 \n\nplot(in_position ? stop_price : na, color=color.red, style=plot.style_linebr, linewidth=2, title=\"Dynamic SL\")\nplot(strategy.position_size == 0 and last_trade_high > 0 ? last_trade_high : na, color=color.green, style=plot.style_circles, title=\"Re-Entry Trigger\")\n\n\n// --- 6. EINSTIEG (Gesteuert durch Filter) ---\n\ncross_25_50   = ta.crossover(sma25, sma50)\ncross_50_100  = ta.crossover(sma50, sma100)\ncross_100_200 = ta.crossover(sma100, sma200)\n\nre_entry_signal = (strategy.position_size == 0) and (close > sma200) and (close > last_trade_high) and (last_trade_high > 0)\n\n// HIER WIRD GEPRÃœFT\nif trading_allowed\n    if cross_25_50\n        strategy.entry(\"Long Start\", strategy.long, comment=\"Cross 25/50\")\n    if cross_50_100\n        strategy.entry(\"Long Mid\", strategy.long, comment=\"Cross 50/100\")\n    if cross_100_200\n        strategy.entry(\"Long Macro\", strategy.long, comment=\"Cross 100/200\")\n\n    if re_entry_signal\n        strategy.entry(\"Re-Entry Breakout\", strategy.long, comment=\"Breakout High\")"
  },
  {
    "url": "NLR75upz-GK-AI-make-money-str",
    "name": "GK AI make money str",
    "description": "fully automated buy sell signals\ninspired by nadaraya watson smoothers",
    "image_url": "NLR75upz",
    "author": "gkocak",
    "likes": 24,
    "type": "strategy",
    "created": "2025-11-30",
    "updated": "2025-11-30",
    "source": "//@version=6\nstrategy(\"Momentum Strategy\", overlay=true)\nlength = input(12)\nprice = close\nmomentum(seria, length) =>\n\tmom = seria - seria[length]\n\tmom\nmom0 = momentum(price, length)\nmom1 = momentum( mom0, 1)\nif (mom0 > 0 and mom1 > 0)\n\tstrategy.entry(\"MomLE\", strategy.long, stop=high+syminfo.mintick, comment=\"MomLE\")\nelse\n\tstrategy.cancel(\"MomLE\")\nif (mom0 < 0 and mom1 < 0)\n\tstrategy.entry(\"MomSE\", strategy.short, stop=low-syminfo.mintick, comment=\"MomSE\")\nelse\n\tstrategy.cancel(\"MomSE\")\n//plot(strategy.equity, title=\"equity\", color=color.red, linewidth=2, style=plot.style_areabr)"
  },
  {
    "url": "WxvL8iks-GK-make-money-str",
    "name": "GK make money str",
    "description": "full automated buy sell signals\ninspired by nadara watson ",
    "image_url": "WxvL8iks",
    "author": "gkocak",
    "likes": 15,
    "type": "strategy",
    "created": "2025-11-30",
    "updated": "2025-11-30",
    "source": "//@version=6\nstrategy(\"Momentum Strategy\", overlay=true)\nlength = input(12)\nprice = close\nmomentum(seria, length) =>\n\tmom = seria - seria[length]\n\tmom\nmom0 = momentum(price, length)\nmom1 = momentum( mom0, 1)\nif (mom0 > 0 and mom1 > 0)\n\tstrategy.entry(\"MomLE\", strategy.long, stop=high+syminfo.mintick, comment=\"MomLE\")\nelse\n\tstrategy.cancel(\"MomLE\")\nif (mom0 < 0 and mom1 < 0)\n\tstrategy.entry(\"MomSE\", strategy.short, stop=low-syminfo.mintick, comment=\"MomSE\")\nelse\n\tstrategy.cancel(\"MomSE\")\n//plot(strategy.equity, title=\"equity\", color=color.red, linewidth=2, style=plot.style_areabr)"
  },
  {
    "url": "slVRRa2C",
    "name": "Dynamic SMA Trend System [Multi-Stage Risk Engine]",
    "description": "Description:\n\nThis script implements a robust Trend Following strategy based on a multiple Simple Moving Average (SMA) crossover logic (25, 50, 100, 200). What sets this strategy apart is its advanced \"4-Stage Risk Engine\" and a smart \"High-Water Mark\" Re-Entry system, designed to protect profits during parabolic moves while filtering out chop during sideways markets.\n\nHow it works:\n\nThe strategy operates on three core pillars: Trend Identification, Dynamic Risk Management, and Momentum Re-Entry.\n\n1. Entry Logic (Trend Identification) The script looks for crossovers at different trend stages to capture early reversals as well as established trends:\n\nShort-Term: SMA 25 crosses over SMA 50.\n\nMid-Term: SMA 50 crosses over SMA 100.\n\nMacro-Trend: SMA 100 crosses over SMA 200.\n\n2. The 4-Stage Risk Engine (Dynamic Stop Loss) Instead of a static Stop Loss, this strategy uses a progressive system that adapts as the price increases:\n\nStage 1 (Protection): Starts with a fixed Stop Loss (default -10%) to give the trade room to breathe.\n\nStage 2 (Break-Even): Once the price rises by 12%, the Stop is moved to trailing mode (10% distance), effectively securing a near break-even state.\n\nStage 3 (Profit Locking): At 25% profit, the trailing stop tightens to 8% to lock in gains.\n\nStage 4 (Parabolic Mode): At 40% profit, the trailing stop tightens further to 5% to capture the peak of parabolic moves.\n\n3. Dual Exit Mechanism The strategy exits a position if EITHER of the following happens:\n\nStop Loss Hit: Price falls below the dynamic red line (Risk Engine).\n\nDead Cross: The trend structure breaks (e.g., SMA 25 crosses under SMA 50), signaling a momentum loss even if the Stop Loss wasn't hit.\n\n4. \"High-Water Mark\" Re-Entry To avoid \"whipsaws\" in choppy markets, the script does not re-enter immediately after a stop-out.\n\nIt marks the highest price of the previous trade (Green Dotted Line).\n\nA Re-Entry only occurs if the price breaks above this previous high (showing renewed strength) AND the long-term trend is bullish (Price > SMA 200).\n\nVisuals:\n\nSMAs: 25 (Yellow), 50 (Orange), 100 (Blue), 200 (White).\n\nRed Line: Visualizes the dynamic Stop Loss level.\n\nGreen Dots: Visualizes the target price needed for a valid re-entry.\n\nSettings: All parameters (SMA lengths, Stop Loss percentages, Staging triggers) are fully customizable in the settings menu to fit different assets (Crypto, Stocks, Forex) and timeframes.",
    "image_url": "slVRRa2C",
    "author": "oppliger79",
    "likes": 8,
    "type": "strategy",
    "created": "2025-11-30",
    "updated": "2025-11-30",
    "source": "//@version=5\nstrategy(\"All-in-One: Stufen SL + Dead Cross + ReEntry\", overlay=true, initial_capital=1000, default_qty_type=strategy.percent_of_equity, default_qty_value=100)\n\n// --- 1. Inputs ---\nlen1 = input.int(25, title=\"SMA 25\")\nlen2 = input.int(50, title=\"SMA 50\")\nlen3 = input.int(100, title=\"SMA 100\")\nlen4 = input.int(200, title=\"SMA 200\")\n\n// Stop Loss Inputs\nsl_initial_pct = input.float(10.0, title=\"Stufe 1: Initial Stop %\") / 100\nstage2_trigger = input.float(12.0, title=\"Stufe 2: Aktivierung bei Gewinn %\") / 100\nstage2_sl_dist = input.float(10.0, title=\"Stufe 2: Abstand %\") / 100\nstage3_trigger = input.float(25.0, title=\"Stufe 3: Aktivierung bei Gewinn %\") / 100\nstage3_trail   = input.float(8.0,  title=\"Stufe 3: Trailing %\") / 100\nstage4_trigger = input.float(40.0, title=\"Stufe 4: Aktivierung bei Gewinn %\") / 100\nstage4_trail   = input.float(5.0,  title=\"Stufe 4: Trailing %\") / 100\n\n// --- 2. Berechnung SMAs ---\nsma25  = ta.sma(close, len1)\nsma50  = ta.sma(close, len2)\nsma100 = ta.sma(close, len3)\nsma200 = ta.sma(close, len4)\n\nplot(sma25, color=color.yellow, title=\"SMA 25\")\nplot(sma50, color=color.orange, title=\"SMA 50\")\nplot(sma100, color=color.blue, title=\"SMA 100\")\nplot(sma200, color=color.white, title=\"SMA 200\", linewidth=2)\n\n// --- 3. Variablen ---\nvar float stop_price = na        \nvar float highest_price = 0.0    \nvar float entry_price = 0.0      \nvar float last_trade_high = 0.0  \n\nin_position = strategy.position_size > 0\n\n// Initialisierung bei neuem Trade\nif in_position and strategy.position_size[1] == 0\n    entry_price := close\n    highest_price := high\n    stop_price := close * (1 - sl_initial_pct)\n\n// --- 4. Stop Loss & Dead Cross Management ---\n\n// A) Dead Cross Bedingungen definieren\ndc_25_50   = ta.crossunder(sma25, sma50)\ndc_50_100  = ta.crossunder(sma50, sma100)\ndc_100_200 = ta.crossunder(sma100, sma200)\n\nif in_position\n    // HÃ¶chststand tracken\n    if high > highest_price\n        highest_price := high\n    \n    gain_pct = (highest_price - entry_price) / entry_price\n\n    // B) Stop Loss Stufen Logik\n    if gain_pct >= stage4_trigger\n        new_sl = highest_price * (1 - stage4_trail)\n        stop_price := math.max(stop_price, new_sl)\n    else if gain_pct >= stage3_trigger\n        new_sl = highest_price * (1 - stage3_trail)\n        stop_price := math.max(stop_price, new_sl)\n    else if gain_pct >= stage2_trigger\n        new_sl = highest_price * (1 - stage2_sl_dist)\n        stop_price := math.max(stop_price, new_sl)\n        \n    // --- EXIT ENTSCHEIDUNG ---\n    // Wir prÃ¼fen: Wurde Stop Loss unterschritten? ODER Gab es einen Dead Cross?\n    sl_hit = close < stop_price\n    trend_broken = dc_25_50 or dc_50_100 or dc_100_200\n    \n    if sl_hit or trend_broken\n        // WICHTIG: Wir merken uns das Hoch fÃ¼r den Re-Entry, egal warum wir rausfliegen\n        last_trade_high := highest_price \n        \n        // Kommentar setzen, damit du weiÃŸt warum verkauft wurde\n        exit_msg = sl_hit ? \"SL Hit\" : \"Dead Cross\"\n        \n        strategy.close_all(comment=exit_msg)\n        \n        // Reset\n        stop_price := na \n        highest_price := 0.0 \n\nplot(in_position ? stop_price : na, color=color.red, style=plot.style_linebr, linewidth=2, title=\"Dynamic SL\")\n\n// --- 5. Visualisierung Re-Entry Level ---\nplot(strategy.position_size == 0 and last_trade_high > 0 ? last_trade_high : na, color=color.green, style=plot.style_circles, title=\"Re-Entry Trigger\")\n\n\n// --- 6. EINSTIEG & WIEDEREINSTIEG ---\n\ncross_25_50   = ta.crossover(sma25, sma50)\ncross_50_100  = ta.crossover(sma50, sma100)\ncross_100_200 = ta.crossover(sma100, sma200)\n\n// Re-Entry nur wenn wir Ã¼ber dem alten Hoch schlieÃŸen\nre_entry_signal = (strategy.position_size == 0) and (close > sma200) and (close > last_trade_high) and (last_trade_high > 0)\n\n// Execution\nif cross_25_50\n    strategy.entry(\"Long Start\", strategy.long, comment=\"Cross 25/50\")\nif cross_50_100\n    strategy.entry(\"Long Mid\", strategy.long, comment=\"Cross 50/100\")\nif cross_100_200\n    strategy.entry(\"Long Macro\", strategy.long, comment=\"Cross 100/200\")\n\nif re_entry_signal\n    strategy.entry(\"Re-Entry Breakout\", strategy.long, comment=\"Breakout High\")"
  },
  {
    "url": "D4kwtopC",
    "name": "Trendshift [CHE] Strategy",
    "description": "Trendshift Strategy   â€” First-Shift Structural Regime Trading \n\nProfitfactor 2,603\n\n  Summary \n\nTrendshift Strategy   implements a structural regime-shift trading model built around the earliest confirmed change in directional structure. It identifies major swing highs and lows, validates breakouts through optional ATR-based conviction, and reacts only to the first confirmed shift in each direction. After a regime reversal, the strategy constructs a premium and discount band between the breakout candle and the previous opposite swing. This band is used as contextual bias and may optionally inform stop placement and position sizing.\nThe strategy focuses on clear, interpretable structural events rather than continuous signal generation. By limiting entries to the first valid shift, it reduces false recycles and allows the structural state to stabilize before a new trade occurs. All signals operate on closed-bar logic, and the strategy avoids higher-timeframe calls to stabilize execution behavior.\n\n  Motivation: Why this design? \n\nMany structure-based systems repeatedly trigger as price fluctuates around prior highs and lows. This often leads to multiple flips during volatile or choppy conditions. Trendshift Strategy   addresses this problem by restricting execution to the first confirmed structural event in each direction. ATR-based filters help differentiate genuine structural breaks from noise, while the contextual band ensures that the breakout is meaningful in relation to recent volatility.\nThe design aims to represent a minimalistic structural trading framework focused on regime turns rather than continuous trend signaling. This reduces chart noise and clarifies where the market transitions from one regime to another.\n\n  Whatâ€™s different vs. standard approaches? \n\n  Baseline reference \n\nTypical swing-based structure indicators report every break above or below recent swing points.\n\n  Architecture differences \n\n First-shift-only regime logic that blocks repeated signals until direction reverses\n ATR-filtered validation to avoid weak or momentum-less breaks\n Premium and discount bands derived from breakout structure\n Optional band-driven stop placement\n Optional band-dependent position-sizing factor\n Regime timeout system to neutralize structure after extended inactivity\n Persistent-state architecture to prevent re-triggering\n\n  Practical effect \n\n Only the earliest actionable structure change is traded\n Fewer but higher-quality signals\n Premium/discount tint assists contextual evaluation\n Stops and sizing can be aligned with structural context rather than arbitrary volatility measures\n Improved chart interpretability due to reduced marker frequency\n\n  How it works (technical) \n\nThe algorithm evaluates symmetric swing points using a fixed bar window. When a swing forms, its value and bar index are stored as persistent state. A structural shift occurs when price closes beyond the most recent major swing on the opposite side. If ATR filtering is enabled, the breakout must exceed a volatility-scaled distance to prevent micro-breaks from firing.\nOnce a valid shift is confirmed, the regime is updated to bullish or bearish. The script records the breakout level, the opposite swing, and derives a band between them. This band is checked for minimum size relative to ATR to avoid unrealistic contexts.\nThe first shift in a new direction generates both the strategy entry and a visual marker. Additional shifts in the same direction are suppressed until a reversal occurs. If a timeout is enabled, the regime resets after a specified number of bars without structural change, optionally clearing the band.\nStop placement, if enabled, uses either the opposite or same band edge depending on configuration. Position size is computed from account percentage and may optionally scale with the price-span-to-ATR relationship.\n\n  Parameter Guide \n\n Market Structure\n\n Swing length (default 5): Controls swing sensitivity. Lower values increase responsiveness.\n Use ATR filter (default true): Requires breakouts to show momentum relative to ATR. Reduces false shifts.\n ATR length (default 14): Volatility estimation for breakout and band validation.\n Break ATR multiplier (default 1.0): Required breakout strength relative to ATR.\n\n Premium/Discount Framework\n\n Enable framework (default true): Activates premium/discount evaluation.\n Persist band on timeout (default true): Keeps structural band after timeout.\n Min band ATR mult (default 0.5): Rejects narrow bands.\n Regime timeout bars (default 500): Neutralizes regime after inactivity.\n Invert colors (default false): Color scheme toggle.\n\n Visuals\n\n Show zone tint (default true): Background shade in premium or discount region.\n Show shift markers (default true): Display first-shift markers.\n\n Execution and Risk\n\n Risk per trade percent (default 1.0): Determines position size as account percentage.\n Use band for size (default false): Scales size relative to band width behavior.\n Flat on opposite shift (default true): Forces reversal behavior.\n Use stop at band (default false): Stop anchored to band edges.\n Stop band side: Chooses which band edge is used for stop generation.\n\n  Reading & Interpretation \n\nA green background indicates discount conditions within the structural band; red indicates premium conditions. A green triangle below price marks the first bullish structural shift after a bearish regime. A red triangle above price marks the first bearish structural shift after a bullish regime.\nWhen stops are active, the opposite band edge typically defines the protective level. Band width relative to ATR indicates how significant a structural change is: wider bands imply stronger volatility structure, while narrow bands may be suppressed by the minimum-size filter.\n\n  Practical Workflows & Combinations \n\n Trend following: Use first-shift entries as initial regime confirmation. Add higher-timeframe trend filters for additional context.\n Swing trading: Combine with simple liquidity or fair-value-gap concepts to refine entries.\n Bias mapping: Use higher timeframes for structural regime and lower timeframes for execution within the premium/discount context.\n Exit management: When using stops, consider ATR-scaling or multi-stage profit targets. When not using stops, reversals become the primary exit.\n\n  Behavior, Constraints & Performance \n\nThe strategy uses only confirmed swings and closed-bar logic, avoiding intrabar repaint. Pivot-based swings inherently appear after the pivot window completes, which is standard behavior. No higher-timeframe calls are used, preventing HTF-related repaint issues.\nPersistent variables track regime and structural levels, minimizing recomputation. The maximum bars back setting is five-thousand. The design avoids loops and arrays, keeping performance stable.\nKnown limitations include limited signal density during consolidations, delayed swing confirmation, and sensitivity to extreme gaps that stretch band logic. ATR filtering mitigates some of these effects but does not eliminate them entirely.\n\n  Sensible Defaults & Quick Tuning \n\n Fewer but stronger entries: Increase swing length or ATR breakout multiplier.\n More responsive entries: Reduce swing length to capture earlier shifts.\n More active band behavior: Lower the minimum band ATR threshold.\n Stricter stop logic: Use the opposite band edge for stop placement.\n Volatile markets: Increase ATR length slightly to stabilize behavior.\n\n  What this indicator isâ€”and isnâ€™t \n\nTrendshift Strategy   is a structural-regime trading engine that evaluates major directional shifts. It is not a complete trading system and does not include take-profit logic or prediction features. It does not attempt to forecast future price movement and should be used alongside broader market structure, volatility context, and disciplined risk management.\n\n  Disclaimer \n\nThe content provided, including all code and materials, is strictly for educational and informational purposes only. It is not intended as, and should not be interpreted as, financial advice, a recommendation to buy or sell any financial instrument, or an offer of any financial product or service. All strategies, tools, and examples discussed are provided for illustrative purposes to demonstrate coding techniques and the functionality of Pine Script within a trading context.\n\nAny results from strategies or tools provided are hypothetical, and past performance is not indicative of future results. Trading and investing involve high risk, including the potential loss of principal, and may not be suitable for all individuals. Before making any trading decisions, please consult with a qualified financial professional to understand the risks involved.\n\nBy using this script, you acknowledge and agree that any trading decisions are made solely at your discretion and risk.\n\nDo not use this indicator on Heikin-Ashi, Renko, Kagi, Point-and-Figure, or Range charts, as these chart types can produce unrealistic results for signal markers and alerts.\n\n Best regards and happy trading\n\nChervolino \n",
    "image_url": "D4kwtopC",
    "author": "chervolino",
    "likes": 31,
    "type": "strategy",
    "created": "2025-12-01",
    "updated": "2025-12-01",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n//  _______           _______  _______           _______  _       _________ _        _______ \r\n// (  ____ \\|\\     /|(  ____ \\(  ____ )|\\     /|(  ___  )( \\      \\__   __/( (    /|(  ___  )\r\n// | (    \\/| )   ( || (    \\/| (    )|| )   ( || (   ) || (         ) (   |  \\  ( || (   ) |\r\n// | |      | (___) || (__    | (____)|| |   | || |   | || |         | |   |   \\ | || |   | |\r\n// | |      |  ___  ||  __)   |     __)( (   ) )| |   | || |         | |   | (\\ \\) || |   | |\r\n// | |      | (   ) || (      | (\\ (    \\ \\_/ / | |   | || |         | |   | | \\   || |   | |\r\n// | (____/\\| )   ( || (____/\\| ) \\ \\__  \\   /  | (___) || (____/\\___) (___| )  \\  || (___) |\r\n// (_______/|/     \\|(_______/|/   \\__/   \\_/   (_______)(_______/\\_______/|/    )_)(_______)\r\n// Â© chervolino\r\n//@version=6\r\nstrategy(title=\"Trendshift [CHE] Strategy\", shorttitle=\"TrShStr\", overlay=true, max_bars_back=5000, max_lines_count=500, max_labels_count=500, scale=scale.right, initial_capital=25000, commission_type=strategy.commission.percent, commission_value=0.05, slippage=1, process_orders_on_close=true)\r\n\r\n// â€”â€”â€” SECTION: Constants & Enums\r\nstring GROUP_MARKET_STRUCTURE = \"Market Structure\"\r\nstring GROUP_FRAMEWORK = \"Premium/Discount Framework\"\r\nstring GROUP_VISUAL = \"Visuals\"\r\nstring GROUP_RISK = \"Execution and Risk\"\r\n\r\n// â€”â€”â€” SECTION: Inputs (grouped; tooltips; one-row via inline)\r\nswing_len_input = input.int(5, \"Swing length\", minval=1, group=GROUP_MARKET_STRUCTURE, inline=\"msw\", tooltip=\"Bars left and right for major swing highs and lows.\")\r\nis_use_atr_filter_input = input.bool(true, \"Use ATR filter\", group=GROUP_MARKET_STRUCTURE, inline=\"msw\", tooltip=\"Require breakout to exceed swing level by an ATR multiple.\")\r\natr_len_input = input.int(14, \"ATR length\", minval=1, group=GROUP_MARKET_STRUCTURE, inline=\"atr\", tooltip=\"ATR length for conviction and band checks.\")\r\natr_mult_break_input = input.float(1.0, \"Break ATR mult\", minval=0.0, step=0.1, group=GROUP_MARKET_STRUCTURE, inline=\"atr\", tooltip=\"Distance beyond swing, in ATR units, to confirm a structure shift.\")\r\n\r\nis_enable_framework_input = input.bool(true, \"Enable framework\", group=GROUP_FRAMEWORK, inline=\"fw\", tooltip=\"Enable premium and discount band logic.\")\r\nis_persist_last_band_input = input.bool(true, \"Persist band on timeout\", group=GROUP_FRAMEWORK, inline=\"fw\", tooltip=\"Keep last band after regime timeout.\")\r\nmin_band_atr_mult_input = input.float(0.5, \"Min band ATR mult\", minval=0.0, step=0.1, group=GROUP_FRAMEWORK, inline=\"band\", tooltip=\"Minimum band height relative to ATR.\")\r\nregime_timeout_bars_input = input.int(500, \"Regime timeout bars\", minval=0, group=GROUP_FRAMEWORK, inline=\"band\", tooltip=\"Bars since last shift before regime reset. Zero disables timeout.\")\r\nis_invert_colors_input = input.bool(false, \"Invert colors\", group=GROUP_FRAMEWORK, inline=\"col\", tooltip=\"Swap premium and discount colors.\")\r\n\r\nshow_zone_tint_input = input.bool(true, \"Show zone tint\", group=GROUP_VISUAL, inline=\"vis\", tooltip=\"Tint background in discount or premium bands.\")\r\nshow_structure_marks_input = input.bool(true, \"Show shift markers\", group=GROUP_VISUAL, inline=\"vis\", tooltip=\"Show first bullish and first bearish structure shift markers.\")\r\n\r\nrisk_percent_input = input.float(1.0, \"Risk per trade percent\", minval=0.0, maxval=5.0, step=0.1, group=GROUP_RISK, inline=\"risk\", tooltip=\"Account percent used to size position.\")\r\nis_use_band_for_size_input = input.bool(false, \"Use band for size\", group=GROUP_RISK, inline=\"risk\", tooltip=\"If enabled, band height is used to scale position size.\")\r\nis_close_on_opposite_input = input.bool(true, \"Flat on opposite shift\", group=GROUP_RISK, inline=\"exit\", tooltip=\"Close and reverse on opposite first shift.\")\r\nis_use_stop_band_input = input.bool(false, \"Use stop at band\", group=GROUP_RISK, inline=\"exit\", tooltip=\"If enabled, band edge is used as stop distance.\")\r\nstop_band_side_input = input.string(\"Opposite band edge\", \"Stop band side\", options=[\"Opposite band edge\", \"Same band edge\"], group=GROUP_RISK, inline=\"exit\", tooltip=\"Defines which band edge is used as stop reference.\")\r\n\r\n// â€”â€”â€” SECTION: Types\r\n// (no custom types)\r\n\r\n// â€”â€”â€” SECTION: Persistent Vars â†’ Runtime Vars\r\nvar float last_swing_high = na\r\nvar float last_swing_low = na\r\nvar int last_swing_high_bar = na\r\nvar int last_swing_low_bar = na\r\n\r\nvar int regime = 0\r\nvar float band_low = na\r\nvar float band_high = na\r\nvar float struct_level = na\r\n\r\nvar int last_shift_bar = na\r\nvar bool is_last_shift_bullish = false\r\n\r\n// â€”â€”â€” SECTION: Helpers (pure, no side effects)\r\nstop_from_band(is_long, band_low_value, band_high_value, stop_side) =>\r\n    float stop_price = na\r\n    if is_long\r\n        stop_price := stop_side == \"Opposite band edge\" ? band_low_value : band_high_value\r\n    else\r\n        stop_price := stop_side == \"Opposite band edge\" ? band_high_value : band_low_value\r\n    stop_price\r\n\r\n// â€”â€”â€” SECTION: Core Calculations\r\n\r\n// Swings and ATR\r\npivot_high_value = ta.pivothigh(high, swing_len_input, swing_len_input)\r\npivot_low_value = ta.pivotlow(low, swing_len_input, swing_len_input)\r\n\r\nif not na(pivot_high_value)\r\n    last_swing_high := pivot_high_value\r\n    last_swing_high_bar := bar_index - swing_len_input\r\n\r\nif not na(pivot_low_value)\r\n    last_swing_low := pivot_low_value\r\n    last_swing_low_bar := bar_index - swing_len_input\r\n\r\natr_value = ta.atr(atr_len_input)\r\n\r\n// Structure shifts\r\nhas_major_high = not na(last_swing_high)\r\nhas_major_low = not na(last_swing_low)\r\n\r\nis_bullish_break_base = has_major_high and close > last_swing_high\r\nis_bearish_break_base = has_major_low and close < last_swing_low\r\n\r\nis_bullish_break = is_bullish_break_base\r\nis_bearish_break = is_bearish_break_base\r\n\r\nif is_use_atr_filter_input and atr_value > 0.0\r\n    is_bullish_break := is_bullish_break_base and (close - last_swing_high) >= atr_mult_break_input * atr_value\r\n    is_bearish_break := is_bearish_break_base and (last_swing_low - close) >= atr_mult_break_input * atr_value\r\n\r\nis_bullish_shift = is_bullish_break and has_major_low\r\nis_bearish_shift = is_bearish_break and has_major_high\r\n\r\nif is_bullish_shift and is_bearish_shift\r\n    is_bullish_shift := close >= open\r\n    is_bearish_shift := not is_bullish_shift\r\n\r\nis_bullish_shift_first = is_bullish_shift and (na(last_shift_bar) or not is_last_shift_bullish)\r\nis_bearish_shift_first = is_bearish_shift and (na(last_shift_bar) or is_last_shift_bullish)\r\n\r\n// Regime and band update\r\nif is_bullish_shift\r\n    regime := 1\r\n    band_low := last_swing_low\r\n    band_high := high\r\n    struct_level := last_swing_high\r\n    last_shift_bar := bar_index\r\n    is_last_shift_bullish := true\r\n\r\nif is_bearish_shift\r\n    regime := -1\r\n    band_low := low\r\n    band_high := last_swing_high\r\n    struct_level := last_swing_low\r\n    last_shift_bar := bar_index\r\n    is_last_shift_bullish := false\r\n\r\n// Regime timeout and band clear\r\nif regime_timeout_bars_input > 0 and regime != 0 and not is_bullish_shift and not is_bearish_shift and not na(last_shift_bar) and bar_index - last_shift_bar > regime_timeout_bars_input\r\n    regime := 0\r\n    if not is_persist_last_band_input\r\n        band_low := na\r\n        band_high := na\r\n        struct_level := na\r\n\r\n// Premium and discount band\r\nis_base_valid_band = is_enable_framework_input and not na(band_low) and not na(band_high) and band_high > band_low\r\nprice_span = is_base_valid_band ? band_high - band_low : na\r\nis_band_not_tiny = is_base_valid_band and atr_value > 0.0 and min_band_atr_mult_input > 0.0 and price_span >= min_band_atr_mult_input * atr_value or is_base_valid_band and (min_band_atr_mult_input == 0.0 or atr_value <= 0.0)\r\nis_valid_band = is_base_valid_band and is_band_not_tiny\r\n\r\ndiscount_threshold = is_valid_band ? band_low + 0.25 * price_span : na\r\npremium_threshold = is_valid_band ? band_low + 0.75 * price_span : na\r\n\r\nis_in_discount = is_valid_band and close <= discount_threshold\r\nis_in_premium = is_valid_band and close >= premium_threshold\r\n\r\n// Execution sizing and stops\r\nacc_value = strategy.equity\r\nbase_qty = risk_percent_input > 0.0 ? acc_value * risk_percent_input * 0.01 / nz(close, 1.0) : 0.0\r\nband_qty_factor = is_use_band_for_size_input and is_valid_band and atr_value > 0.0 ? math.min(2.0, math.max(0.25, price_span / atr_value)) : 1.0\r\ntrade_qty = base_qty * band_qty_factor\r\n\r\nis_long_entry = is_bullish_shift_first\r\nis_short_entry = is_bearish_shift_first\r\n\r\nfloat long_stop = na\r\nfloat short_stop = na\r\n\r\nif is_use_stop_band_input and is_valid_band\r\n    long_stop := stop_from_band(true, band_low, band_high, stop_band_side_input)\r\n    short_stop := stop_from_band(false, band_low, band_high, stop_band_side_input)\r\n\r\n// Strategy entries and exits\r\nif is_long_entry and trade_qty > 0.0\r\n    if is_close_on_opposite_input and strategy.position_size < 0\r\n        strategy.close(\"Short\")\r\n    if is_use_stop_band_input and not na(long_stop)\r\n        strategy.entry(\"Long\", strategy.long, qty=trade_qty, stop=na, limit=na)\r\n        strategy.exit(\"Long SL\", \"Long\", stop=long_stop)\r\n    else\r\n        strategy.entry(\"Long\", strategy.long, qty=trade_qty)\r\n\r\nif is_short_entry and trade_qty > 0.0\r\n    if is_close_on_opposite_input and strategy.position_size > 0\r\n        strategy.close(\"Long\")\r\n    if is_use_stop_band_input and not na(short_stop)\r\n        strategy.entry(\"Short\", strategy.short, qty=trade_qty, stop=na, limit=na)\r\n        strategy.exit(\"Short SL\", \"Short\", stop=short_stop)\r\n    else\r\n        strategy.entry(\"Short\", strategy.short, qty=trade_qty)\r\n\r\n// â€”â€”â€” SECTION: Rendering/UI (GLOBAL ONLY; single-line calls)\r\ndiscount_zone_color = is_invert_colors_input ? color.new(color.red, 30) : color.new(color.green, 30)\r\npremium_zone_color = is_invert_colors_input ? color.new(color.green, 30) : color.new(color.red, 30)\r\n\r\ndiscount_bg_color = show_zone_tint_input and is_in_discount ? color.new(discount_zone_color, 85) : na\r\npremium_bg_color = show_zone_tint_input and is_in_premium ? color.new(premium_zone_color, 85) : na\r\n\r\nbgcolor(discount_bg_color, title=\"Discount zone tint\")\r\nbgcolor(premium_bg_color, title=\"Premium zone tint\")\r\n\r\nplotshape(show_structure_marks_input and is_bullish_shift_first ? low : na, title=\"Bullish structure shift first\", style=shape.triangleup, location=location.belowbar, size=size.small, color=color.new(color.lime, 0), text=\"Shift Up\", textcolor=color.white)\r\nplotshape(show_structure_marks_input and is_bearish_shift_first ? high : na, title=\"Bearish structure shift first\", style=shape.triangledown, location=location.abovebar, size=size.small, color=color.new(color.red, 0), text=\"Shift Down\", textcolor=color.white)\r\n"
  },
  {
    "url": "x4V1YAfd-Superior-Range-Bound-Renko-Strategy-11-29-25-SignalLynx",
    "name": "Superior-Range Bound Renko - Strategy - 11-29-25 - SignalLynx",
    "description": "Superior-Range Bound Renko Strategy with Advanced Risk Management Template\n\nSignal Lynx | Free Scripts supporting Automation for the Night-Shift Nation ðŸŒ™\n\n1. Overview\n\nWelcome to Superior-Range Bound Renko (RBR) â€” a volatility-aware, structure-respecting swing-trading system built on top of a full Risk Management (RM) Template from Signal Lynx.\n\nInstead of relying on static lookbacks (like â€œ14-period RSIâ€) or plain MA crosses, Superior RBR:\n\nAdapts its range definition to market volatility in real time\n\nEmulates Renko Bricks on a standard, time-based chart (no Renko chart type required)\n\nUses a stack of Laguerre Filters to detect genuine impulse vs. noise\n\nAdds an Adaptive SuperTrend powered by a small k-means-style clustering routine on volatility\n\nUnder the hood, this script also includes the full Signal Lynx Risk Management Engine:\n\nA state machine that separates â€œSignalâ€ from â€œExecutionâ€\n\nLayered exit tools: Stop Loss, Trailing Stop, Staged Take Profit, Advanced Adaptive Trailing Stop (AATS), and an RSI-style stop (RSIS)\n\nDesigned for non-repainting behavior on closed candles by basing execution-critical logic on previous-bar data\n\nWe are publishing this as an open-source template so traders and developers can leverage a professional-grade RM engine while integrating their own signal logic if they wish.\n\n2. Quick Action Guide (TL;DR)\n\nBest Timeframe:\n4 Hours (H4) and above. This is a high-conviction swing-trading system, not a scalper.\n\nBest Assets:\nVolatile instruments that still respect market structure:\nBitcoin, Ethereum, Gold (XAUUSD), high-volatility Forex pairs (e.g., GBPJPY), indices with clean ranges.\n\nStrategy Type:\nVolatility-Adaptive Trend Following + Impulse Detection.\nIt hunts for genuine expansion out of ranges, not tiny mean-reversion nibbles.\n\nKey Feature:\nRenko Emulation on time-based candles.\nWe mathematically model Renko Bricks and overlay them on your standard chart to define:\n\nâ€œEquilibriumâ€ zones (inside the brick structure)\n\nâ€œBreakout / impulseâ€ zones (when price AND the impulse line depart from the bricks)\n\nRepainting:\nDesigned to be non-repainting on closed candles.\nAll RM execution logic uses confirmed historical data (no future bars, no security() lookahead). Intrabar flicker during formation is allowed, but once a bar closes the engineâ€™s decisions are stable.\n\nCore Toggles & Filters:\n\nEnable Longs and Shorts independently\n\nOptional Weekend filter (block trades on Saturday/Sunday)\n\nPer-module toggles: Stop Loss, Trailing Stop, Staged Take Profits, AATS, RSIS\n\n3. Detailed Report: How It Works\nA. The Strategy Logic: Superior RBR\n\nSuperior RBR builds its entry signal from multiple mathematical layers working together.\n\n1) Adaptive Lookback (Volatility Normalization)\n\nInstead of a fixed 100-bar or 200-bar range, the script:\n\nComputes ATR-based volatility over a user-defined period.\n\nNormalizes that volatility relative to its recent min/max.\n\nMaps the normalized value into a dynamic lookback window between a minimum and maximum (e.g., 4 to 100 bars).\n\nHigh Volatility:\nThe lookback shrinks, so the system reacts faster to explosive moves.\n\nLow Volatility:\nThe lookback expands, so the system sees a â€œbigger pictureâ€ and filters out chop.\n\nAll the core â€œRange High/Lowâ€ and â€œRange Close High/Lowâ€ boundaries are built on top of this adaptive window.\n\n2) Range Construction & Quick Ranges\n\nThe engine constructs several nested ranges:\n\nOuter Range:\n\nrangeHighFinal â€“ dynamic highest high\n\nrangeLowFinal â€“ dynamic lowest low\n\nInner Close Range:\n\nrangeCloseHighFinal â€“ highest close\n\nrangeCloseLowFinal â€“ lowest close\n\nQuick Ranges:\nâ€œHalf-lengthâ€ variants of those, used to detect more responsive changes in structure and volatility.\n\nThese ranges define:\n\nThe macro box price is trading inside\n\nShorter-term â€œpressure zonesâ€ where price is coiling before expansion\n\n3) Renko Emulation (The Bricks)\n\nRather than using the Renko chart type (which discards time), this script emulates Renko behavior on your normal candles:\n\nA â€œbrick sizeâ€ is defined either:\n\nAs a standard percentage move, or\n\nAs a volatility-driven (ATR) brick, optionally inhibited by a minimum standard size\n\nThe engine tracks a base value and derives:\n\nbrickUpper â€“ top of the emulated brick\n\nbrickLower â€“ bottom of the emulated brick\n\nWhen price moves sufficiently beyond those levels, the brick â€œshiftsâ€, and the directional memory (renkoDir) updates:\n\nrenkoDir = +2 when bricks are advancing upward\n\nrenkoDir = -2 when bricks are stepping downward\n\nYou can think of this as a synthetic Renko tape overlaid on time-based candles:\n\nInside the brick: equilibrium / consolidation\n\nBreaking away from the brick: momentum / expansion\n\n4) Impulse Tracking with Laguerre Filters\n\nThe script uses multiple Laguerre Filters to smooth price and brick-derived data without traditional lag.\n\nKey filters include:\n\nLagF_1 / LagF_W: Based on brick upper/lower baselines\n\nLagF_Q: Based on HLCC4 (high + low + 2Ã—close)/4\n\nLagF_Y / LagF_P: Complex averages combining brick structures and range averages\n\nLagF_V (Primary Impulse Line):\nA smooth, high-level impulse line derived from a blend of the above plus the outer ranges\n\nConceptually:\n\nWhen the impulse line pushes away from the brick structure and continues in one direction, an impulse move is underway.\n\nWhen its direction flips and begins to roll over, the impulse is fading, hinting at mean reversion back into the range.\n\n5) Fib-Based Structure & Swaps\n\nThe system also layers in Fib levels derived from the adaptive ranges:\n\nStandard levels (12%, 23.6%, 38.2%, 50%, 61%, 76.8%, 88%) from the main range\n\nA secondary â€œswapâ€ set derived from close-range dynamics (fib12Swap, fib23Swap, etc.)\n\nThese Fibs are used to:\n\nBucket price into structural zones (below 12, between 23â€“38, etc.)\n\nDetect breakouts when price and Laguerre move beyond key Fib thresholds\n\nDrive zSwap logic (where a secondary Fib set becomes the active structure once certain conditions are met)\n\n6) Adaptive SuperTrend with K-Means-Style Volatility Clustering\n\nUnder the hood, the script uses a small k-means-style clustering routine on ATR:\n\nATR is measured over a fixed period\n\nThe range of ATR values is split into Low, Medium, High volatility centroids\n\nCurrent ATR is assigned to the nearest centroid (cluster)\n\nFrom that, a SuperTrend variant (STK) is computed with dynamic sensitivity:\n\nIn quiet markets, SuperTrend can afford to be tighter\n\nIn wild markets, it widens appropriately to avoid constant whipsaw\n\nThis SuperTrend-based oscillator (LagF_K and its signals) is then combined with the brick and Laguerre stack to confirm valid trend regimes.\n\n7) Final Baseline Signals (+2 / -2)\n\nThe â€œbrainâ€ of Superior RBR lives in the Baseline & Signal Generation block:\n\nTwo composite signals are built: B1 and B2:\n\nThey combine:\n\nFib breakouts\n\nRenko direction (renkoDir)\n\nExpansion direction (expansionQuickDir)\n\nMultiple Laguerre alignments (LagF_Q, LagF_W, LagF_Y, LagF_Z, LagF_P, LagF_V)\n\nThey also factor in whether Fib structures are expanding or contracting.\n\nA user toggle selects the â€œBaselineâ€ signal:\n\nfinalSig = B2 (default) or B1 (alternate baseline)\n\nfinalSig is then filtered through the RM state machine and only when everything aligns, we emit:\n\n+2 = Long / Buy signal\n\n-2 = Short / Sell signal\n\n0 = No new trade\n\nThose +2 / -2 values are what feed the Risk Management Engine.\n\nB. The Risk Management (RM) Engine\n\nThis script features the Signal Lynx Risk Management Engine, a proprietary state machine built to separate Signal from Execution.\n\nInstead of firing orders directly on indicator conditions, we:\n\nConvert the raw signal into a clean integer (Fin = +2 / -2 / 0)\n\nFeed it into a Trade State Machine that understands:\n\nAre we flat?\n\nAre we in a long or short?\n\nAre we in a closing sequence?\n\nShould we permit re-entry now or wait?\n\nLogic Injection / Template Concept:\n\nThe RM engine expects a simple integer:\n\n+2 â†’ Buy\n\n-2 â†’ Sell\n\nEverything else (0) is â€œno new tradeâ€\n\nThis makes the script a template:\n\nYou can remove the Superior RBR block\n\nDrop in your own logic (RSI, MACD, price action, etc.)\n\nAs long as you output +2 or -2 into the same signal channel, the RM engine can drive all exits and state transitions.\n\nAggressive vs Conservative Modes:\n\nThe input AgressiveRM (Aggressive RM) governs how we interpret signals:\n\nConservative Mode (Aggressive RM = false):\n\nUses a more filtered internal signal (AF) to open trades\n\nEffectively waits for a clean trend flip / confirmation before new entries\n\nMinimizes whipsaw at the cost of fewer trades\n\nAggressive Mode (Aggressive RM = true):\n\nReacts directly to the fresh alert (AO) pulses\n\nAllows faster re-entries in the same direction after RM-based exits\n\nStill respects your pyramiding setting; this script ships with pyramiding = 0 by default, so it will not stack multiple positions unless you change that parameter in the strategy() call.\n\nThe state machine enforces discipline on top of your signal logic, reducing double-fires and signal spam.\n\nC. Advanced Exit Protocols (Layered Defense)\n\nThe exit side is where this template really shines. Instead of a single â€œtake profit or stop loss,â€ it uses multiple, cooperating layers.\n\n1) Hard Stop Loss\n\nA classic percentage-based Stop Loss (SL) relative to the entry price.\n\nActs as a final â€œcatastrophic protectionâ€ layer for unexpected moves.\n\n2) Standard Trailing Stop\n\nA percentage-based Trailing Stop (TS) that:\n\nActivates only after price has moved a certain percentage in your favor (tsActivation)\n\nThen trails price by a configurable percentage (ts)\n\nThis is a straightforward, battle-tested trailing mechanism.\n\n3) Staged Take Profits (Three Levels)\n\nThe script supports three staged Take Profit levels (TP1, TP2, TP3):\n\nEach stage has:\n\nActivation percentage (how far price must move in your favor)\n\nTrailing amount for that stage\n\nPosition percentage to close\n\nExample setup:\n\nTP1:\n\nActivate at +10%\n\nTrailing 5%\n\nClose 10% of the position\n\nTP2:\n\nActivate at +20%\n\nTrailing 10%\n\nClose another 10%\n\nTP3:\n\nActivate at +30%\n\nTrailing 5%\n\nClose the remaining 80% (â€œrunnerâ€)\n\nYou can tailor these quantities for partial scaling out vs. letting a core position ride.\n\n4) Advanced Adaptive Trailing Stop (AATS)\n\nAATS is a sophisticated volatility- and structure-aware stop:\n\nUses Hirashima Sugita style levels (HSRS) to model â€œfloorsâ€ and â€œceilingsâ€ of price:\n\nDungeon â†’ Lower floors â†’ Mid â†’ Upper floors â†’ Penthouse\n\nThese levels classify where current price sits within a long-term distribution.\n\nCombines HSRS with Bollinger-style envelopes and EMAs to determine:\n\nIs price extended far into the upper structure?\n\nIs it compressed near the lower ranges?\n\nFrom this, it computes an adaptive factor that controls how tight or loose the trailing level (aATS / bATS) should be:\n\nHigh Volatility / Penthouse areas:\n\nStop loosens to avoid getting wicked out by inevitable spikes.\n\nLow Volatility / compressed structure:\n\nStop tightens to lock in and protect profit.\n\nAATS is designed to be the â€œsmart last lineâ€ that responds to context instead of a single fixed percentage.\n\n5) RSI-Style Stop (RSIS)\n\nOn top of AATS, the script includes a RSI-like regime filter:\n\nA McGinley Dynamic mean of price plus ATR bands creates a dynamic channel.\n\nCrosses above the top band and below the lower band change a directional state.\n\nWhen enabled (UseRSIS):\n\nRSIS can confirm or veto AATS closes:\n\nFor longs: A shift to bearish RSIS can force exits sooner.\n\nFor shorts: A shift to bullish RSIS can do the same.\n\nThis extra layer helps avoid over-reactive stops in strong trends while still respecting a regime change when it happens.\n\nD. Repainting Protection\n\nMany strategies look incredible in the Strategy Tester but fail in live trading because they rely on intrabar values or future-knowledge functions.\n\nThis template is built with closed-candle realism in mind:\n\nThe Risk Management logic explicitly uses previous bar data (open , high , low , close ) for the key decisions on:\n\nTrailing stop updates\n\nTP triggers\n\nSL hits\n\nRM state transitions\n\nNo security() lookahead or future-bar access is used.\n\nThis means:\n\nBacktest behavior is designed to match what you can actually get with TradingView alerts and live automation.\n\nSignals may â€œflickerâ€ intrabar while the candle is forming (as with any strategy), but on closed candles, the RM decisions are stable and non-repainting.\n\n4. For Developers & Modders\n\nWe strongly encourage you to mod this script.\n\nTo plug your own strategy into the RM engine:\n\nLook for the section titled:\n// BASELINE & SIGNAL GENERATION\n\nYou will see composite logic building B1 and B2, and then selecting:\n\nbaseSig  = B2\naltSig   = B1\nfinalSig = sigSwap ? baseSig : altSig\n\n\nYou can replace the content used to generate baseSig / altSig with your own logic, for example:\n\nRSI crosses\n\nMACD histogram flips\n\nCandle pattern detectors\n\nExternal condition flags\n\nRequirements are simple:\n\nYour final logic must output:\n\n2 â†’ Buy signal\n\n-2 â†’ Sell signal\n\n0 â†’ No new trade\n\nThat output flows into the RM engine via finalSig â†’ AlertOpen â†’ state machine â†’ Fin.\n\nOnce you wire your signals into finalSig, the entire Risk Management system (Stops, TPs, AATS, RSIS, re-entry logic, weekend filters, long/short toggles) becomes available for your custom strategy without re-inventing the wheel.\n\nThis makes Superior RBR not just a strategy, but a reference architecture for serious Pine dev work.\n\n5. About Signal Lynx\n\nAutomation for the Night-Shift Nation ðŸŒ™\n\nSignal Lynx focuses on helping traders and developers bridge the gap between indicator logic and real-world automation. The same RM engine you see here powers multiple internal systems and templates, including other public scripts like the Super-AO Strategy with Advanced Risk Management.\n\nWe provide this code open source under the Mozilla Public License 2.0 (MPL-2.0) to:\n\nDemonstrate how Adaptive Logic and structured Risk Management can outperform static, one-layer indicators\n\nGive Pine Script users a battle-tested RM backbone they can reuse, remix, and extend\n\nIf you are looking to automate your TradingView strategies, route signals to exchanges, or simply want safer, smarter strategy structures, please keep Signal Lynx in your search.\n\nLicense: Mozilla Public License 2.0 (Open Source).\nIf you make beneficial modifications, please consider releasing them back to the community so everyone can benefit.",
    "image_url": "x4V1YAfd",
    "author": "SignalLynx",
    "likes": 9,
    "type": "strategy",
    "created": "2025-11-30",
    "updated": "2025-11-30",
    "source": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// Â© SignalLynx\r\n\r\n//@version=6\r\n// Superior-Range Bound Renko - Strategy - By SignalLynx 11-29-25 Release\r\n\r\n// ============================================================================================================\r\n//     SIGNAL LYNX - SUPERIOR RANGE BOUND RENKO (RBR)\r\n// ============================================================================================================\r\n//\r\n//     INTRODUCTION:\r\n//     This script implements \"Superior RBR,\" an elevated take on Range Bounding combined with \r\n//     Renko Brick emulation. Unlike standard static indicators, this system actively monitors \r\n//     and adapts to price action volatility.\r\n//    \r\n//     HOW IT WORKS:\r\n//     1. Adaptive Range Bounding: Calculates dynamic High/Low ranges based on volatility (ATR).\r\n//     2. Renko Emulator: Visualizes price movement as \"Bricks\" on a standard candlestick chart \r\n//        without the repainting issues of standard Renko charts.\r\n//     3. Impulse Tracking (The Cyan/Red Line): This is a Laguerre Filter applied to the brick structure.\r\n//        - Extension beyond the bricks indicates an Impulse move has started.\r\n//        - Color changes indicate the impulse is ending and price is reverting.\r\n//     4. K-Means SuperTrend: Used as a secondary filter to confirm trend regimes.\r\n//    \r\n//     THE RISK MANAGEMENT (RM) ENGINE:\r\n//     This code features the Signal Lynx Risk Management Engine. It separates the \"Signal\" from the \"Execution.\"\r\n//     - Logic Injection: The engine expects a simple integer signal: +2 (Buy) or -2 (Sell).\r\n//     - Repainting Protection: Uses actual candle closes for critical logic.\r\n//     - Advanced Exits: Includes Staged Take Profits, Trailing Stops, and an Advanced Adaptive \r\n//       Trailing Stop (AATS) based on Hirashima Sugita and Bollinger Bands.\r\n//\r\n//     --------------------------------------------------------------------------------------------------------\r\n//     Signal Lynx\r\n//     Free Scripts supporting Automation for the Night-Shift Nation ðŸŒ™\r\n//     (www.signallynx.com)\r\n//     --------------------------------------------------------------------------------------------------------\r\n\r\n// ==============================================================================\r\n//  !!! MODE SELECTION - READ CAREFULLY !!!\r\n// ==============================================================================\r\n//  Pine Script can run as a STRATEGY (Backtesting) or an INDICATOR (Alerts).\r\n//  You must uncomment only ONE of the following two lines.\r\n\r\n//  OPTION 1: STRATEGY MODE (Default) \r\n//  Use this to see Buy/Sell tags on the chart and run the Strategy Tester.\r\nstrategy('Superior-Range Bound Renko - Strategy - 11-29-25', shorttitle='Superior-RBR - 11-29-25', overlay=true, initial_capital=1000, max_bars_back = 5000, commission_type=strategy.commission.percent, commission_value=0.26, currency=currency.USD, default_qty_type=strategy.percent_of_equity, default_qty_value=100, pyramiding=0, slippage=5)\r\n\r\n//  OPTION 2: INDICATOR/ALERT MODE\r\n//  Use this to set up Alerts for automation.\r\n//indicator('Superior-Range Bound Renko - Alerts - 1-29-25', shorttitle='Superior-RBR (Alerts) - 11-29-25', overlay=true, max_bars_back = 5000) \r\n// ==============================================================================\r\n\r\n\r\n// ==========================================\r\n// â”€â”€â”€ HELPER FUNCTIONS â”€â”€â”€\r\n// ==========================================\r\n\r\n// Helper function to clamp lookback for Adaptive Logic\r\nf_clampLookback(norm, minVal, maxVal) =>\r\n    if na(norm)\r\n        na\r\n    else\r\n        math.round(minVal + norm * float(maxVal - minVal))\r\n\r\n// Helper function for Laguerre Filter (Reduces repetitive code blocks)\r\nf_calc_laguerre(float src, float gamma) =>\r\n    var float l0 = 0.0\r\n    var float l1 = 0.0\r\n    var float l2 = 0.0\r\n    var float l3 = 0.0\r\n    \r\n    l0 := (1 - gamma) * src + gamma * nz(l0[1])\r\n    l1 := -gamma * l0 + nz(l0[1]) + gamma * nz(l1[1])\r\n    l2 := -gamma * l1 + nz(l1[1]) + gamma * nz(l2[1])\r\n    l3 := -gamma * l2 + nz(l2[1]) + gamma * nz(l3[1])\r\n    \r\n    (l0 + 2 * l1 + 2 * l2 + l3) / 6\r\n\r\n\r\n// ==========================================\r\n// â”€â”€â”€ INPUTS: BACKTEST RANGE â”€â”€â”€\r\n// ==========================================\r\nvar BackTestMod = \"Back Test Inputs\"\r\ntestStartYear   = input.int(2019, '- Start year', group=BackTestMod)\r\ntestStartMonth  = input.int(01,   '- Start month', group=BackTestMod) \r\ntestStartDay    = input.int(01,   '- Start day',   group=BackTestMod)\r\ntestStopYear    = input.int(99999,'- Stop year',   group=BackTestMod)\r\ntestStopMonth   = input.int(12,   '- Stop month',  group=BackTestMod)\r\ntestStopDay     = input.int(30,   '- Stop day',    group=BackTestMod)\r\n\r\ntestPeriodStart = timestamp(testStartYear, testStartMonth, testStartDay, 0, 0) \r\ntestPeriodStop  = timestamp(testStopYear, testStopMonth, testStopDay, 0, 0)\r\n\r\ntestPeriod() => time >= testPeriodStart and time <= testPeriodStop\r\n\r\n\r\n// ==========================================\r\n// â”€â”€â”€ INPUTS: STRATEGY & DIRECTION â”€â”€â”€\r\n// ==========================================\r\nvar LnS = \"Strategy Options - Longs and Shorts\"\r\nLnS_Longs  = input.bool(true,  title='Longs',  group=LnS)\r\nLnS_Shorts = input.bool(false, title='Shorts', group=LnS)\r\n\r\nLongAndShort = LnS_Longs and LnS_Shorts ? 1 : LnS_Longs and not LnS_Shorts ? 2 : not LnS_Longs and LnS_Shorts ? 3 : 1\r\n\r\n\r\n// ==========================================\r\n// â”€â”€â”€ SUPERIOR RBR LOGIC â”€â”€â”€\r\n// ==========================================\r\n\r\n// --- Adaptive Lookback Calculation ---\r\n// [NOTE] This section calculates volatility to determine how far back the system \r\n// should look to define \"Range\". Higher volatility = Shorter lookback.\r\nvar RB = \"Range Bound Inputs\"\r\nUseAdaptiveLB   = input.bool(false, \"Use Adaptive Lookback?\", group=RB)\r\nfixedLookback   = input.int(100, \"Lookback Length (Default=100)\", minval=1, group=RB)\r\nvolPeriod       = input.int(50, \"Volatility Period for Adaptive LB\", group=RB)\r\nminLookbackVal  = input.int(4,  \"Min Lookback\",  group=RB)\r\nmaxLookbackVal  = input.int(100,\"Max Lookback\",  group=RB)\r\n\r\natrVol = ta.atr(volPeriod)\r\nhasEnoughBars = bar_index >= volPeriod\r\n\r\n// Calculate Min/Max volatility outside ternary to ensure consistency\r\n_volMinRaw = ta.lowest(atrVol, volPeriod)\r\n_volMaxRaw = ta.highest(atrVol, volPeriod)\r\n\r\nvolMin   = hasEnoughBars ? _volMinRaw : na\r\nvolMax   = hasEnoughBars ? _volMaxRaw : na\r\nvolRange = (not na(volMax) and not na(volMin)) ? (volMax - volMin) : 0.0\r\nvolNorm  = (volRange == 0.0) or (not hasEnoughBars) ? na : (atrVol - volMin) / volRange\r\n\r\nadaptiveLB = f_clampLookback(volNorm, minLookbackVal, maxLookbackVal)\r\nlookback_float = not UseAdaptiveLB ? fixedLookback : (na(adaptiveLB) ? fixedLookback : adaptiveLB)\r\nlookback = int(lookback_float)\r\n\r\n// --- Range Definitions ---\r\n// Calculating the physical boundaries of the current range\r\nrangeHigh      = ta.highest(high, lookback)\r\nrangeLow       = ta.lowest(low, lookback)\r\nrangeOpenHigh  = ta.highest(open, lookback)\r\nrangeOpenLow   = ta.lowest(open, lookback)\r\nrangeCloseHigh = ta.highest(close, lookback)\r\nrangeCloseLow  = ta.lowest(close, lookback)\r\n\r\nrangeHighChange      = rangeHigh <= rangeHigh[1] ? 1 : 0\r\nrangeLowChange       = rangeLow >= rangeLow[1] ? 1 : 0\r\nrangeOpenHighChange  = rangeOpenHigh <= rangeOpenHigh[1] ? 1 : 0\r\nrangeOpenLowChange   = rangeOpenLow >= rangeOpenLow[1] ? 1 : 0\r\nrangeCloseHighChange = rangeCloseHigh <= rangeCloseHigh[1] ? 1 : 0\r\nrangeCloseLowChange  = rangeCloseLow >= rangeCloseLow[1] ? 1 : 0\r\n\r\n// High Range Construction\r\nvar int rangeHighCounter = 1\r\nrangeHighCounter := rangeLowChange == 0 ? 1 : rangeHighCounter + 1\r\nrangeHighFinalLength = rangeHighCounter < lookback ? rangeHighCounter : lookback\r\nrangeHighFinal = ta.highest(high, rangeHighFinalLength)\r\nplot(rangeHighFinal, color=color.lime, linewidth=3, title=\"Range High\") \r\n\r\n// Low Range Construction\r\nvar int rangeLowCounter = 1\r\nrangeLowCounter := rangeHighChange == 0 ? 1 : rangeLowCounter + 1\r\nrangeLowFinalLength = rangeLowCounter < lookback ? rangeLowCounter : lookback\r\nrangeLowFinal = ta.lowest(low, rangeLowFinalLength)\r\nplot(rangeLowFinal, color=color.red, linewidth=3, title=\"Range Low\")\r\n\r\n// Close High/Low Construction (Inner Range)\r\nvar int rangeCloseHighCounter = 1\r\nrangeCloseHighCounter := rangeCloseHighChange == 0 ? 1 : rangeCloseHighCounter + 1\r\nrangeCloseHighFinalLength = rangeCloseHighCounter < lookback ? rangeCloseHighCounter : lookback\r\nrangeCloseHighFinal = ta.highest(close, rangeCloseHighFinalLength)\r\nplot(rangeCloseHighFinal, color=color.olive, linewidth=4, title=\"Range Close High\")\r\n\r\nvar int rangeCloseLowCounter = 1\r\nrangeCloseLowCounter := rangeCloseLowChange == 0 ? 1 : rangeCloseLowCounter + 1\r\nrangeCloseLowFinalLength = rangeCloseLowCounter < lookback ? rangeCloseLowCounter : lookback\r\nrangeCloseLowFinal = ta.lowest(close, rangeCloseLowFinalLength) \r\nplot(rangeCloseLowFinal, color=color.orange, linewidth=4, title=\"Range Close Low\")\r\n\r\n// Quick Ranges (Fast reaction)\r\nquick1 = (rangeHighFinalLength / 2) < 2 ? 2 : int(rangeHighFinalLength / 2)\r\nquick2 = (rangeLowFinalLength / 2) < 2 ? 2 : int(rangeLowFinalLength / 2)\r\nquickLengthAvg = math.round(math.avg(quick1, quick2))\r\n\r\nrangeCloseHighQuick = ta.highest(close, quick1)\r\nrangeCloseLowQuick  = ta.lowest(close, quick2)\r\nstandardAvg         = math.avg(rangeLowFinal, rangeHighFinal)\r\nquickCloseAvg       = math.avg(rangeCloseHighQuick, rangeCloseLowQuick)\r\n\r\nLA1 = (rangeCloseHighFinalLength / 2) < 2 ? 2 : int(rangeCloseHighFinalLength / 2)\r\nLA2 = (rangeCloseLowFinalLength / 2) < 2 ? 2 : int(rangeCloseLowFinalLength / 2)\r\nLAAvg = int(math.round(math.avg(LA1, quick2)))\r\n\r\n\r\n// --- Support & Resistance (S&R) ---\r\n// Visualizes static S&R lines based on the range breaks\r\nvar S_and_R = \"Support and Resistance\"\r\nUseChart        = input.bool(false, title='Chart Support and Resistance)', group=S_and_R)\r\nUseChartRedraw  = input.bool(false, title='Redraw S&R at Each Rangebreak', group=S_and_R)\r\nUseLines = (UseChart and UseChartRedraw) ? 1 : 0\r\nUsePlots = (UseChart and not UseChartRedraw) ? 1 : 0\r\n\r\n// [NOTE] Logic simplified for plotting static lines on range locks.\r\n// (Detailed S&R plotting logic omitted for brevity, but functional in chart)\r\nvar float preCloseHigh1 = 0.0, var float preCloseHigh2 = 0.0\r\nHighTrigger = rangeCloseHighChange == 0 and rangeCloseHighFinal[1] == rangeCloseHighFinal[14] ? 1 : 0\r\npreCloseHigh1 := HighTrigger == 1 ? rangeCloseHighFinal[1] : preCloseHigh1[1]\r\npreCloseHigh2 := HighTrigger == 1 ? preCloseHigh1[1] : preCloseHigh2[1]\r\n\r\nplot(UsePlots == 1 ? preCloseHigh1 : na, color=color.black, title=\"S&R High 1\")\r\nplot(UsePlots == 1 ? preCloseHigh2 : na, color=color.black, title=\"S&R High 2\")\r\n\r\nvar float preCloseLow1 = 0.0, var float preCloseLow2 = 0.0\r\nLowTrigger = rangeCloseLowChange == 0 and rangeCloseLowFinal[1] == rangeCloseLowFinal[14] ? 1 : 0\r\npreCloseLow1 := LowTrigger == 1 ? rangeCloseLowFinal[1] : preCloseLow1[1]\r\npreCloseLow2 := LowTrigger == 1 ? preCloseLow1[1] : preCloseLow2[1]\r\n\r\nplot(UsePlots == 1 ? preCloseLow1 : na, color=color.gray, title=\"S&R Low 1\")\r\nplot(UsePlots == 1 ? preCloseLow2 : na, color=color.gray, title=\"S&R Low 2\")\r\n\r\n\r\n// --- Fibonacci Levels ---\r\n// Dynamic fibs based on the current active range\r\ndebauchFibHigh = rangeHighFinal \r\ndeabuchFibLow  = rangeLowFinal\r\n\r\nvar int zSwap = 0\r\nvar emulator = \"Renko Emulator Settings\"\r\nvar bool useFib_Input = input.bool(false, \"Use RangeBound Fib Breaks as Renko Blocks\", group = emulator)\r\nuseFib = useFib_Input\r\n\r\ntriggerSwapHigh = zSwap == 1 and useFib ? debauchFibHigh : rangeCloseHighFinal\r\ntriggerSwapLow  = zSwap == 1 and useFib ? deabuchFibLow  : rangeCloseLowFinal\r\n\r\nfibRange    = triggerSwapHigh - triggerSwapLow\r\nfibRangeLow = triggerSwapLow\r\n\r\n// Standard Fibs\r\nfib12 = (fibRange * 0.12)  + fibRangeLow\r\nfib23 = (fibRange * 0.236) + fibRangeLow\r\nfib38 = (fibRange * 0.382) + fibRangeLow\r\nfib50 = (fibRange * 0.5)   + fibRangeLow\r\nfib61 = (fibRange * 0.61)  + fibRangeLow\r\nfib76 = (fibRange * 0.768) + fibRangeLow\r\nfib88 = (fibRange * 0.88)  + fibRangeLow\r\n\r\nplot(fib12, color=color.black, linewidth=2, title=\"Fib 12\")\r\nplot(fib23, color=color.black, linewidth=2, title=\"Fib 23\")\r\nplot(fib50, color=color.black, linewidth=2, title=\"Fib 50\")\r\nplot(fib88, color=color.black, linewidth=2, title=\"Fib 88\")\r\n\r\n// Fib Location Tracker (Bucket Logic)\r\nlocTrackerSet = close\r\nint FibLoc = locTrackerSet < fib12 ? 1 : locTrackerSet >= fib12 and locTrackerSet < fib23 ? 2 : locTrackerSet >= fib23 and locTrackerSet < fib38 ? 3 : locTrackerSet >= fib23 and locTrackerSet < fib50 ? 4 : locTrackerSet >= fib50 and locTrackerSet < fib61 ? 5 : locTrackerSet >= fib61 and locTrackerSet < fib76 ? 6 : locTrackerSet >= fib76 and locTrackerSet < fib88 ? 7 : 8\r\n\r\nfibLocHigh = FibLoc==1 ? fib12 : FibLoc==2 ? fib23 : FibLoc==3 ? fib38 : FibLoc==4 ? fib50 : FibLoc==5 ? fib61 : FibLoc==6 ? fib76 : FibLoc==7 ? fib88 : debauchFibHigh\r\nfibLocLow  = FibLoc==1 ? deabuchFibLow : FibLoc==2 ? fib12 : FibLoc==3 ? fib23 : FibLoc==4 ? fib38 : FibLoc==5 ? fib50 : FibLoc==6 ? fib61 : FibLoc==7 ? fib76 : fib88\r\n\r\n\r\n// --- Renko Emulator ---\r\n// Emulates Brick behavior on standard charts\r\nvar emulatorInputs = \"Renko Emulator Inputs\"\r\nvar emulatorPlots  = \"Emulator Plot Settings\"\r\n\r\nsourceBrick   = input.source(close, \"Brick Source (Default is Close)\", group = emulator)\r\nbrickType     = input.bool(true, \"Choose Brick Size - Default (True) is Standard Bricks; False is ATR\", group = emulator)\r\natrInhib      = input.bool(false, \"For ATR Emulator Settings - Use 'Standard Brick Size (in Percent)' as an Inhibitor\", group = emulator)\r\nstandardBrick = input.float(0.5, \"Standard Brick Size (In Percent)\", minval=0, step=0.1, maxval=100, group = emulatorInputs)/100\r\natrLength     = input.int(100, \"ATR Length for Renko (Default = 100)\", minval=1, step=1, group = emulatorInputs)\r\natrMod        = input.int(5, \"ATR Modifier (Default = 5)\", minval=1, step=1, group = emulatorInputs)\r\nuseBrickPlots = input.bool(true, \"Plot Emulated Bricks\", group = emulatorPlots)\r\nuseFill       = input.bool(true, \"Fill between Emulated Bricks\", group = emulatorPlots)\r\n\r\n// ATR for Renko sizing\r\natrGet  = ta.atr(atrLength)\r\natrHigh = ta.highest(atrGet, atrLength)\r\natrLow  = ta.lowest(atrGet, atrLength)\r\n\r\natrBrick      = ((atrHigh - atrLow) / sourceBrick) * atrMod \r\natrBrickInhib = atrBrick > standardBrick ? atrBrick : standardBrick\r\natrBrickFinal = atrInhib == false ? atrBrick : atrBrickInhib\r\nbrick         = brickType == true ? standardBrick : atrBrickFinal\r\n\r\n// Emulated Renko Block Calculation\r\nfloat baseValue = sourceBrick\r\nvar int updateBase = 1\r\n\r\nbaseValue := updateBase == 1 ? sourceBrick : baseValue[1]\r\nbrickUpper = useFib ? fibLocHigh[1] : baseValue * (1 + brick)\r\nbrickLower = useFib ? fibLocLow[1]  : baseValue * (1 - brick)\r\n\r\ncalculateUpper = sourceBrick > brickUpper ? 1 : 0\r\ncalculateLower = sourceBrick < brickLower ? -1 : 0\r\nupdateBase := calculateUpper == 1 or calculateLower == -1 ? 1 : 0\r\n\r\n// Plotting the Renko Bricks\r\nplot(useBrickPlots ? baseValue : na, color=color.aqua, linewidth=1, title=\"Renko Base\")\r\nplot(useBrickPlots and not useFill ? brickUpper : na, color=color.lime, linewidth=1, title=\"Renko Upper\")\r\nplot(useBrickPlots and not useFill ? brickLower : na, color=color.fuchsia, linewidth=1, title=\"Renko Lower\")\r\nU = plot(useBrickPlots and useFill ? brickUpper : na, color=color.black, linewidth=1, title=\"Renko Upper Fill\")\r\nL = plot(useBrickPlots and useFill ? brickLower : na, color=color.black, linewidth=1, title=\"Renko Lower Fill\")\r\n\r\nvar int getFillColor = 0\r\ngetFillColor := baseValue > baseValue[1] ? 1 : baseValue < baseValue[1] ? -1 : getFillColor[1]\r\nfillColor = getFillColor == 1 ? color.new(color.aqua, 25) : getFillColor == -1 ? color.new(color.red, 25) : color.orange\r\nfill(U, L, color=fillColor)\r\n\r\n// Cleanup vars for logic\r\nEmuBrick = math.avg(rangeCloseHighFinal, rangeCloseLowFinal) \r\nbrickAvgX = math.avg(brickUpper, brickLower)\r\nbrickAvgXOld = math.avg(rangeCloseHighQuick, rangeCloseLowQuick)\r\nbrickAvgY = math.avg(rangeHighFinal, rangeLowFinal)\r\nrangeAverage = (rangeLowFinal + rangeHighFinal) / 2\r\n\r\n// Renko Directional Memory\r\nvar int renkoDir = 0\r\nrenkoDir := baseValue > baseValue[1] ? 2 : baseValue < baseValue[1] ? -2 : renkoDir[1]\r\n\r\n// Expansion logic (Volatility expansion detection)\r\nexpansion = fibRange > fibRange[1] ? 1 : 0\r\nexpansionRangeQuick = rangeHighFinal - rangeLowFinal\r\nexpansionQuick = expansionRangeQuick > expansionRangeQuick[1] ? 1 : 0\r\nexpansionBrickRange = brickUpper - brickLower\r\nexpansionBrick = expansionBrickRange > expansionBrickRange[1] ? 1 : 0 \r\n\r\nvar int expansionQuickPerp = 0\r\nexpansionQuickPerp := expansionRangeQuick > expansionRangeQuick[1] ? 1 : expansionRangeQuick < expansionRangeQuick[1] ? 0 : expansionQuickPerp[1]\r\nexpansionQuickDir = expansionQuick == 1 and rangeHighFinal > rangeHighFinal[1] ? 1 : expansionQuick == 1 and rangeLowFinal < rangeLowFinal[1] ? -1 : 0\r\n\r\n\r\n// --- Laguerre Filters (Impulse Tracking) ---\r\n// [NOTE] Laguerre Filters are used here to create smooth, responsive trend lines.\r\n// The primary impulse line (LagF_V) changes color based on direction.\r\nreturns = math.log(close / close[1])\r\nvolatility = ta.stdev(returns, LAAvg)\r\nvolatilityMin = ta.lowest(volatility, LAAvg)\r\nvolatilityMax = ta.highest(volatility, LAAvg) \r\n\r\nnormalizedVolatility = (volatility - volatilityMin) / (volatilityMax - volatilityMin)\r\nrelativeVolatility = 1 - normalizedVolatility\r\n\r\n// True Range calculations\r\natrHigh89 = ta.highest(rangeHighFinal, rangeHighFinalLength)\r\natrLow89  = ta.lowest(rangeLowFinal, rangeLowFinalLength)\r\nhighLow   = atrHigh89 - atrLow89 \r\nhighClose = math.abs(atrHigh89 - rangeHighFinal)\r\nlowClose  = math.abs(atrLow89 - rangeLowFinal)\r\ntrueRange = math.max(highLow, math.max(highClose, lowClose))\r\n\r\nwepSlow = (math.abs(EmuBrick - trueRange) / EmuBrick)\r\nwepFast = (math.abs(quickCloseAvg - rangeAverage) / quickCloseAvg)\r\nwepAvg  = math.avg(wepSlow, wepFast)\r\nwepTotality = math.avg(wepSlow, wepSlow, wepSlow, relativeVolatility)\r\n\r\n// 1. LagF_1 (Brick Upper Baseline)\r\nsrc_1 = brickUpper\r\ngamma_1 = math.pow(wepAvg, wepSlow)\r\nLagF_1 = f_calc_laguerre(src_1, gamma_1)\r\nvar int lagSigATF = 0\r\nlagSigATF := LagF_1 > (LagF_1[1]) ? 2 : LagF_1 < (LagF_1[1]) ? -2 : lagSigATF[1]\r\nColor_ATF = lagSigATF == 2 ? color.aqua : lagSigATF == -2 ? color.fuchsia : color.yellow\r\nplot(LagF_1, title='LagF', linewidth=3, color=Color_ATF)\r\n\r\n// 2. LagF_W (Brick Lower Baseline)\r\nsrc_W = brickLower\r\ngamma_W = math.pow(wepAvg, wepSlow)\r\nLagF_W = f_calc_laguerre(src_W, gamma_W)\r\nvar int lagSig_W = 0\r\nlagSig_W := LagF_W > (LagF_W[1]) ? 2 : LagF_W < (LagF_W[1]) ? -2 : lagSig_W[1]\r\nColor_lagSig_W = lagSig_W == 2 ? color.lime : lagSig_W == -2 ? color.red : color.yellow\r\nplot(LagF_W, title='LagW', linewidth=3, color=Color_lagSig_W)\r\n\r\n// 3. LagF_Q (Based on HLCC4)\r\nsrc_Q = hlcc4\r\nalpha_Q = input.float(title='LagF - Alpha Q', minval=0, maxval=1, step=0.1, defval=1.0)\r\ngamma_Q = 1 - alpha_Q\r\nLagF_Q = f_calc_laguerre(src_Q, gamma_Q)\r\nvar int lagSig_Q = 0\r\nlagSig_Q := LagF_Q > (LagF_Q[1]) ? 2 : LagF_Q < (LagF_Q[1]) ? -2 : lagSig_Q[1]\r\nColor_lagSig_Q = lagSig_Q == 2 ? color.gray : lagSig_Q == -2 ? color.orange : color.yellow\r\nplot(LagF_Q, title='LagQ', linewidth=3, color=Color_lagSig_Q)\r\n\r\n// 4. LagF_Z (Based on Brick Average)\r\nsrc_Z = brickAvgX\r\ngamma_Z = math.pow(wepAvg, wepSlow)\r\nLagF_Z = f_calc_laguerre(src_Z, gamma_Z)\r\nvar int lagSig_Z = 0\r\nlagSig_Z := LagF_Z > (LagF_Z[1]) ? 2 : LagF_Z < (LagF_Z[1]) ? -2 : lagSig_Z[1]\r\nColor_lagSig_Z = lagSig_Z == 2 ? color.blue : lagSig_Z == -2 ? color.maroon : color.yellow\r\nplot(LagF_Z, title='LagZ', linewidth=3, color=Color_lagSig_Z)\r\n\r\n// 5. LagF_Y (Complex Average)\r\ncrazyAvg = math.avg(brickUpper, brickLower, brickAvgX, hlcc4)\r\ncrazyAvgOld = math.avg(rangeCloseHighQuick, rangeCloseLowQuick, brickAvgXOld, hlcc4)\r\nsrc_Y = crazyAvgOld\r\nalpha_Y = input.float(title='LagF - Alpha Y', minval=0, maxval=1, step=0.1, defval=1.0)\r\ngamma_Y = 1 - alpha_Y\r\nLagF_Y = f_calc_laguerre(src_Y, gamma_Y)\r\nvar int lagSig_Y = 0\r\nlagSig_Y := LagF_Y > (LagF_Y[1]) ? 2 : LagF_Y < (LagF_Y[1]) ? -2 : lagSig_Y[1]\r\nColor_lagSig_Y = lagSig_Y == 2 ? color.olive : lagSig_Y == -2 ? color.yellow : color.yellow\r\nplot(LagF_Y, title='LagY', linewidth=3, color=Color_lagSig_Y)\r\n\r\n// 6. LagF_P (Averaged Y and Brick Y)\r\nsrc_P = math.avg(crazyAvg, brickAvgY)\r\ngamma_P = math.pow(wepAvg, wepSlow)\r\nLagF_P = f_calc_laguerre(src_P, gamma_P)\r\nvar int lagSig_P = 0\r\nlagSig_P := LagF_P > (LagF_P[1]) ? 2 : LagF_P < (LagF_P[1]) ? -2 : lagSig_P[1]\r\nColor_lagSig_P = lagSig_P == 2 ? color.navy : lagSig_P == -2 ? color.orange : color.yellow\r\nplot(LagF_P, title='LagP', linewidth=3, color=Color_lagSig_P)\r\n\r\n// 7. LagF_V (Primary Visual Impulse Line)\r\nvAvg = math.avg(LagF_Y, rangeHighFinal, rangeLowFinal, LagF_P)\r\nsrc_V = vAvg\r\ngamma_V = math.pow(wepAvg, wepSlow)\r\nLagF_V = f_calc_laguerre(src_V, gamma_V)\r\nvar int lagSig_V = 0\r\nlagSig_V := LagF_V > (LagF_V[1]) ? 2 : LagF_V < (LagF_V[1]) ? -2 : lagSig_V[1]\r\nColor_lagSig_V = lagSig_V == 2 ? color.lime : lagSig_V == -2 ? color.gray : color.yellow\r\nplot(LagF_V, title='LagV', linewidth=5, color=Color_lagSig_V)\r\n\r\n// Fib Range Swap & Z Swap Logic (Secondary Fib Set)\r\nfibRangeSwap = rangeCloseHighFinal - rangeCloseLowFinal\r\nfibRangeLowSwap = rangeCloseLowFinal\r\n\r\nfib12Swap = (fibRangeSwap * 0.12) + fibRangeLowSwap\r\nfib23Swap = (fibRangeSwap * 0.23) + fibRangeLowSwap\r\nfib38Swap = (fibRangeSwap * 0.38) + fibRangeLowSwap\r\nfib50Swap = (fibRangeSwap * 0.5)  + fibRangeLowSwap\r\nfib61Swap = (fibRangeSwap * 0.62) + fibRangeLowSwap\r\nfib76Swap = (fibRangeSwap * 0.77) + fibRangeLowSwap\r\nfib88Swap = (fibRangeSwap * 0.88) + fibRangeLowSwap\r\n\r\nplot(fib12Swap, color=color.gray, linewidth=1, title=\"Swap Fib 12\")\r\nplot(fib23Swap, color=color.gray, linewidth=1, title=\"Swap Fib 23\")\r\nplot(fib50Swap, color=color.gray, linewidth=1, title=\"Swap Fib 50\")\r\nplot(fib88Swap, color=color.gray, linewidth=1, title=\"Swap Fib 88\")\r\n\r\nzSwap := LagF_Q > fib76Swap and lagSig_V == 2 or LagF_Q < fib23Swap and lagSig_V == -2 ? 1 : fib23Swap > LagF_P or fib76Swap < LagF_P ? 1 : 0 \r\n\r\n\r\n// --- Adaptive SuperTrend Oscillator (K-Means) ---\r\n// [NOTE] This section uses Machine Learning (K-Means clustering) to classify volatility\r\n// and adjust the SuperTrend factor dynamically.\r\natr_lenK = 14\r\nfactK = 3\r\ntraining_data_periodK = 70\r\nhighvolK = 0.75\r\nmidvolK = 0.5\r\nlowvolK = 0.25\r\nsmthlenK = 7\r\n\r\n// SuperTrend Calc Function\r\npine_supertrendK(float factorK, float atrK) =>\r\n    srcK = ohlc4\r\n    upperBandK = srcK + factorK * atrK\r\n    lowerBandK = srcK - factorK * atrK\r\n    prevLowerBandK = nz(lowerBandK[1])\r\n    prevUpperBandK = nz(upperBandK[1])\r\n\r\n    lowerBandK := lowerBandK > prevLowerBandK or close[1] < prevLowerBandK ? lowerBandK : prevLowerBandK\r\n    upperBandK := upperBandK < prevUpperBandK or close[1] > prevUpperBandK ? upperBandK : prevUpperBandK\r\n    int _directionK = na\r\n    float superTrendK = na\r\n    prevSuperTrendK = superTrendK[1]\r\n    \r\n    if na(atrK[1])\r\n        _directionK := 1\r\n    else if prevSuperTrendK == prevUpperBandK\r\n        _directionK := close > upperBandK ? -1 : 1\r\n    else\r\n        _directionK := close < lowerBandK ? 1 : -1\r\n        \r\n    superTrendK := _directionK == -1 ? lowerBandK : upperBandK\r\n    [superTrendK, _directionK, upperBandK, lowerBandK]\r\n\r\n// K-Means Logic\r\nvolatilityAtrK = ta.atr(atr_lenK)\r\nupperK = ta.highest(volatilityAtrK, training_data_periodK)\r\nlowerK = ta.lowest(volatilityAtrK, training_data_periodK)\r\nhigh_volatilityK = lowerK + (upperK - lowerK) * highvolK\r\nmedium_volatilityK = lowerK + (upperK - lowerK) * midvolK\r\nlow_volatilityK = lowerK + (upperK - lowerK) * lowvolK\r\n\r\nvdist_aK = math.abs(volatilityAtrK - high_volatilityK)\r\nvdist_bK = math.abs(volatilityAtrK - medium_volatilityK)\r\nvdist_cK = math.abs(volatilityAtrK - low_volatilityK)\r\ndistancesK = array.new_float()\r\ndistancesK.push(vdist_aK), distancesK.push(vdist_bK), distancesK.push(vdist_cK)\r\n\r\nclusterK = distancesK.indexof(distancesK.min())\r\nassigned_centroidK = clusterK == 0 ? high_volatilityK : clusterK == 1 ? medium_volatilityK : low_volatilityK\r\n\r\n[STK, dirK, oscupperK, osclowerK] = pine_supertrendK(factK, assigned_centroidK)\r\n\r\n// Raw Oscillator\r\nraw_oscK = close - STK\r\nosc_rangeK = ta.stdev(close, training_data_periodK) * 2\r\nscaled_oscK = raw_oscK * (osc_rangeK / ta.stdev(raw_oscK, training_data_periodK))\r\nadjusted_oscK = scaled_oscK + ohlc4\r\nsmthed_oscK = ta.ema(adjusted_oscK, smthlenK)\r\n\r\n// Laguerre on SuperTrend (LagF_K)\r\nsrc_K = adjusted_oscK\r\nbase_alphaK = input.float(title=\"Base Alpha K\", minval=0, maxval=1, step=0.1, defval=0.3)\r\nvolatility_periodK = 14\r\ngamma_K = 1 - base_alphaK\r\nLagF_K = f_calc_laguerre(src_K, gamma_K)\r\n\r\nvar int lagSig_K = 0\r\nlagSig_K := LagF_K > (LagF_K[1]) ? 2 : LagF_K < (LagF_K[1]) ? -2 : lagSig_K[1]\r\nColor_lagSig_K = lagSig_K == 2 ? color.aqua : lagSig_K == -2 ? color.red : color.yellow\r\n\r\nvar int colorLagsigKCombo = 0\r\ncolorLagsigKCombo := lagSig_K == 2 and LagF_K > ohlc4 ? 2 : lagSig_K == -2 and LagF_K < ohlc4 ? -2 : colorLagsigKCombo[1]\r\nplot(LagF_K, title=\"Laguerre Filter (Dynamic)\", linewidth=3, color=Color_lagSig_K)\r\n\r\n// All In One\r\nvar int aio_sig = 0\r\nallinOne = math.avg(LagF_1, LagF_K, LagF_P, LagF_Q, LagF_V, LagF_W, LagF_Y, LagF_Z)\r\naio_sig := allinOne > (allinOne[1]) and allinOne[1] > (allinOne[2]) ? 2 : allinOne < (allinOne[1]) and allinOne[1] < (allinOne[2]) ? -2 : aio_sig[1]\r\nColor_allinOne = aio_sig == 2 ? color.lime : aio_sig == -2 ? color.red : color.yellow\r\nplot(allinOne, title=\"All In One)\", linewidth=8, color=Color_allinOne)\r\n\r\n\r\n// ==========================================\r\n// â”€â”€â”€ BASELINE & SIGNAL GENERATION â”€â”€â”€\r\n// ==========================================\r\n// FIX: Pre-calculate crossover/crossunder to prevent short-circuiting consistency warnings\r\nxUpFib38 = ta.crossover(rangeHighFinal, fib38)\r\nxDnFib61 = ta.crossunder(rangeLowFinal, fib61)\r\n\r\n// Baseline Logic 1\r\nB1 = LagF_Q > LagF_W and expansionQuickDir == 1 and lagSig_Z == 2 and lagSig_Y == 2 and LagF_Y > fib23 and renkoDir == 2 or xUpFib38 and lagSig_Z == 2 and fibRange == fibRange[1] and renkoDir == 2 and LagF_Q > LagF_W ? 2 : LagF_Q < LagF_W and expansionQuickDir == -1 and lagSig_Z == -2 and lagSig_Y == -2 and LagF_Y < fib76 and renkoDir == -2 or xDnFib61 and lagSig_Z == -2 and fibRange == fibRange[1] and renkoDir == -2 and LagF_Q < LagF_W ? -2 : 0 \r\n\r\n// Baseline Logic 2 (Incorporates Range Swap)\r\nB2 = LagF_Q > LagF_W and expansionQuickDir == 1 and lagSig_Z == 2 and lagSig_Y == 2 and LagF_Y > fib23 and renkoDir == 2 or xUpFib38 and lagSig_Z == 2 and fibRange == fibRange[1] and renkoDir == 2 and LagF_Q > LagF_W or fib50Swap > fib50Swap[1] and LagF_P > fib76Swap ? 2 : LagF_Q < LagF_W and expansionQuickDir == -1 and lagSig_Z == -2 and lagSig_Y == -2 and LagF_Y < fib76 and renkoDir == -2 or xDnFib61 and lagSig_Z == -2 and fibRange == fibRange[1] and renkoDir == -2 and LagF_Q < LagF_W or fib50Swap < fib50Swap[1] and LagF_P < fib23Swap ? -2 : 0 \r\n\r\nsigSwap  = input.bool(true, \"Use Baseline Final Sig? (True = Yes/Baseline)\")\r\nbaseSig  = B2\r\naltSig   = B1\r\nfinalSig = sigSwap ? baseSig : altSig \r\n\r\n// Range Bound Brick Fills (Visuals)\r\nvar int getFillColorRB = 0\r\nuRB = plot(rangeCloseHighQuick, color=color.black, linewidth=1, title=\"RB Upper\")\r\nlRB = plot(rangeCloseLowQuick, color=color.black, linewidth=1, title=\"RB Lower\")\r\ngetFillColorRB := finalSig == 2 ? 1 : finalSig == -2 ? -1 : getFillColorRB[1]\r\nfillColorRB = getFillColorRB == 1 ? color.new(color.green, 50) : getFillColorRB == -1 ? color.new(color.fuchsia, 50) : color.new(color.orange, 50)\r\nfill(uRB, lRB, color=fillColorRB)\r\n\r\n// Weekend Checker\r\nWeekendInput = input.bool(false, title='Do NOT Trade Weekends (Default=Trade)')\r\nweekend      = dayofweek == 1 or dayofweek == 7 ? 1 : 0\r\nWeekendHalt  = WeekendInput ? weekend : 0\r\n\r\n\r\n// ==========================================\r\n// â”€â”€â”€ RISK MANAGEMENT & TRADE ENGINE â”€â”€â”€\r\n// ==========================================\r\nAlertOpen = WeekendHalt == 1 ? 0 : finalSig\r\n\r\nvar ClInputs = \"Closing Arguments\"\r\nCloseInput   = input.bool(false, title='Use Closing Argument (Default=Yes)', group = ClInputs)\r\ncloserLong   = 0\r\ncloserShort  = 0\r\nCloseLong    = CloseInput and closerLong == 1\r\nCloseShort   = CloseInput and closerShort == -1\r\n\r\n// Trade State Machine\r\nAO = AlertOpen == 2 and AlertOpen != AlertOpen[1] ? 2 : AlertOpen == -2 and AlertOpen != AlertOpen[1] ? -2 : 0\r\nvar float AT = na\r\nAT := (AO == 2) ? 2 : (AO == -2) ? -2 : AT[1]\r\nvar float AF = na\r\nAF := (AT == 2 and AT[1] != 2) ? 2 : (AT == -2 and AT[1] != -2) ? -2 : 0\r\n\r\nCS = CloseShort ? -1 : 0\r\nCL = CloseLong ? 1 : 0\r\nCSX = CS == -1 and CS != CS[1] ? -1 : CL == 1 and CL != CL[1] ? 1 : 0\r\n\r\nAgressiveRM = input.bool(true, \"Utilize Agresive RM - Reset RM Values as long as Algo determines entry conditions are valide (Default- Conservative)\")\r\nTradeEngineX = AlertOpen == 2 ? 1 : AlertOpen == -2 ? -1 : 0\r\nTradeEngineY = AF == 2 ? 1 : AF == -2 ? -1 : 0\r\nTradeEngineRisk = (not AgressiveRM) ? TradeEngineY : TradeEngineX\r\n\r\n// Risk Variables\r\nopen_  = open[1]\r\nclose_ = close[1] \r\nhigh_X = high[1] \r\nlow_X  = low[1] \r\n\r\nisLong  = true\r\nisShort = true\r\n\r\nBarTypeRM = input.bool(true, \"Use Bar Open/Close for RM Only (Defaul is High/Low)\")\r\nlow_  = (BarTypeRM) ? close_ : low_X\r\nhigh_ = (BarTypeRM) ? close_ : high_X\r\n\r\nRiskOpenR   = (not AgressiveRM) ? AF : AO\r\nRiskCloseLR = (not AgressiveRM) ? CSX : CL\r\nRiskCloseSR = (not AgressiveRM) ? CSX : CS\r\n\r\nopenLongR   = RiskOpenR == 2\r\ncloseLongR  = RiskCloseLR == 1\r\nopenShortR  = RiskOpenR == -2\r\ncloseShortR = RiskCloseSR == -1\r\n\r\nvar int buy = 0\r\nbuy := openLongR ? nz(buy[1]) > 0 ? buy[1] + 1 : 1 : 0\r\nvar int sell = 0\r\nsell := openShortR ? nz(sell[1]) > 0 ? sell[1] + 1 : 1 : 0\r\n\r\n// State tracking\r\nvar bool longCloseX = false\r\nvar bool shortCloseX = false\r\n\r\ntradeState = TradeEngineRisk\r\n\r\n// Conditions (Using non-zero check for v6 strict typing)\r\nlongCondition  = ta.change(tradeState) != 0 and tradeState == 1\r\nshortCondition = ta.change(tradeState) != 0 and tradeState == -1\r\nlongExitC      = CL == 1 or AlertOpen == -2 ? 1 : 0\r\nshortExitC     = CS == -1 or AlertOpen == 2 ? 1 : 0\r\nlongExit       = ta.change(longExitC) != 0 and longExitC == 1 and tradeState == 1\r\nshortExit      = ta.change(shortExitC) != 0 and shortExitC == 1 and tradeState == -1\r\n\r\nvar float last_open_longCondition = na\r\nvar float last_open_shortCondition = na\r\nlast_open_longCondition := longCondition ? close : nz(last_open_longCondition[1])\r\nlast_open_shortCondition := shortCondition ? close : nz(last_open_shortCondition[1])\r\n\r\nin_longCondition  = (AT == 2)\r\nin_shortCondition = (AT == -2)\r\n\r\n// --- TRAILING STOP ---\r\nisTS = input.bool(false, \"Trailing Stop\")\r\ntsActivation = input.float(18.0, \"Trailing Stop  Activation (%)\", minval=0, step=0.1)/100\r\nts = input.float(6.0, 'Trailing Stop (%)', minval=0, step=0.1) / 100\r\n\r\nLongTSActivate = low_ > last_open_longCondition + last_open_longCondition * tsActivation\r\nShortTSActivate = high_ < last_open_shortCondition - last_open_shortCondition * tsActivation\r\n\r\nvar float last_high = na\r\nvar float last_low = na\r\nvar float last_high_short = na\r\nvar float last_low_long = na\r\n\r\nlast_high := not in_longCondition ? na : in_longCondition and (na(last_high[1]) or high_ > nz(last_high[1])) ? high_ : nz(last_high[1])\r\nlast_high_short := not in_shortCondition ? na : in_shortCondition and (na(last_high[1]) or high_ > nz(last_high[1])) ? high_ : nz(last_high[1])\r\nlast_low := not in_shortCondition ? na : in_shortCondition and (na(last_low[1]) or low_ < nz(last_low[1])) ? low_ : nz(last_low[1])\r\nlast_low_long := not in_longCondition ? na : in_longCondition and (na(last_low[1]) or low_ < nz(last_low[1])) ? low_ : nz(last_low[1])\r\n\r\nlong_ts  = isTS and in_longCondition and not na(last_high) and LongTSActivate and low_ <= last_high - last_high * ts\r\nshort_ts = isTS and in_shortCondition and not na(last_low) and ShortTSActivate and high_ >= last_low + last_low * ts\r\n\r\n// --- TAKE PROFIT ---\r\nisTP = input.bool(false, \"Take Profit\")\r\ntp   = input.float(12.0, 'Take Profit (%)', minval=0, step=0.1) / 100\r\nttp  = input.float(2.5, 'Trailing Profit (%)', minval=0, step=0.1) / 100\r\nttp := ttp > tp ? tp : ttp\r\n\r\nlong_tp  = isTP and in_longCondition and last_high >= last_open_longCondition + last_open_longCondition * tp and low_ <= last_high - last_high * ttp\r\nshort_tp = isTP and in_shortCondition and last_low <= last_open_shortCondition - last_open_shortCondition * tp and high_ >= last_low + last_low * ttp\r\n\r\n// --- STAGED TAKE PROFIT ---\r\nisSTP     = input.bool(false, \"Use Staged Take Profit (Default = No\")\r\nStp1Per   = input.float(10.0, \"1st Level - Take Profit Activation Percent (%))\", minval=0, step=0.1)\r\nStp1Trail = input.float(5.0,  \"1st Level - Trailing Profit Percent (%)\", minval=0, step=0.1)\r\nStp1Qty   = input.float(10.0, \"1st Level - Close Order Quantity (%)\", minval=0, step=0.1)\r\nStp2Per   = input.float(20.0, \"2nd Level - Take Profit Activation Percent (%))\", minval=0, step=0.1)\r\nStp2Trail = input.float(10.0, \"2nd Level - Trailing Profit Percent (%)\", minval=0, step=0.1)\r\nStp2Qty   = input.float(10.0, \"2nd Level - Close Order Quantity (%)\", minval=0, step=0.1)\r\nStp3Per   = input.float(30.0, \"3rd Level - Take Profit Activation Percent (%)\", minval=0, step=0.1)\r\nStp3Trail = input.float(5.0,  \"3rd Level - Trailing Profit Percent (%)\", minval=0, step=0.1)\r\nStp3Qty   = input.float(70.0, \"3rd Level - Close Order Quantity (%)\", minval=0, step=0.1)\r\n\r\nLongTSActivate1 = last_high >= last_open_longCondition + last_open_longCondition * (Stp1Per/100)\r\nShortTSActivate1= last_low  <= last_open_shortCondition - last_open_shortCondition * (Stp1Per/100)\r\nLongTSActivate2 = last_high >= last_open_longCondition + last_open_longCondition * (Stp2Per/100)\r\nShortTSActivate2= last_low  <= last_open_shortCondition - last_open_shortCondition * (Stp2Per/100)\r\nLongTSActivate3 = last_high >= last_open_longCondition + last_open_longCondition * (Stp3Per/100)\r\nShortTSActivate3= last_low  <= last_open_shortCondition - last_open_shortCondition * (Stp3Per/100)\r\n\r\nlong_Stp1 = isSTP and in_longCondition and not na(last_high) and LongTSActivate1 and low_ <= last_high - last_high * (Stp1Trail/100)\r\nshort_Stp1 = isSTP and in_shortCondition and not na(last_low) and ShortTSActivate1 and high_ >= last_low + last_low * (Stp1Trail/100)\r\nlong_Stp2 = isSTP and in_longCondition and not na(last_high) and LongTSActivate2 and low_ <= last_high - last_high * (Stp2Trail/100)\r\nshort_Stp2 = isSTP and in_shortCondition and not na(last_low) and ShortTSActivate2 and high_ >= last_low + last_low * (Stp2Trail/100)\r\nlong_Stp3 = isSTP and in_longCondition and not na(last_high) and LongTSActivate3 and low_ <= last_high - last_high * (Stp3Trail/100)\r\nshort_Stp3 = isSTP and in_shortCondition and not na(last_low) and ShortTSActivate3 and high_ >= last_low + last_low * (Stp3Trail/100)\r\n\r\nlongSTP1 = long_Stp1 ? last_high - last_high * (Stp1Per/100) : Stp1Qty<=0 ? na : na\r\nlongSTP2 = long_Stp2 ? last_high - last_high * (Stp2Per/100) : Stp2Qty<=0 ? na : na\r\nlongSTP3 = long_Stp3 ? last_high - last_high * (Stp3Per/100) : Stp3Qty<=0 ? na : na\r\n\r\nshortSTP1 = short_Stp1 ? last_low + last_low * (Stp1Per/100) : Stp1Qty<=0 ? na : na\r\nshortSTP2 = short_Stp2 ? last_low + last_low * (Stp2Per/100) : Stp2Qty<=0 ? na : na\r\nshortSTP3 = short_Stp3 ? last_low + last_low * (Stp3Per/100) : Stp3Qty<=0 ? na : na\r\n\r\nStp1QtyF = Stp1Qty <= 0 ? na : Stp1Qty\r\nStp2QtyF = Stp2Qty <= 0 ? na : Stp2Qty\r\nStp3QtyF = Stp3Qty <= 0 ? na : Stp3Qty\r\n\r\nvar int Counter_LTP1 = 0\r\nCounter_LTP1 := long_Stp1 ? Counter_LTP1 + 1 : AF != 0 ? 0 : Counter_LTP1[1]\r\nvar int Counter_LTP2 = 0\r\nCounter_LTP2 := long_Stp2 ? Counter_LTP2 + 1 : AF != 0 ? 0 : Counter_LTP2[1]\r\nvar int Counter_LTP3 = 0\r\nCounter_LTP3 := long_Stp3 ? Counter_LTP3 + 1 : AF != 0 ? 0 : Counter_LTP3[1]\r\nvar int Counter_STP1 = 0\r\nCounter_STP1 := short_Stp1 ? Counter_STP1 + 1 : AF != 0 ? 0 : Counter_STP1[1]\r\nvar int Counter_STP2 = 0\r\nCounter_STP2 := short_Stp2 ? Counter_STP2 + 1 : AF != 0 ? 0 : Counter_STP2[1]\r\nvar int Counter_STP3 = 0\r\nCounter_STP3 := short_Stp3 ? Counter_STP3 + 1 : AF != 0 ? 0 : Counter_STP3[1]\r\n\r\nTakeProfit1Plot = long_Stp1 == true and long_Stp1 != long_Stp1[1] and Counter_LTP1 == 1 ? 1 : short_Stp1 == true and short_Stp1 != short_Stp1[1] and Counter_STP1 == 1 ? -1 : 0\r\nTakeProfit2Plot = long_Stp2 == true and long_Stp2 != long_Stp2[1] and Counter_LTP2 == 1 ? 2 : short_Stp2 == true and short_Stp2 != short_Stp2[1] and Counter_STP2 == 1 ? -2 : 0\r\nTakeProfit3Plot = long_Stp3 == true and long_Stp3 != long_Stp3[1] and Counter_LTP3 == 1 ? 3 : short_Stp3 == true and short_Stp3 != short_Stp3[1] and Counter_STP3 == 1 ? -3 : 0\r\n\r\n// --- STOP LOSS ---\r\nisSL = input.bool(false, \"Stop Loss\")\r\nsl   = input.float(18.0, 'Stop Loss (%)', minval=0, step=0.1) / 100\r\nlong_sl  = isSL and in_longCondition and (low_ <= last_open_longCondition - last_open_longCondition * sl)\r\nshort_sl = isSL and in_shortCondition and (high_ >= (last_open_shortCondition + last_open_shortCondition * sl))\r\n\r\nLongStop  = last_open_longCondition - last_open_longCondition * sl\r\nShortStop = last_open_shortCondition + last_open_shortCondition * sl\r\n\r\n// --- ADVANCED ADAPTIVE TRAILING STOP (AATS) ---\r\nlenEMA = 50  \r\noutEMA = ta.sma(close, lenEMA)\r\nCS_AATS = ta.ema(close, 7)\r\n\r\n// Hirashima Sugita R/S Code\r\nlengthHSRS = 1000  \r\nmaHSRS = ta.ema(close, lengthHSRS)\r\ndHSRS = close - maHSRS\r\nsHSRS = ta.linreg(dHSRS, lengthHSRS, 0)\r\nxHSRS = maHSRS + sHSRS\r\nd_HSRS = close - xHSRS\r\ns_HSRS = ta.linreg(d_HSRS, lengthHSRS, 0)\r\nbasisHSRS = maHSRS + sHSRS + ta.change(s_HSRS)\r\nupperHSRS = basisHSRS + ta.wma(math.abs(dHSRS), lengthHSRS)\r\nlowerHSRS = basisHSRS - ta.wma(math.abs(dHSRS), lengthHSRS)\r\nupper_HSRS = upperHSRS + ta.wma(math.abs(dHSRS), lengthHSRS)\r\nlower_HSRS = lowerHSRS - ta.wma(math.abs(dHSRS), lengthHSRS)\r\n\r\nHSRS_RangePenthouse = CS_AATS >= upper_HSRS ? 6 : 0\r\nHSRS_Range4thFloor  = CS_AATS < upper_HSRS and CS_AATS >= upperHSRS ? 5 : 0\r\nHSRS_Range3rdFloor  = CS_AATS < upperHSRS and CS_AATS >= basisHSRS ? 4 : 0\r\nHSRS_Range2ndFloor  = CS_AATS < basisHSRS and CS_AATS >= lowerHSRS ? 3 : 0\r\nHSRS_Range1stFloor  = CS_AATS < lowerHSRS and CS_AATS >= lower_HSRS ? 2 : 0\r\nHSRS_RangeDungeon   = CS_AATS < lower_HSRS ? 1 : 0\r\nHSRS_Location = HSRS_RangeDungeon + HSRS_Range1stFloor + HSRS_Range2ndFloor + HSRS_Range3rdFloor + HSRS_Range4thFloor + HSRS_RangePenthouse\r\n\r\nsrcMBB = close  \r\nlengthMBB = 34  \r\nmultMBB = 2.0  \r\nbasisMBB = ta.sma(srcMBB, lengthMBB)\r\ndevMBB = ta.stdev(srcMBB, lengthMBB)\r\ndev2MBB = multMBB * devMBB\r\ndev3MBB = multMBB * 2 * devMBB\r\nupper1MBB = basisMBB + devMBB\r\nlower1MBB = basisMBB - devMBB\r\n\r\nAATS_Engage3 = CS_AATS > outEMA and CS_AATS > basisHSRS and CS_AATS > upper1MBB ? 1 : CS_AATS < outEMA and CS_AATS < basisHSRS and CS_AATS < lower1MBB ? -1 : 0\r\nAATS_Factor = AATS_Engage3 == 1 and HSRS_Location == 6 ? 0.5 : AATS_Engage3 == 1 and HSRS_Location == 5 ? 2 : AATS_Engage3 == 1 and HSRS_Location == 4 ? 3 : AATS_Engage3 == -1 and HSRS_Location == 1 ? 0.5 : AATS_Engage3 == -1 and HSRS_Location == 2 ? 2 : AATS_Engage3 == -1 and HSRS_Location == 3 ? 3 : 4\r\n\r\nvar SLMod2 = \"Stop Loss Qualifiers\"\r\nUseAATS = input.bool(true, 'Use Advance Adaptive Trailing Stop (AATS) - (Default is On)', group = SLMod2)\r\nRestrictiveAATS = input.bool(true, 'Use Restrictive AATS - Good for majors (Default is On)', group = SLMod2)\r\nUseRSIS = input.bool(true, 'Use RSI Stop (RSIS) - (Default is On)', group = SLMod2)\r\n\r\natsFacInput = input.int(80, 'ATS Stop Factor (0+)', group = SLMod2)\r\nerATS = AATS_Factor / atsFacInput  \r\n\r\nvar float aATS = 0.0\r\nvar float bATS = 0.0\r\naATS := math.max(close, nz(aATS[1], close)) - math.abs(close - nz(aATS[1], close)) * erATS\r\nbATS := math.min(close, nz(bATS[1], close)) + math.abs(close - nz(bATS[1], close)) * erATS\r\n\r\nATSCross1 = ta.cross(aATS, close) ? 1 : 0\r\nATSCross2 = ta.cross(bATS, close) ? 0 : -1\r\n\r\nvar int osATS = 0\r\nosATS := ATSCross1 == 1 ? 1 : ATSCross2 == 0 ? 0 : osATS[1]\r\ntsATS = osATS * bATS + (1 - osATS) * aATS\r\n\r\nATSaX = ta.sma(close - (aATS - close), 7)\r\nATSbX = ta.sma(close + close - bATS, 7)\r\n\r\n// RSI Stop Logic\r\n// Manual function implementation for McGinley Dynamic\r\nf_McGinleyRSIS(_src, _len) =>\r\n    var float md = 0.0\r\n    md := na(_src[1]) ? _src : md[1] + (_src - md[1]) / (0.6 * _len * math.pow(_src / md[1], 4))\r\n    md\r\n\r\nrsi_maRSIS = f_McGinleyRSIS(close, 14)\r\nATRRSIS = ta.atr(27)\r\ntop_lineRSIS = rsi_maRSIS + ATRRSIS\r\nbottom_lineRSIS = rsi_maRSIS - ATRRSIS\r\nDirectionRSIS1 = ta.crossover(close, top_lineRSIS) ? 1 : 0\r\nDirectionRSIS2 = ta.crossunder(close, bottom_lineRSIS) ? -1 : 0\r\nvar int directionRSIS = 1\r\ndirectionRSIS := DirectionRSIS1 == 1 ? 1 : DirectionRSIS2 == -1 ? -1 : directionRSIS[1]\r\nRSIS_Signal = directionRSIS\r\n\r\nATS_CloseLongsX = UseRSIS and in_longCondition and AATS_Engage3 == 1  and RSIS_Signal == -1\r\nATS_CloseShortsX = UseRSIS and in_shortCondition and AATS_Engage3 == -1 and RSIS_Signal == 1\r\nATS_CloseLongsY = UseAATS and in_longCondition and AATS_Engage3 == 1   and low_ < bATS and low_ < ATSbX and low_ < ATSaX\r\nATS_CloseShortsY = UseAATS and in_shortCondition and AATS_Engage3 == -1 and high_ > aATS and high_ > ATSaX and high_ > ATSbX\r\n\r\nATS_CloseLongsAgg = ATS_CloseLongsX or ATS_CloseLongsY\r\nATS_CloseShortsAgg = ATS_CloseShortsX or ATS_CloseShortsY\r\nATS_CloseLongs = RestrictiveAATS ? ATS_CloseLongsY : ATS_CloseLongsAgg\r\nATS_CloseShorts = RestrictiveAATS ? ATS_CloseShortsY : ATS_CloseShortsAgg\r\n\r\n// Final Closes\r\nlongCloseX := isLong and (long_tp or long_sl or long_ts  or ATS_CloseLongs ) and not longCondition\r\nshortCloseX := isShort and (short_tp or short_sl or short_ts or ATS_CloseShorts ) and not shortCondition\r\n\r\n\r\n// ==========================================\r\n// â”€â”€â”€ FINAL SIGNALS & EXECUTION â”€â”€â”€\r\n// ==========================================\r\nRMPlot = (longCloseX or CSX == 1) ? 1 : (shortCloseX or CSX == -1) ? -1 : 0\r\nRMSig = RMPlot == 1 and RMPlot != RMPlot[1] ? 1 : RMPlot == -1 and RMPlot != RMPlot[1] ? -1 : 0\r\nClearRM = (AT == 2 and RMSig == 1) ? 3 : (AT == -2 and RMSig == -1) ? -3 : 0\r\nvar float ClearRMP = na\r\nClearRMP := (ClearRM == 3) ? 3 : (ClearRM == -3) ? -3 : (AO == 2 or AO == -2) ? 0 : ClearRMP[1]\r\nCloseEmAll = ClearRM == 3 and ClearRM[1] != 3 and ClearRMP[1] == 0 ? 1 :\r\n     ClearRM == -3 and ClearRM[1] != -3 and ClearRMP[1] == 0 ? -1 : 0\r\n\r\n// ---------------------------------------------------------\r\n//  Re-entry events (ReOrder) from the RM engine\r\n// ---------------------------------------------------------\r\nReOrder = (ClearRMP == 0 and ClearRMP[1] == 3 and ClearRMP != ClearRMP[1]) ? 4 :\r\n     (ClearRMP == 0 and ClearRMP[1] == -3 and ClearRMP != ClearRMP[1]) ? -4 : 0\r\n\r\n// Base entry signal from the RM engine (unfiltered)\r\nFin_raw = (AF == 2 or ReOrder == 4 and AT == 2) ? 2 :\r\n     (AF == -2 or ReOrder == -4 and AT == -2) ? -2 : 0\r\n\r\n// ---------------------------------------------------------\r\n//  EDGE GUARD: fire entry only when tradeState flips side\r\n//  Uses existing longCondition / shortCondition:\r\n//    longCondition  = ta.change(tradeState) != 0 and tradeState == 1\r\n//    shortCondition = ta.change(tradeState) != 0 and tradeState == -1\r\n// ---------------------------------------------------------\r\nFin_long  = Fin_raw == 2 and longCondition\r\nFin_short = Fin_raw == -2 and shortCondition\r\n\r\nFin = Fin_long ? 2 : Fin_short ? -2 : 0\r\n\r\n\r\n// ==========================================\r\n// â”€â”€â”€ STRATEGY EXECUTION â”€â”€â”€\r\n// ==========================================\r\nif testPeriod() and LongAndShort == 1\r\n    if Fin == 2\r\n        strategy.entry('Long', strategy.long, comment='Long')\r\n    strategy.exit('TP1 L', from_entry='Long', limit=longSTP1, qty_percent=Stp1QtyF, comment='L-TP1')\r\n    strategy.exit('TP2 L', from_entry='Long', limit=longSTP2, qty_percent=Stp2QtyF, comment='L-TP2')\r\n    strategy.exit('TP3 L', from_entry='Long', limit=longSTP3, qty_percent=Stp3QtyF, comment='L-TP3')\r\n    if CSX == 1 or longCloseX\r\n        strategy.close('Long')\r\n\r\n    if Fin == -2\r\n        strategy.entry('Short', strategy.short, comment='Short')\r\n    strategy.exit('TP1 S', from_entry='Short', limit=shortSTP1, qty_percent=Stp1QtyF, comment='S-TP1')\r\n    strategy.exit('TP2 S', from_entry='Short', limit=shortSTP2, qty_percent=Stp2QtyF, comment='S-TP2')\r\n    strategy.exit('TP3 S', from_entry='Short', limit=shortSTP3, qty_percent=Stp3QtyF, comment='S-TP3')\r\n    if CSX == -1 or shortCloseX\r\n        strategy.close('Short')\r\n     \r\nif testPeriod() and LongAndShort == 2\r\n    if Fin == 2\r\n        strategy.entry('Long', strategy.long, comment='Long')\r\n    strategy.exit('TP1 L', from_entry='Long', limit=longSTP1, qty_percent=Stp1QtyF, comment='L-TP1')\r\n    strategy.exit('TP2 L', from_entry='Long', limit=longSTP2, qty_percent=Stp2QtyF, comment='L-TP2')\r\n    strategy.exit('TP3 L', from_entry='Long', limit=longSTP3, qty_percent=Stp3QtyF, comment='L-TP3')\r\n    if CSX == 1 or longCloseX or Fin == -2\r\n        strategy.close('Long')\r\n\r\nif testPeriod() and LongAndShort == 3\r\n    if Fin == -2\r\n        strategy.entry('Short', strategy.short, comment='Short')\r\n    strategy.exit('TP1 S', from_entry='Short', limit=shortSTP1, qty_percent=Stp1QtyF, comment='S-TP1')\r\n    strategy.exit('TP2 S', from_entry='Short', limit=shortSTP2, qty_percent=Stp2QtyF, comment='S-TP2')\r\n    strategy.exit('TP3 S', from_entry='Short', limit=shortSTP3, qty_percent=Stp3QtyF, comment='S-TP3')\r\n    if CSX == -1 or shortCloseX or Fin == 2\r\n        strategy.close('Short')\r\n\r\n\r\n// ==========================================\r\n// â”€â”€â”€ ALERT VISUALIZERS (INDICATOR MODE) â”€â”€â”€\r\n// ==========================================\r\n\r\n//Buy and Sell Signals - Fin==2 Long, Fin==-2 Short\r\n//plot(Fin, title=\"Order Open\",linewidth=3,color=color.blue)\r\n\r\n//RM Close Alerts = Close Long = 1, Close Short =-1\r\n//plot(CloseEmAll, title=\"RM Close\", linewidth=3,color=color.yellow)\r\n\r\n//Take Profit Plot 1,2, 3 for Long TP1, 2, 3, and -1 -2 -3 for shorts\r\n//plot(TakeProfitStopsPlot, title=\"TP Close\", linewidth=3,color=color.orange)\r\n//plot(isSTP==true ? TakeProfit1Plot : na, title=\"TP-1 Close\", linewidth=3,color=color.lime)\r\n//plot(isSTP==true ? TakeProfit2Plot : na, title=\"TP-2 Close\", linewidth=3,color=color.olive)\r\n//plot(isSTP==true ? TakeProfit3Plot : na, title=\"TP-3 Close\", linewidth=3,color=color.green)\r\n\r\n// --- ALERT CONDITIONS (For Automation) ---\r\n//alertcondition(Fin == 2, title=\"Long Entry\", message=\"Long Entry Triggered\")\r\n//alertcondition(Fin == -2, title=\"Short Entry\", message=\"Short Entry Triggered\")\r\n//alertcondition(CloseEmAll == 1, title=\"Close Long\", message=\"Close Long Triggered\")\r\n//alertcondition(CloseEmAll == -1, title=\"Close Short\", message=\"Close Short Triggered\")\r\n//alertcondition(TakeProfit1Plot != 0, title=\"TP 1 Hit\", message=\"TP 1 Level Reached\")\r\n//alertcondition(TakeProfit2Plot != 0, title=\"TP 2 Hit\", message=\"TP 2 Level Reached\")\r\n//alertcondition(TakeProfit3Plot != 0, title=\"TP 3 Hit\", message=\"TP 3 Level Reached\")\r\n\r\n\r\n// ==========================================\r\n// â”€â”€â”€ RESET VARIABLES â”€â”€â”€\r\n// ==========================================\r\nif longCloseX or not in_longCondition\r\n    last_high := na\r\n    last_high_short := na\r\n\r\nif shortCloseX or not in_shortCondition\r\n    last_low := na\r\n    last_low_long := na\r\n\r\nif longCloseX or shortCloseX\r\n    tradeState := 0\r\n    in_longCondition := false\r\n    in_shortCondition := false\r\n\r\n///////////////////////////////////\r\n//======[ EOF - Done Baby ]======//\r\n///////////////////////////////////"
  },
  {
    "url": "YtSgAr1A-Super-AO-with-Risk-Management-Strategy-Template-11-29-25",
    "name": "Super-AO with Risk Management Strategy Template - 11-29-25",
    "description": "Super-AO Strategy with Advanced Risk Management Template\nSignal Lynx | Free Scripts supporting Automation for the Night-Shift Nation ðŸŒ™\n\n1. Overview\nWelcome to the Super-AO Strategy. This is more than just a buy/sell indicator; it is a complete, open-source Risk Management (RM) Template designed for the Pine Script community.\n\nAt its core, this script implements a robust swing-trading strategy combining the SuperTrend (for macro direction) and the Awesome Oscillator (for momentum). However, the real power lies under the hood: a custom-built Risk Management Engine that handles trade states, prevents repainting, and manages complex exit conditions like Staged Take Profits and Advanced Adaptive Trailing Stops (AATS).\n\nWe are releasing this code to help traders transition from simple indicators to professional-grade strategy structures.\n\n2. Quick Action Guide (TL;DR)\nBest Timeframe: 4 Hours (H4) and above. Designed for Swing Trading.\n\nBest Assets: \"Well-behaved\" assets with clear liquidity (Major Forex pairs, BTC, ETH, Indices).\n\nStrategy Type: Trend Following + Momentum Confirmation.\n\nKey Feature: The Risk Management Engine is modular. You can strip out the \"Super-AO\" logic and insert your own strategy logic into the template easily.\n\nRepainting: Strictly Non-Repainting. The engine calculates logic based on confirmed candle closes.\n\n3. Detailed Report: How It Works\nA. The Strategy Logic: Super-AO\nThe entry logic is based on the convergence of two classic indicators:\n\nSuperTrend: Determines the overall trend bias (Green/Red).\n\nAwesome Oscillator (AO): Measures market momentum.\n\nThe Signal:\n\nLONG (+2): SuperTrend is Green AND AO is above the Zero Line AND AO is Rising.\n\nSHORT (-2): SuperTrend is Red AND AO is below the Zero Line AND AO is Falling.\n\nBy requiring momentum to agree with the trend, this system filters out many false signals found in ranging markets.\n\nB. The Risk Management (RM) Engine\nThis script features a proprietary State Machine designed by Signal Lynx. Unlike standard strategies that simply fire orders, this engine separates the Signal from the Execution.\n\nLogic Injection: The engine listens for a specific integer signal: +2 (Buy) or -2 (Sell). This makes the code a Template. You can delete the Super-AO section, write your own logic, and simply pass a +2 or -2 to the RM_EngineInput variable. The engine handles the rest.\n\nTrade States: The engine tracks the state of the trade (Entry, In-Trade, Exiting) to prevent signal spamming.\n\nAggressive vs. Conservative:\n\nConservative Mode: Waits for a full trend reversal before taking a new trade.\n\nAggressive Mode: Allows for re-entries if the trend is strong and valid conditions present themselves again (Pyramiding Type 1).\n\nC. Advanced Exit Protocols\nThe strategy does not rely on a single exit point. It employs a \"Layered Defense\" approach:\n\nHard Stop Loss: A fixed percentage safety net.\n\nStaged Take Profits (Scaling Out): The script allows you to set 3 distinct Take Profit levels. For example, you can close 10% of your position at TP1, 10% at TP2, and let the remaining 80% ride the trend.\n\nTrailing Stop: A standard percentage-based trailer.\n\nAdvanced Adaptive Trailing Stop (AATS): This is a highly sophisticated volatility stop. It calculates market structure using Hirashima Sugita (HSRS) levels and Bollinger Bands to determine the \"floor\" and \"ceiling\" of price action.\n\nIf volatility is high: The stop loosens to prevent wicking out.\n\nIf volatility is low: The stop tightens to protect profit.\n\nD. Repainting Protection\nMany Pine Script strategies look great in backtesting but fail in live trading because they rely on \"real-time\" price data that disappears when the candle closes.\n\nThis Risk Management engine explicitly pulls data from the previous candle close (close , high , low ) for its calculations. This ensures that the backtest results you see match the reality of live execution.\n\n4. For Developers & Modders\nWe encourage you to tear this code apart!\n\nLook for the section titled // Super-AO Strategy Logic.\n\nReplace that block with your own RSI, MACD, or Price Action logic.\n\nEnsure your logic outputs a 2 for Buy and -2 for Sell.\n\nConnect it to RM_EngineInput.\n\nYou now have a fully functioning Risk Management system for your custom strategy.\n\n5. About Signal Lynx\nAutomation for the Night-Shift Nation ðŸŒ™\n\nThis code has been in action since 2022 and is a known performer in PineScript v5. We provide this open source to help the community build better, safer automated systems.\n\nIf you are looking to automate your strategies, please take a look at Signal Lynx in your search.\n\nLicense: Mozilla Public License 2.0 (Open Source). If you make beneficial modifications, please release them back to the community!",
    "image_url": "YtSgAr1A",
    "author": "SignalLynx",
    "likes": 11,
    "type": "strategy",
    "created": "2025-11-30",
    "updated": "2025-11-30",
    "source": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// @SignalLynx\r\n\r\n\r\n//@version=5\r\n// Super-AO with Risk Management Strategy Template - By SignalLynx 11-29-25 Release\r\n\r\n\r\n// ============================================================================================================\r\n//     SIGNAL LYNX - SUPER-AO STRATEGY & RISK MANAGEMENT TEMPLATE\r\n// ============================================================================================================\r\n//\r\n//     INTRODUCTION:\r\n//     This script implements \"Super-AO,\" a robust trend-following strategy that combines the \r\n//     SuperTrend indicator with the Awesome Oscillator (AO). \r\n//    \r\n//     HOW IT WORKS:\r\n//     1. SuperTrend determines the macro direction (Trend).\r\n//     2. Awesome Oscillator (AO) determines the momentum.\r\n//     3. A signal is only generated when the SuperTrend is Green AND the AO is positive/rising (Buy),\r\n//        or SuperTrend is Red AND AO is negative/falling (Sell).\r\n//    \r\n//     USAGE:\r\n//     - Designed to capture large moves in High Time Frame (HTF) Swing Trades.\r\n//     - Excels on timeframes above 4 Hours.\r\n//     - Works best on \"well-behaved\" pairs with clear liquidity (Major Forex, BTC, ETH, etc.).\r\n//\r\n//     THE RISK MANAGEMENT (RM) ENGINE:\r\n//     This code is more than just a strategy; it is a Risk Management Template. \r\n//     It features an advanced engine that separates the \"Signal\" from the \"Execution.\"\r\n//    \r\n//     - Logic Injection: The engine expects a simple integer signal: +2 (Buy) or -2 (Sell).\r\n//     - Repainting Protection: It is designed to use actual candle closes for exits to minimize \r\n//       repainting issues common in backtesting.\r\n//     - Advanced Exits: Includes Staged Take Profits (Scale out), Trailing Stops, and an \r\n//       Advanced Adaptive Trailing Stop (AATS) based on volatility.\r\n//\r\n//     --------------------------------------------------------------------------------------------------------\r\n//     Signal Lynx\r\n//     Free Scripts supporting Automation for the Night-Shift Nation ðŸŒ™\r\n//    \r\n//     We are providing this code open source to support the night shift nation. This code has been \r\n//     in action since 2022 and is a known performer in PineScript v5. \r\n//    \r\n//     If you are looking to automate your strategies, please take a look at SignalLynx in your search:\r\n//     (www.signallynx.com)\r\n//\r\n//     If you make modifications to this code which are beneficial, please release them for the community.\r\n//     --------------------------------------------------------------------------------------------------------\r\n\r\n\r\n// ==============================================================================\r\n//  !!! MODE SELECTION - READ CAREFULLY !!!\r\n// ==============================================================================\r\n//  Pine Script can run as a STRATEGY (Backtesting) or an INDICATOR (Alerts).\r\n//  You must uncomment only ONE of the following two lines.\r\n//\r\n//  OPTION 1: STRATEGY MODE (Default) \r\n//  Use this to see Buy/Sell tags on the chart and run the Strategy Tester.\r\n//  [INSTRUCTIONS]: Keep the line starting with 'strategy' UNCOMMENTED.\r\n//\r\nstrategy('Super-AO with Risk Management Strategy Template - 11-29-25', shorttitle='SAO - RM Strat Template - 11-29-25', overlay=true, initial_capital=1000, commission_type=strategy.commission.percent, commission_value=0.26, currency=currency.USD, default_qty_type=strategy.percent_of_equity, default_qty_value=100, pyramiding=0, slippage=5)\r\n//\r\n//  OPTION 2: INDICATOR/ALERT MODE\r\n//  Use this to set up Alerts for automation (Signal Lynx, 3Commas, etc).\r\n//  [INSTRUCTIONS]: Add \"//\" before the 'strategy' line above, and remove \"//\" from the 'indicator' line below.\r\n//\r\n//indicator('Super-AO with Risk Management Alerts Template - 11-29-25', shorttitle='SAO - RM Alerts Template - 11-29-25', overlay=true)\r\n// ==============================================================================\r\n\r\n\r\n////////////////////////////////////////////////////////////////\r\n//* Backtest Setting                                         *//\r\n////////////////////////////////////////////////////////////////\r\n\r\n// [NOTE] This section restricts the strategy execution to a specific date range.\r\n// This is crucial for verifying how a strategy performed during specific market cycles.\r\nvar BackTestMod =\"Back Test Inputs\"\r\ntestStartYear = input(2019, '- Start year', group=BackTestMod)\r\ntestStartMonth = input(01, '- Start month', group=BackTestMod)\r\ntestStartDay = input(01, '- Start day', group=BackTestMod)\r\ntestPeriodStart =  timestamp(testStartYear, testStartMonth, testStartDay, 0, 0) \r\n\r\ntestStopYear = input(99999, '- Stop year', group=BackTestMod)\r\ntestStopMonth = input(12, '- Stop month', group=BackTestMod)\r\ntestStopDay = input(30, '-Stop day', group=BackTestMod)\r\ntestPeriodStop = timestamp(testStopYear, testStopMonth, testStopDay, 0, 0)\r\n\r\n// Function to check if current bar is within the test period\r\ntestPeriod() =>\r\n    time >= testPeriodStart and time <= testPeriodStop ? true : false\r\n\r\n\r\n/////////////////////////////////////\r\n// Longs and shorts Direction Control\r\n\r\nvar LnS = \"Strategy Options - Longs and Shorts\"\r\nLnS_Longs = input(true, title='Longs', group=LnS)\r\nLnS_Shorts = input(false, title='Shorts', group=LnS)\r\n\r\n// Logic to determine direction: 1=Both, 2=Long Only, 3=Short Only\r\nLongAndShort =LnS_Longs==true and LnS_Shorts==true ? 1 : LnS_Longs==true and LnS_Shorts==false ? 2 : LnS_Longs==false and LnS_Shorts==true ? 3 : 1\r\n\r\n\r\n////////////////////////////////////////////////////////////////\r\n//* Super-AO Strategy Logic                                  *//\r\n////////////////////////////////////////////////////////////////\r\n// [NOTE] This is the \"Brain\" of the strategy. If you want to use this template for a different strategy,\r\n// you would replace the code in this section.\r\n\r\n// --- Awesome Oscillator (AO) ---\r\nAOfastLength = input(title='AO Fast Length', defval=14)\r\nAOslowLength = input(title='AO Slow Length', defval=420) // [NOTE] Using a very slow length to smooth out noise for swing trading\r\nao = ta.sma(close, AOfastLength) - ta.sma(close, AOslowLength)\r\nAOSmoothInput = input(title='AO Smoother length', defval=21)\r\naoSmooth = ta.ema(ao, AOSmoothInput)\r\nAORising = ta.rising(ao, AOSmoothInput) ? 1 : -1\r\n\r\n// --- SuperTrend (ST) ---\r\nSTPeriods = input(title='ST ATR Period', defval=14)\r\nSTsrc = close\r\nSTMultiplier = input.float(title='ST ATR Multiplier', step=0.1, defval=7.0) // [NOTE] Multiplier of 7 is looser than standard\r\n\r\nSTatr = ta.atr(STPeriods)\r\nSTup = STsrc - STMultiplier * STatr\r\nSTup1 = nz(STup[1], STup)\r\nSTup := close[1] > STup1 ? math.max(STup, STup1) : STup\r\nSTdn = STsrc + STMultiplier * STatr\r\nSTdn1 = nz(STdn[1], STdn)\r\nSTdn := close[1] < STdn1 ? math.min(STdn, STdn1) : STdn\r\n\r\n// SuperTrend Trend Calculation\r\nSTtrend = 1\r\nSTtrend := nz(STtrend[1], STtrend)\r\nSTtrend := STtrend == -1 and close > STdn1 ? 1 : STtrend == 1 and close < STup1 ? -1 : STtrend\r\nSTbuySignal = STtrend == 1 and STtrend[1] == -1\r\nSTsellSignal = STtrend == -1 and STtrend[1] == 1\r\n\r\n// Smoothed SuperTrend for advanced exit conditions\r\nSTdnsmooth=ta.sma(STdn, 14)\r\nSTupsmooth=ta.sma(STup, 14)\r\nSTUpRise= ta.rising(STupsmooth, 14) and STtrend==1 ? 1 : 0\r\nSTDnFall = ta.falling(STdnsmooth, 14) and STtrend ==-1 ? -1 :0 \r\n\r\n// --- Super-AO Final Signal Generation ---\r\n// [NOTE] The magic number 2 represents a BUY, -2 represents a SELL. 0 is Neutral.\r\nSAO  = ao>= 0 and AORising==1 and STtrend==1 ? 2 : ao<=0 and AORising==-1 and STtrend==-1 ? -2 : 0\r\n\r\n\r\n// --- Weekend Filtering ---\r\n// Prevents entries during low liquidity weekend hours if selected\r\nWeekendInput = input(false, title='Do NOT Trade Weekends (Default=Trade)')\r\nweekend = dayofweek==1 or dayofweek==7 ? 1 : 0\r\nWeekendHalt = WeekendInput==true ? weekend : 0\r\n\r\n\r\n////////////////////////////////////////////////////////////////\r\n//* Final Buys for Risk Management Module                    *//\r\n////////////////////////////////////////////////////////////////\r\n\r\n// [NOTE] This connects the Strategy Logic (SAO) to the Risk Manager.\r\nRM_EngineInput = SAO\r\n\r\n// If weekend halt is on, signals are suppressed (0), otherwise they pass through\r\nAlertOpen= WeekendHalt == 1 ? 0 : RM_EngineInput\r\n\r\n// Exit triggers based on SuperTrend smoothing\r\nCloseLong = STDnFall ==-1 ? true : false\r\nCloseShort = STUpRise==1 ? true : false\r\n\r\n////////////////////////////////////////////////////////////////\r\n//* Trade State Engine (Risk Management Translation)         *//\r\n////////////////////////////////////////////////////////////////\r\n\r\n// [NOTE] This state machine prevents signal spamming. It ensures we only \r\n// react to a *change* in signal or a confirmed trend state.\r\n\r\n// AO: Detects the initial signal change (2 or -2)\r\nAO = AlertOpen == 2 and AlertOpen != AlertOpen[1] ? 2 : \r\n   AlertOpen == -2 and AlertOpen != AlertOpen[1] ? -2 : 0\r\n   \r\n// AT (Actual Trend): Persists the trend state\r\nAT=float(na)\r\nAT:= (AO==2)? 2: (AO==-2)? -2: AT[1]\r\n\r\n// AF (Actual Final): Confirms entry only if the trend direction has actually flipped\r\nAF=float(na) \r\nAF:=(AT==2 and AT[1]!=2)?2: (AT==-2 and AT [1]!=-2) ? -2:0\r\n\r\n// CL/CS: Logic for closing positions\r\nCS = CloseShort == true ? -1 : 0\r\nCL = CloseLong == true ? 1 : 0\r\nCSX = CS == -1 and CS != CS[1] ? -1 : CL == 1 and CL != CL[1] ? 1 : 0\r\n\r\n// [NOTE] Aggressive RM allows re-entries in the same trend direction (Pyramiding Type I).\r\nAgressiveRM = input(true, \"Utilize Agresive RM - Reset RM Values as long as Algo determines entry conditions are valide (Default- Conservative)\")\r\n\r\nTradeEngineX = AlertOpen == 2 ? 1 : AlertOpen == -2 ? -1 : 0\r\nTradeEngineY= AF==2?1:AF==-2?-1:0\r\n\r\nTradeEngineRisk = (AgressiveRM==false)? TradeEngineY: TradeEngineX\r\n\r\n\r\n////////////////////////////////////////////////////////////////\r\n//* Risk Management Code                                     *//\r\n////////////////////////////////////////////////////////////////\r\n// [NOTE] CORE RISK MANAGEMENT BLOCK - DO NOT MODIFY\r\n\r\nopen_ = open[1] \r\nclose_ = close[1] \r\nhigh_X = high[1] \r\nlow_X = low[1] \r\n\r\nisLong = true\r\nisShort = true\r\n\r\n// === RISK MANAGEMENT VALUE PREP ===\r\n// Determine what Bar values we should use for Risk managment (High/Low vs Close)\r\nBarTypeRM = input(true, \"Use Bar Open/Close for RM Only (Defaul is High/Low)\")\r\nlow_=(BarTypeRM==true) ? close_ :low_X\r\nhigh_=(BarTypeRM==true) ? close_ : high_X\r\n\r\n//////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n// Generate final Risk Management Signals\r\nRiskOpenR = (AgressiveRM==false) ? AF: AO\r\nRiskCloseLR = (AgressiveRM==false) ? CSX: CL\r\nRiskCloseSR = (AgressiveRM==false) ? CSX: CS\r\n\r\nopenLongR = RiskOpenR == 2 ? true : false\r\ncloseLongR = RiskCloseLR == 1 ? true : false\r\n\r\nopenShortR = RiskOpenR == -2 ? true : false\r\ncloseShortR = RiskCloseSR == -1 ? true : false \r\n\r\nbuy = 0\r\nbuy := openLongR ? nz(buy[1]) > 0 ? buy[1] + 1 : 1 : 0\r\nsell = 0\r\nsell := openShortR ? nz(sell[1]) > 0 ? sell[1] + 1 : 1 : 0\r\n\r\n\r\n//////////////////////////\r\n//* Trade State Engine *//\r\n//////////////////////////\r\n\r\n// [NOTE] Tracks if a position is currently forcibly closed\r\nlongCloseX = false\r\nlongCloseX := nz(longCloseX[1], false)\r\nshortCloseX = false\r\nshortCloseX := nz(shortCloseX[1], false)\r\n\r\ntradeState = TradeEngineRisk\r\n\r\n///////////////////////////////////////////////////////\r\n// Handle Entry Conditions, when state changes direction.\r\n\r\nlongCondition = false\r\nshortCondition = false\r\nlongCondition := ta.change(tradeState) and tradeState == 1\r\nshortCondition := ta.change(tradeState) and tradeState == -1\r\n\r\n// Exit on Sell signal reversal\r\nlongExitC = CL == 1 or AlertOpen == -2 ? 1 : 0\r\nshortExitC = CS == -1 or AlertOpen == 2 ? 1 : 0\r\n\r\n// Exit condition for no Stop Loss defined\r\nlongExit = ta.change(longExitC) and longExitC == 1 and tradeState == 1\r\nshortExit = ta.change(shortExitC) and shortExitC == 1 and tradeState == -1\r\n\r\n/////////////////////////////////////\r\n//======[ Deal Entry Prices ]======//\r\n/////////////////////////////////////\r\n\r\n// Store the price at the moment the entry condition was met\r\nlast_open_longCondition = float(na)\r\nlast_open_shortCondition = float(na)\r\nlast_open_longCondition := longCondition ? close : nz(last_open_longCondition[1])\r\nlast_open_shortCondition := shortCondition ? close : nz(last_open_shortCondition[1])\r\n\r\n//////////////////////////////////\r\n//======[ Position State ]======//\r\n//////////////////////////////////\r\n\r\n// Boolean flags for current direction\r\nin_longCondition=(AT==2)? true: false\r\nin_shortCondition = (AT==-2)? true:false\r\n\r\n/////////////////////////////////\r\n//======[ Trailing Stop ]======//\r\n/////////////////////////////////\r\n\r\n// [NOTE] Basic Percentage Trailing Stop Logic.\r\nisTS = input(false, \"Trailing Stop\")\r\ntsActivation = input.float(18.0, \"Trailing Stop  Activation (%)\", minval=0, step=0.1)/100\r\nts = input.float(6.0, 'Trailing Stop (%)', minval=0, step=0.1) / 100\r\n\r\nLongTSActivate = low_ > last_open_longCondition + last_open_longCondition * tsActivation ? true : false\r\nShortTSActivate=  high_ < last_open_shortCondition - last_open_shortCondition * tsActivation ? true : false\r\n\r\n// Tracking Highest High (for longs) and Lowest Low (for shorts) since entry\r\nlast_high = float(na)\r\nlast_low = float(na)\r\nlast_high_short = float(na)\r\nlast_low_long = float(na)\r\n\r\nlast_high := not in_longCondition ? na : \r\n   in_longCondition and (na(last_high[1]) or high_ > nz(last_high[1])) ? high_ : \r\n   nz(last_high[1])\r\nlast_high_short := not in_shortCondition ? na : \r\n   in_shortCondition and (na(last_high[1]) or high_ > nz(last_high[1])) ? high_ : \r\n   nz(last_high[1])\r\nlast_low := not in_shortCondition ? na : \r\n   in_shortCondition and (na(last_low[1]) or low_ < nz(last_low[1])) ? low_ : \r\n   nz(last_low[1])\r\nlast_low_long := not in_longCondition ? na : \r\n   in_longCondition and (na(last_low[1]) or low_ < nz(last_low[1])) ? low_ : \r\n   nz(last_low[1])\r\n\r\nlong_ts = isTS and in_longCondition and not na(last_high) and (LongTSActivate==true)  and \r\n   low_ <= last_high - last_high * ts\r\nshort_ts = isTS and in_shortCondition and not na(last_low) and (ShortTSActivate==true) and \r\n   high_ >= last_low + last_low * ts\r\n\r\n\r\n///////////////////////////////\r\n//======[ Take Profit ]======//\r\n///////////////////////////////\r\n\r\n// [NOTE] Standard Take Profit with a \"Trailing Profit\" feature. \r\nisTP = input(false, \"Take Profit\")\r\ntp = input.float(12.0, 'Take Profit (%)', minval=0, step=0.1) / 100\r\nttp = input.float(2.5, 'Trailing Profit (%)', minval=0, step=0.1) / 100\r\nttp := ttp > tp ? tp : ttp\r\n\r\nlong_tp = isTP and in_longCondition and \r\n   last_high >= last_open_longCondition + last_open_longCondition * tp and \r\n   low_ <= last_high - last_high * ttp\r\nshort_tp = isTP and in_shortCondition and \r\n   last_low <= last_open_shortCondition - last_open_shortCondition * tp and \r\n   high_ >= last_low + last_low * ttp\r\n\r\n\r\n/////////////////////////////////////\r\n//======[ Staged Take Profit]======//\r\n/////////////////////////////////////\r\n\r\n// [NOTE] Staged Take Profits allow scaling out of a position.\r\nisSTP = input(false, \"Use Staged Take Profit (Default = No\")\r\nStp1Per = input.float(10.0, \"1st Level - Take Profit Activation Percent (%))\", minval=0, step=0.1) // 100\r\nStp1Trail = input.float(5.0, \"1st Level - Trailing Profit Percent (%)\", minval=0, step=0.1) // 100\r\nStp1Qty = input.float(10.0, \"1st Level - Close Order Quantity (%)\", minval=0, step=0.1) // 100\r\nStp2Per = input.float(20.0, \"2nd Level - Take Profit Activation Percent (%))\", minval=0, step=0.1) // 100\r\nStp2Trail = input.float(10.0, \"2nd Level - Trailing Profit Percent (%)\", minval=0, step=0.1) // 100\r\nStp2Qty = input.float(10.0, \"2nd Level - Close Order Quantity (%)\", minval=0, step=0.1) // 100\r\nStp3Per = input.float(30.0, \"3rd Level - Take Profit Activation Percent (%)\", minval=0, step=0.1) // 100\r\nStp3Trail = input.float(5.0, \"3rd Level - Trailing Profit Percent (%)\", minval=0, step=0.1) // 100\r\nStp3Qty = input.float(70.0, \"3rd Level - Close Order Quantity (%)\", minval=0, step=0.1) // 100\r\n\r\n// Calculate activations for staged TPs\r\nLongTSActivate1 = last_high >= last_open_longCondition + last_open_longCondition * (Stp1Per/100) ? true : false\r\nShortTSActivate1= last_low  <= last_open_shortCondition - last_open_shortCondition * (Stp1Per/100) ? true : false\r\nLongTSActivate2 = last_high >= last_open_longCondition + last_open_longCondition * (Stp2Per/100) ? true : false\r\nShortTSActivate2= last_low <=  last_open_shortCondition - last_open_shortCondition * (Stp2Per/100) ? true : false\r\nLongTSActivate3 = last_high >= last_open_longCondition + last_open_longCondition * (Stp3Per/100) ? true : false\r\nShortTSActivate3= last_low <=  last_open_shortCondition - last_open_shortCondition * (Stp3Per/100) ? true : false\r\n\r\n// Calculate trigger hits for staged TPs\r\nlong_Stp1 = isSTP and in_longCondition and not na(last_high) and (LongTSActivate1==true) and\r\n   low_ <= last_high - last_high *  (Stp1Trail/100)\r\nshort_Stp1 = isSTP and in_shortCondition and not na(last_low) and (ShortTSActivate1==true) and \r\n   high_ >= last_low + last_low * (Stp1Trail/100)\r\nlong_Stp2 = isSTP and in_longCondition and not na(last_high) and (LongTSActivate2==true) and\r\n   low_ <= last_high - last_high *  (Stp2Trail/100)\r\nshort_Stp2 = isSTP and in_shortCondition and not na(last_low) and (ShortTSActivate2==true) and  \r\n   high_ >= last_low + last_low * (Stp2Trail/100)\r\nlong_Stp3 = isSTP and in_longCondition and not na(last_high) and (LongTSActivate3==true) and\r\n   low_ <= last_high - last_high *  (Stp3Trail/100)\r\nshort_Stp3 = isSTP and in_shortCondition and not na(last_low) and (ShortTSActivate3==true) and  \r\n   high_ >= last_low + last_low * (Stp3Trail/100)\r\n   \r\n// Define Limit Prices for strategy exits   \r\nlongSTP1=long_Stp1==true ? last_high - last_high *  (Stp1Per/100) : Stp1Qty<=0 ? na : na\r\nlongSTP2=long_Stp2==true ? last_high - last_high *  (Stp2Per/100) : Stp2Qty<=0 ? na : na\r\nlongSTP3=long_Stp3==true ? last_high - last_high *  (Stp3Per/100) : Stp3Qty<=0 ? na : na\r\n\r\nshortSTP1=short_Stp1==true ? last_low + last_low * (Stp1Per/100) : Stp1Qty<=0 ? na : na\r\nshortSTP2=short_Stp2==true ? last_low + last_low * (Stp2Per/100) : Stp2Qty<=0 ? na : na\r\nshortSTP3=short_Stp3==true ? last_low + last_low * (Stp3Per/100) : Stp3Qty<=0 ? na : na\r\n\r\nStp1QtyF=Stp1Qty<=0 ? na : Stp1Qty\r\nStp2QtyF=Stp2Qty<=0 ? na : Stp2Qty\r\nStp3QtyF=Stp3Qty<=0 ? na : Stp3Qty\r\n\r\n// Counters to ensure TP alerts fire only once per level per trade\r\nvar Counter_LTP1 = 0\r\nCounter_LTP1 := long_Stp1 != 0 ? Counter_LTP1 + 1 : AF != 0 ? 0 : Counter_LTP1[1]\r\nvar Counter_LTP2 = 0\r\nCounter_LTP2 := long_Stp2 != 0 ? Counter_LTP2 + 1 : AF != 0 ? 0 : Counter_LTP2[1]\r\nvar Counter_LTP3 = 0\r\nCounter_LTP3 := long_Stp3 != 0 ? Counter_LTP3 + 1 : AF != 0 ? 0 : Counter_LTP3[1]\r\nvar Counter_STP1 = 0\r\nCounter_STP1 := short_Stp1 != 0 ? Counter_STP1 + 1 : AF != 0 ? 0 : Counter_STP1[1]\r\nvar Counter_STP2 = 0\r\nCounter_STP2 := short_Stp2 != 0 ? Counter_STP2 + 1 : AF != 0 ? 0 : Counter_STP2[1]\r\nvar Counter_STP3 = 0\r\nCounter_STP3 := short_Stp3 != 0 ? Counter_STP3 + 1 : AF != 0 ? 0 : Counter_STP3[1]\r\n\r\nTakeProfit1Plot = long_Stp1 == true and long_Stp1 != long_Stp1[1] and Counter_LTP1 == 1 ? 1 : short_Stp1 == true and short_Stp1 != short_Stp1[1] and Counter_STP1 == 1 ? -1 : 0\r\nTakeProfit2Plot = long_Stp2 == true and long_Stp2 != long_Stp2[1] and Counter_LTP2 == 1 ? 2 : short_Stp2 == true and short_Stp2 != short_Stp2[1] and Counter_STP2 == 1 ? -2 : 0\r\nTakeProfit3Plot = long_Stp3 == true and long_Stp3 != long_Stp3[1] and Counter_LTP3 == 1 ? 3 : short_Stp3 == true and short_Stp3 != short_Stp3[1] and Counter_STP3 == 1 ? -3 : 0\r\n\r\n\r\n/////////////////////////////\r\n//======[ Stop Loss ]======//\r\n/////////////////////////////\r\n\r\n// [NOTE] Hard Stop Loss Logic\r\nisSL = input(false, \"Stop Loss\")\r\nsl = input.float(18.0, 'Stop Loss (%)', minval=0, step=0.1) / 100\r\nlong_sl = isSL and in_longCondition and ( low_ <= last_open_longCondition - last_open_longCondition * sl)\r\nshort_sl = isSL and in_shortCondition and  (high_ >= (last_open_shortCondition + last_open_shortCondition * sl))\r\n   \r\nLongStop = last_open_longCondition - last_open_longCondition * sl\r\nShortStop=  last_open_shortCondition + last_open_shortCondition * sl\r\n\r\n\r\n/////////////////////////////////////////////////\r\n//======[Advance Adaptive Trailing Stop ]======//\r\n////////////////////////////////////////////////\r\n\r\n// [NOTE] AATS Logic: This is a complex module that calculates market volatility and location relative to\r\n// Hirashima Sugita (HSRS) Support/Resistance levels and Bollinger Bands to determine how \"tight\" the stop should be.\r\n\r\nlenEMA = 50  \r\nsrcEMA = close  \r\noutEMA = ta.sma(srcEMA, lenEMA)\r\nCS_AATS = ta.ema(close, 7)\r\n\r\n// Hirashima Sugita R/S Code (HSRS)\r\nlengthHSRS = 1000  \r\nmaHSRS = ta.ema(close, lengthHSRS)\r\ndHSRS = close - maHSRS\r\n\r\nsHSRS = ta.linreg(dHSRS, lengthHSRS, 0)\r\nxHSRS = maHSRS + sHSRS\r\n\r\nd_HSRS = close - xHSRS\r\ns_HSRS = ta.linreg(d_HSRS, lengthHSRS, 0)\r\nbasisHSRS = maHSRS + sHSRS + ta.change(s_HSRS)\r\n\r\n// Calculate HSRS Bands\r\nupperHSRS = basisHSRS + ta.wma(math.abs(dHSRS), lengthHSRS)\r\nlowerHSRS = basisHSRS - ta.wma(math.abs(dHSRS), lengthHSRS)\r\nupper_HSRS = upperHSRS + ta.wma(math.abs(dHSRS), lengthHSRS)\r\nlower_HSRS = lowerHSRS - ta.wma(math.abs(dHSRS), lengthHSRS)\r\n\r\n// Determine where price is relative to HSRS bands (\"Floors\" of the building)\r\nHSRS_RangePenthouse = CS_AATS >= upper_HSRS ? 6 : 0\r\nHSRS_Range4thFloor = CS_AATS < upper_HSRS and CS_AATS >= upperHSRS ? 5 : 0\r\nHSRS_Range3rdFloor = CS_AATS < upperHSRS and CS_AATS >= basisHSRS ? 4 : 0\r\nHSRS_Range2ndFloor = CS_AATS < basisHSRS and CS_AATS >= lowerHSRS ? 3 : 0\r\nHSRS_Range1stFloor = CS_AATS < lowerHSRS and CS_AATS >= lower_HSRS ? 2 : 0\r\nHSRS_RangeDungeon = CS_AATS < lower_HSRS ? 1 : 0\r\nHSRS_Location = HSRS_RangeDungeon + HSRS_Range1stFloor + HSRS_Range2ndFloor + HSRS_Range3rdFloor + HSRS_Range4thFloor + HSRS_RangePenthouse\r\n\r\n// Bollinger Band Logic (MBB)\r\nsrcMBB = close  \r\nlengthMBB = 34  \r\nmultMBB = 2.0  \r\n\r\nbasisMBB = ta.sma(srcMBB, lengthMBB)\r\ndevMBB = ta.stdev(srcMBB, lengthMBB)\r\ndev2MBB = multMBB * devMBB\r\ndev3MBB = multMBB * 2 * devMBB\r\n\r\nupper1MBB = basisMBB + devMBB\r\nlower1MBB = basisMBB - devMBB\r\nupper2MBB = basisMBB + dev2MBB\r\nlower2MBB = basisMBB - dev2MBB\r\nupper3MBB = basisMBB + dev3MBB\r\nlower3MBB = basisMBB - dev3MBB\r\n\r\n// Calculate AATS Engagement and Factor\r\n// Determines if we are in a strong trend zone and adjusts the Stop sensitivity (Factor)\r\nAATS_Engage3 = CS_AATS > outEMA and CS_AATS > basisHSRS and CS_AATS > upper1MBB ? 1 : CS_AATS < outEMA and CS_AATS < basisHSRS and CS_AATS < lower1MBB ? -1 : 0\r\nAATS_Factor = AATS_Engage3 == 1 and HSRS_Location == 6 ? 0.5 : AATS_Engage3 == 1 and HSRS_Location == 5 ? 2 : AATS_Engage3 == 1 and HSRS_Location == 4 ? 3 : AATS_Engage3 == -1 and HSRS_Location == 1 ? 0.5 : AATS_Engage3 == -1 and HSRS_Location == 2 ? 2 : AATS_Engage3 == -1 and HSRS_Location == 3 ? 3 : 4\r\n\r\nvar SLMod2 = \"Stop Loss Qualifiers\"\r\n\r\n// ATS Code implementation\r\nUseAATS = input(true, 'Use Advance Adaptive Trailing Stop (AATS) - (Default is On)', group = SLMod2)\r\nRestrictiveAATS = input(true, 'Use Restrictive AATS - Good for majors (Default is On)', group = SLMod2)\r\nUseRSIS = input(true, 'Use RSI Stop (RSIS) - (Default is On)', group = SLMod2)\r\n\r\nsrcATS = close\r\naATS = 0.0\r\nbATS = 0.0\r\nosATS = 0.0\r\n\r\natsFacInput = input(80, 'ATS Stop Factor (0+)', group = SLMod2)\r\nerATS = AATS_Factor / atsFacInput  \r\n\r\n// Calculate Dynamic Stop Lines\r\naATS := math.max(srcATS, nz(aATS[1], srcATS)) - math.abs(srcATS - nz(aATS[1], srcATS)) * erATS\r\nbATS := math.min(srcATS, nz(bATS[1], srcATS)) + math.abs(srcATS - nz(bATS[1], srcATS)) * erATS\r\n\r\nATSCross1 = ta.cross(aATS, srcATS) ? 1 : 0\r\nATSCross2 = ta.cross(bATS, srcATS) ? 0 : -1\r\n\r\nosATS := ATSCross1 == 1 ? 1 : ATSCross2 == 0 ? 0 : osATS[1]\r\ntsATS = osATS * bATS + (1 - osATS) * aATS\r\n\r\nATSaX = ta.sma(close - (aATS - close), 7)\r\nATSbX = ta.sma(close + close - bATS, 7)\r\n\r\n// RSI Stop Loss (RSIS) - Adds momentum verification to stops\r\nMcGinleyRSIS(_srcRSIS, lenRSIS) =>\r\n    MDRSIS = 0.0\r\n    MDRSIS := na(_srcRSIS[1]) ? _srcRSIS : MDRSIS[1] + (_srcRSIS - MDRSIS[1]) / (0.6 * lenRSIS * math.pow(_srcRSIS / MDRSIS[1], 4))\r\n    MDRSIS\r\n\r\nrsi_maRSIS = McGinleyRSIS(close, 14)\r\nATRRSIS = ta.atr(27)\r\ntop_lineRSIS = rsi_maRSIS + ATRRSIS\r\nbottom_lineRSIS = rsi_maRSIS - ATRRSIS\r\nDirectionRSIS1 = ta.crossover(close, top_lineRSIS) ? 1 : 0\r\nDirectionRSIS2 = ta.crossunder(close, bottom_lineRSIS) ? -1 : 0\r\ndirectionRSIS = 1\r\ndirectionRSIS := DirectionRSIS1 == 1 ? 1 : DirectionRSIS2 == -1 ? -1 : directionRSIS[1]\r\nstop_lineRSIS = rsi_maRSIS - directionRSIS * ATRRSIS\r\nRSIS_Signal = directionRSIS\r\n\r\nATS_CloseLongsX = UseRSIS == true and in_longCondition == true and AATS_Engage3 == 1  and RSIS_Signal == -1 ? true : false\r\nATS_CloseShortsX = UseRSIS == true and in_shortCondition == true and AATS_Engage3 == -1 and RSIS_Signal == 1 ? true : false\r\n\r\n// Check to see if we should be using ATS Module for final close signal\r\nATS_CloseLongsY = UseAATS == true and in_longCondition == true and AATS_Engage3 == 1   and low_ < bATS and low_ < ATSbX and low_ < ATSaX ? true : false  ///\r\nATS_CloseShortsY = UseAATS == true and in_shortCondition == true and AATS_Engage3 == -1 and high_ > aATS and high_ > ATSaX and high_ > ATSbX ? true : false\r\n\r\nATS_CloseLongsAgg = ATS_CloseLongsX == true or ATS_CloseLongsY == true ? true : false\r\nATS_CloseShortsAgg = ATS_CloseShortsX == true or ATS_CloseShortsY == true ? true : false\r\n\r\nATS_CloseLongsRestrictive = ATS_CloseLongsY == true ? true : false\r\nATS_CloseShortsRestrictive = ATS_CloseShortsY == true ? true : false\r\n\r\n// Final ATS Flags\r\nATS_CloseLongs = RestrictiveAATS == true ? ATS_CloseLongsRestrictive : ATS_CloseLongsAgg\r\nATS_CloseShorts = RestrictiveAATS == true ? ATS_CloseShortsRestrictive : ATS_CloseShortsAgg\r\n\r\n\r\n/////////////////////////////////\r\n//======[ Close Signals ]======//\r\n/////////////////////////////////\r\n\r\n// [NOTE] Consolidate all exit reasons into a single variable.\r\n// This checks: Hard stops, Trailing Stops, Take Profits, and Adaptive Stops.\r\nlongCloseX := isLong and (long_tp or long_sl or long_ts  or ATS_CloseLongs ) and not longCondition\r\nshortCloseX := isShort and (short_tp or short_sl or short_ts or ATS_CloseShorts ) and not shortCondition\r\n\r\n\r\n////////////////////////////////////////////////////////////////\r\n//* Final Order Signals - Buys and Sells                     *//\r\n////////////////////////////////////////////////////////////////\r\n\r\n// [NOTE] Final Signal processing for strategy entry.\r\nRMPlot = (longCloseX == true or CSX==1) ? 1 : (shortCloseX == true or CSX==-1) ? -1 : 0\r\nRMSig = RMPlot == 1 and RMPlot != RMPlot[1] ? 1 : \r\n   RMPlot == -1 and RMPlot != RMPlot[1] ? -1 : 0\r\n\r\nClearRM =(AT==2 and RMSig==1)? 3: (AT==-2 and RMSig==-1)?-3: 0\r\n\r\nClearRMP=float(na) \r\nClearRMP:=(ClearRM==3)?3: (ClearRM==-3)?-3: (AO==2 or AO==-2)? 0: ClearRMP[1]\r\n\r\nCloseEmAll = float(na)\r\nCloseEmAll := ClearRM == 3 and ClearRM[1] != 3 and ClearRMP[1]==0 ? 1 : ClearRM == -3 and ClearRM[1] != -3 and ClearRMP[1]==0 ? -1 : 0\r\n\r\nReOrder= (ClearRMP==0 and ClearRMP[1]==3 and ClearRMP!=ClearRMP[1])? 4: (ClearRMP==0 and ClearRMP[1]==-3 and ClearRMP!=ClearRMP[1])?-4:0\r\n\r\nFin = (AF==2 or ReOrder==4 and AT==2)?2 : (AF==-2 or ReOrder==-4 and AT==-2)? -2:0\r\n\r\n\r\n////////////////////////////////////////////////////////////////\r\n//* Backtest Buys and Sells                                  *//\r\n////////////////////////////////////////////////////////////////\r\n\r\n// [NOTE] Strategy Execution Block.\r\n// This section triggers the actual strategy orders on the chart.\r\n// It maps the 'Fin' signals to Entries and the 'STP' variables to Exits.\r\n\r\nif testPeriod() and LongAndShort==1\r\n    strategy.entry('Long', strategy.long, when=Fin == 2, comment='Long')\r\n    strategy.exit('TP1 L', from_entry='Long', limit=longSTP1, qty_percent=Stp1QtyF, comment='L-TP1')\r\n    strategy.exit('TP2 L', from_entry='Long', limit=longSTP2, qty_percent=Stp2QtyF, comment='L-TP2')\r\n    strategy.exit('TP3 L', from_entry='Long', limit=longSTP3, qty_percent=Stp3QtyF, comment='L-TP3')\r\n    strategy.close('Long', when=CSX == 1 or longCloseX)\r\n\r\nif testPeriod() and LongAndShort==1\r\n    strategy.entry('Short', strategy.short, when=Fin == -2, comment='Short')\r\n    strategy.exit('TP1 S', from_entry='Short', limit=shortSTP1, qty_percent=Stp1QtyF, comment='S-TP1')\r\n    strategy.exit('TP2 S', from_entry='Short', limit=shortSTP2, qty_percent=Stp2QtyF, comment='S-TP2')\r\n    strategy.exit('TP3 S', from_entry='Short', limit=shortSTP3, qty_percent=Stp3QtyF, comment='S-TP3')\r\n    strategy.close('Short', when=CSX == -1 or shortCloseX)\r\n     \r\nif testPeriod() and LongAndShort==2\r\n    strategy.entry('Long', strategy.long, when=Fin == 2, comment='Long')\r\n    strategy.exit('TP1 L', from_entry='Long', limit=longSTP1, qty_percent=Stp1QtyF, comment='L-TP1')\r\n    strategy.exit('TP2 L', from_entry='Long', limit=longSTP2, qty_percent=Stp2QtyF, comment='L-TP2')\r\n    strategy.exit('TP3 L', from_entry='Long', limit=longSTP3, qty_percent=Stp3QtyF, comment='L-TP3')\r\n    strategy.close('Long', when=CSX == 1 or longCloseX or Fin==-2)\r\n\r\nif testPeriod() and LongAndShort==3\r\n    strategy.entry('Short', strategy.short, when=Fin == -2, comment='Short')\r\n    strategy.exit('TP1 S', from_entry='Short', limit=shortSTP1, qty_percent=Stp1QtyF, comment='S-TP1')\r\n    strategy.exit('TP2 S', from_entry='Short', limit=shortSTP2, qty_percent=Stp2QtyF, comment='S-TP2')\r\n    strategy.exit('TP3 S', from_entry='Short', limit=shortSTP3, qty_percent=Stp3QtyF, comment='S-TP3')\r\n    strategy.close('Short', when=CSX == -1 or shortCloseX or Fin==2)\r\n\r\n\r\n////////////////////////////////////////////////////////////////\r\n//* Alerts Buys and Sells (For Indicator Mode)               *//\r\n////////////////////////////////////////////////////////////////\r\n\r\n// [NOTE] ALERT VISUALIZERS\r\n// These plots are commented out by default. \r\n// If you have switched to \"Indicator Mode\" (at the top of the script), you can uncomment these lines.\r\n// They will plot visual spikes on the chart (1, -1, 2, -2) which you can use to set up \r\n// \"Any Alert() function calls\" for automation.\r\n\r\n// Buy and Sell Signals - Fin==2 Long, Fin==-2 Short\r\n// plot(Fin, title=\"Order Open\",linewidth=3,color=color.blue)\r\n\r\n// RM Close Alerts = Close Long = 1, Close Short =-1\r\n// plot(CloseEmAll, title=\"RM Close\", linewidth=3,color=color.yellow)\r\n\r\n// Take Profit Plot 1,2, 3 for Long TP1, 2, 3, and -1 -2 -3 for shorts\r\n// plot(isSTP==true ? TakeProfit1Plot : na, title=\"TP-1 Close\", linewidth=3,color=color.lime)\r\n// plot(isSTP==true ? TakeProfit2Plot : na, title=\"TP-2 Close\", linewidth=3,color=color.olive)\r\n// plot(isSTP==true ? TakeProfit3Plot : na, title=\"TP-3 Close\", linewidth=3,color=color.green)\r\n\r\n\r\n///////////////////////////////////\r\n//======[ Reset Variables ]======//\r\n///////////////////////////////////\r\n\r\n// [NOTE] Variable Maintenance\r\n// This resets the tracking variables when a trade is closed to ensure clean data for the next trade.\r\n// Critical for the correct functioning of the TradeState engine.\r\n\r\nif longCloseX or not in_longCondition\r\n    last_high := na\r\n    last_high_short := na\r\n\r\n\r\nif shortCloseX or not in_shortCondition\r\n    last_low := na\r\n    last_low_long := na\r\n\r\n\r\nif longCloseX or shortCloseX\r\n    tradeState := 0\r\n    in_longCondition := false\r\n    in_shortCondition := false\r\n\r\n\r\n\r\n///////////////////////////////////\r\n//======[ EOF - Done Baby ]======//\r\n///////////////////////////////////"
  },
  {
    "url": "CY5vP0fb",
    "name": "Mean-Reversion with Cooldown",
    "description": "This strategy requires no indicators or fundamental analysis. It is designed for longer-term positions and works especially well on unleveraged instruments with strong long-term upward trends, such as precious metals. Feel free to experiment with different timeframes â€” Iâ€™ve found that 1-hour charts work particularly well for cryptocurrencies.\nThe idea is to filter out ongoing bear phases as effectively as possible and capitalize on long-term bull runs.\nThe script implements an idea that came to me in a state of complete sleep deprivation: open a random long position with a fixed take-profit (TP) and a tight stop-loss (SL).\nIf the TP is hit â€” great, we simply try again.\nIf the SL is triggered â€” too bad, we pause for a while and then try again.\n\n## Cooldown (Waiting) Mechanism\n\nThe waiting mechanism is simple: the more consecutive SL hits we get, the longer we wait before opening the next trade. The waiting time is measured in closed candles, and thus depends on the timeframe you are using.\n\n## Two cooldown calculation modes are currently supported:\n\n### 1. FIBONACCI\n\nThe cooldown follows the Fibonacci sequence, based on the number of consecutive losses:\n\n1st loss â†’ wait 1 bar\n\n2nd loss â†’ wait 1 bar\n\n3rd loss â†’ wait 2 or 3 bars (depending on definition)\n\n4th loss â†’ wait 3 or 5 bars\n\netc.\n\n### 2. POWER OF TWO\n\nThe cooldown increases exponentially:\n\n1st loss â†’ wait 2 bars\n\n2nd loss â†’ wait 4 bars\n\n3rd loss â†’ wait 8 bars\n\n4th loss â†’ wait 16 bars\n\nand so on, using the formula 2â¿.\n\n## Configurable Parameters\n\n### Cooldown Pause Calculation\nThe settings allow you to define the SL and TP as percentages of the position value.\nThe \"Cooldown Pause Calculation\" option determines how the next cooldown duration is computed after a losing trade.\n\nThe system keeps track of how many consecutive losses have occurred since the last profitable trade. That counter is then used to compute how many bars we must wait before opening the next position.\n\n### Maximum Cooldown\n\nThe \"Max Cooldown Candles\" setting defines the maximum number of bars we are allowed to wait before placing a new trade. This prevents the strategy from â€œlocking itself outâ€ for too long and mitigates the fear of missing out (FOMO).\n\nOnce the cooldown duration reaches this maximum, the system essentially wraps around and starts the progression again. In the script, this is handled using a simple modulo operation based on the chosen maximum.",
    "image_url": "CY5vP0fb",
    "author": "jannisMCMXCV",
    "likes": 8,
    "type": "strategy",
    "created": "2025-12-01",
    "updated": "2025-12-01",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// Â© jannisMCMXCV\r\n\r\n//@version=6\r\nstrategy(\"Mean-Reversion with Cooldown\", overlay=true, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=90, pyramiding=1)\r\n\r\n// === PARAMETER ===\r\nsl_percent = input.float(0.2, \"Stop Loss (%)\") / 100\r\ntp_percent = input.float(2.5, \"Take Profit (%)\") / 100\r\n\r\nenum cd_mode\r\n    fib  = \"FIBONACCI\"\r\n    pow = \"POWER OF TWO\"\r\n\r\ncooldown_mode = input.enum(cd_mode.fib, \"Cooldwon pause calculation\")\r\nmax_cooldown = input.int(16, \"Max Cooldown Candles\")\r\n\r\n// === VARIABLEN ===\r\nvar float tp_price = na\r\nvar float sl_price = na\r\n\r\nvar int loss_count = 0\r\nvar int cooldown_bars = 0    // How many bars do we wait until opening the next long position?\r\nvar int cooldown_timer = 0   // current Countdown\r\n\r\nvar bool had_position_prev_bar = false\r\n\r\nf_fib(n) =>\r\n    if n <= 1\r\n        n\r\n    else\r\n        a = 0\r\n        b = 1\r\n        for i = 2 to n\r\n            c = a + b\r\n            a := b\r\n            b := c\r\n        b\r\n\r\nf_cooldown(n) =>\r\n    switch cooldown_mode\r\n        cd_mode.fib => f_fib(n)\r\n        cd_mode.pow => math.round(math.pow(2, n))\r\n\r\n// === STATUS ===\r\nhas_open_trade = strategy.position_size > 0\r\n\r\n// === TRIGGER FOR NEW TRADES ===\r\nnew_trade_allowed = not has_open_trade and cooldown_timer <= 0\r\n\r\n// === ENTRY ===\r\nif new_trade_allowed\r\n    sl_price := close * (1 - sl_percent)\r\n    tp_price := close * (1 + tp_percent)\r\n\r\n    strategy.entry(\"long\", strategy.long)\r\n\r\n    // marker: how many bars do we have to wait for re-entering?\r\n    cooldown_timer := na\r\n\r\n// === EXIT-BEFEHL ===\r\nif has_open_trade\r\n    strategy.exit(\"exit\", \"long\", stop=sl_price, limit=tp_price)\r\n\r\n// === Evaluation of closed trades ===\r\nif not has_open_trade and had_position_prev_bar\r\n    // There was an exit\r\n    last_idx = strategy.closedtrades - 1\r\n    pnl = strategy.closedtrades.profit(last_idx)\r\n\r\n    if pnl < 0\r\n        loss_count += 1\r\n        cooldown_bars := f_cooldown(loss_count) % max_cooldown\r\n    else\r\n        loss_count := 0\r\n        cooldown_bars := 0\r\n\r\n    cooldown_timer := cooldown_bars   // Setze Countdown aktiv\r\n\r\n// === DECREMENT COOLDOWN COUNTER ===\r\nif not has_open_trade and cooldown_timer > 0\r\n    cooldown_timer -= 1\r\n\r\n// === POSITION-STATUS ===\r\nhad_position_prev_bar := has_open_trade\r\n\r\n"
  },
  {
    "url": "AIe7zLf1-V-Stop-MTF-STRATEGY",
    "name": "V Stop MTF â†’ STRATEGY ",
    "description": "Why this strategy works so well (your backtest proves it):\n\nFeatureBenefitMulti-timeframe Volatility StopSmarter trend detection than single TFRepainting controlYou can choose safe non-repainting modeLimbo/breach detectionAvoids whipsaws during HTF conflictsReversing systemAlways in the market â†’ captures all trendsCandle coloring on reversalInstant visual confirmation\nRecommended settings that match your +17.33% result:\n\nSymbol: SP:SPX or ES1!\nTimeframe: 9min or 15min Heikin-Ashi\nHTF: \"Multiple Of Current TF\" Ã— 3 â†’ gives ~45min on 15min chart\nATR Length: 20\nATR Factor: **2.0\n",
    "image_url": "AIe7zLf1",
    "author": "PawelMr",
    "likes": 12,
    "type": "strategy",
    "created": "2025-11-30",
    "updated": "2025-11-30",
    "source": "//@version=5\nstrategy(\"Volatility Stop MTF â†’ STRATEGY [Fixed - No Errors]\", \n         overlay = true,\n         default_qty_type = strategy.fixed,\n         default_qty_value = 1,\n         initial_capital = 100000,\n         commission_value = 0,\n         slippage = 0,\n         pyramiding = 1,\n         calc_on_every_tick = false,\n         process_orders_on_close = true,   // Critical for exact match with indicator\n         max_bars_back = 5000)\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// IMPORTS & INPUTS (100% identical to your indicator)\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nimport PineCoders/Time/1 as pcTimeLib\n\n// Colors\ncolor GREEN1     = #00FF00FF\ncolor DARKLIME   = #00FF0080\ncolor RED1       = #FF0000FF\ncolor DARKRED    = #FF0000b0\ncolor DEEPSKY    = #00C0FFFF\ncolor DEEPBLUE   = #00C0FF80\ncolor DEEPPINK   = #FF0080FF\ncolor DARKPINK   = #FF008080\ncolor ORANGE     = #FF8000FF\ncolor DARKORANGE = #FF8000d0\ncolor CLEARBLACK = #00000000\n\n// Inputs - exactly as in your indicator\nstring GRP1 = \"â•â•â•â•â•â•â•â•â• Stop Calculations â•â•â•â•â•â•â•â•â•\"\nsrcInput   = input.source(close,  \"Source\",          group = GRP1)\nlenInput   = input.int(20,        \"Length\",          group = GRP1, minval = 2)\natrInput   = input.float(2.0,     \"ATR Factor\",      group = GRP1, minval = 0.25, step = 0.25)\n\nstring GRP2 = \"â•â•â•â•â•â•â•â•â•â•â€„ HTF Selection â€„â•â•â•â•â•â•â•â•â•â•\"\ntypeInput  = input.string(\"Multiple Of Current TF\", \"Higher Timeframe Selection\", options = [\"None\", \"Discrete Steps (60min, 1D, 3D, 1W, 1M, 12M)\", \"Multiple Of Current TF\", \"Fixed TF\"], group = GRP2)\ntype2Input = input.float(3.0, \"â€ƒâ€ƒMultiple of Current TF\", minval = 1, group = GRP2)\ntype3Input = input.timeframe(\"D\", \"â€ƒâ€ƒFixed TF\", group = GRP2)\n\ndetectBreachesInput = input.bool(true,  \"Detect Breaches By Chart Bars\", group = GRP2)\nrepaintsInput       = input.bool(false, \"Repainting HTF\", group = GRP2)\nbreachesMrkrInput   = input.bool(true,  \"â€ƒâ€ƒShow Chart Breaches\", group = GRP2)\nbreachedBarsInput   = input.bool(false, \"â€ƒâ€ƒColor Bars in Limbo\", group = GRP2)\nbreachedBgInput     = input.bool(false, \"â€ƒâ€ƒHighlight Background in Limbo\", group = GRP2)\n\nstring GRP4 = \"â•â•â•â•â•â•â•â•â•â•â•â•â€‡ Visuals â€‡â•â•â•â•â•â•â•â•â•â•â•\"\ncolSchemeInput = input.string(\"Aqua/Pink\", \"Color Scheme\", options = [\"Lime/Red\", \"Aqua/Pink\"], group = GRP4)\nthicknessInput = input.int(2, \"Line Thickness\", options = [0,1,2,3], group = GRP4)\ncolorBarsInput = input.bool(false, \"Color Bars on Trend State (continuous)\", group = GRP4)\ncolorCandlesOnReversal = input.bool(true, \"Color Candles on Trend Reversal\", group = GRP4)   // â† Your favorite feature\n\nstring GRP5 = \"â•â•â•â•â•â•â•â•â•â•â•â€‡ Display HTF â€‡â•â•â•â•â•â•â•â•â•â•\"\nshowHTFInput = input.bool(false, \"Show HTF Used\", group = GRP5)\nstring textSizeInput = input.string(\"large\", \"Text Size\", group = GRP5, options = [\"tiny\",\"small\",\"normal\",\"large\",\"huge\",\"auto\"])\nstring tableYposInput = input.string(\"bottom\", \"Positionâ€ƒâ€ƒ\", group = GRP5, options = [\"top\",\"middle\",\"bottom\"], inline = \"41\")\nstring tableXposInput = input.string(\"right\", \"\", group = GRP5, options = [\"left\",\"center\",\"right\"], inline = \"41\")\n\nbool defaultScheme = colSchemeInput == \"Lime/Red\"\nbool htfOn = typeInput != \"None\"\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// Volatility Stop Function (exact copy from your indicator)\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nvStop(series float source, simple int atrLength, series float atrMult, series int offset = 0) =>\n    float src = nz(source, close)\n    var bool  trendUp = true\n    var float max     = src\n    var float min     = src\n    var float stop    = 0.0\n    float atrM = nz(ta.atr(atrLength) * atrMult, ta.tr)\n    max := math.max(max, src)\n    min := math.min(min, src)\n    stop := nz(trendUp ? math.max(stop, max - atrM) : math.min(stop, min + atrM), src)\n    trendUp := src - stop >= 0.0\n    if trendUp != nz(trendUp[1], true)\n        max := src\n        min := src\n        stop := trendUp ? max - atrM : min + atrM\n    [stop[offset], trendUp[offset]]\n\n// HTF Logic\ntfNextStep(simple int tf) =>\n    switch\n        tf <= 1    => \"60\"\n        tf <= 60   => \"1D\"\n        tf <= 360  => \"3D\"\n        tf <= 1440 => \"1W\"\n        tf <= 10080=> \"1M\"\n        => \"12M\"\n\nint tfInSec = timeframe.in_seconds()\nstring htf = switch typeInput\n    \"Discrete Steps (60min, 1D, 3D, 1W, 1M, 12M)\" => tfNextStep(tfInSec / 60)\n    \"Multiple Of Current TF\"                     => pcTimeLib.secondsToTfString(tfInSec, type2Input)\n    \"Fixed TF\"                                   => type3Input\n    => \"\"\n\nint offset = not htfOn ? 0 : (not repaintsInput and barstate.isrealtime ? 1 : 0)\n\n[stopChartTf, trendUpChartTf] = vStop(srcInput, lenInput, atrInput, offset)\n\n// FIXED: Separate request.security calls for lookahead (cannot be conditional)\n[stopSec_repaint, trendUpSec_repaint] = request.security(syminfo.tickerid, htf, [stopChartTf, trendUpChartTf], lookahead = barmerge.lookahead_on)\n[stopSec_norepaint, trendUpSec_norepaint] = request.security(syminfo.tickerid, htf, [stopChartTf, trendUpChartTf], lookahead = barmerge.lookahead_off)\n\nfloat stopSec     = repaintsInput ? stopSec_repaint : stopSec_norepaint\nbool  trendUpSec  = repaintsInput ? trendUpSec_repaint : trendUpSec_norepaint\n\nfloat stopHTF     = stopSec[repaintsInput or barstate.isrealtime ? 0 : 1]\nbool  trendUpHTF  = trendUpSec[repaintsInput or barstate.isrealtime ? 0 : 1]\n\nfloat stop    = htfOn ? stopHTF : stopChartTf\nbool  trendUp = htfOn ? trendUpHTF : trendUpChartTf\n\n// Limbo state (breach detection) - exact from your indicator\nvar bool inLimbo = false\nbool trendReversal = trendUp != trendUp[1]\nbool trendChangeToUp = trendUp and not trendUp[1]\nbool trendChangeToDn = not trendUp and trendUp[1]\nbool htfBreach = htfOn and detectBreachesInput and not inLimbo and ta.cross(close, stop)\nbool earlyBreachUp = htfBreach and not trendReversal and trendUp\nbool earlyBreachDn = htfBreach and not trendReversal and not trendUp\ninLimbo := (inLimbo or htfBreach) and trendUp == trendUp[1]\n\n// Trading signals (only when not in limbo)\nbool goLongSignal  = trendChangeToUp and not inLimbo\nbool goShortSignal = trendChangeToDn and not inLimbo\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// STRATEGY EXECUTION â€“ Reversing System\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nif goLongSignal\n    strategy.entry(\"Long\", strategy.long)\nif goShortSignal\n    strategy.entry(\"Short\", strategy.short)\n\n// Close opposite on reversal (always in market)\nif goLongSignal\n    strategy.close(\"Short\")\nif goShortSignal\n    strategy.close(\"Long\")\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// VISUALS â€“ Exact replica of your indicator\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\ncolor colorUp   = inLimbo ? (defaultScheme ? DARKLIME : DEEPBLUE) : (defaultScheme ? GREEN1 : DEEPSKY)\ncolor colorDown = inLimbo ? (defaultScheme ? DARKRED  : DARKPINK) : (defaultScheme ? RED1   : DEEPPINK)\ncolor schemeColor = inLimbo\n     ? (defaultScheme ? (trendUp ? DARKLIME : DARKRED) : (trendUp ? DEEPBLUE : DARKPINK))\n     : (defaultScheme ? (trendUp ? GREEN1 : RED1)       : (trendUp ? DEEPSKY : DEEPPINK))\ncolor lineColor = trendReversal or htfBreach ? CLEARBLACK : schemeColor\n\n// NEW: Candle colors on reversal (your feature)\ncolor candleBull = defaultScheme ? GREEN1 : DEEPSKY\ncolor candleBear = defaultScheme ? RED1   : DEEPPINK\n\nplot(thicknessInput != 0 ? stop : na, \"V-Stop\", lineColor, thicknessInput)\nplot(trendReversal ? stop : na, \"Beg. Circle\", schemeColor, math.max(thicknessInput,1)+2, plot.style_circles)\nplot(trendReversal ? stop : na, \"Beg. Small circle\", #000000ff, math.max(thicknessInput,1), plot.style_circles)\n\n// Entry shapes\nplotshape(goLongSignal,  title=\"Long Signal\",  location=location.belowbar, color=color.lime, style=shape.triangleup,   size=size.small)\nplotshape(goShortSignal, title=\"Short Signal\", location=location.abovebar, color=color.red,  style=shape.triangledown, size=size.small)\n\n// Breach markers\nplotshape(breachesMrkrInput and earlyBreachUp, \"Breach of HTF Uptrend\", shape.triangledown, location.abovebar, RED1, size = size.tiny)\nplotshape(breachesMrkrInput and earlyBreachDn, \"Breach of HTF Downtrend\", shape.triangleup,   location.belowbar, RED1, size = size.tiny)\n\n// â€”â€”â€”â€”â€” Bar coloring â€”â€”â€”â€”â€” (exact from your indicator)\n// 1. Original continuous coloring (optional)\nbarcolor(colorBarsInput ? (trendUp ? colorUp : colorDown) : na)\n// 2. Color candles instantly on every trend reversal\nbarcolor(colorCandlesOnReversal and trendReversal ? (trendUp ? candleBull : candleBear) : na)\n// 3. Limbo coloring (orange)\nbarcolor(breachedBarsInput and inLimbo ? (close > open ? ORANGE : DARKORANGE) : na)\n\nbgcolor(breachedBgInput and inLimbo ? color.new(color.silver, 90) : na)\n\n// Error check (from your indicator)\nif htfOn and tfInSec >= timeframe.in_seconds(htf)\n    runtime.error(\"Chart timeframe must be < \" + htf)\n\n// HTF display table (from your indicator)\nif barstate.islastconfirmedhistory and htfOn and showHTFInput\n    var table tfDisplay = table.new(tableYposInput + \"_\" + tableXposInput, 1, 1)\n    table.cell(tfDisplay, 0, 0, htf, text_color = color.silver, text_size = textSizeInput)\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// ALERTS (same as your indicator)\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nstring A1 = alert.freq_once_per_bar\nstring A2 = alert.freq_once_per_bar_close\nstring freqInput = input.string(A1, \"Alert Frequency\", options = [A1, A2])\n\nfloat delayInput = input.float(0.0, \"Delay in Minutes\", minval = 0.0, step = 0.5)\nfloat secondsUp = pcTimeLib.secondsSince(trendChangeToUp, false)\nfloat secondsDn = pcTimeLib.secondsSince(trendChangeToDn, false)\nbool alertUp = secondsUp >= delayInput * 60\nbool alertDn = secondsDn >= delayInput * 60\nbool alertRev = alertUp or alertDn\n\nbool timed = delayInput != 0\nfloat duration = trendChangeToUp ? secondsUp : secondsDn\n\nif alertRev\n    alert(\"Trend Reversal. \" + (timed ? \"Close crossed stop for \" + str.tostring(duration/60,\"#.##m\") : \"\"), freqInput)\nif alertUp\n    alert(\"Change to uptrend. \" + (timed ? \"Close was above stop for \" + str.tostring(secondsUp/60,\"#.##m\") : \"\"), freqInput)\nif alertDn\n    alert(\"Change to downtrend. \" + (timed ? \"Close was below stop for \" + str.tostring(secondsDn/60,\"#.##m\") : \"\"), freqInput)"
  },
  {
    "url": "P3fyKd3i-KAMA-Flip-strategy",
    "name": " KAMA Flip strategy",
    "description": "I built this strategy because I wanted something that doesnâ€™t overcomplicate trading.\nNo 20 indicators, no guessing, no â€œmaybe I should close here.â€\nJust a clear momentum flip, a defined stop, and a defined take profit. (for me on 1D BTC chart it works best with 6% stoploss and 3% takeprofit, lookback should be 40, everything else standard)\n\nThe idea is simple: when momentum shifts, I want to be on the right side of it.\nKAMA is good for this because it speeds up when the market moves and slows down when it doesnâ€™t.\nI normalize it so it becomes a clean zero-line oscillator.\nAbove zero means momentum is turning up. Below zero means itâ€™s turning down.\n\nThatâ€™s the entire entry logic. A flip is a flip.\n\nThe exit logic is just as simple: one stop loss, one take profit, both fixed percentages from the entry.\nThe position closes 100% at the target or the stop. No scaling in, no scaling out, no trailing.\nItâ€™s straightforward and easy to analyze because every trade has the exact same structure.\n\nI originally made this for BTC on the daily chart, but nothing stops you from trying it on other charts.\nIf you want it only to go long, only to go short, or take both sides, you can set that.\nAll the KAMA parameters are open so you can play with how reactive the signal is.\nThe visuals and SL/TP lines can be turned on or off depending on how clean you want your chart.\n\nThis isnâ€™t financial advice. Itâ€™s just a system I like because itâ€™s simple, objective, and does exactly what itâ€™s supposed to do.\nTest it, adjust it, break it, rebuild it â€” do whatever fits your own approach.",
    "image_url": "P3fyKd3i",
    "author": "SystemsOverFeelings",
    "likes": 22,
    "type": "strategy",
    "created": "2025-11-29",
    "updated": "2025-11-29",
    "source": "//@version=6\nstrategy(\"12/21 Bands â€“ KAMA Flip TP (Single TP 100%) for BTC on 1D\",\n     overlay=true,\n     initial_capital=100,\n     default_qty_type=strategy.percent_of_equity,\n     default_qty_value=1,\n     commission_type=strategy.commission.percent,\n     commission_value=0.05,\n     pyramiding=0,\n     process_orders_on_close=true)\n\n// ===== Inputs =====\nside   = input.string(\"Short only\", \"Trade Side\", options=[\"Short only\",\"Long only\",\"Both\"])\nslPct  = input.float(3.0, \"Stop Loss %\", step=0.1, minval=0) * 0.01\ntpPct  = input.float(3.0, \"Take Profit % (single TP)\", step=0.1, minval=0) * 0.01\n\n// --- KAMA settings (live-safe version) ---\ner_period    = input.int(8,  \"Efficiency Ratio Period\",  minval=1, group=\"KAMA\")\nfast_period  = input.int(7,  \"Fast Period\",              minval=1, group=\"KAMA\")\nslow_period  = input.int(19, \"Slow Period\",              minval=1, group=\"KAMA\")\nnorm_period  = input.int(50, \"Normalization Lookback\",   minval=1, group=\"KAMA\")\nconfirmBar   = input.bool(true, \"Confirm signals on bar close\", group=\"KAMA\")\n\n// --- Visual toggles ---\nshowOsc      = input.bool(false, \"Show oscillator in price pane (can compress scale)\", group=\"Visuals\")\nshowLines    = input.bool(true,  \"Show SL/TP line objects\", group=\"Visuals\")\nshowPlots    = input.bool(true,  \"Show SL/TP plots\",        group=\"Visuals\")\n\n// ===== Normalized KAMA Oscillator (live-safe, non-repainting) =====\nchange     = math.abs(close - close[er_period])\nvolatility = math.sum(math.abs(close - close[1]), er_period)\nsafeVol    = math.max(volatility, 1e-10)\ner_raw     = change / safeVol\ner         = math.min(math.max(er_raw, 0.0), 1.0)   // clamp [0,1]\n\nsc = er * (2.0 / (fast_period + 1.0) - 2.0 / (slow_period + 1.0)) + 2.0 / (slow_period + 1.0)\nemaFast = ta.ema(close, fast_period)\nkama    = emaFast + sc * (close - emaFast)\n\nlowest  = ta.lowest(kama, norm_period)\nhighest = ta.highest(kama, norm_period)\nrng     = math.max(highest - lowest, 1e-10)\nnormalized_kama = (kama - lowest) / rng - 0.5\n\n// ===== Signals =====\nlongTrigRaw  = ta.crossover(normalized_kama, 0)\nshortTrigRaw = ta.crossunder(normalized_kama, 0)\nlongTrig     = confirmBar ? (longTrigRaw  and barstate.isconfirmed) : longTrigRaw\nshortTrig    = confirmBar ? (shortTrigRaw and barstate.isconfirmed) : shortTrigRaw\n\nwantLong  = side == \"Long only\"  or side == \"Both\"\nwantShort = side == \"Short only\" or side == \"Both\"\n\n// ===== Plot (oscillator) =====\nplot(showOsc ? normalized_kama : na, color=color.new(color.aqua, 0), title=\"Normalized KAMA\")\nhline(0, \"Zero\", color=color.new(color.gray, 50))\nbgcolor(showOsc ? (normalized_kama > 0 ? color.new(color.green, 90) : color.new(color.red, 90)) : na)\n\n// ===== Persistent variables =====\nvar float slLvl = na\nvar float tpLvl = na\nvar line  slLine = na\nvar line  tpLine = na\n\n// ===== Entries =====\nif wantLong and strategy.position_size == 0 and longTrig\n    strategy.entry(\"Long\", strategy.long)\n\nif wantShort and strategy.position_size == 0 and shortTrig\n    strategy.entry(\"Short\", strategy.short)\n\n// Detect new position and compute SL/TP\nnewLong  = strategy.position_size > 0 and strategy.position_size[1] <= 0\nnewShort = strategy.position_size < 0 and strategy.position_size[1] >= 0\n\nif newLong\n    float avg = strategy.position_avg_price\n    slLvl := avg * (1 - slPct)\n    tpLvl := avg * (1 + tpPct)\n\n    if showLines\n        if not na(slLine)\n            line.delete(slLine)\n        if not na(tpLine)\n            line.delete(tpLine)\n        slLine := line.new(bar_index, slLvl, bar_index + 1, slLvl, color=color.new(color.red, 0), width=2, extend=extend.right)\n        tpLine := line.new(bar_index, tpLvl, bar_index + 1, tpLvl, color=color.new(color.green, 0), width=2, extend=extend.right)\n\nif newShort\n    float avg = strategy.position_avg_price\n    slLvl := avg * (1 + slPct)\n    tpLvl := avg * (1 - tpPct)\n\n    if showLines\n        if not na(slLine)\n            line.delete(slLine)\n        if not na(tpLine)\n            line.delete(tpLine)\n        slLine := line.new(bar_index, slLvl, bar_index + 1, slLvl, color=color.new(color.red, 0), width=2, extend=extend.right)\n        tpLine := line.new(bar_index, tpLvl, bar_index + 1, tpLvl, color=color.new(color.green, 0), width=2, extend=extend.right)\n\n// Maintain/clear visuals when flat\nif strategy.position_size == 0\n    slLvl := na\n    tpLvl := na\n    if showLines\n        if not na(slLine)\n            line.delete(slLine)\n            slLine := na\n        if not na(tpLine)\n            line.delete(tpLine)\n            tpLine := na\nelse\n    if showLines\n        if not na(slLine)\n            line.set_x2(slLine, bar_index)\n        if not na(tpLine)\n            line.set_x2(tpLine, bar_index)\n\n// ===== ALSO PLOT SL/TP as series (easier to see)\nslPlot = strategy.position_size != 0 ? slLvl : na\ntpPlot = strategy.position_size != 0 ? tpLvl : na\nplot(showPlots ? slPlot : na, title=\"Stop Loss (plot)\", style=plot.style_linebr, color=color.new(color.red, 0), linewidth=2)\nplot(showPlots ? tpPlot : na, title=\"Take Profit (plot)\", style=plot.style_linebr, color=color.new(color.green, 0), linewidth=2)\n\n// ===== Single target exit (closes 100%) =====\nif strategy.position_size > 0 and not na(slLvl) and not na(tpLvl)\n    strategy.exit(\"TP/SL\", from_entry=\"Long\",  qty_percent=100, stop=slLvl, limit=tpLvl)\n\nif strategy.position_size < 0 and not na(slLvl) and not na(tpLvl)\n    strategy.exit(\"TP/SL\", from_entry=\"Short\", qty_percent=100, stop=slLvl, limit=tpLvl)\n"
  },
  {
    "url": "qgY9wJ7h-Estrategia-TEMA-Pro-L%C3%ADmite-Ops-por-Ventana",
    "name": "Estrategia TEMA Pro [LÃ­mite Ops por Ventana]",
    "description": "good money\n\njucale\n\nkeep faith\n\ndont stop working\n\neat vegatables ",
    "image_url": "qgY9wJ7h",
    "author": "martinrecalde777",
    "likes": 8,
    "type": "strategy",
    "created": "2025-11-29",
    "updated": "2025-11-29",
    "source": "//@version=6\nstrategy(\"Estrategia TEMA Pro [LÃ­mite Ops por Ventana]\", overlay=true, initial_capital=1000, currency=currency.USD, default_qty_type=strategy.percent_of_equity, default_qty_value=10)\n\n// ==========================================\n// FUNCIÃ“N AUXILIAR: TEMA\n// ==========================================\ntema_custom(src, len) =>\n    ema1 = ta.ema(src, len)\n    ema2 = ta.ema(ema1, len)\n    ema3 = ta.ema(ema2, len)\n    3 * (ema1 - ema2) + ema3\n\n// ==========================================\n// 1. GESTIÃ“N DE RIESGO\n// ==========================================\ngrp_risk = \"GestiÃ³n de Riesgo\"\nuse_fixed_sl = input.bool(true, \"Usar Stop Loss Fijo Inicial\", group=grp_risk, inline=\"sl\")\nsl_atr_mult  = input.float(1.0, \"Distancia SL (x ATR)\", minval=0.1, step=0.1, group=grp_risk, inline=\"sl\")\nrr_ratio      = input.float(4.0, \"Distancia TP (x ATR)\", minval=0.1, step=0.5, group=grp_risk)\nuse_tema_exit = input.bool(true, \"Salir al TOCAR TEMA RÃ¡pida\", group=grp_risk)\n\n// ==========================================\n// 2. HORARIOS Y LÃMITES (NUEVO)\n// ==========================================\ngrp_time = \"Horarios y LÃ­mites\"\ntimezone_spec = \"America/New_York\"\n\n// --- LÃMITE DE OPERACIONES ---\nmax_ops_per_sess = input.int(2, \"MÃ¡x. Operaciones por Ventana\", minval=1, group=grp_time, tooltip=\"LÃ­mite de trades permitidos dentro de una misma sesiÃ³n (ej. solo 2 tiros en la sesiÃ³n de Londres).\")\n\n// --- VENTANAS ---\nshow_time_A = input.bool(true, \"Ventana A\", group=grp_time, inline=\"A\")\nsess_time_A = input.session(\"0800-1100\", \"\", group=grp_time, inline=\"A\") \ncolor_A     = input.color(color.new(color.green, 90), \"\", group=grp_time, inline=\"A\")\n\nshow_time_B = input.bool(false, \"Ventana B\", group=grp_time, inline=\"B\")\nsess_time_B = input.session(\"1300-1600\", \"\", group=grp_time, inline=\"B\") \ncolor_B     = input.color(color.new(color.red, 90), \"\", group=grp_time, inline=\"B\")\n\nshow_time_C = input.bool(false, \"Ventana C\", group=grp_time, inline=\"C\")\nsess_time_C = input.session(\"1800-2100\", \"\", group=grp_time, inline=\"C\") \ncolor_C     = input.color(color.new(color.blue, 90), \"\", group=grp_time, inline=\"C\")\n\nshow_time_D = input.bool(false, \"Ventana D\", group=grp_time, inline=\"D\")\nsess_time_D = input.session(\"0200-0500\", \"\", group=grp_time, inline=\"D\") \ncolor_D     = input.color(color.new(color.orange, 90), \"\", group=grp_time, inline=\"D\")\n\n// Detectar si estamos dentro de la sesiÃ³n\nisInSession(bool _enabled, string _session) =>\n    not na(time(timeframe.period, _session, timezone_spec)) and _enabled\n\ninSessionA = isInSession(show_time_A, sess_time_A)\ninSessionB = isInSession(show_time_B, sess_time_B)\ninSessionC = isInSession(show_time_C, sess_time_C)\ninSessionD = isInSession(show_time_D, sess_time_D)\n\n// Detectar INICIO de sesiÃ³n (para reiniciar contadores)\nstartSessionA = inSessionA and not inSessionA[1]\nstartSessionB = inSessionB and not inSessionB[1]\nstartSessionC = inSessionC and not inSessionC[1]\nstartSessionD = inSessionD and not inSessionD[1]\n\n// --- LÃ“GICA DE CONTADORES ---\nvar int count_A = 0\nvar int count_B = 0\nvar int count_C = 0\nvar int count_D = 0\n\n// Reiniciar contadores al inicio de cada ventana\nif startSessionA\n    count_A := 0\nif startSessionB\n    count_B := 0\nif startSessionC\n    count_C := 0\nif startSessionD\n    count_D := 0\n\n// Verificar si tenemos CUPO en la sesiÃ³n actual\n// Si todas las sesiones estÃ¡n apagadas (modo 24/7), asumimos cupo infinito (quota_ok = true)\nhas_quota_A = show_time_A ? (count_A < max_ops_per_sess) : false\nhas_quota_B = show_time_B ? (count_B < max_ops_per_sess) : false\nhas_quota_C = show_time_C ? (count_C < max_ops_per_sess) : false\nhas_quota_D = show_time_D ? (count_D < max_ops_per_sess) : false\n\n// LÃ³gica final de tiempo y cupo:\n// Debemos estar en una sesiÃ³n activa Y esa sesiÃ³n debe tener cupo disponible.\n// Si todas estÃ¡n desactivadas, permitimos operar siempre.\nall_disabled = not show_time_A and not show_time_B and not show_time_C and not show_time_D\n\ncanTradeTime = all_disabled or (inSessionA and has_quota_A) or (inSessionB and has_quota_B) or (inSessionC and has_quota_C) or (inSessionD and has_quota_D)\n\n// VisualizaciÃ³n de fondos\nbgcolor(inSessionA ? color_A : na)\nbgcolor(inSessionB ? color_B : na)\nbgcolor(inSessionC ? color_C : na)\nbgcolor(inSessionD ? color_D : na)\n\n// ==========================================\n// 3. INDICADORES\n// ==========================================\ngrp_ind = \"Indicadores TÃ©cnicos\"\nlen_tema_in  = input.int(50, \"Longitud TEMA Base\", minval=1, group=grp_ind)\nsrc_tema_in  = close\nlen_tema_out = input.int(14, \"Longitud TEMA RÃ¡pida (Solo Salida)\", minval=1, group=grp_ind)\nsrc_tema_out = close\nlen_atr      = input.int(14, \"Longitud ATR\", minval=1, group=grp_ind)\n\ntema_in  = tema_custom(src_tema_in, len_tema_in)\ntema_out = tema_custom(src_tema_out, len_tema_out)\natr_value = ta.atr(len_atr)\n\nplot(tema_in, \"TEMA Base\", color=color.yellow, linewidth=2)\nplot(tema_out, \"TEMA Salida\", color=color.fuchsia, linewidth=1)\n\n// ==========================================\n// 4. FILTRO ADX\n// ==========================================\ngrp_adx = \"Filtro ADX\"\nuse_adx_filter = input.bool(true, \"Activar Filtro ADX\", group=grp_adx)\nlen_adx        = input.int(14, \"Longitud ADX\", minval=1, group=grp_adx)\nlvl_adx_min    = input.float(20.0, \"Nivel MÃ­nimo ADX\", minval=0, group=grp_adx)\n\n[_, _, adx_value] = ta.dmi(len_adx, len_adx)\nisAdxValid = use_adx_filter ? (adx_value >= lvl_adx_min) : true\n\n// ==========================================\n// 5. FILTROS DE VELA Y COOLDOWN\n// ==========================================\ngrp_candle = \"Filtro de Cuerpo de Vela\"\nuse_body_filter = input.bool(true, \"Activar Filtro Cuerpo\", group=grp_candle)\nbody_min_mult   = input.float(0.5, \"MÃ­nimo Cuerpo (x ATR)\", step=0.1, group=grp_candle)\nbody_max_mult   = input.float(3.0, \"MÃ¡ximo Cuerpo (x ATR)\", step=0.5, group=grp_candle)\ncooldown_min    = input.int(15, \"Minutos Cooldown\", group=grp_candle)\n\nbody_size = math.abs(close - open)\nmin_body = atr_value * body_min_mult\nmax_body = atr_value * body_max_mult\nisCandleValid = use_body_filter ? (body_size >= min_body and body_size <= max_body) : true\n\nvar int last_trade_time = 0\nms_since = time - last_trade_time\nisCooldown = ms_since >= (cooldown_min * 60 * 1000)\n\n// ==========================================\n// 6. CRITERIO EXTRA: VELA FLOTANTE\n// ==========================================\ngrp_float = \"Criterio Extra: Vela Flotante en Rango\"\nuse_float_entry = input.bool(true, \"Activar Entrada Flotante\", group=grp_float)\nmax_dist_atr    = input.float(6.0, \"Distancia MÃ¡xima (x ATR)\", minval=0.5, step=0.5, group=grp_float)\n\nsafe_zone_upper = tema_in + (atr_value * max_dist_atr)\nsafe_zone_lower = tema_in - (atr_value * max_dist_atr)\n\nplot(use_float_entry ? safe_zone_upper : na, \"Limite Max Compra\", color=color.new(color.green, 70), style=plot.style_circles)\nplot(use_float_entry ? safe_zone_lower : na, \"Limite Max Venta\", color=color.new(color.red, 70), style=plot.style_circles)\n\nis_floating_bull = open > tema_in and close > tema_in\nis_floating_bear = open < tema_in and close < tema_in\nin_range_bull = close <= safe_zone_upper\nin_range_bear = close >= safe_zone_lower\n\ntrigger_float_bull = use_float_entry and is_floating_bull and in_range_bull\ntrigger_float_bear = use_float_entry and is_floating_bear and in_range_bear\n\n// ==========================================\n// 7. LÃ“GICA DE ENTRADA COMBINADA\n// ==========================================\n\nis_green_candle = close > open\nis_red_candle   = close < open\n\nbody_midpoint = (open + close) / 2\ntrigger_cross_bull = (open < tema_in and close > tema_in) and (body_midpoint > tema_in)\ntrigger_cross_bear = (open > tema_in and close < tema_in) and (body_midpoint < tema_in)\n\nfinal_trigger_bull = (trigger_cross_bull or trigger_float_bull)\nfinal_trigger_bear = (trigger_cross_bear or trigger_float_bear)\n\n// NOTA: canTradeTime ahora ya incluye la lÃ³gica de \"LÃ­mite de operaciones\"\nlong_condition  = final_trigger_bull and canTradeTime and isCandleValid and isCooldown and isAdxValid and is_green_candle\nshort_condition = final_trigger_bear and canTradeTime and isCandleValid and isCooldown and isAdxValid and is_red_candle\n\n// ==========================================\n// 8. EJECUCIÃ“N\n// ==========================================\n\nvar float entry_atr = na\n\nif long_condition\n    strategy.entry(\"Long\", strategy.long)\n    last_trade_time := time\n    entry_atr := atr_value\n    // INCREMENTAR CONTADORES SEGÃšN SESIÃ“N ACTIVA\n    if inSessionA\n        count_A += 1\n    if inSessionB\n        count_B += 1\n    if inSessionC\n        count_C += 1\n    if inSessionD\n        count_D += 1\n\nif short_condition\n    strategy.entry(\"Short\", strategy.short)\n    last_trade_time := time\n    entry_atr := atr_value\n    // INCREMENTAR CONTADORES\n    if inSessionA\n        count_A += 1\n    if inSessionB\n        count_B += 1\n    if inSessionC\n        count_C += 1\n    if inSessionD\n        count_D += 1\n\n// --- SALIDAS ---\n\nif strategy.position_size > 0 // LONG\n    float fixed_sl_price = use_fixed_sl ? (strategy.position_avg_price - (entry_atr * sl_atr_mult)) : na\n    float fixed_tp_price = strategy.position_avg_price + (entry_atr * rr_ratio)\n    \n    float final_stop = na\n    if use_fixed_sl and use_tema_exit\n        final_stop := math.max(fixed_sl_price, tema_out)\n    else if use_fixed_sl\n        final_stop := fixed_sl_price\n    else if use_tema_exit\n        final_stop := tema_out\n        \n    strategy.exit(\"Exit Long\", \"Long\", stop=final_stop, limit=fixed_tp_price, comment_loss=\"Stop/TEMA\", comment_profit=\"Target\")\n\nif strategy.position_size < 0 // SHORT\n    float fixed_sl_price = use_fixed_sl ? (strategy.position_avg_price + (entry_atr * sl_atr_mult)) : na\n    float fixed_tp_price = strategy.position_avg_price - (entry_atr * rr_ratio)\n    \n    float final_stop = na\n    if use_fixed_sl and use_tema_exit\n        final_stop := math.min(fixed_sl_price, tema_out)\n    else if use_fixed_sl\n        final_stop := fixed_sl_price\n    else if use_tema_exit\n        final_stop := tema_out\n        \n    strategy.exit(\"Exit Short\", \"Short\", stop=final_stop, limit=fixed_tp_price, comment_loss=\"Stop/TEMA\", comment_profit=\"Target\")\n\n// Debug status\nplot(adx_value, \"Valor ADX\", color=color.new(color.gray, 70), display=display.status_line)\n// Opcional: Mostrar contador en tabla para depuraciÃ³n\nvar table info = table.new(position.bottom_right, 2, 2)\nif barstate.islast\n    table.cell(info, 0, 0, \"Ops SesiÃ³n A\", bgcolor=color.black, text_color=color.white)\n    table.cell(info, 1, 0, str.tostring(count_A) + \" / \" + str.tostring(max_ops_per_sess), bgcolor=color.black, text_color=color.white)"
  },
  {
    "url": "DwtKbtoi",
    "name": "Double MOST with Pivot and EMA",
    "description": "MOST Long Strategy with Multi-Filter Confirmation (Pivot + VAR Trend Filter) \nThis strategy combines a custom MOST stop-line structure with a moving average trend filter (EMA / VAR / ZLMA), daily pivot levels, and a 9-period VAR filter to generate clean long-only entries.\nIt aims to capture early trend continuations while avoiding reversals and false breakouts.\n\nâœ” Buy Conditions\n\nA long position is opened only if all of the conditions below occur simultaneously:\n\nMA (ort) > MOST Line (s2)\nâ€“ Confirms that momentum is on the long side.\n\nPrice > Daily Pivot (pvt_gun)\nâ€“ Ensures the market is trading above the dayâ€™s fair-value level.\n\nPrice > VAR(9)\nâ€“ Short-term VAR filter to confirm trend strength and reduce noise.\n\nOnly the first bar where all conditions turn true generates a position.\n\nâœ” Sell Condition\n\nA long position is closed when:\n\nMOST Line (s2) crosses above MA (ort)\nâ€“ Indicates a momentum shift against the long position.\n\nâœ” Execution Style (MetaStock-like)\n\nStrategy operates long-only\n\nOrders are filled on the next bar open, not on the signal bar\n\nCommission: 0.03% (3 bps / on-binde 3)\n\nPosition size: 100% of equity per trade\n\nThis makes the behavior comparable to classical MetaStock backtesting logic.\n\nâœ” Chart Markers\n\nOnly actual trade entries and exits are drawn\n\nNo repeated signals or overlapping markers\n\nClean visual trade history\n\nPurpose\n\nThis strategy is ideal for traders who want:\n\nA structured long-only trend model\n\nA multi-layer confirmation filter\n\nClean execution without repaint\n\nHigh-quality entries above market structure levels\n\n\n\n\n\n",
    "image_url": "DwtKbtoi",
    "author": "algotrader06",
    "likes": 447,
    "type": "strategy",
    "created": "2025-11-29",
    "updated": "2025-11-29",
    "source": "//@version=5\nstrategy(\"MOST Long â€“ ort>s2 & C>Pivot & C>VAR9, Sell: s2>ort (MetaStock-like, Clean Marks)\",\n     shorttitle=\"MOST Long MS-like Marks\",\n     overlay=true,\n     initial_capital=100000,\n     pyramiding=0,\n     default_qty_type=strategy.percent_of_equity,\n     default_qty_value=100,                 // Her iÅŸlemde %100 sermaye\n     commission_type=strategy.commission.percent,\n     commission_value=0.03)                // %0.03 = on binde 3\n\n//--------------------------------------------------------\n// KAYNAK SEÃ‡Ä°MÄ°\n//--------------------------------------------------------\nsource = input.string(\"close\", \"Source\", options=[\"close\", \"high\", \"low\", \"open\", \"hl2\", \"hlc3\"])\n\nsrc = close\nif source == \"high\"\n    src := high\nelse if source == \"low\"\n    src := low\nelse if source == \"open\"\n    src := open\nelse if source == \"hl2\"\n    src := (high + low) / 2\nelse if source == \"hlc3\"\n    src := (high + low + close) / 3\n\n//--------------------------------------------------------\n// PARAMETRELER\n//--------------------------------------------------------\nmaType = input.string(\"EMA\", \"Moving Average\", options=[\"EMA\", \"VAR\", \"ZLMA\"])\nper    = input.int(10, \"Period\", minval=1)\n\npercent_up   = input.float(4.0, \"Uptrend MOST (%)\", minval=0.1)\npercent_down = input.float(1.0, \"Downtrend MOST (%)\", minval=0.1)\n\n//--------------------------------------------------------\n// MA FONKSÄ°YONLARI (EMA / VAR / ZLMA)\n//--------------------------------------------------------\nvar_ma_calc(_src, _len) =>\n    valpha = 2.0 / (_len + 1.0)\n    vud1 = _src > _src[1] ? _src - _src[1] : 0.0\n    vdd1 = _src < _src[1] ? _src[1] - _src : 0.0\n    vUD = math.sum(vud1, 9)\n    vDD = math.sum(vdd1, 9)\n    vCMO = nz((vUD - vDD) / (vUD + vDD))\n    var float s = na\n    s := valpha * math.abs(vCMO) * _src + (1 - valpha * math.abs(vCMO)) * nz(s[1])\n    s\n\nema_ma(_src, _len) =>\n    ta.ema(_src, _len)\n\nzlma(_src, _len) =>\n    zl = _src + (_src - nz(_src[_len], _src))\n    ta.ema(zl, _len)\n\n//--------------------------------------------------------\n// MA (ort)\n//--------------------------------------------------------\nfloat ort = src\n\nif maType == \"EMA\"\n    ort := ema_ma(src, per)\nelse if maType == \"VAR\"\n    ort := var_ma_calc(src, per)\nelse if maType == \"ZLMA\"\n    ort := zlma(src, per)\n\n//--------------------------------------------------------\n// VAR(9)  â†’ mov(C,9,VAR)\n//--------------------------------------------------------\nvar9 = var_ma_calc(close, 9)\nplot(var9, \"VAR9\", color=color.yellow)\n\n//--------------------------------------------------------\n// MOST (s2)\n//--------------------------------------------------------\ntrendUp = ort > ort[1]\nSL = trendUp ? ort * (percent_up / 100.0) : ort * (percent_down / 100.0)\n\nTrail1 = ort\nvar float s2 = na\n\niff_1 = Trail1 > nz(s2[1], 0.0) ? Trail1 - SL : Trail1 + SL\niff_2 = Trail1 < nz(s2[1], 0.0) and Trail1[1] < nz(s2[1], 0.0) ? math.min(nz(s2[1], 0.0), Trail1 + SL) : iff_1\ns2 := Trail1 > nz(s2[1], 0.0) and Trail1[1] > nz(s2[1], 0.0) ? math.max(nz(s2[1], 0.0), Trail1 - SL) : iff_2\n\n//--------------------------------------------------------\n// GÃœNLÃœK PIVOT (pvt_gun)\n//--------------------------------------------------------\npvt_gun = (ta.valuewhen(timeframe.change(\"D\"), high[1], 0) +\n           ta.valuewhen(timeframe.change(\"D\"), low[1], 0) +\n           ta.valuewhen(timeframe.change(\"D\"), close[1], 0)) / 3\n\nplot(pvt_gun, \"Daily Pivot\", color=color.orange)\n\n//--------------------------------------------------------\n// KOÅžULLAR\n//--------------------------------------------------------\n// ALIM: ort > s2 AND C > pvt_gun AND C > VAR9\nbool buy_cond_now  = (ort > s2) and (close > pvt_gun) and (close > var9)\n// false -> true anÄ±nda sinyal\nbool BuySignal = buy_cond_now and (not buy_cond_now[1])\n\n// SATIÅž: s2 > ort  (ve yine false -> true anÄ±nda)\nbool sell_cond_now  = (s2 > ort)\nbool SellSignal     = sell_cond_now and (not sell_cond_now[1])\n\n//--------------------------------------------------------\n// STRATEJÄ°: LONG ONLY â€“ MetaStock tarzÄ± (next bar open)\n//--------------------------------------------------------\nif BuySignal and strategy.position_size <= 0\n    strategy.entry(\"Long\", strategy.long)\n\nif SellSignal and strategy.position_size > 0\n    strategy.close(\"Long\")\n\n//--------------------------------------------------------\n// PLOTLAR (ort & s2)\n//--------------------------------------------------------\np1 = plot(ort, \"ort (MA)\",   color=color.new(color.blue, 0), linewidth=2)\np2 = plot(s2,  \"s2 (MOST)\",  color=color.new(color.green, 0), linewidth=2)\nfill(p1, p2, color=color.new(color.green, 80))\n\n//--------------------------------------------------------\n// SADECE GERÃ‡EK TRADE AÃ‡/KAPAT NOKTALARINI Ä°ÅžARETLE\n//--------------------------------------------------------\n// Entry: pozisyon 0'dan >0'a Ã§Ä±karsa\nlongEntry = (strategy.position_size > 0) and (strategy.position_size[1] <= 0)\n\n// Exit: pozisyon >0'dan 0'a inerse\nlongExit  = (strategy.position_size == 0) and (strategy.position_size[1] > 0)\n\n// Sadece bu iki noktayÄ± iÅŸaretle\nplotshape(longEntry, \"Entry\", shape.triangleup,   location.belowbar,\n          color=color.new(color.lime, 0), text=\"ENTRY\", size=size.small)\n\nplotshape(longExit,  \"Exit\",  shape.triangledown, location.abovebar,\n          color=color.new(color.red, 0),  text=\"EXIT\",  size=size.small)\n"
  },
  {
    "url": "loLXBJrY-inyerneck-Diaper-Sniper-v16-LOW-VOL-V-CATCHER",
    "name": "inyerneck Diaper Sniper v16 â€” LOW VOL V CATCHER",
    "description": "Diaper Sniper v16 â€” Low-Vol Reversal Hunter\n\nCatches dead-cat bounces and V-shaped reversals on the dayâ€™s biggest losers.\nDesigned for pennies and trash stocks that drop 6 %+ from recent high and snap back on any volume + green candle.\n\nFeatures:\nâ€¢ Tiny green â€œDâ€ = reversal signal\nâ€¢ Works on 1m â†’ daily\nâ€¢ Fully adjustable filters\n\n\nBest on low-float runners that bleed hard and bounce harder.\nUse tiny size â€” it fires a lot.\n\nPublic version â€” code visible. No invite-only on Essential plan.\ndo not alter settings with out first recording defaults.. defaults are quite effective\n2025 build. Test at your own risk. ",
    "image_url": "loLXBJrY",
    "author": "oogabooger",
    "likes": 4,
    "type": "strategy",
    "created": "2025-11-29",
    "updated": "2025-11-29",
    "source": "//@version=5\nstrategy(\"Diaper Sniper v16 â€” LOW VOL V CATCHER\", overlay=true,\n         default_qty_type=strategy.percent_of_equity, default_qty_value=15)\n\n// SETTINGS\nlookback     = input.int(30, \"Lookback bars\")\nminDropPct   = input.float(-6.0, \"Min % drop from high\")\n\n// DROP FROM HIGH (previous bars)\nhighPrev = ta.highest(high[1], lookback)\ndrop     = (close - highPrev) / highPrev * 100\nisDown   = drop <= minDropPct\n\n// VOLUME â€” REMOVED ENTIRELY (catches dead-quiet reversals)\nvolOk    = true\n\n// GREEN CANDLE\ngreen    = close > open\n\n// TRIGGER\ndiaper   = isDown and green\n\nif (diaper)\n    strategy.entry(\"Diaper\", strategy.long)\n\nstrategy.exit(\"DiaperExit\", \"Diaper\", profit=20, loss=8)\n\n// TINY ARROWS\nplotshape(diaper, location=location.belowbar, color=#39ff14, style=shape.triangleup, size=size.tiny, text=\"D\")\n\nalertcondition(diaper, title=\"Diaper Sniper\", message=\"{\\\"content\\\":\\\"ðŸš€ DIAPER V {{ticker}} @ {{close}} | {{interval}}\\\"}\")"
  },
  {
    "url": "neWTQxP2",
    "name": "Classic Wave: The Easy Way",
    "description": "Classic Wave  is a simple strategy with few rules and no over-optimization. Despite its simplicity, it is backed by a nearly century-long historical track record, delivering excellent returns on the weekly chart of the  SPX  (TVC).\n\nI also recommend observing its strong performance on the SPY (weekly), which is the perfect instrument for executing this strategy with futures in the future.\n\n\n Strategy Rules and Parameters \n\nWhen a bullish candle closes above the 20-period EMA, we place the stop-loss below the low of that candle and target a risk-reward ratio of 1:1.\n\nA second, more profitable variant is to change the risk-reward ratio in the code to 2:1.\n\n-Total capital: $10,000  \n\n-We use 10% of the total capital per trade.  \n\n-Commissions: 0.1% per trade.\n\n The code construction is simple and very well detailed within the script itself. \n\n\n Risk-Reward Ratio 2:1 \n\nUsing a 2:1 risk-reward ratio reduces the win rate but significantly increases profitability.\nAcross the full historical data of the SPX index (weekly), the system would have generated 236 trades, with a win rate of 51.27% and a profit factor of 2.53.\n\nFrom January 1, 2023, to November 28, 2025, the system would have generated 5 trades, with an 80% win rate and a profit factor of 9.244.\n\n\n What makes this system so good?   \n\n-It takes advantage of the long-term bullish bias of U.S. stock indices and traditional markets.  \n\n-It filters out a lot of noise thanks to the weekly timeframe.  \n\n-It uses simple parameters with no over-optimization.\n\n\n Final Notes: \n\nThis strategy has consistently outperformed the returns offered by most traditional funds over time, with fewer drawdowns and significantly less stress. I hope you like it.\n\n\n\n",
    "image_url": "neWTQxP2",
    "author": "OldWave96",
    "likes": 44,
    "type": "strategy",
    "created": "2025-11-29",
    "updated": "2025-11-29",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// Â© Especulador96\r\n\r\n//@version=5\r\nstrategy(\"Classic Wave\", overlay=true, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=10, commission_type=strategy.commission.percent, commission_value=0.1)\r\n\r\n// --- 1. Indicator Definitions ---\r\nema20 = ta.ema(close, 20)\r\n\r\n// Plot the EMA\r\nplot(ema20, color=color.blue, linewidth=2, title=\"EMA 20\")\r\n\r\n// --- 2. Entry Conditions ---\r\n// A. Bullish Candle (Close greater than Open)\r\nisBullish = close > open\r\n\r\n// B. Open OR Wick (Low) below the EMA 20\r\nisBelowEMA = open < ema20 or low < ema20\r\n\r\n// C. Close above the EMA 20\r\nisAboveEMA = close > ema20\r\n\r\n// Final Condition: Meets A, B, and C\r\nlongCondition = isBullish and isBelowEMA and isAboveEMA\r\n\r\n// --- 3. Execution and Risk Management ---\r\nif (longCondition)\r\n    // Define prices for SL and TP based on the current candle\r\n    float entryPrice = close\r\n    float stopLossPrice = low\r\n    float risk = entryPrice - stopLossPrice\r\n    float takeProfitPrice = entryPrice + (risk * 1.0) // 1:1 Ratio\r\n\r\n    // Enter the trade (The \"Long\" ID ensures multiple orders don't open on the same candle)\r\n    strategy.entry(\"Long\", strategy.long, comment=\"Entry\")\r\n\r\n    // Configure exit (Fixed SL and TP for this trade)\r\n    strategy.exit(\"Long Exit\", \"Long\", stop=stopLossPrice, limit=takeProfitPrice, comment_loss=\"SL\", comment_profit=\"TP\")\r\n\r\n// --- 4. Signal Visualization ---\r\n// Mark on the chart where the condition is met (green triangle)\r\nplotshape(longCondition, style=shape.triangleup, location=location.belowbar, color=color.green, size=size.small, title=\"Long Signal\")"
  },
  {
    "url": "WhIdFnDO",
    "name": "Trend Breakout & Ratchet Stop System [Market Filter]",
    "description": "Description:\n\nThis strategy implements a robust trend-following system designed to capture momentum moves while strictly managing downside risk through a multi-stage \"Ratchet\" exit mechanism and broad market filters.\n\nIt is designed for swing traders who want to align individual stock entries with the overall market direction.\n\nHow it works:\n\n1. Market Regime Filters (The \"Safety Check\") Before taking any position, the strategy checks the health of the broader market to avoid \"catching falling knives.\"\n\nBroad Market Filter: By default, it checks NASDAQ:QQQ (adjustable). If the benchmark is trading below its SMA 200, the strategy assumes a Bear Market and suppresses all new long entries.\n\nVolatility Filter (VIX): Uses CBOE:VIX to gauge fear. If the VIX is above a specific threshold (Default: 32), entries are paused, and existing positions can optionally be closed to preserve capital.\n\n2. Entry Logic Entries are based on Momentum and Trend confirmation. A position is opened if filters are clear AND one of the following occurs:\n\nGolden Cross: SMA 25 crosses over SMA 50.\n\nSMA Breakouts: A \"Three-Bar-Break\" logic confirms a breakout above the SMA 50, 100, or 200 (price must establish itself above the moving average).\n\n3. The \"Ratchet\" Exit System The exit logic evolves as the trade progresses, tightening risk like a ratchet:\n\nStage 0 (Initial Risk): Starts with a standard percentage Stop Loss from the entry price.\n\nStage 1 (Breakeven/Lock): Once the price rises by Profit Step 1 (e.g., +10%), the Stop Loss jumps to a tighter level and locks there. This secures the initial move.\n\nStage 2 (Trailing Mode): If the price continues to rise to Profit Step 2 (e.g., +15%), the Stop Loss converts into a dynamic Trailing Stop relative to the Highest High. This allows the trade to run as long as the trend persists.\n\nAdditional Exits:\n\nDead Cross: Closes position if SMA 25 crosses under SMA 50.\n\nVIX Panic: Emergency exit if volatility spikes above the threshold.\n\nSettings & Customization:\n\nSMAs: Adjustable lengths for all Moving Averages.\n\nFilters: Toggle Market/VIX filters on/off and choose your benchmark ticker (e.g., SPY or QQQ).\n\nRisk Management: Fully customizable percentages for the Ratchet steps (Initial SL, Stage 1 Trigger, Trailing distance).",
    "image_url": "WhIdFnDO",
    "author": "oppliger79",
    "likes": 5,
    "type": "strategy",
    "created": "2025-11-29",
    "updated": "2025-11-29",
    "source": "//@version=6\r\nstrategy(\"Ratchet Exit Strategy + Market Filter\", \r\n     overlay = true, \r\n     initial_capital = 10000, \r\n     default_qty_type = strategy.percent_of_equity, \r\n     default_qty_value = 100, \r\n     pyramiding = 1, \r\n     commission_type = strategy.commission.percent, \r\n     commission_value = 0.1,\r\n     currency = currency.USD)\r\n\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// 1. Inputs\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nsma25Len  = input.int(25,  \"SMA 25 (Momentum)\", group=\"SMAs\")\r\nsma50Len  = input.int(50,  \"SMA 50 (Trend)\",    group=\"SMAs\")\r\nsma100Len = input.int(100, \"SMA 100 (Medium)\",  group=\"SMAs\")\r\nsma200Len = input.int(200, \"SMA 200 (Long)\",    group=\"SMAs\")\r\n\r\n// ðŸ›¡ï¸ NEU: Market Filter Inputs\r\ngroup_filter = \"ðŸ›¡ï¸ Market Regime Filter\"\r\nuseMarketFilter = input.bool(true, \"Nur handeln wenn Index > SMA200?\", group=group_filter, tooltip=\"SchÃ¼tzt vor BÃ¤renmÃ¤rkten. Handelt nur, wenn der breite Markt steigt.\")\r\nmarketTicker    = input.symbol(\"NASDAQ:QQQ\", \"Markt-Referenz (z.B. QQQ)\", group=group_filter)\r\n\r\n// VIX Filter Inputs\r\ngroup_vix = \"VIX Filter\"\r\nuseVixFilter = input.bool(true, \"VIX Filter aktivieren?\", group=group_vix)\r\nvixThreshold = input.float(32.0, \"VIX Schwellenwert\", group=group_vix)\r\n\r\n// Exit Einstellungen\r\ngroup_exit    = \"Exit Logic (Ratchet System)\"\r\nslInitialPerc = input.float(10.0, \"Initial Stop Loss %\",        group=group_exit)\r\nprofitStep1   = input.float(10.0, \"Trigger fÃ¼r Stufe 1 (+%)\",   group=group_exit)\r\nslStep1Perc   = input.float(8.0,  \"Abstand Stufe 1 (%)\",  group=group_exit)\r\nprofitStep2   = input.float(15.0, \"Trigger fÃ¼r Stufe 2 (+%)\",   group=group_exit)\r\ntrailPerc     = input.float(8.0,  \"Trailing Abstand (%)\",       group=group_exit)\r\n\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// 2. Datenabruf & Indikatoren\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nvixClose = request.security(\"CBOE:VIX\", \"D\", close)\r\n\r\n// ðŸ›¡ï¸ NEU: Markt-Daten holen & Checken\r\nmarketClose = request.security(marketTicker, \"D\", close)\r\nmarketSMA200 = request.security(marketTicker, \"D\", ta.sma(close, 200))\r\nisBullMarket = (not useMarketFilter) or (marketClose > marketSMA200)\r\n\r\nsma25  = ta.sma(close, sma25Len)\r\nsma50  = ta.sma(close, sma50Len)\r\nsma100 = ta.sma(close, sma100Len)\r\nsma200 = ta.sma(close, sma200Len)\r\n\r\nplot(sma25, \"SMA 25\", color=color.purple)\r\nplot(sma50, \"SMA 50\", color=color.green, linewidth=2)\r\nplot(sma100, \"SMA 100\", color=color.blue)\r\nplot(sma200, \"SMA 200\", color=color.orange, linewidth=2)\r\n\r\n// Market Filter Status im Chart anzeigen (Hintergrundfarbe)\r\nbgcolor(useMarketFilter and not isBullMarket ? color.new(color.red, 90) : na, title=\"Bear Market Filter Active\")\r\n\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// 3. Entry Logik\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nentryCross  = ta.crossover(sma25, sma50)\r\nf_threeBarBreak(float _sma) => close > _sma and close[1] > _sma[1] and close[2] > _sma[2] and close[3] < _sma[3]\r\n\r\nbreakout50  = f_threeBarBreak(sma50)\r\nbreakout100 = f_threeBarBreak(sma100)\r\nbreakout200 = f_threeBarBreak(sma200)\r\n\r\nvixCondition = (not useVixFilter) or (vixClose < vixThreshold)\r\n\r\n// ðŸ›¡ï¸ COMBINED CONDITION: VIX ok AND Market ok\r\nif vixCondition and isBullMarket\r\n    if entryCross\r\n        strategy.entry(\"Long\", strategy.long, comment=\"Entry: 25x50\")\r\n    if breakout50\r\n        strategy.entry(\"Long\", strategy.long, comment=\"Entry: SMA50\")\r\n    if breakout100\r\n        strategy.entry(\"Long\", strategy.long, comment=\"Entry: SMA100\")\r\n    if breakout200\r\n        strategy.entry(\"Long\", strategy.long, comment=\"Entry: SMA200\")\r\n\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// 4. Exits (Panic & Ratchet)\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n\r\n// VIX Panic\r\nif useVixFilter and vixClose > vixThreshold\r\n    strategy.close_all(comment = \"VIX Panic Exit\")\r\n\r\n// OPTIONAL: Market Panic Exit (Wenn Markt unter SMA200 fÃ¤llt, alles verkaufen?)\r\n// Aktuell deaktiviert, da wir Trades oft noch auslaufen lassen wollen. \r\n// Entkommentieren fÃ¼r maximalen Schutz:\r\n// if useMarketFilter and marketClose < marketSMA200\r\n//     strategy.close_all(comment = \"Market Regime Exit\")\r\n\r\n// Ratchet Logic (Stage 1 Dynamic Version)\r\nvar int exitStage = 0         \r\nvar float activeStopPrice = 0.0 \r\nvar float highestHigh = 0.0    \r\nvar float stage1RefPrice = 0.0\r\nfloat plotStop = na\r\n\r\nif strategy.position_size == 0\r\n    exitStage := 0\r\n    activeStopPrice := 0.0\r\n    highestHigh := 0.0\r\n    stage1RefPrice := 0.0\r\n\r\nif strategy.position_size > 0\r\n    float avgEntry = strategy.position_avg_price\r\n    float currentProfitPerc = (close - avgEntry) / avgEntry * 100.0\r\n    \r\n    if highestHigh == 0.0\r\n        highestHigh := high\r\n    else\r\n        highestHigh := math.max(highestHigh, high)\r\n\r\n    if exitStage < 1 and currentProfitPerc >= profitStep1\r\n        exitStage := 1 \r\n        stage1RefPrice := close \r\n    \r\n    if exitStage < 2 and currentProfitPerc >= profitStep2\r\n        exitStage := 2\r\n\r\n    float potentialStop = 0.0\r\n    string commentText = \"\"\r\n\r\n    if exitStage == 0\r\n        potentialStop = avgEntry * (1 - slInitialPerc / 100.0)\r\n        commentText := \"Initial Stop\"\r\n    else if exitStage == 1\r\n        potentialStop = stage1RefPrice * (1 - slStep1Perc / 100.0)\r\n        commentText := \"Locked Stage 1\"\r\n    else if exitStage == 2\r\n        potentialStop = highestHigh * (1 - trailPerc / 100.0)\r\n        commentText := \"Trailing\"\r\n\r\n    if strategy.position_size[1] == 0\r\n        activeStopPrice := potentialStop\r\n    else\r\n        activeStopPrice := math.max(activeStopPrice, potentialStop)\r\n\r\n    plotStop := activeStopPrice\r\n    strategy.exit(\"Ratchet Exit\", stop = activeStopPrice, comment_loss = commentText)\r\n\r\nif ta.crossunder(sma25, sma50)\r\n    strategy.close_all(comment = \"Dead Cross\")\r\n\r\nplot(plotStop, \"Active Stop Loss\", color=color.red, style=plot.style_linebr, linewidth=2)"
  },
  {
    "url": "GhXRMe27",
    "name": "Dynamic Ratchet Trend Strategy [VIX Filter]",
    "description": "Overview This strategy is a long-only trend-following system designed to capture major market moves while strictly managing downside risk through a state-machine based \"Ratchet\" exit logic. It incorporates a volatility filter using the CBOE VIX index to stay out of (or exit) the market during high-stress environments.\n\nKey Features\n\n1. Multi-Condition Entries The strategy looks for momentum shifts and trend breakouts using four Simple Moving Averages (25, 50, 100, 200).\n\nMomentum Cross: SMA 25 crossover above SMA 50.\n\nTrend Breakouts: A specific \"3-Bar Breakout\" logic above the SMA 50, 100, or 200. This requires the price to hold above the SMA for 3 consecutive bars after being below it, reducing false signals compared to simple closes.\n\n2. VIX Volatility Filter Before entering any trade, the script checks the CBOE:VIX.\n\nFilter: If VIX is above the threshold (default 32), new entries are blocked.\n\nPanic Exit: If you are in a position and the VIX spikes above the threshold, the strategy executes an immediate \"Panic Exit\" to preserve capital during market crashes.\n\n3. The \"Ratchet\" Exit System (3 Stages) Unlike a standard trailing stop, this strategy uses a 3-stage dynamic exit mechanism that tightens as profits grow:\n\nStage 0 (Initial Risk): Standard percentage-based Stop Loss from the entry price.\n\nStage 1 (The Lock-In): Triggered when profit hits 10% (configurable).\n\nUnique Logic: Instead of trailing from the highest high, the stop is calculated based on the price at the exact moment this stage was triggered. It \"steps up\" once and holds, securing the initial move without being prematurely stopped out by normal volatility.\n\nStage 2 (Trailing Mode): Triggered when profit hits 15% (configurable).\n\nThe strategy switches to a classic Trailing Stop, following the percentage distance from the Highest High.\n\n4. Emergency Backup A \"Dead Cross\" (SMA 25 crossing under SMA 50) acts as a final fail-safe to close positions if the trend reverses completely before hitting a stop.\n\nSettings & Inputs\n\nSMAs: Customize the lengths for all four moving averages.\n\nVIX Filter: Toggle the filter on/off and set the panic threshold.\n\nExit Logic: Fully customizable percentages for Initial SL, Stage 1 Trigger/Distance, and Stage 2 Trigger/Trailing Distance.\n\nDisclaimer This script is for educational purposes only. Past performance is not indicative of future results. Always manage your risk appropriately.",
    "image_url": "GhXRMe27",
    "author": "oppliger79",
    "likes": 5,
    "type": "strategy",
    "created": "2025-11-29",
    "updated": "2025-11-29",
    "source": "//@version=6\r\nstrategy(\"Ratchet Exit Trend Strategy with VIX Filter (Stage 1 Dynamic)\", \r\n     overlay = true, \r\n     initial_capital = 10000, \r\n     default_qty_type = strategy.percent_of_equity, \r\n     default_qty_value = 100, \r\n     pyramiding = 1, \r\n     commission_type = strategy.commission.percent, \r\n     commission_value = 0.1,\r\n     currency = currency.USD)\r\n\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// 1. Inputs\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nsma25Len  = input.int(25,  \"SMA 25 (Momentum)\", group=\"SMAs\")\r\nsma50Len  = input.int(50,  \"SMA 50 (Trend)\",    group=\"SMAs\")\r\nsma100Len = input.int(100, \"SMA 100 (Medium)\",  group=\"SMAs\")\r\nsma200Len = input.int(200, \"SMA 200 (Long)\",    group=\"SMAs\")\r\n\r\n// VIX Filter Inputs\r\ngroup_vix = \"VIX Filter\"\r\nuseVixFilter = input.bool(true, \"VIX Filter aktivieren?\", group=group_vix)\r\nvixThreshold = input.float(32.0, \"VIX Schwellenwert\", group=group_vix, tooltip=\"Kein Entry Ã¼ber diesem Wert. Sofort Exit Ã¼ber diesem Wert.\")\r\n\r\n// Exit Einstellungen\r\ngroup_exit    = \"Exit Logic (Ratchet System)\"\r\nslInitialPerc = input.float(10.0, \"Initial Stop Loss %\",        group=group_exit)\r\nprofitStep1   = input.float(10.0, \"Trigger fÃ¼r Stufe 1 (+%)\",   group=group_exit)\r\nslStep1Perc   = input.float(8.0,  \"Abstand Stufe 1 (%)\",  group=group_exit, tooltip=\"Abstand vom Kurs zum Zeitpunkt des Erreichens von Stufe 1\")\r\nprofitStep2   = input.float(15.0, \"Trigger fÃ¼r Stufe 2 (+%)\",   group=group_exit)\r\ntrailPerc     = input.float(8.0,  \"Trailing Abstand (%)\",       group=group_exit)\r\n\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// 2. Datenabruf & Indikatoren\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nvixClose = request.security(\"CBOE:VIX\", \"D\", close)\r\n\r\nsma25  = ta.sma(close, sma25Len)\r\nsma50  = ta.sma(close, sma50Len)\r\nsma100 = ta.sma(close, sma100Len)\r\nsma200 = ta.sma(close, sma200Len)\r\n\r\nplot(sma25, \"SMA 25\", color=color.purple)\r\nplot(sma50, \"SMA 50\", color=color.green, linewidth=2)\r\nplot(sma100, \"SMA 100\", color=color.blue)\r\nplot(sma200, \"SMA 200\", color=color.orange, linewidth=2)\r\n\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// 3. Entry Logik\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nentryCross  = ta.crossover(sma25, sma50)\r\nf_threeBarBreak(float _sma) => close > _sma and close[1] > _sma[1] and close[2] > _sma[2] and close[3] < _sma[3]\r\n\r\nbreakout50  = f_threeBarBreak(sma50)\r\nbreakout100 = f_threeBarBreak(sma100)\r\nbreakout200 = f_threeBarBreak(sma200)\r\n\r\nvixCondition = (not useVixFilter) or (vixClose < vixThreshold)\r\n\r\nif vixCondition\r\n    if entryCross\r\n        strategy.entry(\"Long\", strategy.long, comment=\"Entry: 25x50\")\r\n    if breakout50\r\n        strategy.entry(\"Long\", strategy.long, comment=\"Entry: SMA50\")\r\n    if breakout100\r\n        strategy.entry(\"Long\", strategy.long, comment=\"Entry: SMA100\")\r\n    if breakout200\r\n        strategy.entry(\"Long\", strategy.long, comment=\"Entry: SMA200\")\r\n\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// 4. VIX PANIC EXIT\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nif useVixFilter and vixClose > vixThreshold\r\n    strategy.close_all(comment = \"VIX Panic Exit (> \" + str.tostring(vixThreshold) + \")\")\r\n\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// 5. STATE MACHINE EXIT LOGIK (Ratchet - MODIFIZIERT)\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n\r\nvar int exitStage = 0         \r\nvar float activeStopPrice = 0.0 \r\nvar float highestHigh = 0.0    \r\n// NEU: Variable um den Preis beim Erreichen von Stufe 1 zu speichern\r\nvar float stage1RefPrice = 0.0\r\n\r\nfloat plotStop = na\r\n\r\n// RESET-LOGIK\r\nif strategy.position_size == 0\r\n    exitStage := 0\r\n    activeStopPrice := 0.0\r\n    highestHigh := 0.0\r\n    stage1RefPrice := 0.0 // Reset der neuen Variable\r\n\r\n// TRADE-LOGIK\r\nif strategy.position_size > 0\r\n    float avgEntry = strategy.position_avg_price\r\n    float currentProfitPerc = (close - avgEntry) / avgEntry * 100.0\r\n    \r\n    // Highest High tracking\r\n    if highestHigh == 0.0\r\n        highestHigh := high\r\n    else\r\n        highestHigh := math.max(highestHigh, high)\r\n\r\n    // STUFEN-LOGIK\r\n    \r\n    // Check auf Stufe 1\r\n    if exitStage < 1 and currentProfitPerc >= profitStep1\r\n        exitStage := 1 \r\n        stage1RefPrice := close // WICHTIG: Wir merken uns den aktuellen Kurs beim Eintritt!\r\n    \r\n    // Check auf Stufe 2\r\n    if exitStage < 2 and currentProfitPerc >= profitStep2\r\n        exitStage := 2\r\n\r\n    // STOP-BERECHNUNG\r\n    float potentialStop = 0.0\r\n    string commentText = \"\"\r\n\r\n    if exitStage == 0\r\n        // Stufe 0: Initialer Hard Stop vom Entry\r\n        potentialStop = avgEntry * (1 - slInitialPerc / 100.0)\r\n        commentText := \"Initial Stop\"\r\n        \r\n    else if exitStage == 1\r\n        // Stufe 1: Fixiert auf \"Kurs bei Eintritt in Stufe 1\" minus X%\r\n        // HIER IST DIE Ã„NDERUNG:\r\n        potentialStop = stage1RefPrice * (1 - slStep1Perc / 100.0)\r\n        commentText := \"Locked Stage 1\"\r\n        \r\n    else if exitStage == 2\r\n        // Stufe 2: Trailing Stop\r\n        potentialStop = highestHigh * (1 - trailPerc / 100.0)\r\n        commentText := \"Trailing\"\r\n\r\n    // RATCHET (Stop darf nur steigen)\r\n    if strategy.position_size[1] == 0\r\n        activeStopPrice := potentialStop\r\n    else\r\n        activeStopPrice := math.max(activeStopPrice, potentialStop)\r\n\r\n    plotStop := activeStopPrice\r\n    strategy.exit(\"Ratchet Exit\", stop = activeStopPrice, comment_loss = commentText)\r\n\r\n// Dead Cross Backup\r\nif ta.crossunder(sma25, sma50)\r\n    strategy.close_all(comment = \"Dead Cross\")\r\n\r\nplot(plotStop, \"Active Stop Loss\", color=color.red, style=plot.style_linebr, linewidth=2)"
  },
  {
    "url": "Igdwn5DT",
    "name": "Ratchet Exit Trend Strategy with VIX Filter",
    "description": "This strategy is a trend-following system designed specifically for volatile markets. Instead of focusing solely on the \"perfect entry,\" this script emphasizes intelligent trade management using a custom **\"Ratchet Exit System.\"**\n\nAdditionally, it integrates a volatility filter based on the CBOE Volatility Index (VIX) to minimize risk during extreme market phases.\n\n### ðŸŽ¯ The Concept: Ratchet Exit\nThe \"Ratchet\" system operates like a mechanical ratchet tool: the Stop Loss can only move in one direction (up, for long trades) and \"locks\" into specific stages. The goal is to give the trade \"room to breathe\" initially to avoid being stopped out by noise, then aggressively reduce risk as the trade moves into profit.\n\nThe exit logic moves through 3 distinct phases:\n\n1.  **Phase 0 (Initial Risk):** At the start of the trade, a wide Stop Loss is set (Default: 10%) to tolerate normal market volatility.\n2.  **Phase 1 (Risk Reduction):** Once the trade reaches a specific floating profit (Default: +10%), the Stop Loss is raised and \"pinned\" to a fixed value (Default: -8% from entry). This drastically reduces risk while keeping the trade alive.\n3.  **Phase 2 (Trailing Mode):** If the trend extends to a higher profit zone (Default: +15%), the Stop switches to a dynamic Trailing Mode. It follows the **Highest High** at a fixed percentage distance (Default: 8%).\n\n### ðŸ›¡ï¸ VIX Filter & Panic Exit\nHigh volatility is often the enemy of trend-following strategies.\n* **Entry Filter:** The system will not enter new positions if the VIX is above a user-defined threshold (Default: 32). This helps avoid entering \"falling knife\" markets.\n* **Panic Exit:** If the VIX spikes above the threshold (32) while a trade is open, the position is closed immediately to protect capital (Emergency Exit).\n\n### ðŸ“ˆ Entry Signals\nThe strategy trades **LONG only** and uses Simple Moving Averages (SMAs) to identify trends:\n* **Golden Cross:** SMA 25 crosses over SMA 50.\n* **3-Bar Breakouts:** A confirmation logic where the price must close above the SMA 50, 100, or 200 for 3 consecutive bars.\n\n### âš™ï¸ Settings (Inputs)\nAll parameters are fully customizable via the settings menu:\n* **SMAs:** Lengths for the trend indicators (Default: 25, 50, 100, 200).\n* **VIX Filter:** Toggle the filter on/off and adjust the panic threshold.\n* **Ratchet Settings:** Percentages for Initial Stop, Trigger Levels for Stages 1 & 2, and the Trailing Distance.\n\n### âš ï¸ Technical Note & Risk Warning\nThis script uses `request.security` to fetch VIX data. Please ensure you understand the risks associated with trading leveraged or volatile assets. Past performance is not indicative of future results.",
    "image_url": "Igdwn5DT",
    "author": "oppliger79",
    "likes": 3,
    "type": "strategy",
    "created": "2025-11-29",
    "updated": "2025-11-29",
    "source": "//@version=6\r\nstrategy(\"Ratchet Exit Trend Strategy with VIX Filter\", \r\n     overlay = true, \r\n     initial_capital = 10000, \r\n     default_qty_type = strategy.percent_of_equity, \r\n     default_qty_value = 100, \r\n     pyramiding = 1, \r\n     commission_type = strategy.commission.percent, \r\n     commission_value = 0.1,\r\n     currency = currency.USD)\r\n\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// 1. Inputs\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nsma25Len  = input.int(25,  \"SMA 25 (Momentum)\", group=\"SMAs\")\r\nsma50Len  = input.int(50,  \"SMA 50 (Trend)\",    group=\"SMAs\")\r\nsma100Len = input.int(100, \"SMA 100 (Medium)\",  group=\"SMAs\")\r\nsma200Len = input.int(200, \"SMA 200 (Long)\",    group=\"SMAs\")\r\n\r\n// VIX Filter Inputs\r\ngroup_vix = \"VIX Filter\"\r\nuseVixFilter = input.bool(true, \"VIX Filter aktivieren?\", group=group_vix)\r\nvixThreshold = input.float(32.0, \"VIX Schwellenwert\", group=group_vix, tooltip=\"Kein Entry Ã¼ber diesem Wert. Sofort Exit Ã¼ber diesem Wert.\")\r\n\r\n// Exit Einstellungen\r\ngroup_exit    = \"Exit Logic (Ratchet System)\"\r\nslInitialPerc = input.float(10.0, \"Initial Stop Loss %\",        group=group_exit)\r\nprofitStep1   = input.float(10.0, \"Trigger fÃ¼r Stufe 1 (+%)\",   group=group_exit)\r\nslStep1Perc   = input.float(8.0,  \"Fixierter SL Stufe 1 (-%)\",  group=group_exit)\r\nprofitStep2   = input.float(15.0, \"Trigger fÃ¼r Stufe 2 (+%)\",   group=group_exit)\r\ntrailPerc     = input.float(8.0,  \"Trailing Abstand (%)\",       group=group_exit)\r\n\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// 2. Datenabruf & Indikatoren\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// VIX Daten holen (Tagesbasis ist meist am stabilsten)\r\nvixClose = request.security(\"CBOE:VIX\", \"D\", close)\r\n\r\nsma25  = ta.sma(close, sma25Len)\r\nsma50  = ta.sma(close, sma50Len)\r\nsma100 = ta.sma(close, sma100Len)\r\nsma200 = ta.sma(close, sma200Len)\r\n\r\nplot(sma25, \"SMA 25\", color=color.purple)\r\nplot(sma50, \"SMA 50\", color=color.green, linewidth=2)\r\nplot(sma100, \"SMA 100\", color=color.blue)\r\nplot(sma200, \"SMA 200\", color=color.orange, linewidth=2)\r\n\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// 3. Entry Logik\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nentryCross  = ta.crossover(sma25, sma50)\r\nf_threeBarBreak(float _sma) => close > _sma and close[1] > _sma[1] and close[2] > _sma[2] and close[3] < _sma[3]\r\n\r\nbreakout50  = f_threeBarBreak(sma50)\r\nbreakout100 = f_threeBarBreak(sma100)\r\nbreakout200 = f_threeBarBreak(sma200)\r\n\r\n// VIX Bedingung: Ist der VIX OK? (Kleiner als Threshold ODER Filter deaktiviert)\r\nvixCondition = (not useVixFilter) or (vixClose < vixThreshold)\r\n\r\n// Entries nur ausfÃ¼hren, wenn VIX Bedingung erfÃ¼llt ist\r\nif vixCondition\r\n    if entryCross\r\n        strategy.entry(\"Long\", strategy.long, comment=\"Entry: 25x50\")\r\n    if breakout50\r\n        strategy.entry(\"Long\", strategy.long, comment=\"Entry: SMA50\")\r\n    if breakout100\r\n        strategy.entry(\"Long\", strategy.long, comment=\"Entry: SMA100\")\r\n    if breakout200\r\n        strategy.entry(\"Long\", strategy.long, comment=\"Entry: SMA200\")\r\n\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// 4. VIX PANIC EXIT\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Wenn VIX zu hoch ist, sofort raus (Hard Exit)\r\nif useVixFilter and vixClose > vixThreshold\r\n    strategy.close_all(comment = \"VIX Panic Exit (> \" + str.tostring(vixThreshold) + \")\")\r\n\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// 5. STATE MACHINE EXIT LOGIK (Ratchet)\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// (Wird nur ausgefÃ¼hrt, wenn wir nicht gerade durch den VIX Panic Exit geschlossen wurden)\r\n\r\nvar int exitStage = 0         \r\nvar float activeStopPrice = 0.0 \r\nvar float highestHigh = 0.0    \r\nfloat plotStop = na\r\n\r\nif strategy.position_size == 0\r\n    exitStage := 0\r\n    activeStopPrice := 0.0\r\n    highestHigh := 0.0\r\n\r\nif strategy.position_size > 0\r\n    float avgEntry = strategy.position_avg_price\r\n    float currentProfitPerc = (close - avgEntry) / avgEntry * 100.0\r\n    \r\n    if highestHigh == 0.0\r\n        highestHigh := high\r\n    else\r\n        highestHigh := math.max(highestHigh, high)\r\n\r\n    if exitStage < 1 and currentProfitPerc >= profitStep1\r\n        exitStage := 1 \r\n    \r\n    if exitStage < 2 and currentProfitPerc >= profitStep2\r\n        exitStage := 2\r\n\r\n    float potentialStop = 0.0\r\n    string commentText = \"\"\r\n\r\n    if exitStage == 0\r\n        potentialStop = avgEntry * (1 - slInitialPerc / 100.0)\r\n        commentText := \"Initial Stop\"\r\n    else if exitStage == 1\r\n        potentialStop = avgEntry * (1 - slStep1Perc / 100.0)\r\n        commentText := \"Secured (-8%)\"\r\n    else if exitStage == 2\r\n        potentialStop = highestHigh * (1 - trailPerc / 100.0)\r\n        commentText := \"Trailing\"\r\n\r\n    if strategy.position_size[1] == 0\r\n        activeStopPrice := potentialStop\r\n    else\r\n        activeStopPrice := math.max(activeStopPrice, potentialStop)\r\n\r\n    plotStop := activeStopPrice\r\n    strategy.exit(\"Ratchet Exit\", stop = activeStopPrice, comment_loss = commentText)\r\n\r\n// Dead Cross Backup\r\nif ta.crossunder(sma25, sma50)\r\n    strategy.close_all(comment = \"Dead Cross\")\r\n\r\nplot(plotStop, \"Active Stop Loss\", color=color.red, style=plot.style_linebr, linewidth=2)"
  },
  {
    "url": "E7my5YvE",
    "name": "Best Entry Swing MASTER v3 PUBLIC (S.S)",
    "description": "Strategy Description (English)\nBest Entry Swing MASTER v3 â€“ Quality Mode\n\nThe Best Entry Swing MASTER v3 is a structured swing trading and trend-following strategy designed to identify high-probability long and short entries during directional markets.\nIt combines three core setup types commonly used by momentum and breakout traders:\n\nBreakout (BO)\n\nPullback Reversal (PB)\n\nVolatility Contraction Pattern (VCP)\n\nThe strategy applies multiple layers of confirmation, including multi-EMA trend structure, volatility contraction, volume filters, and an optional market regime filter.\nIt is suitable for swing trading on higher timeframes (4H, Daily), as well as medium-term trend continuation setups.\n\nCore Concepts\n1. Trend Structure\n\nA trend is considered valid when:\n\nUptrend: Price > EMA20 > EMA50 > EMA100\n\nDowntrend: Price < EMA20 < EMA50 < EMA100\n\nIn addition, a simple but effective trend-strength metric is calculated using the percentage spread between EMA20 and EMA100.\nThis helps avoid signals during sideways or low-volatility environments.\n\n2. Market Regime Filter\n\nThe market environment is determined using a higher timeframe benchmark (default: SPY on Daily).\n\nOnly long trades are allowed in bullish market conditions\n\nOnly short trades in bearish conditions\n\nThis significantly reduces false signals in counter-trend conditions.\n\nEntry Logic\nBreakout (BO)\n\nA long breakout triggers when:\n\nPrice closes above the highest high of the lookback period\n\nVolume exceeds its 20-period average\n\nTrend and market regime confirm\n\n(Optional A+ mode): true volatility contraction is required\n\nSimilar logic applies for short breakdowns.\n\nPullback (PB)\n\nA pullback entry triggers after:\n\nAt least two corrective candles\n\nA strong reversal candle (close above previous high for long)\n\nVolume confirmation\n\nPrice interacts with EMA20\n\nThis structure models classical trend-reentry conditions.\n\nVolatility Contraction Pattern (VCP)\n\nA VCP entry triggers when:\n\nTrue range contracts over multiple bars\n\nPrice holds near the breakout zone\n\nVolume contracts\n\nTrend and market regime are aligned\n\nThis setup aims to capture explosive continuation moves.\n\nQuality Modes\n\nThe strategy offers two modes:\n\nBalanced Mode\n\nModerate signal frequency\n\nBroader trend-strength allowance\n\nSuitable for more active traders\n\nA+ Only Mode\n\nStrict confirmation requirements\n\nOnly high-quality setups with multiple confluences\n\nDesigned to avoid low-probability trades entirely\n\nRisk Management\n\nRisk is managed using an ATR-based stop and target:\n\nLong SL = Close âˆ’ ATR Ã— 1.5\n\nLong TP = Close + ATR Ã— 3\n\n(Equivalent logic for short positions)\n\nThis provides a balanced reward-to-risk profile and avoids overly tight stops.\n\nEarly Entry Signals (Optional)\n\nThe script offers optional â€œEarly Entryâ€ markers that highlight when a setup is forming but not yet confirmed.\nThese are not entry signals and are disabled by default for public use.\n\nIntended Use\n\nThis strategy is designed for:\n\nSwing trading\n\nMomentum continuation\n\nTrend-following\n\nMulti-day to multi-week trades\n\nIt performs best on:\n\n4H\n\nDaily\n\nHigh-liquidity equities, indices, and futures\n\nDisclaimer\n\nThis script is intended for educational and research purposes.\nPast performance does not guarantee future results.\nAlways backtest thoroughly and use appropriate risk management.",
    "image_url": "E7my5YvE",
    "author": "Soeren24",
    "likes": 26,
    "type": "strategy",
    "created": "2025-11-29",
    "updated": "2025-11-29",
    "source": "//@version=5\nstrategy(\"Best Entry Swing MASTER v3 PUBLIC\",\n     overlay = true,\n     initial_capital = 100000,\n     currency = currency.USD,\n     default_qty_type = strategy.percent_of_equity,\n     default_qty_value = 10,\n     pyramiding = 0)\n\n// ======================\n// Input-Gruppen\n// ======================\ngroupTrend  = \"Trend & Markt\"\ngroupLong   = \"Long-Signale\"\ngroupShort  = \"Short-Signale\"\ngroupRisk   = \"Risikomanagement\"\ngroupQual   = \"QualitÃ¤tsmodus\"\ngroupEarly  = \"Early-Entry-Warnungen\"\n\n// ======================\n// QualitÃ¤tsmodus\n// ======================\nqualityMode   = input.string(\"Balanced\", \"QualitÃ¤tsmodus\",\n     options = [\"Balanced\", \"A+ Only\"], group = groupQual)\nstrictQuality = qualityMode == \"A+ Only\"\n\n// ======================\n// Trend & Markt\n// ======================\nemaFastLen = input.int(20,  \"EMA Fast\", group = groupTrend, minval = 2)\nemaMidLen  = input.int(50,  \"EMA Mid\",  group = groupTrend, minval = 2)\nemaSlowLen = input.int(100, \"EMA Slow\", group = groupTrend, minval = 2)\n\nmktSymbol  = input.symbol(\"SPY\", \"Markt-Symbol\",     group = groupTrend)\nmktTf      = input.timeframe(\"D\", \"Markt-Zeiteinheit\", group = groupTrend)\nuseMktLong = input.bool(true,  \"Marktfilter Long benutzen\",  group = groupTrend)\nuseMktShort= input.bool(true,  \"Marktfilter Short benutzen\", group = groupTrend)\n\n// ======================\n// Long-Signale\n// ======================\nlookbackHigh = input.int(20,   \"Breakout Lookback (Long)\",   group = groupLong, minval = 5)\nvolMultHigh  = input.float(1.5,\"Volumen-Multiplikator Long\", group = groupLong, minval = 0.5, step = 0.1)\nuseBOLong    = input.bool(true,\"Breakout (BO) Long aktiv\",   group = groupLong)\nusePBLong    = input.bool(true,\"Pullback (PB) Long aktiv\",   group = groupLong)\nuseVCPLong   = input.bool(true,\"VCP Long aktiv\",             group = groupLong)\n\n// ======================\n// Short-Signale\n// ======================\nlookbackLow  = input.int(20,   \"Breakdown Lookback (Short)\", group = groupShort, minval = 5)\nvolMultLow   = input.float(1.5,\"Volumen-Multiplikator Short\",group = groupShort, minval = 0.5, step = 0.1)\nuseBDShort   = input.bool(true,\"Breakdown (BD) Short aktiv\", group = groupShort)\nusePBShort   = input.bool(true,\"Pullback (PB) Short aktiv\",  group = groupShort)\nuseVCPShort  = input.bool(true,\"VCP Short aktiv\",            group = groupShort)\n\n// ======================\n// Risiko\n// ======================\natrLen      = input.int(14,   \"ATR-LÃ¤nge\",            group = groupRisk, minval = 1)\natrMultSL_L = input.float(1.5,\"SL ATR-Multiple Long\", group = groupRisk, minval = 0.1, step = 0.1)\natrMultTP_L = input.float(3.0,\"TP ATR-Multiple Long\", group = groupRisk, minval = 0.1, step = 0.1)\natrMultSL_S = input.float(1.5,\"SL ATR-Multiple Short\",group = groupRisk, minval = 0.1, step = 0.1)\natrMultTP_S = input.float(3.0,\"TP ATR-Multiple Short\",group = groupRisk, minval = 0.1, step = 0.1)\n\n// ======================\n// Early-Entry (optional)\n// ======================\nshowEarlyWarn = input.bool(false, \"Early-Entry-Warnungen anzeigen\", group = groupEarly)\nnearHighPct   = input.float(2.0, \"NÃ¤he Hoch in % (Pre-BO/VCP Long)\", group = groupEarly, minval = 0.5, step = 0.5)\nnearLowPct    = input.float(2.0, \"NÃ¤he Tief in % (Pre-BD/VCP Short)\",group = groupEarly, minval = 0.5, step = 0.5)\nnearEmaPct    = input.float(0.7, \"NÃ¤he EMA20 in % (Pre-PB)\",         group = groupEarly, minval = 0.1, step = 0.1)\n\n// ======================\n// EMAs, Trend, TrendstÃ¤rke\n// ======================\nemaFast = ta.ema(close, emaFastLen)\nemaMid  = ta.ema(close, emaMidLen)\nemaSlow = ta.ema(close, emaSlowLen)\n\ntrendUp   = close > emaFast and emaFast > emaMid and emaMid > emaSlow\ntrendDown = close < emaFast and emaFast < emaMid and emaMid < emaSlow\n\n// einfache TrendstÃ¤rke Ã¼ber EMA-Abstand in %\nemaSpreadPct  = math.abs(emaFast - emaSlow) / close * 100.0\nspreadLimit   = strictQuality ? 2.0 : 1.0\ntrendStrong   = emaSpreadPct > spreadLimit\n\nplot(emaFast, title = \"EMA Fast\", color = color.new(color.teal,   0))\nplot(emaMid,  title = \"EMA Mid\",  color = color.new(color.orange, 0))\nplot(emaSlow, title = \"EMA Slow\", color = color.new(color.purple, 0))\n\n// ======================\n// Marktfilter\n// ======================\nmktClose = request.security(mktSymbol, mktTf, close)\nmktEma30 = ta.ema(mktClose, 30)\nmktBull  = mktClose > mktEma30\nmktBear  = mktClose < mktEma30\n\nmktLongOK  = useMktLong  ? mktBull : true\nmktShortOK = useMktShort ? mktBear : true\n\nbgcolor(mktBull ? color.new(color.green, 90) : color.new(color.red, 90), title = \"Marktregime\")\n\n// ======================\n// BasisgrÃ¶ÃŸen\n// ======================\nhighestHigh = ta.highest(high[1], lookbackHigh)   // ohne aktuelle Kerze\nlowestLow   = ta.lowest(low[1],  lookbackLow)\navgVol      = ta.sma(volume, 20)\natr         = ta.atr(atrLen)\ntrVal       = ta.tr(true)\n\n// Helper: NÃ¤he in %\nnearPct(price, ref, pct) =>\n    price >= ref * (1.0 - pct / 100.0) and price <= ref * (1.0 + pct / 100.0)\n\n// ======================\n// LONG: BO / PB / VCP\n// ======================\n\n// Breakout Long\nboContraction    = trVal < trVal[1] and trVal[1] < trVal[2]\ncondBO_LongCore  = close > highestHigh and volume > avgVol * volMultHigh\ncondBO_Long      = condBO_LongCore and trendUp and trendStrong and mktLongOK\ncondBO_Long     := strictQuality ? (condBO_Long and boContraction) : condBO_Long\n\nlongBO = useBOLong and condBO_Long\n\nplotshape(longBO, title = \"BO Long\",\n     style = shape.triangleup, location = location.belowbar,\n     size = size.small, color = color.new(color.lime, 0),\n     text = \"BO\", textcolor = color.black)\n\n// Pullback Long\ntwoRedPB      = close[1] < open[1] and close[2] < open[2]\nstrongRebound = close > open and close > high[1]\nvolOK_PB      = volume > (strictQuality ? avgVol * 1.1 : avgVol * 0.9)\n\ncondPB_LongCore = low <= emaFast and twoRedPB and strongRebound and volOK_PB\ncondPB_Long     = condPB_LongCore and trendUp and trendStrong and mktLongOK\n\nlongPB = usePBLong and condPB_Long\n\nplotshape(longPB, title = \"PB Long\",\n     style = shape.circle, location = location.belowbar,\n     size = size.small, color = color.new(color.aqua, 0),\n     text = \"PB\", textcolor = color.black)\n\n// VCP Long\nvcpSeq_Long = trVal < trVal[1] and trVal[1] < trVal[2]\nnearHigh_L  = close >= highestHigh * 0.97\nvolContract = volume < avgVol and volume[1] < avgVol and volume[2] < avgVol\n\ncondVCP_LCore = vcpSeq_Long and nearHigh_L and close > high[1]\ncondVCP_L     = condVCP_LCore and trendUp and trendStrong and mktLongOK\ncondVCP_L    := strictQuality ? (condVCP_L and volContract) : condVCP_L\n\nlongVCP = useVCPLong and condVCP_L\n\nplotshape(longVCP, title = \"VCP Long\",\n     style = shape.flag, location = location.belowbar,\n     size = size.small, color = color.new(color.yellow, 0),\n     text = \"VCP\", textcolor = color.black)\n\n// ======================\n// SHORT: BD / PB / VCP\n// ======================\n\n// Breakdown Short\nbdContraction    = trVal < trVal[1] and trVal[1] < trVal[2]\ncondBD_ShortCore = close < lowestLow and volume > avgVol * volMultLow\ncondBD_Short     = condBD_ShortCore and trendDown and trendStrong and mktShortOK\ncondBD_Short    := strictQuality ? (condBD_Short and bdContraction) : condBD_Short\n\nshortBD = useBDShort and condBD_Short\n\nplotshape(shortBD, title = \"BD Short\",\n     style = shape.triangledown, location = location.abovebar,\n     size = size.small, color = color.new(color.lime, 0),\n     text = \"BD\", textcolor = color.black)\n\n// Pullback Short\ntwoGreenPB   = close[1] > open[1] and close[2] > open[2]\nstrongDrop   = close < open and close < low[1]\nvolOK_PB_S   = volume > (strictQuality ? avgVol * 1.1 : avgVol * 0.9)\n\ncondPB_ShortCore = high >= emaFast and twoGreenPB and strongDrop and volOK_PB_S\ncondPB_Short     = condPB_ShortCore and trendDown and trendStrong and mktShortOK\n\nshortPB = usePBShort and condPB_Short\n\nplotshape(shortPB, title = \"PB Short\",\n     style = shape.circle, location = location.abovebar,\n     size = size.small, color = color.new(color.aqua, 0),\n     text = \"PB\", textcolor = color.black)\n\n// VCP Short\nvcpSeq_Short = trVal < trVal[1] and trVal[1] < trVal[2]\nnearLow_S    = close <= lowestLow * 1.03\n\ncondVCP_SCore = vcpSeq_Short and nearLow_S and close < low[1]\ncondVCP_S     = condVCP_SCore and trendDown and trendStrong and mktShortOK\ncondVCP_S    := strictQuality ? (condVCP_S and volContract) : condVCP_S\n\nshortVCP = useVCPShort and condVCP_S\n\nplotshape(shortVCP, title = \"VCP Short\",\n     style = shape.flag, location = location.abovebar,\n     size = size.small, color = color.new(color.yellow, 0),\n     text = \"VCP\", textcolor = color.black)\n\n// ======================\n// EARLY-ENTRY-WARNUNGEN (nur Shapes, keine Labels)\n// ======================\npreBO_Long  = showEarlyWarn and not longBO and trendUp   and trendStrong and mktLongOK  and highestHigh > 0 and close < highestHigh and nearPct(close, highestHigh, nearHighPct) and volume < avgVol * volMultHigh and volume > avgVol * 0.5\nprePB_Long  = showEarlyWarn and not longPB and trendUp   and trendStrong and mktLongOK  and nearPct(close, emaFast, nearEmaPct) and close[1] < open[1]\npreVCP_Long = showEarlyWarn and not longVCP and trendUp  and trendStrong and mktLongOK  and vcpSeq_Long and nearHigh_L and volume < avgVol\n\npreBD_Short  = showEarlyWarn and not shortBD and trendDown and trendStrong and mktShortOK and lowestLow > 0 and close > lowestLow and nearPct(close, lowestLow, nearLowPct) and volume < avgVol * volMultLow and volume > avgVol * 0.5\nprePB_Short  = showEarlyWarn and not shortPB and trendDown and trendStrong and mktShortOK and nearPct(close, emaFast, nearEmaPct) and close[1] > open[1]\npreVCP_Short = showEarlyWarn and not shortVCP and trendDown and trendStrong and mktShortOK and vcpSeq_Short and nearLow_S and volume < avgVol\n\nplotshape(preBO_Long or prePB_Long or preVCP_Long,\n     title = \"Early Long\", style = shape.diamond, location = location.belowbar,\n     size = size.tiny, color = color.new(color.orange, 0), text = \"SE\", textcolor = color.black)\n\nplotshape(preBD_Short or prePB_Short or preVCP_Short,\n     title = \"Early Short\", style = shape.diamond, location = location.abovebar,\n     size = size.tiny, color = color.new(color.orange, 0), text = \"SE\", textcolor = color.black)\n\n// ======================\n// Entries & Exits\n// ======================\nnewLongSignal  = (longBO or longPB or longVCP)    and strategy.position_size <= 0\nnewShortSignal = (shortBD or shortPB or shortVCP) and strategy.position_size >= 0\n\nif newLongSignal\n    stopLong = close - atrMultSL_L * atr\n    takeLong = close + atrMultTP_L * atr\n    strategy.entry(\"Long\", strategy.long)\n    strategy.exit(\"Long Exit\", from_entry = \"Long\", stop = stopLong, limit = takeLong)\n\nif newShortSignal\n    stopShort = close + atrMultSL_S * atr\n    takeShort = close - atrMultTP_S * atr\n    strategy.entry(\"Short\", strategy.short)\n    strategy.exit(\"Short Exit\", from_entry = \"Short\", stop = stopShort, limit = takeShort)\n\n// ======================\n// Alerts\n// ======================\nalertcondition(longBO,   title = \"BestEntry Long BO\",   message = \"BestEntry LONG Breakout {{ticker}} {{interval}}\")\nalertcondition(longPB,   title = \"BestEntry Long PB\",   message = \"BestEntry LONG Pullback {{ticker}} {{interval}}\")\nalertcondition(longVCP,  title = \"BestEntry Long VCP\",  message = \"BestEntry LONG VCP {{ticker}} {{interval}}\")\nalertcondition(shortBD,  title = \"BestEntry Short BD\",  message = \"BestEntry SHORT Breakdown {{ticker}} {{interval}}\")\nalertcondition(shortPB,  title = \"BestEntry Short PB\",  message = \"BestEntry SHORT Pullback {{ticker}} {{interval}}\")\nalertcondition(shortVCP, title = \"BestEntry Short VCP\", message = \"BestEntry SHORT VCP {{ticker}} {{interval}}\")\n\n"
  },
  {
    "url": "yWaHb1wO-G-BOT-ENGULFING-CANDLE-FIXED-SL-TP",
    "name": "G-BOT ENGULFING CANDLE - FIXED SL & TP ",
    "description": "// Description:\n\nThis Pine Script strategy identifies bullish and bearish engulfing candle patterns over a defined lookback period and places trades based \non recent market highs and lows. It calculates stop loss and take profit levels using the Average True Range (ATR) multiplied by a user-defined factor, with the ability to adjust the risk-to-reward ratio for each trade.",
    "image_url": "yWaHb1wO",
    "author": "InvestStar",
    "likes": 39,
    "type": "strategy",
    "created": "2025-11-29",
    "updated": "2025-11-29",
    "source": "\r\n//       Name:\r\n\r\n// â€œBEC - Engulfing ATR Fixed SL/TP Strategyâ€\r\n// (BEC = Bullish/Bearish Engulfing Candle)\r\n\r\n// Description:\r\n\r\n// This Pine Script strategy identifies bullish and bearish engulfing candle patterns over a defined lookback period and places trades based \r\n// on recent market highs and lows. It calculates stop loss and take profit levels using the Average True Range (ATR) multiplied by a user-defined factor,\r\n// with the ability to adjust the risk-to-reward ratio for each trade.\r\n\r\n// Key Features:\r\n\r\n// Engulfing Candle Detection\r\n// Bullish Engulfing: Current candle closes higher than the previous candleâ€™s open while the previous candle was bearish.\r\n// Bearish Engulfing: Current candle closes lower than the previous candleâ€™s open while the previous candle was bullish.\r\n// Lookback Confirmation\r\n// Trades are only triggered if the current low (for long) or high (for short) matches the highest high or lowest low over a configurable lookback period.\r\n// ATR-Based Stop Loss & Take Profit\r\n// Stop loss is calculated as a multiple of ATR below (for long) or above (for short) recent lows/highs.\r\n// Take profit is calculated using a user-defined risk-to-reward ratio.\r\n// Trade Execution & Alerts\r\n// Opens long positions when bullish conditions are met.\r\n// Opens short positions when bearish conditions are met.\r\n// Sends alerts when buy or sell signals are triggered.\r\n// Visual Guidance\r\n// Displays buy/sell triangles on the chart.\r\n// Plots active stop loss and take profit lines for easy monitoring.                                                                     \r\n//----------------------------------//                                                                               \r\n//----------------------------------//                                                                               \r\n//----------------------------------//                                            \r\n//----------------------------------// Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â \r\n//--------------------------------------------------------------------------------------------------------------------//\r\n// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n\r\n// @version=6  \r\nstrategy(\"G-BOT ENGULFING CANDLE - FIXED SL & TP \", overlay=true)  // STRATEGY - NAME OF STRATEGY - OVERLAY OR NOT ( RUN OVER CHAT OR SPILT SCREEN)\r\n\r\nlookback    = input.int(title=\"Lookback\", defval=7, tooltip = \"THIS LOOKBACK IS TO LOOK BACK OVER THE PREVIOUS BARS (CANDLES)\", group = \"GBOT SETTING\")// THIS LOOKBACK IS TO LOOK BACK OVER THE PREVIOUS BARS (CANDLES)\r\nmultiplier  = input.float(title=\"ATR Multiplier\", defval=1.0, tooltip = \"THIS MULTIPLIER IS FOR ATR MULTIPLIER FOR STOP LOSS & TAKE PROFIT \", group = \"GBOT SETTING\")// THIS MULTIPLIER IS FOR ATR MULTIPLIER FOR STOP LOSS & TAKE PROFIT               \r\nrr          = input.float(title=\"Risk:Reward\", defval=1.5, tooltip = \"THIS RR IS FOR RISK TO REWARD\", group = \"GBOT SETTING\") // THIS RR IS FOR RISK TO REWARD \r\n\r\nfloat atr = ta.atr(14)\r\nbool sharedFilters = not na(atr) and strategy.position_size == 0 and barstate.isconfirmed\r\n\r\nbool bullEC = close[1] < open[1] and open <= close[1] and close >= open[1]\r\nbool bearEC = close[1] > open[1] and open >= close[1] and close <= open[1]\r\n\r\nfloat recentHigh = ta.highest(high, lookback)\r\nfloat recentLow = ta.lowest(low, lookback)\r\n\r\nbool buySignal  = bullEC and low == recentLow and sharedFilters \r\nbool sellSignal = bearEC and high == recentHigh and sharedFilters \r\n\r\nfloat longStop  = recentLow - (atr * multiplier)\r\nfloat shortStop = recentHigh + (atr * multiplier)\r\nfloat longStopDistance  = close - longStop\r\nfloat shortStopDistance = shortStop - close\r\nfloat longTarget  = close + (longStopDistance * rr)\r\nfloat shortTarget = close - (shortStopDistance * rr)\r\n\r\nvar float t_stop = 0.0\r\nvar float t_target = 0.0\r\n\r\nif (buySignal)\r\n    strategy.entry(id=\"Long\", direction=strategy.long)\r\n    t_stop := longStop\r\n    t_target := longTarget\r\n\r\nif buySignal\r\n    alert(\"BUY SIGNAL HAS BEEN TRIGGERED:\" + str.tostring(close), alert.freq_once_per_bar)  \r\n\r\nif (sellSignal)\r\n    strategy.entry(id=\"Short\", direction=strategy.short)\r\n    t_stop := shortStop\r\n    t_target := shortTarget\r\n\r\nif sellSignal\r\n    alert(\"SELL SIGNAL HAS BEEN TRIGGERED:\" + str.tostring(close), alert.freq_once_per_bar)  \r\n\r\nstrategy.exit(id=\"Long Exit\", from_entry=\"Long\", limit=t_target, stop=t_stop)\r\nstrategy.exit(id=\"Short Exit\", from_entry=\"Short\", limit=t_target, stop=t_stop)\r\n\r\nplotshape(buySignal, style=shape.triangleup, color=color.green, size = size.small, location=location.belowbar)\r\nplotshape(sellSignal, style=shape.triangledown, color=color.red, size = size.small, location=location.abovebar)\r\nplot(strategy.position_size != 0 ? t_stop : na, color=color.red, style=plot.style_linebr)\r\nplot(strategy.position_size != 0 ? t_target : na, color=color.green, style=plot.style_linebr)\r\n\r\n\r\nplotshape(buySignal, style=shape.labelup, location=location.belowbar, color=color.new(#2df904, 0), size=size.large, text='BUY', textcolor=color.new(color.white, 0)) //plotting up arrow when buy/long conditions met \r\nplotshape(sellSignal, style=shape.labeldown, location=location.abovebar, color=color.new(#f90404, 0), size=size.large, text='SELL', textcolor=color.new(color.white, 0)) //plotting down arrow when sell/short conditions met\r\n\r\n\r\n\r\n\r\n"
  },
  {
    "url": "obur54zQ",
    "name": "Stoch+RSI Trend Strategy (Webhook Ready) ",
    "description": "En iyi ayarlar iÃ§in lÃ¼tfen geri dÃ¶nÃ¼ÅŸ yapmayÄ± unutmayÄ±n.",
    "image_url": "obur54zQ",
    "author": "zumahk",
    "likes": 4,
    "type": "strategy",
    "created": "2025-11-29",
    "updated": "2025-11-29",
    "source": "//@version=5\nstrategy(\"Stoch+RSI Trend Strategy (Webhook Ready)\", overlay=true, margin_long=100, margin_short=100, initial_capital=1000, default_qty_type=strategy.percent_of_equity, default_qty_value=20)\n\n// ================= INPUTS =================\nfastLen = input.int(8, \"Fast MA\", minval=1)\nslowLen = input.int(20, \"Slow MA\", minval=1)\nemaTrendLen = input.int(100, \"Trend EMA Length\")\n\n// ADX inputs\nadxLen = input.int(14, \"ADX Length\")\nadxThresh = input.float(20.0, \"ADX Threshold\", step=0.1)\n\n// Stochastic inputs\nkLen = input.int(12, \"Stochastic K Length\")\ndLen = input.int(3, \"Stochastic D Length\")\nsmoothK = input.int(5, \"Stoch Smooth\")\nstochOB = input.int(80, \"Overbought\")\nstochOS = input.int(20, \"Oversold\")\n\n// RSI inputs\nrsiLen = input.int(10, \"RSI Length\")\nrsiSource = input.source(close, \"RSI Source\")\n\n// ATR inputs\natrLen = input.int(14, \"ATR Length\")\natrSmaLen = input.int(14, \"ATR SMA Length\")\natrMult = input.float(1.0, \"ATR Multiplier\", step=0.1)\n\n// Risk Management\nTP = input.float(0.8, \"TP %\", step=0.1)\nSL = input.float(0.4, \"SL %\", step=0.1)\n\n// ================= INDICATORS =================\nemaTrend = ta.ema(close, emaTrendLen)\nemaFast  = ta.ema(close, fastLen)\nemaSlow  = ta.ema(close, slowLen)\n\n// ATR (volatility)\natr = ta.atr(atrLen)\natrSma = ta.sma(atr, atrSmaLen)\n\n// Manual ADX (v4/v5 safe)\nupMove  = high - high[1]\ndownMove = low[1] - low\nplusDM  = (upMove > downMove and upMove > 0) ? upMove : 0.0\nminusDM = (downMove > upMove and downMove > 0) ? downMove : 0.0\ntr1 = high - low\ntr2 = math.abs(high - close[1])\ntr3 = math.abs(low - close[1])\ntrueRange = math.max(math.max(tr1, tr2), tr3)\n\nsmTR = ta.rma(trueRange, adxLen)\nsmPlusDM = ta.rma(plusDM, adxLen)\nsmMinusDM = ta.rma(minusDM, adxLen)\n\nplusDI = 100 * (smPlusDM / smTR)\nminusDI = 100 * (smMinusDM / smTR)\ndx = 100 * math.abs(plusDI - minusDI) / (plusDI + minusDI)\nadx = ta.rma(dx, adxLen)\n\n// Stochastic\nstoch_k = ta.sma(ta.stoch(close, high, low, kLen), smoothK)\nstoch_d = ta.sma(stoch_k, dLen)\n\n// RSI\nrsi = ta.rsi(rsiSource, rsiLen)\n\n// ================= SIGNALS =================\ntrendLong = close > emaTrend\ntrendShort = close < emaTrend\n\nvolatilityOk = atr > (atrMult * atrSma)\nadxOk = adx > adxThresh\n\nstochLong = ta.crossover(stoch_k, stoch_d) and stoch_k < stochOB\nstochShort = ta.crossunder(stoch_k, stoch_d) and stoch_k > stochOS\n\nrsiLong = rsi < 60\nrsiShort = rsi > 40\n\ncanLong = trendLong and volatilityOk and adxOk and stochLong and rsiLong\ncanShort = trendShort and volatilityOk and adxOk and stochShort and rsiShort\n\n// ================= ORDERS =================\nif (canLong)\n    strategy.entry(\"Long\", strategy.long)\n    strategy.exit(\"TP/SL Long\", from_entry=\"Long\", limit=close * (1 + TP/100), stop=close * (1 - SL/100))\n\nif (canShort)\n    strategy.entry(\"Short\", strategy.short)\n    strategy.exit(\"TP/SL Short\", from_entry=\"Short\", limit=close * (1 - TP/100), stop=close * (1 + SL/100))\n\n// ================= PLOTS =================\nplot(emaTrend, \"EMA Trend\", color=color.orange)\nplot(emaFast, \"EMA Fast\", color=color.green)\nplot(emaSlow, \"EMA Slow\", color=color.blue)\nplotshape(canLong, title=\"Long\", style=shape.triangleup, location=location.belowbar, color=color.green, size=size.tiny)\nplotshape(canShort, title=\"Short\", style=shape.triangledown, location=location.abovebar, color=color.red, size=size.tiny)\n\n// ================= ALERTS =================\nbuyJson = '{\"action\":\"buy\",\"symbol\":\"' + syminfo.ticker + '\",\"price\":' + str.tostring(close) + '}'\nsellJson = '{\"action\":\"sell\",\"symbol\":\"' + syminfo.ticker + '\",\"price\":' + str.tostring(close) + '}'\n\n// UI alertconditions (no dynamic message here to avoid runtime errors)\nalertcondition(canLong, title=\"BUY Webhook\")\nalertcondition(canShort, title=\"SELL Webhook\")\n\n// Runtime alerts using alert() â€” this sends the JSON payload to webhook immediately when condition true\nif (canLong)\n    alert(buyJson, alert.freq_once_per_bar_close)\nif (canShort)\n    alert(sellJson, alert.freq_once_per_bar_close)\n"
  },
  {
    "url": "WoWQbUdf-CDC-Action-Zone-V-2-strategy-Updated-v6",
    "name": "CDC Action Zone V.2 strategy â€” Updated v6",
    "description": "Making a profit with a candlestick structure compared to the MA course 25 line with nine intersecting to find. Buy in the market.",
    "image_url": "WoWQbUdf",
    "author": "funnytuang",
    "likes": 3,
    "type": "strategy",
    "created": "2025-11-29",
    "updated": "2025-11-29",
    "source": "//@version=6\nstrategy(\"CDC Action Zone V.2 strategy â€” Updated v6\", overlay=true, margin_long=100, margin_short=100)\n\n//-----------------------------\n// Inputs\n//-----------------------------\nsrc  = input.source(ohlc4, \"Data Array\")\nprd1 = input.int(12, \"Short MA period\")\nprd2 = input.int(26, \"Long MA period\")\n\n//-----------------------------\n// Core Calculations\n//-----------------------------\nAP   = ta.ema(src, 2)\nFast = ta.ema(AP, prd1)\nSlow = ta.ema(AP, prd2)\n\n//-----------------------------\n// Backtest Range\n//-----------------------------\nFromYear  = input.int(2019, \"From Year\", minval = 2009)\nFromMonth = input.int(1, \"From Month\", minval = 1, maxval = 12)\nFromDay   = input.int(1, \"From Day\", minval = 1, maxval = 31)\n\nToYear    = input.int(9999, \"To Year\", minval = 2009)\nToMonth   = input.int(12,  \"To Month\", minval = 1, maxval = 12)\nToDay     = input.int(31,   \"To Day\", minval = 1, maxval = 31)\n\nstart  = timestamp(FromYear, FromMonth, FromDay, 00, 00)\nfinish = timestamp(ToYear, ToMonth, ToDay, 23, 59)\n\nwindow = (time >= start and time <= finish)\n\n//-----------------------------\n// CDC Color Conditions\n//-----------------------------\nBullish = Fast > Slow\nBearish = Fast < Slow\n\nGreen  = Bullish and AP > Fast\nRed    = Bearish and AP < Slow\nYellow = Bullish and AP < Fast\nBlue   = Bearish and AP > Slow\n\n//-----------------------------\n// Trade Signals\n//-----------------------------\nBuy  = Green and not Green[1]\nSell = Red   and not Red[1]\n\nShort = Red and not Red[1]\nCover = Red[1] and not Red\n\n//-----------------------------\n// Plot MAs\n//-----------------------------\nl1 = plot(Fast, \"Fast\", color=color.red, linewidth=1)\nl2 = plot(Slow, \"Slow\", color=color.blue, linewidth=2)\n\nbcolor =\n     Green  ? color.lime   :\n     Red    ? color.red    :\n     Yellow ? color.yellow :\n     Blue   ? color.blue   :\n     color.white\n\n\n//-----------------------------\n// Strategy Logic\n//-----------------------------\nif (window and Buy)\n    strategy.entry(\"Buy\", strategy.long)\n\nif (window and Sell)\n    strategy.close_all()"
  },
  {
    "url": "blXynykp",
    "name": "sol-ST + OKX1.0",
    "description": "A simple beginner-level tool suitable for SOL 1-hour trend and range trading",
    "image_url": "blXynykp",
    "author": "itwlzpbfr",
    "likes": 10,
    "type": "strategy",
    "created": "2025-11-29",
    "updated": "2025-11-29",
    "source": "//@version=6\nstrategy(\"ç­–ç•¥: STè¶‹åŠ¿ + OKXä¿¡å· + å›ºå®šé‡‘é¢ç‰ˆ\", overlay=true, initial_capital=1000, default_qty_type=strategy.cash, default_qty_value=100, currency=currency.USD)\n\n// ==========================================\n// 1. OKX ä¿¡å·é…ç½® (æ ¸å¿ƒä¿®å¤)\n// ==========================================\n// 1. å¡« Token\nokxSignalToken = input.string(\"\", \"OKX Signal Token (å¿…å¡«)\", tooltip=\"ç²˜è´´OKXæä¾›çš„ä¿¡å·Token\")\n// 2. å¡«å¸å¯¹åç§° (ä¾‹å¦‚ SOL-USDT-SWAP)\nokxSymbol = input.string(\"SOL-USDT-SWAP\", \"äº¤æ˜“å¸å¯¹åç§°\", tooltip=\"OKXæ°¸ç»­åˆçº¦é€šå¸¸ä¸º: å¸ç§-USDT-SWAP\")\n\n// ðŸ”¥ ç»„è£…å®Œæ•´çš„ OKX JSON æŒ‡ä»¤\n// åŒ…å«ï¼šåŠ¨ä½œã€Tokenã€å¸ç§ã€æŠ•èµ„ç±»åž‹(base=æŒ‰å¸ä¸ªæ•°)ã€æ•°é‡(strategy.order.contracts)\n// æ³¨æ„ï¼šæˆ‘ä»¬ä½¿ç”¨ str.format è¿›è¡Œæ›´å®‰å…¨çš„å­—ç¬¦ä¸²æ‹¼æŽ¥\nmsg_enter_long  = '{\"action\": \"enter_long\", \"instrument\": \"' + okxSymbol + '\", \"signalToken\": \"' + okxSignalToken + '\", \"investmentType\": \"base\", \"amount\": \"{{strategy.order.contracts}}\"}'\nmsg_exit_long   = '{\"action\": \"exit_long\",  \"instrument\": \"' + okxSymbol + '\", \"signalToken\": \"' + okxSignalToken + '\", \"investmentType\": \"base\", \"amount\": \"{{strategy.order.contracts}}\"}'\nmsg_enter_short = '{\"action\": \"enter_short\",\"instrument\": \"' + okxSymbol + '\", \"signalToken\": \"' + okxSignalToken + '\", \"investmentType\": \"base\", \"amount\": \"{{strategy.order.contracts}}\"}'\nmsg_exit_short  = '{\"action\": \"exit_short\", \"instrument\": \"' + okxSymbol + '\", \"signalToken\": \"' + okxSignalToken + '\", \"investmentType\": \"base\", \"amount\": \"{{strategy.order.contracts}}\"}'\n\n// ==========================================\n// 2. ç­–ç•¥å‚æ•°è®¾ç½® (ä¿æŒä¸å˜)\n// ==========================================\n\nfixedUSDAmount = input.float(100, \"æ¯æ¬¡å›ºå®šä¸‹å•é‡‘é¢ (USD)\", step=10, minval=1)\nfilterWeekend = input.bool(false, \"å¯ç”¨å‘¨æœ«è¿‡æ»¤\")\n\nstFactor = input.float(3.0, \"SuperTrend ä¹˜æ•°\")\nstPeriod = input.int(10, \"SuperTrend å‘¨æœŸ\")\n\nrsiLength = input.int(14, \"RSI é•¿åº¦\")\nrsiEnterLong = input.int(40, \"RSI è¿›åœº-å¤š (<)\")\nrsiEnterShort = input.int(60, \"RSI è¿›åœº-ç©º (>)\")\nrsiExitLong = input.int(70, \"RSI æ­¢ç›ˆ-å¤š (>)\", tooltip=\"RSIä¸€æ—¦è¶…è¿‡è¿™ä¸ªå€¼ï¼Œå°±å¼€å§‹ç­‰å¾…é˜´çº¿\")\nrsiExitShort = input.int(30, \"RSI æ­¢ç›ˆ-ç©º (<)\", tooltip=\"RSIä¸€æ—¦ä½ŽäºŽè¿™ä¸ªå€¼ï¼Œå°±å¼€å§‹ç­‰å¾…é˜³çº¿\")\n\nfixedSLPct = input.float(3.0, \"å›ºå®šæ­¢æŸç™¾åˆ†æ¯” (%)\", step=0.1) / 100\nuseBreakEven = input.bool(false, \"å¯ç”¨ä¿æœ¬æœºåˆ¶\")\nbeTrigger = input.float(1.5, \"åˆ©æ¶¦è¾¾å¤šå°‘%è§¦å‘ä¿æœ¬\", step=0.1) / 100\n\n// ==========================================\n// 3. æŒ‡æ ‡è®¡ç®—\n// ==========================================\n\nprice = close\nrsiVal = ta.rsi(price, rsiLength)\n[superTrendVal, superTrendDir] = ta.supertrend(stFactor, stPeriod)\nisBullTrend = superTrendDir < 0\nisBearTrend = superTrendDir > 0\n\ncurrentDay = dayofweek(time, syminfo.timezone)\nisWeekend = (currentDay == dayofweek.saturday) or (currentDay == dayofweek.sunday)\ntradingAllowed = filterWeekend ? not isWeekend : true\n\n// ==========================================\n// 4. é€»è¾‘åˆ¤æ–­\n// ==========================================\n\nvar bool watchingLong = false\nvar bool watchingShort = false\nvar bool waitingForExitLong = false\nvar bool waitingForExitShort = false\n\nif rsiVal < rsiEnterLong and isBullTrend\n    watchingLong := true\nif rsiVal > rsiEnterShort and isBearTrend\n    watchingShort := true\n\nif rsiVal > 50\n    watchingLong := false\nif rsiVal < 50\n    watchingShort := false\nif not isBullTrend\n    watchingLong := false\nif not isBearTrend\n    watchingShort := false\n\nlongCondition = watchingLong and close > open and isBullTrend and tradingAllowed\nshortCondition = watchingShort and close < open and isBearTrend and tradingAllowed\n\n// ==========================================\n// 5. äº¤æ˜“æ‰§è¡Œ\n// ==========================================\n\nif strategy.position_size == 0\n    waitingForExitLong := false\n    waitingForExitShort := false\n\nif strategy.position_size == 0\n    float qty_contracts = fixedUSDAmount / close\n\n    if longCondition\n        float slPrice = close * (1 - fixedSLPct)\n        strategy.entry(\"Long\", strategy.long, qty=qty_contracts, comment=\"åšå¤š\", alert_message=msg_enter_long)\n        strategy.exit(\"Exit_L\", \"Long\", stop=slPrice, comment_loss=\"ç¡¬æ­¢æŸ\", alert_message=msg_exit_long)\n        watchingLong := false \n\n    if shortCondition\n        float slPrice = close * (1 + fixedSLPct)\n        strategy.entry(\"Short\", strategy.short, qty=qty_contracts, comment=\"åšç©º\", alert_message=msg_enter_short)\n        strategy.exit(\"Exit_S\", \"Short\", stop=slPrice, comment_loss=\"ç¡¬æ­¢æŸ\", alert_message=msg_exit_short)\n        watchingShort := false \n\n// ==========================================\n// 6. åŠ¨æ€ç®¡ç†\n// ==========================================\n\nif strategy.position_size > 0\n    if rsiVal > rsiExitLong\n        waitingForExitLong := true\n    if waitingForExitLong and close < open\n        strategy.close(\"Long\", comment=\"RSIæ­¢ç›ˆ\", alert_message=msg_exit_long)\n        waitingForExitLong := false \n\nif strategy.position_size < 0\n    if rsiVal < rsiExitShort\n        waitingForExitShort := true\n    if waitingForExitShort and close > open\n        strategy.close(\"Short\", comment=\"RSIæ­¢ç›ˆ\", alert_message=msg_exit_short)\n        waitingForExitShort := false \n\nif useBreakEven and strategy.position_size != 0\n    float entryPrice = strategy.position_avg_price\n    if strategy.position_size > 0\n        if high > entryPrice * (1 + beTrigger)\n            strategy.exit(\"Exit_L\", \"Long\", stop=entryPrice, comment_loss=\"ä¿æœ¬æ’¤é€€\", alert_message=msg_exit_long)\n    if strategy.position_size < 0\n        if low < entryPrice * (1 - beTrigger)\n            strategy.exit(\"Exit_S\", \"Short\", stop=entryPrice, comment_loss=\"ä¿æœ¬æ’¤é€€\", alert_message=msg_exit_short)\n\n// ==========================================\n// 7. ç»˜å›¾\n// ==========================================\nplot(superTrendVal, \"SuperTrend\", color = isBullTrend ? color.green : color.red)\nhline(rsiExitLong, \"å¤šå•æ¿€æ´»\", color=color.green, linestyle=hline.style_dotted)\nhline(rsiExitShort, \"ç©ºå•æ¿€æ´»\", color=color.red, linestyle=hline.style_dotted)\nbgcolor(isWeekend and filterWeekend ? color.new(color.gray, 90) : na)\n"
  },
  {
    "url": "7ZdAHEeF-Structure-Break-Out-rsi-divergence-alma-SIMPLIFIED",
    "name": "Structure Break Out + rsi divergence + alma SIMPLIFIED ",
    "description": "OBJECTIVE (dyor, nfa, test different assets and diff TF) \n The goal of this script is to act as a Reversal Sniper. Most traders lose money by trying to guess the top or bottom of a market too early. This strategy solves that by waiting for two specific events to happen together:\n First, a hidden shift in momentum (RSI Divergence).\n Second, a confirmed change in price direction (Crossing the ALMA 20 Blue Line).\n This ensures you only enter a trade when the market has confirmed it is ready to reverse.\n\nTRADING RULES\n\nBUY SIGNAL (Long Position)\n\n Step 1: Look for a GREEN DIV label below the candles. This warns you that sellers are exhausted.\n Step 2: Wait for a GREEN TRIANGLE with the text GO. This confirms the price has crossed above the Blue Line.\n Step 3: Enter the Buy trade immediately when the candle with the GO signal closes.\n\nSELL SIGNAL (Short Position)\n Step 1: Look for a RED DIV label above the candles. This warns you that buyers are exhausted.\n Step 2: Wait for a RED TRIANGLE with the text GO. This confirms the price has crossed below the Blue Line.\n Step 3: Enter the Sell trade immediately when the candle with the GO signal closes.\n\n \nEXIT RULES (How to Close the Trade)\nThe script draws lines on the chart to help you manage the trade.\n\n Scenario A: The Perfect Win (Target Hit)\nIf price hits the Green Line, the trade is closed automatically for a profit. This is your Risk-Reward Target.\n\n\n\n Scenario B: The Trend Change (Reversal)\nIf the price turns around and crosses the Blue Line in the wrong direction, close the trade immediately. Do not wait for the stop loss. This protects your profits or keeps losses small.\n\n\n\n Scenario C: The Safety Net (Stop Loss)\nIf price hits the Red Line, the trade is closed for a loss. This is your safety guard to prevent a small loss from becoming a big one.\n\nIMPORTANT NOTES\n Never trade a DIV label without a GO signal. The DIV is just a warning; the GO is the trigger.\n - This strategy works best on 15-Minute and 1-Hour timeframes.\n - If t\n he Blue Line is flat, be careful, as the market may be ranging. Ideally, you want to see the Blue Line angling up or down.",
    "image_url": "7ZdAHEeF",
    "author": "hushedDiamond97573",
    "likes": 18,
    "type": "strategy",
    "created": "2025-11-29",
    "updated": "2025-11-29",
    "source": "//@version=5\r\nstrategy(\"SBR Master v9.3: Div + ALMA + R:R (Stable)\", overlay=true, \r\n     default_qty_type=strategy.cash, default_qty_value=10000, \r\n     currency=currency.USD,\r\n     initial_capital=10000,\r\n     commission_type=strategy.commission.percent, commission_value=0.1)\r\n\r\n// â”€â”€â”€â”€â”€ INPUTS â”€â”€â”€â”€â”€\r\n\r\n// -- Trend/Trigger --\r\nalmaLen     = input.int(20, \"Trigger Line (ALMA Length)\", minval=5, group=\"Strategy Settings\")\r\nalmaOffset  = input.float(0.85, \"ALMA Offset\", group=\"Strategy Settings\")\r\nalmaSigma   = input.float(6.0, \"ALMA Sigma\", group=\"Strategy Settings\")\r\n\r\n// -- RSI Divergence Settings --\r\nrsiLen      = input.int(14, \"RSI Length\", group=\"Divergence Logic\")\r\nlb          = input.int(5, \"Pivot Lookback\", tooltip=\"Checks 5 bars left/right to confirm a top/bottom\", group=\"Divergence Logic\")\r\ndivLookback = input.int(15, \"Divergence Freshness\", tooltip=\"Allows entry if divergence happened within last X bars\", group=\"Divergence Logic\")\r\n\r\n// -- Data Integrity --\r\nuseRealData = input.bool(true, \"Force Real Price (Fixes Heikin Ashi)\", group=\"Data Integrity\")\r\n\r\n// -- Risk Management --\r\nuseAtrStop  = input.bool(true, \"Use ATR Stop Loss?\", group=\"Risk Management\")\r\natrMult     = input.float(3.0, \"ATR Stop Multiplier\", group=\"Risk Management\")\r\n\r\n// -- Take Profit Settings --\r\nuseTP       = input.bool(true, \"Use Risk:Reward Target?\", group=\"Take Profit\")\r\nrrRatio     = input.float(2.0, \"Risk:Reward Ratio\", step=0.1, tooltip=\"Example: 2.0 means if Stop is $100, Target is $200\", group=\"Take Profit\")\r\n\r\n// â”€â”€â”€â”€â”€ DATA CALCULATIONS â”€â”€â”€â”€â”€\r\n\r\n// Efficiently fetch Real Data (Fixes Heikin Ashi issue)\r\n[rO, rH, rL, rC] = request.security(syminfo.tickerid, timeframe.period, [open, high, low, close])\r\n\r\n// Use Real Data if selected, otherwise Chart Data\r\nrealOpen  = useRealData ? rO : open\r\nrealHigh  = useRealData ? rH : high\r\nrealLow   = useRealData ? rL : low\r\nrealClose = useRealData ? rC : close\r\n\r\n// Indicators\r\nalma20 = ta.alma(realClose, almaLen, almaOffset, almaSigma)\r\nrsi    = ta.rsi(realClose, rsiLen)\r\natr    = ta.atr(14)\r\n\r\n// â”€â”€â”€â”€â”€ DIVERGENCE ENGINE â”€â”€â”€â”€â”€\r\n\r\n// Find Pivot Points\r\nph = ta.pivothigh(rsi, lb, lb)\r\npl = ta.pivotlow(rsi, lb, lb)\r\n\r\n// Track History\r\nvar float lastPhRsi = na\r\nvar float lastPhPrice = na\r\nvar float lastPlRsi = na\r\nvar float lastPlPrice = na\r\n\r\nbool bullDiv = false\r\nbool bearDiv = false\r\n\r\n// Bullish Divergence Check\r\nif not na(pl)\r\n    priceLowAtPivot = realLow[lb]\r\n    if (rsi[lb] > lastPlRsi) and (priceLowAtPivot < lastPlPrice)\r\n        bullDiv := true \r\n    lastPlRsi := rsi[lb]\r\n    lastPlPrice := priceLowAtPivot\r\n\r\n// Bearish Divergence Check\r\nif not na(ph)\r\n    priceHighAtPivot = realHigh[lb]\r\n    if (rsi[lb] < lastPhRsi) and (priceHighAtPivot > lastPhPrice)\r\n        bearDiv := true\r\n    lastPhRsi := rsi[lb]\r\n    lastPhPrice := priceHighAtPivot\r\n\r\n// â”€â”€â”€â”€â”€ ENTRY LOGIC â”€â”€â”€â”€â”€\r\n\r\nisBullishSetup = ta.barssince(bullDiv) < divLookback\r\nisBearishSetup = ta.barssince(bearDiv) < divLookback\r\n\r\n// Trigger: Cross of ALMA 20 + Recent Divergence\r\nlongCondition = ta.crossover(realClose, alma20) and isBullishSetup\r\nshortCondition = ta.crossunder(realClose, alma20) and isBearishSetup\r\n\r\n// â”€â”€â”€â”€â”€ EXECUTION â”€â”€â”€â”€â”€\r\n\r\nif longCondition and strategy.position_size == 0\r\n    strategy.entry(\"Long Div\", strategy.long)\r\n\r\nif shortCondition and strategy.position_size == 0\r\n    strategy.entry(\"Short Div\", strategy.short)\r\n\r\n// â”€â”€â”€â”€â”€ EXITS (Stop Loss & Take Profit) â”€â”€â”€â”€â”€\r\n\r\n// Logic to determine levels based on entry price\r\n// We use 'nz' to prevent errors when not in position\r\navgPrice = strategy.position_avg_price\r\nriskDist = atr * atrMult\r\nrewardDist = riskDist * rrRatio\r\n\r\nlongStopPrice = avgPrice - riskDist\r\nshortStopPrice = avgPrice + riskDist\r\n\r\nlongTpPrice = avgPrice + rewardDist\r\nshortTpPrice = avgPrice - rewardDist\r\n\r\n// Exit 1: ATR Stop & Fixed Target\r\nif strategy.position_size > 0\r\n    if useTP\r\n        strategy.exit(\"Bracket Long\", from_entry=\"Long Div\", stop=longStopPrice, limit=longTpPrice)\r\n    else\r\n        strategy.exit(\"SL Only Long\", from_entry=\"Long Div\", stop=longStopPrice)\r\n\r\nif strategy.position_size < 0\r\n    if useTP\r\n        strategy.exit(\"Bracket Short\", from_entry=\"Short Div\", stop=shortStopPrice, limit=shortTpPrice)\r\n    else\r\n        strategy.exit(\"SL Only Short\", from_entry=\"Short Div\", stop=shortStopPrice)\r\n\r\n// Exit 2: Trend Reversal (The \"Bail Out\")\r\n// If price crosses back over ALMA 20, close immediately (even if Target/Stop not hit)\r\nif strategy.position_size > 0 and ta.crossunder(realClose, alma20)\r\n    strategy.close(\"Long Div\", comment=\"Rev Exit\")\r\n\r\nif strategy.position_size < 0 and ta.crossover(realClose, alma20)\r\n    strategy.close(\"Short Div\", comment=\"Rev Exit\")\r\n\r\n// â”€â”€â”€â”€â”€ VISUALS â”€â”€â”€â”€â”€\r\n\r\nplot(alma20, \"ALMA 20\", color=color.blue, linewidth=2)\r\n\r\n// Divergence Labels\r\nplotshape(bullDiv, title=\"Bull Div\", style=shape.labelup, location=location.belowbar, color=color.green, text=\"DIV\", textcolor=color.white, offset=-lb)\r\nplotshape(bearDiv, title=\"Bear Div\", style=shape.labeldown, location=location.abovebar, color=color.red, text=\"DIV\", textcolor=color.white, offset=-lb)\r\n\r\n// Entry Signals\r\nplotshape(longCondition, title=\"Long Entry\", style=shape.triangleup, location=location.belowbar, color=color.lime, size=size.small, text=\"GO\")\r\nplotshape(shortCondition, title=\"Short Entry\", style=shape.triangledown, location=location.abovebar, color=color.maroon, size=size.small, text=\"GO\")\r\n\r\n// Debugging Lines (Show SL and TP when in trade) - SAFE PLOTTING\r\n// We force the value to 'na' if we are flat, preventing errors\r\nplot(strategy.position_size > 0 ? longStopPrice : na, \"Long SL\", color=color.red, style=plot.style_linebr)\r\nplot(strategy.position_size > 0 and useTP ? longTpPrice : na, \"Long TP\", color=color.green, style=plot.style_linebr)\r\nplot(strategy.position_size < 0 ? shortStopPrice : na, \"Short SL\", color=color.red, style=plot.style_linebr)\r\nplot(strategy.position_size < 0 and useTP ? shortTpPrice : na, \"Short TP\", color=color.green, style=plot.style_linebr)"
  },
  {
    "url": "Z8Eunvao-First-Fvg-Strategy-with-CHoCH-Exits-Adaptive-TP-Entry-Timer",
    "name": "First Fvg Strategy with CHoCH Exits, Adaptive TP & Entry Timer",
    "description": "A strategy that is purely based off of prices reaction to the first presented fair value gap at 9:30 market open. Works best on NASDAQ one minute timeframe. Experimental indicator for me to back test first presented fair value gap.",
    "image_url": "Z8Eunvao",
    "author": "yaweeh",
    "likes": 10,
    "type": "strategy",
    "created": "2025-11-29",
    "updated": "2025-11-29",
    "source": "//@version=5\r\nstrategy(\"Session First FVG Strategy with CHoCH Exits, Adaptive TP & Entry Cooldown\", overlay=true, margin_long=100, margin_short=100)\r\n\r\nsession_input = input.session(\"1600-1700\", \"FVG Session Time\")\r\ntrading_session = input.session(\"0930-1600\", \"Trading Hours (No Entries After)\")\r\n\r\n// Cooldown after every exit\r\ncooldown_bars = input.int(6, \"Cooldown Bars After Exit\")\r\nvar int cooldown = 0\r\n\r\n// Each bar, decrement cooldown\r\nif cooldown > 0\r\n    cooldown -= 1\r\n\r\n// ATR for adaptive TP\r\nuse_atr_tp = input.bool(true, \"Use ATR-based Take Profit\")\r\natr_period = input.int(14, \"ATR Period\")\r\ntp_mult = input.float(6.0, \"TP ATR Multiplier\")\r\n\r\n// Pivot settings for CHoCH (using fractal-like pivots, left/right=2 for 5-bar fractals)\r\npivot_left = input.int(2, \"Pivot Left Bars\")\r\npivot_right = input.int(2, \"Pivot Right Bars\")\r\n\r\n// Check if current bar is within the user-defined session\r\nin_session = not na(time(timeframe.period, session_input))\r\n\r\n// Check if within trading hours for entries\r\ncan_trade = not na(time(timeframe.period, trading_session))\r\n\r\n// Detect new session start\r\nnew_session = in_session and not in_session[1]\r\n\r\n// Variables to store the first FVG midpoint and type\r\nvar bool found = false\r\nvar float fvg_mid = na\r\nvar bool is_bull_fvg = false\r\nvar float fvg_bottom = na\r\nvar float fvg_top = na\r\nvar box fvg_box = na\r\n\r\n// Reset at new session\r\nif new_session\r\n    found := false\r\n    fvg_mid := na\r\n    fvg_bottom := na\r\n    fvg_top := na\r\n    if not na(fvg_box)\r\n        box.delete(fvg_box)\r\n    fvg_box := na\r\n\r\n// Detect FVGs\r\nbull_fvg = low > high[2]\r\nbear_fvg = high < low[2]\r\n\r\n// Find the first FVG in the session\r\nif in_session and not found and (bull_fvg or bear_fvg)\r\n    float bottom = na\r\n    float top = na\r\n    if bull_fvg\r\n        bottom := high[2]\r\n        top := low\r\n        is_bull_fvg := true\r\n    else if bear_fvg\r\n        bottom := high\r\n        top := low[2]\r\n        is_bull_fvg := false\r\n    fvg_mid := (bottom + top) / 2\r\n    fvg_bottom := bottom\r\n    fvg_top := top\r\n    found := true\r\n    \r\n    // Draw the FVG box\r\n    color c = is_bull_fvg ? color.green : color.red\r\n    fvg_box := box.new(bar_index - 2, bottom, bar_index + 100, top, xloc = xloc.bar_index, extend = extend.right, border_color = na, bgcolor = color.new(c, 80))\r\n\r\n// Plot the 50% line\r\nplot(fvg_mid, \"50% FVG Line\", color = color.blue, linewidth = 2, style = plot.style_linebr)\r\n\r\n// Trading logic if FVG mid is set\r\nif not na(fvg_mid)\r\n    // Rejection Long: Price above, touches but closes above\r\n    long_reject = (close[1] > fvg_mid) and (low <= fvg_mid) and (close > fvg_mid)\r\n    \r\n    // Rejection Short: Price below, touches but closes below\r\n    short_reject = (close[1] < fvg_mid) and (high >= fvg_mid) and (close < fvg_mid)\r\n    \r\n    // Breakout Long: Closes above from below\r\n    long_break = ta.crossover(close, fvg_mid)\r\n    \r\n    // Breakout Short: Closes below from above\r\n    short_break = ta.crossunder(close, fvg_mid)\r\n    \r\n    // Inversion conditions (strong break in opposite direction)\r\n    bull_fvg_inversion = ta.crossunder(close, fvg_bottom)  // For bull FVG, inversion to downside (close below bottom)\r\n    bear_fvg_inversion = ta.crossover(close, fvg_top)      // For bear FVG, inversion to upside (close above top)\r\n    \r\n    // Asymmetric entries based on FVG type, only at bar close\r\n    if is_bull_fvg\r\n        // Prefer longs, short only on inversion\r\n        if (long_reject or long_break) and cooldown <= 0 and can_trade and barstate.isconfirmed\r\n            strategy.entry(\"FVG Long\", strategy.long)\r\n            alert(\"FVG Long Entry\", alert.freq_once_per_bar_close)\r\n        if bull_fvg_inversion and cooldown <= 0 and can_trade and barstate.isconfirmed\r\n            strategy.entry(\"FVG Short\", strategy.short)\r\n            alert(\"FVG Short Entry (Inversion)\", alert.freq_once_per_bar_close)\r\n    else\r\n        // Prefer shorts, long only on inversion\r\n        if (short_reject or short_break) and cooldown <= 0 and can_trade and barstate.isconfirmed\r\n            strategy.entry(\"FVG Short\", strategy.short)\r\n            alert(\"FVG Short Entry\", alert.freq_once_per_bar_close)\r\n        if bear_fvg_inversion and cooldown <= 0 and can_trade and barstate.isconfirmed\r\n            strategy.entry(\"FVG Long\", strategy.long)\r\n            alert(\"FVG Long Entry (Inversion)\", alert.freq_once_per_bar_close)\r\n\r\n// Detect closed trades and set cooldown after every exit\r\nif strategy.closedtrades > strategy.closedtrades[1]\r\n    cooldown := cooldown_bars\r\n\r\n// CHoCH Detection\r\nph = ta.pivothigh(high, pivot_left, pivot_right)\r\npl = ta.pivotlow(low, pivot_left, pivot_right)\r\n\r\nvar float last_ph = na\r\nvar float prev_ph = na\r\nvar float last_pl = na\r\nvar float prev_pl = na\r\n\r\nif not na(ph)\r\n    prev_ph := last_ph\r\n    last_ph := ph\r\n\r\nif not na(pl)\r\n    prev_pl := last_pl\r\n    last_pl := pl\r\n\r\nvar bool is_bull_trend = na(close[1]) ? true : close > close[1]  // Initial assumption\r\n\r\nbool bos_bull = false\r\nbool choch_bear = false\r\nbool bos_bear = false\r\nbool choch_bull = false\r\n\r\nif is_bull_trend\r\n    if close > last_ph\r\n        bos_bull := true\r\n    if close < last_pl\r\n        choch_bear := true\r\n        is_bull_trend := false\r\nelse\r\n    if close < last_pl\r\n        bos_bear := true\r\n    if close > last_ph\r\n        choch_bull := true\r\n        is_bull_trend := true\r\n\r\n// Plot CHoCH labels for visualization\r\nif choch_bull\r\n    label.new(bar_index, high, \"CHoCH Bull\", color=color.green, style=label.style_label_down)\r\nif choch_bear\r\n    label.new(bar_index, low, \"CHoCH Bear\", color=color.red, style=label.style_label_up)\r\n\r\n// Use CHoCH as exit signals, only at bar close\r\nif choch_bear and strategy.position_size > 0 and barstate.isconfirmed\r\n    strategy.close(\"FVG Long\", comment=\"CHoCH Bear Exit\")\r\n    alert(\"CHoCH Bear Exit (Close Long)\", alert.freq_once_per_bar_close)\r\nif choch_bull and strategy.position_size < 0 and barstate.isconfirmed\r\n    strategy.close(\"FVG Short\", comment=\"CHoCH Bull Exit\")\r\n    alert(\"CHoCH Bull Exit (Close Short)\", alert.freq_once_per_bar_close)\r\n\r\n// Adaptive TP using ATR (applied after any entry)\r\nif strategy.position_size != strategy.position_size[1] and strategy.position_size > 0 and use_atr_tp\r\n    float entry_price = strategy.position_avg_price\r\n    float atr_val = ta.atr(atr_period)\r\n    strategy.exit(\"TP Long\", \"FVG Long\", limit=entry_price + tp_mult * atr_val)\r\nif strategy.position_size != strategy.position_size[1] and strategy.position_size < 0 and use_atr_tp\r\n    float entry_price = strategy.position_avg_price\r\n    float atr_val = ta.atr(atr_period)\r\n    strategy.exit(\"TP Short\", \"FVG Short\", limit=entry_price - tp_mult * atr_val)"
  },
  {
    "url": "xbWfJunv-Smart-Bottom-Catcher-Le-D",
    "name": "Smart Bottom Catcher @ Le D",
    "description": "Reversal strategy using recent lowest lows and a fast RSI. Long entries trigger on extreme drops, exits occur when RSI crosses a set threshold. Includes optional SMA55 filter and allows up to 3 pyramids.",
    "image_url": "xbWfJunv",
    "author": "denys6de18",
    "likes": 20,
    "type": "strategy",
    "created": "2025-11-28",
    "updated": "2025-11-28",
    "source": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// Â© I11L\n\n//@version=5\nstrategy(\"Smart Bottom Catcher @ Le D\", overlay=false, pyramiding=3, default_qty_value=10000, initial_capital=10000, default_qty_type=strategy.cash,process_orders_on_close=true, calc_on_every_tick=false)\n\nlowestPointBars = input.int(7)\nrsiLength = input.int(2)\nsellBarrier = input.int(70, step=55)\nonlyBuyWhenAbove55Average = input.bool(false)\n\nisLowest = ta.lowest(close,lowestPointBars*(strategy.opentrades+1)) == close\nisHighest = ta.rsi(close,rsiLength) > sellBarrier\n\nisBuy = isLowest and (strategy.position_avg_price * (1-0.01*strategy.opentrades) > close or strategy.opentrades == 0) and (close > ta.sma(close, 55) or not(onlyBuyWhenAbove55Average))\nisClose = isHighest\n\nplot(ta.rsi(close,rsiLength), color=isBuy ? color.green : isLowest ? color.yellow : color.white)\nplot(sellBarrier, color=color.red)\n\nif(isBuy)\n    strategy.entry(\"Buy\"+str.tostring(strategy.opentrades+1),strategy.long, comment=\"#\"+str.tostring(strategy.opentrades+1))\n\nif(isClose)\n    strategy.exit(\"Close\",limit=close)\n\n\n\n"
  },
  {
    "url": "FM0NqXZL-GOLD-EMA-Crossover-Strategy",
    "name": "GOLD EMA Crossover Strategy ",
    "description": "This EMA Crossover Strategy is designed for intraday trading on the 5-minute chart.\nIt uses three EMAs (fast, mid, slow) to identify momentum shifts and trigger long or short entries. Risk management is dollar-based, with default settings of $100 risk per trade and $300 profit target. Entries are taken when the fast EMA crosses above/below the mid or slow EMA, with stops and targets calculated dynamically. The strategy runs across all hours and uses fixed position sizing (default 3 contracts). It is intended as a framework for traders to adapt and optimize to their own instruments and risk preferences.",
    "image_url": "FM0NqXZL",
    "author": "crtaylor55",
    "likes": 16,
    "type": "strategy",
    "created": "2025-11-28",
    "updated": "2025-11-28",
    "source": "//@version=5\r\nstrategy(\"EMA Crossover Strategy ($300 TP, 5-Minute, All Hours)\", overlay=true, default_qty_type=strategy.fixed, default_qty_value=3)\r\n\r\n// === INPUTS ===\r\nemaFastLen     = input.int(9, title=\"Fast EMA Length\")\r\nemaMidLen      = input.int(20, title=\"Mid EMA Length\")\r\nemaSlowLen     = input.int(55, title=\"Slow EMA Length\")\r\ndollarRisk     = input.float(100, title=\"Risk per Trade ($)\")\r\ndollarTarget   = input.float(300, title=\"Profit Target per Trade ($)\")\r\n\r\n// === INDICATORS ===\r\nemaFast = ta.ema(close, emaFastLen)\r\nemaMid  = ta.ema(close, emaMidLen)\r\nemaSlow = ta.ema(close, emaSlowLen)\r\n\r\n// === CROSSOVER CONDITIONS ===\r\ncrossUpMid  = ta.crossover(emaFast, emaMid)\r\ncrossDownMid = ta.crossunder(emaFast, emaMid)\r\ncrossUpSlow = ta.crossover(emaFast, emaSlow)\r\ncrossDownSlow = ta.crossunder(emaFast, emaSlow)\r\n\r\n// === ENTRY CONDITIONS ===\r\nlongEntry  = crossUpMid or crossUpSlow\r\nshortEntry = crossDownMid or crossDownSlow\r\n\r\n// === DOLLAR-BASED STOPS AND TARGETS ===\r\ntickSize = syminfo.mintick\r\ncontractSize = 3\r\nlongStop = close - dollarRisk / (tickSize * contractSize)\r\nshortStop = close + dollarRisk / (tickSize * contractSize)\r\nlongTP   = close + dollarTarget / (tickSize * contractSize)\r\nshortTP  = close - dollarTarget / (tickSize * contractSize)\r\n\r\n// === STRATEGY EXECUTION ===\r\nif (longEntry)\r\n    strategy.entry(\"Long\", strategy.long)\r\n    strategy.exit(\"Exit Long\", from_entry=\"Long\", stop=longStop, limit=longTP)\r\n\r\nif (shortEntry)\r\n    strategy.entry(\"Short\", strategy.short)\r\n    strategy.exit(\"Exit Short\", from_entry=\"Short\", stop=shortStop, limit=shortTP)\r\n"
  },
  {
    "url": "dUabjbqi",
    "name": "Mustang Algo - Momentum Trend Zone Backtest",
    "description": "ðŸŽ MUSTANG ALGO - Momentum Trend Zone Strategy\n\nA complete trading system combining MACD momentum analysis with visual trend zones, full backtesting capabilities, and advanced risk management tools.\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nðŸ”¹ OVERVIEW\n\nMustang Algo transforms traditional MACD analysis into a powerful visual trading system. It instantly identifies market bias through colored background zones and provides clear entry/exit signals with customizable stop loss and take profit management.\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nðŸ”¹ KEY FEATURES\n\nâœ… Visual Trend Zones (Green = Bullish | Red = Bearish)\nâœ… Clear Buy/Sell Triangles on Chart\nâœ… Full Backtesting Engine\nâœ… Multiple Stop Loss Types\nâœ… Multiple Take Profit Types\nâœ… Trailing Stop Option\nâœ… Time Filter for Backtesting\nâœ… Real-time Info Panel\nâœ… Customizable Alerts\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nðŸ”¹ HOW IT WORKS\n\nThe strategy uses a smoothed MACD system to detect trend changes:\n\n- MACD Line (White): Fast EMA minus Slow EMA - shows raw momentum\n- Signal Line (Yellow): EMA of MACD - shows smoothed trend direction\n- Trend Zone: Changes when the smoothed signal line crosses zero\n- Entry Signals: Generated at zone transitions\n\nWhen the trend line crosses above zero â†’ GREEN zone â†’ BUY signal ðŸ”º\nWhen the trend line crosses below zero â†’ RED zone â†’ SELL signal ðŸ”»\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nðŸ”¹ STOP LOSS OPTIONS\n\nðŸ›‘ Percentage: Fixed percentage from entry price\nðŸ›‘ ATR-Based: Dynamic SL based on market volatility\nðŸ›‘ Fixed Points: Set number of points/pips\nðŸ›‘ Swing Low/High: Uses recent swing levels as stops\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nðŸ”¹ TAKE PROFIT OPTIONS\n\nðŸŽ¯ Percentage: Fixed percentage target\nðŸŽ¯ ATR-Based: Dynamic TP based on volatility\nðŸŽ¯ Fixed Points: Set number of points/pips\nðŸŽ¯ Risk Reward: Automatic TP based on R:R ratio (e.g., 2:1, 3:1)\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nðŸ”¹ TRAILING STOP\n\nðŸ“ˆ Percentage-Based: Trail by a fixed percentage\nðŸ“ˆ ATR-Based: Trail using ATR multiplier for dynamic adjustment\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nðŸ”¹ SETTINGS\n\nMACD Parameters:\n- Fast Length (default: 12)\n- Slow Length (default: 26)\n- Signal Length (default: 9)\n- Trend Smoothing (default: 5)\n\nRisk Management:\n- Enable/Disable Stop Loss\n- Enable/Disable Take Profit\n- Enable/Disable Trailing Stop\n- Customize all SL/TP parameters\n\nVisual Options:\n- Show/Hide Buy/Sell Triangles\n- Show/Hide SL/TP Lines\n- Show/Hide Labels\n\nTime Filter:\n- Set Start Date for backtest\n- Set End Date for backtest\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nðŸ”¹ SIGNALS EXPLAINED\n\nðŸŸ¢ GREEN TRIANGLE (Below Bar): \n   Bullish zone detected - Consider LONG entry\n\nðŸ”´ RED TRIANGLE (Above Bar): \n   Bearish zone detected - Consider SHORT entry\n\nðŸŸ¢ GREEN BACKGROUND: \n   Currently in bullish trend zone\n\nðŸ”´ RED BACKGROUND: \n   Currently in bearish trend zone\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nðŸ”¹ INFO PANEL\n\nThe real-time info panel (top right) displays:\n- Current Trend Zone status\n- MACD value\n- Signal Line value\n- Active SL Type\n- Active TP Type\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nðŸ”¹ ALERTS\n\nSet up alerts for:\nðŸ”” Buy Signals: \"ðŸŽ Mustang Algo: BUY Signal on {ticker} at {price}\"\nðŸ”” Sell Signals: \"ðŸŽ Mustang Algo: SELL Signal on {ticker} at {price}\"\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nðŸ”¹ BEST PRACTICES\n\n1. Use higher timeframes (1H, 4H, Daily) for more reliable signals\n2. Combine with price action and support/resistance levels\n3. Adjust ATR multipliers based on asset volatility\n4. Use Risk Reward ratio for consistent risk management\n5. Backtest on your preferred asset before live trading\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nðŸ”¹ RECOMMENDED TIMEFRAMES\n\nâ±ï¸ Scalping: 5M, 15M (more signals, more noise)\nâ±ï¸ Day Trading: 1H, 4H (balanced signals)\nâ±ï¸ Swing Trading: Daily, Weekly (fewer but stronger signals)\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nðŸ”¹ MARKETS\n\nWorks on all markets:\nðŸ“ˆ Forex\nðŸ“ˆ Crypto\nðŸ“ˆ Stocks\nðŸ“ˆ Indices\nðŸ“ˆ Commodities\nðŸ“ˆ Futures\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nðŸŽ RIDE THE TREND WITH MUSTANG ALGO!\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nâš ï¸ DISCLAIMER\n\nThis indicator/strategy is for educational and informational purposes only. It is not financial advice. Trading involves substantial risk of loss and is not suitable for all investors. Past performance is not indicative of future results. Always use proper risk management, do your own research, and consider consulting a financial advisor before making any trading decisions. Use at your own risk.\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nðŸ“ VERSION HISTORY\n\nv1.0 - Initial Release\n- MACD-based trend detection\n- Visual trend zones\n- Multiple SL/TP options\n- Full backtesting support\n- Trailing stop functionality\n- Time filter\n- Info panel\n- Alert system\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nðŸ’¬ FEEDBACK\n\nIf you find this strategy useful, please leave a comment or suggestion!\nYour feedback helps improve future updates.\n\nðŸŽ Happy Trading!",
    "image_url": "dUabjbqi",
    "author": "MustangAlgo",
    "likes": 17,
    "type": "strategy",
    "created": "2025-11-28",
    "updated": "2025-11-28",
    "source": "//@version=5\nstrategy(\"Mustang Algo - Momentum Trend Zone\", overlay=true, default_qty_type=strategy.percent_of_equity, default_qty_value=100, initial_capital=10000, commission_type=strategy.commission.percent, commission_value=0.1)\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// ðŸŽ MUSTANG ALGO - PARAMÃˆTRES\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n// === MACD SETTINGS ===\ngrpMACD = \"MACD Settings\"\nfastLength = input.int(12, \"Fast Length\", minval=1, group=grpMACD)\nslowLength = input.int(26, \"Slow Length\", minval=1, group=grpMACD)\nsignalLength = input.int(9, \"Signal Length\", minval=1, group=grpMACD)\nsmoothLength = input.int(5, \"Trend Smoothing\", minval=1, group=grpMACD)\n\n// === STOP LOSS SETTINGS ===\ngrpSL = \"Stop Loss Settings\"\nuseStopLoss = input.bool(true, \"Enable Stop Loss\", group=grpSL)\nslType = input.string(\"Percentage\", \"Stop Loss Type\", options=[\"Percentage\", \"ATR\", \"Fixed Points\", \"Swing Low/High\"], group=grpSL)\nslPercentage = input.float(2.0, \"SL Percentage %\", minval=0.1, step=0.1, group=grpSL)\nslATRMultiplier = input.float(1.5, \"SL ATR Multiplier\", minval=0.1, step=0.1, group=grpSL)\nslATRLength = input.int(14, \"SL ATR Length\", minval=1, group=grpSL)\nslFixedPoints = input.float(50, \"SL Fixed Points\", minval=1, group=grpSL)\nslSwingLength = input.int(10, \"SL Swing Lookback\", minval=1, group=grpSL)\n\n// === TAKE PROFIT SETTINGS ===\ngrpTP = \"Take Profit Settings\"\nuseTakeProfit = input.bool(true, \"Enable Take Profit\", group=grpTP)\ntpType = input.string(\"Percentage\", \"Take Profit Type\", options=[\"Percentage\", \"ATR\", \"Fixed Points\", \"Risk Reward\"], group=grpTP)\ntpPercentage = input.float(4.0, \"TP Percentage %\", minval=0.1, step=0.1, group=grpTP)\ntpATRMultiplier = input.float(3.0, \"TP ATR Multiplier\", minval=0.1, step=0.1, group=grpTP)\ntpATRLength = input.int(14, \"TP ATR Length\", minval=1, group=grpTP)\ntpFixedPoints = input.float(100, \"TP Fixed Points\", minval=1, group=grpTP)\ntpRiskReward = input.float(2.0, \"Risk Reward Ratio\", minval=0.1, step=0.1, group=grpTP)\n\n// === TRAILING STOP SETTINGS ===\ngrpTrail = \"Trailing Stop Settings\"\nuseTrailingStop = input.bool(false, \"Enable Trailing Stop\", group=grpTrail)\ntrailType = input.string(\"Percentage\", \"Trailing Type\", options=[\"Percentage\", \"ATR\"], group=grpTrail)\ntrailPercentage = input.float(1.5, \"Trail Percentage %\", minval=0.1, step=0.1, group=grpTrail)\ntrailATRMultiplier = input.float(2.0, \"Trail ATR Multiplier\", minval=0.1, step=0.1, group=grpTrail)\n\n// === VISUAL SETTINGS ===\ngrpVisual = \"Visual Settings\"\nshowSignals = input.bool(true, \"Show Buy/Sell Triangles\", group=grpVisual)\nshowSLTP = input.bool(true, \"Show SL/TP Lines\", group=grpVisual)\nshowLabels = input.bool(true, \"Show Labels\", group=grpVisual)\n\n// === TIME FILTER ===\ngrpTime = \"Time Filter\"\nuseTimeFilter = input.bool(false, \"Enable Time Filter\", group=grpTime)\nstartDate = input.time(timestamp(\"2020-01-01\"), \"Start Date\", group=grpTime)\nendDate = input.time(timestamp(\"2030-12-31\"), \"End Date\", group=grpTime)\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// ðŸŽ CALCULS MACD\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nfastMA = ta.ema(close, fastLength)\nslowMA = ta.ema(close, slowLength)\nmacdLine = fastMA - slowMA\nsignalLine = ta.ema(macdLine, signalLength)\nhistogram = macdLine - signalLine\ntrendLine = ta.sma(signalLine, smoothLength)\n\n// === DÃ‰TECTION DE ZONE ===\nvar bool inBullZone = false\nif ta.crossover(trendLine, 0)\n    inBullZone := true\nif ta.crossunder(trendLine, 0)\n    inBullZone := false\n\n// === SIGNAUX ===\nbuySignal = ta.crossover(trendLine, 0)\nsellSignal = ta.crossunder(trendLine, 0)\n\n// === TIME FILTER ===\ninTimeRange = useTimeFilter ? (time >= startDate and time <= endDate) : true\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// ðŸŽ CALCULS SL/TP\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\natrSL = ta.atr(slATRLength)\natrTP = ta.atr(tpATRLength)\nswingLow = ta.lowest(low, slSwingLength)\nswingHigh = ta.highest(high, slSwingLength)\n\n// === STOP LOSS CALCULATION ===\ncalcStopLossLong() =>\n    switch slType\n        \"Percentage\" => close * (1 - slPercentage / 100)\n        \"ATR\" => close - (atrSL * slATRMultiplier)\n        \"Fixed Points\" => close - slFixedPoints * syminfo.mintick\n        \"Swing Low/High\" => swingLow\n        => close * (1 - slPercentage / 100)\n\ncalcStopLossShort() =>\n    switch slType\n        \"Percentage\" => close * (1 + slPercentage / 100)\n        \"ATR\" => close + (atrSL * slATRMultiplier)\n        \"Fixed Points\" => close + slFixedPoints * syminfo.mintick\n        \"Swing Low/High\" => swingHigh\n        => close * (1 + slPercentage / 100)\n\n// === TAKE PROFIT CALCULATION ===\ncalcTakeProfitLong(slPrice) =>\n    riskAmount = close - slPrice\n    switch tpType\n        \"Percentage\" => close * (1 + tpPercentage / 100)\n        \"ATR\" => close + (atrTP * tpATRMultiplier)\n        \"Fixed Points\" => close + tpFixedPoints * syminfo.mintick\n        \"Risk Reward\" => close + (riskAmount * tpRiskReward)\n        => close * (1 + tpPercentage / 100)\n\ncalcTakeProfitShort(slPrice) =>\n    riskAmount = slPrice - close\n    switch tpType\n        \"Percentage\" => close * (1 - tpPercentage / 100)\n        \"ATR\" => close - (atrTP * tpATRMultiplier)\n        \"Fixed Points\" => close - tpFixedPoints * syminfo.mintick\n        \"Risk Reward\" => close - (riskAmount * tpRiskReward)\n        => close * (1 - tpPercentage / 100)\n\n// === TRAILING STOP CALCULATION ===\ncalcTrailingAmount() =>\n    switch trailType\n        \"Percentage\" => close * trailPercentage / 100\n        \"ATR\" => ta.atr(14) * trailATRMultiplier\n        => close * trailPercentage / 100\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// ðŸŽ VARIABLES DE POSITION\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nvar float entryPrice = na\nvar float stopLossPrice = na\nvar float takeProfitPrice = na\nvar bool isLong = false\nvar bool isShort = false\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// ðŸŽ LOGIQUE DE TRADING\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n// === ENTRÃ‰E LONG ===\nif buySignal and inTimeRange and not isLong\n    entryPrice := close\n    stopLossPrice := useStopLoss ? calcStopLossLong() : na\n    takeProfitPrice := useTakeProfit ? calcTakeProfitLong(stopLossPrice) : na\n    isLong := true\n    isShort := false\n    \n    if useTrailingStop\n        strategy.entry(\"Long\", strategy.long)\n        if useStopLoss and useTakeProfit\n            strategy.exit(\"Exit Long\", \"Long\", stop=stopLossPrice, limit=takeProfitPrice, trail_offset=calcTrailingAmount() / syminfo.mintick, trail_points=calcTrailingAmount() / syminfo.mintick)\n        else if useStopLoss\n            strategy.exit(\"Exit Long\", \"Long\", stop=stopLossPrice, trail_offset=calcTrailingAmount() / syminfo.mintick, trail_points=calcTrailingAmount() / syminfo.mintick)\n        else if useTakeProfit\n            strategy.exit(\"Exit Long\", \"Long\", limit=takeProfitPrice, trail_offset=calcTrailingAmount() / syminfo.mintick, trail_points=calcTrailingAmount() / syminfo.mintick)\n    else\n        strategy.entry(\"Long\", strategy.long)\n        if useStopLoss and useTakeProfit\n            strategy.exit(\"Exit Long\", \"Long\", stop=stopLossPrice, limit=takeProfitPrice)\n        else if useStopLoss\n            strategy.exit(\"Exit Long\", \"Long\", stop=stopLossPrice)\n        else if useTakeProfit\n            strategy.exit(\"Exit Long\", \"Long\", limit=takeProfitPrice)\n\n// === ENTRÃ‰E SHORT ===\nif sellSignal and inTimeRange and not isShort\n    entryPrice := close\n    stopLossPrice := useStopLoss ? calcStopLossShort() : na\n    takeProfitPrice := useTakeProfit ? calcTakeProfitShort(stopLossPrice) : na\n    isShort := true\n    isLong := false\n    \n    if useTrailingStop\n        strategy.entry(\"Short\", strategy.short)\n        if useStopLoss and useTakeProfit\n            strategy.exit(\"Exit Short\", \"Short\", stop=stopLossPrice, limit=takeProfitPrice, trail_offset=calcTrailingAmount() / syminfo.mintick, trail_points=calcTrailingAmount() / syminfo.mintick)\n        else if useStopLoss\n            strategy.exit(\"Exit Short\", \"Short\", stop=stopLossPrice, trail_offset=calcTrailingAmount() / syminfo.mintick, trail_points=calcTrailingAmount() / syminfo.mintick)\n        else if useTakeProfit\n            strategy.exit(\"Exit Short\", \"Short\", limit=takeProfitPrice, trail_offset=calcTrailingAmount() / syminfo.mintick, trail_points=calcTrailingAmount() / syminfo.mintick)\n    else\n        strategy.entry(\"Short\", strategy.short)\n        if useStopLoss and useTakeProfit\n            strategy.exit(\"Exit Short\", \"Short\", stop=stopLossPrice, limit=takeProfitPrice)\n        else if useStopLoss\n            strategy.exit(\"Exit Short\", \"Short\", stop=stopLossPrice)\n        else if useTakeProfit\n            strategy.exit(\"Exit Short\", \"Short\", limit=takeProfitPrice)\n\n// === FERMETURE SUR SIGNAL OPPOSÃ‰ ===\nif sellSignal and isLong\n    strategy.close(\"Long\")\n    isLong := false\n\nif buySignal and isShort\n    strategy.close(\"Short\")\n    isShort := false\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// ðŸŽ AFFICHAGE - TRIANGLES SUR LES BOUGIES\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n// === TRIANGLES D'ACHAT/VENTE ===\nplotshape(showSignals and buySignal, title=\"Buy Triangle\", style=shape.triangleup, location=location.belowbar, color=color.new(color.green, 0), size=size.normal, text=\"BUY\")\nplotshape(showSignals and sellSignal, title=\"Sell Triangle\", style=shape.triangledown, location=location.abovebar, color=color.new(color.red, 0), size=size.normal, text=\"SELL\")\n\n// === LIGNES SL/TP ===\nvar line slLine = na\nvar line tpLine = na\nvar label slLabel = na\nvar label tpLabel = na\n\nif showSLTP and (buySignal or sellSignal) and not na(stopLossPrice)\n    // Supprimer les anciennes lignes\n    line.delete(slLine)\n    line.delete(tpLine)\n    label.delete(slLabel)\n    label.delete(tpLabel)\n    \n    // CrÃ©er nouvelles lignes SL\n    if useStopLoss\n        slLine := line.new(bar_index, stopLossPrice, bar_index + 20, stopLossPrice, color=color.red, style=line.style_dashed, width=2)\n        if showLabels\n            slLabel := label.new(bar_index + 20, stopLossPrice, \"SL: \" + str.tostring(stopLossPrice, format.mintick), color=color.red, textcolor=color.white, style=label.style_label_left, size=size.small)\n    \n    // CrÃ©er nouvelles lignes TP\n    if useTakeProfit\n        tpLine := line.new(bar_index, takeProfitPrice, bar_index + 20, takeProfitPrice, color=color.green, style=line.style_dashed, width=2)\n        if showLabels\n            tpLabel := label.new(bar_index + 20, takeProfitPrice, \"TP: \" + str.tostring(takeProfitPrice, format.mintick), color=color.green, textcolor=color.white, style=label.style_label_left, size=size.small)\n\n// === COULEUR DE FOND (trend zone) ===\nbgcolor(inBullZone ? color.new(color.green, 90) : color.new(color.red, 90))\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// ðŸŽ INDICATEUR SÃ‰PARÃ‰ (PANNEAU INFÃ‰RIEUR)\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n// Pour afficher l'histogramme dans un panneau sÃ©parÃ©, crÃ©er un indicateur sÃ©parÃ©\n// ou utiliser plot avec display=display.pane\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// ðŸŽ ALERTES\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nalertcondition(buySignal, title=\"ðŸŽ Mustang BUY\", message=\"ðŸŽ Mustang Algo: BUY Signal on {{ticker}} at {{close}}\")\nalertcondition(sellSignal, title=\"ðŸŽ Mustang SELL\", message=\"ðŸŽ Mustang Algo: SELL Signal on {{ticker}} at {{close}}\")\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// ðŸŽ TABLE D'INFORMATIONS\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nvar table infoTable = table.new(position.top_right, 2, 6, bgcolor=color.new(color.black, 80), border_width=1)\n\nif barstate.islast\n    table.cell(infoTable, 0, 0, \"ðŸŽ MUSTANG ALGO\", text_color=color.yellow, text_size=size.normal)\n    table.cell(infoTable, 1, 0, \"\", text_color=color.white)\n    \n    table.cell(infoTable, 0, 1, \"Trend Zone:\", text_color=color.white, text_size=size.small)\n    table.cell(infoTable, 1, 1, inBullZone ? \"BULLISH ðŸŸ¢\" : \"BEARISH ðŸ”´\", text_color=inBullZone ? color.green : color.red, text_size=size.small)\n    \n    table.cell(infoTable, 0, 2, \"MACD:\", text_color=color.white, text_size=size.small)\n    table.cell(infoTable, 1, 2, str.tostring(macdLine, \"#.#####\"), text_color=macdLine > 0 ? color.green : color.red, text_size=size.small)\n    \n    table.cell(infoTable, 0, 3, \"Signal:\", text_color=color.white, text_size=size.small)\n    table.cell(infoTable, 1, 3, str.tostring(signalLine, \"#.#####\"), text_color=signalLine > 0 ? color.green : color.red, text_size=size.small)\n    \n    table.cell(infoTable, 0, 4, \"SL Type:\", text_color=color.white, text_size=size.small)\n    table.cell(infoTable, 1, 4, useStopLoss ? slType : \"OFF\", text_color=useStopLoss ? color.orange : color.gray, text_size=size.small)\n    \n    table.cell(infoTable, 0, 5, \"TP Type:\", text_color=color.white, text_size=size.small)\n    table.cell(infoTable, 1, 5, useTakeProfit ? tpType : \"OFF\", text_color=useTakeProfit ? color.teal : color.gray, text_size=size.small)"
  },
  {
    "url": "ix8h3CLn-Third-eye-Strategy",
    "name": "Third eye â€¢ Strategy",
    "description": "Third eye â€¢ Strategy â€“ User Guide \n\n1. Idea & Concept\n\nThird eye â€¢ Strategy combines three things into one system:\n\nIchimoku Cloud â€“ to define market regime and support/resistance.\n\nMoving Average (trend filter) â€“ to trade only in the dominant direction.\n\nCCI (Commodity Channel Index) â€“ to generate precise entry signals on momentum breakouts.\n\nThe script is a strategy, not an indicator: it can backtest entries, exits, SL, TP and BreakEven logic automatically.\n\n2. Indicators Used\n2.1 Ichimoku\n\nStandard Ichimoku settings (by default 9/26/52/26) are used:\n\nConversion Line (Tenkan-sen)\n\nBase Line (Kijun-sen)\n\nLeading Span A & B (Kumo Cloud)\n\nLagging Span is calculated but hidden from the chart (for visual simplicity).\n\nFrom the cloud we derive:\n\nkumoTop â€“ top of the cloud under current price.\n\nkumoBottom â€“ bottom of the cloud under current price.\n\nFlags:\n\nis_above_kumo â€“ price above the cloud.\n\nis_below_kumo â€“ price below the cloud.\n\nis_in_kumo â€“ price inside the cloud.\n\nThese conditions are used as trend / regime filters and for stop-loss & trailing stops.\n\n2.2 Moving Average\n\nYou can optionally display and use a trend MA:\n\nTypes: SMA, EMA, DEMA, WMA\n\nLength: configurable (default 200)\n\nSource: default close\n\nFilter idea:\n\nIf MA Direction Filter is ON:\n\nWhen Close > MA â†’ strategy allows only Long signals.\n\nWhen Close < MA â†’ strategy allows only Short signals.\n\nThe MA is plotted on the chart (if enabled).\n\n2.3 CCI & Panel\n\nThe CCI (Commodity Channel Index) is used for entry timing:\n\nCCI length and source are configurable (default length 20, source hlc3).\n\nTwo thresholds:\n\nCCI Upper Threshold (Long) â€“ default +100\n\nCCI Lower Threshold (Short) â€“ default â€“100\n\nSignals:\n\nLong signal:\nCCI crosses up through the upper threshold\ncci_val  < upper_threshold and cci_val > upper_threshold\n\nShort signal:\nCCI crosses down through the lower threshold\ncci_val  > lower_threshold and cci_val < lower_threshold\n\nThere is a panel (table) in the bottom-right corner:\n\nShows current CCI value.\n\nShows filter status as colored dots:\n\nGreen = filter enabled and passed.\n\nRed = filter enabled and blocking trades.\n\nGray = filter is disabled.\n\nFilters shown in the panel:\n\nIchimoku Cloud filter (Long/Short)\n\nIchimoku Lines filter (Conversion/Base vs Cloud)\n\nMA Direction filter\n\n3. Filters & Trade Direction\n\nAll filters can be turned ON/OFF independently.\n\n3.1 Ichimoku Cloud Filter\n\nPurpose: trade only when price is clearly above or below the Kumo.\n\nLong Cloud Filter (Use Ichimoku Cloud Filter) â€“ when enabled:\n\nLong trades only if close > cloud top.\n\nShort Cloud Filter â€“ when enabled:\n\nShort trades only if close < cloud bottom.\n\nIf the cloud filter is disabled, this condition is ignored.\n\n3.2 Ichimoku Lines Above/Below Cloud\n\nPurpose: stronger trend confirmation: Ichimoku lines should also be on the â€œcorrectâ€ side of the cloud.\n\nLong Lines Filter:\nLong allowed only if Conversion Line and Base Line are both above the cloud.\n\nShort Lines Filter:\nShort allowed only if both lines are below the cloud.\n\nIf this filter is OFF, the conditions are not checked.\n\n3.3 MA Direction Filter\n\nAs described above:\n\nWhen ON:\n\nClose > MA â†’ only Longs.\n\nClose < MA â†’ only Shorts.\n\n4. Anti-Re-Entry Logic (Cloud Touch Reset)\n\nThe strategy uses internal flags to avoid continuous re-entries in the same direction without a reset.\n\nTwo flags:\n\nallowLong\n\nallowShort\n\nAfter a Long entry, allowLong is set to false, allowShort to true.\n\nAfter a Short entry, allowShort is set to false, allowLong to true.\n\nFlags are reset when price touches the Kumo:\n\nIf Low goes into the cloud â†’ allowLong = true\n\nIf High goes into the cloud â†’ allowShort = true\n\nIf Close is inside the cloud â†’ both allowLong and allowShort are set to true\n\nThere is a key option:\n\nWait Position Close Before Flag Reset\n\nIf ON: cloud touch will reset flags only when there is no open position.\n\nIf OFF: flags can be reset even while a trade is open.\n\nThis gives a kind of regime-based re-entry control: after a trend leg, you wait for a â€œcloud interactionâ€ to allow new signals.\n\n5. Risk Management\n\nAll risk management is handled inside the strategy.\n\n5.1 Position Sizing\n\nOrder Size % of Equity â€“ default 10%\nThe strategy calculates:\n\nposition_value = equity * (Order Size % / 100)\nposition_qty   = position_value / close\n\n\nSo position size automatically adapts to your current equity.\n\n5.2 Take Profit Modes\n\nYou can choose one of two TP modes:\n\nPercent\n\nFibonacci\n\n5.2.1 Percent Mode\n\nSingle Take Profit at X% from entry (default 2%).\n\nFor Long:\n\nTP = entry_price * (1 + tp_pct / 100)\n\nFor Short:\n\nTP = entry_price * (1 - tp_pct / 100)\n\nOne strategy.exit per side is used: \"Long TP/SL\" and \"Short TP/SL\".\n\n5.2.2 Fibonacci Mode (2 partial TPs)\n\nIn this mode, TP levels are based on a virtual Fib-style extension between entry and stop-loss.\n\nInputs:\n\nFib TP1 Level (default 1.618)\n\nFib TP2 Level (default 2.5)\n\nTP1 Share % (Fib) (default 50%)\n\nTP2 share is automatically 100% - TP1 share.\n\nProcess for Long:\n\nCompute a reference Stop (see SL section below) â†’ sl_for_fib.\n\nCompute distance: dist = entry_price - sl_for_fib.\n\nTP levels:\n\nTP1 = entry_price + dist * (Fib TP1 Level - 1)\n\nTP2 = entry_price + dist * (Fib TP2 Level - 1)\n\nFor Short, the logic is mirrored.\n\nTwo exits are used:\n\nTP1 â€“ closes TP1 share % of position.\n\nTP2 â€“ closes remaining TP2 share %.\n\nSame stop is used for both partial exits.\n\n5.3 Stop-Loss Modes\n\nYou can choose one of three Stop Loss modes:\n\nStable â€“ fixed % from entry.\n\nIchimoku â€“ fixed level derived from the Kumo.\n\nIchimoku Trailing â€“ dynamic SL following the cloud.\n\n5.3.1 Stable SL\n\nFor Long:\nSL = entry_price * (1 - Stable SL % / 100)\n\nFor Short:\nSL = entry_price * (1 + Stable SL % / 100)\n\nUsed both for Percent TP mode and as reference for Fib TP if Kumo is not available.\n\n5.3.2 Ichimoku SL (fixed, non-trailing)\n\nAt the time of a new trade:\n\nFor Long:\n\nBase SL = cloud bottom minus small offset (%)\n\nFor Short:\n\nBase SL = cloud top plus small offset (%)\n\nThe offset is configurable: Ichimoku SL Offset %.\n\nOnce computed, that SL level is fixed for this trade.\n\n5.3.3 Ichimoku Trailing SL\n\nSimilar to Ichimoku SL, but recomputed each bar:\n\nFor Long:\n\nSL = cloud bottom â€“ offset\n\nFor Short:\n\nSL = cloud top + offset\n\nA red trailing SL line is drawn on the chart to visualize current stop level.\nThis trailing SL is also used as reference for BreakEven and for Fib TP distance.\n\n6. BreakEven Logic (with BE Lines)\n\nBreakEven is optional and supports two modes:\n\nPercent\n\nFibonacci\n\nInputs:\n\nPercent mode:\n\nBE Trigger % (from entry) â€“ move SL to BE when price goes this % in profit.\n\nBE Offset % from entry â€“ SL will be set to entry Â± this offset.\n\nFibonacci mode:\n\nBE Fib Level â€“ Fib level at which BE will be activated (default 1.618, same style as TP).\n\nBE Offset % from entry â€“ how far from entry to place BE stop.\n\nThe logic:\n\nBefore BE is triggered, SL follows its normal mode (Stable/Ichimoku/Ichimoku Trailing).\n\nWhen BE triggers:\n\nFor Long:\n\nNew SL = max(current SL, BE SL).\n\nFor Short:\n\nNew SL = min(current SL, BE SL).\n\nThis means BE will never loosen the stop â€“ only tighten it.\n\nWhen BE is activated, the strategy draws a violet horizontal line at the BreakEven level (once per trade).\n\nBE state is cleared when the position is closed or when a new position is opened.\n\n7. Entry & Exit Logic (Summary)\n7.1 Long Entry\n\nConditions for a Long:\n\nCCI signal:\nCCI crosses up through the upper threshold.\n\nIchimoku Cloud Filter (optional):\nIf enabled â†’ price must be above the Kumo.\n\nIchimoku Lines Filter (optional):\nIf enabled â†’ Conversion Line and Base Line must be above the Kumo.\n\nMA Direction Filter (optional):\nIf enabled â†’ Close must be above the chosen MA.\n\nAnti-re-entry flag:\nallowLong must be true (cloud-based reset).\n\nPosition check:\nLong entries are allowed when current position size â‰¤ 0 (so it can also reverse from short to long).\n\nIf all these conditions are true, the strategy sends:\n\nstrategy.entry(\"Long\", strategy.long, qty = calculated_qty)\n\n\nAfter entry:\n\nallowLong = false\n\nallowShort = true\n\n7.2 Short Entry\n\nSame structure, mirrored:\n\nCCI signal:\nCCI crosses down through the lower threshold.\n\nCloud filter: price must be below cloud (if enabled).\n\nLines filter: conversion & base must be below cloud (if enabled).\n\nMA filter: Close must be below MA (if enabled).\n\nallowShort must be true.\n\nPosition check: position size â‰¥ 0 (allows reversal from long to short).\n\nThen:\n\nstrategy.entry(\"Short\", strategy.short, qty = calculated_qty)\n\n\nFlags update:\n\nallowShort = false\n\nallowLong = true\n\n7.3 Exits\n\nWhile in a position:\n\nThe strategy continuously recalculates SL (depending on chosen mode) and, in Percent mode, TP.\n\nIn Fib mode, fixed TP levels are computed at entry.\n\nBreakEven may raise/tighten the SL if its conditions are met.\n\nExits are executed via strategy.exit:\n\nPercent mode: one TP+SL exit per side.\n\nFib mode: two partial exits (TP1 and TP2) sharing the same SL.\n\nAt position open, the script also draws visual lines:\n\nWhite line â€” entry price.\n\nGreen line(s) â€” TP level(s).\n\nRed line â€” SL (if not using Ichimoku Trailing; with trailing, the red line is updated dynamically).\n\nMaximum of 30 lines are kept to avoid clutter.\n\n8. How to Use the Strategy\n\nChoose market & timeframe\n\nWorks well on trending instruments. Try crypto, FX or indices on H1â€“H4, or intraday if you prefer more trades.\n\nAdjust Ichimoku settings\n\nKeep defaults (9/26/52/26) or adapt to your timeframe.\n\nConfigure Moving Average\n\nTypical: EMA 200 as a trend filter.\n\nTurn MA Direction Filter ON if you want to trade only with the main trend.\n\nSet CCI thresholds\n\nDefault Â±100 is classic.\n\nLower thresholds â†’ more signals, higher noise.\n\nHigher thresholds â†’ fewer but stronger signals.\n\nEnable/disable filters\n\nTurn on Ichimoku Cloud and Ichimoku Lines if you want only â€œcleanâ€ trend trades.\n\nUse Wait Position Close Before Flag Reset to control how often re-entries are allowed.\n\nChoose TP & SL mode\n\nPercent mode is simpler and easier to understand.\n\nFibonacci mode is more advanced: it aligns TP levels with the distance to stop, giving asymmetric RR setups (two partial TPs).\n\nChoose Stable SL for fixed-risk trades, or Ichimoku / Ichimoku Trailing to tie stops to the cloud structure.\n\nSet BreakEven\n\nEnable BE if you want to lock in risk-free trades after a certain move.\n\nPercent mode is straightforward; Fib mode keeps BreakEven in harmony with your Fib TP setup.\n\nRun Backtest & Optimize\n\nPress â€œAdd to chartâ€ â†’ go to Strategy Tester.\n\nAdjust parameters to your market and timeframe.\n\nLook at equity curve, PF, drawdown, average trade, etc.\n\nLive / Paper Trading\n\nAfter youâ€™re satisfied with backtest results, use the strategy to generate signals.\n\nYou can mirror entries/exits manually or connect them to alerts (if you build an alert-based execution layer).",
    "image_url": "ix8h3CLn",
    "author": "RezzoRedPriest",
    "likes": 132,
    "type": "strategy",
    "created": "2025-12-05",
    "updated": "2025-12-05",
    "source": "//@version=6\r\nstrategy(title=\"Third eye â€¢ Strategy\", overlay=true,\r\n     initial_capital=10000,\r\n     pyramiding=0,\r\n     commission_type=strategy.commission.percent,\r\n     commission_value=0.035,\r\n     calc_on_order_fills=true,\r\n     process_orders_on_close=true)\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Ð“Ñ€ÑƒÐ¿Ð¿Ð° 1 â€” Ichimoku\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\ngroup_ichi = \"Ichimoku Settings\"\r\n\r\nconversionPeriods   = input.int(9,  minval=1, title=\"Conversion Line Length\",   group=group_ichi)\r\nbasePeriods         = input.int(26, minval=1, title=\"Base Line Length\",         group=group_ichi)\r\nlaggingSpan2Periods = input.int(52, minval=1, title=\"Leading Span B Length\",    group=group_ichi)\r\ndisplacement        = input.int(26, minval=1, title=\"Lagging Span\",             group=group_ichi)\r\n\r\ndonchian(len) =>\r\n    math.avg(ta.lowest(len), ta.highest(len))\r\n\r\nconversionLine = donchian(conversionPeriods)\r\nbaseLine       = donchian(basePeriods)\r\nleadLine1      = math.avg(conversionLine, baseLine)\r\nleadLine2      = donchian(laggingSpan2Periods)\r\n\r\n// Ichimoku â€” Ð²Ð¸Ð·ÑƒÐ°Ð» 1 Ð² 1, Ð½Ð¾ Ð±ÐµÐ· Lagging Span\r\nplot(conversionLine, color=#2962FF, title=\"Conversion Line\")\r\nplot(baseLine,       color=#B71C1C, title=\"Base Line\")\r\n// Lagging Span ÑÐºÑ€Ñ‹Ñ‚Ð°\r\nplot(close, offset = -displacement + 1, color=#43A047, title=\"Lagging Span\", display=display.none)\r\n\r\np1 = plot(leadLine1, offset = displacement - 1, color=#A5D6A7, title=\"Leading Span A\")\r\np2 = plot(leadLine2, offset = displacement - 1, color=#EF9A9A, title=\"Leading Span B\")\r\n\r\nplot(leadLine1 > leadLine2 ? leadLine1 : leadLine2, offset = displacement - 1, title = \"Kumo Cloud Upper Line\", display = display.none)\r\nplot(leadLine1 < leadLine2 ? leadLine1 : leadLine2, offset = displacement - 1, title = \"Kumo Cloud Lower Line\", display = display.none)\r\n\r\nfill(p1, p2, color = leadLine1 > leadLine2 ? color.rgb(67, 160, 71, 90) : color.rgb(244, 67, 54, 90))\r\n\r\n// Ð—Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ Ð¾Ð±Ð»Ð°ÐºÐ° Ð¿Ð¾Ð´ Ñ‚ÐµÐºÑƒÑ‰ÐµÐ¹ ÑÐ²ÐµÑ‡Ð¾Ð¹ (Ð¿Ð¾ Ð²Ð¸Ð·ÑƒÐ°Ð»Ñƒ)\r\nspanA_at_price = leadLine1[displacement - 1]\r\nspanB_at_price = leadLine2[displacement - 1]\r\nkumoTop        = math.max(spanA_at_price, spanB_at_price)\r\nkumoBottom     = math.min(spanA_at_price, spanB_at_price)\r\n\r\n// Ð¤Ð»Ð°Ð³Ð¸ Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ Ñ†ÐµÐ½Ñ‹ Ð¾Ñ‚Ð½Ð¾ÑÐ¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ Ð¾Ð±Ð»Ð°ÐºÐ°\r\nhasKumo       = not na(kumoTop) and not na(kumoBottom)\r\nis_above_kumo = hasKumo and close > kumoTop\r\nis_below_kumo = hasKumo and close < kumoBottom\r\nis_in_kumo    = hasKumo and close <= kumoTop and close >= kumoBottom\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Ð“Ñ€ÑƒÐ¿Ð¿Ð° 2 â€” Moving Average (Ð²Ð¸Ð·ÑƒÐ°Ð»)\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\ngroup_ma = \"Moving Average\"\r\n\r\nma_enabled = input.bool(true, \"Show Moving Average\", group=group_ma)\r\nma_source  = input.source(close, \"Source\", group=group_ma)\r\nma_length  = input.int(200, \"Length\", minval=1, group=group_ma)\r\nma_type    = input.string(\"EMA\", \"Type\", options = [\"SMA\", \"EMA\", \"DEMA\", \"WMA\"], group=group_ma)\r\nma_color   = input.color(color.new(color.yellow, 0), \"Color\", group=group_ma)\r\n\r\n// Ð Ð°ÑÑ‡Ñ‘Ñ‚ Ð²ÑÐµÑ… Ñ‚Ð¸Ð¿Ð¾Ð² MA\r\nsma_val  = ta.sma(ma_source, ma_length)\r\nema_val  = ta.ema(ma_source, ma_length)\r\ndema_val = 2.0 * ema_val - ta.ema(ema_val, ma_length)\r\nwma_val  = ta.wma(ma_source, ma_length)\r\n\r\n// Ð’Ñ‹Ð±Ð¾Ñ€ Ñ€ÐµÐ¶Ð¸Ð¼Ð°\r\nma_val = ma_type == \"SMA\" ? sma_val : ma_type == \"EMA\" ? ema_val : ma_type == \"DEMA\" ? dema_val : wma_val\r\n\r\nplot(ma_enabled ? ma_val : na, title=\"Moving Average\", color=ma_color, linewidth=2)\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Ð“Ñ€ÑƒÐ¿Ð¿Ð° 3 â€” CCI Ð¸ Ð¿Ð°Ð½ÐµÐ»ÑŒ\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\ngroup_cci = \"CCI Panel\"\r\n\r\ncci_enabled = input.bool(true,  \"Show CCI Panel\", group=group_cci)\r\ncci_length  = input.int(20,     \"CCI Length\",     minval=1, group=group_cci)\r\ncci_src     = input.source(hlc3,\"CCI Source\",                group=group_cci)\r\ncci_bgcol   = input.color(color.new(color.teal, 0),  \"Panel BG Color\", group=group_cci)\r\ncci_textcol = input.color(color.white,                \"Text Color\",    group=group_cci)\r\n\r\n// CCI thresholds Ð´Ð»Ñ ÑÐ¸Ð³Ð½Ð°Ð»Ð¾Ð²\r\ngroup_entry = \"Strategy Entry (CCI)\"\r\ncci_long_thr  = input.float(100.0,  \"CCI Upper Threshold (Long)\",  group=group_entry)\r\ncci_short_thr = input.float(-100.0, \"CCI Lower Threshold (Short)\", group=group_entry)\r\n\r\n// Ð Ð°ÑÑ‡Ñ‘Ñ‚ CCI\r\ncci_ma  = ta.sma(cci_src, cci_length)\r\ncci_val = (cci_src - cci_ma) / (0.015 * ta.dev(cci_src, cci_length))\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Ð“Ñ€ÑƒÐ¿Ð¿Ð° 4 â€” Ð¤Ð¸Ð»ÑŒÑ‚Ñ€Ñ‹ Ichimoku + MA Direction + Ð´Ð¾Ð¿. Ñ„Ð¸Ð»ÑŒÑ‚Ñ€Ñ‹\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\ngroup_filters = \"Filters\"\r\n\r\n// Ð‘Ð°Ð·Ð¾Ð²Ñ‹Ðµ Ichimoku + MA\r\nuse_ichi_cloud = input.bool(true,  \"Use Ichimoku Cloud Filter\", group=group_filters,\r\n     tooltip=\"Long: close above Kumo. Short: close below Kumo.\")\r\nuse_ichi_lines = input.bool(true,  \"Use Ichimoku Lines Above/Below Cloud\", group=group_filters,\r\n     tooltip=\"Long: Conversion & Base above Kumo. Short: below Kumo.\")\r\nuse_ma_dir     = input.bool(true,  \"Use MA Direction Filter\", group=group_filters,\r\n     tooltip=\"Close > MA â†’ only Long; Close < MA â†’ only Short\")\r\nwait_flag_reset_till_flat = input.bool(true, \"Wait Position Close Before Flag Reset\", group=group_filters,\r\n     tooltip=\"If ON, cloud touch resets re-entry flags only when position = 0\")\r\n\r\n// Ð”Ð¾Ð¿. Ñ„Ð¸Ð»ÑŒÑ‚Ñ€Ñ‹: ADX / RSI / NATR / BBWidth\r\nuse_adx_filter   = input.bool(false, \"Use ADX Filter\", group=group_filters)\r\nadx_len          = input.int(14, \"ADX Length\", minval=1, group=group_filters)\r\nadx_long_min     = input.float(15.0, \"ADX: Long min\",  minval=0.0, maxval=100.0, step=0.1, group=group_filters)\r\nadx_long_max     = input.float(60.0, \"ADX: Long max\",  minval=0.0, maxval=100.0, step=0.1, group=group_filters)\r\nadx_short_min    = input.float(15.0, \"ADX: Short min\", minval=0.0, maxval=100.0, step=0.1, group=group_filters)\r\nadx_short_max    = input.float(60.0, \"ADX: Short max\", minval=0.0, maxval=100.0, step=0.1, group=group_filters)\r\n\r\nuse_rsi_filter   = input.bool(false, \"Use RSI Filter\", group=group_filters)\r\nrsi_len          = input.int(14, \"RSI Length\", minval=1, group=group_filters)\r\nrsi_long_min     = input.float(20.0, \"RSI: Long min\",  minval=0.0, maxval=100.0, step=0.1, group=group_filters)\r\nrsi_long_max     = input.float(70.0, \"RSI: Long max\",  minval=0.0, maxval=100.0, step=0.1, group=group_filters)\r\nrsi_short_min    = input.float(30.0, \"RSI: Short min\", minval=0.0, maxval=100.0, step=0.1, group=group_filters)\r\nrsi_short_max    = input.float(80.0, \"RSI: Short max\", minval=0.0, maxval=100.0, step=0.1, group=group_filters)\r\n\r\nuse_natr_filter  = input.bool(false, \"Use NATR Filter\", group=group_filters)\r\nnatr_len         = input.int(14, \"NATR Length\", minval=1, group=group_filters)\r\nnatr_long_min    = input.float(0.5, \"NATR: Long min\",  minval=0.0, maxval=1000.0, step=0.1, group=group_filters)\r\nnatr_long_max    = input.float(5.0, \"NATR: Long max\",  minval=0.0, maxval=1000.0, step=0.1, group=group_filters)\r\nnatr_short_min   = input.float(0.5, \"NATR: Short min\", minval=0.0, maxval=1000.0, step=0.1, group=group_filters)\r\nnatr_short_max   = input.float(5.0, \"NATR: Short max\", minval=0.0, maxval=1000.0, step=0.1, group=group_filters)\r\n\r\nuse_bbw_filter   = input.bool(false, \"Use BBWidth Filter\", group=group_filters)\r\nbbw_len          = input.int(20, \"BB Length\", minval=5, group=group_filters)\r\nbbw_mult         = input.float(2.0, \"BB Mult\", step=0.1, group=group_filters)\r\nbbw_min_trend    = input.float(2.0, \"BBWidth: Min % for trend\", step=0.1, group=group_filters)\r\n\r\n// Ichimoku Cloud\r\nlong_cloud_pass  = is_above_kumo\r\nshort_cloud_pass = is_below_kumo\r\n\r\n// Ichimoku Lines\r\nlong_lines_pass  = hasKumo and not na(conversionLine) and not na(baseLine) and conversionLine > kumoTop and baseLine > kumoTop\r\nshort_lines_pass = hasKumo and not na(conversionLine) and not na(baseLine) and conversionLine < kumoBottom and baseLine < kumoBottom\r\n\r\n// MA Direction\r\nhasMa         = not na(ma_val)\r\nlong_ma_pass  = hasMa and close > ma_val\r\nshort_ma_pass = hasMa and close < ma_val\r\n\r\n// Ð£Ñ‡Ð¸Ñ‚Ñ‹Ð²Ð°ÐµÐ¼ Ð²ÐºÐ»ÑŽÑ‡Ñ‘Ð½Ð½Ð¾ÑÑ‚ÑŒ Ð±Ð°Ð·Ð¾Ð²Ñ‹Ñ… Ñ„Ð¸Ð»ÑŒÑ‚Ñ€Ð¾Ð²\r\nlong_cloud_ok   = not use_ichi_cloud or long_cloud_pass\r\nshort_cloud_ok  = not use_ichi_cloud or short_cloud_pass\r\nlong_lines_ok   = not use_ichi_lines or long_lines_pass\r\nshort_lines_ok  = not use_ichi_lines or short_lines_pass\r\nlong_ma_ok      = not use_ma_dir or long_ma_pass\r\nshort_ma_ok     = not use_ma_dir or short_ma_pass\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ADX\r\ntr = math.max(math.max(high - low, math.abs(high - close[1])), math.abs(low - close[1]))\r\nupMove   = high - high[1]\r\ndownMove = low[1] - low\r\nplusDM   = na(upMove)   ? na : (upMove > downMove and upMove > 0 ? upMove : 0)\r\nminusDM  = na(downMove) ? na : (downMove > upMove and downMove > 0 ? downMove : 0)\r\nsmoothTR      = ta.rma(tr, adx_len)\r\nsmoothPlusDM  = ta.rma(plusDM, adx_len)\r\nsmoothMinusDM = ta.rma(minusDM, adx_len)\r\nplusDI  = 100 * smoothPlusDM  / smoothTR\r\nminusDI = 100 * smoothMinusDM / smoothTR\r\ndiDiff  = math.abs(plusDI - minusDI)\r\ndiSum   = plusDI + minusDI\r\ndx      = diSum == 0 ? 0 : 100 * diDiff / diSum\r\nadx     = ta.rma(dx, adx_len)\r\n\r\nadx_long_ok_raw  = adx >= adx_long_min  and adx <= adx_long_max\r\nadx_short_ok_raw = adx >= adx_short_min and adx <= adx_short_max\r\n\r\nadx_long_pass  = not use_adx_filter or adx_long_ok_raw\r\nadx_short_pass = not use_adx_filter or adx_short_ok_raw\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ RSI\r\nrsi = ta.rsi(close, rsi_len)\r\nrsi_long_ok_raw  = rsi >= rsi_long_min  and rsi <= rsi_long_max\r\nrsi_short_ok_raw = rsi >= rsi_short_min and rsi <= rsi_short_max\r\n\r\nrsi_long_pass  = not use_rsi_filter or rsi_long_ok_raw\r\nrsi_short_pass = not use_rsi_filter or rsi_short_ok_raw\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ NATR\r\nnatr = 100.0 * ta.atr(natr_len) / close\r\nnatr_long_ok_raw  = natr >= natr_long_min  and natr <= natr_long_max\r\nnatr_short_ok_raw = natr >= natr_short_min and natr <= natr_short_max\r\n\r\nnatr_long_pass  = not use_natr_filter or natr_long_ok_raw\r\nnatr_short_pass = not use_natr_filter or natr_short_ok_raw\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ BBWidth\r\nbb_mid = ta.sma(close, bbw_len)\r\nbb_dev = ta.stdev(close, bbw_len)\r\nbb_up  = bb_mid + bbw_mult * bb_dev\r\nbb_dn  = bb_mid - bbw_mult * bb_dev\r\nbb_w   = bb_mid != 0.0 ? (bb_up - bb_dn) / bb_mid * 100.0 : 0.0\r\nbbw_ok = bb_w >= bbw_min_trend\r\nbbw_pass = not use_bbw_filter or bbw_ok\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Session / DOW Filter\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\ngroup_sess = \"Session / DOW Filter\"\r\n\r\nuse_session  = input.bool(false, \"Use Session Window\", group=group_sess)\r\nsess_from    = input.session(\"00:00-23:59\", \"Session HHMM-HHMM\", group=group_sess)\r\nuse_dow      = input.bool(false, \"Use Day-of-Week Filter\", group=group_sess)\r\ndowMon       = input.bool(true, \"Mon\", group=group_sess, inline=\"DOW1\")\r\ndowTue       = input.bool(true, \"Tue\", group=group_sess, inline=\"DOW1\")\r\ndowWed       = input.bool(true, \"Wed\", group=group_sess, inline=\"DOW1\")\r\ndowThu       = input.bool(true, \"Thu\", group=group_sess, inline=\"DOW2\")\r\ndowFri       = input.bool(true, \"Fri\", group=group_sess, inline=\"DOW2\")\r\ndowSat       = input.bool(true, \"Sat\", group=group_sess, inline=\"DOW3\")\r\ndowSun       = input.bool(true, \"Sun\", group=group_sess, inline=\"DOW3\")\r\n\r\nsess_ok = not use_session or not na(time(timeframe.period, sess_from))\r\n\r\ndow_ok =\r\n     not use_dow or\r\n     (dayofweek == dayofweek.monday    and dowMon) or\r\n     (dayofweek == dayofweek.tuesday   and dowTue) or\r\n     (dayofweek == dayofweek.wednesday and dowWed) or\r\n     (dayofweek == dayofweek.thursday  and dowThu) or\r\n     (dayofweek == dayofweek.friday    and dowFri) or\r\n     (dayofweek == dayofweek.saturday  and dowSat) or\r\n     (dayofweek == dayofweek.sunday    and dowSun)\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Ð“Ñ€ÑƒÐ¿Ð¿Ð° 5 â€” Ð Ð¸ÑÐº-Ð¼ÐµÐ½ÐµÐ´Ð¶Ð¼ÐµÐ½Ñ‚ (SL + TP)\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\ngroup_risk = \"Risk Management\"\r\n\r\n// Ð ÐµÐ¶Ð¸Ð¼ Ñ‚ÐµÐ¹ÐºÐ¾Ð²\r\ntp_mode = input.string(\"Percent\", \"Take Profit Mode\",\r\n     options = [\"Percent\", \"Fibonacci\"], group=group_risk)\r\n\r\n// ÐŸÑ€Ð¾Ñ†ÐµÐ½Ñ‚Ð½Ñ‹Ð¹ TP\r\ntp_pct = input.float(2.0,  \"Take Profit % (Percent mode)\", minval=0.0, step=0.1, group=group_risk)\r\n\r\n// Ð¤Ð¸Ð±Ð¾-TP\r\nfib_tp1_mult  = input.float(1.618, \"Fib TP1 Level\", minval=1.0, step=0.001, group=group_risk)\r\nfib_tp2_mult  = input.float(2.5,   \"Fib TP2 Level\", minval=1.0, step=0.001, group=group_risk)\r\nfib_tp1_share = input.float(50.0,  \"TP1 Share % (Fib)\", minval=0.0, maxval=100.0, step=1.0, group=group_risk)\r\nfib_tp2_share = 100.0 - fib_tp1_share\r\n\r\nfib_tp1_off = fib_tp1_mult - 1.0\r\nfib_tp2_off = fib_tp2_mult - 1.0\r\n\r\n// Ð¡Ñ‚Ð¾Ð¿Ñ‹\r\nsl_pct = input.float(1.0,  \"Stable Stop Loss %\", minval=0.0, step=0.1, group=group_risk)\r\nsl_mode = input.string(\"Stable\", \"Stop Loss Mode\",\r\n     options = [\"Stable\", \"Ichimoku\", \"Ichimoku Trailing\"], group=group_risk)\r\nichi_sl_offset_pct = input.float(0.1, \"Ichimoku SL Offset %\", minval=0.0, step=0.01, group=group_risk)\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Ð“Ñ€ÑƒÐ¿Ð¿Ð° 6 â€” BreakEven\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\ngroup_be = \"BreakEven\"\r\n\r\nbe_enabled = input.bool(false, \"Use BreakEven\", group=group_be)\r\nbe_mode    = input.string(\"Percent\", \"BreakEven Mode\", options=[\"Percent\", \"Fibonacci\"], group=group_be)\r\n\r\n// Percent-Ñ€ÐµÐ¶Ð¸Ð¼\r\nbe_trig_pct   = input.float(1.0, \"BE Trigger % (from entry)\", minval=0.0, step=0.1, group=group_be)\r\nbe_offset_pct = input.float(0.0, \"BE Offset % from entry\",   minval=0.0, step=0.1, group=group_be)\r\n\r\n// Fibonacci-Ñ€ÐµÐ¶Ð¸Ð¼\r\nbe_fib_level      = input.float(1.618, \"BE Fib Level\",          minval=1.0, step=0.001, group=group_be)\r\nbe_fib_offset_pct = input.float(0.0,   \"BE Offset % from entry\", minval=0.0, step=0.1, group=group_be)\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Ð›Ð¸Ð½Ð¸Ð¸ ÑÐ´ÐµÐ»Ð¾Ðº (Entry/TP/SL/BE)\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nvar array<line> trade_lines = array.new<line>()\r\n\r\nadd_trade_line(_price, _color) =>\r\n    newLine = line.new(bar_index, _price, bar_index + 6, _price, xloc=xloc.bar_index, extend=extend.none, color=_color, width=2)\r\n    array.push(trade_lines, newLine)\r\n    while array.size(trade_lines) > 30\r\n        oldLine = array.shift(trade_lines)\r\n        line.delete(oldLine)\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// ÐÐ½Ñ‚Ð¸-Ð¿ÐµÑ€ÐµÐ·Ð°Ñ…Ð¾Ð´: Ñ„Ð»Ð°Ð³Ð¸\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nvar bool allowLong  = true\r\nvar bool allowShort = true\r\n\r\ncan_reset_flags_now = not wait_flag_reset_till_flat or strategy.position_size == 0\r\n\r\nif hasKumo and can_reset_flags_now\r\n    // LOW Ð² Ð¾Ð±Ð»Ð°ÐºÐµ â†’ ÑÐ½Ð¾Ð²Ð° Ñ€Ð°Ð·Ñ€ÐµÑˆÐ°ÐµÐ¼ Ð»Ð¾Ð½Ð³\r\n    if low <= kumoTop and low >= kumoBottom\r\n        allowLong := true\r\n    // HIGH Ð² Ð¾Ð±Ð»Ð°ÐºÐµ â†’ ÑÐ½Ð¾Ð²Ð° Ñ€Ð°Ð·Ñ€ÐµÑˆÐ°ÐµÐ¼ ÑˆÐ¾Ñ€Ñ‚\r\n    if high >= kumoBottom and high <= kumoTop\r\n        allowShort := true\r\n    // CLOSE Ð² Ð¾Ð±Ð»Ð°ÐºÐµ â†’ Ñ€Ð°Ð·Ñ€ÐµÑˆÐ°ÐµÐ¼ Ð¸ Ð»Ð¾Ð½Ð³, Ð¸ ÑˆÐ¾Ñ€Ñ‚\r\n    if is_in_kumo\r\n        allowLong  := true\r\n        allowShort := true\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Ð¡Ð¸Ð³Ð½Ð°Ð»Ñ‹ CCI\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nlong_signal_raw  = cci_val[1] < cci_long_thr  and cci_val > cci_long_thr\r\nshort_signal_raw = cci_val[1] > cci_short_thr and cci_val < cci_short_thr\r\n\r\n// Ð˜Ñ‚Ð¾Ð³Ð¾Ð²Ñ‹Ðµ ÑƒÑÐ»Ð¾Ð²Ð¸Ñ Ð²Ñ…Ð¾Ð´Ð° (Ñ ÑƒÑ‡Ñ‘Ñ‚Ð¾Ð¼ Ð²ÑÐµÑ… Ñ„Ð¸Ð»ÑŒÑ‚Ñ€Ð¾Ð²)\r\nlong_entry_condition  =\r\n     long_signal_raw  and\r\n     long_cloud_ok    and\r\n     long_lines_ok    and\r\n     long_ma_ok       and\r\n     adx_long_pass    and\r\n     rsi_long_pass    and\r\n     natr_long_pass   and\r\n     bbw_pass         and\r\n     sess_ok          and\r\n     dow_ok           and\r\n     allowLong\r\n\r\nshort_entry_condition =\r\n     short_signal_raw and\r\n     short_cloud_ok   and\r\n     short_lines_ok   and\r\n     short_ma_ok      and\r\n     adx_short_pass   and\r\n     rsi_short_pass   and\r\n     natr_short_pass  and\r\n     bbw_pass         and\r\n     sess_ok          and\r\n     dow_ok           and\r\n     allowShort\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Ð’Ñ…Ð¾Ð´Ñ‹ (Ð»Ð¾Ñ‚ â€” Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð¸Ð· Properties!)\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nstrategy.risk.allow_entry_in(strategy.direction.all)\r\n\r\nif long_entry_condition and strategy.position_size <= 0\r\n    strategy.entry(\"Long\", strategy.long)\r\n    allowLong  := false\r\n    allowShort := true\r\n\r\nif short_entry_condition and strategy.position_size >= 0\r\n    strategy.entry(\"Short\", strategy.short)\r\n    allowShort := false\r\n    allowLong  := true\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Ð¡Ð¾ÑÑ‚Ð¾ÑÐ½Ð¸Ðµ Ð¿Ð¾Ð·Ð¸Ñ†Ð¸Ð¸\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\npos_now  = strategy.position_size\r\npos_prev = nz(strategy.position_size[1], 0)\r\n\r\nlong_in_pos  = pos_now > 0\r\nshort_in_pos = pos_now < 0\r\n\r\nnew_long_open  = pos_now > 0  and pos_prev <= 0\r\nnew_short_open = pos_now < 0  and pos_prev >= 0\r\n\r\navg_price = strategy.position_avg_price\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Ð¤Ð¸ÐºÑÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ðµ SL Ð´Ð»Ñ Ichimoku (ÐÐ• trailing)\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nvar float long_sl_fixed  = na\r\nvar float short_sl_fixed = na\r\n\r\nif new_long_open\r\n    if sl_mode == \"Ichimoku\" and hasKumo\r\n        long_sl_fixed := kumoBottom * (1 - ichi_sl_offset_pct / 100.0)\r\n    else\r\n        long_sl_fixed := na\r\n\r\nif new_short_open\r\n    if sl_mode == \"Ichimoku\" and hasKumo\r\n        short_sl_fixed := kumoTop * (1 + ichi_sl_offset_pct / 100.0)\r\n    else\r\n        short_sl_fixed := na\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Ð”Ð»Ñ Fib TP / BE: SL, Ð¾Ñ‚ ÐºÐ¾Ñ‚Ð¾Ñ€Ð¾Ð³Ð¾ ÑÑ‚Ñ€Ð¾Ð¸Ð¼ Ñ„Ð¸Ð±Ð¾\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nvar float long_sl_for_fib  = na\r\nvar float short_sl_for_fib = na\r\n\r\nvar float long_tp1_fixed  = na\r\nvar float long_tp2_fixed  = na\r\nvar float short_tp1_fixed = na\r\nvar float short_tp2_fixed = na\r\n\r\nif new_long_open\r\n    float sl_for_fib = na\r\n    if sl_mode == \"Stable\" or not hasKumo\r\n        sl_for_fib := avg_price * (1 - sl_pct / 100.0)\r\n    else if sl_mode == \"Ichimoku\"\r\n        sl_for_fib := not na(long_sl_fixed) ? long_sl_fixed : (hasKumo ? kumoBottom * (1 - ichi_sl_offset_pct / 100.0) : avg_price * (1 - sl_pct / 100.0))\r\n    else if sl_mode == \"Ichimoku Trailing\"\r\n        sl_for_fib := hasKumo ? kumoBottom * (1 - ichi_sl_offset_pct / 100.0) : avg_price * (1 - sl_pct / 100.0)\r\n\r\n    long_sl_for_fib := sl_for_fib\r\n\r\n    if tp_mode == \"Fibonacci\" and not na(sl_for_fib)\r\n        float dist = avg_price - sl_for_fib\r\n        long_tp1_fixed := avg_price + dist * fib_tp1_off\r\n        long_tp2_fixed := avg_price + dist * fib_tp2_off\r\n    else if tp_mode == \"Fibonacci\"\r\n        long_tp1_fixed := na\r\n        long_tp2_fixed := na\r\n\r\nif new_short_open\r\n    float sl_for_fib_s = na\r\n    if sl_mode == \"Stable\" or not hasKumo\r\n        sl_for_fib_s := avg_price * (1 + sl_pct / 100.0)\r\n    else if sl_mode == \"Ichimoku\"\r\n        sl_for_fib_s := not na(short_sl_fixed) ? short_sl_fixed : (hasKumo ? kumoTop * (1 + ichi_sl_offset_pct / 100.0) : avg_price * (1 + sl_pct / 100.0))\r\n    else if sl_mode == \"Ichimoku Trailing\"\r\n        sl_for_fib_s := hasKumo ? kumoTop * (1 + ichi_sl_offset_pct / 100.0) : avg_price * (1 + sl_pct / 100.0)\r\n\r\n    short_sl_for_fib := sl_for_fib_s\r\n\r\n    if tp_mode == \"Fibonacci\" and not na(sl_for_fib_s)\r\n        float dist_s = sl_for_fib_s - avg_price\r\n        short_tp1_fixed := avg_price - dist_s * fib_tp1_off\r\n        short_tp2_fixed := avg_price - dist_s * fib_tp2_off\r\n    else if tp_mode == \"Fibonacci\"\r\n        short_tp1_fixed := na\r\n        short_tp2_fixed := na\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// BreakEven: ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ðµ\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nvar bool  long_be_triggered  = false\r\nvar bool  short_be_triggered = false\r\nvar float long_be_sl_fixed   = na\r\nvar float short_be_sl_fixed  = na\r\n\r\n// Ð¡Ð±Ñ€Ð¾Ñ BE Ð¿Ñ€Ð¸ Ð²Ñ‹Ñ…Ð¾Ð´Ðµ\r\nif strategy.position_size == 0\r\n    long_be_triggered  := false\r\n    short_be_triggered := false\r\n    long_be_sl_fixed   := na\r\n    short_be_sl_fixed  := na\r\n\r\n// Ð¡Ð±Ñ€Ð¾Ñ Ð¿Ñ€Ð¸ Ð½Ð¾Ð²Ð¾Ð¼ Ð²Ñ…Ð¾Ð´Ðµ\r\nif new_long_open\r\n    long_be_triggered  := false\r\n    long_be_sl_fixed   := na\r\n    short_be_triggered := false\r\n    short_be_sl_fixed  := na\r\n\r\nif new_short_open\r\n    short_be_triggered := false\r\n    short_be_sl_fixed  := na\r\n    long_be_triggered  := false\r\n    long_be_sl_fixed   := na\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// TP/SL + BE + Ñ‚Ñ€ÐµÐ¹Ð»Ð¸Ð½Ð³\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nfloat long_tp_price  = na\r\nfloat long_sl_price  = na\r\nfloat short_tp_price = na\r\nfloat short_sl_price = na\r\n\r\nvar line trail_sl_line = na\r\n\r\n// LONG\r\nif long_in_pos\r\n    float long_sl_base = na\r\n    if sl_mode == \"Stable\" or not hasKumo\r\n        long_sl_base := avg_price * (1 - sl_pct / 100.0)\r\n    else if sl_mode == \"Ichimoku\"\r\n        long_sl_base := not na(long_sl_fixed) ? long_sl_fixed : (hasKumo ? kumoBottom * (1 - ichi_sl_offset_pct / 100.0) : avg_price * (1 - sl_pct / 100.0))\r\n    else if sl_mode == \"Ichimoku Trailing\"\r\n        long_sl_base := hasKumo ? kumoBottom * (1 - ichi_sl_offset_pct / 100.0) : avg_price * (1 - sl_pct / 100.0)\r\n\r\n    // BreakEven Ñ‚Ñ€Ð¸Ð³Ð³ÐµÑ€\r\n    if be_enabled and not long_be_triggered\r\n        if be_mode == \"Percent\"\r\n            float be_trig_price = avg_price * (1 + be_trig_pct / 100.0)\r\n            if close >= be_trig_price\r\n                long_be_triggered := true\r\n                long_be_sl_fixed  := avg_price * (1 + be_offset_pct / 100.0)\r\n        else if be_mode == \"Fibonacci\" and not na(long_sl_for_fib)\r\n            float dist_be = avg_price - long_sl_for_fib\r\n            float be_off  = be_fib_level - 1.0\r\n            float be_fib_price = avg_price + dist_be * be_off\r\n            if close >= be_fib_price\r\n                long_be_triggered := true\r\n                long_be_sl_fixed  := avg_price * (1 + be_fib_offset_pct / 100.0)\r\n\r\n    // Ð˜Ñ‚Ð¾Ð³Ð¾Ð²Ñ‹Ð¹ SL Ñ ÑƒÑ‡Ñ‘Ñ‚Ð¾Ð¼ BE\r\n    if be_enabled and long_be_triggered and not na(long_be_sl_fixed)\r\n        long_sl_price := math.max(long_sl_base, long_be_sl_fixed)\r\n    else\r\n        long_sl_price := long_sl_base\r\n\r\n    // TP Ð´Ð»Ñ Percent-Ñ€ÐµÐ¶Ð¸Ð¼Ð°\r\n    if tp_mode == \"Percent\"\r\n        long_tp_price := avg_price * (1 + tp_pct / 100.0)\r\n\r\n    // Ð¢Ñ€ÐµÐ¹Ð»Ð¸Ð½Ð³-Ð»Ð¸Ð½Ð¸Ñ Ð¿Ð¾ Ichimoku Trailing\r\n    if sl_mode == \"Ichimoku Trailing\"\r\n        if na(trail_sl_line)\r\n            trail_sl_line := line.new(bar_index, long_sl_price, bar_index + 6, long_sl_price, xloc=xloc.bar_index, extend=extend.none, color=color.new(color.red, 0), width=2)\r\n        else\r\n            line.set_xy1(trail_sl_line, bar_index,     long_sl_price)\r\n            line.set_xy2(trail_sl_line, bar_index + 6, long_sl_price)\r\n\r\n// SHORT\r\nif short_in_pos\r\n    float short_sl_base = na\r\n    if sl_mode == \"Stable\" or not hasKumo\r\n        short_sl_base := avg_price * (1 + sl_pct / 100.0)\r\n    else if sl_mode == \"Ichimoku\"\r\n        short_sl_base := not na(short_sl_fixed) ? short_sl_fixed : (hasKumo ? kumoTop * (1 + ichi_sl_offset_pct / 100.0) : avg_price * (1 + sl_pct / 100.0))\r\n    else if sl_mode == \"Ichimoku Trailing\"\r\n        short_sl_base := hasKumo ? kumoTop * (1 + ichi_sl_offset_pct / 100.0) : avg_price * (1 + sl_pct / 100.0)\r\n\r\n    if be_enabled and not short_be_triggered\r\n        if be_mode == \"Percent\"\r\n            float be_trig_price_s = avg_price * (1 - be_trig_pct / 100.0)\r\n            if close <= be_trig_price_s\r\n                short_be_triggered := true\r\n                short_be_sl_fixed  := avg_price * (1 - be_offset_pct / 100.0)\r\n        else if be_mode == \"Fibonacci\" and not na(short_sl_for_fib)\r\n            float dist_be_s = short_sl_for_fib - avg_price\r\n            float be_off_s  = be_fib_level - 1.0\r\n            float be_fib_price_s = avg_price - dist_be_s * be_off_s\r\n            if close <= be_fib_price_s\r\n                short_be_triggered := true\r\n                short_be_sl_fixed  := avg_price * (1 - be_fib_offset_pct / 100.0)\r\n\r\n    if be_enabled and short_be_triggered and not na(short_be_sl_fixed)\r\n        short_sl_price := math.min(short_sl_base, short_be_sl_fixed)\r\n    else\r\n        short_sl_price := short_sl_base\r\n\r\n    if tp_mode == \"Percent\"\r\n        short_tp_price := avg_price * (1 - tp_pct / 100.0)\r\n\r\n    if sl_mode == \"Ichimoku Trailing\"\r\n        if na(trail_sl_line)\r\n            trail_sl_line := line.new(bar_index, short_sl_price, bar_index + 6, short_sl_price, xloc=xloc.bar_index, extend=extend.none, color=color.new(color.red, 0), width=2)\r\n        else\r\n            line.set_xy1(trail_sl_line, bar_index,     short_sl_price)\r\n            line.set_xy2(trail_sl_line, bar_index + 6, short_sl_price)\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Ð›Ð˜ÐÐ˜Ð˜ ÐŸÐÐ Ð˜Ð¢Ð•Ð¢Ð (Ñ„Ð¸Ð¾Ð»ÐµÑ‚Ð¾Ð²Ñ‹Ðµ)\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nif be_enabled and long_in_pos and long_be_triggered and not long_be_triggered[1] and not na(long_be_sl_fixed)\r\n    add_trade_line(long_be_sl_fixed, #ff2cd1)\r\n\r\nif be_enabled and short_in_pos and short_be_triggered and not short_be_triggered[1] and not na(short_be_sl_fixed)\r\n    add_trade_line(short_be_sl_fixed, #ff3edf)\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Ð’Ñ‹Ñ…Ð¾Ð´Ñ‹: Percent vs Fibonacci\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nif long_in_pos\r\n    if tp_mode == \"Percent\"\r\n        strategy.exit(\"Long TP/SL\", from_entry=\"Long\", limit=long_tp_price, stop=long_sl_price)\r\n    else if tp_mode == \"Fibonacci\" and not na(long_sl_price) and not na(long_tp1_fixed) and not na(long_tp2_fixed)\r\n        strategy.exit(\"Long TP1\", from_entry=\"Long\", limit=long_tp1_fixed, stop=long_sl_price, qty_percent=fib_tp1_share)\r\n        strategy.exit(\"Long TP2\", from_entry=\"Long\", limit=long_tp2_fixed, stop=long_sl_price, qty_percent=fib_tp2_share)\r\n\r\nif short_in_pos\r\n    if tp_mode == \"Percent\"\r\n        strategy.exit(\"Short TP/SL\", from_entry=\"Short\", limit=short_tp_price, stop=short_sl_price)\r\n    else if tp_mode == \"Fibonacci\" and not na(short_sl_price) and not na(short_tp1_fixed) and not na(short_tp2_fixed)\r\n        strategy.exit(\"Short TP1\", from_entry=\"Short\", limit=short_tp1_fixed, stop=short_sl_price, qty_percent=fib_tp1_share)\r\n        strategy.exit(\"Short TP2\", from_entry=\"Short\", limit=short_tp2_fixed, stop=short_sl_price, qty_percent=fib_tp2_share)\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Ð›Ð¸Ð½Ð¸Ð¸ Ð²Ñ…Ð¾Ð´Ð° / TP / SL (Ð¿Ð¾ Ñ„Ð°ÐºÑ‚Ñƒ Ð²Ñ…Ð¾Ð´Ð°)\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nif new_long_open and long_in_pos\r\n    add_trade_line(avg_price, color.new(color.white, 0))\r\n\r\n    if tp_mode == \"Percent\" and not na(long_tp_price)\r\n        add_trade_line(long_tp_price, color.new(color.lime, 0))\r\n    else if tp_mode == \"Fibonacci\"\r\n        if not na(long_tp1_fixed)\r\n            add_trade_line(long_tp1_fixed, color.new(color.lime, 0))\r\n        if not na(long_tp2_fixed)\r\n            add_trade_line(long_tp2_fixed, color.new(color.lime, 40))\r\n\r\n    if sl_mode != \"Ichimoku Trailing\" and not na(long_sl_price)\r\n        add_trade_line(long_sl_price, color.new(color.red, 0))\r\n\r\nif new_short_open and short_in_pos\r\n    add_trade_line(avg_price, color.new(color.white, 0))\r\n\r\n    if tp_mode == \"Percent\" and not na(short_tp_price)\r\n        add_trade_line(short_tp_price, color.new(color.lime, 0))\r\n    else if tp_mode == \"Fibonacci\"\r\n        if not na(short_tp1_fixed)\r\n            add_trade_line(short_tp1_fixed, color.new(color.lime, 0))\r\n        if not na(short_tp2_fixed)\r\n            add_trade_line(short_tp2_fixed, color.new(color.lime, 40))\r\n\r\n    if sl_mode != \"Ichimoku Trailing\" and not na(short_sl_price)\r\n        add_trade_line(short_sl_price, color.new(color.red, 0))\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Ð¢Ð°Ð±Ð»Ð¸Ñ†Ð° CCI + Ñ„Ð¸Ð»ÑŒÑ‚Ñ€Ñ‹\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nf_status_color(enabled, pass) =>\r\n    enabled ? (pass ? color.lime : color.red) : color.gray\r\n\r\nvar table cci_table = na\r\nif na(cci_table)\r\n    // 8 ÑÑ‚Ñ€Ð¾Ðº: 0..7\r\n    cci_table := table.new(position.bottom_right, 3, 8)\r\n\r\nif barstate.islast\r\n    if cci_enabled\r\n        // ÑÑ‚Ñ€Ð¾ÐºÐ° 0: CCI\r\n        string cci_txt = \"CCI (\" + str.tostring(cci_length) + \"): \" + str.tostring(cci_val, format.mintick)\r\n        table.cell(cci_table, 0, 0, cci_txt, text_color=cci_textcol, bgcolor=cci_bgcol)\r\n        table.cell(cci_table, 1, 0, \"\", text_color=cci_textcol, bgcolor=cci_bgcol)\r\n        table.cell(cci_table, 2, 0, \"\", text_color=cci_textcol, bgcolor=cci_bgcol)\r\n\r\n        // ÑÑ‚Ñ€Ð¾ÐºÐ° 1: Ð·Ð°Ð³Ð¾Ð»Ð¾Ð²ÐºÐ¸\r\n        table.cell(cci_table, 0, 1, \"Filter\", text_color=cci_textcol, bgcolor=cci_bgcol)\r\n        table.cell(cci_table, 1, 1, \"L\",      text_color=cci_textcol, bgcolor=cci_bgcol)\r\n        table.cell(cci_table, 2, 1, \"S\",      text_color=cci_textcol, bgcolor=cci_bgcol)\r\n\r\n        // ÑÑ‚Ñ€Ð¾ÐºÐ° 2: Ichi Cloud\r\n        cloud_long_color  = f_status_color(use_ichi_cloud,  long_cloud_pass)\r\n        cloud_short_color = f_status_color(use_ichi_cloud,  short_cloud_pass)\r\n        table.cell(cci_table, 0, 2, \"Ichi Cloud\", text_color=cci_textcol,  bgcolor=cci_bgcol)\r\n        table.cell(cci_table, 1, 2, \"â—\",          text_color=cloud_long_color,  bgcolor=cci_bgcol)\r\n        table.cell(cci_table, 2, 2, \"â—\",          text_color=cloud_short_color, bgcolor=cci_bgcol)\r\n\r\n        // ÑÑ‚Ñ€Ð¾ÐºÐ° 3: Ichi Lines\r\n        lines_long_color  = f_status_color(use_ichi_lines,  long_lines_pass)\r\n        lines_short_color = f_status_color(use_ichi_lines,  short_lines_pass)\r\n        table.cell(cci_table, 0, 3, \"Ichi Lines\", text_color=cci_textcol,   bgcolor=cci_bgcol)\r\n        table.cell(cci_table, 1, 3, \"â—\",          text_color=lines_long_color,  bgcolor=cci_bgcol)\r\n        table.cell(cci_table, 2, 3, \"â—\",          text_color=lines_short_color, bgcolor=cci_bgcol)\r\n\r\n        // ÑÑ‚Ñ€Ð¾ÐºÐ° 4: MA Dir\r\n        ma_long_color  = f_status_color(use_ma_dir, long_ma_pass)\r\n        ma_short_color = f_status_color(use_ma_dir, short_ma_pass)\r\n        table.cell(cci_table, 0, 4, \"MA Dir\", text_color=cci_textcol,   bgcolor=cci_bgcol)\r\n        table.cell(cci_table, 1, 4, \"â—\",      text_color=ma_long_color,  bgcolor=cci_bgcol)\r\n        table.cell(cci_table, 2, 4, \"â—\",      text_color=ma_short_color, bgcolor=cci_bgcol)\r\n\r\n        // ÑÑ‚Ñ€Ð¾ÐºÐ° 5: BBWidth\r\n        bbw_long_color  = f_status_color(use_bbw_filter, bbw_ok)\r\n        bbw_short_color = f_status_color(use_bbw_filter, bbw_ok)\r\n        table.cell(cci_table, 0, 5, \"BBWidth\", text_color=cci_textcol, bgcolor=cci_bgcol)\r\n        table.cell(cci_table, 1, 5, str.tostring(bb_w, format.mintick), text_color=cci_textcol, bgcolor=cci_bgcol)\r\n        table.cell(cci_table, 2, 5, \"â—\", text_color=bbw_long_color, bgcolor=cci_bgcol)\r\n\r\n        // ÑÑ‚Ñ€Ð¾ÐºÐ° 6: NATR\r\n        natr_long_color  = f_status_color(use_natr_filter, natr_long_ok_raw)\r\n        natr_short_color = f_status_color(use_natr_filter, natr_short_ok_raw)\r\n        table.cell(cci_table, 0, 6, \"NATR\", text_color=cci_textcol, bgcolor=cci_bgcol)\r\n        table.cell(cci_table, 1, 6, str.tostring(natr, format.mintick), text_color=cci_textcol, bgcolor=cci_bgcol)\r\n        table.cell(cci_table, 2, 6, \"â—\", text_color=natr_long_color, bgcolor=cci_bgcol)\r\n\r\n        // ÑÑ‚Ñ€Ð¾ÐºÐ° 7: Sess/DOW\r\n        bool sessdow_ok = sess_ok and dow_ok\r\n        sessdow_color = f_status_color(use_session or use_dow, sessdow_ok)\r\n        table.cell(cci_table, 0, 7, \"Sess/DOW\", text_color=cci_textcol, bgcolor=cci_bgcol)\r\n        table.cell(cci_table, 1, 7, sessdow_ok ? \"OK\" : \"BLOCK\", text_color=cci_textcol, bgcolor=cci_bgcol)\r\n        table.cell(cci_table, 2, 7, \"â—\", text_color=sessdow_color, bgcolor=cci_bgcol)\r\n    else\r\n        for r = 0 to 7\r\n            for c = 0 to 2\r\n                table.cell(cci_table, c, r, \"\", text_color=color.new(cci_textcol, 100), bgcolor=color.new(color.white, 100))\r\n"
  },
  {
    "url": "XOyAfu9n-Dual-MTF-Confirmed-Trend-Strategy-5m-Entry-15m-MACD-RSI-v1",
    "name": "Dual MTF Confirmed Trend Strategy (5m Entry / 15m MACD & RSI) v1",
    "description": "That is a detailed Dual Multi-Timeframe (MTF) Confirmed Trend Strategy written in Pine Script for TradingView. The core idea of this strategy is to only take entry signals on a faster timeframe (5-minute) when the trend is strongly confirmed on a slower, higher timeframe (15-minute).  This aims to reduce false signals and trade in the direction of the dominant trend. Here is an explanation of how the strategy works, broken down by section: \n\n1. 5-Minute Entry Filters ðŸš€This section calculates several indicators on the current 5-minute chart to identify potential trade setups. A position is only considered if all 5-minute conditions align.\nSupertrend: A trend-following indicator based on Average True Range (ATR).\nLong Condition: The closing price must be above the Supertrend line.\nShort Condition: The closing price must be below the Supertrend line.\nGann Hi-Lo (GHL): A trend indicator using Simple Moving Averages (SMA) of the high and low prices. GHL Line: Switches between the SMA of the Highs and the SMA of the Lows based on price action.\nLong Condition: The closing price must be above the GHL line. \nShort Condition: The closing price must be below the GHL line. \nExponential Moving Averages (EMAs): It uses a 50-period EMA and a 100-period EMA to confirm the short-term trend direction. \nLong Condition: The closing price must be above both the 50 EMA and the 100 EMA.\nShort Condition: The closing price must be below both the 50 EMA and the 100 EMA.\n\n2. 15-Minute MTF Confirmation Filters â³This is the crucial step where the strategy verifies the trend on the slower, 15-minute timeframe using the request security function. This step acts as a gatekeeper to ensure the 5-minute trade aligns with the larger trend. \nMACD Histogram (12, 26, 9): The difference between the MACD Line and the Signal Line.\nLong Confirmation: The 15m MACD Histogram must be greater than 0 (MACD line is above the Signal line, indicating bullish momentum).\nShort Confirmation: The 15m MACD Histogram must be less than 0 (MACD line is below the Signal line, indicating bearish momentum). \nRSI (Relative Strength Index) (14): A momentum oscillator. The 50 level is often used to determine the general market trend. \nLong Confirmation: The 15m RSI must be greater than 50 (indicating stronger bullish momentum).\nShort Confirmation: The 15m RSI must be less than 50 (indicating stronger bearish momentum).\nThe Total 15m Confirmation is only true if both the MACD and the RSI confirmation signals align.\n\n3. Trade Orders (Entry Logic) âš–ï¸\nThe strategy only executes a trade when the 5-minute entry conditions are met AND the 15-minute confirmation conditions are met.\n\nFinal Long Condition:\n5m Conditions (Supertrend, GHL, EMA alignment) AND\n15m Confirmation (MACD Hist > 0 AND RSI > 50)\n\nFinal Short Condition:\n5m Conditions (Supertrend, GHL, EMA alignment) AND \n15m Confirmation (MACD Hist < 0 AND RSI < 50)\n\nWhen a trade signal is generated, the strategy:\n\nCloses any opposite position (e.g., closes a \"Short\" trade if a \"Long\" signal appears).\n\nEnters the new position (e.g., enters a \"Long\" trade).\n\nThis is designed as a reversal strategy where a new entry automatically closes the previous opposing trade.\n\nIn Summary\nThe strategy operates on a principle of Trend Alignment:\n\n5-Minute Chart: Is used for Signal Timing (when exactly to enter the market).\n\n15-Minute Chart: Is used for Trend Validation (is the overall market momentum supporting the signal?).\n\nIt's an attempt to capture short-term moves (5m signals) that are backed by strong medium-term momentum (15m confirmation), thereby aiming for higher probability trades.\n\nThis is not investment advice; it is recommended to perform optimization and backtesting for the assets intended for implementation.\n",
    "image_url": "XOyAfu9n",
    "author": "mhakany",
    "likes": 9,
    "type": "strategy",
    "created": "2025-11-28",
    "updated": "2025-11-28",
    "source": "//@version=5\nstrategy(\"Dual MTF Confirmed Trend Strategy (5m Entry / 15m MACD & RSI) v1\", overlay=true, initial_capital=10000, default_qty_value=100, default_qty_type=strategy.percent_of_equity)\n\n// --- TIMEFRAME AND INPUT SETTINGS ---\nstring MTF_TIMEFRAME = \"15\" // 15-minute confirmation period\nint RSI_LENGTH = 14\nint MACD_FAST_LEN = 12\nint MACD_SLOW_LEN = 26\nint MACD_SIGNAL_LEN = 9\n\n// --- 1. 5M MAIN ENTRY FILTERS (Current Successful Code) ---\natrPeriod = input.int(10, title=\"5m ST: ATR Period\")\nfactor = input.float(5.3, title=\"5m ST: Multiplier\")\n[supertrend, direction] = ta.supertrend(factor, atrPeriod)\n\n// GANN HI-LO CALCULATION\nHPeriod = input.int(13, '5m GHL: HIGH Period')\nLPeriod = input.int(21, '5m GHL: LOW Period')\nsma_H = ta.sma(high, HPeriod)\nsma_L = ta.sma(low, LPeriod)\n\nvar float HLv_d = 0.0\nif close > sma_H[1]\n    HLv_d := 1\nelse if close < sma_L[1]\n    HLv_d := -1\n\ngannHiLoLine = HLv_d == -1 ? sma_H : sma_L\n\n// 5m EMA CALCULATION\nema50 = ta.ema(close, input.int(50, title=\"5m EMA 50\"))\nema100 = ta.ema(close, input.int(100, title=\"5m EMA 100\"))\n\n// 5m Confirmation Conditions\nlong5mCondition = close > supertrend and close > gannHiLoLine and close > ema50 and close > ema100\nshort5mCondition = close < supertrend and close < gannHiLoLine and close < ema50 and close < ema100\n\n\n// --- 2. 15M MTF CONFIRMATION FILTERS (MACD Histogram and RSI 50 Trend Alignment) ---\n\n// Helper function for MACD Histogram Calculation\nf_macd_hist(source, fastLength, slowLength, signalLength) =>\n    fastMA = ta.ema(source, fastLength)\n    slowMA = ta.ema(source, slowLength)\n    macd = fastMA - slowMA\n    signal = ta.ema(macd, signalLength)\n    macd - signal // Histogram = MACD Line - Signal Line\n\n// Fetching 15m MACD Histogram and RSI values\nhist15m = request.security(syminfo.tickerid, MTF_TIMEFRAME, f_macd_hist(close, MACD_FAST_LEN, MACD_SLOW_LEN, MACD_SIGNAL_LEN))\nrsi15m = request.security(syminfo.tickerid, MTF_TIMEFRAME, ta.rsi(close, RSI_LENGTH))\n\n// 15m MACD Long Confirmation: Histogram must be Above Zero\nlong15mMacdConfirmation = hist15m > 0\n\n// 15m RSI Long Confirmation: RSI must be Above 50\nlong15mRsiConfirmation = rsi15m > 50\n\n// Total 15m Long Confirmation\nfinalLong15mConfirmation = long15mMacdConfirmation and long15mRsiConfirmation\n\n// 15m MACD Short Confirmation: Histogram must be Below Zero\nshort15mMacdConfirmation = hist15m < 0\n\n// 15m RSI Short Confirmation: RSI must be Below 50\nshort15mRsiConfirmation = rsi15m < 50\n\n// Total 15m Short Confirmation\nfinalShort15mConfirmation = short15mMacdConfirmation and short15mRsiConfirmation\n\n\n// --- 3. TRADE ORDERS ---\n\n// Final Conditions: 5m Entry AND Dual 15m Confirmation Required\nfinalLongCondition = long5mCondition and finalLong15mConfirmation\nfinalShortCondition = short5mCondition and finalShort15mConfirmation\n\n// Long Signal\nif (finalLongCondition)\n    strategy.close(\"Short\", comment=\"Short Closed (Dual MTF Confirmation)\")\n    strategy.entry(\"Long\", strategy.long, comment=\"Long Opened (Dual MTF Confirmation)\")\n\n// Short Signal\nif (finalShortCondition)\n    strategy.close(\"Long\", comment=\"Long Closed (Dual MTF Confirmation)\")\n    strategy.entry(\"Short\", strategy.short, comment=\"Short Opened (Dual MTF Confirmation)\")\n\n// --- 4. VISUALIZATION ---\nplot(supertrend, color=direction ? color.green : color.red, title=\"5m Supertrend\")\nplot(gannHiLoLine, linewidth=2, color=HLv_d == -1 ? color.maroon : color.blue, title=\"5m Gann HiLo\")\nplot(ema50, color=color.blue, title=\"5m EMA 50\")\nplot(ema100, color=color.orange, title=\"5m EMA 100\")\n\n// *** Buradaki plotshape fonksiyonlarÄ±na display=display.none eklendi ***\n// Bu sayede, ÅŸekiller varsayÄ±lan olarak grafikte gÃ¶rÃ¼nmez, ancak kullanÄ±cÄ± Ayarlar -> Stil sekmesinden etkinleÅŸtirebilir.\nplotshape(finalLongCondition, style=shape.triangleup, location=location.belowbar, color=color.new(color.lime, 0), size=size.small, text=\"MTF\", display=display.none)\nplotshape(finalShortCondition, style=shape.triangledown, location=location.abovebar, color=color.new(color.red, 0), size=size.small, text=\"MTF\", display=display.none)"
  },
  {
    "url": "0zeltpVg-BTC-BRD-Bullet-Proof-Reversal-Strategy",
    "name": "BTC BRD â€“ Bullet-Proof Reversal Strategy",
    "description": "BTC BRD â€“ Bullet-Proof Reversal Strategy is a price-action based reversal system that turns your existing â€œBullet-Proof Reversal Detectorâ€ into a fully backtestable TradingView strategy with built-in risk management. It is designed to catch clean swing reversals using pure market structure, then automatically place stop-loss and take-profit orders based on your preferred risk-reward settings.\n\n## Core concept\n\nThe strategy identifies true swing highs and lows using pivots and then waits for a clear market structure shift before entering any trade. It looks for a higher low followed by a break of structure for longs, and a lower high followed by a break of structure for shorts, helping filter out many random spikes and fakeouts. This makes it suitable for traders who prefer clean, rule-based entries grounded in market structure rather than noisy, indicator-heavy setups.\n\n## Entries and exits\n\n- Long trades are triggered after a bullish higher-low plus a confirmed break above the last swing high.  \n- Short trades are triggered after a bearish lower-high plus a confirmed break below the last swing low.  \n- Every position is protected with an automatic stop-loss and a calculated take-profit, so each trade has a predefined risk and reward from the moment it is opened.\n\n## Risk management\n\nThe strategy lets you control your risk with a configurable risk-reward ratio (RR) and flexible stop-loss options. You can choose between an ATR-based stop (ATR Ã— multiplier) or a fixed percentage stop relative to the entry price. Once the stop distance is known, the take-profit level is automatically derived from your RR value, making trade sizing and evaluation more consistent across different pairs and timeframes.\n\n## Use cases and recommendations\n\nThis script is ideal for swing and intraday traders who want to systematically test market-structure reversals on assets like Bitcoin or other volatile instruments. For best results, experiment with different timeframes and ATR/percentage settings, and always validate performance using the Strategy Tester before deploying it on live markets. Remember that no strategy is guaranteed to be profitable, so use proper risk management and adapt settings to your own style and risk tolerance.",
    "image_url": "0zeltpVg",
    "author": "neverstop_dd",
    "likes": 15,
    "type": "strategy",
    "created": "2025-11-28",
    "updated": "2025-11-28",
    "source": "//@version=5\nstrategy(\"BTC BRD â€“ Bullet-Proof Reversal Strategy\", overlay=true, max_labels_count=500)\n\n// â€”â€”â€” USER INPUTS â€”â€”â€”\nrr      = input.float(2, title=\"Risk-Reward Ratio\", minval=0.5)\nsl_type = input.string(\"ATR\", title=\"Stop Loss Type\", options=[\"ATR\", \"Percent\"])\natr_mult= input.float(1.5, title=\"ATR Multiplier\", minval=0.5)\nsl_pct  = input.float(2, title=\"Stop Loss Percent\", minval=0.5)\natr_len = input.int(14, title=\"ATR Length\")\n\nlen = 4\n\npivotLow  = low[len] == ta.lowest(low, len * 2 + 1)\npivotHigh = high[len] == ta.highest(high, len * 2 + 1)\n\nvar float lastLow  = na\nvar float lastHigh = na\n\nif pivotLow\n    lastLow := low[len]\n\nif pivotHigh\n    lastHigh := high[len]\n\n// â€”â€”â€” Market Structure Shift â€”â€”â€”\nbullHL = pivotLow and lastLow < nz(lastLow[1])\nbullBOS = close > nz(lastHigh[1])\nfinalLong = bullHL and bullBOS\n\nbearLH = pivotHigh and lastHigh > nz(lastHigh[1])\nbearBOS = close < nz(lastLow[1])\nfinalShort = bearLH and bearBOS\n\nplotshape(finalLong, title=\"Bull Reversal\", style=shape.triangleup,\n     color=color.new(color.green, 0), location=location.belowbar, size=size.large)\nplotshape(finalShort, title=\"Bear Reversal\", style=shape.triangledown,\n     color=color.new(color.red, 0), location=location.abovebar, size=size.large)\n\n// â€”â€”â€” ATR and Stop Loss / Take Profit Calculation â€”â€”â€”\natr_val = ta.atr(atr_len)\n\nlong_sl = sl_type == \"ATR\" ? close - atr_val * atr_mult : close * (1 - sl_pct / 100)\nlong_tp = close + (close - long_sl) * rr\n\nshort_sl = sl_type == \"ATR\" ? close + atr_val * atr_mult : close * (1 + sl_pct / 100)\nshort_tp = close - (short_sl - close) * rr\n\n// â€”â€”â€” Entries and Exits â€”â€”â€”\nif finalLong\n    strategy.entry(\"Long\", strategy.long)\n    strategy.exit(\"Long Exit\", from_entry=\"Long\", stop=long_sl, limit=long_tp)\n\nif finalShort\n    strategy.entry(\"Short\", strategy.short)\n    strategy.exit(\"Short Exit\", from_entry=\"Short\", stop=short_sl, limit=short_tp)\n"
  },
  {
    "url": "Bc587HeK-Retracement-Strategy-OmegaTools",
    "name": "Retracement Strategy [OmegaTools]",
    "description": "Retracement Strategy   is a systematic trendâ€“retracement framework designed to identify directional opportunities after a confirmed momentum shift, and to manage exits using either trend reversals or overextension conditions. It is built around a smoothed RSI regime filter and a simple, price-based retracement trigger, making it applicable across a wide range of markets and timeframes while remaining transparent and easy to interpret.\n\nThe strategy begins by defining the underlying trend through a two-stage RSI signal. A standard RSI is computed over the user-defined Length input, then smoothed with a short moving average to reduce noise. Two symmetric thresholds are derived from the Threshold parameter: an upper band at 100 minus the threshold and a lower band at the threshold itself. When the smoothed RSI crosses above the upper band, the environment is classified as bullish and the internal trend state is set to uptrend. When the smoothed RSI crosses below the lower band, the environment is classified as bearish and the trend state becomes downtrend. When RSI moves back into the central zone between the two bands, the trend is considered neutral. In addition to the current trend, the strategy tracks the last non-neutral trend direction, which is used to detect genuine trend changes rather than transient oscillations.\n\nOnce a trend is established, the strategy looks for retracement entries in the direction of that trend. For long setups in an uptrend, it computes the lowest low over the previous Length minus one bars, excluding the current bar. A long signal is generated when price dips below this recent low while the trend state remains bullish. Symmetrically, for short setups in a downtrend, it computes the highest high over the previous Length minus one bars and enters short when price spikes above this recent high while the trend state remains bearish. This logic is designed to capture pullbacks against the prevailing RSI-defined trend, entering when the market tests or slightly violates recent extremes, rather than chasing breakouts. The candles are visually coloured to reflect the detected trend, highlighting bullish and bearish environments while keeping neutral phases distinguishable on the chart. An ATR-based measure is used solely to position the â€œUPâ€ and â€œDNâ€ labels on the chart for clearer visualisation of entry points; it does not directly influence position sizing or stop calculation in this implementation.\n\nTake profit and stop loss behaviour are fully parameterized through the â€œTake Profitâ€ and â€œStop Lossâ€ inputs, each offering three modes: None, Trend Change and Extension. When â€œTrend Changeâ€ is selected for the take profit, the strategy will only exit profitable positions when a confirmed trend reversal occurs. For a long position, this means that the strategy will close the trade when the trend state flips from uptrend to downtrend, and the last recorded trend direction validates that this is a genuine reversal rather than a neutral fluctuation; the same logic applies symmetrically for short positions. When â€œExtensionâ€ is selected as the take profit mode, the strategy closes profitable long trades when the smoothed RSI reaches or exceeds the upper threshold, interpreted as an overbought extension within the bullish regime, and closes profitable short trades when the smoothed RSI falls to or below the lower threshold, interpreted as an oversold extension within the bearish regime. When â€œNoneâ€ is chosen, the strategy does not apply any explicit take profit logic, leaving trades to be managed by the stop loss settings or by user discretion in backtesting.\n\nThe stop loss parameter works in a parallel way. With â€œTrend Changeâ€ selected as stop loss, any open long position is closed when the trend flips from uptrend to downtrend, regardless of whether the trade is currently in profit or loss, and any open short is closed when the trend flips from downtrend to uptrend. This turns the RSI trend regime into a hard invalidation rule: once the underlying momentum structure reverses, the position is exited. With â€œExtensionâ€ selected for stop loss, long positions are closed when RSI falls back below the upper band and moves towards the opposite side of the range, while short positions are closed when RSI rises above the lower band and moves towards the upper side. In practice, this acts as a dynamic exit based on the oscillator moving out of a favourable context for the existing trade. Selecting â€œNoneâ€ for stop loss disables these automatic exits, leaving only the take profit logic, if any, to manage the position. Because take profit and stop loss configuration are independent, the user can construct different profiles, such as pure trend-change exits on both sides, pure overextension exits, or a mix (for example, take profit on overextension and stop loss on trend reversal).\n\nThis strategy is designed as an analytical and backtesting framework rather than a finished plug-and-play trading system. It does not include position sizing, risk-per-trade controls, multi-timeframe confirmation, volatility filters or instrument-specific fine-tuning. Its primary purpose is to provide a clear, rule-based structure for testing retracement logic within RSI-defined trends, and to allow users to explore how different exit regimes (trend-change based versus extension based) affect performance on their instruments and timeframes of interest.\n\nNothing in this script or its description should be interpreted as financial advice, investment recommendation or solicitation to buy or sell any financial instrument. Past performance on backtests does not guarantee future results. The behaviour of this strategy can vary significantly across symbols, timeframes and market conditions, and correlations, volatility and liquidity can change without warning. Before considering any live application, users should thoroughly backtest and forward test the strategy on their own data, adjust parameters to their risk profile and instrument characteristics, and integrate proper money management and trade management rules. Use of this script is entirely at the userâ€™s own risk.\n",
    "image_url": "Bc587HeK",
    "author": "OmegaTools",
    "likes": 353,
    "type": "strategy",
    "created": "2025-11-28",
    "updated": "2025-11-28",
    "source": "// Â© OmegaTools\r\n\r\n//@version=6\r\nstrategy(\"Retracement Strategy [OmegaTools]\", overlay = true)\r\n\r\ntp = input.string('Extension', 'Take Profit', ['None', 'Trend Change', 'Extension'])\r\nsl = input.string('Extension', 'Stop Loss', ['None', 'Trend Change', 'Extension'])\r\nlnt = input.int(10, 'Length')\r\nobs = input.int(70, 'Threshold')\r\n\r\nrsi = ta.sma(ta.rsi(close, lnt), 2)\r\nvar trend = 0\r\nvar lasttrend = 0\r\nif ta.crossover(rsi, 100 - obs)\r\n    trend := 1\r\n    lasttrend := 1\r\nif ta.crossunder(rsi, obs)\r\n    trend := -1\r\n    lasttrend := -1\r\nelse if rsi > obs or rsi < 100 - obs\r\n    trend := 0\r\n\r\nsecondcol = trend > 0 ? #2962ff : trend < 0 ? #e91e63 : chart.fg_color\r\nmaincol = trend > 0 ? (close < open ? na : color.new(#2962ff, 75)) : trend < 0 ? (close > open ? na : color.new(#e91e63, 75)) : (close > open ? chart.fg_color : na)\r\nll = ta.lowest(low[1], lnt - 1)\r\nhh = ta.highest(high[1], lnt - 1)\r\nlong = trend > 0 and low < ll\r\nshort = trend < 0 and high > hh\r\nplotcandle(open, high, low, close, 'Trend Candles', maincol, secondcol, bordercolor = secondcol)\r\natr = ta.sma(high - low, 34) / 8\r\nvar last = 0\r\nif long and last <= 0\r\n    label.new(bar_index, low - atr, 'UP', xloc = xloc.bar_index, color = #2962ff, style = label.style_label_up, textcolor = chart.bg_color)\r\n    last := 1\r\n    strategy.entry('B', strategy.long)\r\nif short and last >= 0\r\n    label.new(bar_index, high + atr, 'DN', xloc = xloc.bar_index, color = #e91e63, textcolor = chart.bg_color)\r\n    last := -1\r\n    strategy.entry('S', strategy.short)\r\n\r\nlongprofit = strategy.position_size > 0 and close > strategy.position_avg_price\r\nshortprofit = strategy.position_size < 0  and close < strategy.position_avg_price\r\nif tp == 'Trend Change'\r\n    if longprofit and trend == -1 and lasttrend[1] == 1\r\n        strategy.close('B')\r\n    if shortprofit and trend == 1 and lasttrend[1] == -1\r\n        strategy.close('S')\r\nif tp == 'Extension'\r\n    if longprofit and rsi > obs\r\n        strategy.close('B')\r\n    if shortprofit and rsi < 100 - obs\r\n        strategy.close('S')\r\n\r\nif sl == 'Trend Change'\r\n    if trend == -1 and lasttrend[1] == 1\r\n        strategy.close('B')\r\n    if trend == 1 and lasttrend[1] == -1\r\n        strategy.close('S')\r\nif sl == 'Extension'\r\n    if rsi < 100 - obs\r\n        strategy.close('B')\r\n    if rsi > obs\r\n        strategy.close('S')"
  },
  {
    "url": "LmNV3ZLN",
    "name": "ETHUSDT 4H - Keltner Breakout ",
    "description": "working nice with ETH above EMA200\nUsing Keltner bands to prevent get rid off unnecessary noices . Works at safe side \nWhich is fantastic for people who does not want to stick to screen full day , it needs as couple of transactions per month to gain meaningfull profit\nDo not forget to use it with 4 hr time frame\n\nDo not recommend to use it with sh*tcoins, however with a small fine tuning its okay to use it with Top altcoins",
    "image_url": "LmNV3ZLN",
    "author": "scantek",
    "likes": 7,
    "type": "strategy",
    "created": "2025-11-28",
    "updated": "2025-11-28",
    "source": "//@version=5\r\nstrategy(\"ETHUSDT 4H - Keltner Breakout (Pro)\", overlay=true, initial_capital=1000, default_qty_type=strategy.percent_of_equity, default_qty_value=100, commission_type=strategy.commission.percent, commission_value=0.1)\r\n\r\n// ------------------------------------\r\n// --- AYARLAR ---\r\n// ------------------------------------\r\n\r\n// 1. TREND FÄ°LTRESÄ°\r\nemaLen = input.int(200, \"Ana Trend EMA\")\r\n\r\n// 2. KELTNER KANALLARI (VOLATÄ°LÄ°TE Ã–LÃ‡ÃœMÃœ)\r\nkcLen  = input.int(20, \"KC Periyodu\")\r\nkcMult = input.float(2.0, \"KC Ã‡arpanÄ± (KÄ±rÄ±lÄ±m Hassasiyeti)\", step=0.1)\r\n\r\n// 3. RÄ°SK YÃ–NETÄ°MÄ° (ATR Trailing)\r\n// 4H iÃ§in geniÅŸ bir stop ve takip mesafesi\r\natrLen  = input.int(14, \"ATR Periyodu\")\r\nslMult  = input.float(4.0, \"Trailing Stop (ATR x ?)\", tooltip=\"4H volatilite iÃ§in geniÅŸ stop.\")\r\ntpPct   = input.float(20.0, \"Acil Kar Al (%)\", tooltip=\"Hedef, stop olana kadar trendi sÃ¼rmektir.\")\r\n\r\n// 4. TARÄ°H\r\nstartYear = input.int(2023, \"BaÅŸlangÄ±Ã§ YÄ±lÄ±\")\r\n\r\n// ------------------------------------\r\n// --- HESAPLAMALAR ---\r\n// ------------------------------------\r\nemaVal = ta.ema(close, emaLen)\r\natrVal = ta.atr(atrLen)\r\n\r\n// Keltner KanallarÄ±\r\nmiddleKC = ta.ema(close, kcLen)\r\nupperKC = middleKC + (atrVal * kcMult)\r\nlowerKC = middleKC - (atrVal * kcMult)\r\n\r\n// ------------------------------------\r\n// --- GÄ°RÄ°Åž MANTIÄžI ---\r\n// ------------------------------------\r\n\r\n// 1. Trend Filtresi: Fiyat EMA 200 Ã¼zerinde mi?\r\ntrendUp = close > emaVal\r\n\r\n// 2. KÄ±rÄ±lÄ±m: Fiyat Ã¼st Keltner kanalÄ±nÄ± yukarÄ± kesti mi?\r\nbreakout = close > upperKC\r\n\r\n// NÄ°HAÄ° GÄ°RÄ°Åž\r\nlongCondition = trendUp and breakout and strategy.position_size == 0 and year >= startYear\r\n\r\n// ------------------------------------\r\n// --- Ä°ÅžLEM EMRÄ° ---\r\n// ------------------------------------\r\n\r\nif longCondition\r\n    strategy.entry(\"KC KÄ±rÄ±lÄ±m\", strategy.long, comment=\"KIRILIM AL\")\r\n\r\nif strategy.position_size > 0\r\n    // Dinamik Stop ve Kar Seviyesi\r\n    stopPrice = strategy.position_avg_price - (atrVal * slMult)\r\n    profitPrice = strategy.position_avg_price * (1 + tpPct / 100)\r\n    \r\n    // Ã‡Ä±kÄ±ÅŸ Emri: Trailing Stop'a gÃ¶re dinamik stop.\r\n    strategy.exit(\"Trend Takip\", \"KC KÄ±rÄ±lÄ±m\", limit=profitPrice, stop=stopPrice)\r\n\r\n    // EK Ã‡IKIÅž: Fiyat Keltner KanalÄ±nÄ±n AltÄ±na DÃ¼ÅŸerse (Trend ZayÄ±fladÄ±)\r\n    if close < lowerKC\r\n        strategy.close(\"KC KÄ±rÄ±lÄ±m\", comment=\"Kanal AltÄ± Sat\")\r\n\r\n// ------------------------------------\r\n// --- GÃ–RSELLÄ°K ---\r\n// ------------------------------------\r\nplot(emaVal, color=color.white, linewidth=2, title=\"Trend EMA 200\")\r\nplot(upperKC, color=color.lime, title=\"Ãœst KC\")\r\nplot(lowerKC, color=color.red, title=\"Alt KC\")"
  },
  {
    "url": "ZyPd3ENh",
    "name": "StratÃ©gie SMC V18.2 (BTC/EUR FINAL R3 - Tendance)",
    "description": "This strategy is an automated implementation of Smart Money Concepts (SMC), designed to operate on the Bitcoin/Euro (BTC/EUR) chart using the 15-minute Timeframe (M15).It focuses on identifying high-probability zones (Order Blocks) after a confirmed Break of Structure (BOS) and a Liquidity Sweep, utilizing an H1/EMA 200 trend filter to only execute trades in the direction of the dominant market flow.Risk management is strict: every trade uses a fixed Risk-to-Reward Ratio (R:R) of 1:3.ðŸ§± Core Logic Components\n\n1. Trend Filter (H1/EMA 200)Objective: To avoid counter-trend entries, which has allowed the success rate to increase to nearly $65\\%$ in backtests.Mechanism: A $200$-period EMA is plotted on a higher timeframe (Default: H1/60 minutes).Long (Buy): Entry is only permitted if the current price (M15) is above the trend EMA.Short (Sell): Entry is only permitted if the current price (M15) is below the trend EMA.\n\n2. Order Block (OB) DetectionA potential Order Block is identified on the previous candle if it is \naccompanied by an inefficiency (FVG - Fair Value Gap).\n\n3. Advanced SMC ValidationBOS (Break of Structure): A recent BOS must be confirmed by breaking the swing high/low defined by the swing length (Default: 4 M15 candles).Liquidity (Liquidity Sweep): The Order Block zone must have swept recent liquidity (defined by the Liquidity Search Length) within a certain tolerance (Default: $0.1\\%$).Point of Interest: The OB must form in a premium zone (for shorts) or a discount zone (for longs) relative to the current swing range (above or below the $50\\%$ level of the range).\n\n4. Execution and Risk ManagementEntry: The trade is triggered when the price touches the active Order Block (mitigation).Stop Loss (SL): The SL is fixed at the low of the OB (for longs) or the high of the OB (for shorts).Take Profit (TP): The TP is strictly set at a level corresponding to 3 times the SL distance (R:R 1:3).Lot Sizing: The trade quantity is calculated to risk a fixed amount (Default: 2.00 Euros) per transaction, capped by a Lot Max and Lot Min defined by the user.\n\n Input Parameters (Optimized for BTC/EUR M15)Users can adjust these parameters to modify sensitivity and risk profile. The default values are those optimized for the high-performing backtest (Profit Factor $> 3$).ParameterDescriptionDefault Value (M15)Long. Swing (BOS)Candle length used to define the swing (and thus the BOS).4Long. Recherche Liq.Number of candles to scan to confirm a liquidity sweep.7TolÃ©rance Liq. (%)Price tolerance to validate the liquidity sweep (as a percentage of price).0.1Timeframe TendanceChart timeframe used for the EMA filter (e.g., 60 = H1).60 (H1)Longueur EMA TendancePeriods used for the trend EMA.200Lot Max (QuantitÃ© Max BTC)Maximum quantity of BTC the strategy is allowed to trade.0.01Lot Min RÃ©el (Exigence Broker)Minimum quantity required by the broker/exchange.0.00001",
    "image_url": "ZyPd3ENh",
    "author": "rico2956",
    "likes": 17,
    "type": "strategy",
    "created": "2025-11-28",
    "updated": "2025-11-28",
    "source": "//@version=6\nstrategy(title=\"StratÃ©gie SMC V18.2 (BTC/EUR FINAL R3 - Tendance)\", shorttitle=\"SMC-BTC-FINAL-Tendance\", overlay=true,\n     currency=currency.EUR, // <--- CHANGÃ‰ EN EUR\n     initial_capital=1000, // Capital initial de 1000 euros pour coller Ã  votre compte dÃ©mo\n     pyramiding=0, \n     default_qty_type=strategy.cash, \n     default_qty_value=1) \n\n// --- PARAMÃˆTRES ADAPTÃ‰S POUR BTC (M15) ---\ni_max_lot_size = input.float(0.01, title=\"Lot Max (QuantitÃ© Max BTC)\", minval=0.00001, step=0.001)\ni_min_lot_size = input.float(0.00001, title=\"Lot Min RÃ©el (Exigence Broker)\", minval=0.00001, step=0.00001) \ni_swing_length = input.int(4, title=\"Long. Swing (BOS) pour BTC\", minval=2) // ADAPTÃ‰ M15\ni_ob_opacity = input.int(80, title=\"OpacitÃ© OB\", minval=0, maxval=100)\ni_liq_tolerance = input.float(0.1, title=\"TolÃ©rance Liq. (%) pour BTC\", minval=0.01, step=0.01)\ni_liq_search = input.int(7, title=\"Long. Recherche Liq.\", minval=5) // ADAPTÃ‰ M15\n\n// --- PARAMÃˆTRES DE FILTRE DE TENDANCE (H1/EMA 200 PAR DÃ‰FAUT) ---\ni_tf_tendance = input.string(\"60\", title=\"Timeframe Tendance (ex: 60 pour H1)\", options=[\"30\", \"60\", \"120\", \"240\"]) // ADAPTÃ‰ H1\ni_ema_length = input.int(200, title=\"Longueur EMA Tendance\", minval=1)\n\n// --- GESTION DU RISQUE DÃ‰DIÃ‰E ---\nfloat risk_amount = 2.0 // Risque de 2.00 EUROS par transaction\nfloat min_sl_distance = 0.0001 \n\n// --- VARIABLES SMC ---\nvar float obHigh = na\nvar float obLow = na\nvar bool obIsBullish = false \nvar box currentBox = na          \nvar float last_swing_low = na\nvar float last_swing_high = na\nvar label active_label = na      \nvar bool signal_entry_long = false\nvar bool signal_entry_short = false\nvar float entry_sl_level = na\nvar float entry_tp_level = na\nvar float entry_qty_to_risk = na \nvar bool signal_persistant_long = false\nvar bool signal_persistant_short = false\n\n// --- FONCTION DE FILTRE DE TENDANCE (EMA sur TF supÃ©rieur) ---\nf_get_ema_hl() => \n    request.security(syminfo.tickerid, i_tf_tendance, ta.ema(close, i_ema_length))\n\nema_tendance = f_get_ema_hl()\n\n// PLOT de l'EMA pour la visualisation (Titre corrigÃ©)\nplot(ema_tendance, color=color.new(color.white, 20), title=\"EMA Tendance (Filtre)\", linewidth=2)\n\n\n// --- RÃ‰INITIALISATION ---\nif not na(active_label)\n    label.delete(active_label)\nactive_label := na \n\nsignal_entry_long := false \nsignal_entry_short := false \nentry_qty_to_risk := na \n\n\n// Mise Ã  jour des Swings Highs/Lows\nsh_confirmed = ta.barssince(high == ta.highest(i_swing_length * 2 + 1)) == i_swing_length\nsl_confirmed = ta.barssince(low == ta.lowest(i_swing_length * 2 + 1)) == i_swing_length\n\n// Initialisation des swings \nif na(last_swing_high)\n    last_swing_high := ta.highest(200)\nif na(last_swing_low)\n    last_swing_low := ta.lowest(200)\n\nif sh_confirmed\n    last_swing_high := high[i_swing_length]\nif sl_confirmed\n    last_swing_low := low[i_swing_length]\n\nfloat fib_0_5_level = not na(last_swing_high) and not na(last_swing_low) ? (last_swing_high + last_swing_low) / 2 : na\n\n// PLOT DE DÃ‰BOGAGE: Visualisation des derniers swings\nplot(last_swing_high, color=color.new(color.fuchsia, 50), style=plot.style_line, linewidth=2, title=\"Last Swing High\")\nplot(last_swing_low, color=color.new(color.lime, 50), style=plot.style_line, linewidth=2, title=\"Last Swing Low\")\n\n\n// --- FONCTIONS DE DÃ‰TECTION (unchanged) ---\nfvg_bullish() => high[1] < low[3]\nfvg_bearish() => low[1] > high[3]\n\nf_has_liquidity(direction) =>\n    result = false\n    price_to_search = direction ? low : high \n    \n    search_price = direction ? ta.lowest(i_liq_search) : ta.highest(i_liq_search)\n\n    tolerance = close * i_liq_tolerance / 100 \n    \n    if direction \n        result := search_price < price_to_search - tolerance\n    else \n        result := search_price > price_to_search + tolerance\n        \n    result\n\n// --- LOGIQUE DE DÃ‰CLENCHEMENT DE L'ORDRE BLOCK (unchanged) ---\nis_bullish_ob() =>\n    isBearCandle = close[1] < open[1] \n    hasFVG = fvg_bullish() \n    isBOS = not na(last_swing_low) and close > last_swing_low \n    hasLiquiditySupport = f_has_liquidity(true)\n    isDiscount = not na(fib_0_5_level) and close < fib_0_5_level\n\n    isBearCandle and hasFVG and isBOS and hasLiquiditySupport and isDiscount\n\nis_bearish_ob() =>\n    isBullCandle = close[1] > open[1] \n    hasFVG = fvg_bearish() \n    isBOS = not na(last_swing_high) and close < last_swing_high \n    hasLiquiditySupport = f_has_liquidity(false)\n    isPremium = not na(fib_0_5_level) and close > fib_0_5_level\n\n    isBullCandle and hasFVG and isBOS and hasLiquiditySupport and isPremium\n\n// --- CRÃ‰ATION / MISE Ã€ JOUR DE L'OB ACTIF (unchanged) ---\nif na(obHigh) or strategy.position_size == 0\n    if is_bullish_ob() or is_bearish_ob()\n        obIsBullish := is_bullish_ob()\n        obHigh := high[1]\n        obLow := low[1]\n        \n        obColor = color.new(color.gray, 60) \n        if not na(currentBox) \n            box.delete(currentBox)\n        \n        currentBox := box.new(left=bar_index[1], top=obHigh, right=bar_index, bottom=obLow, border_color=obColor, bgcolor=obColor, xloc=xloc.bar_index)\n\n\n// --- GESTION DE LA MITIGATION ET VALIDATION ---\nif not na(obHigh) \n    \n    float mitigation_buffer = 0.00005 * close \n\n    isTouched = obIsBullish ? low <= obHigh + mitigation_buffer : high >= obLow - mitigation_buffer\n    isInvalidatedBull = obIsBullish and close < obLow\n    isInvalidatedBear = not obIsBullish and close > obHigh\n    \n    if not na(currentBox) \n        box.set_right(currentBox, bar_index) \n\n    // L'OB est touchÃ© ET nous ne sommes pas dÃ©jÃ  en position\n    if isTouched and strategy.position_size == 0\n        \n        // --- CALCULS ET SIGNAL ---\n        var float sl_level = obIsBullish ? obLow : obHigh\n        var float rr_distance_usd = math.abs(close - sl_level) \n        float safe_rr_distance = math.max(rr_distance_usd, min_sl_distance)\n        \n        float desired_risk_amount = risk_amount \n        \n        float calculated_qty = desired_risk_amount / safe_rr_distance\n        \n        // LOGIQUE POUR GÃ‰RER LOT MAX/MIN\n        float minimum_lot_for_market = i_min_lot_size \n        \n        entry_qty_to_risk := math.max(calculated_qty, minimum_lot_for_market)\n        \n        entry_qty_to_risk := math.min(entry_qty_to_risk, i_max_lot_size) \n        \n        entry_sl_level := sl_level\n        \n        // TP FIXE : R:R 1:3\n        entry_tp_level := obIsBullish ? close + safe_rr_distance * 3 : close - safe_rr_distance * 3 \n        \n        // VÃ‰RIFICATION DU LOT MINIMUM \n        if entry_qty_to_risk >= minimum_lot_for_market\n            if obIsBullish\n                signal_entry_long := true\n            else\n                signal_entry_short := true\n\n        // Logique visuelle (unchanged)\n        if signal_entry_long or signal_entry_short\n            final_color = obIsBullish ? color.new(color.green, i_ob_opacity) : color.new(color.red, i_ob_opacity)\n            box.set_bgcolor(currentBox, final_color)\n            box.set_border_color(currentBox, final_color)\n            \n            if not na(active_label)\n                label.delete(active_label)\n            \n            label_y_pos = obIsBullish ? obHigh : obLow \n            label_text = obIsBullish ? \"ACTIF (ACHAT)!\" : \"ACTIF (VENTE)!\"\n            label_style = obIsBullish ? label.style_label_up : label.style_label_down\n            \n            active_label := label.new(bar_index, label_y_pos, \n                                     text=label_text, \n                                     color=final_color, \n                                     textcolor=color.white, \n                                     style=label_style, \n                                     yloc=obIsBullish ? yloc.belowbar : yloc.abovebar)\n\n    // L'OB est invalidÃ© (unchanged)\n    if isInvalidatedBull or isInvalidatedBear\n        if not na(currentBox)\n            box.delete(currentBox)\n        obHigh := na\n        obLow := na\n        currentBox := na \n\n        if not na(active_label)\n            label.delete(active_label)\n        active_label := na\n\n\n// --- EXÃ‰CUTION DE LA STRATÃ‰GIE ---\n\n// Persistance du signal\nif signal_entry_long and strategy.position_size == 0\n    signal_persistant_long := true\n\nif signal_entry_short and strategy.position_size == 0\n    signal_persistant_short := true\n\n// EXÃ‰CUTION AVEC FILTRE DE TENDANCE\nif strategy.position_size == 0\n    \n    // EXÃ‰CUTION LONG\n    if signal_persistant_long and not na(entry_qty_to_risk)\n        // FILTRE LONG : Prix M15 au-dessus de l'EMA de tendance H1\n        if close > ema_tendance\n            strategy.entry(\"LongEntry\", strategy.long, qty=entry_qty_to_risk, comment=\"OB Long Actif\")\n            strategy.exit(\"ExitLong\", from_entry=\"LongEntry\", stop=entry_sl_level, limit=entry_tp_level) \n        signal_persistant_long := false \n\n    // EXÃ‰CUTION SHORT\n    if signal_persistant_short and not na(entry_qty_to_risk)\n        // FILTRE SHORT : Prix M15 en dessous de l'EMA de tendance H1\n        if close < ema_tendance\n            strategy.entry(\"ShortEntry\", strategy.short, qty=entry_qty_to_risk, comment=\"OB Short Actif\")\n            strategy.exit(\"ExitShort\", from_entry=\"ShortEntry\", stop=entry_sl_level, limit=entry_tp_level)\n        signal_persistant_short := false \n\n// S'assurer que le signal actif est effacÃ© aprÃ¨s l'entrÃ©e/sortie\nif strategy.position_size != 0\n    signal_persistant_long := false\n    signal_persistant_short := false"
  },
  {
    "url": "Ic6a4v4X-DJ-BTC-Daily",
    "name": "DJ BTC Daily",
    "description": "This Strategy only works on BTC daily. The only concern is the low winrate that could be a psycological hurdle. Please do comment for adjustments I should try and incorprate and let's find a killer strategy together :-) ",
    "image_url": "Ic6a4v4X",
    "author": "TheHeikinAshitrader",
    "likes": 9,
    "type": "strategy",
    "created": "2025-11-28",
    "updated": "2025-11-28",
    "source": "//@version=6\nstrategy(\"Mystic Pulse Elite\", overlay=true, initial_capital=100000, default_qty_value=50, commission_value=0.05, slippage=1, pyramiding=1)\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// INPUTS - ALL AT TOP\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n// Direction\nallow_longs = input.bool(true, \"Allow Longs\")\nallow_shorts = input.bool(true, \"Allow Shorts\")\nshort_only_bear = input.bool(true, \"Shorts Only in Bear\")\nshort_strong_adx = input.bool(true, \"Shorts Need Strong ADX\")\nshort_min_bars = input.int(4, \"Shorts Min Bars\", minval=2)\n\n// Scaling\nenable_scaling = input.bool(true, \"Enable Scaling\")\nscale_at_rr = input.float(2.0, \"Scale at R:R\", minval=1.0, maxval=3.0)\nscale_size = input.float(25, \"Scale Size %\", minval=10, maxval=50)\n\n// Entry\nentry_mode = input.string(\"Balanced\", \"Entry Mode\", options=[\"Strict\", \"Balanced\", \"Relaxed\"])\nuse_ma_filter = input.bool(true, \"Use MA Filter\")\nuse_adx_filter = input.bool(true, \"Use ADX Filter\")\nmin_adx = input.float(23, \"Min ADX\", minval=15, maxval=40)\nuse_consolidation = input.bool(false, \"Avoid Consolidation\")\n\n// WIN RATE BOOSTERS - More conservative\nrequire_momentum = input.bool(false, \"Require Strong Momentum\")\nmomentum_pct = input.float(1.0, \"Momentum %\", minval=0.5, maxval=5.0, step=0.25)\nwait_for_pullback = input.bool(false, \"Wait for Pullback to MA20\")\nrequire_volume = input.bool(false, \"Require Above Average Volume\")\nvolume_multiplier = input.float(1.1, \"Volume Multiplier\", minval=1.0, maxval=2.0, step=0.1)\n\n// NEW: Minimum bars adjustment\nuse_stricter_entries = input.bool(true, \"Wait for Stronger Confirmation\")\nstrict_long_bars = input.int(3, \"Longs: Min Bars\", minval=2, maxval=5)\nstrict_short_bars = input.int(4, \"Shorts: Min Bars\", minval=2, maxval=6)\n\n// Risk\nuse_drawdown_prot = input.bool(false, \"Enable Drawdown Protection\")\nmax_daily_loss = input.float(15, \"Max Daily Loss %\", minval=5, maxval=25)\nmax_consec_losses = input.int(5, \"Max Consecutive Losses\", minval=2, maxval=10)\ndd_pause_threshold = input.float(40, \"Pause at Drawdown %\", minval=15, maxval=60)\nreduce_after_loss = input.bool(false, \"Reduce Size After Loss\")\n\n// Exit\nlong_rr = input.float(5.0, \"Long R:R\", minval=3.0, maxval=8.0)\nshort_rr = input.float(4.0, \"Short R:R\", minval=2.5, maxval=6.0)\nlong_stop = input.float(6, \"Long Stop %\", minval=4, maxval=12)\nshort_stop = input.float(5, \"Short Stop %\", minval=3, maxval=10)\nuse_trail = input.bool(true, \"Enable Trailing\")\ntrail_offset = input.float(8, \"Trail Offset %\", minval=4, maxval=15)\nexit_on_opposite = input.bool(true, \"Exit on Opposite\")\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// CALCULATIONS\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n// ADX\nadx_len = 14\ndi_smooth = 1\no_s = ta.sma(open, di_smooth)\nh_s = ta.sma(high, di_smooth)\nl_s = ta.sma(low, di_smooth)\nc_s = ta.sma(close, di_smooth)\n\ntr = math.max(math.max(h_s - l_s, math.abs(h_s - nz(c_s[1]))), math.abs(l_s - nz(c_s[1])))\ndm_p = (h_s - nz(h_s[1]) > nz(l_s[1]) - l_s) ? math.max(h_s - nz(h_s[1]), 0) : 0\ndm_m = (nz(l_s[1]) - l_s > h_s - nz(h_s[1])) ? math.max(nz(l_s[1]) - l_s, 0) : 0\n\nvar float s_tr = na\nvar float s_dm_p = na\nvar float s_dm_m = na\n\ns_tr := na(s_tr[1]) ? tr : (s_tr[1] - (s_tr[1] / adx_len) + tr)\ns_dm_p := na(s_dm_p[1]) ? dm_p : (s_dm_p[1] - (s_dm_p[1] / adx_len) + dm_p)\ns_dm_m := na(s_dm_m[1]) ? dm_m : (s_dm_m[1] - (s_dm_m[1] / adx_len) + dm_m)\n\ndi_plus = s_tr != 0 ? (s_dm_p / s_tr * 100) : 0\ndi_minus = s_tr != 0 ? (s_dm_m / s_tr * 100) : 0\n\ndx = (di_plus + di_minus) != 0 ? math.abs(di_plus - di_minus) / (di_plus + di_minus) * 100 : 0\nadx = ta.sma(dx, adx_len)\n\n// Trend Score\nvar int pos_count = 0\nvar int neg_count = 0\n\nif di_plus > di_plus[1] and di_plus > di_minus\n    pos_count += 1\n    neg_count := 0\nif di_minus > di_minus[1] and di_minus > di_plus\n    neg_count += 1\n    pos_count := 0\n\ntrend_score = pos_count - neg_count\n\n// MAs\nma20 = ta.sma(close, 20)\nma50 = ta.sma(close, 50)\nma200 = ta.sma(close, 200)\n\n// ATR\natr = ta.atr(14)\natr_sma = ta.sma(atr, 20)\nis_consolidating = use_consolidation and (atr < atr_sma * 0.7)\n\n// Volume\navg_volume = ta.sma(volume, 20)\nhas_volume = not require_volume or (volume > avg_volume * volume_multiplier)\n\n// Momentum check\nmomentum_distance = ((close - ma20) / ma20) * 100\nhas_bullish_momentum = not require_momentum or (momentum_distance > momentum_pct)\nhas_bearish_momentum = not require_momentum or (momentum_distance < -momentum_pct)\n\n// Pullback check (price near MA20)\nnear_ma20 = math.abs(momentum_distance) < 2.0\npullback_ok = not wait_for_pullback or near_ma20\n\n// Drawdown Protection\nvar float session_equity = strategy.initial_capital\nvar float peak_equity = strategy.initial_capital\nvar int consec_losses = 0\nvar bool paused = false\nvar float pos_multiplier = 1.0\n\nnew_day = ta.change(dayofweek) != 0\nif new_day\n    session_equity := strategy.equity\n\ncurr_equity = strategy.equity\nif curr_equity > peak_equity\n    peak_equity := curr_equity\n\ncurr_dd = curr_equity < peak_equity ? ((peak_equity - curr_equity) / peak_equity) * 100 : 0\ndaily_loss = curr_equity < session_equity ? ((session_equity - curr_equity) / session_equity) * 100 : 0\n\nif strategy.closedtrades > 0\n    if strategy.closedtrades != strategy.closedtrades[1]\n        last_profit = strategy.closedtrades.profit(strategy.closedtrades - 1)\n        if last_profit < 0\n            consec_losses += 1\n        else if last_profit > 0\n            consec_losses := 0\n\npause_daily = use_drawdown_prot and (daily_loss > max_daily_loss)\npause_consec = use_drawdown_prot and (consec_losses >= max_consec_losses)\npause_dd = use_drawdown_prot and (curr_dd > dd_pause_threshold)\npaused := pause_daily or pause_consec or pause_dd\n\nif reduce_after_loss and use_drawdown_prot\n    pos_multiplier := consec_losses >= 3 ? 0.5 : 1.0\nelse\n    pos_multiplier := 1.0\n\n// Entry Conditions\nbase_min_bars = entry_mode == \"Strict\" ? 3 : entry_mode == \"Balanced\" ? 2 : 1\nmin_bars_long = use_stricter_entries ? strict_long_bars : base_min_bars\nmin_bars_short = use_stricter_entries ? strict_short_bars : base_min_bars\n\n// LONG - SIMPLIFIED\nlong_signal = trend_score >= min_bars_long\nlong_adx = not use_adx_filter or adx > min_adx\nlong_ma = not use_ma_filter or close > ma50\nlong_di = di_plus > di_minus\nlong_not_consol = not is_consolidating\nlong_not_paused = not paused\nlong_momentum = has_bullish_momentum\nlong_pullback = pullback_ok\nlong_volume = has_volume\n\nlongCondition = allow_longs and long_signal and long_adx and long_ma and long_di and long_not_consol and long_not_paused and long_momentum and long_pullback and long_volume\n\n// SHORT - SIMPLIFIED\nshort_min = short_strong_adx ? short_min_bars : min_bars_short\nshort_signal = trend_score <= -short_min\nshort_adx_min = short_strong_adx ? 30 : min_adx\nshort_adx = not use_adx_filter or adx > short_adx_min\nshort_bear = not short_only_bear or (close < ma200 and ma50 < ma200)\nshort_ma = not use_ma_filter or close < ma50\nshort_di = di_minus > di_plus * 1.5\nshort_not_consol = not is_consolidating\nshort_momentum = has_bearish_momentum\nshort_pullback = pullback_ok\nshort_volume = has_volume\n\nshortCondition = allow_shorts and short_signal and short_adx and short_bear and short_ma and short_di and short_not_consol and long_not_paused and short_momentum and short_pullback and short_volume\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// POSITION MANAGEMENT\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nvar float entry_price = na\nvar float stop_level = na\nvar float target_level = na\nvar float trail_stop = na\nvar bool trailing = false\nvar bool scaled = false\n\nactual_pos_size = 50 * pos_multiplier\n\n// LONG ENTRY\nif longCondition and strategy.position_size == 0\n    entry_price := close\n    stop_amt = close * (long_stop / 100)\n    stop_level := close - stop_amt\n    target_level := close + (stop_amt * long_rr)\n    trail_stop := na\n    trailing := false\n    scaled := false\n    \n    strategy.entry(\"Long\", strategy.long, qty=actual_pos_size)\n    strategy.exit(\"Exit\", \"Long\", stop=stop_level, limit=target_level)\n\n// SHORT ENTRY\nif shortCondition and strategy.position_size == 0\n    entry_price := close\n    stop_amt = close * (short_stop / 100)\n    stop_level := close + stop_amt\n    target_level := close - (stop_amt * short_rr)\n    trail_stop := na\n    trailing := false\n    scaled := false\n    \n    strategy.entry(\"Short\", strategy.short, qty=actual_pos_size)\n    strategy.exit(\"Exit\", \"Short\", stop=stop_level, limit=target_level)\n\n// SCALING\nif enable_scaling and strategy.position_size > 0 and not scaled\n    if not na(entry_price) and not na(stop_level)\n        rr_long = (close - entry_price) / (entry_price - stop_level)\n        if rr_long >= scale_at_rr\n            strategy.entry(\"Long Add\", strategy.long, qty=scale_size)\n            scaled := true\n\nif enable_scaling and strategy.position_size < 0 and not scaled\n    if not na(entry_price) and not na(stop_level)\n        rr_short = (entry_price - close) / (stop_level - entry_price)\n        if rr_short >= scale_at_rr\n            strategy.entry(\"Short Add\", strategy.short, qty=scale_size)\n            scaled := true\n\n// TRAILING\nif use_trail and strategy.position_size > 0\n    if not na(entry_price) and not na(stop_level)\n        rr_trail = (close - entry_price) / (entry_price - stop_level)\n        if rr_trail >= 3.0\n            new_trail = close * (1 - trail_offset / 100)\n            if na(trail_stop) or new_trail > trail_stop\n                trail_stop := new_trail\n                trailing := true\n        if trailing and not na(trail_stop) and close < trail_stop\n            strategy.close(\"Long\")\n\nif use_trail and strategy.position_size < 0\n    if not na(entry_price) and not na(stop_level)\n        rr_trail = (entry_price - close) / (stop_level - entry_price)\n        if rr_trail >= 3.0\n            new_trail = close * (1 + trail_offset / 100)\n            if na(trail_stop) or new_trail < trail_stop\n                trail_stop := new_trail\n                trailing := true\n        if trailing and not na(trail_stop) and close > trail_stop\n            strategy.close(\"Short\")\n\n// EXIT ON OPPOSITE\nif exit_on_opposite\n    if strategy.position_size > 0 and shortCondition\n        strategy.close(\"Long\")\n    if strategy.position_size < 0 and longCondition\n        strategy.close(\"Short\")\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// VISUALS\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nin_long = strategy.position_size > 0\nin_short = strategy.position_size < 0\nlong_entry = longCondition and strategy.position_size == 0\nshort_entry = shortCondition and strategy.position_size == 0\n\nbar_col = long_entry ? color.new(color.lime, 0) :\n          short_entry ? color.new(color.red, 0) :\n          in_long ? color.new(color.green, 30) :\n          in_short ? color.new(color.red, 30) :\n          color.new(color.gray, 60)\n\nbarcolor(bar_col)\n\nplot(ma20, \"MA20\", color.orange)\nplot(ma50, \"MA50\", color.blue, linewidth=2)\nplot(ma200, \"MA200\", color.gray)\n\nshow_lines = strategy.position_size != 0\nplot(show_lines ? stop_level : na, \"Stop\", color.red, linewidth=3)\nplot(show_lines ? target_level : na, \"Target\", color.green, linewidth=3)\nplot(trailing and show_lines ? trail_stop : na, \"Trail\", color.orange, linewidth=2)\n\nplotshape(long_entry, \"Long\", shape.triangleup, location.belowbar, color.lime, size=size.normal)\nplotshape(short_entry, \"Short\", shape.triangledown, location.abovebar, color.red, size=size.normal)\n\n// Dashboard\nvar table dash = table.new(position.top_right, 2, 6)\nif barstate.islast\n    table.cell(dash, 0, 0, \"Position\", bgcolor=color.gray)\n    pos_txt = in_long ? \"LONG\" : in_short ? \"SHORT\" : \"FLAT\"\n    pos_col = in_long ? color.lime : in_short ? color.red : color.gray\n    table.cell(dash, 1, 0, pos_txt, text_color=pos_col, bgcolor=color.gray)\n    \n    table.cell(dash, 0, 1, \"Scaled\", bgcolor=color.gray)\n    table.cell(dash, 1, 1, scaled ? \"YES\" : \"No\", text_color=scaled ? color.aqua : color.gray, bgcolor=color.gray)\n    \n    table.cell(dash, 0, 2, \"Drawdown\", bgcolor=color.gray)\n    dd_col = curr_dd > 20 ? color.red : curr_dd > 10 ? color.orange : color.lime\n    table.cell(dash, 1, 2, str.tostring(curr_dd, \"#.#\") + \"%\", text_color=dd_col, bgcolor=color.gray)\n    \n    table.cell(dash, 0, 3, \"Consec Loss\", bgcolor=color.gray)\n    loss_col = consec_losses >= 3 ? color.red : consec_losses >= 2 ? color.orange : color.white\n    table.cell(dash, 1, 3, str.tostring(consec_losses), text_color=loss_col, bgcolor=color.gray)\n    \n    table.cell(dash, 0, 4, \"Status\", bgcolor=color.gray)\n    stat_txt = paused ? \"PAUSED\" : \"Active\"\n    stat_col = paused ? color.red : color.lime\n    table.cell(dash, 1, 4, stat_txt, text_color=stat_col, bgcolor=color.gray)\n    \n    table.cell(dash, 0, 5, \"ADX\", bgcolor=color.gray)\n    adx_col = adx > min_adx ? color.lime : color.red\n    table.cell(dash, 1, 5, str.tostring(math.round(adx)), text_color=adx_col, bgcolor=color.gray)"
  },
  {
    "url": "1x2AawHf-50-200-SMA-RSI-Average-Strategy-Long-Only-Single-Trade",
    "name": "50 & 200 SMA + RSI Average Strategy (Long Only, Single Trade)",
    "description": "It works better in trending markets. It delivers its best performance in the 4-hour to 1-day timeframes.",
    "image_url": "1x2AawHf",
    "author": "muratkbesiroglu",
    "likes": 19,
    "type": "strategy",
    "created": "2025-11-29",
    "updated": "2025-11-29",
    "source": "//@version=6\r\nstrategy(\"50 & 200 SMA + RSI OrtalamasÄ± Stratejisi (Long Only, Tek Ä°ÅŸlem)\",\r\n     overlay           = true,\r\n     initial_capital   = 1000,                      // BaÅŸlangÄ±Ã§ sermayesi: 1000$\r\n     pyramiding        = 0,                         // AynÄ± anda sadece 1 pozisyon\r\n     margin_long       = 100,\r\n     default_qty_type  = strategy.percent_of_equity,// Pozisyon bÃ¼yÃ¼klÃ¼ÄŸÃ¼: sermayenin yÃ¼zdesi\r\n     default_qty_value = 84)                       // %100 sermaye ile pozisyon\r\n\r\n//=== Parametreler ===//\r\nsmaLenShort  = input.int(50,  \"KÄ±sa SMA Periyodu (50)\")\r\nsmaLenLong   = input.int(200, \"Uzun SMA Periyodu (200)\")\r\n\r\nrsiLen       = input.int(21,  \"RSI Periyodu\")\r\nrsiMaLen     = input.int(9,   \"RSI Hareketli Ortalama Periyodu\")\r\n\r\nbuyRsiMaLvl  = input.float(57.0, \"AlÄ±ÅŸ RSI Ort. EÅŸiÄŸi\")\r\nsellRsiMaLvl = input.float(57.0, \"SatÄ±ÅŸ RSI Ort. EÅŸiÄŸi\")\r\n\r\n//=== Hareketli Ortalamalar ===//\r\nsma50  = ta.sma(close, smaLenShort)\r\nsma200 = ta.sma(close, smaLenLong)\r\n\r\n//=== RSI ve RSI'Ä±n Hareketli OrtalamasÄ± ===//\r\nrsiVal   = ta.rsi(close, rsiLen)\r\nrsiMaVal = ta.sma(rsiVal, rsiMaLen)\r\n\r\n//=== Pozisyonda mÄ±yÄ±z? ===//\r\ninLong = strategy.position_size > 0\r\n\r\n//=== AlÄ±ÅŸ KoÅŸulu ===//\r\n// Fiyat 50 SMA ve 200 SMA Ã¼zerinde\r\n// RSI'Ä±n hareketli ortalamasÄ± > 58\r\n// ve ÅŸu anda aÃ§Ä±k pozisyon yok\r\nlongEntryCond = close > sma50 and close > sma200 and rsiMaVal > buyRsiMaLvl and not inLong\r\n\r\n//=== SatÄ±ÅŸ KoÅŸulu ===//\r\n// Fiyat 50 SMA altÄ±nda\r\n// RSI'Ä±n hareketli ortalamasÄ± < 50\r\n// ve pozisyonda isek\r\nlongExitCond = close < sma50 and rsiMaVal < sellRsiMaLvl and inLong\r\n\r\n//=== Ä°ÅŸlemler ===//\r\nif longEntryCond\r\n    strategy.entry(\"Long\", strategy.long)\r\n\r\nif longExitCond\r\n    strategy.close(\"Long\")\r\n\r\n//=== GÃ¶rselleÅŸtirme ===//\r\nplot(sma50,  title = \"SMA 50\",  linewidth = 2)\r\nplot(sma200, title = \"SMA 200\", linewidth = 2)\r\n"
  },
  {
    "url": "kCWsY6Jq-Breakout-with-Alma-Slope-for-high-volatility-play",
    "name": "Breakout with Alma & Slope - for high volatility play",
    "description": "Sometimes best not to overthink,\nbuy at line crosses ;) \n\nNFA, DYOR\nbest for 15m-1Hr, high volatility FX,Gold etc\n\nLong only when 3 conditions met:-\n- Fast Alma crosses Slow Alma\n-Angle Pointing UP\n-ADX above 20\n\nShort when\n- aqua line below navy line\n- navy line pointing down\n- adx >20\n\n\n EXIT \n- Trailing Stop:  The trade closes automatically if price hits the **Red Stepped Line** (this is your safety net that follows the price).\n\n- Emergency Exit:** The trade closes immediately if the ALMA lines cross back in the opposite direction (Reversal).\n\n",
    "image_url": "kCWsY6Jq",
    "author": "hushedDiamond97573",
    "likes": 17,
    "type": "strategy",
    "created": "2025-11-28",
    "updated": "2025-11-28",
    "source": "//@version=5\nstrategy(\"SBR Master v6.0: ALMA Crossover & Slope\", overlay=true, \n     default_qty_type=strategy.percent_of_equity, default_qty_value=100, \n     commission_value=0.00)\n\n// â”€â”€â”€â”€â”€ INPUTS â”€â”€â”€â”€â”€\n\n// -- ALMA Settings (The Engine) --\nfastLen     = input.int(20, \"Fast ALMA Length\", minval=5, group=\"ALMA Settings\")\nslowLen     = input.int(50, \"Slow ALMA Length\", minval=10, group=\"ALMA Settings\")\nalmaOffset  = input.float(0.85, \"ALMA Offset\", step=0.05, group=\"ALMA Settings\")\nalmaSigma   = input.float(6.0, \"ALMA Sigma\", step=0.5, group=\"ALMA Settings\")\n\n// -- Filters (The Safety) --\nuseAdx      = input.bool(true, \"Use ADX Filter?\", tooltip=\"Only trade if trend strength is > 20\", group=\"Filters\")\nadxThresh   = input.int(20, \"Min ADX Threshold\", group=\"Filters\")\n\n// -- Risk Management --\n// Using a Trailing Stop is best for Crossovers to catch big runs\nuseTrail    = input.bool(true, \"Use Trailing Stop?\", group=\"Exits\")\natrTrail    = input.float(3.0, \"Trailing Stop (ATR Multiple)\", step=0.1, group=\"Exits\")\nhardRR      = input.float(2.0, \"Hard Target (Risk:Reward)\", step=0.1, tooltip=\"Optional fixed target if trend moves fast\", group=\"Exits\")\n\n// â”€â”€â”€â”€â”€ CALCULATIONS â”€â”€â”€â”€â”€\n\n// 1. ALMA Lines\nalmaFast = ta.alma(close, fastLen, almaOffset, almaSigma)\nalmaSlow = ta.alma(close, slowLen, almaOffset, almaSigma)\n\n// 2. Slope Detection (Crucial Filter)\n// We check if the Slow ALMA is higher now than it was 1 bar ago\nslowSlopeUp   = almaSlow > almaSlow[1]\nslowSlopeDown = almaSlow < almaSlow[1]\n\n// 3. ADX Filter\n[diplus, diminus, adxValue] = ta.dmi(14, 14)\ntrendActive = useAdx ? (adxValue > adxThresh) : true\n\n// â”€â”€â”€â”€â”€ ENTRY CONDITIONS â”€â”€â”€â”€â”€\n\n// LONG:\n// 1. Fast ALMA crosses OVER Slow ALMA\n// 2. The Slow ALMA is angling UP (Momentum is real)\n// 3. ADX says the market is awake\nlongCondition = ta.crossover(almaFast, almaSlow) and slowSlopeUp and trendActive\n\n// SHORT:\n// 1. Fast ALMA crosses UNDER Slow ALMA\n// 2. The Slow ALMA is angling DOWN\n// 3. ADX says the market is awake\nshortCondition = ta.crossunder(almaFast, almaSlow) and slowSlopeDown and trendActive\n\n// â”€â”€â”€â”€â”€ EXIT MANAGEMENT â”€â”€â”€â”€â”€\n\n// Calculate ATR for Stops\natr = ta.atr(14)\n\n// Variables to track entry price for R:R calculation\nvar float entryPrice = na\nvar float stopPrice  = na\n\nif longCondition and strategy.position_size == 0\n    entryPrice := close\n    stopPrice  := close - (atr * atrTrail) // Initial Stop\n    strategy.entry(\"Long Cross\", strategy.long)\n\nif shortCondition and strategy.position_size == 0\n    entryPrice := close\n    stopPrice  := close + (atr * atrTrail) // Initial Stop\n    strategy.entry(\"Short Cross\", strategy.short)\n\n// â”€â”€â”€â”€â”€ TRAILING STOP LOGIC â”€â”€â”€â”€â”€\n// This moves the stop loss behind the price as it moves in our favor\n\nif strategy.position_size > 0\n    // Trail the stop UP only\n    float newStop = close - (atr * atrTrail)\n    stopPrice := math.max(stopPrice, newStop)\n    strategy.exit(\"Exit Long\", from_entry=\"Long Cross\", stop=stopPrice)\n\nif strategy.position_size < 0\n    // Trail the stop DOWN only\n    float newStop = close + (atr * atrTrail)\n    stopPrice := math.min(stopPrice, newStop)\n    strategy.exit(\"Exit Short\", from_entry=\"Short Cross\", stop=stopPrice)\n\n// Close on Reverse Signal (Safety Net)\nif strategy.position_size > 0 and ta.crossunder(almaFast, almaSlow)\n    strategy.close(\"Long Cross\", comment=\"Reverse\")\nif strategy.position_size < 0 and ta.crossover(almaFast, almaSlow)\n    strategy.close(\"Short Cross\", comment=\"Reverse\")\n\n// â”€â”€â”€â”€â”€ VISUALS â”€â”€â”€â”€â”€\n\n// Plot the Ribbons\npFast = plot(almaFast, \"Fast ALMA\", color=color.aqua, linewidth=2)\npSlow = plot(almaSlow, \"Slow ALMA\", color=color.navy, linewidth=2)\n\n// Fill Color to show trend direction clearly\nfill(pFast, pSlow, color = almaFast > almaSlow ? color.new(color.green, 80) : color.new(color.red, 80), title=\"Trend Cloud\")\n\n// Plot Signals\nplotshape(longCondition, title=\"Buy Cross\", location=location.belowbar, color=color.green, style=shape.triangleup, size=size.small, text=\"CROSS\")\nplotshape(shortCondition, title=\"Sell Cross\", location=location.abovebar, color=color.red, style=shape.triangledown, size=size.small, text=\"CROSS\")\n\n// Plot Stop Loss line for visual tracking\nplot(strategy.position_size != 0 ? stopPrice : na, \"Trailing SL\", color=color.red, style=plot.style_linebr)"
  },
  {
    "url": "IVKy1kJr-Turtle-Momentum-Strategy",
    "name": "Turtle Momentum Strategy",
    "description": "Turtle momentum strategy as per Momentum Trading Strategy article on Substack (Nov 26, 2025)",
    "image_url": "IVKy1kJr",
    "author": "CryptoAutoTrader",
    "likes": 23,
    "type": "strategy",
    "created": "2025-11-28",
    "updated": "2025-11-28",
    "source": "//@version=5\nstrategy(\"Turtle Momentum Strategy\",\n     overlay                 = true,\n     initial_capital         = 100000,\n     pyramiding              = 3,                    // we manage pyramiding manually up to 4 units\n     commission_type         = strategy.commission.percent,\n     commission_value        = 0.1,                  // 0.1% commission\n     default_qty_type        = strategy.fixed,\n     default_qty_value       = 1,\n     process_orders_on_close = true)\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// 1. Inputs\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n// Choose which Turtle system to trade\nsystemMode = input.string(     \"System 2 (Long-Term)\",     \"System to Trade\",     options = [\"System 1 (Short-Term)\", \"System 2 (Long-Term)\"])\n\n// Direction filter (handy for testing long-only on indexes/crypto)\ndirection = input.string(     \"Both\",     \"Trade direction\",     options = [\"Both\", \"Long Only\", \"Short Only\"])\nlongEnabled  = direction == \"Both\" or direction == \"Long Only\"\nshortEnabled = direction == \"Both\" or direction == \"Short Only\"\n\n// Trading window inputs\nstartDate = input.time(     defval = timestamp(\"2017-12-31T00:00:00\"),     title  = \"Start trading from\")\n\nendDate = input.time(     defval = timestamp(\"2099-12-31T00:00:00\"),     title  = \"End trading at\")\n\ninTradeWindow = time >= startDate and time <= endDate\n\nisSystem1 = systemMode == \"System 1 (Short-Term)\"\n\nriskPct  = input.float(2.0, \"Risk per Trade (% of equity)\", minval = 0.1, maxval = 5.0)\natrLen   = input.int(20, \"ATR length (N)\", minval = 1)\nstopN    = input.float(2.0, \"Stop distance in N (2N in article)\")\naddStepN = input.float(0.5, \"Add unit every N move (0.5N in article)\")\nmaxUnits = input.int(4, \"Max units (including initial)\", minval = 1, maxval = 10)\n\n// Donchian parameters from the article\ndc1EntryLen = input.int(20, \"System 1 entry Donchian (20)\", minval = 1)\ndc1ExitLen  = input.int(10, \"System 1 exit Donchian (10)\",  minval = 1)\ndc2EntryLen = input.int(55, \"System 2 entry Donchian (55)\", minval = 1)\ndc2ExitLen  = input.int(20, \"System 2 exit Donchian (20)\",  minval = 1)\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// 2. Core Turtle metrics: N (ATR), Donchian Channels\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nN = ta.atr(atrLen)\n\n// System 1 Donchian\ns1High = ta.highest(high, dc1EntryLen)\ns1Low  = ta.lowest(low,  dc1EntryLen)\n\n// For exits, we use the previous bar's Donchian channel (very important)\n// so exits can actually trigger.\ns1ExitLow  = ta.lowest(low,  dc1ExitLen)[1]\ns1ExitHigh = ta.highest(high, dc1ExitLen)[1]\n\n// System 2 Donchian (55/20 mixed lookback)\ns2High = ta.highest(high, dc2EntryLen)\ns2Low  = ta.lowest(low,  dc2EntryLen)\ns2ExitLow  = ta.lowest(low,  dc2ExitLen)[1]\ns2ExitHigh = ta.highest(high, dc2ExitLen)[1]\n\n// Use [1] for breakout to avoid â€œsame-barâ€ lookback (entries)\nlongBreakout  = isSystem1 ? close > s1High[1] : close > s2High[1]\nshortBreakout = isSystem1 ? close < s1Low[1]  : close < s2Low[1]\n\n// Donchian exits by system (now reachable thanks to [1] on exit channels)\nlongDonchExit  = isSystem1 ? close < s1ExitLow  : close < s2ExitLow\nshortDonchExit = isSystem1 ? close > s1ExitHigh : close > s2ExitHigh\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// 3. State variables: entry price, units, System 1 skip rule\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nvar float baseEntryPrice = na\nvar int   unitCount      = 0\n\n// System 1 rule: â€œIf last breakout was a winner, skip the next breakoutâ€\nvar bool skipNextLongBreakout  = false\nvar bool skipNextShortBreakout = false\n\n// For detecting trade closes (previous barâ€™s position)\nposSizePrev    = strategy.position_size[1]\nposDirPrev     = posSizePrev > 0 ? 1 : posSizePrev < 0 ? -1 : 0\ntradeClosedLong  = posDirPrev == 1  and strategy.position_size == 0\ntradeClosedShort = posDirPrev == -1 and strategy.position_size == 0\n\n// When a trade closes, evaluate PnL and set skip flags for System 1\nif (tradeClosedLong or tradeClosedShort) and not na(baseEntryPrice)\n    dir = posDirPrev\n    qty = math.abs(posSizePrev)\n\n    // Approximate exit at current close\n    profit = (close - baseEntryPrice) * dir * qty * syminfo.pointvalue\n\n    if isSystem1\n        if dir == 1 and profit > 0\n            skipNextLongBreakout := true\n        if dir == -1 and profit > 0\n            skipNextShortBreakout := true\n\n    // reset per-trade variables\n    baseEntryPrice := na\n    unitCount      := 0\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// 4. Position sizing: risk a fixed % of equity with 2N stop\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nf_calcQty(_N, _riskPct, _stopN) =>\n    _N > 0 ? math.max(1, math.floor((strategy.equity * (_riskPct / 100)) / (_stopN * _N * syminfo.pointvalue))) : 0\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// 5. Entry logic (with System 1 skip-after-win filter)\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nflat = strategy.position_size == 0\n\n// LONG entry\ndoLongEntry = longBreakout and flat and longEnabled\n\nif inTradeWindow and doLongEntry\n    if isSystem1 and skipNextLongBreakout\n        // consume the â€œskip nextâ€ and do nothing\n        skipNextLongBreakout := false\n    else\n        qty = f_calcQty(N, riskPct, stopN)\n        if qty > 0\n            strategy.entry(\"Long\", strategy.long, qty = qty)\n            baseEntryPrice := close\n            unitCount      := 1\n\n// SHORT entry\ndoShortEntry = shortBreakout and flat and shortEnabled\n\nif inTradeWindow and doShortEntry\n    if isSystem1 and skipNextShortBreakout\n        skipNextShortBreakout := false\n    else\n        qty = f_calcQty(N, riskPct, stopN)\n        if qty > 0\n            strategy.entry(\"Short\", strategy.short, qty = qty)\n            baseEntryPrice := close\n            unitCount      := 1\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// 6. Pyramiding: add 1 unit every 0.5N in your favor, up to maxUnits\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\ninLong  = strategy.position_size > 0\ninShort = strategy.position_size < 0\n\n// Long pyramiding\nif inLong and unitCount > 0 and unitCount < maxUnits and not na(baseEntryPrice)\n    // each add is 0.5N above last filled unit â†’ base + 0.5N * current unitCount\n    nextAddPrice = baseEntryPrice + addStepN * N * unitCount\n    if close >= nextAddPrice\n        qty = f_calcQty(N, riskPct, stopN)\n        if qty > 0\n            strategy.entry(\"Long\", strategy.long, qty = qty)\n            unitCount += 1\n\n// Short pyramiding\nif inShort and unitCount > 0 and unitCount < maxUnits and not na(baseEntryPrice)\n    nextAddPrice = baseEntryPrice - addStepN * N * unitCount\n    if close <= nextAddPrice\n        qty = f_calcQty(N, riskPct, stopN)\n        if qty > 0\n            strategy.entry(\"Short\", strategy.short, qty = qty)\n            unitCount += 1\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// 7. Exits: 2N ATR stop + Donchian exit\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nlongStopPrice  = not na(baseEntryPrice) ? baseEntryPrice - stopN * N : na\nshortStopPrice = not na(baseEntryPrice) ? baseEntryPrice + stopN * N : na\n\nif inLong and not na(longStopPrice)\n    strategy.exit(\"Long Stop\", \"Long\", stop = longStopPrice)\n\nif inShort and not na(shortStopPrice)\n    strategy.exit(\"Short Stop\", \"Short\", stop = shortStopPrice)\n\n// Donchian exits for open trades\nif inLong and longDonchExit\n    strategy.close(\"Long\", comment = \"Donchian Exit\")\n\nif inShort and shortDonchExit\n    strategy.close(\"Short\", comment = \"Donchian Exit\")\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// 8. Visuals â€“ Donchian bands & ATR stop\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nentryHighPlot = isSystem1 ? s1High : s2High\nentryLowPlot  = isSystem1 ? s1Low  : s2Low\nexitLowPlot   = isSystem1 ? s1ExitLow : s2ExitLow\nexitHighPlot  = isSystem1 ? s1ExitHigh : s2ExitHigh\n\nplot(entryHighPlot, \"Entry High (Donchian)\", style = plot.style_line)\nplot(entryLowPlot,  \"Entry Low (Donchian)\",  style = plot.style_line)\nplot(exitLowPlot,   \"Exit Low (Donchian)\",   style = plot.style_line)\nplot(exitHighPlot,  \"Exit High (Donchian)\",  style = plot.style_line)\n\nplot(inLong  and not na(longStopPrice)  ? longStopPrice  : na,\n     \"ATR Stop Long\",\n     style = plot.style_line)\n\nplot(inShort and not na(shortStopPrice) ? shortStopPrice : na,\n     \"ATR Stop Short\",\n     style = plot.style_line)\n"
  },
  {
    "url": "WeapP9KD-ema-12-26-100-momentum-strategy",
    "name": "EMA 12-26-100 Momentum Strategy",
    "description": "# Triple EMA Multi-Signal Momentum Strategy\n\n## ðŸ“Š Overview\n\n**Triple EMA Multi-Signal** is a comprehensive trend-following momentum strategy designed specifically for cryptocurrency markets. It combines multiple technical indicators and signal types to identify high-probability trading opportunities while maintaining strict risk management protocols.\n\nThe strategy excels in trending markets and uses adaptive position sizing with trailing stops to maximize profits during strong trends while protecting capital during choppy conditions.\n\n## ðŸŽ¯ Core Algorithm\n\n### Triple EMA System\nThe strategy employs a three-layer EMA system to identify trend direction and strength:\n- **Fast EMA (12)**: Quick response to price changes\n- **Slow EMA (26)**: Confirmation of trend direction  \n- **Trend EMA (100)**: Overall market bias filter\n\nTrades are only taken when all three EMAs align in the same direction, ensuring we trade with the dominant trend.\n\n### Multi-Signal Confirmation (8 Signal Types)\n\nThe strategy requires at least 1-2 confirmed signals from multiple independent sources before entering a position:\n\n1. **EMA Crossover** - Fast EMA crossing Slow EMA (primary signal)\n2. **MACD Cross** - MACD line crossing signal line (momentum confirmation)\n3. **RSI Reversal** - RSI bouncing from oversold/overbought zones\n4. **Price Action** - Strong bullish/bearish candles (>60% of range)\n5. **Volume Spike** - Above-average volume confirmation\n6. **Breakout** - Price breaking 20-period high/low with volume\n7. **Pullback to EMA** - Trend continuation after healthy retracement\n8. **Bollinger Bounce** - Price bouncing from BB bands\n\nThis multi-signal approach significantly reduces false signals and improves win rate.\n\n## ðŸ’° Risk Management\n\n### Position Sizing\n- Default: 20-25% of equity per trade\n- Adjustable based on risk tolerance\n- Smaller positions recommended for leveraged trading\n\n### Stop Loss & Take Profit\n- **Stop Loss**: 2.0% (tight control of risk)\n- **Take Profit**: 5.5% (2.75:1 reward-to-risk ratio)\n- Both levels are fixed at entry to avoid emotional decisions\n\n### Trailing Stop System\n- Activates after 1.8% profit\n- Trails at 1.3% below current price\n- Locks in profits during extended trends\n- Automatically adjusts as price moves in your favor\n\n### Maximum Hold Time\n- 36-48 hours maximum (configurable)\n- Designed to minimize funding rate costs on futures\n- Forces position closure to avoid excessive exposure\n- Helps maintain capital velocity\n\n## ðŸ“ˆ Key Features\n\n### Trend Filters\n- **ADX Filter**: Ensures sufficient trend strength (threshold: 20)\n- **EMA Alignment**: All three EMAs must confirm trend direction\n- **RSI Boundaries**: Avoids extreme overbought/oversold entries\n\n### Volume Analysis\n- Volume must exceed 20-period moving average\n- Configurable multiplier (default: 1.0x)\n- Helps identify institutional participation\n\n### Automatic Exit Conditions\n1. Take Profit target reached\n2. Stop Loss triggered\n3. Trailing stop activated\n4. Trend reversal (EMA cross in opposite direction)\n5. Maximum hold time exceeded\n\n## ðŸŽ® Recommended Settings\n\n### For Spot Trading (Conservative)\n```\nPosition Size: 15-20%\nStop Loss: 2.5%\nTake Profit: 6.0%\nMax Hold: 72 hours\nLeverage: 1x\n```\n\n### For Futures 3-5x Leverage (Balanced)\n```\nPosition Size: 12-15%\nStop Loss: 2.0%\nTake Profit: 5.5%\nMax Hold: 36 hours\nTrailing: Active\n```\n\n### For Aggressive Trading 5-10x (High Risk)\n```\nPosition Size: 8-12%\nStop Loss: 1.5%\nTake Profit: 4.5%\nMax Hold: 24 hours\nADX Filter: Disabled\n```\n\n## ðŸ“Š Performance Metrics\n\n### Backtested Results (BTC/USDT 1H, 2 years)\n- **Total Return**: ~19% (spot) / ~75% (5x leverage)*\n- **Total Trades**: 240-300\n- **Win Rate**: 49-52%\n- **Profit Factor**: 1.25-1.50\n- **Max Drawdown**: ~18-22%\n- **Average Trade**: 0.5-3 days\n\n*Leverage results exclude funding rates and real-world slippage\n\n### Optimal Timeframes\n- **1 Hour**: Best for active trading (recommended)\n- **4 Hour**: More stable, fewer signals\n- **15 Min**: High frequency (requires monitoring)\n\n### Best Performing Assets\n- BTC/USDT (most tested)\n- ETH/USDT\n- Major altcoins with good liquidity\n- Not recommended for low-cap or illiquid pairs\n\n## âš™ï¸ How to Use\n\n1. **Add to Chart**: Apply strategy to 1H BTC/USDT chart\n2. **Adjust Settings**: Configure risk parameters based on your preference\n3. **Review Signals**: Green = Long, Red = Short, labels show signal count\n4. **Monitor Performance**: Check strategy tester for detailed statistics\n5. **Optimize**: Use strategy optimization to find best parameters for your market\n\n## ðŸŽ¨ Visual Indicators\n\nThe strategy provides clear visual feedback:\n- **EMA Lines**: Blue (Fast), Red (Slow), Orange (Trend)\n- **BUY/SELL Labels**: Show entry points with signal count\n- **Stop/Target Lines**: Red (SL), Green (TP) displayed during active trades\n- **Background Color**: Light green (long), light red (short) when in position\n- **Info Panel**: Shows current trend, RSI, ADX, and volume status\n\n## âš ï¸ Important Notes\n\n### Risk Disclaimer\n- This strategy is for educational purposes only\n- Past performance does not guarantee future results\n- Cryptocurrency trading involves substantial risk\n- Only trade with capital you can afford to lose\n- Always use proper position sizing and risk management\n\n### Limitations\n- Performs poorly in sideways/choppy markets\n- Requires sufficient liquidity for best execution\n- Backtests do not include:\n  - Real-world slippage (especially during volatility)\n  - Funding rates (for perpetual futures)\n  - Exchange downtime or connection issues\n  - Emotional trading decisions\n\n### For Futures Trading\nIf using this strategy on futures with leverage:\n- Reduce position size proportionally to leverage\n- Account for funding rates (~0.01% per 8h)\n- Set max hold time to minimize funding costs\n- Use lower leverage (3-5x max recommended)\n- Monitor liquidation price carefully\n\n## ðŸ”§ Customization\n\nAll parameters are fully customizable:\n- EMA periods (fast/slow/trend)\n- MACD settings (12/26/9)\n- RSI levels (30/70)\n- Stop Loss / Take Profit percentages\n- Trailing stop activation and offset\n- Volume multiplier\n- ADX threshold\n- Maximum hold time\n\n## ðŸ“š Strategy Logic\n\nThe strategy follows this decision tree:\n\n```\n1. Check Trend Direction (EMA alignment)\n   â†“\n2. Scan for Entry Signals (8 types)\n   â†“\n3. Confirm with Filters (ADX, Volume, RSI)\n   â†“\n4. Enter Position with Fixed SL/TP\n   â†“\n5. Monitor for Exit Conditions:\n   - TP Hit â†’ Close with profit\n   - SL Hit â†’ Close with loss\n   - Trailing Active â†’ Follow price\n   - Trend Reversal â†’ Close position\n   - Max Time â†’ Force close\n```\n\n## ðŸŽ“ Best Practices\n\n1. **Start Conservative**: Use smaller position sizes initially\n2. **Track Performance**: Monitor actual vs backtested results\n3. **Optimize Regularly**: Market conditions change, adapt parameters\n4. **Combine with Analysis**: Don't rely solely on automated signals\n5. **Manage Emotions**: Stick to the system, avoid manual overrides\n6. **Paper Trade First**: Test on demo before risking real capital\n\n## ðŸ“ž Support & Updates\n\nThis strategy is actively maintained and updated based on:\n- Market condition changes\n- User feedback and suggestions\n- Performance optimization\n- Bug fixes and improvements\n\n## ðŸ† Conclusion\n\nTriple EMA Multi-Signal Strategy offers a robust, systematic approach to cryptocurrency trading by combining trend following, momentum indicators, and strict risk management. Its multi-signal confirmation system helps filter false signals while the trailing stop mechanism captures extended trends.\n\nThe strategy is suitable for both manual traders looking for high-probability setups and algorithmic traders seeking a proven systematic approach.\n\n**Remember**: No strategy wins 100% of the time. Success comes from consistent application, proper risk management, and continuous adaptation to changing market conditions.\n\n---\n\n*Version: 1.0*  \n*Last Updated: November 2025*  \n*Tested on: BTC/USDT, ETH/USDT (1H, 4H timeframes)*  \n*Recommended Capital: $5,000+ for optimal position sizing*\n",
    "image_url": "WeapP9KD",
    "author": "RomanEnlil",
    "likes": 22,
    "type": "strategy",
    "created": "2025-11-28",
    "updated": "2025-11-28",
    "source": "//@version=6\nstrategy(title='E<A 12-26-100 Momentum Strategy', \n         shorttitle='', \n         overlay=true, \n         pyramiding=0, \n         initial_capital=10000, \n         default_qty_type=strategy.percent_of_equity,\n         default_qty_value=25,\n         commission_type=strategy.commission.percent,\n         commission_value=0.075,\n         slippage=3,\n         calc_on_every_tick=true,  // ÐÑƒÐ¶Ð½Ð¾ Ð´Ð»Ñ barstate.islast Ð² Ñ€ÐµÐ°Ð»ÑŒÐ½Ð¾Ð¼ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð¸\n         process_orders_on_close=true)  // ÐÐ¾ Ð¾Ñ€Ð´ÐµÑ€Ð° Ð²ÑÐµ Ñ€Ð°Ð²Ð½Ð¾ Ð½Ð° Ð·Ð°ÐºÑ€Ñ‹Ñ‚Ð¸Ð¸!\n\n// Ð¦Ð•Ð›Ð¬: $10,000 â†’ $18,000+ Ð·Ð° 2 Ð³Ð¾Ð´Ð°\n// ÐŸÐžÐ”Ð¥ÐžÐ”: Ð¢Ñ€ÐµÐ½Ð´Ð¾Ð²Ð°Ñ ÑÑ‚Ñ€Ð°Ñ‚ÐµÐ³Ð¸Ñ + Ð¼Ð¾Ð¼ÐµÐ½Ñ‚ÑƒÐ¼ + Ð¼Ð½Ð¾Ð¶ÐµÑÑ‚Ð²ÐµÐ½Ð½Ñ‹Ðµ Ð²Ñ…Ð¾Ð´Ñ‹\n\n// ============================================================================\n// ÐÐÐ¡Ð¢Ð ÐžÐ™ÐšÐ˜\n// ============================================================================\n\n// --- Ð¢Ñ€ÐµÐ½Ð´ ---\nemaFast = input.int(12, \"Fast EMA\", minval=5, maxval=50, group=\"Trend\")\nemaSlow = input.int(26, \"Slow EMA\", minval=20, maxval=100, group=\"Trend\")\nemaTrend = input.int(100, \"Trend EMA\", minval=50, maxval=200, group=\"Trend\")\n\n// --- ÐœÐ¾Ð¼ÐµÐ½Ñ‚ÑƒÐ¼ ---\nrsiLen = input.int(14, \"RSI Length\", group=\"Momentum\")\nrsiOB = input.int(70, \"RSI Overbought\", group=\"Momentum\")\nrsiOS = input.int(30, \"RSI Oversold\", group=\"Momentum\")\nmacdFast = input.int(12, \"MACD Fast\", group=\"Momentum\")\nmacdSlow = input.int(26, \"MACD Slow\", group=\"Momentum\")\nmacdSignal = input.int(9, \"MACD Signal\", group=\"Momentum\")\n\n// --- Risk Management ---\nstopLoss = input.float(2.0, \"Stop Loss %\", minval=1.0, maxval=5.0, step=0.5, group=\"Risk\", \n                       tooltip=\"ÐœÐµÐ½ÑŒÑˆÐµ Ð´Ð»Ñ Ñ„ÑŒÑŽÑ‡ÐµÐ¹ Ñ Ð¿Ð»ÐµÑ‡Ð¾Ð¼\")\ntakeProfit = input.float(5.5, \"Take Profit %\", minval=3.0, maxval=15.0, step=0.5, group=\"Risk\",\n                         tooltip=\"TP:SL = 2.75:1 Ð´Ð»Ñ Ð»ÑƒÑ‡ÑˆÐµÐ¹ Ð¿Ñ€Ð¸Ð±Ñ‹Ð»ÑŒÐ½Ð¾ÑÑ‚Ð¸\")\nuseTrailing = input.bool(true, \"Trailing Stop\", group=\"Risk\")\ntrailPct = input.float(1.3, \"Trail %\", minval=0.5, maxval=3.0, step=0.1, group=\"Risk\")\ntrailActivate = input.float(1.8, \"Trail Activation %\", minval=1.0, maxval=5.0, step=0.2, group=\"Risk\", tooltip=\"Ð‘Ñ‹ÑÑ‚Ñ€ÐµÐµ Ð°ÐºÑ‚Ð¸Ð²Ð¸Ñ€ÑƒÐµÐ¼ trailing\")\nmaxHoldBars = input.int(36, \"Max Hold Time (hours)\", minval=12, maxval=168, group=\"Risk\",tooltip=\"36Ñ‡ = Ð¸Ð·Ð±ÐµÐ³Ð°ÐµÐ¼ Ð»Ð¸ÑˆÐ½Ð¸Ñ… funding Ð¿Ð»Ð°Ñ‚ÐµÐ¶ÐµÐ¹\")\n\n// --- Ð¤Ð¸Ð»ÑŒÑ‚Ñ€Ñ‹ ---\nminVolMultiplier = input.float(1.0, \"Min Volume Multiplier\", minval=0.5, maxval=3.0, step=0.5, group=\"Filters\")\nuseADX = input.bool(true, \"Use ADX Filter\", group=\"Filters\")\nadxThreshold = input.int(20, \"ADX Threshold\", minval=15, maxval=40, group=\"Filters\")\n\n// ============================================================================\n// Ð˜ÐÐ”Ð˜ÐšÐÐ¢ÐžÐ Ð«\n// ============================================================================\n\n// EMA\nema_fast = ta.ema(close, emaFast)\nema_slow = ta.ema(close, emaSlow)\nema_trend = ta.ema(close, emaTrend)\n\n// RSI\nrsi = ta.rsi(close, rsiLen)\n\n// MACD\n[macdLine, signalLine, histLine] = ta.macd(close, macdFast, macdSlow, macdSignal)\n\n// Volume\nvolSMA = ta.sma(volume, 20)\n\n// ADX (Ñ‚Ñ€ÐµÐ½Ð´ ÑÐ¸Ð»Ñ‹)\n[diPlus, diMinus, adx] = ta.dmi(14, 14)\n\n// Bollinger Bands Ð´Ð»Ñ Ð²Ð¾Ð»Ð°Ñ‚Ð¸Ð»ÑŒÐ½Ð¾ÑÑ‚Ð¸\n[bbMiddle, bbUpper, bbLower] = ta.bb(close, 20, 2)\n\n// ATR\natr = ta.atr(14)\n\n// Ð’Ð¸Ð·ÑƒÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ\nplot(ema_fast, \"EMA Fast\", color.blue, 2)\nplot(ema_slow, \"EMA Slow\", color.red, 2)\nplot(ema_trend, \"EMA Trend\", color.orange, 3)\n\n// ============================================================================\n// ÐžÐŸÐ Ð•Ð”Ð•Ð›Ð•ÐÐ˜Ð• Ð¢Ð Ð•ÐÐ”Ð\n// ============================================================================\n\n// Ð¡Ð¸Ð»ÑŒÐ½Ñ‹Ð¹ Ð±Ñ‹Ñ‡Ð¸Ð¹ Ñ‚Ñ€ÐµÐ½Ð´\nstrongBullTrend = close > ema_trend and \n                  ema_fast > ema_slow and \n                  ema_slow > ema_trend and\n                  close > close[1]\n\n// Ð¡Ð¸Ð»ÑŒÐ½Ñ‹Ð¹ Ð¼ÐµÐ´Ð²ÐµÐ¶Ð¸Ð¹ Ñ‚Ñ€ÐµÐ½Ð´\nstrongBearTrend = close < ema_trend and \n                  ema_fast < ema_slow and \n                  ema_slow < ema_trend and\n                  close < close[1]\n\n// Ð¡Ñ€ÐµÐ´Ð½Ð¸Ð¹ Ñ‚Ñ€ÐµÐ½Ð´\nmediumBullTrend = close > ema_trend and ema_fast > ema_slow\nmediumBearTrend = close < ema_trend and ema_fast < ema_slow\n\n// ÐžÐ±Ñ‰Ð¸Ð¹ Ñ‚Ñ€ÐµÐ½Ð´\nbullTrend = mediumBullTrend\nbearTrend = mediumBearTrend\n\n// ADX Ñ„Ð¸Ð»ÑŒÑ‚Ñ€ (ÑÐ¸Ð»Ð° Ñ‚Ñ€ÐµÐ½Ð´Ð°)\nadxOK = not useADX or adx > adxThreshold\n\n// ============================================================================\n// Ð¡Ð˜Ð“ÐÐÐ›Ð« Ð’Ð¥ÐžÐ”Ð - ÐœÐÐžÐ–Ð•Ð¡Ð¢Ð’Ð•ÐÐÐ«Ð•\n// ============================================================================\n\n// --- 1. EMA CROSS (Ð³Ð»Ð°Ð²Ð½Ñ‹Ð¹ ÑÐ¸Ð³Ð½Ð°Ð») ---\nemaCrossUp = ta.crossover(ema_fast, ema_slow)\nemaCrossDown = ta.crossunder(ema_fast, ema_slow)\n\n// --- 2. MACD CROSS ---\nmacdCrossUp = ta.crossover(macdLine, signalLine)\nmacdCrossDown = ta.crossunder(macdLine, signalLine)\n\n// --- 3. RSI REVERSAL ---\nrsiReverseUp = rsi[1] < rsiOS and rsi > rsiOS and rsi > rsi[1]\nrsiReverseDown = rsi[1] > rsiOB and rsi < rsiOB and rsi < rsi[1]\n\n// --- 4. PRICE ACTION ---\nbullishCandle = close > open and (close - open) > (high - low) * 0.6\nbearishCandle = close < open and (open - close) > (high - low) * 0.6\n\n// --- 5. VOLUME SPIKE ---\nvolumeSpike = volume > volSMA * minVolMultiplier\n\n// --- 6. BREAKOUT ---\nbreakoutUp = close > ta.highest(high[1], 20) and volumeSpike\nbreakoutDown = close < ta.lowest(low[1], 20) and volumeSpike\n\n// --- 7. PULLBACK TO EMA ---\npullbackBull = bullTrend and \n               low <= ema_fast * 1.01 and \n               close > ema_fast and\n               bullishCandle\n\npullbackBear = bearTrend and \n               high >= ema_fast * 0.99 and \n               close < ema_fast and\n               bearishCandle\n\n// --- 8. BOLLINGER BOUNCE ---\nbbBounceBull = close[1] <= bbLower and close > bbLower and bullishCandle\nbbBounceBear = close[1] >= bbUpper and close < bbUpper and bearishCandle\n\n// ============================================================================\n// ÐšÐžÐœÐ‘Ð˜ÐÐ˜Ð ÐžÐ’ÐÐÐÐ«Ð• Ð£Ð¡Ð›ÐžÐ’Ð˜Ð¯ Ð’Ð¥ÐžÐ”Ð\n// ============================================================================\n\n// Ð›ÐžÐÐ“: ÐÑƒÐ¶Ð½Ð¾ Ð¼Ð¸Ð½Ð¸Ð¼ÑƒÐ¼ 2 ÑÐ¸Ð³Ð½Ð°Ð»Ð° Ð¸Ð· Ñ€Ð°Ð·Ð½Ñ‹Ñ… ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ð¹\nlongSignalCount = (emaCrossUp ? 1 : 0) + \n                  (macdCrossUp ? 1 : 0) + \n                  (rsiReverseUp ? 1 : 0) + \n                  (breakoutUp ? 1 : 0) + \n                  (pullbackBull ? 1 : 0) + \n                  (bbBounceBull ? 1 : 0)\n\n// Ð¨ÐžÐ Ð¢\nshortSignalCount = (emaCrossDown ? 1 : 0) + \n                   (macdCrossDown ? 1 : 0) + \n                   (rsiReverseDown ? 1 : 0) + \n                   (breakoutDown ? 1 : 0) + \n                   (pullbackBear ? 1 : 0) + \n                   (bbBounceBear ? 1 : 0)\n\n// Ð¤Ð¸Ð½Ð°Ð»ÑŒÐ½Ñ‹Ðµ ÑƒÑÐ»Ð¾Ð²Ð¸Ñ\nlongEntry = longSignalCount >= 1 and             bullTrend and             volumeSpike and             adxOK and            rsi < 75  // ÐÐµ Ð¿Ð¾ÐºÑƒÐ¿Ð°ÐµÐ¼ Ð² Ð¿ÐµÑ€ÐµÐºÑƒÐ¿Ð»ÐµÐ½Ð½Ð¾ÑÑ‚Ð¸\n\nshortEntry = shortSignalCount >= 1 and\n             bearTrend and \n             volumeSpike and \n             adxOK and\n             rsi > 25  // ÐÐµ Ð¿Ñ€Ð¾Ð´Ð°ÐµÐ¼ Ð² Ð¿ÐµÑ€ÐµÐ¿Ñ€Ð¾Ð´Ð°Ð½Ð½Ð¾ÑÑ‚Ð¸\n\n// ============================================================================\n// Ð’Ð˜Ð—Ð£ÐÐ›Ð˜Ð—ÐÐ¦Ð˜Ð¯ Ð¡Ð˜Ð“ÐÐÐ›ÐžÐ’\n// ============================================================================\n\nplotshape(longEntry, \"LONG\", shape.labelup, location.belowbar, \n          color.new(color.green, 0), text=\"BUY\", textcolor=color.white, size=size.normal)\nplotshape(shortEntry, \"SHORT\", shape.labeldown, location.abovebar, \n          color.new(color.red, 0), text=\"SELL\", textcolor=color.white, size=size.normal)\n\n// Ð¤Ð¾Ð½ Ñ‚Ñ€ÐµÐ½Ð´Ð°\nbgcolor(strongBullTrend ? color.new(color.green, 95) :         strongBearTrend ? color.new(color.red, 95) : na)\n\n// ============================================================================\n// Ð¢ÐžÐ Ð“ÐžÐ’ÐÐ¯ Ð›ÐžÐ“Ð˜ÐšÐ\n// ============================================================================\n\nvar float entryPrice = na\nvar float stopPrice = na\nvar float profitPrice = na\n\n// LONG ENTRY\nif longEntry and strategy.position_size == 0\n    entryPrice := close\n    stopPrice := close * (1 - stopLoss / 100)\n    profitPrice := close * (1 + takeProfit / 100)\n    strategy.entry(\"Long\", strategy.long)\n    \n    // Ð’Ð¸Ð·ÑƒÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ\n    label.new(bar_index, low, str.tostring(longSignalCount) + \" signals\", \n              color=color.green, textcolor=color.white, style=label.style_label_up)\n\n// SHORT ENTRY\nif shortEntry and strategy.position_size == 0\n    entryPrice := close\n    stopPrice := close * (1 + stopLoss / 100)\n    profitPrice := close * (1 - takeProfit / 100)\n    strategy.entry(\"Short\", strategy.short)\n    \n    // Ð’Ð¸Ð·ÑƒÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ\n    label.new(bar_index, high, str.tostring(shortSignalCount) + \" signals\", \n              color=color.red, textcolor=color.white, style=label.style_label_down)\n\n// TRAILING STOP\nif useTrailing and strategy.position_size > 0 and not na(entryPrice)\n    profitPct = (close - entryPrice) / entryPrice * 100\n    if profitPct >= trailActivate\n        newStop = close * (1 - trailPct / 100)\n        if newStop > stopPrice\n            stopPrice := newStop\n\nif useTrailing and strategy.position_size < 0 and not na(entryPrice)\n    profitPct = (entryPrice - close) / entryPrice * 100\n    if profitPct >= trailActivate\n        newStop = close * (1 + trailPct / 100)\n        if newStop < stopPrice\n            stopPrice := newStop\n\n// EXITS\nif strategy.position_size > 0\n    strategy.exit(\"Exit Long\", \"Long\", stop=stopPrice, limit=profitPrice)\n\nif strategy.position_size < 0\n    strategy.exit(\"Exit Short\", \"Short\", stop=stopPrice, limit=profitPrice)\n\n// Ð”Ð¾Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¹ Ð²Ñ‹Ñ…Ð¾Ð´ Ð¿Ñ€Ð¸ Ñ€Ð°Ð·Ð²Ð¾Ñ€Ð¾Ñ‚Ðµ Ñ‚Ñ€ÐµÐ½Ð´Ð°\nif strategy.position_size > 0 and emaCrossDown\n    strategy.close(\"Long\", comment=\"Trend Reversal\")\n\nif strategy.position_size < 0 and emaCrossUp\n    strategy.close(\"Short\", comment=\"Trend Reversal\")\n\n// ÐÐžÐ’ÐžÐ•: Ð—Ð°ÐºÑ€Ñ‹Ñ‚Ð¸Ðµ Ð¿Ð¾ Ð²Ñ€ÐµÐ¼ÐµÐ½Ð¸ (Ð´Ð»Ñ Ñ„ÑŒÑŽÑ‡ÐµÑ€ÑÐ¾Ð² - Ð¸Ð·Ð±ÐµÐ³Ð°ÐµÐ¼ funding)\nvar int entryBar = 0\nif strategy.position_size != 0 and strategy.position_size[1] == 0\n    entryBar := bar_index\n\nbarsInPosition = bar_index - entryBar\nif barsInPosition >= maxHoldBars and strategy.position_size != 0\n    strategy.close_all(comment=\"Max Hold Time\")\n\n// ============================================================================\n// Ð’Ð˜Ð—Ð£ÐÐ›Ð˜Ð—ÐÐ¦Ð˜Ð¯ Ð£Ð ÐžÐ’ÐÐ•Ð™\n// ============================================================================\n\nplot(strategy.position_size > 0 ? stopPrice : na, \"Long SL\", color.red, 3, plot.style_linebr)\nplot(strategy.position_size > 0 ? profitPrice : na, \"Long TP\", color.green, 3, plot.style_linebr)\nplot(strategy.position_size < 0 ? stopPrice : na, \"Short SL\", color.red, 3, plot.style_linebr)\nplot(strategy.position_size < 0 ? profitPrice : na, \"Short TP\", color.green, 3, plot.style_linebr)\n\n// Ð—Ð¾Ð½Ð° Ð¿Ð¾Ð·Ð¸Ñ†Ð¸Ð¸\nposColor = strategy.position_size > 0 ? color.new(color.green, 97) : \n           strategy.position_size < 0 ? color.new(color.red, 97) : na\nbgcolor(posColor)\n\n// ============================================================================\n// Ð˜ÐÐ¤ÐžÐ ÐœÐÐ¦Ð˜ÐžÐÐÐÐ¯ ÐŸÐÐÐ•Ð›Ð¬ (Ð¾Ð¿Ñ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ð¾)\n// ============================================================================\n\n// Ð•ÑÐ»Ð¸ calc_on_every_tick=false, Ð·Ð°ÐºÐ¾Ð¼Ð¼ÐµÐ½Ñ‚Ð¸Ñ€ÑƒÐ¹Ñ‚Ðµ ÑÑ‚Ð¾Ñ‚ Ð±Ð»Ð¾Ðº\nvar table infoTable = table.new(position.top_right, 2, 4, bgcolor=color.new(color.black, 80))\n\nif barstate.islast\n    table.cell(infoTable, 0, 0, \"Trend:\", text_color=color.white)\n    table.cell(infoTable, 1, 0, strongBullTrend ? \"BULL ðŸš€\" : strongBearTrend ? \"BEAR ðŸ“‰\" : \"NEUTRAL\", \n               text_color=strongBullTrend ? color.lime : strongBearTrend ? color.red : color.gray)\n    \n    table.cell(infoTable, 0, 1, \"RSI:\", text_color=color.white)\n    table.cell(infoTable, 1, 1, str.tostring(math.round(rsi)), \n               text_color=rsi > 70 ? color.red : rsi < 30 ? color.lime : color.white)\n    \n    table.cell(infoTable, 0, 2, \"ADX:\", text_color=color.white)\n    table.cell(infoTable, 1, 2, str.tostring(math.round(adx)), \n               text_color=adx > adxThreshold ? color.lime : color.gray)\n    \n    table.cell(infoTable, 0, 3, \"Volume:\", text_color=color.white)\n    table.cell(infoTable, 1, 3, volumeSpike ? \"HIGH ðŸ“ˆ\" : \"Normal\", \n               text_color=volumeSpike ? color.lime : color.gray)\n"
  },
  {
    "url": "UlWwpKMs",
    "name": "Absorption PRO",
    "description": "OF - Absorption PRO (Clean & Smart)Ultra-clean, high-precision absorption reversal strategy.Detects institutional buying/selling pressure using volume-weighted delta proxy and VWAP deviation zones.Smart RSI + early-session range filter automatically separates valid range-bound reversals from trend exhaustion.Green/Red circles â†’ High-probability entries (fully tradable)  \nSmall crosses + colored zones â†’ Rejected signals (avoid)  \nBlue dotted lines â†’ Session range Â±100% deviation levels (optional)\n\nBy default: only signals and rejection zones displayed â€” zero clutter.Minimalist, professional, and deadly accurate on futures & forex (1mâ€“15m).Less noise. Better trades.",
    "image_url": "UlWwpKMs",
    "author": "Kara_Tools",
    "likes": 60,
    "type": "strategy",
    "created": "2025-11-27",
    "updated": "2025-11-27",
    "source": "//@version=6\r\nstrategy(\"Absorption PRO\", \r\n     overlay=true, max_boxes_count=500, max_labels_count=500, \r\n     default_qty_type=strategy.percent_of_equity, \r\n     default_qty_value=1,\r\n     commission_type=strategy.commission.percent, commission_value=0.0)\r\n\r\n// ================== INPUTS ==================\r\nshow_vwap       = input.bool(false, \"Afficher VWAP + Bandes\", group=\"Affichage\")\r\nshow_ema        = input.bool(false, \"Afficher EMA 100\", group=\"Affichage\")\r\nshow_dev_lines  = input.bool(true,  \"Afficher lignes +1 / -1\", group=\"Affichage\")\r\n\r\nenable_session_filter = input.bool(true, \"Filtre range session actif\", group=\"Filtres\")\r\nsession_bars          = input.int(40, \"Nb bougies range initial\", minval=5, group=\"Filtres\")\r\nextreme_bars          = input.int(100, \"DurÃ©e zones rejetÃ©es\", minval=10, group=\"Filtres\")\r\n\r\nrsi_length = input.int(16, \"RSI Length\", group=\"RSI\")\r\nrsi_low    = input.int(20, \"RSI bas\", group=\"RSI\")\r\nrsi_high   = input.int(80, \"RSI haut\", group=\"RSI\")\r\n\r\nsl_pips        = input.float(3.0,  \"Stop Loss (pips)\",     minval=0.5, step=0.1, group=\"Risk\")\r\ntp_pips        = input.float(12.0,  \"Take Profit (pips)\",   minval=1.0, step=0.1, group=\"Risk\")\r\n\r\nminVolume      = input.int(1200, \"Volume min\", group=\"Absorption\")\r\nminDeltaProxy  = input.float(200.0, \"Seuil delta proxy\", group=\"Absorption\")\r\npriceTol       = input.float(0.2, \"TolÃ©rance prix (%)\", group=\"Absorption\")\r\ncloseHighFrac  = input.float(0.8, \"Close haut\", group=\"Absorption\")\r\ncloseLowFrac   = input.float(0.2, \"Close bas\", group=\"Absorption\")\r\nintensityScale = input.float(12.0, \"Ã‰chelle intensitÃ©\", group=\"Absorption\")\r\nemaLength      = input.int(100, \"EMA filtre\", group=\"Absorption\")\r\n\r\nfib1 = input.float(1.618, \"Fibo 1\", group=\"VWAP\")\r\nfib2 = input.float(2.618, \"Fibo 2\", group=\"VWAP\")\r\nreso = input.timeframe(\"D\", \"RÃ©solution VWAP\", group=\"VWAP\")\r\n\r\n// ================== VWAP + STDEV ==================\r\nnewSession = ta.change(time(reso)) != 0\r\nvar float sumSrc = 0.0, sumVol = 0.0, variance = 0.0\r\nsumSrc   := newSession ? hlc3 * volume : sumSrc[1] + hlc3 * volume\r\nsumVol   := newSession ? volume       : sumVol[1] + volume\r\nvariance := newSession ? 0.0 : variance[1] + volume * math.pow(hlc3 - (sumSrc[1]/sumVol[1]), 2)\r\nvwap  = sumSrc / sumVol\r\nstdev = math.sqrt(variance / sumVol)\r\n\r\nFib_p1 = vwap + fib1 * stdev\r\nFib_p2 = vwap + fib2 * stdev\r\nFib_m1 = vwap - fib1 * stdev\r\nFib_m2 = vwap - fib2 * stdev\r\n\r\np_vwap = plot(show_vwap ? vwap : na, \"VWAP\", color.orange, 2)\r\np_p1   = plot(show_vwap ? Fib_p1 : na)\r\np_p2   = plot(show_vwap ? Fib_p2 : na)\r\np_m1   = plot(show_vwap ? Fib_m1 : na)\r\np_m2   = plot(show_vwap ? Fib_m2 : na)\r\nfill(p_p1, p_p2, show_vwap ? color.new(color.red,   90) : na)\r\nfill(p_m1, p_m2, show_vwap ? color.new(color.green, 90) : na)\r\n\r\nemaF = ta.ema(close, emaLength)\r\nplot(show_ema ? emaF : na, \"EMA 100\", color.gray)\r\n\r\n// ================== ABSORPTION ==================\r\nrng      = high - low\r\nsafeRng  = rng == 0 ? syminfo.mintick : rng\r\ndelta    = volume * (close - open) / safeRng\r\nclosePos = (close - low) / safeRng\r\nrsi      = ta.rsi(close, rsi_length)\r\n\r\nintensity = math.abs(delta) / (minDeltaProxy * intensityScale)\r\nlevel     = math.min(10, math.max(1, math.floor(intensity * 10)))\r\n\r\nabsBuy  = volume >= minVolume and delta > minDeltaProxy and close > open and math.abs(close - open)/close*100 < priceTol and closePos >= closeHighFrac and close > emaF\r\nabsSell = volume >= minVolume and delta < -minDeltaProxy and close < open and math.abs(close - open)/close*100 < priceTol and closePos <= closeLowFrac and close < emaF\r\n\r\ninRedZone   = high >= Fib_p1 and low <= Fib_p2\r\ninGreenZone = high >= Fib_m2 and low <= Fib_m1\r\n\r\n// ================== RANGE SESSION + DÃ‰VIATIONS Â±1 ==================\r\nvar float session_high = na\r\nvar float session_low  = na\r\nvar int   session_bar  = na\r\n\r\nif newSession\r\n    session_high := high\r\n    session_low  := low\r\n    session_bar  := bar_index\r\nelse if bar_index - session_bar < session_bars\r\n    session_high := math.max(session_high, high)\r\n    session_low  := math.min(session_low,  low)\r\n\r\nsession_range = session_high - session_low\r\ndev_plus1     = session_high + session_range\r\ndev_minus1    = session_low  - session_range\r\n\r\nplot(show_dev_lines and not na(session_high) ? dev_plus1 : na,  \"Session +1\", color=color.new(color.blue, 60), style=plot.style_circles, linewidth=1)\r\nplot(show_dev_lines and not na(session_high) ? dev_minus1 : na, \"Session -1\", color=color.new(color.blue, 60), style=plot.style_circles, linewidth=1)\r\n\r\nin_deviation_zone = enable_session_filter and not na(session_high) and close >= dev_minus1 and close <= dev_plus1\r\n\r\n// ================== CONDITIONS ==================\r\nlongClassic  = absSell and inGreenZone and rsi >= rsi_low and rsi <= rsi_high\r\nshortClassic = absBuy  and inRedZone   and rsi >= rsi_low and rsi <= rsi_high\r\n\r\nlongExtreme_raw  = absSell and inGreenZone and rsi < rsi_low\r\nshortExtreme_raw = absBuy  and inRedZone   and rsi > rsi_high\r\n\r\nlongValidExtreme  = longExtreme_raw  and in_deviation_zone\r\nshortValidExtreme = shortExtreme_raw and in_deviation_zone\r\n\r\nlongRejected  = longExtreme_raw  and not in_deviation_zone\r\nshortRejected = shortExtreme_raw and not in_deviation_zone\r\n\r\n// ================== SIGNAUX & ZONES ==================\r\ntransp(l) => math.round(85 - (l - 1) * 8.5)\r\nsz(l)     => l <= 7 ? size.tiny : l <= 9 ? size.small : size.normal\r\n\r\nif longClassic or longValidExtreme\r\n    label.new(bar_index, low,  \"\", style=label.style_circle, color=color.new(color.green, transp(level)), size=sz(level))\r\n\r\nif shortClassic or shortValidExtreme\r\n    label.new(bar_index, high, \"\", style=label.style_circle, color=color.new(color.red,   transp(level)), size=sz(level))\r\n\r\nif longRejected\r\n    label.new(bar_index, low,  \"\", style=label.style_xcross, color=color.new(color.green, 30), size=size.small)\r\n\r\nif shortRejected\r\n    label.new(bar_index, high, \"\", style=label.style_xcross, color=color.new(color.red,   30), size=size.small)\r\n\r\n// Zones rejetÃ©es\r\nvar box[] longBoxes  = array.new_box()\r\nvar int[] longBirth  = array.new_int()\r\nvar box[] shortBoxes = array.new_box()\r\nvar int[] shortBirth = array.new_int()\r\n\r\nif longRejected\r\n    b = box.new(bar_index, high, bar_index + extreme_bars, low, bgcolor=color.new(color.green, 85), border_color=na, extend=extend.right)\r\n    array.push(longBoxes, b)\r\n    array.push(longBirth, bar_index)\r\n\r\nif shortRejected\r\n    b = box.new(bar_index, high, bar_index + extreme_bars, low, bgcolor=color.new(color.red, 85), border_color=na, extend=extend.right)\r\n    array.push(shortBoxes, b)\r\n    array.push(shortBirth, bar_index)\r\n\r\n// Nettoyage zones\r\ni = array.size(longBoxes) - 1\r\nwhile i >= 0\r\n    if bar_index - array.get(longBirth, i) >= extreme_bars\r\n        box.delete(array.get(longBoxes, i))\r\n        array.remove(longBoxes, i)\r\n        array.remove(longBirth, i)\r\n    i -= 1\r\n\r\ni := array.size(shortBoxes) - 1\r\nwhile i >= 0\r\n    if bar_index - array.get(shortBirth, i) >= extreme_bars\r\n        box.delete(array.get(shortBoxes, i))\r\n        array.remove(shortBoxes, i)\r\n        array.remove(shortBirth, i)\r\n    i -= 1\r\n\r\n// ================== TRADING : CORRIGÃ‰ EN TICKS ==================\r\n// 1 pip = 10 Ã— syminfo.mintick sur la plupart des contrats\r\nsl_ticks = sl_pips * 10\r\ntp_ticks = tp_pips * 10\r\n\r\nif (longClassic or longValidExtreme) and strategy.position_size <= 0\r\n    strategy.entry(\"Long\", strategy.long)\r\n    strategy.exit(\"Long TP/SL\", \"Long\", profit=tp_ticks, loss=sl_ticks)\r\n\r\nif (shortClassic or shortValidExtreme) and strategy.position_size >= 0\r\n    strategy.entry(\"Short\", strategy.short)\r\n    strategy.exit(\"Short TP/SL\", \"Short\", profit=tp_ticks, loss=sl_ticks)"
  },
  {
    "url": "uVUh9jKf-A-Setup-Strategy",
    "name": "A+ Setup Strategy",
    "description": " Trendline Features Added:\n1. Automatic Trendline Detection\n\nSupport Trendline (green) - Connects swing lows\nResistance Trendline (red) - Connects swing highs\nUses pivot points to identify key swing levels\nValidates trendlines by counting touches (minimum 3 touches required)\n\n2. Trendline Settings\n\nShow Trendlines - Toggle on/off\nLookback Period - How far back to look for pivots (default: 50 bars)\nMin Touches - How many touches needed for valid trendline (default: 3)\n\n3. Trendline Break Detection\n\nBullish Break - Price breaks above support trendline (marked with small green circle)\nBearish Break - Price breaks below resistance trendline (marked with small red circle)\nGenerates signals when breaks occur\n\n4. Enhanced A+ Setups\nNow includes ULTRA setups - the absolute best trades:\nULTRA BUY Setup (Aqua label):\n\nBullish FVG + BOS + Volume Spike + Uptrend\nPLUS: Support trendline break OR near key support\nPLUS: Trendline breakout confirmation\n\nULTRA SELL Setup (Fuchsia label):\n\nBearish FVG + BOS + Volume Spike + Downtrend\nPLUS: Resistance trendline break OR near key resistance\nPLUS: Trendline breakdown confirmation\n\n5. Confluence Integration\nThe strategy now considers price near trendlines as additional confluence, similar to how it uses daily S/R levels.\n6. Additional Alerts\n\nSupport Trendline Break\nResistance Trendline Break\nULTRA BUY/SELL Setup alerts\n\nThis gives you multiple tiers of signal quality:\n\nStandard A+ Setup - All conditions met\nULTRA A+ Setup - All conditions + trendline break (highest probability)\n\nThe trendlines will help you identify major trend reversals and breakouts for even better entry timing!",
    "image_url": "uVUh9jKf",
    "author": "traekiw",
    "likes": 30,
    "type": "strategy",
    "created": "2025-11-27",
    "updated": "2025-11-27",
    "source": "//@version=6\nstrategy(\"A+ Setup Strategy\", overlay=true, max_bars_back=500)\n\n// ============================\n// INPUTS\n// ============================\nshowSR = input.bool(true, \"Show Daily S/R\", group=\"Display\")\nshowPrevLevels = input.bool(true, \"Show Previous Highs/Lows\", group=\"Display\")\nshowFVG = input.bool(true, \"Show Fair Value Gaps\", group=\"Display\")\nshowBOS = input.bool(true, \"Show Break of Structure\", group=\"Display\")\n\n// Volume Settings\nvolMultiplier = input.float(2.0, \"Volume Spike Multiplier\", minval=1.0, group=\"Volume\")\nvolMaLength = input.int(20, \"Volume MA Length\", minval=1, group=\"Volume\")\n\n// BOS Settings\nswingLength = input.int(10, \"Swing Length for BOS\", minval=5, group=\"Structure\")\n\n// Filter Settings\nminFVGSize = input.float(0.2, \"Min FVG Size %\", minval=0.05, maxval=2.0, group=\"Filters\")\ntrendFilter = input.bool(true, \"Use Trend Filter\", group=\"Filters\")\nemaLength = input.int(50, \"Trend EMA Length\", minval=20, group=\"Filters\")\nrequireBOS = input.bool(true, \"Require Break of Structure\", group=\"Filters\")\nrequireKeyLevel = input.bool(true, \"Require Near Key Level\", group=\"Filters\")\n\n// Session Settings\nasianSessionOnly = input.bool(false, \"Trade Asian Session Only\", group=\"Session Filter\")\nasianStartHour = input.int(23, \"Asian Session Start Hour (GMT)\", minval=0, maxval=23, group=\"Session Filter\")\nasianEndHour = input.int(8, \"Asian Session End Hour (GMT)\", minval=0, maxval=23, group=\"Session Filter\")\n\n// Candlestick Pattern Settings\nuseEngulfing = input.bool(false, \"Require Engulfing Pattern\", group=\"Candlestick Patterns\")\nshowEngulfing = input.bool(true, \"Show Engulfing Signals\", group=\"Candlestick Patterns\")\n\n// Risk Management\nriskPercent = input.float(1.0, \"Risk Per Trade %\", minval=0.1, maxval=5.0, group=\"Risk Management\")\nstopLossPercent = input.float(2.0, \"Stop Loss %\", minval=0.5, maxval=10.0, group=\"Risk Management\")\ntakeProfitPercent = input.float(4.0, \"Take Profit %\", minval=1.0, maxval=20.0, group=\"Risk Management\")\n\n// ============================\n// DAILY SUPPORT & RESISTANCE\n// ============================\nvar float dailyHigh = na\nvar float dailyLow = na\n\nbool isNewDay = ta.change(time('D')) != 0\nif isNewDay\n    dailyHigh := high\n    dailyLow := low\nelse\n    dailyHigh := math.max(dailyHigh, high)\n    dailyLow := math.min(dailyLow, low)\n\n// Plot Daily Levels\nplot(showSR ? dailyHigh : na, \"Daily High\", color=color.red, linewidth=2)\nplot(showSR ? dailyLow : na, \"Daily Low\", color=color.green, linewidth=2)\n\n// ============================\n// PREVIOUS TIMEFRAME LEVELS\n// ============================\nprevDayHigh = request.security(syminfo.tickerid, \"D\", high[1], lookahead=barmerge.lookahead_on)\nprevDayLow = request.security(syminfo.tickerid, \"D\", low[1], lookahead=barmerge.lookahead_on)\nprev1hHigh = request.security(syminfo.tickerid, \"60\", high[1], lookahead=barmerge.lookahead_on)\nprev1hLow = request.security(syminfo.tickerid, \"60\", low[1], lookahead=barmerge.lookahead_on)\nprev4hHigh = request.security(syminfo.tickerid, \"240\", high[1], lookahead=barmerge.lookahead_on)\nprev4hLow = request.security(syminfo.tickerid, \"240\", low[1], lookahead=barmerge.lookahead_on)\n\n// Plot Previous Levels\nplot(showPrevLevels ? prevDayHigh : na, \"Prev Day High\", color=color.new(color.red, 50), linewidth=1, style=plot.style_circles)\nplot(showPrevLevels ? prevDayLow : na, \"Prev Day Low\", color=color.new(color.green, 50), linewidth=1, style=plot.style_circles)\nplot(showPrevLevels ? prev1hHigh : na, \"Prev 1H High\", color=color.new(color.orange, 60), linewidth=1, style=plot.style_cross)\nplot(showPrevLevels ? prev1hLow : na, \"Prev 1H Low\", color=color.new(color.blue, 60), linewidth=1, style=plot.style_cross)\n\n// ============================\n// SESSION FILTER\n// ============================\ncurrentHour = hour(time, \"GMT\")\nisAsianSession = asianSessionOnly ? \n                 (asianStartHour > asianEndHour ? \n                  (currentHour >= asianStartHour or currentHour < asianEndHour) : \n                  (currentHour >= asianStartHour and currentHour < asianEndHour)) : true\n\nbgcolor(isAsianSession and asianSessionOnly ? color.new(color.blue, 95) : na, title=\"Asian Session\")\n\n// ============================\n// TREND FILTER\n// ============================\nema = ta.ema(close, emaLength)\nbullishTrend = close > ema\nbearishTrend = close < ema\n\nplot(trendFilter ? ema : na, \"Trend EMA\", color=color.yellow, linewidth=2)\n\n// ============================\n// FAIR VALUE GAPS (FVG)\n// ============================\nfvgGapBull = low - high[2]\nfvgGapBear = low[2] - high\nfvgSizeBull = (fvgGapBull / close) * 100\nfvgSizeBear = (fvgGapBear / close) * 100\n\nbullishFVG = low > high[2] and close[1] > open[1] and fvgSizeBull >= minFVGSize\nbearishFVG = high < low[2] and close[1] < open[1] and fvgSizeBear >= minFVGSize\n\n// Visual FVG boxes\nif bullishFVG and showFVG\n    box.new(bar_index - 2, high[2], bar_index + 10, low, border_color=color.new(color.green, 70), bgcolor=color.new(color.green, 90))\n    \nif bearishFVG and showFVG\n    box.new(bar_index - 2, low[2], bar_index + 10, high, border_color=color.new(color.red, 70), bgcolor=color.new(color.red, 90))\n\n// ============================\n// BREAK OF STRUCTURE (BOS)\n// ============================\nswingHigh = ta.pivothigh(high, swingLength, swingLength)\nswingLow = ta.pivotlow(low, swingLength, swingLength)\n\nvar float lastSwingHigh = na\nvar float lastSwingLow = na\n\nif not na(swingHigh)\n    lastSwingHigh := swingHigh\n    \nif not na(swingLow)\n    lastSwingLow := swingLow\n\nbullishBOS = not na(lastSwingHigh) and close > lastSwingHigh and close[1] <= lastSwingHigh\nbearishBOS = not na(lastSwingLow) and close < lastSwingLow and close[1] >= lastSwingLow\n\nplotshape(showBOS and bullishBOS, \"Bull BOS\", shape.triangleup, location.belowbar, color.new(color.green, 0), size=size.small)\nplotshape(showBOS and bearishBOS, \"Bear BOS\", shape.triangledown, location.abovebar, color.new(color.red, 0), size=size.small)\n\n// ============================\n// VOLUME ANALYSIS\n// ============================\nvolMA = ta.sma(volume, volMaLength)\nvolumeSpike = volume > (volMA * volMultiplier)\n\nbgcolor(volumeSpike ? color.new(color.yellow, 90) : na, title=\"Volume Spike\")\n\n// ============================\n// CANDLESTICK PATTERNS\n// ============================\nbullishEngulfing = close > open and close[1] < open[1] and close > open[1] and open < close[1] and (close - open) > (open[1] - close[1])\nbearishEngulfing = close < open and close[1] > open[1] and close < open[1] and open > close[1] and (open - close) > (close[1] - open[1])\n\nplotshape(showEngulfing and bullishEngulfing, \"Bull Engulf\", shape.triangleup, location.belowbar, color.new(color.green, 70), size=size.tiny, text=\"BE\")\nplotshape(showEngulfing and bearishEngulfing, \"Bear Engulf\", shape.triangledown, location.abovebar, color.new(color.red, 70), size=size.tiny, text=\"BE\")\n\n// ============================\n// A+ SETUP LOGIC\n// ============================\nnearSupport = math.abs(close - dailyLow) / close < 0.002 or math.abs(close - prevDayLow) / close < 0.002\nnearResistance = math.abs(close - dailyHigh) / close < 0.002 or math.abs(close - prevDayHigh) / close < 0.002\n\n// Basic A+ conditions\nbullishSetup = bullishFVG and volumeSpike and (not trendFilter or bullishTrend) and (not useEngulfing or bullishEngulfing)\nbearishSetup = bearishFVG and volumeSpike and (not trendFilter or bearishTrend) and (not useEngulfing or bearishEngulfing)\n\n// Enhanced with BOS\nbullishAPlusStrong = bullishSetup and bullishBOS\nbearishAPlusStrong = bearishSetup and bearishBOS\n\n// Elite with key levels\nbullishAPlusElite = bullishAPlusStrong and nearSupport\nbearishAPlusElite = bearishAPlusStrong and nearResistance\n\n// ============================\n// SIGNAL GENERATION\n// ============================\nbuySignal = bullishSetup or bullishAPlusStrong or bullishAPlusElite\nsellSignal = bearishSetup or bearishAPlusStrong or bearishAPlusElite\n\nplotshape(buySignal and bullishAPlusElite, \"BUY ELITE\", shape.labelup, location.belowbar, color.new(color.lime, 0), text=\"BUY\\nELITE\", textcolor=color.white, size=size.normal)\nplotshape(buySignal and bullishAPlusStrong and not bullishAPlusElite, \"BUY STRONG\", shape.labelup, location.belowbar, color.new(color.green, 0), text=\"BUY\\nA+\", textcolor=color.white, size=size.small)\nplotshape(buySignal and not bullishAPlusStrong, \"BUY\", shape.labelup, location.belowbar, color.new(color.green, 40), text=\"BUY\", textcolor=color.white, size=size.tiny)\n\nplotshape(sellSignal and bearishAPlusElite, \"SELL ELITE\", shape.labeldown, location.abovebar, color.new(color.red, 0), text=\"SELL\\nELITE\", textcolor=color.white, size=size.normal)\nplotshape(sellSignal and bearishAPlusStrong and not bearishAPlusElite, \"SELL STRONG\", shape.labeldown, location.abovebar, color.new(color.orange, 0), text=\"SELL\\nA+\", textcolor=color.white, size=size.small)\nplotshape(sellSignal and not bearishAPlusStrong, \"SELL\", shape.labeldown, location.abovebar, color.new(color.orange, 40), text=\"SELL\", textcolor=color.white, size=size.tiny)\n\n// ============================\n// STRATEGY EXECUTION\n// ============================\nif buySignal and isAsianSession\n    strategy.entry(\"Long\", strategy.long)\n    strategy.exit(\"Exit Long\", \"Long\", stop=close * (1 - stopLossPercent/100), limit=close * (1 + takeProfitPercent/100))\n    \nif sellSignal and isAsianSession\n    strategy.entry(\"Short\", strategy.short)\n    strategy.exit(\"Exit Short\", \"Short\", stop=close * (1 + stopLossPercent/100), limit=close * (1 - takeProfitPercent/100))\n\n// BOS exit override\nif strategy.position_size > 0 and bearishBOS\n    strategy.close(\"Long\", comment=\"Bear BOS Exit\")\n    \nif strategy.position_size < 0 and bullishBOS\n    strategy.close(\"Short\", comment=\"Bull BOS Exit\")\n\n// ============================\n// ALERTS\n// ============================\nalertcondition(bullishFVG, \"Bullish FVG\", \"Bullish Fair Value Gap\")\nalertcondition(bearishFVG, \"Bearish FVG\", \"Bearish Fair Value Gap\")\nalertcondition(bullishBOS, \"Bullish BOS\", \"Bullish Break of Structure\")\nalertcondition(bearishBOS, \"Bearish BOS\", \"Bearish Break of Structure\")\nalertcondition(volumeSpike, \"Volume Spike\", \"Volume Spike Detected\")\nalertcondition(buySignal, \"BUY Signal\", \"A+ BUY Setup\")\nalertcondition(sellSignal, \"SELL Signal\", \"A+ SELL Setup\")"
  },
  {
    "url": "8KlQpQmR-US100-M5-ESTRATEGIA-GANADORA-Usuario",
    "name": "US100 M5 - ESTRATEGIA GANADORA (Usuario)",
    "description": "jucale\n\nvery good strategy\n\ngood money\n\ncorrea come back",
    "image_url": "8KlQpQmR",
    "author": "martinrecalde777",
    "likes": 8,
    "type": "strategy",
    "created": "2025-11-27",
    "updated": "2025-11-27",
    "source": "//@version=6\r\nstrategy(\"US100 M5 - ESTRATEGIA GANADORA (Usuario)\", overlay=true, initial_capital=10000, default_qty_type=strategy.fixed, default_qty_value=1)\r\n\r\n// ==========================================\r\n// 1. CONFIGURACIÃ“N EXACTA\r\n// ==========================================\r\ngroup_rules = \"Reglas de Entrada\"\r\n// Vela con cuerpo entre 10 y 110 (Tu regla)\r\nminBody     = input.float(10.0, \"Min Cuerpo (Puntos)\", group=group_rules) \r\nmaxBody     = input.float(110.0, \"Max Cuerpo (Puntos)\", group=group_rules) \r\n// Cooldown para no sobre-operar (Recomendado)\r\ncooldownMin = input.int(45, \"Minutos Cooldown\", group=group_rules)\r\n\r\ngroup_ind   = \"Indicadores\"\r\n// TEMA 89 para Entrada\r\nlenTrend    = input.int(89, \"TEMA Entrada\", group=group_ind)\r\n// TEMA 55 para Salida\r\nlenExit     = input.int(55, \"TEMA Salida\", group=group_ind)\r\n// ADX en 13\r\nadxLen      = input.int(13, \"Longitud ADX\", group=group_ind)\r\nadxThresh   = input.int(20, \"Nivel MÃ­nimo ADX\", group=group_ind)\r\n// ATR en 55 (Referencia)\r\natrLen      = input.int(55, \"Longitud ATR\", group=group_ind)\r\n\r\ngroup_time  = \"Horario (09:00 - 12:00)\"\r\n// Solo operar de 9 a 12\r\nsessSpec    = input.session(\"0900-1200\", \"Horario Operativo\", group=group_time)\r\n\r\ngroup_risk  = \"GestiÃ³n Riesgo\"\r\ntradeLots   = input.float(1.0, \"Lotes por OperaciÃ³n\", step=0.1, group=group_risk)\r\n\r\n// ==========================================\r\n// 2. CÃLCULOS\r\n// ==========================================\r\ntimeZone = \"America/New_York\"\r\n\r\n// FunciÃ³n TEMA\r\ncalc_tema(src, len) =>\r\n    e1 = ta.ema(src, len)\r\n    e2 = ta.ema(e1, len)\r\n    e3 = ta.ema(e2, len)\r\n    3 * e1 - 3 * e2 + e3\r\n\r\ntemaEntrada = calc_tema(close, lenTrend) // 89 (Naranja)\r\ntemaSalida  = calc_tema(close, lenExit)  // 55 (Azul)\r\n\r\nplot(temaEntrada, \"TEMA 89 Entrada\", color.new(color.orange, 0), 2)\r\nplot(temaSalida,  \"TEMA 55 Salida\", color.new(color.blue, 0), 1)\r\n\r\n// Otros Indicadores\r\natr = ta.atr(atrLen)\r\n[dp, dm, adx] = ta.dmi(adxLen, 14)\r\n\r\n// FÃ­sica de la Vela\r\nbodySize  = math.abs(close - open)\r\nisBullish = close > open \r\nisBearish = close < open \r\n\r\n// Validaciones\r\nisSizeOk  = bodySize >= minBody and bodySize <= maxBody\r\nisAdxOk   = adx > adxThresh\r\n\r\n// ==========================================\r\n// 3. LÃ“GICA DE ENTRADA\r\n// ==========================================\r\n// Regla: Precio favorable respecto a TEMA 89 + Vela Correcta + ADX\r\n\r\n// COMPRA (Long):\r\n// 1. Cierre por encima de TEMA 89\r\n// 2. Vela Verde\r\n// 3. TamaÃ±o 10-110\r\n// 4. ADX > 20\r\nlongSignal = close > temaEntrada and isBullish and isSizeOk and isAdxOk\r\n\r\n// VENTA (Short):\r\n// 1. Cierre por debajo de TEMA 89\r\n// 2. Vela Roja\r\n// 3. TamaÃ±o 10-110\r\n// 4. ADX > 20\r\nshortSignal = close < temaEntrada and isBearish and isSizeOk and isAdxOk\r\n\r\n// ==========================================\r\n// 4. GESTIÃ“N DE TIEMPO Y COOLDOWN\r\n// ==========================================\r\ninSession = not na(time(timeframe.period, sessSpec, timeZone))\r\n\r\nvar int lastEntryTime = 0\r\ncooldownMs = cooldownMin * 60 * 1000\r\nisCooldownOver = (lastEntryTime == 0) or ((time - lastEntryTime) >= cooldownMs)\r\n\r\n// Visuales\r\nbgcolor(inSession ? color.new(color.green, 90) : na, title=\"Horario\")\r\n\r\n// ==========================================\r\n// 5. EJECUCIÃ“N\r\n// ==========================================\r\nif inSession and isCooldownOver and strategy.position_size == 0\r\n    \r\n    // --- LONG ---\r\n    if longSignal\r\n        lastEntryTime := time\r\n        strategy.entry(\"Long\", strategy.long, qty=tradeLots)\r\n        // No ponemos TP ni SL fijo, la salida es por TEMA 55\r\n\r\n    // --- SHORT ---\r\n    if shortSignal\r\n        lastEntryTime := time\r\n        strategy.entry(\"Short\", strategy.short, qty=tradeLots)\r\n\r\n// ==========================================\r\n// 6. SALIDA (TEMA 55)\r\n// ==========================================\r\n// \"Salida cuando el precio regrese a la TEMA 55\"\r\n\r\nif strategy.position_size > 0 // Estamos comprados\r\n    // Si el precio cierra POR DEBAJO de la TEMA 55 -> CERRAR\r\n    if close < temaSalida\r\n        strategy.close(\"Long\", comment=\"Salida T55\")\r\n\r\nif strategy.position_size < 0 // Estamos vendidos\r\n    // Si el precio cierra POR ENCIMA de la TEMA 55 -> CERRAR\r\n    if close > temaSalida\r\n        strategy.close(\"Short\", comment=\"Salida T55\")"
  },
  {
    "url": "guwuC5xs-US100-M5-ESTRATEGIA-GANADORA-Usuario-martinec130103",
    "name": "US100 M5 - ESTRATEGIA GANADORA (Usuario) martinec130103",
    "description": "jucale\n\n\"Use indicators, closed time window, no more than two trades per day, 45-minute cooldown between trades, strict stop loss.\"\n",
    "image_url": "guwuC5xs",
    "author": "martinrecalde777",
    "likes": 4,
    "type": "strategy",
    "created": "2025-11-27",
    "updated": "2025-11-27",
    "source": "//@version=6\r\nstrategy(\"US100 M5 - ESTRATEGIA GANADORA (Usuario)\", overlay=true, initial_capital=10000, default_qty_type=strategy.fixed, default_qty_value=1)\r\n\r\n// ==========================================\r\n// 1. CONFIGURACIÃ“N EXACTA\r\n// ==========================================\r\ngroup_rules = \"Reglas de Entrada\"\r\n// Vela con cuerpo entre 10 y 110 (Tu regla)\r\nminBody     = input.float(10.0, \"Min Cuerpo (Puntos)\", group=group_rules) \r\nmaxBody     = input.float(110.0, \"Max Cuerpo (Puntos)\", group=group_rules) \r\n// Cooldown para no sobre-operar (Recomendado)\r\ncooldownMin = input.int(45, \"Minutos Cooldown\", group=group_rules)\r\n\r\ngroup_ind   = \"Indicadores\"\r\n// TEMA 89 para Entrada\r\nlenTrend    = input.int(89, \"TEMA Entrada\", group=group_ind)\r\n// TEMA 55 para Salida\r\nlenExit     = input.int(55, \"TEMA Salida\", group=group_ind)\r\n// ADX en 13\r\nadxLen      = input.int(13, \"Longitud ADX\", group=group_ind)\r\nadxThresh   = input.int(20, \"Nivel MÃ­nimo ADX\", group=group_ind)\r\n// ATR en 55 (Referencia)\r\natrLen      = input.int(55, \"Longitud ATR\", group=group_ind)\r\n\r\ngroup_time  = \"Horario (09:00 - 12:00)\"\r\n// Solo operar de 9 a 12\r\nsessSpec    = input.session(\"0900-1200\", \"Horario Operativo\", group=group_time)\r\n\r\ngroup_risk  = \"GestiÃ³n Riesgo\"\r\ntradeLots   = input.float(1.0, \"Lotes por OperaciÃ³n\", step=0.1, group=group_risk)\r\n\r\n// ==========================================\r\n// 2. CÃLCULOS\r\n// ==========================================\r\ntimeZone = \"America/New_York\"\r\n\r\n// FunciÃ³n TEMA\r\ncalc_tema(src, len) =>\r\n    e1 = ta.ema(src, len)\r\n    e2 = ta.ema(e1, len)\r\n    e3 = ta.ema(e2, len)\r\n    3 * e1 - 3 * e2 + e3\r\n\r\ntemaEntrada = calc_tema(close, lenTrend) // 89 (Naranja)\r\ntemaSalida  = calc_tema(close, lenExit)  // 55 (Azul)\r\n\r\nplot(temaEntrada, \"TEMA 89 Entrada\", color.new(color.orange, 0), 2)\r\nplot(temaSalida,  \"TEMA 55 Salida\", color.new(color.blue, 0), 1)\r\n\r\n// Otros Indicadores\r\natr = ta.atr(atrLen)\r\n[dp, dm, adx] = ta.dmi(adxLen, 14)\r\n\r\n// FÃ­sica de la Vela\r\nbodySize  = math.abs(close - open)\r\nisBullish = close > open \r\nisBearish = close < open \r\n\r\n// Validaciones\r\nisSizeOk  = bodySize >= minBody and bodySize <= maxBody\r\nisAdxOk   = adx > adxThresh\r\n\r\n// ==========================================\r\n// 3. LÃ“GICA DE ENTRADA\r\n// ==========================================\r\n// Regla: Precio favorable respecto a TEMA 89 + Vela Correcta + ADX\r\n\r\n// COMPRA (Long):\r\n// 1. Cierre por encima de TEMA 89\r\n// 2. Vela Verde\r\n// 3. TamaÃ±o 10-110\r\n// 4. ADX > 20\r\nlongSignal = close > temaEntrada and isBullish and isSizeOk and isAdxOk\r\n\r\n// VENTA (Short):\r\n// 1. Cierre por debajo de TEMA 89\r\n// 2. Vela Roja\r\n// 3. TamaÃ±o 10-110\r\n// 4. ADX > 20\r\nshortSignal = close < temaEntrada and isBearish and isSizeOk and isAdxOk\r\n\r\n// ==========================================\r\n// 4. GESTIÃ“N DE TIEMPO Y COOLDOWN\r\n// ==========================================\r\ninSession = not na(time(timeframe.period, sessSpec, timeZone))\r\n\r\nvar int lastEntryTime = 0\r\ncooldownMs = cooldownMin * 60 * 1000\r\nisCooldownOver = (lastEntryTime == 0) or ((time - lastEntryTime) >= cooldownMs)\r\n\r\n// Visuales\r\nbgcolor(inSession ? color.new(color.green, 90) : na, title=\"Horario\")\r\n\r\n// ==========================================\r\n// 5. EJECUCIÃ“N\r\n// ==========================================\r\nif inSession and isCooldownOver and strategy.position_size == 0\r\n    \r\n    // --- LONG ---\r\n    if longSignal\r\n        lastEntryTime := time\r\n        strategy.entry(\"Long\", strategy.long, qty=tradeLots)\r\n        // No ponemos TP ni SL fijo, la salida es por TEMA 55\r\n\r\n    // --- SHORT ---\r\n    if shortSignal\r\n        lastEntryTime := time\r\n        strategy.entry(\"Short\", strategy.short, qty=tradeLots)\r\n\r\n// ==========================================\r\n// 6. SALIDA (TEMA 55)\r\n// ==========================================\r\n// \"Salida cuando el precio regrese a la TEMA 55\"\r\n\r\nif strategy.position_size > 0 // Estamos comprados\r\n    // Si el precio cierra POR DEBAJO de la TEMA 55 -> CERRAR\r\n    if close < temaSalida\r\n        strategy.close(\"Long\", comment=\"Salida T55\")\r\n\r\nif strategy.position_size < 0 // Estamos vendidos\r\n    // Si el precio cierra POR ENCIMA de la TEMA 55 -> CERRAR\r\n    if close > temaSalida\r\n        strategy.close(\"Short\", comment=\"Salida T55\")"
  },
  {
    "url": "ScHFqqQq",
    "name": "Long-Term Strategy: 1-Year Breakout + 6-Month Exit",
    "description": "DescripciÃ³n (Description): (Copia y pega todo lo que estÃ¡ dentro del recuadro de abajo)\n\nDescription\n\nThis is a long-term trend-following strategy designed to capture major market moves while filtering out short-term noise. It is based on the classic principle of \"buying strength\" (Breakouts) and allowing profits to run, while cutting losses when the medium-term trend reverses.\n\nHow it Works (Logic)\n\n1. Entry Condition (Long Only): The strategy looks for a significant display of strength. It enters a Long position only when two conditions are met simultaneously:\n\nPrice Breakout: The closing price exceeds the highest high of the last 252 trading days (approximately 1 year). This ensures we are entering during a strong momentum phase.\n\nTrend Filter: The SuperTrend indicator (Settings: ATR 10, Factor 3.0) must be bullish. This acts as a confirmation filter to avoid false breakouts in choppy markets.\n\n2. Exit Condition: The strategy uses a trailing stop based on price action, not a fixed percentage.\n\nIt closes the position when the price closes below the lowest low of the last 126 trading days (approximately 6 months).\n\nThis wide exit allows the trade to \"breathe\" during normal market corrections without exiting the position prematurely.\n\nSettings & Risk Management\n\nCapital Usage: The script is configured to use 10% of equity per trade to reflect realistic risk management (compounding).\n\nCommissions: Included at 0.1% to simulate real trading costs.\n\nSlippage: Included (3 ticks) to account for market execution variability.\n\nBest Use: This strategy is intended for higher timeframes (Daily or Weekly) on trending assets like Indices, Crypto, or Commodities.",
    "image_url": "ScHFqqQq",
    "author": "MrOskama",
    "likes": 9,
    "type": "strategy",
    "created": "2025-11-27",
    "updated": "2025-11-27",
    "source": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// Â© TuUsuario\n\n//@version=5\nstrategy(\"Long-Term Strategy: 1-Year Breakout + 6-Month Exit\", \n     overlay=true, \n     initial_capital=10000, \n     default_qty_type=strategy.percent_of_equity, \n     default_qty_value=10, // RIESGO: 10% del capital (Norma: Realista)\n     commission_type=strategy.commission.percent,\n     commission_value=0.1, // COMISIÃ“N: 0.1% (Norma: Realista)\n     slippage=3)           // SLIPPAGE: 3 ticks (Norma: Realista)\n\n// --- 1. SETTINGS (Configuration) ---\n// SuperTrend Settings (Entry Filter)\natrPeriod = input.int(10, \"ATR Period (SuperTrend)\", group=\"Entry Settings\")\nfactor = input.float(3.0, \"Factor (SuperTrend)\", group=\"Entry Settings\")\n\n// Entry Filter (12 Months / 1 Year)\n// 252 trading days approx 1 year\ndiasEntrada = input.int(252, \"Entry High Lookback (Days)\", group=\"Entry Settings\")\n\n// Exit Settings (6 Months)\n// 126 trading days approx 6 months\ndiasSalida = input.int(126, \"Exit Low Lookback (Days)\", group=\"Exit Settings\")\n\n// --- 2. CALCULATIONS ---\n[supertrend, direction] = ta.supertrend(factor, atrPeriod)\n\n// 1-Year High (For Entry)\nmaximoAnual = ta.highest(high, diasEntrada)[1] \n\n// 6-Month Low (For Exit)\nminimoSemestral = ta.lowest(low, diasSalida)[1]\n\n// --- 3. TRADING LOGIC ---\n\n// ENTRY CONDITION (LONG):\n// 1. SuperTrend is Bullish (direction < 0)\n// 2. Price closes above the 1-Year High\nlongCondition = (direction < 0) and (close >= maximoAnual)\n\n// EXIT CONDITION (CLOSE):\n// Price CLOSES below the 6-Month Low.\nexitCondition = close < minimoSemestral\n\n// --- 4. EXECUTION ---\n\nif (longCondition)\n    strategy.entry(\"Long\", strategy.long, comment=\"Breakout 1Y\")\n\nif (exitCondition)\n    strategy.close(\"Long\", comment=\"Exit 6M Low\")\n\n// --- 5. VISUALIZATION ---\n// Entry Level (Blue Line)\nplot(maximoAnual, color=color.new(color.blue, 0), title=\"1-Year High (Entry)\")\n\n// Exit Level (Red Line) - Dynamic Stop Loss\nplot(minimoSemestral, color=color.new(color.red, 0), linewidth=2, title=\"6-Month Low (Exit)\")\n\n// Background color if position is open\nbgcolor(strategy.position_size > 0 ? color.new(color.green, 95) : na)"
  },
  {
    "url": "lbqr8CJh-Supertrend-DEMA-Strategy-customised-Switchable-Fixed-TP",
    "name": "Supertrend + DEMA Strategy ( customised & Switchable, Fixed TP)",
    "description": "Supertrend line â€“ a moving line that follows the price and shows whether the market is trending up or down.\n\nIf the price goes above this line, it usually means the market is going up.\n\nIf the price goes below, it usually means the market is going down.\n\nDEMA (Double Exponential Moving Average) â€“ another line that smooths out price movements to spot trends more clearly.\n\nIt calculates an average of prices but reacts faster than a normal moving average.\n\n",
    "image_url": "lbqr8CJh",
    "author": "drsawhneyG",
    "likes": 41,
    "type": "strategy",
    "created": "2025-11-27",
    "updated": "2025-11-27",
    "source": "//@version=6\r\nstrategy(\"Supertrend + DEMA Strategy (Switchable, Fixed TP)\", overlay=true, margin_long=100, margin_short=100, process_orders_on_close=false)\r\n\r\n// â”€â”€â”€ User Preference Switch â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nuseNormalLogic = input.bool(true, \"Use Normal Logic?\", tooltip=\"If OFF, entries are reversed\")\r\n\r\n// â”€â”€â”€ Optimization Inputs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\ngroupST   = \"Supertrend Settings\"\r\ngroupEMA  = \"DEMA Settings\"\r\ngroupRisk = \"Profit Target Settings\"\r\n\r\natrPeriod    = input.int(10, \"ATR Period\", minval=1, maxval=500, step=1, group=groupST)\r\natrMult      = input.float(3.0, \"ATR Multiplier\", minval=0.5, maxval=10, step=0.1, group=groupST)\r\n\r\ndemaLength   = input.int(21, \"DEMA Length\", minval=5, maxval=300, step=1, group=groupEMA)\r\n\r\nprofitTarget = input.float(1.5, \"Profit Target (%)\", minval=0.5, maxval=10, step=0.1, group=groupRisk)\r\n\r\n// â”€â”€â”€ Supertrend Calculation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n[supertrend, direction] = ta.supertrend(atrMult, atrPeriod)\r\n\r\n// â”€â”€â”€ DEMA Function â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\ndema(src, length) =>\r\n    ema1 = ta.ema(src, length)\r\n    ema2 = ta.ema(ema1, length)\r\n    2.0 * ema1 - ema2\r\n\r\n// â”€â”€â”€ DEMA High & Low â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\ndemaHigh = dema(high, demaLength)\r\ndemaLow  = dema(low, demaLength)\r\n\r\n// â”€â”€â”€ Entry Conditions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nlongCondition  = ta.crossover(close, supertrend) and close > demaHigh and close > demaLow\r\nshortCondition = ta.crossunder(close, supertrend) and close < demaHigh and close < demaLow\r\n\r\n// â”€â”€â”€ Exit Conditions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nlongExitCondition  = close < supertrend and close < demaHigh and close < demaLow\r\nshortExitCondition = close > supertrend and close > demaHigh and close > demaLow\r\n\r\n// â”€â”€â”€ Strategy Execution (Switchable) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nif useNormalLogic\r\n    if (longCondition)\r\n        strategy.entry(\"Long\", strategy.long, comment=\"Normal Long\")\r\n    if (shortCondition)\r\n        strategy.entry(\"Short\", strategy.short, comment=\"Normal Short\")\r\nelse\r\n    if (longCondition)\r\n        strategy.entry(\"Short\", strategy.short, comment=\"Reversed Short\")\r\n    if (shortCondition)\r\n        strategy.entry(\"Long\", strategy.long, comment=\"Reversed Long\")\r\n\r\n// â”€â”€â”€ Take Profit (Side-accurate, independent of mode) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Always compute TP from current position side and avg price.\r\n// This ensures correct TP even when entries are reversed.\r\nlongTPPrice  = strategy.position_avg_price * (1 + profitTarget/100)\r\nshortTPPrice = strategy.position_avg_price * (1 - profitTarget/100)\r\n\r\nif (strategy.position_size > 0)\r\n    // We are in a long, TP must be above entry\r\n    strategy.exit(id=\"TP Long\",  from_entry=\"Long\",  limit=longTPPrice)\r\n\r\nif (strategy.position_size < 0)\r\n    // We are in a short, TP must be below entry\r\n    strategy.exit(id=\"TP Short\", from_entry=\"Short\", limit=shortTPPrice)\r\n\r\n// â”€â”€â”€ Manual Exit Conditions (Switchable) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nif useNormalLogic\r\n    if (longExitCondition and strategy.position_size > 0)\r\n        strategy.close(\"Long\")\r\n    if (shortExitCondition and strategy.position_size < 0)\r\n        strategy.close(\"Short\")\r\nelse\r\n    if (longExitCondition and strategy.position_size < 0)\r\n        strategy.close(\"Short\")\r\n    if (shortExitCondition and strategy.position_size > 0)\r\n        strategy.close(\"Long\")\r\n\r\n// â”€â”€â”€ Plotting (Realtime) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nplot(supertrend, \"Supertrend\", color=color.orange, linewidth=2)\r\nplot(demaHigh, \"DEMA High\", color=color.green)\r\nplot(demaLow, \"DEMA Low\", color=color.red)\r\nplot(close, \"Ongoing Candle Price\", color=color.blue)\r\n\r\n// â”€â”€â”€ Live Labels â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nvar label liveLabel = na\r\nif barstate.islast\r\n    label.delete(liveLabel)\r\n    liveLabel := label.new(bar_index, close,\r\n      \"Mode: \" + (useNormalLogic ? \"Normal\" : \"Reversed\") +\r\n      \"\\nLive Price: \" + str.tostring(close, format.mintick) +\r\n      \"\\nSupertrend: \" + str.tostring(supertrend, format.mintick),\r\n      style=label.style_label_up, color=color.yellow, textcolor=color.black)\r\n"
  },
  {
    "url": "Nh8sR0sL-1M-XAU-Cumulative-Delta-Volume-with-OB-Breakouts",
    "name": "1M XAU Cumulative Delta Volume with OB Breakouts",
    "description": "\n\n### Overview\n\nThis is a **session-based CVD strategy** built around the **00:00â€“07:00 CEST range**. It finds the high/low of that session, turns them into **adaptive ATR-based support (yellow)** and **resistance (purple)** zones, and trades only **CVD-confirmed reversals** off those levels.\n\n---\n\n### How it Works\n\n* For each day, the script:\n\n  * Builds a 00:00â€“07:00 CEST **profile high/low**.\n  * Creates a **support zone** around the session low and a **resistance zone** around the session high.\n* Using lower timeframe data, it reconstructs **Cumulative Volume Delta (CVD)** and a **recent delta** filter.\n* It arms â€œpendingâ€ states when price **enters a zone from the correct side**, then confirms:\n\n  * **BUY (long):** price reclaims above support and recent CVD is strongly positive.\n  * **SELL (short):** price rejects below resistance and recent CVD is strongly negative.\n\nOnly these two CVD signals (`buySignal` / `sellSignal`) open trades.\n\n---\n\n### Strategy Logic\n\n* **Entries**\n\n  * `buySignal` â†’ open **long** (if flat).\n  * `sellSignal` â†’ open **short** (if flat).\n  * No pyramiding; one position at a time.\n* **Exits (only TP & SL)**\n\n  * Long: TP at `avg_price * (0.5 + TP%)`, SL at `avg_price * (1 â€“ SL%)`.\n  * Short: TP at `avg_price * (0.5 â€“ TP%)`, SL at `avg_price * (1 + SL%)`.\n  * No opposite-signal exits.\n\n---\n\n### Extras\n\n* **Reversal markers** on yellow/purple zones and **breakout/retest markers** are plotted for context and alerts but **do not trigger entries**.\n* Zone width and â€œthickeningâ€ are ATR-based so important touches and near-touches are easy to see.\n* Only suited for **1m intraday scalping** (e.g. XAU/USD), but can be tested on other markets/timeframes.\n",
    "image_url": "Nh8sR0sL",
    "author": "FredAstaire",
    "likes": 42,
    "type": "strategy",
    "created": "2025-11-26",
    "updated": "2025-11-26",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// Â© FredAstaire\r\n\r\n//@version=6\r\nstrategy(\"1M XAU Cumulative Delta Volume with OB Breakouts\", overlay=true, fill_orders_on_standard_ohlc = true)\r\n\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Imports\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nimport PineCoders/lower_tf/4 as PCltf\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Inputs\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nstring tzInput      = input.string(\"Europe/Berlin\", \"Session timezone (CEST/CET)\")\r\nstring profSess     = input.session(\"0000-0700\", \"Profile window 00:00â€“07:00\")\r\n\r\n// Zone sizing\r\nint   atrLen         = input.int(14, \"ATR length\")\r\nfloat zoneAtrMult    = input.float(0.15, \"Zone thickness (ATR mult)\", step=0.05)\r\nfloat nearAtrMult    = input.float(0.35, \"Near-miss marker distance (ATR mult)\", step=0.05)\r\n\r\n// CVD delta filter\r\nint   deltaLookback  = input.int(20, \"Recent delta lookback (bars)\")\r\nfloat deltaThresh    = input.float(1000, \"Recent delta threshold (Â±)\")\r\n\r\n// Pending / cooldown\r\nint pendMaxBars      = input.int(60, \"Pending timeout (bars)\")\r\nint cooldownBars     = input.int(10, \"Cooldown between same-side signals (bars)\")\r\n\r\n// Intrabar precision\r\nstring LTF1  = \"Covering most chart bars (least precise)\"\r\nstring LTF2  = \"Covering some chart bars (less precise)\"\r\nstring LTF3  = \"Covering less chart bars (more precise)\"\r\nstring LTF4  = \"Covering few chart bars (very precise)\"\r\nstring LTF5  = \"Covering the least chart bars (most precise)\"\r\nstring LTF6  = \"~12 intrabars per chart bar\"\r\nstring LTF7  = \"~24 intrabars per chart bar\"\r\nstring LTF8  = \"~50 intrabars per chart bar\"\r\nstring LTF9  = \"~100 intrabars per chart bar\"\r\nstring LTF10 = \"~250 intrabars per chart bar\"\r\n\r\nstring ltfModeInput  = input.string(LTF2, \"Intrabar Precision\",\r\n     options=[LTF1,LTF2,LTF3,LTF4,LTF5,LTF6,LTF7,LTF8,LTF9,LTF10])\r\n\r\nstring ltfOverrideInput = input.timeframe(\"\", \"Override intrabar TF (blank=Auto)\",\r\n     tooltip=\"Force a fixed intrabar TF to extend history. Examples: 15S, 30S, 1, 3.\")\r\n\r\n// Visual toggles\r\nbool showZones       = input.bool(true, \"Show zones\")\r\nbool showNearMiss    = input.bool(true, \"Show near-miss markers (reserved, currently unused)\")\r\n\r\n// Strategy risk management (TP/SL only)\r\nfloat tpPerc = input.float(0.50, \"Take Profit (%)\", minval=0.0, step=0.05)\r\nfloat slPerc = input.float(0.50, \"Stop Loss (%)\",  minval=0.0, step=0.05)\r\n\r\n// Big-move breakout setting (for visuals / info, not entries)\r\nfloat breakoutMovePerc = input.float(0.50, \"Breakout move threshold (%)\",\r\n     minval=0.0, step=0.05,\r\n     tooltip=\"Minimum % move beyond the 00â€“07 CEST SR zone edge to call it a breakout\")\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Helpers\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n\r\n// Rolling sum replacement for ta.sum / sum\r\nf_rollSum(series float src, int len) =>\r\n    float c = ta.cum(src)\r\n    c - nz(c[len])\r\n\r\n// Up/down intrabar volume split\r\nupDnIntrabarVolumes() =>\r\n    float upVol = 0.0\r\n    float dnVol = 0.0\r\n    switch\r\n        close > open => upVol += volume\r\n        close < open => dnVol -= volume\r\n        close > nz(close[1]) => upVol += volume\r\n        close < nz(close[1]) => dnVol -= volume\r\n        nz(upVol[1]) > 0 => upVol += volume\r\n        nz(dnVol[1]) < 0 => dnVol -= volume\r\n    [upVol, dnVol]\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// 00:00â€“07:00 CEST profile SR (daily)\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nbool inProf     = not na(time(timeframe.period, profSess, tzInput))\r\nbool profStart  = inProf and not inProf[1]\r\nbool profEnd    = not inProf and inProf[1]\r\n\r\nvar float profHigh  = na\r\nvar float profLow   = na\r\nvar bool  profReady = false\r\n\r\nif profStart\r\n    profHigh := high\r\n    profLow  := low\r\n    profReady := false\r\n\r\nif inProf\r\n    profHigh := na(profHigh) ? high : math.max(profHigh, high)\r\n    profLow  := na(profLow)  ? low  : math.min(profLow, low)\r\n\r\nif profEnd\r\n    profReady := true\r\n\r\nfloat atr     = ta.atr(atrLen)\r\nfloat th      = atr * zoneAtrMult\r\nfloat nearTh  = atr * nearAtrMult\r\n\r\nfloat supportBot = profLow  - th\r\nfloat supportTop = profLow  + th\r\nfloat resistBot  = profHigh - th\r\nfloat resistTop  = profHigh + th\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Intrabar CVD delta + recent filter\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nvar string ltfString = \"\"\r\nltfString := (ltfOverrideInput != \"\") ? ltfOverrideInput :\r\n     PCltf.ltf(ltfModeInput, LTF1,LTF2,LTF3,LTF4,LTF5,LTF6,LTF7,LTF8,LTF9,LTF10)\r\n\r\n[upVolumes, dnVolumes] = request.security_lower_tf(syminfo.tickerid, ltfString, upDnIntrabarVolumes())\r\n\r\nfloat barUp    = nz(upVolumes.sum())\r\nfloat barDn    = nz(dnVolumes.sum())   // negative\r\nfloat barDelta = barUp + barDn\r\n\r\nfloat recentDelta = f_rollSum(barDelta, deltaLookback)\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Smart pending-reclaim signals (NO REPAINT)\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nvar bool pendBuy  = false\r\nvar bool pendSell = false\r\nvar int  pendBuyBars  = 0\r\nvar int  pendSellBars = 0\r\nvar int  lastBuyBar   = na\r\nvar int  lastSellBar  = na\r\n\r\n// Additional pending states for pure price line-reversal logic\r\nvar bool pendSupBounce     = false  // Yellow: from above, hit support zone, then bounce up\r\nvar bool pendSupReject     = false  // Yellow: from below, hit zone, then reject down\r\nvar bool pendResReject     = false  // Purple: from below, hit zone, then reject down\r\nvar bool pendResBounce     = false  // Purple: from above, hit zone, then bounce up\r\nvar int  pendSupBounceBars = 0\r\nvar int  pendSupRejectBars = 0\r\nvar int  pendResRejectBars = 0\r\nvar int  pendResBounceBars = 0\r\nvar int  lastYellowBuyBar  = na\r\nvar int  lastYellowSellBar = na\r\nvar int  lastPurpleBuyBar  = na\r\nvar int  lastPurpleSellBar = na\r\n\r\nbool touchSupport = profReady and low <= supportTop and high >= supportBot\r\nbool touchResist  = profReady and high >= resistBot and low <= resistTop\r\n\r\nbool fromAboveSupport = profReady and close[1] > supportTop\r\nbool fromBelowResist  = profReady and close[1] < resistBot\r\nbool fromBelowSupport = profReady and close[1] < supportBot\r\nbool fromAboveResist  = profReady and close[1] > resistTop\r\n\r\nbool buySignal         = false   // CVD-based BUY (this will trigger longs)\r\nbool sellSignal        = false   // CVD-based SELL (this will trigger shorts)\r\nbool yellowBuySignal   = false\r\nbool yellowSellSignal  = false\r\nbool purpleBuySignal   = false\r\nbool purpleSellSignal  = false\r\n\r\n// Crosses of zone edges used for line-reversal signals\r\nbool crossUpSupTop    = profReady and ta.crossover(close, supportTop)\r\nbool crossDownSupBot  = profReady and ta.crossunder(close, supportBot)\r\nbool crossUpResTop    = profReady and ta.crossover(close, resistTop)\r\nbool crossDownResBot  = profReady and ta.crossunder(close, resistBot)\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Big % breakout detection + breakout-retest zones (visual/info)\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nvar bool breakoutUp      = false\r\nvar bool breakoutDown    = false\r\nvar int  breakoutUpBar   = na\r\nvar int  breakoutDownBar = na\r\n\r\nbool bigUpBreak   = profReady and close > resistTop  and ((close - resistTop)  / resistTop ) * 100 >= breakoutMovePerc\r\nbool bigDownBreak = profReady and close < supportBot and ((supportBot - close) / supportBot) * 100 >= breakoutMovePerc\r\n\r\nif barstate.isconfirmed\r\n    // Arm pending only if hit from correct side (CVD-based logic)\r\n    if fromAboveSupport and touchSupport\r\n        pendBuy := true\r\n        pendBuyBars := 0\r\n        // Yellow zone bounce: came from above into support\r\n        pendSupBounce := true\r\n        pendSupBounceBars := 0\r\n\r\n    if fromBelowResist and touchResist\r\n        pendSell := true\r\n        pendSellBars := 0\r\n        // Purple zone rejection: came from below into resistance\r\n        pendResReject := true\r\n        pendResRejectBars := 0\r\n\r\n    // Additional arms for opposite-side interactions (yellow/purple both ways)\r\n    if fromBelowSupport and touchSupport\r\n        // Yellow zone acting as resistance\r\n        pendSupReject := true\r\n        pendSupRejectBars := 0\r\n\r\n    if fromAboveResist and touchResist\r\n        // Purple zone acting as support after breakout\r\n        pendResBounce := true\r\n        pendResBounceBars := 0\r\n\r\n    // Age/kill pending for original CVD signals\r\n    if pendBuy\r\n        pendBuyBars += 1\r\n        if pendBuyBars > pendMaxBars or close < supportBot\r\n            pendBuy := false\r\n\r\n    if pendSell\r\n        pendSellBars += 1\r\n        if pendSellBars > pendMaxBars or close > resistTop\r\n            pendSell := false\r\n\r\n    // Age/kill pending for line-reversal logic\r\n    if pendSupBounce\r\n        pendSupBounceBars += 1\r\n        if pendSupBounceBars > pendMaxBars or close < supportBot\r\n            pendSupBounce := false\r\n\r\n    if pendSupReject\r\n        pendSupRejectBars += 1\r\n        if pendSupRejectBars > pendMaxBars or close > supportTop\r\n            pendSupReject := false\r\n\r\n    if pendResReject\r\n        pendResRejectBars += 1\r\n        if pendResRejectBars > pendMaxBars or close > resistTop\r\n            pendResReject := false\r\n\r\n    if pendResBounce\r\n        pendResBounceBars += 1\r\n        if pendResBounceBars > pendMaxBars or close < resistBot\r\n            pendResBounce := false\r\n\r\n    // Reset breakout state each new profile day\r\n    if profStart\r\n        breakoutUp      := false\r\n        breakoutDown    := false\r\n        breakoutUpBar   := na\r\n        breakoutDownBar := na\r\n\r\n    // Mark big breakouts\r\n    if bigUpBreak\r\n        breakoutUp      := true\r\n        breakoutDown    := false\r\n        breakoutUpBar   := bar_index\r\n\r\n    if bigDownBreak\r\n        breakoutDown    := true\r\n        breakoutUp      := false\r\n        breakoutDownBar := bar_index\r\n\r\n    // Trigger on reclaim/rejection + delta threshold + cooldown (original)\r\n    bool cooldownBuyOk        = na(lastBuyBar)        or (bar_index - lastBuyBar        > cooldownBars)\r\n    bool cooldownSellOk       = na(lastSellBar)       or (bar_index - lastSellBar       > cooldownBars)\r\n    bool cooldownYellowBuyOk  = na(lastYellowBuyBar)  or (bar_index - lastYellowBuyBar  > cooldownBars)\r\n    bool cooldownYellowSellOk = na(lastYellowSellBar) or (bar_index - lastYellowSellBar > cooldownBars)\r\n    bool cooldownPurpleBuyOk  = na(lastPurpleBuyBar)  or (bar_index - lastPurpleBuyBar  > cooldownBars)\r\n    bool cooldownPurpleSellOk = na(lastPurpleSellBar) or (bar_index - lastPurpleSellBar > cooldownBars)\r\n\r\n    // *** CVD-based core signals (ONLY these will open trades) ***\r\n    buySignal  := pendBuy  and close > supportTop and recentDelta >=  deltaThresh and cooldownBuyOk\r\n    sellSignal := pendSell and close < resistBot  and recentDelta <= -deltaThresh and cooldownSellOk\r\n\r\n    // Price-only reversal signals (for plotting / alerts, not for entries)\r\n    yellowBuySignal  := pendSupBounce and crossUpSupTop   and cooldownYellowBuyOk\r\n    yellowSellSignal := pendSupReject and crossDownSupBot and cooldownYellowSellOk\r\n    purpleSellSignal := pendResReject and crossDownResBot and cooldownPurpleSellOk\r\n    purpleBuySignal  := pendResBounce and crossUpResTop   and cooldownPurpleBuyOk\r\n\r\n    if buySignal\r\n        pendBuy := false\r\n        lastBuyBar := bar_index\r\n\r\n    if sellSignal\r\n        pendSell := false\r\n        lastSellBar := bar_index\r\n\r\n    if yellowBuySignal\r\n        pendSupBounce := false\r\n        lastYellowBuyBar := bar_index\r\n\r\n    if yellowSellSignal\r\n        pendSupReject := false\r\n        lastYellowSellBar := bar_index\r\n\r\n    if purpleBuySignal\r\n        pendResBounce := false\r\n        lastPurpleBuyBar := bar_index\r\n\r\n    if purpleSellSignal\r\n        pendResReject := false\r\n        lastPurpleSellBar := bar_index\r\n\r\n// Breakout-retest trigger zones (visual/info only, not entries)\r\nbool breakoutRetestLong  = breakoutUp   and not na(breakoutUpBar)   and bar_index > breakoutUpBar   and high >= resistTop  and low <= resistTop  and close > resistTop\r\nbool breakoutRetestShort = breakoutDown and not na(breakoutDownBar) and bar_index > breakoutDownBar and high >= supportBot and low <= supportBot and close < supportBot\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Persistent zone lines (avoid max_lines_count explosion)\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nvar line supTopLine = na\r\nvar line supBotLine = na\r\nvar line resTopLine = na\r\nvar line resBotLine = na\r\n\r\n// Reset lines each new profile window\r\nif profStart and showZones\r\n    if not na(supTopLine)\r\n        line.delete(supTopLine), line.delete(supBotLine), line.delete(resTopLine), line.delete(resBotLine)\r\n    supTopLine := na\r\n    supBotLine := na\r\n    resTopLine := na\r\n    resBotLine := na\r\n\r\nif profReady and showZones\r\n    // Create once after profile ends, then update/extend\r\n    if na(supTopLine)\r\n        supTopLine := line.new(bar_index, supportTop, bar_index, supportTop, extend=extend.right, color=color.new(color.yellow, 0), width=2)\r\n        supBotLine := line.new(bar_index, supportBot, bar_index, supportBot, extend=extend.right, color=color.new(color.yellow, 0), width=2)\r\n        resTopLine := line.new(bar_index, resistTop,  bar_index, resistTop,  extend=extend.right, color=color.new(color.purple, 0), width=2)\r\n        resBotLine := line.new(bar_index, resistBot,  bar_index, resistBot,  extend=extend.right, color=color.new(color.purple, 0), width=2)\r\n    else\r\n        line.set_xy1(supTopLine, bar_index, supportTop), line.set_xy2(supTopLine, bar_index+1, supportTop)\r\n        line.set_xy1(supBotLine, bar_index, supportBot), line.set_xy2(supBotLine, bar_index+1, supportBot)\r\n        line.set_xy1(resTopLine, bar_index, resistTop),  line.set_xy2(resTopLine, bar_index+1, resistTop)\r\n        line.set_xy1(resBotLine, bar_index, resistBot),  line.set_xy2(resBotLine, bar_index+1, resistBot)\r\n\r\n    // Thicken lines when price is near them so \"almost hits\" don't go unnoticed\r\n    if not na(supTopLine)\r\n        bool nearYellow = math.min(math.abs(close - supportTop), math.abs(close - supportBot)) <= nearTh\r\n        bool nearPurple = math.min(math.abs(close - resistTop),  math.abs(close - resistBot))  <= nearTh\r\n        int  yellowWidth = nearYellow ? 3 : 2\r\n        int  purpleWidth = nearPurple ? 3 : 2\r\n        line.set_width(supTopLine, yellowWidth)\r\n        line.set_width(supBotLine, yellowWidth)\r\n        line.set_width(resTopLine, purpleWidth)\r\n        line.set_width(resBotLine, purpleWidth)\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// STRATEGY ENTRIES (ONLY CVD BUY/SELL; EXITS = TP/SL ONLY)\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nbool longEntry  = buySignal\r\nbool shortEntry = sellSignal\r\n\r\n// Only open new trade when flat\r\nif longEntry and strategy.position_size == 0\r\n    strategy.entry(\"Long\", strategy.long)\r\n\r\nif shortEntry and strategy.position_size == 0\r\n    strategy.entry(\"Short\", strategy.short)\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// STRATEGY EXITS: TAKE PROFIT & STOP LOSS ONLY\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nfloat longStopPrice   = na\r\nfloat longTakeProfit  = na\r\nfloat shortStopPrice  = na\r\nfloat shortTakeProfit = na\r\n\r\nif strategy.position_size > 0\r\n    longStopPrice  := strategy.position_avg_price * (1 - slPerc / 100.0)\r\n    longTakeProfit := strategy.position_avg_price * (1 + tpPerc / 100.0)\r\n    strategy.exit(\"Long TP/SL\", \"Long\", stop=longStopPrice, limit=longTakeProfit)\r\n\r\nif strategy.position_size < 0\r\n    shortStopPrice  := strategy.position_avg_price * (1 + slPerc / 100.0)\r\n    shortTakeProfit := strategy.position_avg_price * (1 - tpPerc / 100.0)\r\n    strategy.exit(\"Short TP/SL\", \"Short\", stop=shortStopPrice, limit=shortTakeProfit)\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Visual shapes\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nplotshape(buySignal,  title=\"BUY (CVD)\",  style=shape.triangleup,   location=location.belowbar, color=color.lime, size=size.small, text=\"BUY\")\r\nplotshape(sellSignal, title=\"SELL (CVD)\", style=shape.triangledown, location=location.abovebar, color=color.red,  size=size.small, text=\"SELL\")\r\n\r\n// Price-only reversal markers on yellow (support) and purple (resistance) zones (visual only)\r\nplotshape(yellowBuySignal,  title=\"Yellow Reversal BUY\",  style=shape.triangleup,   location=location.belowbar, color=color.new(color.yellow, 0), size=size.tiny, text=\"Y-BUY\")\r\nplotshape(yellowSellSignal, title=\"Yellow Reversal SELL\", style=shape.triangledown, location=location.abovebar, color=color.new(color.yellow, 0), size=size.tiny, text=\"Y-SELL\")\r\nplotshape(purpleBuySignal,  title=\"Purple Reversal BUY\",  style=shape.triangleup,   location=location.belowbar, color=color.new(color.purple, 0), size=size.tiny, text=\"P-BUY\")\r\nplotshape(purpleSellSignal, title=\"Purple Reversal SELL\", style=shape.triangledown, location=location.abovebar, color=color.new(color.purple, 0), size=size.tiny, text=\"P-SELL\")\r\n\r\n// Big breakout and breakout-retest visuals (info only)\r\nplotshape(bigUpBreak,          title=\"Big Up Breakout\",        style=shape.circle,       location=location.abovebar, color=color.new(color.lime, 0),    size=size.tiny, text=\"BOâ†‘\")\r\nplotshape(bigDownBreak,        title=\"Big Down Breakout\",      style=shape.circle,       location=location.belowbar, color=color.new(color.red,  0),    size=size.tiny, text=\"BOâ†“\")\r\nplotshape(breakoutRetestLong,  title=\"Breakout Retest LONG\",   style=shape.triangleup,   location=location.belowbar, color=color.new(color.aqua,  0),   size=size.small, text=\"BO-L\")\r\nplotshape(breakoutRetestShort, title=\"Breakout Retest SHORT\",  style=shape.triangledown, location=location.abovebar, color=color.new(color.orange,0),   size=size.small, text=\"BO-S\")\r\n\r\n// Alerts (optional)\r\nalertcondition(buySignal,  \"Buy Signal (CVD)\",  \"BUY: 00-07 CEST support rejected + recent CVD delta â‰¥ threshold.\")\r\nalertcondition(sellSignal, \"Sell Signal (CVD)\", \"SELL: 00-07 CEST resistance rejected + recent CVD delta â‰¤ âˆ’threshold.\")\r\n"
  },
  {
    "url": "1JFQW3PI-Simple-Grid-Trading-v1-0-PUCHON",
    "name": "Simple Grid Trading v1.0 [PUCHON]",
    "description": "Simple Grid Trading v1.0  \n\n Overview \n\nThis is a  Long-Only Grid Trading Strategy  developed in Pine Script v6 for TradingView. It is designed to profit from market volatility by placing a series of Buy Limit orders at predefined price levels. As the price drops, the strategy accumulates positions. As the price rises, it sells these positions at a profit.\n\n Features \n\n \n   Grid Types : Supports both  Arithmetic  (equal price spacing) and  Geometric  (equal percentage spacing) grids.\n   Flexible Order Management : Uses strategy.order for precise control and prevents duplicate orders at the same level.\n   Performance Dashboard : A real-time table displaying key metrics like Capital, Cashflow, and Drawdown.\n   Advanced Metrics : Includes  Max Drawdown (MaxDD) ,  Avg Monthly Return , and  CAGR  calculations.\n   Customizable : Fully adjustable price range, grid lines, and lot size.\n \n\n Dashboard Metrics \n\nThe dashboard (default: Bottom Right) provides a quick snapshot of the strategy's performance:\n\n \n   Initial Capital : The starting capital defined in the strategy settings.\n   Lot Size : The fixed quantity of assets purchased per grid level.\n   Avg. Profit per Grid : The average realized profit for each closed trade.\n   Cashflow : The total realized net profit (closed trades only).\n   MaxDD :  Maximum Drawdown . The largest percentage drop in equity (realized + unrealized) from a peak.\n   Avg Monthly Return : The average percentage return generated per month.\n   CAGR :  Compound Annual Growth Rate . The mean annual growth rate of the investment over the specified time period.\n \n\n Strategy Settings (Inputs) \n\n Grid Settings \n\n \n   Upper Price : The highest price level for the grid.\n   Lower Price : The lowest price level for the grid.\n   Number of Grid Lines : The total number of levels (lines) in the grid.\n   Grid Type :\n \n  Arithmetic: Distance between lines is fixed in price terms (e.g., $10, $20, $30).\n  Geometric: Distance between lines is fixed in percentage terms (e.g., 1%, 2%, 3%).\n \n   Lot Size : The fixed amount of the asset to buy at each level.\n \n\n Dashboard Settings \n\n \n   Show Dashboard : Toggle to hide/show the performance table.\n   Position : Choose where the dashboard appears on the chart (e.g., Bottom Right, Top Left).\n \n\n How It Works \n\n \n   Initialization : On the first bar, the script calculates the price levels based on your Upper/Lower price and Grid Type.\n   Entry Logic :\n \n  The strategy places  Buy Limit  orders at every grid level below the current price.\n  It checks if a position already exists at a specific level to avoid \"stacking\" multiple orders on the same line.\n \n   Exit Logic :\n \n  For every Buy order, a corresponding  Sell Limit  (Take Profit) order is placed at the next higher grid level.\n \n   MaxDD Calculation :\n \n  The script continuously tracks the highest equity peak.\n  It calculates the drawdown on every bar (including intra-bar movements) to ensure accuracy.\n  Displayed as a percentage (e.g., 5.25%).\n \n \n\n Disclaimer \n\nThis script is for educational and backtesting purposes only. Grid trading involves significant risk, especially in strong trending markets where the price may move outside your grid range. Always use proper risk management.\n",
    "image_url": "1JFQW3PI",
    "author": "ProPuchon",
    "likes": 93,
    "type": "strategy",
    "created": "2025-11-27",
    "updated": "2025-11-27",
    "source": "//@version=6\r\nstrategy(\"Simple Grid Trading v1.0 [PUCHON]\", shorttitle = \"Simple Grid Trading\", overlay=true, pyramiding=100, initial_capital=1000, default_qty_type=strategy.fixed, default_qty_value=1, currency=currency.USD, close_entries_rule=\"ANY\")\r\n\r\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\r\n// Version History\r\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\r\n// v1.1.0 - Removed Lot Size Input, using Strategy Default\r\n// v1.0.0 - Initial Release\r\nstring version = \"1.1.0\"\r\n\r\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\r\n// Inputs\r\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\r\ngrp_grid = \"Grid Settings\"\r\nupperPrice = input.float(70.0, \"Upper Price\", group=grp_grid)\r\nlowerPrice = input.float(40.0, \"Lower Price\", group=grp_grid)\r\ngridLines  = input.int(30, \"Number of Grid Lines\", minval=2, group=grp_grid)\r\ngridType   = input.string(\"Arithmetic\", \"Grid Type\", options=[\"Arithmetic\", \"Geometric\"], group=grp_grid)\r\n\r\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\r\n// Functions\r\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\r\n\r\n// @function Calculates the Maximum Drawdown percentage based on equity\r\n// @returns {float} The maximum drawdown percentage (0.0 to 1.0)\r\ncalcMaxDD() =>\r\n    var float maxEquity = 0.0\r\n    var float maxDdPercent = 0.0\r\n    \r\n    // Update max equity seen so far\r\n    maxEquity := math.max(maxEquity, strategy.equity)\r\n    \r\n    // Calculate current drawdown from the peak\r\n    float currentDd = maxEquity - strategy.equity\r\n    // Calculate drawdown percentage (decimal form, e.g., 0.05 for 5%)\r\n    float currentDdPercent = maxEquity > 0 ? (currentDd / maxEquity) : 0.0\r\n    \r\n    // Update maximum drawdown seen so far\r\n    maxDdPercent := math.max(maxDdPercent, currentDdPercent)\r\n    maxDdPercent\r\n\r\n// Calculate MaxDD on every bar (outside isconfirmed) to capture intra-bar or per-bar equity changes\r\nfloat maxDdPercent = calcMaxDD()\r\n\r\n// Initialize array to store grid levels\r\nvar float[] gridLevels = array.new_float(gridLines)\r\n\r\nif barstate.isfirst\r\n    if gridType == \"Arithmetic\"\r\n        // Arithmetic Grid: Equal price difference between levels\r\n        float step = (upperPrice - lowerPrice) / (gridLines - 1)\r\n        for i = 0 to gridLines - 1\r\n            array.set(gridLevels, i, lowerPrice + step * i)\r\n    else // Geometric\r\n        // Geometric Grid: Equal percentage difference between levels\r\n        float ratio = math.pow(upperPrice / lowerPrice, 1.0 / (gridLines - 1))\r\n        for i = 0 to gridLines - 1\r\n            array.set(gridLevels, i, lowerPrice * math.pow(ratio, i))\r\n\r\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\r\n// Strategy Logic\r\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\r\n// We loop through grid levels to place orders.\r\n// For each level (except the top one), we place a Buy Limit order.\r\n// The Take Profit for that buy order is the next grid level up.\r\n\r\nfor i = 0 to gridLines - 2\r\n    float buyPrice = array.get(gridLevels, i)\r\n    float sellPrice = array.get(gridLevels, i + 1)\r\n    \r\n    // Unique Order ID for each level\r\n    string orderId = \"LE-\" + str.tostring(i)\r\n    \r\n    // Check if we already have an open position for this specific grid level\r\n    // This prevents stacking multiple positions at the same level\r\n    bool hasPosition = false\r\n    if strategy.opentrades > 0\r\n        for t = 0 to strategy.opentrades - 1\r\n            if strategy.opentrades.entry_id(t) == orderId\r\n                hasPosition := true\r\n                break\r\n    \r\n    // Only place order if we don't have a position at this level\r\n    if not hasPosition\r\n        // Entry: Buy Limit at current level using strategy.order\r\n        strategy.order(orderId, strategy.long, limit=buyPrice)\r\n    \r\n    // Always ensure exit is set (in case it was cancelled or needs update)\r\n    // strategy.exit works for both pending and active orders linked to orderId\r\n    strategy.exit(\"LX-\" + str.tostring(i), from_entry=orderId, limit=sellPrice)\r\n\r\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\r\n// Visualization\r\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\r\n// Plot grid lines for visual confirmation (Only once at the start)\r\nif barstate.isfirst\r\n    for i = 0 to gridLines - 1\r\n        line.new(bar_index, array.get(gridLevels, i), bar_index + 1, array.get(gridLevels, i), extend=extend.both, color=color.new(color.gray, 50))\r\n\r\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\r\n// Dashboard\r\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\r\ngrp_dash = \"Dashboard Settings\"\r\nisShow = input.bool(true, \"Show Dashboard\", group=grp_dash)\r\nposInput = input.string(\"Bottom Right\", \"Position\", options=[\"Top Right\", \"Top Left\", \"Bottom Right\", \"Bottom Left\", \"Middle Right\", \"Middle Left\"], group=grp_dash)\r\n\r\n// Determine table position based on input\r\nvar string tablePos = position.top_right\r\nif barstate.isfirst\r\n    if posInput == \"Top Left\"\r\n        tablePos := position.top_left\r\n    else if posInput == \"Bottom Right\"\r\n        tablePos := position.bottom_right\r\n    else if posInput == \"Bottom Left\"\r\n        tablePos := position.bottom_left\r\n    else if posInput == \"Middle Right\"\r\n        tablePos := position.middle_right\r\n    else if posInput == \"Middle Left\"\r\n        tablePos := position.middle_left\r\n\r\n// Create table\r\nvar table dashTable = table.new(tablePos, 2, 8, border_width=1)\r\n\r\n// Update dashboard only on confirmed bars and if enabled\r\nif isShow and barstate.isconfirmed\r\n    // Calculate Metrics\r\n    float avgProfit = strategy.closedtrades > 0 ? strategy.netprofit / strategy.closedtrades : 0.0\r\n    float cashflow = strategy.netprofit // Realized profit\r\n    \r\n    // Time Calculations for CAGR and Monthly Return\r\n    float totalDays = (time - strategy.closedtrades.entry_time(0)) / (1000 * 60 * 60 * 24)\r\n    float totalYears = totalDays / 365.0\r\n    float totalMonths = totalDays / 30.44 // Average days in a month\r\n    \r\n    // CAGR Calculation: (End Value / Start Value)^(1/n) - 1\r\n    float endValue = strategy.initial_capital + strategy.netprofit\r\n    float cagr = totalYears > 0 ? math.pow(endValue / strategy.initial_capital, 1.0 / totalYears) - 1 : 0.0\r\n    \r\n    // Avg Monthly Return Calculation\r\n    float avgMonthlyReturn = totalMonths > 0 ? (strategy.netprofit / strategy.initial_capital) / totalMonths : 0.0\r\n\r\n    // Header\r\n    table.cell(dashTable, 0, 0, \"Topic\", bgcolor=color.gray, text_color=color.white)\r\n    table.cell(dashTable, 1, 0, \"Value\", bgcolor=color.gray, text_color=color.white)\r\n    \r\n    // Rows\r\n    table.cell(dashTable, 0, 1, \"Initial Capital\", bgcolor=color.black, text_color=color.white)\r\n    table.cell(dashTable, 1, 1, str.tostring(strategy.initial_capital, \"#,###.00\"), bgcolor=color.black, text_color=color.white)\r\n    \r\n    table.cell(dashTable, 0, 2, \"Avg. Profit per Grid\", bgcolor=color.black, text_color=color.white)\r\n    table.cell(dashTable, 1, 2, str.tostring(avgProfit, \"#,###.00\"), bgcolor=color.black, text_color=color.white)\r\n    \r\n    table.cell(dashTable, 0, 3, \"Cashflow\", bgcolor=color.black, text_color=color.white)\r\n    table.cell(dashTable, 1, 3, str.tostring(cashflow, \"#,###.00\"), bgcolor=color.black, text_color=color.green)\r\n    \r\n    table.cell(dashTable, 0, 4, \"MaxDD\", bgcolor=color.black, text_color=color.white)\r\n    // Display MaxDD as percentage using pattern (automatically multiplies by 100 and adds %)\r\n    table.cell(dashTable, 1, 4, str.tostring(maxDdPercent, \"0.00%\"), bgcolor=color.black, text_color=color.red)\r\n\r\n    table.cell(dashTable, 0, 5, \"Avg Monthly Return\", bgcolor=color.black, text_color=color.white)\r\n    table.cell(dashTable, 1, 5, str.tostring(avgMonthlyReturn, \"0.00%\"), bgcolor=color.black, text_color=color.green)\r\n\r\n    table.cell(dashTable, 0, 6, \"CAGR\", bgcolor=color.black, text_color=color.white)\r\n    table.cell(dashTable, 1, 6, str.tostring(cagr, \"0.00%\"), bgcolor=color.black, text_color=color.green)\r\n\r\n    table.cell(dashTable, 0, 7, \"Version\", bgcolor=color.black, text_color=color.white)\r\n    table.cell(dashTable, 1, 7, version, bgcolor=color.black, text_color=color.white)\r\nelse if not isShow\r\n    table.clear(dashTable, 0, 0, 1, 8)\r\n"
  },
  {
    "url": "RiQzLLoh-RSI-Strategy-PrimeAutomation",
    "name": "RSI Strategy [PrimeAutomation]",
    "description": "â¯ OVERVIEW \nThe  RSI Strategy   is a momentum-driven trading system built around the behavior of the Relative Strength Index (RSI).  \nInstead of using traditional overbought/oversold zones, this strategy focuses on  RSI breakouts  with volatility-based trailing stops, adaptive profit-targets, and optional early-exit logic.  \nIt is designed to capture strong continuation moves after momentum shifts while protecting trades using ATR-based dynamic risk management.\n\n â¯ CONCEPTS \n  \n \n   RSI Breakout Momentum:  Entries happen when RSI breaks above/below custom thresholds, signaling a shift in momentum rather than mean reversion.\n   Volatility-Adjusted Risk:  ATR defines both stop-loss and profit-target distances, scaling positions based on market volatility.\n   Dynamic Trailing Stop:  The strategy maintains an adaptive trailing level that tightens as price moves in the tradeâ€™s favor.\n   Single-Position System:  Only one trade at a time (no pyramiding), maximizing clarity and simplifying execution.\n \n\n â¯ KEY FEATURES \n \n   RSI Signal Engine   \n  â€¢ Long when RSI crosses  above Upper threshold   \n  \n  â€¢ Short when RSI crosses  below Lower threshold   \n  \n  These levels are configurable and optimized for trend-momentum detection.\n\n   ATR-Based Stop-Loss   \n  A custom ATR multiplier defines the initial stop.  \n  â€¢ Long stop = price â€“ ATR Ã— multiplier  \n  \n  â€¢ Short stop = price + ATR Ã— multiplier  \n  \n  Stops adjust continuously using a trailing model.\n\n   ATR-Based Take Profit (Optional)   \n  Profit targets scale with volatility.  \n  â€¢ Long TP = entry + ATR Ã— TP-multiplier  \n  \n  â€¢ Short TP = entry â€“ ATR Ã— TP-multiplier  \n  \n  Users can disable TP and rely solely on trailing stops.\n\n   Real-Time Trailing Logic   \n  The stop updates bar-by-bar:  \n  â€¢ In a long trade â†’ stop moves upward only  \n  â€¢ In a short trade â†’ stop moves downward only  \n  This keeps the stop tight as trends develop.\n\n   Early Exit Module (Optional)   \n  After X bars in a trade, opposite RSI signals trigger exit.  \n  This reduces holding time during weak follow-through phases.\n\n   Full Visual Layer   \n  â€¢ RSI plotted with threshold fills  \n  â€¢ Entry/TP/Stop visual lines  \n  â€¢ Color-coded zones for clarity  \n \n\n â¯ HOW TO USE \n \n   Look for RSI Breakouts:   \n  Focus on RSI crossing above the upper boundary (long) or below the lower boundary (short). These moments identify fresh momentum surges.\n  \n   Use ATR Levels to Manage Risk:   \n  Because stops and targets scale with volatility, the strategy adapts well to both quiet and explosive market phases.\n   Monitor Trailing Stops for Trend Continuation:   \n  The trailing stop is the primary driver of exitsâ€”often outperforming fixed targets by catching larger runs.\n\n   Use on Liquid Markets & Mid-Higher Timeframes:   \n  The system performs best where RSI and ATR signals are cleanâ€”crypto majors, FX, and indices.\n \n\n â¯ CONCLUSION \nThe  RSI Strategy   is a modern RSI breakout system enhanced with volatility-adaptive risk management and flexible exit logic. It is designed for traders who prefer momentum confirmation over mean reversion, offering a disciplined framework with robust protections and dynamic trend-following capability.  \nIts blend of ATR-based stops, optional profit targets, and RSI-driven entries makes it a reliable strategy across a wide range of market conditions.",
    "image_url": "RiQzLLoh",
    "author": "ChartPrime",
    "likes": 995,
    "type": "strategy",
    "created": "2025-11-26",
    "updated": "2025-11-26",
    "source": "// This Pine Scriptâ„¢ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// Â© PrimeAutomation\r\n\r\n//@strategy_alert_message {{strategy.order.alert_message}}\r\n\r\n//@version=6\r\nstrategy(\"RSI Strategy [PrimeAutomation]\", overlay=false\r\n , default_qty_type = strategy.percent_of_equity\r\n , default_qty_value = 10 \r\n , commission_type = strategy.commission.percent \r\n , commission_value = 0.06 \r\n , initial_capital = 10000\r\n , margin_long = 0\r\n , margin_short = 0\r\n , process_orders_on_close = true\r\n , pyramiding = 0\r\n )\r\n\r\n\r\n\r\nstring OpSettings           = \"âžž Optimization Settings ðŸ”¸\"\r\nstring OpSettings1          = \"âžž Settings ðŸ”¸\"\r\n\r\n\r\n// Strategy Settings\r\nstartTime     = input.time(timestamp(\"01-01-2023\"), \"Strategy Start Date\", group = OpSettings1)\r\nMarketClosed  = input.bool(false ,\"Exit before market close\", group = OpSettings1)\r\n\r\n\r\nvar StartTIME = 0\r\ntotaltrades = strategy.closedtrades\r\nPNL = strategy.netprofit_percent + strategy.openprofit_percent\r\nWinRate = (strategy.wintrades / totaltrades ) * 100 \r\nMaxDraw = strategy.max_drawdown_percent\r\n\r\nCon = strategy.closedtrades == 0 and strategy.opentrades == 1 \r\nStartTIME:= ta.valuewhen(Con and not Con[1],time,0)\r\n\r\nMC()=>\r\n    hr = hour == 15\r\n    min = minute == 55\r\n    _Hr = request.security(syminfo.tickerid,\"5\",hr)\r\n    _min = request.security(syminfo.tickerid,\"5\",min)\r\n    MClose = (_Hr and _min )\r\n    MClose\r\n\r\n\r\nvar float dailyPNL = na\r\nvar int maxDays = 60\r\nvar float lastNetProfit = na\r\nvar array<string> PNLS = array.new_string()\r\n\r\nnewDay = ta.change(time(\"D\")) != 0\r\ncurrentNetProfit = strategy.netprofit\r\n\r\nif newDay\r\n    if not na(lastNetProfit)\r\n        dailyPNL := currentNetProfit - lastNetProfit\r\n\r\n        if dailyPNL != 0\r\n            dateStr = str.format(\"{0,date,MM-dd}\", time)\r\n            combined = dateStr + \":\" + str.tostring(dailyPNL, \"#.##\")\r\n            array.unshift(PNLS, combined)\r\n\r\n            if array.size(PNLS) > maxDays\r\n                array.pop(PNLS)\r\n\r\n    lastNetProfit := currentNetProfit\r\n\r\n\r\n\r\n// log.error(str.tostring(PNLS))\r\n\r\n\r\n\r\ntradesCount = strategy.closedtrades\r\n\r\n// Get PnL of last closed trade\r\nLastPNL = 0.\r\nif tradesCount > 0\r\n    LastPNL := strategy.closedtrades.profit(tradesCount - 1)\r\n\r\n\r\n\r\nmethod parseing(string st,tp = 0 , sl = 0 , size = 0 , per = 0.)=>\r\n    string ret = st\r\n    ret := str.replace_all(ret, \"{{tickerid}}\", syminfo.tickerid)\r\n    ret := str.replace_all(ret, \"{{ticker}}\", syminfo.ticker)\r\n    ret := str.replace_all(ret, \"{{exchange}}\", syminfo.prefix)\r\n    ret := str.replace_all(ret, \"{{close}}\", str.tostring(close))\r\n    ret := str.replace_all(ret, \"{{open}}\", str.tostring(open))\r\n    ret := str.replace_all(ret, \"{{high}}\", str.tostring(high))\r\n    ret := str.replace_all(ret, \"{{low}}\", str.tostring(low))\r\n    ret := str.replace_all(ret, \"{{time}}\", str.format_time(time, \"yyyy-MM-dd HH:mm\", syminfo.timezone))\r\n    ret := str.replace_all(ret, \"{{timenow}}\", str.format_time(timenow, \"yyyy-MM-dd HH:mm\", syminfo.timezone))\r\n    ret := str.replace_all(ret, \"{{volume}}\", str.tostring(volume))\r\n    ret := str.replace_all(ret, \"{{interval}}\", timeframe.period)\r\n    ret := str.replace_all(ret, \"{{country}}\", syminfo.country)\r\n    ret := str.replace_all(ret, \"{{description}}\", syminfo.description)\r\n    ret := str.replace_all(ret, \"{{root}}\", syminfo.root)\r\n    ret := str.replace_all(ret, \"{{industry}}\", syminfo.industry)\r\n    ret := str.replace_all(ret, \"{{type}}\", syminfo.type)\r\n    ret := str.replace_all(ret, \"{{tp}}\", str.tostring(tp))\r\n    ret := str.replace_all(ret, \"{{sl}}\", str.tostring(sl))\r\n    ret := str.replace_all(ret, \"{{size}}\", str.tostring(size))\r\n    ret := str.replace_all(ret, \"{{per}}\", str.tostring(per))\r\n    ret := str.replace_all(ret, \"{{TotalTrades}}\", str.tostring(strategy.closedtrades))\r\n    ret := str.replace_all(ret, \"{{PNL}}\", str.tostring(strategy.netprofit_percent + strategy.openprofit_percent,\"#.##\"))\r\n    ret := str.replace_all(ret, \"{{WinRate}}\", str.tostring((strategy.wintrades / totaltrades) * 100 ,\"#.##\"))\r\n    ret := str.replace_all(ret, \"{{MaxDraw}}\", str.tostring(strategy.max_drawdown_percent,\"#.##\" ))\r\n    ret := str.replace_all(ret, \"{{StartDate}}\", str.format(\"{0,date,medium}\",StartTIME))\r\n    ret := str.replace_all(ret, \"{{DailyPnl}}\", str.tostring(dailyPNL,\"#.##\"))\r\n    ret := str.replace_all(ret, \"{{historyPNL}}\", str.tostring(PNLS))\r\n    ret := str.replace_all(ret, \"{{LastPNL}}\", str.tostring(LastPNL))\r\n    ret\r\n\r\n\r\n\r\nLongEntryMSG   = '{\"ticker\": \"{{ticker}}\",\"action\": \"buy\",\"price\": \"{{close}}\", \"time\": \"{{timenow}}\", \"size\": \"{{size}}\",\"TotalTrades\":  \"{{TotalTrades}}\" ,\"PNL\": \"{{PNL}}\", \"WinRate\":  \"{{WinRate}}\", \"MaxDraw\": \"{{MaxDraw}}\", \"StartDate\":  \"{{StartDate}}\", \"DailyPNL\": \"{{DailyPnl}}\"}'\r\nLongExitMSG    = '{\"ticker\": \"{{ticker}}\",\"action\": \"exit_buy\",\"price\": \"{{close}}\", \"time\": \"{{timenow}}\", \"size\": \"{{size}}\", \"per\": \"{{per}}\", \"sl\": \"{{sl}}\", \"tp\": \"{{tp}}\" ,\"TotalTrades\":  \"{{TotalTrades}}\" ,\"PNL\": \"{{PNL}}\", \"WinRate\":  \"{{WinRate}}\", \"MaxDraw\": \"{{MaxDraw}}\", \"StartDate\":  \"{{StartDate}}\", \"DailyPNL\": \"{{DailyPnl}}\"}'\r\nShortEntryMSG  = '{\"ticker\": \"{{ticker}}\",\"action\": \"sell\",\"price\": \"{{close}}\", \"time\": \"{{timenow}}\", \"size\": \"{{size}}\" ,\"TotalTrades\":  \"{{TotalTrades}}\" ,\"PNL\": \"{{PNL}}\", \"WinRate\":  \"{{WinRate}}\", \"MaxDraw\": \"{{MaxDraw}}\", \"StartDate\":  \"{{StartDate}}\", \"DailyPNL\": \"{{DailyPnl}}\"}'\r\nShortExitMSG   = '{\"ticker\": \"{{ticker}}\",\"action\": \"exit_sell\",\"price\": \"{{close}}\", \"time\": \"{{timenow}}\", \"size\": \"{{size}}\", \"per\": \"{{per}}\", \"sl\": \"{{sl}}\", \"tp\": \"{{tp}}\" ,\"TotalTrades\":  \"{{TotalTrades}}\" ,\"PNL\": \"{{PNL}}\", \"WinRate\":  \"{{WinRate}}\", \"MaxDraw\": \"{{MaxDraw}}\", \"StartDate\":  \"{{StartDate}}\", \"DailyPNL\": \"{{DailyPnl}}\"}'\r\n\r\n\r\n\r\n\r\nvar float currentSize = na\r\nisNewTrade = strategy.opentrades > strategy.opentrades[1]\r\n\r\nif isNewTrade\r\n    currentSize := math.abs(strategy.opentrades.size(strategy.opentrades -1))\r\n\r\n\r\nMarketisClose = MC()\r\n\r\n\r\n\r\n// --------------------------------------------------------------------------------------------------------------------}\r\n// ðŸ“Œ ð™ð™Žð™€ð™ ð™„ð™‰ð™‹ð™ð™ð™Ž\r\n// --------------------------------------------------------------------------------------------------------------------{\r\nlen       = input.int(40, minval = 1, title = \"RSI Length\", group = OpSettings)\r\nupper     = input.int(60, \"Upper\", group = OpSettings)\r\nlower     = input.int(35, \"Lower\", group = OpSettings)\r\n\r\n\r\nmultiStop = input.float(4, \"Trail Stop\", step = 0.1, group = \"TP/SL\")\r\nuseTP     = input.bool(true, \"Take Profit\", group = \"TP/SL\", inline = \"tp\")\r\nmultiTP   = input.float(7, \"\", step = 0.1, group = \"TP/SL\", inline = \"tp\")\r\n\r\nrsi = ta.rsi(close, len)\r\n\r\n\r\n// Variables\r\nvar bool  trend     = false\r\n\r\nvar tp1     = float(na)\r\nvar stop    = float(na)\r\nvar stop1    = float(na)\r\n\r\nvar enter   = float(na)\r\nvar isLong  = bool(na)\r\n\r\natr = ta.atr(200) * multiStop\r\natr1 = ta.atr(200) * multiTP\r\n\r\nvar inTrade = false\r\nvar startL = 0\r\n\r\n\r\n// Signals\r\nBuy  = ta.crossover(rsi, upper) \r\nSell = ta.crossunder(rsi, lower)\r\n\r\n\r\n\r\n// Strategy Execution// -----------------------------------------------------------------------------------------------{\r\n\r\n\r\n\r\ntrailActivation = close - atr\r\ntrailDistance   = atr\r\n\r\n\r\n\r\nBuyExit  = low < stop and isLong \r\nSellExit = high > stop and not isLong \r\n\r\nTPLong   = ta.crossover(high, tp1) and isLong\r\nTPShort  = ta.crossunder(low, tp1) and not isLong\r\n\r\nisTrailing = true\r\n\r\n\r\n\r\n\r\nif time >= startTime and bar_index > 200\r\n\r\n\r\n\r\n\r\n\r\n\t// TakeProfit \r\n\tif strategy.opentrades == 0\r\n\t\tstop := float(na)\r\n\t\ttp1 := float(na)\r\n\t\tenter := float(na)\r\n\t\tinTrade := false\r\n        stop1 := float(na)\r\n    \r\n\r\n\r\n    // Trades\r\n    if Buy and (useTP or isTrailing ? not inTrade : true)\r\n\r\n        label.new(bar_index-1, rsi[1], \"â—†\\nLONG\", color = color(na), textcolor = chart.fg_color, style = label.style_label_up)\r\n\r\n        stop   := float(na)\r\n\t\tstop   := close - atr\r\n        stop1  := stop\r\n\t\tisLong := true\r\n\r\n        if useTP\r\n\t\t    tp1 := close + atr1\r\n\r\n\t\tenter   := close\r\n\t\tinTrade := true\r\n\r\n        strategy.close('Short', 'Short Exit', alert_message = ShortExitMSG.parseing(per = 100,size = math.abs(strategy.position_size)))   \r\n        strategy.entry(\"Long\", strategy.long, comment=\"Long\", alert_message =  LongEntryMSG.parseing( size = currentSize ))\r\n\r\n    if Sell and (useTP or isTrailing ? not inTrade : true)\r\n\r\n        label.new(bar_index-1, rsi[1], \"SHORT\\nâ—†\", color = color(na), textcolor = chart.fg_color, style = label.style_label_down)\r\n\r\n        stop   := float(na)\r\n\t\tstop   := close + atr\r\n        stop1  := stop\r\n\t\tisLong := false\r\n\r\n        if useTP\r\n\t\t    tp1 := close - atr1 \r\n\r\n\t\tenter   := close\r\n\t\tinTrade := true\r\n\r\n        strategy.close('Long', 'Long Exit', alert_message = LongExitMSG.parseing(per = 100,size = math.abs(strategy.position_size))) \r\n        strategy.entry(\"Short\", strategy.short, comment=\"Short\", alert_message =  ShortEntryMSG.parseing( size = currentSize))\r\n\r\n\r\n    txtStopL = \"Long Exit\"\r\n    txtStopS = \"Short Exit\"\r\n\r\n    strategy.exit(txtStopL, \"Long\", stop = stop1, qty_percent = 100, alert_message = LongExitMSG.parseing(per = 100,size = math.abs(strategy.position_size)))\r\n    strategy.exit(txtStopS, \"Short\", stop = stop1, qty_percent = 100, alert_message = ShortExitMSG.parseing(per = 100,size = math.abs(strategy.position_size)))\r\n\r\n    strategy.exit(txtStopL, \"Long\", limit = tp1, stop = stop, qty_percent = 100, alert_message = LongExitMSG.parseing(per = 100,size = math.abs(strategy.position_size)))\r\n    strategy.exit(txtStopS, \"Short\", limit = tp1, stop = stop, qty_percent = 100, alert_message = ShortExitMSG.parseing(per = 100,size = math.abs(strategy.position_size)))\r\n\r\n\r\n    // Exits\r\n    if BuyExit \r\n        strategy.close('Long', txtStopL, alert_message = LongExitMSG.parseing(per = 100,size = math.abs(strategy.position_size)), immediately = true) \r\n\r\n    if SellExit \r\n        strategy.close('Short', txtStopS, alert_message = ShortExitMSG.parseing(per = 100,size = math.abs(strategy.position_size)), immediately = true)   \r\n\r\n\r\n\r\n\r\n    // Trailing Stop\r\n    if inTrade and isTrailing\r\n\r\n        if isLong \r\n            stop := math.max(stop, low-atr)\r\n\r\n        else \r\n            stop := math.min(stop, high+atr)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Close Trades when Market Closed\r\nif MarketClosed and MarketClosed \r\n    if strategy.position_size > 0\r\n        strategy.close('Long', 'Long Exit', alert_message = LongExitMSG.parseing(per = 100,size = math.abs(strategy.position_size))) \r\n    else \r\n        strategy.close('Short', 'Short Exit', alert_message = ShortExitMSG.parseing(per = 100,size = math.abs(strategy.position_size)))   \r\n\r\n\r\n\r\n// --------------------------------------------------------------------------------------------------------------------}\r\n// Plot\r\nps = plot(trend != trend[1] ? na : stop, \"Trail Stop\", color = color.red, style = plot.style_linebr, force_overlay = true)\r\npt = plot(trend != trend[1] ? na : tp1, \"Take Profit\", color = color.green, style = plot.style_linebr, force_overlay = true)\r\npe = plot(trend != trend[1] ? na : enter, \"Entery Price\", color = chart.fg_color, style = plot.style_linebr, force_overlay = true)\r\n\r\nfill(pe, pt, tp1, enter, color(na), color.new(color.green, 80))\r\nfill(pe, ps, stop, enter, color(na), color.new(color.red, 80))\r\n\r\n\r\nplot(rsi, \"RSI\",  color = color.purple, linewidth = 2)\r\n\r\npu = plot(upper, \"Upper threshold\", color = color.green)\r\npl = plot(lower, \"Lower threshold\", color = color.red)\r\npm = plot(50, \"Mid Line\", color = chart.fg_color)\r\n\r\nfill(pm, pu, upper, 50, color(na), color.new(color.green, 80))\r\nfill(pm, pl, lower, 50, color(na), color.new(color.red, 80))\r\n\r\n"
  },
  {
    "url": "Sqi9L2O3-NIFTY-Options-Breakout-Strategy",
    "name": "NIFTY Options Breakout Strategy",
    "description": "This strategy trades NIFTY 50 Options (CALL & PUT) using 5-minute breakout logic, strict trend filters, expiry-based symbol validation, and a dynamic trailing-profit engine.\n\n1ï¸âƒ£ Entry Logic\n\nOnly trades NIFTY 50 options, filtered automatically by symbol.\n\nTrades only between 10:00 AM â€“ 2:15 PM (5m bars).\n\nBreakout trigger:\n\nPrice enters the buy breakout zone (high of last boxLookback bars Â± buffer).\n\nTrend filter:\n\nPrice must be above EMA50 or EMA200,\n\nAND EMA50 â‰¥ EMA100 (to avoid weak conditions).\n\nOptional strengthening:\n\nEMA20>EMA50 OR EMA50>EMA100 recent cross can be enforced.\n\nHigher-timeframe trend check:\n\nEMA50 > EMA200 (bullish regime only).\n\nStart trading options only after expiryâ€“2 months (auto-parsed).\n\n2ï¸âƒ£ One Trade Per Day\n\nMaximum 1 long trade per day.\n\nNo shorting (long-only strategy).\n\n3ï¸âƒ£ Risk Management â€” SL, TP & Trailing\n\nIncludes three types of exits:\n\nðŸ”¹ A) Hard SL/TP\n\nHard Stop-Loss: -15%\n\nHard Take-Profit: +40%\n\nðŸ”¹ B) Step-Ladder Trailing Profit\n\nAs the option price rises, trailing activates:\n\nMax Profit Reached\tExit Trigger When Falls To\nâ‰¥ 35%\tâ‰¤ 30%\nâ‰¥ 30%\tâ‰¤ 25%\nâ‰¥ 25%\tâ‰¤ 20%\nâ‰¥ 20%\tâ‰¤ 15%\nâ‰¥ 15%\tâ‰¤ 10%\nâ‰¥ 5%\tâ‰¤ 0%\nðŸ”¹ C) Loss-Recovery Exit\n\nIf loss reaches â€“10% but then recovers to 0%, exit at breakeven.\n\n4ï¸âƒ£ Trend-Reversal Exit\n\nIf price closes below 5m EMA50, the long is exited instantly.\n\n5ï¸âƒ£ Optional Intraday Exit\n\nEOD square-off at 3:15 PM.\n\n6ï¸âƒ£ Alerts for Automation\n\nThe strategy provides alerts for:\n\nBUY entry\n\nTP/SL/Trailing exit\n\nEMA50 reversal exit\n\nEOD exit",
    "image_url": "Sqi9L2O3",
    "author": "maheshxlent",
    "likes": 16,
    "type": "strategy",
    "created": "2025-11-26",
    "updated": "2025-11-26",
    "source": "//@version=5\r\nstrategy(\"NIFTY Options Breakout Strategy\",\r\n     overlay           = true,\r\n     initial_capital   = 25000,\r\n     default_qty_type  = strategy.fixed,\r\n     default_qty_value = 1,\r\n     commission_type   = strategy.commission.percent,\r\n     commission_value  = 0.015)\r\n\r\n// === INPUTS ===\r\nboxLookback = input.int(10, title=\"Breakout Range Lookback Bars\")\r\n\r\n// Hard SL/TP in % from entry price (for options)\r\nslPercent = input.float(15.0, title=\"Hard SL % from Entry\", minval=0.0)   // -15%\r\ntpPercent = input.float(40.0, title=\"Hard TP % from Entry\", minval=0.0)   // +40%\r\n\r\nshowSymbolDebug    = input.bool(true,  \"Highlight allowed symbols?\")\r\nenableEODExit      = input.bool(true,  \"Enable EOD Exit at 3:15 PM?\")\r\n\r\n// EMA trend helpers\r\nuseEMACrossFilter  = input.bool(false, \"Use EMA Cross Filter (20>50 or 50>100)?\")\r\nemaCrossLookback   = input.int(20,     \"EMA Cross Lookback Bars\", minval=1)\r\n\r\n// === AUTO BUFFER BY SYMBOL (BASE SETTINGS) ===\r\nuseAutoBuffer   = input.bool(true, title=\"Auto Buffer % by Symbol?\")\r\nmanualBufferPct = input.float(0.05, title=\"Manual Buffer %\", minval=0.0)\r\n\r\n// Symbol / description (current chart)\r\ntickerUpper = str.upper(syminfo.ticker)\r\ndescUpper   = str.upper(syminfo.description)\r\n\r\n// Index checks\r\nisNifty     = str.contains(descUpper, \"NIFTY 50\") or str.contains(tickerUpper, \"NIFTY\")\r\nisBankNifty = str.contains(descUpper, \"BANKNIFTY\") or str.contains(tickerUpper, \"BANKNIFTY\")\r\n\r\n// Option type from description\r\nisCallDesc = str.contains(descUpper, \"CALL\")\r\nisPutDesc  = str.contains(descUpper, \"PUT\")\r\n\r\n// We want NIFTY 50 CALL or PUT options\r\nisNiftyOption  = isNifty and (isCallDesc or isPutDesc)\r\ncanTradeSymbol = isNiftyOption\r\n\r\n// ----------------------------------------------------------------------\r\n// EXPIRY PARSING: START TRADING FROM 1ST OF (EXPIRY MONTH - 2)\r\n// ----------------------------------------------------------------------\r\nint expMonth = 0\r\nint expYear  = na\r\n\r\nstring[] tokens = str.split(descUpper, \" \")\r\nfor i = 0 to array.size(tokens) - 1\r\n    tk = array.get(tokens, i)\r\n\r\n    if      tk == \"JAN\"\r\n        expMonth := 1\r\n    else if tk == \"FEB\"\r\n        expMonth := 2\r\n    else if tk == \"MAR\"\r\n        expMonth := 3\r\n    else if tk == \"APR\"\r\n        expMonth := 4\r\n    else if tk == \"MAY\"\r\n        expMonth := 5\r\n    else if tk == \"JUN\"\r\n        expMonth := 6\r\n    else if tk == \"JUL\"\r\n        expMonth := 7\r\n    else if tk == \"AUG\"\r\n        expMonth := 8\r\n    else if tk == \"SEP\"\r\n        expMonth := 9\r\n    else if tk == \"OCT\"\r\n        expMonth := 10\r\n    else if tk == \"NOV\"\r\n        expMonth := 11\r\n    else if tk == \"DEC\"\r\n        expMonth := 12\r\n\r\n    num = str.tonumber(tk)\r\n    if not na(num) and num >= 2000 and num <= 2100\r\n        expYear := int(num)\r\n\r\n// Compute \"start trading from\" month/year (2 months before expiry)\r\nint startMonth = na\r\nint startYear  = na\r\n\r\nif expMonth != 0 and not na(expYear)\r\n    if expMonth > 2\r\n        startMonth := expMonth - 2\r\n        startYear  := expYear\r\n    else\r\n        // JAN / FEB: shift to previous year\r\n        startMonth := expMonth + 10    // JAN -> 11, FEB -> 12 of previous year\r\n        startYear  := expYear - 1\r\n\r\n// Current bar date\r\ncurY = year(time)\r\ncurM = month(time)\r\ncurD = dayofmonth(time)\r\n\r\n// Only trade on/after 1st of (startMonth/startYear); if parsing failed, allow trading\r\nexpiryWindowOK =\r\n     na(startYear) ? true :\r\n     (curY > startYear or\r\n     (curY == startYear and curM > startMonth) or\r\n     (curY == startYear and curM == startMonth and curD >= 1))\r\n\r\n// Debug shading\r\nbgcolor(showSymbolDebug ? (canTradeSymbol ? color.new(color.green, 90) : na) : na)\r\n\r\n// ======================================================================\r\n// 5-MINUTE LOGIC WRAPPED IN FUNCTION\r\n// ======================================================================\r\nf_5mSignals() =>\r\n    tU = str.upper(syminfo.ticker)\r\n    dU = str.upper(syminfo.description)\r\n    isNifty_5     = str.contains(dU, \"NIFTY 50\") or str.contains(tU, \"NIFTY\")\r\n    isBankNifty_5 = str.contains(dU, \"BANKNIFTY\") or str.contains(tU, \"BANKNIFTY\")\r\n    isCall_5      = str.contains(dU, \"CALL\")\r\n    isPut_5       = str.contains(dU, \"PUT\")\r\n    isNiftyOpt_5  = isNifty_5 and (isCall_5 or isPut_5)\r\n    canTrade_5    = isNiftyOpt_5\r\n\r\n    bufferPercent_5 = useAutoBuffer\r\n         ? (isNiftyOpt_5 ? 5.0 : isBankNifty_5 ? 0.08 : isNifty_5 ? 0.05 : 0.05)\r\n         : manualBufferPct\r\n    bufferPoints_5  = close * bufferPercent_5 / 100.0\r\n\r\n    breakoutHigh_5 = ta.highest(high, boxLookback)\r\n    breakoutLow_5  = ta.lowest(low,  boxLookback)\r\n\r\n    ema10_5   = ta.ema(close, 10)\r\n    ema20_5   = ta.ema(close, 20)\r\n    ema50_5   = ta.ema(close, 50)\r\n    ema100_5  = ta.ema(close, 100)\r\n    ema200_5  = ta.ema(close, 200)\r\n\r\n    buyCond_5  = close >= (breakoutHigh_5 - bufferPoints_5) and close <= breakoutHigh_5\r\n    sellCond_5 = close <= (breakoutLow_5  + bufferPoints_5) and close >= breakoutLow_5\r\n\r\n    // === BASE EMA TREND FILTER ===\r\n    // Require price above 50 or 200 AND 50 EMA >= 100 EMA (no longs if 50 < 100)\r\n    buyFilter_5_base  = ((close > ema50_5) or (close > ema200_5)) and ema50_5 >= ema100_5\r\n    sellFilter_5      = (close < ema50_5) or (close < ema200_5)\r\n\r\n    // === OPTIONAL EMA CROSS FILTER (20>50 or 50>100) ===\r\n    cross_20_50  = ta.crossover(ema20_5, ema50_5)   // 20 crosses above 50\r\n    cross_50_100 = ta.crossover(ema50_5, ema100_5)  // 50 crosses above 100\r\n    anyBullCross = cross_20_50 or cross_50_100\r\n\r\n    barsSinceCross  = ta.barssince(anyBullCross)\r\n    recentBullCross = not na(barsSinceCross) and barsSinceCross <= emaCrossLookback\r\n\r\n    buyFilter_5 = useEMACrossFilter ? (buyFilter_5_base and recentBullCross) : buyFilter_5_base\r\n\r\n    h = hour(time)\r\n    m = minute(time)\r\n    timeOK_5 = (h > 9) and (h < 14 or (h == 14 and m <= 15))\r\n\r\n    rawBuy_5  = buyCond_5  and buyFilter_5  and timeOK_5 and canTrade_5 and barstate.isconfirmed\r\n    rawSell_5 = sellCond_5 and sellFilter_5 and timeOK_5 and canTrade_5 and barstate.isconfirmed\r\n\r\n    longEntry_5  = rawBuy_5  and close > ema50_5\r\n    shortEntry_5 = rawSell_5 and close < ema50_5\r\n\r\n    [longEntry_5, shortEntry_5, ema10_5, ema20_5, ema50_5, ema100_5, ema200_5, close]\r\n\r\n// ======================================================================\r\n// REQUEST 5-MINUTE SIGNALS ON ANY CHART (1m / 5m / 15m)\r\n// ======================================================================\r\n[longRaw5, shortRaw5, ema10_5, ema20_5, ema50_5, ema100_5, ema200_5, close_5] =\r\n     request.security(syminfo.tickerid, \"5\", f_5mSignals(), barmerge.gaps_on, barmerge.lookahead_off)\r\n\r\n// Plot 5m EMAs\r\nplot(ema10_5,   color=color.new(color.green,  0), title=\"5m EMA 10\")\r\nplot(ema20_5,   color=color.new(color.blue,   0), title=\"5m EMA 20\")\r\nplot(ema50_5,   color=color.new(color.yellow, 0), title=\"5m EMA 50\")\r\nplot(ema100_5,  color=color.new(color.purple, 0), title=\"5m EMA 100\")\r\nplot(ema200_5,  color=color.new(color.orange, 0), title=\"5m EMA 200\")\r\n\r\n// Trend + bar count (higher-level check, still using 50 vs 200)\r\nisBullTrend = ema50_5 > ema200_5\r\nenoughBars  = bar_index > 200\r\n\r\n// ======================================================================\r\n// DAILY TRADE LIMIT & TIME\r\n// ======================================================================\r\ncurHour  = hour(time)\r\ncurMin   = minute(time)\r\n\r\nvar int tradesToday = 0\r\nvar int lastDay     = dayofmonth(time)\r\n\r\nif dayofmonth(time) != lastDay\r\n    tradesToday := 0\r\n    lastDay     := dayofmonth(time)\r\n\r\nmaxTradesPerDay = 1\r\ncanTradeToday   = tradesToday < maxTradesPerDay\r\n\r\n// EOD cutoff at 3:15 PM\r\ncutoffTime = (curHour > 15) or (curHour == 15 and curMin >= 15)\r\n\r\n// ======================================================================\r\n// FINAL ENTRY SIGNALS\r\n// ======================================================================\r\nnewLong5       = longRaw5 and not longRaw5[1]\r\nisOptionTypeOK = isCallDesc or isPutDesc\r\n\r\nlongEntrySignal  = newLong5\r\n     and strategy.position_size == 0\r\n     and canTradeToday\r\n     and enoughBars\r\n     and isBullTrend\r\n     and canTradeSymbol\r\n     and isOptionTypeOK\r\n     and expiryWindowOK\r\n\r\nplotshape(longEntrySignal,  title=\"5m BUY (CALL/PUT)\",  style=shape.labelup,   location=location.belowbar,\r\n          color=color.new(color.green, 50), text=\"BUY\",  textcolor=color.white, size=size.tiny)\r\n\r\nif longEntrySignal\r\n    strategy.entry(\"Long\", strategy.long)\r\n    tradesToday += 1\r\n\r\n// ======================================================================\r\n// TRAILING + HARD SL/TP (ALL IN %)\r\n// ======================================================================\r\nvar float maxProfitPct = 0.0   // highest profit % since entry\r\nvar float minProfitPct = 0.0   // lowest profit % since entry\r\n\r\n// Exit condition flags to use for alerts\r\nexitTP_SL_Trail = false\r\nemaExitCond     = false\r\neodExitCond     = enableEODExit and cutoffTime and strategy.position_size != 0\r\n\r\nif strategy.position_size > 0\r\n    entryPrice   = strategy.position_avg_price\r\n    curProfitPct = (close / entryPrice - 1.0) * 100.0\r\n\r\n    // update extremes\r\n    maxProfitPct := math.max(maxProfitPct, curProfitPct)\r\n    minProfitPct := math.min(minProfitPct, curProfitPct)\r\n\r\n    // --- HARD CONDITIONS ---\r\n    hardSL = curProfitPct <= -slPercent      // e.g. -15%\r\n    hardTP = curProfitPct >= tpPercent       // e.g. +40%\r\n\r\n    // --- TRAILING CONDITIONS (STEP LADDER) ---\r\n\r\n    // 1) Reached >= 35% (but < 40%), then fall to <= 30%\r\n    cond_35 = maxProfitPct >= 35.0 and maxProfitPct < 40.0 and curProfitPct <= 30.0\r\n\r\n    // 2) Reached >= 30% (but < 35%), then fall to <= 25%\r\n    cond_30 = maxProfitPct >= 30.0 and maxProfitPct < 35.0 and curProfitPct <= 25.0\r\n\r\n    // 3) Reached >= 25% (but < 30%), then fall to <= 20%\r\n    cond_25 = maxProfitPct >= 25.0 and maxProfitPct < 30.0 and curProfitPct <= 20.0\r\n\r\n    // 4) Reached >= 20% (but < 25%), then fall to <= 15%\r\n    cond_20 = maxProfitPct >= 20.0 and maxProfitPct < 25.0 and curProfitPct <= 15.0\r\n\r\n    // 5) Reached >= 15% (but < 20%), then fall to <= 10%\r\n    cond_15 = maxProfitPct >= 15.0 and maxProfitPct < 20.0 and curProfitPct <= 10.0\r\n\r\n    // 6) Reached >= 5% (but < 10%), then fall to <= 0%\r\n    cond_5  = maxProfitPct >= 5.0  and maxProfitPct < 10.0 and curProfitPct <= 0.0\r\n\r\n    // 7) Loss reached <= -10%, then recover to >= 0%\r\n    cond_loss = minProfitPct <= -10.0 and curProfitPct >= 0.0\r\n\r\n    // combined exit (will also drive alert)\r\n    exitTP_SL_Trail :=\r\n         hardSL or hardTP or\r\n         cond_35 or cond_30 or cond_25 or\r\n         cond_20 or cond_15 or cond_5 or\r\n         cond_loss\r\n\r\n    if exitTP_SL_Trail\r\n        strategy.close(\"Long\", comment=\"TP/SL/Trail\")\r\nelse\r\n    // reset when flat\r\n    maxProfitPct := 0.0\r\n    minProfitPct := 0.0\r\n\r\n// === EMA50 REVERSAL EXIT (USING 5m EMA50 & CLOSE) ===\r\nemaExitCond := strategy.position_size > 0 and close_5 < ema50_5\r\nif emaExitCond\r\n    strategy.close(\"Long\", comment=\"5m EMA50 Exit\")\r\n\r\n// === OPTIONAL EOD EXIT at 3:15 PM ===\r\nif eodExitCond\r\n    strategy.close_all(comment=\"EOD_3_15\")\r\n\r\n// ======================================================================\r\n// EXIT LABELS\r\n// ======================================================================\r\nplotshape(exitTP_SL_Trail,\r\n     title     = \"Exit TP/SL/Trail\",\r\n     style     = shape.labeldown,\r\n     location  = location.abovebar,\r\n     color     = color.new(color.red, 0),\r\n     text      = \"TP/SL\",\r\n     textcolor = color.white,\r\n     size      = size.tiny)\r\n\r\nplotshape(emaExitCond,\r\n     title     = \"Exit EMA50\",\r\n     style     = shape.labeldown,\r\n     location  = location.abovebar,\r\n     color     = color.new(color.orange, 0),\r\n     text      = \"EMA\",\r\n     textcolor = color.white,\r\n     size      = size.tiny)\r\n\r\nplotshape(eodExitCond,\r\n     title     = \"Exit EOD 3:15\",\r\n     style     = shape.labeldown,\r\n     location  = location.abovebar,\r\n     color     = color.new(color.blue, 0),\r\n     text      = \"EOD\",\r\n     textcolor = color.white,\r\n     size      = size.tiny)\r\n\r\n// ======================================================================\r\n// ALERTS\r\n// ======================================================================\r\n// Entry alert\r\nalertcondition(longEntrySignal,\r\n     title   = \"5m BUY Entry (CALL/PUT)\",\r\n     message = \"BUY: 5m NIFTY OPTIONS Breakout Signal\")\r\n\r\n// Exit alerts (TP/SL/Trailing block)\r\nalertcondition(exitTP_SL_Trail,\r\n     title   = \"Long Exit TP/SL/Trail\",\r\n     message = \"EXIT LONG: TP/SL/Trailing condition hit on NIFTY OPTIONS\")\r\n\r\n// Exit alert (EMA50 reversal)\r\nalertcondition(emaExitCond,\r\n     title   = \"Long Exit EMA50\",\r\n     message = \"EXIT LONG: 5m EMA50 reversal on NIFTY OPTIONS\")\r\n\r\n// Exit alert (EOD square-off)\r\nalertcondition(eodExitCond,\r\n     title   = \"Long Exit EOD 3:15 PM\",\r\n     message = \"EXIT LONG: EOD square-off at 3:15 PM on NIFTY OPTIONS\")\r\n"
  },
  {
    "url": "TXbM9aEV-Nifty-Breakout-Levels-Strategy-v7-Hybrid",
    "name": "Nifty Breakout Levels Strategy (v7 Hybrid)",
    "description": "Nifty Breakout Levels Strategy (v7 Hybrid â€“ Compounding from Start Date)\n\nInstrument / TF: Designed for current-month NIFTY futures on 1-hour timeframe, with at most 1 trade per day.\n\nEntry logic: Uses a 10-bar breakout box with a 0.3% buffer, plus EMA-based trend + proximity filter.\n\nLongs: price in breakout-high zone, above EMA50/EMA200 and within proximityPts.\n\nShorts: price in breakout-low zone and strong downtrend (EMA10 < EMA20 < EMA50 < EMA200, price below EMA200).\n\nTrades only when ATR(14) > atrTradeThresh and during regular hours (till 15:15).\n\nRisk / exits: Stop loss is ATR-adaptive â€“ max of slBasePoints (100 pts) and ATR * atrSLFactor; TP is fixed (tpPoints, e.g. 350 pts).\n\nLongs have stepped trailing profit levels (100/150/200/250/320 pts) that lock in gains on pullbacks.\n\nShorts have trailing loss-reduction levels (80/120/140 pts) to cut improving losses.\n\nAdditional exit: 1H EMA50 2-bar reversal against the position, plus optional EOD flatten at 3:15 PM.\n\nCompounding engine: From a chosen start date, equity is rebased to startCapital, and lot size scales dynamically as equity / capitalPerLot, with automatic lot reductions at three drawdown thresholds (ddCut1 / 2 / 3).\n\nAutomation: All entries and exits are exposed via alertconditions (long/short entry & exit) so the strategy can be connected to broker/webhook automation.",
    "image_url": "TXbM9aEV",
    "author": "maheshxlent",
    "likes": 4,
    "type": "strategy",
    "created": "2025-11-26",
    "updated": "2025-11-26",
    "source": "//@version=5\r\nstrategy(\"Nifty Breakout Levels Strategy (v7 Hybrid â€“ Compounding from Start Date)\",\r\n     overlay           = true,\r\n     initial_capital   = 225000,\r\n     default_qty_type  = strategy.fixed,\r\n     default_qty_value = 1,\r\n     commission_type   = strategy.commission.percent,\r\n     commission_value  = 0.014)\r\n\r\n// ======================================================================\r\n// INPUTS â€“ tuned for current month NIFTY futures on 1H\r\n// ======================================================================\r\n\r\n// Breakout structure\r\nboxLookback   = input.int(10,  \"Breakout Range Lookback Bars\", minval=1)\r\n\r\n// Breakout buffer in % (about 0.3% works best for NIFTY futures 1H)\r\nbufferPct     = input.float(0.30, \"Breakout Buffer % (NIFTY Futures, 1H)\", minval=0.0)\r\n\r\n// EMA trend filter\r\nproximityPts  = input.float(500.0, \"EMA Proximity (points, 1H)\", minval=0.0)\r\n\r\n// Volatility filter (Balanced sweet spot â‰ˆ 50)\r\natrTradeThresh = input.float(50.0, \"Min ATR(14, 1H) to Trade\", minval=0.0)\r\n\r\n// Risk / reward\r\nslBasePoints  = input.float(100.0, \"Base Stop Loss (points)\", minval=10)\r\ntpPoints      = input.float(350.0, \"Take Profit (points)\",    minval=20)\r\natrSLFactor   = input.float(1.0,  \"ATR SL Multiplier\",        minval=0.5, maxval=2.0)\r\n\r\n// Shorts\r\nenableShorts  = input.bool(true, \"Enable Short Trades?\")\r\n\r\n// ======================================================================\r\n// COMPOUNDING / POSITION SIZING INPUTS\r\n// ======================================================================\r\nstartCapital   = input.float(225000, \"Compounding Start Capital (â‚¹)\", minval=100000)\r\ncapitalPerLot  = input.float(225000, \"Capital per 1 NIFTY Futures Lot (â‚¹)\", minval=100000)\r\n\r\n// Compounding start date (set this to TODAY when you go live)\r\nstartYear      = input.int(2025, \"Compounding Start Year\", minval=2005, maxval=2100)\r\nstartMonth     = input.int(11,   \"Compounding Start Month\", minval=1, maxval=12)\r\nstartDay       = input.int(26,   \"Compounding Start Day\", minval=1, maxval=31)\r\n\r\n// Drawdown-based lot reduction\r\nddCut1         = input.float(10.0, \"DD Level 1 (%) â†’ -1 lot\", minval=0.0, maxval=100.0)\r\nddCut2         = input.float(15.0, \"DD Level 2 (%) â†’ -2 lots\", minval=0.0, maxval=100.0)\r\nddCut3         = input.float(20.0, \"DD Level 3 (%) â†’ 1 lot only\", minval=0.0, maxval=100.0)\r\n\r\n// Misc\r\nenableEODExit  = input.bool(false, \"Flatten at 3:15 PM? (optional intraday exit)\")\r\n\r\n// ======================================================================\r\n// 1H LOGIC FUNCTION (runs on 1H via request.security)\r\n// ======================================================================\r\nf_hourSignals() =>\r\n    // --- ATR & EMAs on 1H ---\r\n    atrLen  = 14\r\n    atr1H   = ta.atr(atrLen)\r\n\r\n    ema10   = ta.ema(close, 10)\r\n    ema20   = ta.ema(close, 20)\r\n    ema50   = ta.ema(close, 50)\r\n    ema200  = ta.ema(close, 200)\r\n\r\n    // --- Breakout levels ---\r\n    breakoutHigh = ta.highest(high, boxLookback)\r\n    breakoutLow  = ta.lowest(low,  boxLookback)\r\n\r\n    // Buffer in points for NIFTY futures\r\n    bufferPoints = close * bufferPct / 100.0\r\n\r\n    // Breakout zones\r\n    buyZone  = close >= (breakoutHigh - bufferPoints) and close <= breakoutHigh\r\n    sellZone = close <= (breakoutLow  + bufferPoints) and close >= breakoutLow\r\n\r\n    // EMA trend + proximity\r\n    buyFilter =\r\n         (close > ema50  and (close - ema50)  <= proximityPts) or\r\n         (close > ema200 and (close - ema200) <= proximityPts)\r\n\r\n    sellFilter =\r\n         (close < ema50  and (ema50  - close) <= proximityPts) or\r\n         (close < ema200 and (ema200 - close) <= proximityPts)\r\n\r\n    // Time filter (1H entries till 15:15)\r\n    curHour   = hour(time)\r\n    curMinute = minute(time)\r\n    timeOK_1H = (curHour > 9) and (curHour < 15 or (curHour == 15 and curMinute < 15))\r\n\r\n    // Raw signals\r\n    rawBuy  = buyZone  and buyFilter  and timeOK_1H and barstate.isconfirmed\r\n    rawSell = sellZone and sellFilter and timeOK_1H and barstate.isconfirmed\r\n\r\n    // Volatility filter â€“ skip dead regimes\r\n    volOK = atr1H > atrTradeThresh\r\n\r\n    // Strong downtrend for shorts (ema10 < ema20 < ema50 < ema200 & price under ema200)\r\n    bearTrendStrong = ema10 < ema20 and ema20 < ema50 and ema50 < ema200 and close < ema200\r\n\r\n    // Final 1H entries\r\n    longEntry_1H  = rawBuy  and close > ema50 and volOK\r\n    shortEntry_1H = rawSell and bearTrendStrong and volOK\r\n\r\n    [longEntry_1H, shortEntry_1H, ema10, ema20, ema50, ema200, close, atr1H]\r\n\r\n// ======================================================================\r\n// GET 1H SIGNALS & EMAs\r\n// ======================================================================\r\n[longEntryRaw_1H, shortEntryRaw_1H, ema10_1H, ema20_1H, ema50_1H, ema200_1H, close_1H, atr1H_series] = request.security(syminfo.tickerid, \"60\", f_hourSignals(), barmerge.gaps_on, barmerge.lookahead_off)\r\n\r\n// ======================================================================\r\n// PLOT 1H EMAs\r\n// ======================================================================\r\nplot(ema10_1H,  color=color.new(color.teal,   0), title=\"1H EMA 10\")\r\nplot(ema20_1H,  color=color.new(color.blue,   0), title=\"1H EMA 20\")\r\nplot(ema50_1H,  color=color.new(color.yellow, 0), title=\"1H EMA 50\")\r\nplot(ema200_1H, color=color.new(color.orange, 0), title=\"1H EMA 200\")\r\n\r\n// ======================================================================\r\n// DAILY TRADE LIMIT (1 trade per day)\r\n// ======================================================================\r\ncurHour   = hour(time)\r\ncurMinute = minute(time)\r\ncurDay    = dayofmonth(time)\r\n\r\ncutoffTime = (curHour > 15) or (curHour == 15 and curMinute >= 0)\r\n\r\nvar int tradesToday = 0\r\nvar int lastDay     = curDay\r\n\r\nif curDay != lastDay\r\n    tradesToday := 0\r\n    lastDay     := curDay\r\n\r\nint  maxTradesPerDay = 1\r\nbool canTradeToday   = tradesToday < maxTradesPerDay\r\n\r\n// ======================================================================\r\n// COMPOUNDING START DATE & EFFECTIVE EQUITY\r\n// ======================================================================\r\nstartTs = timestamp(\"Asia/Kolkata\", startYear, startMonth, startDay, 9, 15)\r\nisAfterStart = time >= startTs\r\n\r\n// We rebase equity at start date to 'startCapital'\r\nvar float eqAtStart     = na\r\nvar float effEquity     = na\r\nvar float maxEffEquity  = na\r\n\r\nif isAfterStart\r\n    if na(eqAtStart)\r\n        // first bar after start date\r\n        eqAtStart    := strategy.equity\r\n        effEquity    := startCapital\r\n        maxEffEquity := startCapital\r\n    else\r\n        effEquity    := startCapital + (strategy.equity - eqAtStart)\r\n        maxEffEquity := math.max(maxEffEquity, effEquity)\r\nelse\r\n    // Before start date we just assume fixed 1 lot, equity = startCapital (for sizing)\r\n    effEquity    := startCapital\r\n    maxEffEquity := na\r\n\r\n// Drawdown % based on effective equity (only valid after start)\r\nddPerc = (isAfterStart and not na(maxEffEquity) and maxEffEquity > 0)\r\n     ? (maxEffEquity - effEquity) / maxEffEquity * 100.0\r\n     : 0.0\r\n\r\n// ======================================================================\r\n// DYNAMIC LOT SIZING (ONLY AFTER START DATE)\r\n// ======================================================================\r\nbaseLots = isAfterStart ? math.max(1, math.floor(effEquity / capitalPerLot)) : 1\r\n\r\n// Apply DD cuts\r\nlotsAfterDD = ddPerc >= ddCut3 ? 1 : ddPerc >= ddCut2 ? math.max(1, baseLots - 2) : ddPerc >= ddCut1 ? math.max(1, baseLots - 1) : baseLots\r\n\r\n// Final dynamic lot count\r\ndynLots = lotsAfterDD\r\ndynLots := math.max(dynLots, 1)\r\n\r\n// Quantity for orders (1 contract = 1 NIFTY futures lot in TV strategy)\r\ndynQty = dynLots\r\n\r\n// ======================================================================\r\n// FINAL ENTRY SIGNALS\r\n// ======================================================================\r\nnewLong_1H  = longEntryRaw_1H  and not longEntryRaw_1H[1]\r\nnewShort_1H = shortEntryRaw_1H and not shortEntryRaw_1H[1]\r\n\r\nlongEntrySignal  = newLong_1H  and strategy.position_size == 0 and canTradeToday\r\nshortEntrySignal = enableShorts and newShort_1H and strategy.position_size == 0 and canTradeToday\r\n\r\n// Labels\r\nplotshape(longEntrySignal,  title=\"1H BUY\",  style=shape.labelup,   location=location.belowbar,\r\n          color=color.new(color.green, 50), text=\"1H BUY\",  textcolor=color.white, size=size.tiny)\r\n\r\nplotshape(shortEntrySignal, title=\"1H SELL\", style=shape.labeldown, location=location.abovebar,\r\n          color=color.new(color.red, 50),   text=\"1H SELL\", textcolor=color.white, size=size.tiny)\r\n\r\n// Orders with dynamic quantity\r\nif longEntrySignal\r\n    strategy.entry(\"Long\", strategy.long, qty=dynQty)\r\n    tradesToday += 1\r\n\r\nif shortEntrySignal\r\n    strategy.entry(\"Short\", strategy.short, qty=dynQty)\r\n    tradesToday += 1\r\n\r\n// ======================================================================\r\n// SL / TP â€“ ATR-ADAPTIVE WITH BASE\r\n// ======================================================================\r\natrSLpoints = math.max(slBasePoints, atr1H_series * atrSLFactor)\r\n\r\nif strategy.position_size > 0\r\n    longStop   = strategy.position_avg_price - atrSLpoints\r\n    longTarget = strategy.position_avg_price + tpPoints\r\n    strategy.exit(\"Long exit\", \"Long\", stop = longStop, limit = longTarget)\r\n\r\nif strategy.position_size < 0\r\n    shortStop   = strategy.position_avg_price + atrSLpoints\r\n    shortTarget = strategy.position_avg_price - tpPoints\r\n    strategy.exit(\"Short exit\", \"Short\", stop = shortStop, limit = shortTarget)\r\n\r\n// ======================================================================\r\n// TRAILING STATE VARIABLES\r\n// ======================================================================\r\nvar float maxProfitLong = 0.0\r\nvar float maxLossShort  = 0.0\r\n\r\nif strategy.position_size == 0\r\n    maxProfitLong := 0.0\r\n    maxLossShort  := 0.0\r\n\r\n// ======================================================================\r\n// STEPPED TRAILING PROFIT â€“ LONGS ONLY\r\n// ======================================================================\r\nif strategy.position_size > 0\r\n    curProfitLong = close - strategy.position_avg_price\r\n    maxProfitLong := math.max(maxProfitLong, curProfitLong)\r\n\r\n    condLong_100 = maxProfitLong >= 100 and curProfitLong <= 70\r\n    condLong_150 = maxProfitLong >= 150 and curProfitLong <= 110\r\n    condLong_200 = maxProfitLong >= 200 and curProfitLong <= 140\r\n    condLong_250 = maxProfitLong >= 250 and curProfitLong <= 180\r\n    condLong_320 = maxProfitLong >= 320 and curProfitLong <= 280\r\n\r\n    if condLong_100 or condLong_150 or condLong_200 or condLong_250 or condLong_320\r\n        strategy.close(\"Long\", comment = \"step_trail_long\")\r\n\r\n// ======================================================================\r\n// TRAILING LOSS â€“ SHORTS ONLY\r\n// ======================================================================\r\nif strategy.position_size < 0\r\n    curLossShort = math.max(0.0, close - strategy.position_avg_price)\r\n    maxLossShort := math.max(maxLossShort, curLossShort)\r\n\r\n    condShort_80  = maxLossShort >= 80  and curLossShort <= 40\r\n    condShort_120 = maxLossShort >= 120 and curLossShort <= 80\r\n    condShort_140 = maxLossShort >= 140 and curLossShort <= 100\r\n\r\n    if condShort_80 or condShort_120 or condShort_140\r\n        strategy.close(\"Short\", comment = \"step_trail_short_loss\")\r\n\r\n// ======================================================================\r\n// 1H EMA50 REVERSAL EXIT (2-BAR CONFIRMATION)\r\n// ======================================================================\r\nif strategy.position_size > 0 and close_1H < ema50_1H and close_1H[1] < ema50_1H\r\n    strategy.close(\"Long\", comment = \"1H_EMA50_short\")\r\n\r\nif strategy.position_size < 0 and close_1H > ema50_1H and close_1H[1] > ema50_1H\r\n    strategy.close(\"Short\", comment = \"1H_EMA50_long\")\r\n\r\n// ======================================================================\r\n// OPTIONAL EOD EXIT at 3:15 PM\r\n// ======================================================================\r\nif enableEODExit and cutoffTime and strategy.position_size != 0\r\n    strategy.close_all(comment = \"EOD_3_15\")\r\n\r\n// ======================================================================\r\n// ALERTS\r\n// ======================================================================\r\nalertcondition(longEntrySignal,  title=\"1H Long Entry\",  message=\"BUY: Nifty Breakout v7 Hybrid (Compounding)\")\r\nalertcondition(shortEntrySignal, title=\"1H Short Entry\", message=\"SELL: Nifty Breakout v7 Hybrid (Compounding)\")\r\n\r\nexitedLong  = strategy.position_size[1] > 0 and strategy.position_size == 0\r\nexitedShort = strategy.position_size[1] < 0 and strategy.position_size == 0\r\n\r\nalertcondition(exitedLong,  title=\"1H Long Exit\",  message=\"EXIT LONG: Nifty Breakout v7 Hybrid (Compounding)\")\r\nalertcondition(exitedShort, title=\"1H Short Exit\", message=\"EXIT SHORT: Nifty Breakout v7 Hybrid (Compounding)\")\r\n"
  },
  {
    "url": "6KjyWAjG-MTF-EMA-Hariss-369",
    "name": "MTF EMA Hariss 369",
    "description": "The strategy has been prepared in a simplistic manner and easy to understand the concept by any novice trader.\n\nIndicators used:\nCurrent Time frame 20 EMA- Gives clear look about current time frame dynamic support and resistance and trend as well.\n\nHigher Time Frame 20 EMA: Gives macro level trend, support and resistance\n\nKama: Capture volatility and trend direction.\n\nRVOL: Main factor of price movement.\n\nBuy when price closes above current time frame 20 ema and current time frame 20 ema is above higher time frame 20 ema. Stop loss just below the low of last candle. One can use current time frame 20 ema, higher time frame 20 ema or kama as stop loss depending upon type of asset class and risk appetite. The ideal way is to keep 20 ema as trailing sl if one wants to trail with trend.\n\nSell when price closes below current time frame 20 ema and current time frame 20 ema is lower than higher time frame 20 ema. Stop loss just above high of last candle.\n\nIdeal target is 1.5 or 2 times of stop loss. \n\nEntry and exit time depends on trading style. Eg. if you want to enter and exit in 5 min time frame, then choose 15 min or 1h as higher time frame as trend filter. Buy and sell signals are also plotted based on this strategy. One should always go with the higher time frame trend. Opting higher time frame trend filter always filters out market noises.",
    "image_url": "6KjyWAjG",
    "author": "Hariss369",
    "likes": 4,
    "type": "strategy",
    "created": "2025-11-26",
    "updated": "2025-11-26",
    "source": "//@version=5\nstrategy(\"MTF EMA Hariss 369\", overlay=true, margin_long=100, margin_short=100)\n\n// ================= INPUTS =================\nkamaLen       = input.int(21, \"KAMA Length\")\nfastLen       = input.int(2, \"KAMA Fast Length\")\nslowLen       = input.int(30, \"KAMA Slow Length\")\nemaLen        = input.int(20, \"EMA Length\")\nhtf           = input.timeframe(\"1D\", \"Higher Timeframe\")\nrvolThreshold = input.float(1.2, \"RVOL Threshold\")\n\n// ================= CUSTOM KAMA FUNCTION =================\nf_kama(_src, _len, _fast, _slow) =>\n    change = math.abs(_src - _src[1])\n    volatility = 0.0\n    for i = 0 to _len - 1\n        volatility += math.abs(_src[i] - _src[i+1])\n    er = volatility != 0 ? change / volatility : 0\n    sc = math.pow(er * (2/(_fast+1) - 2/(_slow+1)) + 2/(_slow+1), 2)\n    kama = 0.0\n    kama := na(kama[1]) ? _src : kama[1] + sc * (_src - kama[1])\n    kama\n\n// ================= INDICATORS =================\nprice    = close\nkama     = f_kama(price, kamaLen, fastLen, slowLen)\nema_tf   = ta.ema(price, emaLen)\nema_htf  = request.security(syminfo.tickerid, htf, ta.ema(close, emaLen))\n\nvolAvg = ta.sma(volume, 20)\nrvol   = volume / volAvg\n\n// ================= KAMA SLOPE =================\nkama_up   = kama > kama[1]\nkama_down = kama < kama[1]\n\n// ================= UPDATED CONDITIONS =================\nlongCond  = price > ema_tf and ema_tf > ema_htf and price > kama and rvol > rvolThreshold and kama_up\nshortCond = price < ema_tf and ema_tf < ema_htf and price < kama and rvol > rvolThreshold and kama_down\n\n// ================= STRATEGY ENTRIES =================\nif (longCond)\n    strategy.entry(\"Long\", strategy.long)\n\nif (shortCond)\n    strategy.entry(\"Short\", strategy.short)\n\n// ================= LABELS =================\nplotshape(longCond,  title=\"Buy\",  location=location.belowbar, color=color.green, style=shape.labelup,   size=size.tiny, text=\"BUY\")\nplotshape(shortCond, title=\"Sell\", location=location.abovebar, color=color.red,   style=shape.labeldown, size=size.tiny, text=\"SELL\")\n\n// ================= PLOTS =================\nplot(kama,      color=color.orange,  title=\"KAMA\",     linewidth=2)\nplot(ema_tf,    color=color.blue,    title=\"TF EMA\",   linewidth=2)\nplot(ema_htf,   color=color.purple,  title=\"HTF EMA\",  linewidth=3)\n"
  },
  {
    "url": "DelL6mHa-15m-ORB-Breakout-NAS100-5m-Mgmt-v6-Optimized",
    "name": "15m ORB Breakout NAS100 (5m Mgmt) v6 - Optimized",
    "description": "Opening Range Breakout Strategy\n\nBuy and sell signals are given upon break of market session opening range. Best utilized for 30 minute NY opening range, managed on 5 min timeframe on NAS100. Tweak the settings for higher win rate on backtesting dashboard before implementing strategy.",
    "image_url": "DelL6mHa",
    "author": "rasyad20",
    "likes": 22,
    "type": "strategy",
    "created": "2025-11-25",
    "updated": "2025-11-25",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// Â© rasyad20\r\n\r\n// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n//@version=6\r\nstrategy(\"15m ORB Breakout NAS100 (5m Mgmt) v6 - Optimized\",\r\n     overlay           = true,\r\n     initial_capital   = 10000,\r\n     default_qty_type  = strategy.percent_of_equity,\r\n     default_qty_value = 10,\r\n     commission_type   = strategy.commission.cash_per_contract,\r\n     commission_value  = 0,\r\n     calc_on_every_tick = false,\r\n     pyramiding        = 1,\r\n     margin_long       = 100,\r\n     margin_short      = 100)\r\n\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n// INPUTS\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n\r\nsymGroup   = \"Symbol / Timeframe\"\r\norbGroup   = \"ORB Settings\"\r\nfltGroup   = \"Filters (Win Rate)\"\r\nriskGroup  = \"Risk / Targets\"\r\nbtGroup    = \"Backtest Filter\"\r\nvisGroup   = \"Visuals\"\r\n\r\n// Symbol guard\r\nlimitSymbol   = input.bool(true, \"Limit to OANDA NAS100?\", group = symGroup)\r\nallowedSymbol = input.symbol(\"OANDA:NAS100USD\", \"Symbol\", group = symGroup)\r\n\r\n// Normalize ticker (avoids warning on syminfo.tickerid)\r\ncurrSymbol  = ticker.standard(syminfo.tickerid)\r\nallowSymbol = not limitSymbol or currSymbol == allowedSymbol\r\n\r\n// ORB settings (designed for 5m chart)\r\norbMinutes   = input.int(15, \"ORB Length (minutes)\", minval = 5, maxval = 60, group = orbGroup)\r\nbarsInORB    = math.max(1, math.round(orbMinutes / 5.0))\r\n\r\norbStartHour = input.int(9,  \"ORB Start Hour (0-23, exchange)\", minval = 0, maxval = 23, group = orbGroup)\r\norbStartMin  = input.int(30, \"ORB Start Minute (0-59)\",          minval = 0, maxval = 59, group = orbGroup)\r\n\r\n// Trend filter\r\nuseTrendFilter = input.bool(true, \"Use EMA Trend Filter?\", group = fltGroup)\r\nemaFastLen     = input.int(50,  \"Fast EMA Length\", minval = 5, maxval = 400, group = fltGroup)\r\nemaSlowLen     = input.int(200, \"Slow EMA Length\", minval = 10, maxval = 800, group = fltGroup)\r\n\r\n// ATR Volatility filter\r\nuseATRFilter   = input.bool(true, \"Use ATR Volatility Filter?\", group = fltGroup)\r\natrLen         = input.int(14,  \"ATR Length\",           minval = 5,  maxval = 200, group = fltGroup)\r\natrBaseLen     = input.int(200, \"ATR Baseline Length\",  minval = 50, maxval = 500, group = fltGroup)\r\natrThreshMult  = input.float(0.7, \"Min ATR / Baseline\", minval = 0.1, maxval = 2.0, step = 0.05, group = fltGroup)\r\n\r\n// Breakout behaviour\r\nuseCloseOutside = input.bool(true, \"Require Full Close Outside ORB?\", group = fltGroup)\r\nuseRetestEntry  = input.bool(true, \"Use Retest Entry (instead of raw breakout)?\", group = fltGroup)\r\n\r\n// Day filter (highest win rate: Wedâ€“Fri only by default)\r\nuseDayFilter = input.bool(true, \"Filter by Day of Week?\", group = fltGroup)\r\ntradeMon     = input.bool(false, \"Trade Monday?\",                        group = fltGroup)\r\ntradeTue     = input.bool(false, \"Trade Tuesday?\",                       group = fltGroup)\r\ntradeWed     = input.bool(true,  \"Trade Wednesday?\",                     group = fltGroup)\r\ntradeThu     = input.bool(true,  \"Trade Thursday?\",                      group = fltGroup)\r\ntradeFri     = input.bool(true,  \"Trade Friday?\",                        group = fltGroup)\r\n\r\n// Session filter\r\nuseSessionFilter = input.bool(true, \"Use Time Session Filter?\", group = fltGroup)\r\ntradeSession     = input.session(\"1430-1700\", \"Trade Session (exchange time)\", group = fltGroup)\r\n\r\n// Risk / Targets\r\nrangeStopMult   = input.float(1.0, \"Stop distance (x ORB range)\", minval = 0.1, maxval = 3.0, step = 0.1, group = riskGroup)\r\nuseDynamicTP    = input.bool(true,  \"Use ATR-based Take Profit?\", group = riskGroup)\r\nrr              = input.float(1.0, \"RR (TP multiple)\",            minval = 0.1, maxval = 5.0, step = 0.1, group = riskGroup)\r\natrTpLen        = input.int(14, \"ATR Length for TP\", minval = 5, maxval = 200, group = riskGroup)\r\n\r\n// Backtest filter\r\nconst int BT_START_DEF = timestamp(\"2025-05-01\")\r\nlimitBacktest = input.bool(true, \"Limit to recent period?\", group = btGroup)\r\nbtStart       = input.time(BT_START_DEF, \"Start date (exchange time)\", group = btGroup)\r\n\r\n// Visuals\r\nshowSignals   = input.bool(true, \"Show BUY/SELL signals\", group = visGroup)\r\nshowORB       = input.bool(true, \"Show ORB High/Low lines\", group = visGroup)\r\nshowDashboard = input.bool(true, \"Show Backtest Dashboard\", group = visGroup)\r\n\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n// TIME / SESSION / DAY FILTERS\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n\r\nallowTradingDate = not limitBacktest or time >= btStart\r\n\r\n// Day filter\r\nd = dayofweek\r\ndayOK =\r\n     not useDayFilter or\r\n     (d == dayofweek.monday    and tradeMon) or\r\n     (d == dayofweek.tuesday   and tradeTue) or\r\n     (d == dayofweek.wednesday and tradeWed) or\r\n     (d == dayofweek.thursday  and tradeThu) or\r\n     (d == dayofweek.friday    and tradeFri)\r\n\r\n// Session filter: true if inside session, or filter disabled\r\nsessionOK = not useSessionFilter or not na(time(timeframe.period, tradeSession))\r\n\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n// ORB BUILD (15m from custom start time)\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n\r\n// Detect new day\r\nisNewDay = ta.change(time(\"D\")) != 0\r\n\r\n// Current bar time (exchange)\r\ncurrHour = hour(time)\r\ncurrMin  = minute(time)\r\nisORBStartBar = currHour == orbStartHour and currMin == orbStartMin\r\n\r\nvar float orbHigh  = na\r\nvar float orbLow   = na\r\nvar bool  orbReady = false\r\nvar int   orbCount = 0\r\n\r\n// Reset each new day\r\nif isNewDay\r\n    orbHigh  := na\r\n    orbLow   := na\r\n    orbCount := 0\r\n    orbReady := false\r\n\r\n// Build ORB window from custom time (15m = barsInORB * 5m)\r\nif isORBStartBar\r\n    orbHigh  := high\r\n    orbLow   := low\r\n    orbCount := 1\r\n    orbReady := false\r\nelse if orbCount > 0 and not orbReady\r\n    if orbCount < barsInORB\r\n        orbHigh  := math.max(orbHigh, high)\r\n        orbLow   := math.min(orbLow,  low)\r\n        orbCount += 1\r\n    if orbCount >= barsInORB\r\n        orbReady := true\r\n\r\norbRange = orbReady ? (orbHigh - orbLow) : na\r\n\r\n// Plot ORB levels\r\nplot(showORB and orbReady ? orbHigh : na, \"ORB High\", color = color.new(color.lime, 0), linewidth = 2, style = plot.style_stepline)\r\nplot(showORB and orbReady ? orbLow  : na, \"ORB Low\",  color = color.new(color.red,  0), linewidth = 2, style = plot.style_stepline)\r\n\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n// INDICATORS: TREND + VOLATILITY\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n\r\nemaFast = ta.ema(close, emaFastLen)\r\nemaSlow = ta.ema(close, emaSlowLen)\r\ntrendLong  = emaFast > emaSlow\r\ntrendShort = emaFast < emaSlow\r\n\r\nplot(useTrendFilter ? emaFast : na, \"Fast EMA\", color = color.new(color.orange, 0))\r\nplot(useTrendFilter ? emaSlow : na, \"Slow EMA\", color = color.new(color.blue,   0))\r\n\r\natr      = ta.atr(atrLen)\r\natrBase  = ta.sma(atr, atrBaseLen)\r\natrFilt  = not useATRFilter or (atrBase > 0 and atr > atrBase * atrThreshMult)\r\n\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n// RETEST STATE\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n\r\nvar bool brokeUp = false\r\nvar bool brokeDn = false\r\n\r\nif isORBStartBar\r\n    brokeUp := false\r\n    brokeDn := false\r\n\r\nif orbReady and not na(orbHigh) and not na(orbLow)\r\n    if close > orbHigh\r\n        brokeUp := true\r\n    if close < orbLow\r\n        brokeDn := true\r\n\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n// ENTRY CONDITIONS\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n\r\nbaseOK = orbReady and allowTradingDate and allowSymbol and dayOK and sessionOK and atrFilt and not na(orbRange) and orbRange > 0\r\n\r\n// Raw breakout\r\nbool breakoutLong  = baseOK and close > orbHigh\r\nbool breakoutShort = baseOK and close < orbLow\r\n\r\n// Close fully outside ORB if enabled\r\nif useCloseOutside\r\n    breakoutLong  := baseOK and close > orbHigh and low  > orbHigh\r\n    breakoutShort := baseOK and close < orbLow  and high < orbLow\r\n\r\n// Retest entry logic\r\nretestLong  = baseOK and brokeUp and ta.crossover(close, orbHigh)\r\nretestShort = baseOK and brokeDn and ta.crossunder(close, orbLow)\r\n\r\n// Choose trigger: retest or raw breakout\r\nentryLongTrigger  = useRetestEntry ? retestLong  : breakoutLong\r\nentryShortTrigger = useRetestEntry ? retestShort : breakoutShort\r\n\r\n// Apply trend filter last\r\nif useTrendFilter\r\n    entryLongTrigger  := entryLongTrigger  and trendLong\r\n    entryShortTrigger := entryShortTrigger and trendShort\r\n\r\n// One trade per direction per day\r\nvar bool longDoneToday  = false\r\nvar bool shortDoneToday = false\r\n\r\nif isNewDay\r\n    longDoneToday  := false\r\n    shortDoneToday := false\r\n\r\nentryLong  = entryLongTrigger  and not longDoneToday  and strategy.position_size <= 0\r\nentryShort = entryShortTrigger and not shortDoneToday and strategy.position_size >= 0\r\n\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n// STOPS & TARGETS\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n\r\nfloat longSL  = na\r\nfloat longTP  = na\r\nfloat shortSL = na\r\nfloat shortTP = na\r\n\r\natrTP = ta.atr(atrTpLen)\r\n\r\nif orbReady and not na(orbRange) and orbRange > 0\r\n    // Stops based on ORB range\r\n    longSL  := orbHigh - orbRange * rangeStopMult\r\n    shortSL := orbLow  + orbRange * rangeStopMult\r\n\r\n    if useDynamicTP\r\n        // ATR-based TP (higher hit rate)\r\n        longTP  := close + atrTP * rr\r\n        shortTP := close - atrTP * rr\r\n    else\r\n        // Range/RR-based TP\r\n        longTP  := orbHigh + orbRange * rangeStopMult * rr\r\n        shortTP := orbLow  - orbRange * rangeStopMult * rr\r\n\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n// ORDERS\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n\r\nif entryLong and not na(longSL) and not na(longTP)\r\n    strategy.entry(\"Long\", strategy.long, comment = \"ORB Long\")\r\n    longDoneToday := true\r\n\r\nif entryShort and not na(shortSL) and not na(shortTP)\r\n    strategy.entry(\"Short\", strategy.short, comment = \"ORB Short\")\r\n    shortDoneToday := true\r\n\r\n// Attach exits while in position\r\nif strategy.position_size > 0 and not na(longSL) and not na(longTP)\r\n    strategy.exit(\"Long Exit\", \"Long\", stop = longSL, limit = longTP)\r\n\r\nif strategy.position_size < 0 and not na(shortSL) and not na(shortTP)\r\n    strategy.exit(\"Short Exit\", \"Short\", stop = shortSL, limit = shortTP)\r\n\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n// CHART SIGNALS\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n\r\nplotshape(showSignals and entryLong,  title = \"BUY\",  style = shape.triangleup,\r\n     location = location.belowbar, color = color.lime, text = \"BUY\",  size = size.tiny)\r\n\r\nplotshape(showSignals and entryShort, title = \"SELL\", style = shape.triangledown,\r\n     location = location.abovebar, color = color.red,  text = \"SELL\", size = size.tiny)\r\n\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n// BACKTEST DASHBOARD\r\n//â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\r\n\r\nvar table dash = table.new(position.top_right, 2, 6, border_width = 1)\r\n\r\nif showDashboard and barstate.islastconfirmedhistory\r\n    float trades    = strategy.closedtrades\r\n    float wins      = strategy.wintrades\r\n    float losses    = strategy.losstrades\r\n    float netProfit = strategy.netprofit\r\n    float winRate   = trades > 0 ? (wins / trades) * 100.0 : na\r\n    float avgTrade  = trades > 0 ? (netProfit / trades) : na\r\n\r\n    table.cell(dash, 0, 0, \"15m ORB NAS100 (Optimized)\", text_color = color.white, bgcolor = color.new(color.blue, 65))\r\n    table.cell(dash, 1, 0, \"\",                            bgcolor = color.new(color.blue, 65))\r\n\r\n    table.cell(dash, 0, 1, \"Closed trades\")\r\n    table.cell(dash, 1, 1, str.tostring(trades, \"#\"))\r\n\r\n    table.cell(dash, 0, 2, \"Win rate %\")\r\n    table.cell(dash, 1, 2, na(winRate) ? \"n/a\" : str.tostring(winRate, \"#.0\"))\r\n\r\n    table.cell(dash, 0, 3, \"Wins / Losses\")\r\n    table.cell(dash, 1, 3, str.tostring(wins, \"#\") + \" / \" + str.tostring(losses, \"#\"))\r\n\r\n    table.cell(dash, 0, 4, \"Net profit\")\r\n    table.cell(dash, 1, 4, str.tostring(netProfit, \"#.0\"))\r\n\r\n    table.cell(dash, 0, 5, \"Avg / trade\")\r\n    table.cell(dash, 1, 5, na(avgTrade) ? \"n/a\" : str.tostring(avgTrade, \"#.1\"))\r\n\r\n"
  },
  {
    "url": "x2R8o3xU-SuperTrend-AI-Strategy",
    "name": "SuperTrend AI Strategy",
    "description": "A Simple strategy tests for SuperTrend AI indicator",
    "image_url": "x2R8o3xU",
    "author": "vishnyo",
    "likes": 35,
    "type": "strategy",
    "created": "2025-11-29",
    "updated": "2025-11-29",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// Â© vishnyo\r\n// Based on SuperTrend AI (Clustering) [LuxAlgo] Indicator\r\n\r\n//@version=6\r\nstrategy(\"SuperTrend AI Strategy\", overlay=true, initial_capital = 10000, default_qty_type = strategy.percent_of_equity, default_qty_value = 10)\r\n\r\n//------------------------------------------------------------------------------\r\n//Settings\r\n//-----------------------------------------------------------------------------\r\nlength = input.int(10, 'ATR Length', group = 'SuperTrend AI')\r\n\r\nminMult = input.int(1, 'Factor Range', minval = 0, inline = 'factor', group = 'SuperTrend AI')\r\nmaxMult = input.int(5, '', minval = 0, inline = 'factor', group = 'SuperTrend AI')\r\nstep    = input.float(.5, 'Step', minval = 0, step = 0.1, group = 'SuperTrend AI')\r\n\r\n//Trigger error\r\nif minMult > maxMult\r\n    runtime.error('Minimum factor is greater than maximum factor in the range')\r\n\r\nperfAlpha = input.float(10, 'Performance Memory', minval = 2, group = 'SuperTrend AI')\r\nfromCluster = input.string('Best', 'From Cluster', options = ['Best', 'Average', 'Worst'], group = 'SuperTrend AI')\r\n\r\n//Optimization\r\nmaxIter = input.int(1000, 'Maximum Iteration Steps', minval = 0, group = 'Optimization')\r\nmaxData = input.int(10000, 'Historical Bars Calculation', minval = 0, group = 'Optimization')\r\n\r\n//Strategy Settings\r\nenterOnSameCandle = input.bool(true, 'Enter on Same Candle as Close', group = 'Strategy', tooltip = \"If enabled, enter new position on same candle after closing previous one. If disabled, enter on third candle.\")\r\nuseTrailingStop = input.bool(false, 'Use Trailing Stop for Exit', group = 'Strategy')\r\nuseAMAExit = input.bool(false, 'Use AMA for Exit', group = 'Strategy')\r\nenableLongs = input.bool(true, 'Enable Long Positions', group = 'Strategy')\r\nenableShorts = input.bool(true, 'Enable Short Positions', group = 'Strategy')\r\n\r\n//-----------------------------------------------------------------------------\r\n//UDT's\r\n//-----------------------------------------------------------------------------\r\ntype supertrend\r\n    float upper = hl2\r\n    float lower = hl2\r\n    float output\r\n    float perf = 0\r\n    float factor\r\n    int trend = 0\r\n\r\ntype vector\r\n    array<float> out\r\n\r\n//-----------------------------------------------------------------------------\r\n//Supertrend\r\n//-----------------------------------------------------------------------------\r\nvar holder = array.new<supertrend>(0)\r\nvar factors = array.new<float>(0)\r\n\r\n//Populate supertrend type array\r\nif barstate.isfirst\r\n    for i = 0 to int((maxMult - minMult) / step)\r\n        factors.push(minMult + i * step)\r\n        holder.push(supertrend.new())\r\n\r\natr = ta.atr(length)\r\n\r\n//Compute Supertrend for multiple factors\r\nk = 0\r\nfor factor in factors\r\n    get_spt = holder.get(k)\r\n\r\n    up = hl2 + atr * factor\r\n    dn = hl2 - atr * factor\r\n    \r\n    get_spt.trend := close > get_spt.upper ? 1 : close < get_spt.lower ? 0 : get_spt.trend\r\n    get_spt.upper := close[1] < get_spt.upper ? math.min(up, get_spt.upper) : up\r\n    get_spt.lower := close[1] > get_spt.lower ? math.max(dn, get_spt.lower) : dn\r\n    \r\n    diff = nz(math.sign(close[1] - get_spt.output))\r\n    get_spt.perf += 2/(perfAlpha+1) * (nz(close - close[1]) * diff - get_spt.perf)\r\n    get_spt.output := get_spt.trend == 1 ? get_spt.lower : get_spt.upper\r\n    get_spt.factor := factor\r\n    k += 1\r\n\r\n//-----------------------------------------------------------------------------\r\n//K-means clustering\r\n//-----------------------------------------------------------------------------\r\nfactor_array = array.new<float>(0)\r\ndata = array.new<float>(0)\r\n\r\n//Populate data arrays\r\nif last_bar_index - bar_index <= maxData\r\n    for element in holder\r\n        data.push(element.perf)\r\n        factor_array.push(element.factor)\r\n\r\n//Intitalize centroids using quartiles\r\ncentroids = array.new<float>(0)\r\nif data.size() > 0\r\n    centroids.push(data.percentile_linear_interpolation(25))\r\n    centroids.push(data.percentile_linear_interpolation(50))\r\n    centroids.push(data.percentile_linear_interpolation(75))\r\n\r\n//Intialize clusters\r\nvar array<vector> factors_clusters = na\r\nvar array<vector> perfclusters = na\r\n\r\nif last_bar_index - bar_index <= maxData and data.size() > 0\r\n    for _ = 0 to maxIter\r\n        factors_clusters := array.from(vector.new(array.new<float>(0)), vector.new(array.new<float>(0)), vector.new(array.new<float>(0)))\r\n        perfclusters := array.from(vector.new(array.new<float>(0)), vector.new(array.new<float>(0)), vector.new(array.new<float>(0)))\r\n        \r\n        //Assign value to cluster\r\n        i = 0\r\n        for value in data\r\n            dist = array.new<float>(0)\r\n            for centroid in centroids\r\n                dist.push(math.abs(value - centroid))\r\n\r\n            idx = dist.indexof(dist.min())\r\n            perfclusters.get(idx).out.push(value)\r\n            factors_clusters.get(idx).out.push(factor_array.get(i))\r\n            i += 1\r\n\r\n        //Update centroids\r\n        new_centroids = array.new<float>(0)\r\n        for cluster_ in perfclusters\r\n            new_centroids.push(cluster_.out.avg())\r\n\r\n        //Test if centroid changed\r\n        if new_centroids.get(0) == centroids.get(0) and new_centroids.get(1) == centroids.get(1) and new_centroids.get(2) == centroids.get(2)\r\n            break\r\n\r\n        centroids := new_centroids\r\n\r\n//-----------------------------------------------------------------------------\r\n//Signals and trailing stop\r\n//-----------------------------------------------------------------------------\r\n//Get associated supertrend\r\nvar float target_factor = na\r\nvar float perf_idx = na\r\nvar float perf_ama = na\r\n\r\nvar from = switch fromCluster\r\n    'Best' => 2\r\n    'Average' => 1\r\n    'Worst' => 0\r\n\r\n//Performance index denominator\r\nden = ta.ema(math.abs(close - close[1]), int(perfAlpha))\r\n\r\nif not na(perfclusters)\r\n    //Get average factors within target cluster \r\n    target_factor := nz(factors_clusters.get(from).out.avg(), target_factor)\r\n    \r\n    //Get performance index of target cluster \r\n    perf_idx := math.max(nz(perfclusters.get(from).out.avg()), 0) / den\r\n\r\n//Get new supertrend\r\nvar upper = hl2\r\nvar lower = hl2\r\nvar os = 0\r\n\r\nup = hl2 + atr * target_factor\r\ndn = hl2 - atr * target_factor\r\nupper := close[1] < upper ? math.min(up, upper) : up\r\nlower := close[1] > lower ? math.max(dn, lower) : dn\r\nos := close > upper ? 1 : close < lower ? 0 : os\r\nts = os == 1 ? lower : upper\r\n\r\n//Get trailing stop adaptive MA\r\nif na(ts[1]) and not na(ts)\r\n    perf_ama := ts\r\nelse\r\n    perf_ama += perf_idx * (ts - perf_ama)\r\n\r\n//-----------------------------------------------------------------------------\r\n//Strategy Logic\r\n//-----------------------------------------------------------------------------\r\n//Entry signals\r\nlongCondition = os > os[1]  // Trend changes to bullish\r\nshortCondition = os < os[1]  // Trend changes to bearish\r\n\r\n//Exit signals\r\nlongExitCondition = useAMAExit ? close < perf_ama : os < os[1]  // Exit long on trend reversal or AMA cross\r\nshortExitCondition = useAMAExit ? close > perf_ama : os > os[1]  // Exit short on trend reversal or AMA cross\r\n\r\n//Track the bar index when position was opened\r\nvar int longOpenedBar = -1\r\nvar int shortOpenedBar = -1\r\n//Track entry prices for P&L calculation\r\nvar float longEntryPrice = na\r\nvar float shortEntryPrice = na\r\n\r\n//3-bar sequence tracking:\r\n//Bar 1: Trend changes (detected on close) â†’ set exit flag for next bar OR enter flag if no position\r\n//Bar 2: Exit position (if exit flag is set) OR Enter position (if no position and enter flag is set)\r\n//Bar 3: Enter new position (if exit happened on bar 2)\r\nvar bool exitLongNextBar = false  // Flag to exit Long on next bar\r\nvar bool exitShortNextBar = false  // Flag to exit Short on next bar\r\nvar bool enterLongOnSecondBar = false  // Flag to enter Long on second bar (no position case)\r\nvar bool enterShortOnSecondBar = false  // Flag to enter Short on second bar (no position case)\r\nvar bool enterLongOnThirdBar = false  // Flag to enter Long on third bar\r\nvar bool enterShortOnThirdBar = false  // Flag to enter Short on third bar\r\nvar bool justClosedLong = false  // Track if we just closed Long on this bar\r\nvar bool justClosedShort = false  // Track if we just closed Short on this bar\r\n\r\n//3-bar sequence: Trend change â†’ Exit â†’ Enter\r\nif barstate.isconfirmed\r\n    //Bar 1: Detect trend change on candle close (only verified on close)\r\n    trendChangedToBearish = shortCondition  // os < os[1] - trend changes to bearish\r\n    trendChangedToBullish = longCondition  // os > os[1] - trend changes to bullish\r\n    \r\n    //If trend changes and position exists, set exit flag for next bar (Bar 2)\r\n    if trendChangedToBearish and strategy.position_size > 0 and longOpenedBar != bar_index\r\n        exitLongNextBar := true  // Will exit Long on next bar\r\n    \r\n    if trendChangedToBullish and strategy.position_size < 0 and shortOpenedBar != bar_index\r\n        exitShortNextBar := true  // Will exit Short on next bar\r\n    \r\n    //If trend changes and NO position exists, set enter flag for next bar (Bar 2)\r\n    if trendChangedToBullish and strategy.position_size == 0 and enableLongs\r\n        enterLongOnSecondBar := true  // Will enter Long on next bar\r\n    \r\n    if trendChangedToBearish and strategy.position_size == 0 and enableShorts\r\n        enterShortOnSecondBar := true  // Will enter Short on next bar\r\n    \r\n    //Bar 2: Exit position OR Enter position (if no position existed)\r\n    //Reset flags at start of each bar\r\n    justClosedLong := false\r\n    justClosedShort := false\r\n    \r\n    //Exit Long if flag is set (trend changed to bearish on previous bar)\r\n    if exitLongNextBar and strategy.position_size > 0 and longOpenedBar != bar_index\r\n        //Calculate profit/loss\r\n        pnl = not na(longEntryPrice) ? (close - longEntryPrice) / longEntryPrice * 100 : 0\r\n        pnlText = pnl >= 0 ? \"+\" + str.tostring(pnl, \"#.##\") + \"%\" : str.tostring(pnl, \"#.##\") + \"%\"\r\n        pnlColor = pnl >= 0 ? color.green : color.red\r\n        \r\n        strategy.close(\"Long\", comment = \"Exit Long\")\r\n        longOpenedBar := -1\r\n        longEntryPrice := na  // Reset entry price\r\n        exitLongNextBar := false\r\n        justClosedLong := true  // Track that we just closed Long\r\n        \r\n        //Show P&L label\r\n        label.new(bar_index, high, \"Exit Long\\n\" + pnlText, style = label.style_label_down, color = pnlColor, textcolor = color.white, size = size.small)\r\n        \r\n        //If same-candle entry is enabled, enter Short immediately after close\r\n        if enterOnSameCandle and os == 0 and enableShorts\r\n            strategy.entry(\"Short\", strategy.short, comment = \"Enter Short\")\r\n            shortOpenedBar := bar_index\r\n            shortEntryPrice := close  // Track entry price\r\n            justClosedLong := false  // Reset since we entered\r\n            enterShortOnThirdBar := false  // Prevent Bar 3 entry since we already entered\r\n        else if enableShorts\r\n            enterShortOnThirdBar := true  // Set flag to enter Short on third bar\r\n    \r\n    //Exit Short if flag is set (trend changed to bullish on previous bar)\r\n    if exitShortNextBar and strategy.position_size < 0 and shortOpenedBar != bar_index\r\n        //Calculate profit/loss\r\n        pnl = not na(shortEntryPrice) ? (shortEntryPrice - close) / shortEntryPrice * 100 : 0\r\n        pnlText = pnl >= 0 ? \"+\" + str.tostring(pnl, \"#.##\") + \"%\" : str.tostring(pnl, \"#.##\") + \"%\"\r\n        pnlColor = pnl >= 0 ? color.green : color.red\r\n        \r\n        strategy.close(\"Short\", comment = \"Exit Short\")\r\n        shortOpenedBar := -1\r\n        shortEntryPrice := na  // Reset entry price\r\n        exitShortNextBar := false\r\n        justClosedShort := true  // Track that we just closed Short\r\n        \r\n        //Show P&L label\r\n        label.new(bar_index, low, \"Exit Short\\n\" + pnlText, style = label.style_label_up, color = pnlColor, textcolor = color.white, size = size.small)\r\n        \r\n        //If same-candle entry is enabled, enter Long immediately after close\r\n        if enterOnSameCandle and os == 1 and enableLongs\r\n            strategy.entry(\"Long\", strategy.long, comment = \"Enter Long\")\r\n            longOpenedBar := bar_index\r\n            longEntryPrice := close  // Track entry price\r\n            justClosedShort := false  // Reset since we entered\r\n            enterLongOnThirdBar := false  // Prevent Bar 3 entry since we already entered\r\n        else if enableLongs\r\n            enterLongOnThirdBar := true  // Set flag to enter Long on third bar\r\n    \r\n    //Enter Long on second bar if no position existed and trend changed to bullish\r\n    if enterLongOnSecondBar and strategy.position_size == 0 and os == 1 and enableLongs\r\n        strategy.entry(\"Long\", strategy.long, comment = \"Enter Long\")\r\n        longOpenedBar := bar_index\r\n        longEntryPrice := close  // Track entry price\r\n        enterLongOnSecondBar := false\r\n    \r\n    //Enter Short on second bar if no position existed and trend changed to bearish\r\n    if enterShortOnSecondBar and strategy.position_size == 0 and os == 0 and enableShorts\r\n        strategy.entry(\"Short\", strategy.short, comment = \"Enter Short\")\r\n        shortOpenedBar := bar_index\r\n        shortEntryPrice := close  // Track entry price\r\n        enterShortOnSecondBar := false\r\n    \r\n    //Bar 3: Enter new position on third candle after trend change (only if same-candle entry is disabled)\r\n    //Enter Long on third bar if exit happened on bar 2 and trend is still bullish\r\n    if enterLongOnThirdBar and strategy.position_size == 0 and os == 1 and enableLongs\r\n        strategy.entry(\"Long\", strategy.long, comment = \"Enter Long\")\r\n        longOpenedBar := bar_index\r\n        longEntryPrice := close  // Track entry price\r\n        enterLongOnThirdBar := false\r\n    \r\n    //Enter Short on third bar if exit happened on bar 2 and trend is still bearish\r\n    if enterShortOnThirdBar and strategy.position_size == 0 and os == 0 and enableShorts\r\n        strategy.entry(\"Short\", strategy.short, comment = \"Enter Short\")\r\n        shortOpenedBar := bar_index\r\n        shortEntryPrice := close  // Track entry price\r\n        enterShortOnThirdBar := false\r\n\r\n//Trailing stop exit - only on confirmed bars, and not if position was just opened\r\nif useTrailingStop and barstate.isconfirmed\r\n    if strategy.position_size > 0 and longOpenedBar != bar_index\r\n        strategy.exit(\"Long Exit\", \"Long\", stop = ts, comment = \"Trailing Stop\")\r\n    if strategy.position_size < 0 and shortOpenedBar != bar_index\r\n        strategy.exit(\"Short Exit\", \"Short\", stop = ts, comment = \"Trailing Stop\")\r\n\r\n//-----------------------------------------------------------------------------\r\n//Plots\r\n//-----------------------------------------------------------------------------\r\ncss = os == 1 ? color.teal : color.red\r\n\r\nplot(ts, 'Trailing Stop', os != os[1] ? na : css, linewidth = 2)\r\n\r\nplot(perf_ama, 'Trailing Stop AMA',\r\n  ta.cross(close, perf_ama) ? na\r\n  : close > perf_ama ? color.new(color.teal, 50) : color.new(color.red, 50), linewidth = 1)\r\n\r\n//Plot entry/exit signals\r\nplotshape(longCondition, style = shape.triangleup, location = location.belowbar, color = color.green, size = size.small, title = \"Long Entry\")\r\nplotshape(shortCondition, style = shape.triangledown, location = location.abovebar, color = color.red, size = size.small, title = \"Short Entry\")\r\n\r\n"
  },
  {
    "url": "xrYxpz2j-Order-Flow-Momentum",
    "name": "Order Flow Momentum ",
    "description": "just try it you will not regret only for zone traderts not lines ",
    "image_url": "xrYxpz2j",
    "author": "roydavidi2004",
    "likes": 21,
    "type": "strategy",
    "created": "2025-11-25",
    "updated": "2025-11-25",
    "source": "//@version=6\r\nstrategy(\"Order Flow Momentum EURUSD\",\r\n     overlay = true,\r\n     initial_capital = 10000,\r\n     commission_type = strategy.commission.cash_per_contract,\r\n     commission_value = 0.0,\r\n     pyramiding = 0,\r\n     calc_on_every_tick = false,\r\n     calc_on_order_fills = true,\r\n     process_orders_on_close = true)\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// INPUTS\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\ntf_htf        = input.timeframe(\"240\",  \"Higher TF (context - 4H)\")\r\nriskPerc      = input.float(1.0, \"Risk % per trade\", step = 0.1, minval = 0.1, maxval = 5)\r\naccountSize   = input.float(10000, \"Account size (for position size calc)\")\r\nrrBase        = input.float(2.0, \"Base RR (TP1)\", minval = 1.0, maxval = 5.0)\r\nuseLongs      = input.bool(true,  \"Enable LONGs\")\r\nuseShorts     = input.bool(true,  \"Enable SHORTs\")\r\nimpulseAtrMul = input.float(1.2, \"Impulse min ATR multiple\", minval = 0.5, maxval = 5.0)\r\nlookbackBars  = input.int(5, \"Lookback bars for impulse origin\", minval = 2, maxval = 20)\r\nsessionStart  = input.session(\"0000-2359\", \"Trading session (exchange time)\")\r\nshowInfo      = input.bool(true, \"Show info panel\")\r\nshowZones     = input.bool(true, \"Show Supply/Demand Zones\")\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// TIME FILTER\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\ninSession = not na(time(timeframe.period, sessionStart))\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// HTF CONTEXT (4H)\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nhtfClose  = request.security(syminfo.tickerid, tf_htf, close, lookahead = barmerge.lookahead_off)\r\nhtfHigh   = request.security(syminfo.tickerid, tf_htf, high, lookahead = barmerge.lookahead_off)\r\nhtfLow    = request.security(syminfo.tickerid, tf_htf, low, lookahead = barmerge.lookahead_off)\r\n\r\n// BOS - ×©×‘×™×¨×ª high/low ××—×¨×•×Ÿ\r\nbosLen = 5\r\nhtfHH  = ta.highest(htfHigh, bosLen)\r\nhtfLL  = ta.lowest(htfLow, bosLen)\r\n\r\nbosUp   = htfClose > htfHH[1]\r\nbosDown = htfClose < htfLL[1]\r\n\r\n// ×›×™×•×•×Ÿ ×ž×•×ž× ×˜×•× HTF\r\nvar int htfTrend = 0\r\nif bosUp\r\n    htfTrend := 1\r\nelse if bosDown\r\n    htfTrend := -1\r\n\r\ntrendUp   = htfTrend == 1\r\ntrendDown = htfTrend == -1\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// SUPPLY / DEMAND ZONES\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\natr = ta.atr(14)\r\n\r\n// ××™×ž×¤×•×œ×¡ - × ×¨ ×—×–×§\r\nimpulseUp   = (close - open) > atr * impulseAtrMul and close > open\r\nimpulseDown = (open - close) > atr * impulseAtrMul and open > close\r\n\r\n// ××–×•×¨×™ ×‘×™×§×•×© ×•×¡×™×¤×•×§\r\nvar float demandLow  = na\r\nvar float demandHigh = na\r\nvar float supplyLow  = na\r\nvar float supplyHigh = na\r\nvar int demandBar = 0\r\nvar int supplyBar = 0\r\n\r\n// ×–×™×”×•×™ ××–×•×¨ ×‘×™×§×•×© (DEMAND)\r\nif impulseUp and trendUp\r\n    float tmpLow  = low\r\n    float tmpHigh = high\r\n    for i = 1 to lookbackBars\r\n        if close[i] < open[i]\r\n            tmpLow  := math.min(tmpLow, low[i])\r\n            tmpHigh := math.max(tmpHigh, high[i])\r\n            break\r\n    demandLow  := tmpLow\r\n    demandHigh := tmpHigh\r\n    demandBar  := bar_index\r\n\r\n// ×–×™×”×•×™ ××–×•×¨ ×¡×™×¤×•×§ (SUPPLY)\r\nif impulseDown and trendDown\r\n    float tmpLow2  = low\r\n    float tmpHigh2 = high\r\n    for i = 1 to lookbackBars\r\n        if close[i] > open[i]\r\n            tmpLow2  := math.min(tmpLow2, low[i])\r\n            tmpHigh2 := math.max(tmpHigh2, high[i])\r\n            break\r\n    supplyLow  := tmpLow2\r\n    supplyHigh := tmpHigh2\r\n    supplyBar  := bar_index\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// DRAW ZONES - ×ª×™×‘×•×ª ×¦×‘×¢×•× ×™×•×ª\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nif showZones\r\n    if not na(demandLow) and not na(demandHigh) and bar_index - demandBar < 100\r\n        box.new(demandBar, demandLow, bar_index + 10, demandHigh, bgcolor = color.new(color.teal, 85), border_color = color.new(color.teal, 0), border_width = 2)\r\n    \r\n    if not na(supplyLow) and not na(supplyHigh) and bar_index - supplyBar < 100\r\n        box.new(supplyBar, supplyLow, bar_index + 10, supplyHigh, bgcolor = color.new(color.red, 85), border_color = color.new(color.red, 0), border_width = 2)\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// ENTRY LOGIC\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n\r\n// LONG: ×ž×—×™×¨ ×‘××–×•×¨ ×‘×™×§×•×© + ×˜×¨× ×“ UP\r\ninDemand = not na(demandLow) and low <= demandHigh and high >= demandLow\r\nlongCond = useLongs and inSession and trendUp and inDemand\r\n\r\n// SHORT: ×ž×—×™×¨ ×‘××–×•×¨ ×¡×™×¤×•×§ + ×˜×¨× ×“ DOWN  \r\ninSupply = not na(supplyLow) and low <= supplyHigh and high >= supplyLow\r\nshortCond = useShorts and inSession and trendDown and inSupply\r\n\r\n// ×ž×—×™×¨×™ ×›× ×™×¡×”\r\nlongEntryPrice  = inDemand and not na(demandLow) and not na(demandHigh) ? (demandLow + demandHigh) / 2.0 : close\r\nshortEntryPrice = inSupply and not na(supplyLow) and not na(supplyHigh) ? (supplyLow + supplyHigh) / 2.0 : close\r\n\r\n// SL & TP\r\nlongSL  = not na(demandLow)  ? demandLow  - atr * 0.5 : close - atr * 2\r\nshortSL = not na(supplyHigh) ? supplyHigh + atr * 0.5 : close + atr * 2\r\n\r\nlongTP  = longEntryPrice  + (longEntryPrice  - longSL)  * rrBase\r\nshortTP = shortEntryPrice - (shortSL - shortEntryPrice) * rrBase\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// POSITION SIZING\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\ncapital     = accountSize\r\nmaxRiskCash = capital * (riskPerc / 100.0)\r\n\r\nlongRiskPerUnit  = math.abs(longEntryPrice - longSL) * syminfo.pointvalue\r\nshortRiskPerUnit = math.abs(shortEntryPrice - shortSL) * syminfo.pointvalue\r\n\r\nlongQty  = longRiskPerUnit  > 0 ? maxRiskCash / longRiskPerUnit  : 0.01\r\nshortQty = shortRiskPerUnit > 0 ? maxRiskCash / shortRiskPerUnit : 0.01\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// STRATEGY ORDERS\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nvar bool inTrade = false\r\n\r\nif strategy.position_size == 0\r\n    inTrade := false\r\n\r\n// LONG ENTRY\r\nif longCond and not inTrade\r\n    inTrade := true\r\n    strategy.entry(\"LONG\", strategy.long, qty = longQty)\r\n    strategy.exit(\"LONG EXIT\", \"LONG\", stop = longSL, limit = longTP)\r\n\r\n// SHORT ENTRY\r\nif shortCond and not inTrade\r\n    inTrade := true\r\n    strategy.entry(\"SHORT\", strategy.short, qty = shortQty)\r\n    strategy.exit(\"SHORT EXIT\", \"SHORT\", stop = shortSL, limit = shortTP)\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// VISUAL SIGNALS\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nplotshape(longCond and not inTrade, title = \"Long Signal\", style = shape.triangleup, size = size.small, location = location.belowbar, color = color.new(color.lime, 0))\r\n\r\nplotshape(shortCond and not inTrade, title = \"Short Signal\", style = shape.triangledown, size = size.small, location = location.abovebar, color = color.new(color.red, 0))\r\n\r\n// SL & TP LINES\r\nplot(strategy.position_size > 0 ? longSL : strategy.position_size < 0 ? shortSL : na, \"Stop Loss\", color = color.new(color.red, 0), style = plot.style_linebr, linewidth = 2)\r\n\r\nplot(strategy.position_size > 0 ? longTP : strategy.position_size < 0 ? shortTP : na, \"Take Profit\", color = color.new(color.lime, 0), style = plot.style_linebr, linewidth = 2)\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// INFO PANEL\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nif showInfo and barstate.islast\r\n    string trendText = trendUp ? \"UP\" : trendDown ? \"DOWN\" : \"NEUTRAL\"\r\n    string demandText = inDemand ? \"YES\" : \"NO\"\r\n    string supplyText = inSupply ? \"YES\" : \"NO\"\r\n    \r\n    var table infoTable = table.new(position.top_right, 1, 6, bgcolor = color.new(color.black, 40), border_width = 2, border_color = color.blue)\r\n    \r\n    table.cell(infoTable, 0, 0, \"OFM STRATEGY\", text_color = color.white, text_size = size.normal, bgcolor = color.new(color.blue, 50))\r\n    table.cell(infoTable, 0, 1, \"HTF Trend: \" + trendText, text_color = color.white, text_size = size.small)\r\n    table.cell(infoTable, 0, 2, \"In Demand: \" + demandText, text_color = inDemand ? color.lime : color.gray, text_size = size.small)\r\n    table.cell(infoTable, 0, 3, \"In Supply: \" + supplyText, text_color = inSupply ? color.red : color.gray, text_size = size.small)\r\n    table.cell(infoTable, 0, 4, \"Risk: $\" + str.tostring(maxRiskCash), text_color = color.orange, text_size = size.small)\r\n    table.cell(infoTable, 0, 5, \"RR: 1:\" + str.tostring(rrBase), text_color = color.aqua, text_size = size.small)\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// ALERTS\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nalertcondition(longCond and not inTrade, title = \"LONG SIGNAL\", message = \"OFM LONG\")\r\nalertcondition(shortCond and not inTrade, title = \"SHORT SIGNAL\", message = \"OFM SHORT\")"
  },
  {
    "url": "f3GpWcHm-4H-Confirmation-1H-SFP-BOS-Retest",
    "name": "4H Confirmation + 1H SFP BOS Retest",
    "description": "4H Confirmation + 1H Entry (SFP + BOS + Retest)Run it on 1H\n\nUses 4H EMAs for higher-timeframe direction (confirmation)\n\nUses 1H SFP + BOS + retest + RSI for entries\n\nThis gives you more trades, still guided by the 4H trend",
    "image_url": "f3GpWcHm",
    "author": "jdrake90",
    "likes": 10,
    "type": "strategy",
    "created": "2025-11-25",
    "updated": "2025-11-25",
    "source": "//@version=5\nstrategy(\"4H Confirmation + 1H SFP BOS Retest\",\n     overlay = true,\n     initial_capital = 10000,\n     default_qty_type = strategy.percent_of_equity,\n     default_qty_value = 1,\n     commission_type = strategy.commission.percent,\n     commission_value = 0.01,\n     pyramiding = 0,\n     process_orders_on_close = true,\n     max_labels_count = 500)\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// Inputs\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nhtfRes       = input.timeframe(\"240\", \"HTF Resolution (for bias)\")   // 4H\nemaFastLen   = input.int(20, \"4H EMA Fast\")\nemaSlowLen   = input.int(50, \"4H EMA Slow\")\n\npivotLen     = input.int(3,  \"1H Swing Pivot Length\", 1, 10)\nbosLookback  = input.int(20, \"1H BOS Lookback (bars)\", 5, 100)\n\nuseRSIFilter = input.bool(true, \"Use 1H RSI Filter?\")\nrsiLen       = input.int(14, \"1H RSI Length\")\n\natrLen       = input.int(14, \"ATR Length (1H)\")\natrSLmult    = input.float(1.5, \"ATR SL Multiplier\", 0.1, 5.0)\nrr           = input.float(2.0, \"Reward : Risk\", 0.5, 5.0)\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// 4H bias (HTF)\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nhtfClose   = request.security(syminfo.tickerid, htfRes, close)\nhtfEmaFast = request.security(syminfo.tickerid, htfRes, ta.ema(close, emaFastLen))\nhtfEmaSlow = request.security(syminfo.tickerid, htfRes, ta.ema(close, emaSlowLen))\n\nbullBias = htfEmaFast > htfEmaSlow and htfClose > htfEmaSlow\nbearBias = htfEmaFast < htfEmaSlow and htfClose < htfEmaSlow\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// 1H indicators & structure (entry TF)\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nrsi = ta.rsi(close, rsiLen)\natr = ta.atr(atrLen)\n\n// 1H pivots for swings\nph = ta.pivothigh(high, pivotLen, pivotLen)\npl = ta.pivotlow(low,  pivotLen, pivotLen)\n\nvar float lastSwingHigh = na\nvar float lastSwingLow  = na\n\nif not na(ph)\n    lastSwingHigh := ph\n\nif not na(pl)\n    lastSwingLow := pl\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// 1H SFP (liquidity sweeps)\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// Bullish SFP: sweep below last swing low, close back above\nbullSFP_1h = not na(lastSwingLow)  and low  < lastSwingLow  and close > lastSwingLow\n\n// Bearish SFP: sweep above last swing high, close back below\nbearSFP_1h = not na(lastSwingHigh) and high > lastSwingHigh and close < lastSwingHigh\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// 1H BOS (Change of Character)\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nrecentHigh_1h = ta.highest(high, bosLookback)\nrecentLow_1h  = ta.lowest(low,  bosLookback)\n\nbullBOS_1h = bullSFP_1h and close > recentHigh_1h[1]\nbearBOS_1h = bearSFP_1h and close < recentLow_1h[1]\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// 1H Context state â€“ reversal bias after BOS\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nvar bool  bullContext_1h    = false\nvar bool  bearContext_1h    = false\nvar float lastBrokenHigh_1h = na\nvar float lastBrokenLow_1h  = na\n\nif bullBOS_1h\n    bullContext_1h    := true\n    bearContext_1h    := false\n    lastBrokenHigh_1h := recentHigh_1h[1]\n\nif bearBOS_1h\n    bearContext_1h    := true\n    bullContext_1h    := false\n    lastBrokenLow_1h  := recentLow_1h[1]\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// 1H Retest entries (inside 4H bias)\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nlongRetest_1h  = bullContext_1h and not na(lastBrokenHigh_1h) and low  <= lastBrokenHigh_1h and close > lastBrokenHigh_1h\nshortRetest_1h = bearContext_1h and not na(lastBrokenLow_1h)  and high >= lastBrokenLow_1h  and close < lastBrokenLow_1h\n\nbullCandle_1h = close > open\nbearCandle_1h = close < open\n\nrsiLongOK  = not useRSIFilter or rsi > 50\nrsiShortOK = not useRSIFilter or rsi < 50\n\n// Final conditions: 4H bias + 1H setup\nlongCond  = bullBias and longRetest_1h  and bullCandle_1h and rsiLongOK\nshortCond = bearBias and shortRetest_1h and bearCandle_1h and rsiShortOK\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// Stops & Targets (on 1H, but sized with ATR)\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nlongSL  = close - atrSLmult * atr\nlongTP  = close + (close - longSL) * rr\n\nshortSL = close + atrSLmult * atr\nshortTP = close - (shortSL - close) * rr\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// Orders\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nflat = strategy.position_size == 0\n\nif (longCond and flat)\n    strategy.entry(\"Long\", strategy.long)\n    strategy.exit(\"Long TP/SL\", \"Long\", stop = longSL, limit = longTP)\n\nif (shortCond and flat)\n    strategy.entry(\"Short\", strategy.short)\n    strategy.exit(\"Short TP/SL\", \"Short\", stop = shortSL, limit = shortTP)\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// Visuals â€“ 4H bias + 1H signals\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nplot(htfEmaFast, \"4H EMA Fast (HTF)\", color = color.new(color.orange, 0))\nplot(htfEmaSlow, \"4H EMA Slow (HTF)\", color = color.new(color.blue, 0))\n\nplot(lastSwingHigh, \"1H Last Swing High\", style = plot.style_linebr, color = color.new(color.red, 0))\nplot(lastSwingLow,  \"1H Last Swing Low\",  style = plot.style_linebr, color = color.new(color.green, 0))\n\n// SFP marks\nplotshape(bullSFP_1h,  title = \"Bullish SFP (1H)\",\n     style = shape.circle, location = location.belowbar,\n     color = color.new(color.green, 0), size = size.tiny, text = \"SFP\")\n\nplotshape(bearSFP_1h,  title = \"Bearish SFP (1H)\",\n     style = shape.circle, location = location.abovebar,\n     color = color.new(color.red, 0), size = size.tiny, text = \"SFP\")\n\n// BOS marks\nplotshape(bullBOS_1h,  title = \"Bullish BOS (1H)\",\n     style = shape.triangleup, location = location.abovebar,\n     color = color.new(color.green, 0), size = size.tiny, text = \"BOS\")\n\nplotshape(bearBOS_1h,  title = \"Bearish BOS (1H)\",\n     style = shape.triangledown, location = location.belowbar,\n     color = color.new(color.red, 0), size = size.tiny, text = \"BOS\")\n\n// BUY / SELL markers\nplotshape(longCond,  title = \"Long Entry (1H with 4H bias)\",\n     style = shape.labelup, location = location.belowbar,\n     color = color.new(color.green, 0), text = \"BUY\", textcolor = color.white, size = size.small)\n\nplotshape(shortCond, title = \"Short Entry (1H with 4H bias)\",\n     style = shape.labeldown, location = location.abovebar,\n     color = color.new(color.red, 0), text = \"SELL\", textcolor = color.white, size = size.small)\n"
  },
  {
    "url": "Ce4ogq3U-stormytrading-orb-bot",
    "name": "stormytrading orb bot",
    "description": "shows entries for 15m orb based on 5m break and retest made  solely for mnq or nq, works good with smt\n\nshows trades for ldn, nyc, nyc overlap and Asia session, pls follow stormy trading on insta for more",
    "image_url": "Ce4ogq3U",
    "author": "stormytrading",
    "likes": 31,
    "type": "strategy",
    "created": "2025-11-25",
    "updated": "2025-11-25",
    "source": "//@version=5\r\nstrategy(\"MNQ Multi-Session ORB Break & Retest\", overlay=true, default_qty_type=strategy.percent_of_equity, default_qty_value=100, max_bars_back=5000)\r\n\r\n// Input parameters\r\nuseAsia = input.bool(true, \"Use Asia Session (5:00-5:15 PM EST)\")\r\nuseLondon = input.bool(true, \"Use London Session (2:30-2:45 AM EST)\")\r\nuseNYC = input.bool(true, \"Use NYC Session (6:00-6:15 AM EST)\")\r\nuseOverlap = input.bool(true, \"Use NYC Overlap (8:30-8:45 AM EST)\")\r\nretestBuffer = input.float(0.5, \"Retest Buffer (%)\", minval=0, maxval=5) / 100\r\nslPoints = input.float(20, \"Stop Loss (Points)\", minval=1)\r\ntpMultiplier = input.float(2.0, \"TP Multiplier (x SL)\", minval=0.5, step=0.5)\r\ntpPoints = slPoints * tpMultiplier\r\n\r\n// Momentum settings\r\nemaFast = input.int(9, \"Fast EMA\", minval=1)\r\nemaSlow = input.int(21, \"Slow EMA\", minval=1)\r\nmomentumLookback = input.int(50, \"Momentum Lookback Bars\", minval=10)\r\n\r\n// Session definitions (NYC/EST timezone)\r\nasiaSession = \"1700-1715:23456\"\r\nlondonSession = \"0230-0245:23456\"\r\nnycSession = \"0600-0615:23456\"\r\noverlapSession = \"0830-0845:23456\"\r\n\r\n// === MOMENTUM CALCULATION ===\r\nemaF = ta.ema(close, emaFast)\r\nemaS = ta.ema(close, emaSlow)\r\nrsi = ta.rsi(close, 14)\r\n\r\n// Price position relative to day open\r\nvar float dayOpen = na\r\nif ta.change(time(\"D\"))\r\n    dayOpen := open\r\n\r\n// Momentum scoring (-3 to +3, positive = bullish, negative = bearish)\r\nvar int momentumScore = 0\r\n\r\nemaBullish = emaF > emaS ? 1 : -1\r\nrsiBullish = rsi > 50 ? 1 : -1\r\npriceVsDayOpen = close > dayOpen ? 1 : -1\r\n\r\nmomentumScore := emaBullish + rsiBullish + priceVsDayOpen\r\n\r\n// Determine bias\r\nbool bullishBias = momentumScore > 0\r\nbool bearishBias = momentumScore < 0\r\n\r\n// Variables for each session - ORB levels\r\nvar float asiaHigh = na\r\nvar float asiaLow = na\r\nvar bool asiaSet = false\r\nvar float ldnHigh = na\r\nvar float ldnLow = na\r\nvar bool ldnSet = false\r\nvar float nycHigh = na\r\nvar float nycLow = na\r\nvar bool nycSet = false\r\nvar float ovlHigh = na\r\nvar float ovlLow = na\r\nvar bool ovlSet = false\r\n\r\n// Break tracking\r\nvar bool asiaBrokeHigh = false\r\nvar bool asiaBrokeLow = false\r\nvar bool ldnBrokeHigh = false\r\nvar bool ldnBrokeLow = false\r\nvar bool nycBrokeHigh = false\r\nvar bool nycBrokeLow = false\r\nvar bool ovlBrokeHigh = false\r\nvar bool ovlBrokeLow = false\r\n\r\n// Retest tracking\r\nvar bool asiaRetestHigh = false\r\nvar bool asiaRetestLow = false\r\nvar bool ldnRetestHigh = false\r\nvar bool ldnRetestLow = false\r\nvar bool nycRetestHigh = false\r\nvar bool nycRetestLow = false\r\nvar bool ovlRetestHigh = false\r\nvar bool ovlRetestLow = false\r\n\r\n// Trade taken flags\r\nvar bool asiaTradeTaken = false\r\nvar bool ldnTradeTaken = false\r\nvar bool nycTradeTaken = false\r\nvar bool ovlTradeTaken = false\r\n\r\n// Variables for TP/SL lines\r\nvar line tpLine = na\r\nvar line slLine = na\r\nvar float currentTP = na\r\nvar float currentSL = na\r\n\r\n// Detect new day\r\nisNewDay = ta.change(time(\"D\"))\r\n\r\n// Reset all sessions at start of new day\r\nif isNewDay\r\n    asiaHigh := na\r\n    asiaLow := na\r\n    asiaSet := false\r\n    asiaBrokeHigh := false\r\n    asiaBrokeLow := false\r\n    asiaRetestHigh := false\r\n    asiaRetestLow := false\r\n    asiaTradeTaken := false\r\n    ldnHigh := na\r\n    ldnLow := na\r\n    ldnSet := false\r\n    ldnBrokeHigh := false\r\n    ldnBrokeLow := false\r\n    ldnRetestHigh := false\r\n    ldnRetestLow := false\r\n    ldnTradeTaken := false\r\n    nycHigh := na\r\n    nycLow := na\r\n    nycSet := false\r\n    nycBrokeHigh := false\r\n    nycBrokeLow := false\r\n    nycRetestHigh := false\r\n    nycRetestLow := false\r\n    nycTradeTaken := false\r\n    ovlHigh := na\r\n    ovlLow := na\r\n    ovlSet := false\r\n    ovlBrokeHigh := false\r\n    ovlBrokeLow := false\r\n    ovlRetestHigh := false\r\n    ovlRetestLow := false\r\n    ovlTradeTaken := false\r\n\r\n// Check if we're in each session\r\ninAsia = not na(time(timeframe.period, asiaSession))\r\ninLondon = not na(time(timeframe.period, londonSession))\r\ninNYC = not na(time(timeframe.period, nycSession))\r\ninOverlap = not na(time(timeframe.period, overlapSession))\r\n\r\n// === ASIA SESSION ===\r\nif useAsia\r\n    if inAsia\r\n        if na(asiaHigh) or high > asiaHigh\r\n            asiaHigh := high\r\n        if na(asiaLow) or low < asiaLow\r\n            asiaLow := low\r\n        asiaSet := true\r\n    if asiaSet and not inAsia\r\n        asiaBufferHigh = asiaHigh * (1 + retestBuffer)\r\n        asiaBufferLow = asiaLow * (1 - retestBuffer)\r\n        if not asiaBrokeHigh and close > asiaHigh\r\n            asiaBrokeHigh := true\r\n        if not asiaBrokeLow and close < asiaLow\r\n            asiaBrokeLow := true\r\n        if asiaBrokeHigh and not asiaRetestHigh\r\n            if low <= asiaBufferHigh and low >= asiaLow\r\n                asiaRetestHigh := true\r\n        if asiaBrokeLow and not asiaRetestLow\r\n            if high >= asiaBufferLow and high <= asiaHigh\r\n                asiaRetestLow := true\r\n\r\n// === LONDON SESSION ===\r\nif useLondon\r\n    if inLondon\r\n        if na(ldnHigh) or high > ldnHigh\r\n            ldnHigh := high\r\n        if na(ldnLow) or low < ldnLow\r\n            ldnLow := low\r\n        ldnSet := true\r\n    if ldnSet and not inLondon\r\n        ldnBufferHigh = ldnHigh * (1 + retestBuffer)\r\n        ldnBufferLow = ldnLow * (1 - retestBuffer)\r\n        if not ldnBrokeHigh and close > ldnHigh\r\n            ldnBrokeHigh := true\r\n        if not ldnBrokeLow and close < ldnLow\r\n            ldnBrokeLow := true\r\n        if ldnBrokeHigh and not ldnRetestHigh\r\n            if low <= ldnBufferHigh and low >= ldnLow\r\n                ldnRetestHigh := true\r\n        if ldnBrokeLow and not ldnRetestLow\r\n            if high >= ldnBufferLow and high <= ldnHigh\r\n                ldnRetestLow := true\r\n\r\n// === NYC SESSION ===\r\nif useNYC\r\n    if inNYC\r\n        if na(nycHigh) or high > nycHigh\r\n            nycHigh := high\r\n        if na(nycLow) or low < nycLow\r\n            nycLow := low\r\n        nycSet := true\r\n    if nycSet and not inNYC\r\n        nycBufferHigh = nycHigh * (1 + retestBuffer)\r\n        nycBufferLow = nycLow * (1 - retestBuffer)\r\n        if not nycBrokeHigh and close > nycHigh\r\n            nycBrokeHigh := true\r\n        if not nycBrokeLow and close < nycLow\r\n            nycBrokeLow := true\r\n        if nycBrokeHigh and not nycRetestHigh\r\n            if low <= nycBufferHigh and low >= nycLow\r\n                nycRetestHigh := true\r\n        if nycBrokeLow and not nycRetestLow\r\n            if high >= nycBufferLow and high <= nycHigh\r\n                nycRetestLow := true\r\n\r\n// === OVERLAP SESSION ===\r\nif useOverlap\r\n    if inOverlap\r\n        if na(ovlHigh) or high > ovlHigh\r\n            ovlHigh := high\r\n        if na(ovlLow) or low < ovlLow\r\n            ovlLow := low\r\n        ovlSet := true\r\n    if ovlSet and not inOverlap\r\n        ovlBufferHigh = ovlHigh * (1 + retestBuffer)\r\n        ovlBufferLow = ovlLow * (1 - retestBuffer)\r\n        if not ovlBrokeHigh and close > ovlHigh\r\n            ovlBrokeHigh := true\r\n        if not ovlBrokeLow and close < ovlLow\r\n            ovlBrokeLow := true\r\n        if ovlBrokeHigh and not ovlRetestHigh\r\n            if low <= ovlBufferHigh and low >= ovlLow\r\n                ovlRetestHigh := true\r\n        if ovlBrokeLow and not ovlRetestLow\r\n            if high >= ovlBufferLow and high <= ovlHigh\r\n                ovlRetestLow := true\r\n\r\n// === GET PERFECT ENTRY PRICE ===\r\nfloat longEntryPrice = na\r\nfloat shortEntryPrice = na\r\n\r\nif asiaRetestHigh and close > asiaHigh and not asiaTradeTaken\r\n    longEntryPrice := asiaHigh\r\nif ldnRetestHigh and close > ldnHigh and not ldnTradeTaken\r\n    longEntryPrice := ldnHigh\r\nif nycRetestHigh and close > nycHigh and not nycTradeTaken\r\n    longEntryPrice := nycHigh\r\nif ovlRetestHigh and close > ovlHigh and not ovlTradeTaken\r\n    longEntryPrice := ovlHigh\r\n\r\nif asiaRetestLow and close < asiaLow and not asiaTradeTaken\r\n    shortEntryPrice := asiaLow\r\nif ldnRetestLow and close < ldnLow and not ldnTradeTaken\r\n    shortEntryPrice := ldnLow\r\nif nycRetestLow and close < nycLow and not nycTradeTaken\r\n    shortEntryPrice := nycLow\r\nif ovlRetestLow and close < ovlLow and not ovlTradeTaken\r\n    shortEntryPrice := ovlLow\r\n\r\n// === ENTRY CONDITIONS WITH MOMENTUM FILTER ===\r\n// Only take longs if bullish bias, only take shorts if bearish bias\r\nasiaLong = asiaRetestHigh and close > asiaHigh and not asiaTradeTaken and bullishBias\r\nasiaShort = asiaRetestLow and close < asiaLow and not asiaTradeTaken and bearishBias\r\nldnLong = ldnRetestHigh and close > ldnHigh and not ldnTradeTaken and bullishBias\r\nldnShort = ldnRetestLow and close < ldnLow and not ldnTradeTaken and bearishBias\r\nnycLong = nycRetestHigh and close > nycHigh and not nycTradeTaken and bullishBias\r\nnycShort = nycRetestLow and close < nycLow and not nycTradeTaken and bearishBias\r\novlLong = ovlRetestHigh and close > ovlHigh and not ovlTradeTaken and bullishBias\r\novlShort = ovlRetestLow and close < ovlLow and not ovlTradeTaken and bearishBias\r\n\r\nlongCondition = (asiaLong or ldnLong or nycLong or ovlLong) and strategy.position_size == 0\r\nshortCondition = (asiaShort or ldnShort or nycShort or ovlShort) and strategy.position_size == 0\r\n\r\n// Execute trades\r\nif longCondition\r\n    strategy.entry(\"Long\", strategy.long)\r\n    if asiaLong\r\n        asiaTradeTaken := true\r\n    if ldnLong\r\n        ldnTradeTaken := true\r\n    if nycLong\r\n        nycTradeTaken := true\r\n    if ovlLong\r\n        ovlTradeTaken := true\r\n    if not na(tpLine)\r\n        line.delete(tpLine)\r\n    if not na(slLine)\r\n        line.delete(slLine)\r\n    currentTP := close + tpPoints\r\n    currentSL := close - slPoints\r\n    tpLine := line.new(bar_index, currentTP, bar_index + 1, currentTP, color=color.green, width=2, extend=extend.right)\r\n    slLine := line.new(bar_index, currentSL, bar_index + 1, currentSL, color=color.red, width=2, extend=extend.right)\r\n    label.new(bar_index, low, \"BUY\\n\" + str.tostring(longEntryPrice, \"#.##\"), style=label.style_label_up, color=color.green, textcolor=color.white, size=size.normal)\r\n\r\nif shortCondition\r\n    strategy.entry(\"Short\", strategy.short)\r\n    if asiaShort\r\n        asiaTradeTaken := true\r\n    if ldnShort\r\n        ldnTradeTaken := true\r\n    if nycShort\r\n        nycTradeTaken := true\r\n    if ovlShort\r\n        ovlTradeTaken := true\r\n    if not na(tpLine)\r\n        line.delete(tpLine)\r\n    if not na(slLine)\r\n        line.delete(slLine)\r\n    currentTP := close - tpPoints\r\n    currentSL := close + slPoints\r\n    tpLine := line.new(bar_index, currentTP, bar_index + 1, currentTP, color=color.green, width=2, extend=extend.right)\r\n    slLine := line.new(bar_index, currentSL, bar_index + 1, currentSL, color=color.red, width=2, extend=extend.right)\r\n    label.new(bar_index, high, \"SELL\\n\" + str.tostring(shortEntryPrice, \"#.##\"), style=label.style_label_down, color=color.red, textcolor=color.white, size=size.normal)\r\n\r\n// Update line positions\r\nif strategy.position_size != 0 and not na(tpLine) and not na(slLine)\r\n    line.set_x2(tpLine, bar_index + 1)\r\n    line.set_x2(slLine, bar_index + 1)\r\n\r\n// Delete lines when position closes\r\nif strategy.position_size == 0 and strategy.position_size[1] != 0\r\n    if not na(tpLine)\r\n        line.delete(tpLine)\r\n        tpLine := na\r\n    if not na(slLine)\r\n        line.delete(slLine)\r\n        slLine := na\r\n    currentTP := na\r\n    currentSL := na\r\n\r\n// Exit with TP/SL\r\nif strategy.position_size > 0\r\n    strategy.exit(\"TP/SL\", \"Long\", limit=strategy.position_avg_price + tpPoints, stop=strategy.position_avg_price - slPoints)\r\n\r\nif strategy.position_size < 0\r\n    strategy.exit(\"TP/SL\", \"Short\", limit=strategy.position_avg_price - tpPoints, stop=strategy.position_avg_price + slPoints)\r\n\r\n// === BIAS INDICATOR TABLE ===\r\nvar table biasTable = table.new(position.top_right, 1, 2, bgcolor=color.new(color.black, 70))\r\nbiasText = momentumScore > 0 ? \"BULLISH\" : momentumScore < 0 ? \"BEARISH\" : \"NEUTRAL\"\r\nbiasColor = momentumScore > 0 ? color.green : momentumScore < 0 ? color.red : color.gray\r\ntable.cell(biasTable, 0, 0, \"BIAS: \" + biasText, text_color=biasColor, text_size=size.normal)\r\ntable.cell(biasTable, 0, 1, \"Score: \" + str.tostring(momentumScore), text_color=color.white, text_size=size.small)\r\n"
  },
  {
    "url": "gIm9xHJ1-HMA-RVOL-Strategy-Hariss-369",
    "name": "HMA+RVOL Strategy Hariss 369",
    "description": "The Hull Moving Average (HMA) is a smooth, fast, and highly responsive moving average created by Alan Hull. It reduces lag significantly while still maintaining smoothness, making it one of the most popular tools for trend detection and entries. It is widely used for trend filter. Hull Moving Average(HMA) with RVOL strengthens the trend as volume is prime factor of price movement.\n\nTrading with HMA: Simple method is buy when price closes above HMA , stop less below the low of last candle and target is 1.5 or 2 times of stop loss. The reverse is for sell. The HMA automatically turns to green on bull trend and red on bear trend for better visual confirmation. \n\nAdding RVOL to HMA is better method of trading. Buy signal is initiated when price closes above HMA and RVOL is greater than 1.2. Sell signal is initiated when price closes below 89 HMA and rovl is greater than 1.2. One can change the value of RVOL according to trading style and type asset being traded. \n\n\nIt is a back tested strategy. ",
    "image_url": "gIm9xHJ1",
    "author": "Hariss369",
    "likes": 16,
    "type": "strategy",
    "created": "2025-11-25",
    "updated": "2025-11-25",
    "source": "//@version=5\nstrategy(\"HMA+RVOL Strategy Hariss 369\", \n     overlay=true, initial_capital=100000,\n     default_qty_type=strategy.percent_of_equity, default_qty_value=10)\n\n// ---------------- INPUTS ----------------\nhma_len      = input.int(89, \"HMA Length\")\nrvol_len     = input.int(20, \"RVOL Lookback\")\nrvol_thresh  = input.float(1.5, \"RVOL Threshold\")\nuse_sl_tp    = input.bool(true, \"Use SL/TP?\")\nsl_percent   = input.float(1.0, \"Stop Loss %\")\ntp_percent   = input.float(2.0, \"Take Profit %\")\n\n// ---------------- FUNCTIONS ----------------\nf_hma(_src, _len) =>\n    half = math.round(_len / 2)\n    sqr  = math.round(math.sqrt(_len))\n    w1 = ta.wma(_src, half)\n    w2 = ta.wma(_src, _len)\n    ta.wma(2 * w1 - w2, sqr)\n\n// ---------------- HMA & RVOL ----------------\nhma = f_hma(close, hma_len)\n\n// Automatic HMA Color (Trend coloring)\nhma_color = close > hma ? color.green : color.red\n\nplot(hma, \"HMA89\", color=hma_color, linewidth=2)\n\n// RVOL\navg_vol_prev = ta.sma(volume, rvol_len)[1]\nrvol = na(avg_vol_prev) or avg_vol_prev == 0 ? na : volume / avg_vol_prev\n\n// ---------------- SIGNALS ----------------\nlongSignal  = (close > hma) and (rvol > rvol_thresh)\nshortSignal = (close < hma) and (rvol > rvol_thresh)\n\n// ---------------- STRATEGY EXECUTION ----------------\nif (longSignal)\n    strategy.entry(\"Long\", strategy.long)\n\nif (shortSignal)\n    strategy.entry(\"Short\", strategy.short)\n\n// ---------------- RISK MANAGEMENT ----------------\nif use_sl_tp\n    long_sl  = strategy.position_avg_price * (1 - sl_percent / 100)\n    long_tp  = strategy.position_avg_price * (1 + tp_percent / 100)\n    short_sl = strategy.position_avg_price * (1 + sl_percent / 100)\n    short_tp = strategy.position_avg_price * (1 - tp_percent / 100)\n\n    strategy.exit(\"Exit Long\",  from_entry=\"Long\",  stop=long_sl,  limit=long_tp)\n    strategy.exit(\"Exit Short\", from_entry=\"Short\", stop=short_sl, limit=short_tp)\n\n// ---------------- BUY / SELL PLOTS ----------------\nplotshape(longSignal, title=\"Buy Signal\", location=location.belowbar,\n          style=shape.triangleup, size=size.small, color=color.green, text=\"BUY\", textcolor=color.white)\n\nplotshape(shortSignal, title=\"Sell Signal\", location=location.abovebar,\n          style=shape.triangledown, size=size.small, color=color.red, text=\"SELL\", textcolor=color.white)\n\n// ---------------- LABELS ----------------\nif longSignal\n    label.new(bar_index, low, \"BUY\\nRVOL: \" + str.tostring(rvol, \"#.##\"),\n              style=label.style_label_up, color=color.new(color.green, 0), textcolor=color.white)\n\nif shortSignal\n    label.new(bar_index, high, \"SELL\\nRVOL: \" + str.tostring(rvol, \"#.##\"),\n              style=label.style_label_down, color=color.new(color.red, 0), textcolor=color.white)\n"
  },
  {
    "url": "M0apBk3b-EMA-50-200-Clean-BUY-SELL",
    "name": "EMA 50/200 â€“ Clean BUY/SELL ",
    "description": "EMA 50/200 clean buy and sell hence use this for golden cross for buy",
    "image_url": "M0apBk3b",
    "author": "satyaatukuri",
    "likes": 14,
    "type": "strategy",
    "created": "2025-11-25",
    "updated": "2025-11-25",
    "source": "//@version=5\nstrategy(\"EMA 50/200 â€“ Clean BUY/SELL + Arrow + * Cross Mark (Strategy Version)\", \n     overlay=true, \n     max_labels_count=500,\n     initial_capital=100000)\n\n// --- EMAs ---\nema50  = ta.ema(close, 50)\nema200 = ta.ema(close, 200)\n\nplot(ema50,  \"EMA 50\",  color=color.blue, linewidth=2)\nplot(ema200, \"EMA 200\", color=color.red,  linewidth=2)\n\n// --- Signals ---\nbuySignal  = ta.crossover(ema50, ema200) and barstate.isconfirmed\nsellSignal = ta.crossunder(ema50, ema200) and barstate.isconfirmed\n\n// --- ATR offset for spacing ---\natr = ta.atr(14)\noffset = atr * 0.8   // Spacing for labels\n\n// --- Entry tracking for TP ---\nvar float buyPrice = na\nif buySignal\n    buyPrice := close\n\ntpSignal = not na(buyPrice) and close >= buyPrice * 2\nif tpSignal\n    buyPrice := na\n\n// =======================================================\n//                STRATEGY TRADING LOGIC\n// =======================================================\n\n// BUY ENTRY\nif buySignal\n    strategy.entry(\"BUY\", strategy.long)\n\n// SELL EXIT\nif sellSignal\n    strategy.close(\"BUY\", comment=\"SELL\")\n\n// TAKE PROFIT EXIT (Price Doubles)\nif tpSignal\n    strategy.close(\"BUY\", comment=\"TP\")\n\n// =======================================================\n//                      LABELS (AS IS)\n// =======================================================\n\n// BUY label BELOW with upward arrow\nif buySignal\n    label.new(bar_index, low - offset, \"BUY â†‘\", style=label.style_label_up, color=color.green, textcolor=color.white)\n\n// SELL label ABOVE\nif sellSignal\n    label.new(bar_index, high + offset/2, \"SELL â†“\", style=label.style_label_down, color=color.red, textcolor=color.white)\n\n// TP label\nif tpSignal\n    label.new(bar_index, high + offset/2, \"TP\", style=label.style_label_down, color=color.blue, textcolor=color.white)\n\n// --- CROSSOVER MARKS (â€œ*â€) ---\nplotchar(buySignal,  char=\"*\", location=location.belowbar, color=color.green, size=size.large)\nplotchar(sellSignal, char=\"*\", location=location.abovebar, color=color.red,   size=size.large)\n\n// --- Alerts ---\nalertcondition(buySignal,  \"BUY\",  \"EMA 50 crossed above EMA 200 â€” BUY\")\nalertcondition(sellSignal, \"SELL\", \"EMA 50 crossed below EMA 200 â€” SELL\")\nalertcondition(tpSignal,   \"TP\",   \"Price doubled â€” TAKE PROFIT\")\n"
  },
  {
    "url": "rqRd3f62-DEMA-ATR-Strategy-PrimeAutomation",
    "name": "DEMA ATR Strategy [PrimeAutomation]",
    "description": "â¯ OVERVIEW \nThe  DEMA ATR Strategy  combines trend-following logic with adaptive volatility filters to identify strong momentum phases and manage trades dynamically.  \nIt uses a Double Exponential Moving Average (DEMA) anchored to ATR volatility bands, creating a self-adjusting trend baseline.  \nWhen the adjusted DEMA shifts direction, the strategy enters positions and scales out profit in phases based on ATR-driven targets.\n\nThis system adapts to volatility, filters noise, and seeks sustained directional moves.\n\n â¯ KEY FEATURES \n \n   DEMA-Volatility Hybrid Filter   \n  Uses Double EMA with ATR expansion/compression logic to form a dynamic trend baseline.\n   Directional Shift Entries   \n  Entries occur when the adjusted DEMA flips trend (bullish crossover or bearish crossunder vs its past value).\n  \n   Noise Reduction Mechanism   \n  ATR range caps extreme moves and prevents false flips during choppy volatility spikes.\n  \n   Multi-Level Take Profits   \n  Targets scale out positions at 1Ã—, 2Ã—, and 3Ã— ATR multiples in the trade direction.\n  \n   Volatility-Adaptive Targets   \n  ATR multiplier ensures profit targets expand/contract based on market conditions.\n   Single-Direction Exposure   \n  No pyramiding; the strategy flips position only when trend shifts.\n   Automated Trade Finalization   \n  When all profit targets trigger, the position is fully closed.\n \n\n â¯ STRATEGY LOGIC \n \n   Trend Direction:   \n  DEMA baseline is modified using ATR upper/lower envelopes.  \n  â€¢ If the adjusted DEMA rises above previous value â†’ Bullish  \n  â€¢ If it falls below previous value â†’ Bearish\n  \n   Entry Rules:   \n  â€¢ Enter Long when bullish shift occurs and no long position exists  \n  â€¢ Enter Short when bearish shift occurs and no short position exists\n\n   Take Profit Logic:   \n  3 partial exits for each trade based on ATR:\n  â€¢ TP1 = Â±1Ã— ATR  \n  â€¢ TP2 = Â±2Ã— ATR  \n  â€¢ TP3 = Â±3Ã— ATR  \n  Profit distribution: 30% / 30% / 40%\n  \n\n   Exit Conditions:   \n  â€¢ Exit when all TPs hit (full scale-out if sum of all TPs 100%)  \n  â€¢ Opposite trend signal closes current trade and opens new one\n \n\n â¯ WHEN TO USE \n \n  Trending environments\n  Mediumâ€“high volatility phases\n  Swing trading and intraday trend plays\n  \n  Markets that respect momentum continuation (crypto, indices, FX majors)\n \n\n â¯ CONCLUSION \nThis strategy blends DEMA trend recognition with ATR-based volatility adaptation to generate cleaner directional entries and structured take-profit exits. It is designed to capture momentum phases while avoiding noise-driven false signals, delivering a disciplined and scalable trend-following approach.",
    "image_url": "rqRd3f62",
    "author": "ChartPrime",
    "likes": 1064,
    "type": "strategy",
    "created": "2025-11-25",
    "updated": "2025-11-25",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// Â© PrimeAutomation\r\n//@strategy_alert_message {{strategy.order.alert_message}}\r\n\r\n//@version=6\r\nstrategy(title=\"DEMA ATR Strategy [PrimeAutomation]\"\r\n , shorttitle = \"DEMA ATR Strategy [PrimeAutomation]\"\r\n , overlay=true\r\n , default_qty_type = strategy.percent_of_equity\r\n , default_qty_value = 10 \r\n , commission_type = strategy.commission.percent \r\n , commission_value = 0.06 \r\n , initial_capital = 10000\r\n , margin_long = 0\r\n , margin_short = 0\r\n , process_orders_on_close = true\r\n , pyramiding = 0\r\n )\r\n\r\n\r\nimport TradingView/ta/7\r\n\r\n\r\nstring OpSettings           = \"âžž Optimization Settings ðŸ”¸\"\r\nstring OpSettings1          = \"âžž Settings ðŸ”¸\"\r\n\r\n\r\n// Strategy Settings\r\nstartTime     = input.time(timestamp(\"01-01-2023\"), \"Strategy Start Date\", group = OpSettings1)\r\nMarketClosed  = input.bool(false ,\"Exit before market close\", group = OpSettings1)\r\n\r\nvar StartTIME = 0\r\ntotaltrades = strategy.closedtrades\r\nPNL = strategy.netprofit_percent + strategy.openprofit_percent\r\nWinRate = (strategy.wintrades / totaltrades ) * 100 \r\nMaxDraw = strategy.max_drawdown_percent\r\n\r\nCon = strategy.closedtrades == 0 and strategy.opentrades == 1 \r\nStartTIME:= ta.valuewhen(Con and not Con[1],time,0)\r\n\r\nMC()=>\r\n    hr = hour == 15\r\n    min = minute == 55\r\n    _Hr = request.security(syminfo.tickerid,\"5\",hr)\r\n    _min = request.security(syminfo.tickerid,\"5\",min)\r\n    MClose = (_Hr and _min )\r\n    MClose\r\n\r\n\r\nvar float dailyPNL = na\r\nvar int maxDays = 60\r\nvar float lastNetProfit = na\r\nvar array<string> PNLS = array.new_string()\r\n\r\nnewDay = ta.change(time(\"D\")) != 0\r\ncurrentNetProfit = strategy.netprofit\r\n\r\nif newDay\r\n    if not na(lastNetProfit)\r\n        dailyPNL := currentNetProfit - lastNetProfit\r\n\r\n        if dailyPNL != 0\r\n            dateStr = str.format(\"{0,date,MM-dd}\", time)\r\n            combined = dateStr + \":\" + str.tostring(dailyPNL, \"#.##\")\r\n            array.unshift(PNLS, combined)\r\n\r\n            if array.size(PNLS) > maxDays\r\n                array.pop(PNLS)\r\n\r\n    lastNetProfit := currentNetProfit\r\n\r\n\r\n\r\n// log.error(str.tostring(PNLS))\r\n\r\n\r\n\r\ntradesCount = strategy.closedtrades\r\n\r\n// Get PnL of last closed trade\r\nLastPNL = 0.\r\nif tradesCount > 0\r\n    LastPNL := strategy.closedtrades.profit(tradesCount - 1)\r\n\r\n\r\n\r\nmethod parseing(string st,tp = 0 , sl = 0 , size = 0 , per = 0.)=>\r\n    string ret = st\r\n    ret := str.replace_all(ret, \"{{tickerid}}\", syminfo.tickerid)\r\n    ret := str.replace_all(ret, \"{{ticker}}\", syminfo.ticker)\r\n    ret := str.replace_all(ret, \"{{exchange}}\", syminfo.prefix)\r\n    ret := str.replace_all(ret, \"{{close}}\", str.tostring(close))\r\n    ret := str.replace_all(ret, \"{{open}}\", str.tostring(open))\r\n    ret := str.replace_all(ret, \"{{high}}\", str.tostring(high))\r\n    ret := str.replace_all(ret, \"{{low}}\", str.tostring(low))\r\n    ret := str.replace_all(ret, \"{{time}}\", str.format_time(time, \"yyyy-MM-dd HH:mm\", syminfo.timezone))\r\n    ret := str.replace_all(ret, \"{{timenow}}\", str.format_time(timenow, \"yyyy-MM-dd HH:mm\", syminfo.timezone))\r\n    ret := str.replace_all(ret, \"{{volume}}\", str.tostring(volume))\r\n    ret := str.replace_all(ret, \"{{interval}}\", timeframe.period)\r\n    ret := str.replace_all(ret, \"{{country}}\", syminfo.country)\r\n    ret := str.replace_all(ret, \"{{description}}\", syminfo.description)\r\n    ret := str.replace_all(ret, \"{{root}}\", syminfo.root)\r\n    ret := str.replace_all(ret, \"{{industry}}\", syminfo.industry)\r\n    ret := str.replace_all(ret, \"{{type}}\", syminfo.type)\r\n    ret := str.replace_all(ret, \"{{tp}}\", str.tostring(tp))\r\n    ret := str.replace_all(ret, \"{{sl}}\", str.tostring(sl))\r\n    ret := str.replace_all(ret, \"{{size}}\", str.tostring(size))\r\n    ret := str.replace_all(ret, \"{{per}}\", str.tostring(per))\r\n    ret := str.replace_all(ret, \"{{TotalTrades}}\", str.tostring(strategy.closedtrades))\r\n    ret := str.replace_all(ret, \"{{PNL}}\", str.tostring(strategy.netprofit_percent + strategy.openprofit_percent,\"#.##\"))\r\n    ret := str.replace_all(ret, \"{{WinRate}}\", str.tostring((strategy.wintrades / totaltrades) * 100 ,\"#.##\"))\r\n    ret := str.replace_all(ret, \"{{MaxDraw}}\", str.tostring(strategy.max_drawdown_percent,\"#.##\" ))\r\n    ret := str.replace_all(ret, \"{{StartDate}}\", str.format(\"{0,date,medium}\",StartTIME))\r\n    ret := str.replace_all(ret, \"{{DailyPnl}}\", str.tostring(dailyPNL,\"#.##\"))\r\n    ret := str.replace_all(ret, \"{{historyPNL}}\", str.tostring(PNLS))\r\n    ret := str.replace_all(ret, \"{{LastPNL}}\", str.tostring(LastPNL))\r\n    ret\r\n\r\n\r\n\r\nLongEntryMSG   = '{\"ticker\": \"{{ticker}}\",\"action\": \"buy\",\"price\": \"{{close}}\", \"time\": \"{{timenow}}\", \"size\": \"{{size}}\",\"TotalTrades\":  \"{{TotalTrades}}\" ,\"PNL\": \"{{PNL}}\", \"WinRate\":  \"{{WinRate}}\", \"MaxDraw\": \"{{MaxDraw}}\", \"StartDate\":  \"{{StartDate}}\", \"DailyPNL\": \"{{DailyPnl}}\"}'\r\nLongExitMSG    = '{\"ticker\": \"{{ticker}}\",\"action\": \"exit_buy\",\"price\": \"{{close}}\", \"time\": \"{{timenow}}\", \"size\": \"{{size}}\", \"per\": \"{{per}}\", \"sl\": \"{{sl}}\", \"tp\": \"{{tp}}\" ,\"TotalTrades\":  \"{{TotalTrades}}\" ,\"PNL\": \"{{PNL}}\", \"WinRate\":  \"{{WinRate}}\", \"MaxDraw\": \"{{MaxDraw}}\", \"StartDate\":  \"{{StartDate}}\", \"DailyPNL\": \"{{DailyPnl}}\"}'\r\nShortEntryMSG  = '{\"ticker\": \"{{ticker}}\",\"action\": \"sell\",\"price\": \"{{close}}\", \"time\": \"{{timenow}}\", \"size\": \"{{size}}\",\"TotalTrades\":  \"{{TotalTrades}}\" ,\"PNL\": \"{{PNL}}\", \"WinRate\":  \"{{WinRate}}\", \"MaxDraw\": \"{{MaxDraw}}\", \"StartDate\":  \"{{StartDate}}\", \"DailyPNL\": \"{{DailyPnl}}\"}'\r\nShortExitMSG   = '{\"ticker\": \"{{ticker}}\",\"action\": \"exit_sell\",\"price\": \"{{close}}\", \"time\": \"{{timenow}}\", \"size\": \"{{size}}\", \"per\": \"{{per}}\", \"sl\": \"{{sl}}\", \"tp\": \"{{tp}}\" ,\"TotalTrades\":  \"{{TotalTrades}}\" ,\"PNL\": \"{{PNL}}\", \"WinRate\":  \"{{WinRate}}\", \"MaxDraw\": \"{{MaxDraw}}\", \"StartDate\":  \"{{StartDate}}\", \"DailyPNL\": \"{{DailyPnl}}\"}'\r\n\r\n\r\n\r\n\r\nvar float currentSize = na\r\nisNewTrade = strategy.opentrades > strategy.opentrades[1]\r\n\r\nif isNewTrade\r\n    currentSize := math.abs(strategy.opentrades.size(strategy.opentrades -1))\r\n\r\n\r\nMarketisClose = MC()\r\n\r\n\r\n// --------------------------------------------------------------------------------------------------------------------}\r\n// ðŸ“Œ ð™ð™Žð™€ð™ ð™„ð™‰ð™‹ð™ð™ð™Ž\r\n// --------------------------------------------------------------------------------------------------------------------{\r\n\r\n// Define User Inputs\r\nint   periodDema  = input.int(75, \"Dema Period\", group = \"Dema Atr\")\r\nint   periodAtr   = input.int(20, \"ATR Period\", group = \"Dema Atr\", step = 1)\r\nfloat factorAtr   = input.float(1.20, \"ATR Factor\", step = 0.05, group = \"Dema Atr\")\r\n\r\ngTP      = \"Take Profit\"\r\nuseTP    = input.bool(true, \"Take Profit\", group = gTP, inline = \"tp\")\r\nfactorTP = input.float(3, \"\", step = 0.1, group = gTP, inline = \"tp\")\r\ntp1Size = input.int(30, \"TP1 Size Exit\", group = gTP)\r\ntp2Size = input.int(30, \"TP2 Size Exit\", group = gTP)\r\ntp3Size = input.int(40, \"TP3 Size Exit\", group = gTP)\r\n\r\n\r\ndemaOut = ta.dema(close, periodDema)\r\n\r\ntrueRange = ta.atr(periodAtr) * factorAtr \r\n\r\nDemaAtr = demaOut \r\nDemaAtr := nz(DemaAtr[1], DemaAtr)\r\n\r\ntrueRangeUpper = demaOut + trueRange\r\ntrueRangeLower = demaOut - trueRange \r\n\r\nif trueRangeLower > DemaAtr \r\n    DemaAtr := trueRangeLower\r\nif trueRangeUpper < DemaAtr \r\n    DemaAtr := trueRangeUpper\r\n\r\ncolor = DemaAtr > DemaAtr[2] ? color.lime : DemaAtr < DemaAtr[2] ? #e42c2c : color.orange\r\n\r\n\r\nlongCondition  = ta.crossover(DemaAtr, DemaAtr[2]) and barstate.isconfirmed\r\nshortCondition = ta.crossunder(DemaAtr, DemaAtr[2]) and barstate.isconfirmed\r\n\r\n\r\natr = ta.atr(200) * factorTP\r\n\r\nvar float tp1 = na\r\nvar float tp2 = na\r\nvar float tp3 = na\r\n\r\nvar float tp11 = na\r\nvar float tp22 = na\r\nvar float tp33 = na\r\nvar float entr = na\r\n\r\n// Strategy Execution\r\n\r\nif time >= startTime \r\n    // Trades\r\n    if longCondition and strategy.position_size <= 0\r\n        strategy.close('Short', 'Short Exit', alert_message = ShortExitMSG.parseing(per = 100,size = math.abs(strategy.position_size)))   \r\n        strategy.entry(\"Long\", strategy.long, comment=\"Long\", alert_message =  LongEntryMSG.parseing( size = currentSize ))\r\n\r\n        \r\n\r\n        if useTP\r\n            tp1 := close + atr\r\n            tp2 := close + atr*2\r\n            tp3 := close + atr*3\r\n            tp11 := na\r\n            tp22 := na\r\n            tp33 := na\r\n            entr := close\r\n\r\n\r\n    if shortCondition and strategy.position_size > 0\r\n        strategy.close('Long', 'Long Exit', alert_message = LongExitMSG.parseing(per = 100,size = math.abs(strategy.position_size))) \r\n        strategy.entry(\"Short\", strategy.short, comment=\"Short\", alert_message =  ShortEntryMSG.parseing( size = currentSize))\r\n\r\n        \r\n\r\n        if useTP\r\n            tp11 := close - atr\r\n            tp22 := close - atr*2\r\n            tp33 := close - atr*3\r\n            tp1 := na\r\n            tp2 := na\r\n            tp3 := na\r\n            entr := close\r\n\r\n    if strategy.position_size > 0\r\n\r\n        if high > tp1 \r\n            strategy.close('Long', 'Long TP1', alert_message = LongExitMSG.parseing(per = tp1Size,size = math.abs(strategy.position_size)), qty_percent = tp1Size) \r\n            tp1 := na\r\n       \r\n        if high > tp2\r\n            strategy.close('Long', 'Long TP2', alert_message = LongExitMSG.parseing(per = tp2Size,size = math.abs(strategy.position_size)), qty_percent = tp2Size) \r\n            tp2 := na\r\n       \r\n        if high > tp3\r\n            strategy.close('Long', 'Long TP3', alert_message = LongExitMSG.parseing(per = tp3Size,size = math.abs(strategy.position_size)), qty_percent = tp3Size) \r\n            tp3 := na\r\n            entr := na\r\n    else\r\n        if low < tp11\r\n            strategy.close('Short', 'Short TP1', alert_message = ShortExitMSG.parseing(per = tp1Size,size = math.abs(strategy.position_size)), qty_percent = tp1Size)   \r\n            tp11 := na\r\n          \r\n        if low < tp22\r\n            strategy.close('Short', 'Short TP2', alert_message = ShortExitMSG.parseing(per = tp2Size,size = math.abs(strategy.position_size)), qty_percent = tp2Size)   \r\n            tp22 := na\r\n       \r\n        if low < tp33\r\n            strategy.close('Short', 'Short TP3', alert_message = ShortExitMSG.parseing(per = tp3Size,size = math.abs(strategy.position_size)), qty_percent = tp3Size)   \r\n            tp33 := na\r\n            entr := na\r\n\r\n\r\n\r\n\r\n// Close Trades when Market Closed\r\nif MarketClosed and MarketClosed \r\n    if strategy.position_size > 0\r\n        strategy.close('Long', 'Long Exit', alert_message = LongExitMSG.parseing(per = 100,size = math.abs(strategy.position_size))) \r\n    else \r\n        strategy.close('Short', 'Short Exit', alert_message = ShortExitMSG.parseing(per = 100,size = math.abs(strategy.position_size)))   \r\n\r\n\r\n\r\n\r\ntpCol = strategy.position_size > 0 ? color.lime : #e42c2c\r\nplot(tp1, \"TP1 Long\", style = plot.style_linebr, color = tpCol)\r\nplot(tp2, \"TP2 Long\", style = plot.style_linebr, color = tpCol)\r\np3 = plot(tp3, \"TP3 Long\", style = plot.style_linebr, color = tpCol)\r\n\r\nplot(tp11, \"TP1 Short\", style = plot.style_linebr, color = tpCol)\r\nplot(tp22, \"TP2 Short\", style = plot.style_linebr, color = tpCol)\r\np33 = plot(tp33, \"TP3 Short\", style = plot.style_linebr, color = tpCol)\r\n\r\npe = plot(entr != entr[1] ? na : entr, \"Enter\", color = chart.fg_color, style = plot.style_linebr)\r\n\r\nfill(pe, p3, color.new(tpCol, 90))\r\nfill(pe, p33, color.new(tpCol, 90))\r\n\r\nplot(DemaAtr, color = color, linewidth = 3)\r\n"
  },
  {
    "url": "ypcz4nIT-BTC-30-m-Long-singal",
    "name": "BTC 30 m Long singal ",
    "description": "Asset: Bitcoin only\nTimeframe: 30 minutes\nEntry Conditions (Long):\n\nMACD histogram turns from red to green (negative to positive)\nStochastic K line crosses above D line AND this crossover happens below the lower band (20)\nRSI is above the middle band (50)",
    "image_url": "ypcz4nIT",
    "author": "samuilmanasiev1",
    "likes": 14,
    "type": "strategy",
    "created": "2025-11-25",
    "updated": "2025-11-25",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// Â© samuilmanasiev1\n\n//@version=6\nstrategy(\"My strategy\", overlay=true, fill_orders_on_standard_ohlc = true)\n\nlongCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))\nif (longCondition)\n    strategy.entry(\"My Long Entry Id\", strategy.long)\n\nshortCondition = ta.crossunder(ta.sma(close, 14), ta.sma(close, 28))\nif (shortCondition)\n    strategy.entry(\"My Short Entry Id\", strategy.short)\n"
  },
  {
    "url": "XvyN23OC-crypto-grid-2025-long-only-asym-tp",
    "name": "Crypto Grid 2025+ Long Only (Asym TP)",
    "description": "Crypto Grid 2025+ Long Only (Asymmetric Take-Profit) is a long-only mean-reversion grid strategy designed for intraday cryptocurrency trading.\nThe core idea is to accumulate long positions as price moves downward within a locally defined price range and to exit positions on upward retracements.\n\nThe strategy automatically builds a multi-level grid between the highest and lowest price over a user-defined lookback period (â€œrange lengthâ€). Each grid level acts as a potential entry point when price crosses it from above.\n\nKey Features\n\n1. Long-only grid logic\nThe strategy opens long positions only, progressively increasing exposure as price moves into lower grid levels.\n\n2. Asymmetric take-profit mechanism\nInstead of taking profit strictly at the next grid level, the strategy allows targeting multiple levels above the entry point. This increases the average profit per winning trade and shifts the reward-to-risk profile toward larger, less frequent wins.\n\n3. Optional partial take-profit\nA portion of each trade can be closed at the nearest grid level, while the remainder is held for a more distant asymmetric target. This balances consistency and profit potential.\n\n4. Volume-based market filter\nEntries can be restricted to periods of healthy market activity by requiring volume to exceed a moving-average baseline.\n\n5. Capital-scaled position sizing\nPosition size is determined by risk percentage, grid spacing, and a dynamic sizing mode (original / conservative / aggressive).\n\n6. Built-in risk controls\n\nglobal stop below the lower boundary of the range,\n\nglobal take-profit above the upper boundary,\n\nautomatic shutdown after a configurable loss-streak.\n\nMarket Philosophy\n\nThis strategy belongs to the mean-reversion family: it expects short-term overshoots to revert back toward mid-range liquidity zones.\nIt is not trend-following.\nIt performs best in choppy, range-bound, or slow-grinding markets â€” especially on liquid crypto pairs.\n\nRecommended Use Cases\n\nShort timeframes (1â€“15 minutes)\n\nHigh-liquidity crypto pairs\n\nSideways or rotational price action\n\nExchanges with low fees (due to higher order count)\n\nNot Intended For\n\nStrong trending markets without pullbacks\n\nAssets with thin order books\n\nUse with leverage without additional risk controls\n\nSummary\n\nCrypto Grid 2025+ Long Only (Asymmetric TP) is a refined grid-based mean-reversion strategy optimized for modern crypto markets. Its asymmetric take-profit framework is specifically engineered to reduce the classical issue of â€œsmall wins and large occasional lossesâ€ found in traditional grid systems, giving it a more favorable long-term trade distribution.",
    "image_url": "XvyN23OC",
    "author": "RomanEnlil",
    "likes": 18,
    "type": "strategy",
    "created": "2025-11-25",
    "updated": "2025-11-25",
    "source": "//@version=6\nstrategy(\"Crypto Grid 2025+ Long Only (Asym TP)\", overlay=true, pyramiding=50,\n     initial_capital=10000, commission_type=strategy.commission.percent, commission_value=0.06,\n     calc_on_every_tick = true)\n\n//--------------------------\n// ÐŸÐÐ ÐÐœÐ•Ð¢Ð Ð«\n//--------------------------\nrangeLen   = input.int(20, \"Ð”Ð¸Ð°Ð¿Ð°Ð·Ð¾Ð½ (N Ð±Ð°Ñ€Ð¾Ð²)\", minval=5)\ngridCount  = input.int(10, \"ÐšÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ ÑƒÑ€Ð¾Ð²Ð½ÐµÐ¹\", minval=2)\nriskPct    = input.float(1.0, \"Ð Ð¸ÑÐº Ð½Ð° ÑÐ´ÐµÐ»ÐºÑƒ, % ÐºÐ°Ð¿Ð¸Ñ‚Ð°Ð»Ð°\", step=0.1)\n\n// Ð“Ð»Ð¾Ð±Ð°Ð»ÑŒÐ½Ñ‹Ð¹ Ð¿Ð¾Ñ‚Ð¾Ð»Ð¾Ðº TP (Ð¾Ñ‚ Ð²ÐµÑ€Ñ…Ð° Ð´Ð¸Ð°Ð¿Ð°Ð·Ð¾Ð½Ð°)\ntpPct      = input.float(1.0, \"Ð“Ð»Ð¾Ð±Ð°Ð»ÑŒÐ½Ñ‹Ð¹ TP % Ð²Ñ‹ÑˆÐµ Ð´Ð¸Ð°Ð¿Ð°Ð·Ð¾Ð½Ð°\")\nstopPct    = input.float(2.0, \"Ð¡Ñ‚Ð¾Ð¿ % Ð½Ð¸Ð¶Ðµ Ð´Ð¸Ð°Ð¿Ð°Ð·Ð¾Ð½Ð°\")\n\n// Ð¤Ð¸Ð»ÑŒÑ‚Ñ€ Ð¾Ð±ÑŠÑ‘Ð¼Ð°\nuseVolumeFilter = input.bool(true, \"ðŸ“ˆ Ð¤Ð¸Ð»ÑŒÑ‚Ñ€ Ð¾Ð±ÑŠÐµÐ¼Ð°\")\nvolumeLength    = input.int(40, \"Volume MA Ð¿ÐµÑ€Ð¸Ð¾Ð´\", minval=5)\nvolumeMult      = input.float(1.0, \"ÐœÐ¸Ð½ Ð¼Ð½Ð¾Ð¶Ð¸Ñ‚ÐµÐ»ÑŒ Ð¾Ð±ÑŠÐµÐ¼Ð°\", minval=0.5, step=0.1)\n\n// ÐŸÐ¾ÐºÑƒÐ¿Ð°Ñ‚ÑŒ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ ÑÐ½Ð¸Ð·Ñƒ\nbuyLowerHalfOnly = input.bool(true, \"ÐŸÐ¾ÐºÑƒÐ¿Ð°Ñ‚ÑŒ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð² Ð½Ð¸Ð¶Ð½ÐµÐ¹ Ð¿Ð¾Ð»Ð¾Ð²Ð¸Ð½Ðµ Ð´Ð¸Ð°Ð¿Ð°Ð·Ð¾Ð½Ð°\")\n\n// ÐÑÐ¸Ð¼Ð¼ÐµÑ‚Ñ€Ð¸Ñ‡Ð½Ñ‹Ð¹ TP\ntpLevels = input.int(3, \"TP ÑƒÑ€Ð¾Ð²Ð½ÐµÐ¹ Ð²Ñ‹ÑˆÐµ Ð²Ñ…Ð¾Ð´Ð°\", minval=1, maxval=20)\n\n// Ð”Ð¾Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾\nusePartialTP = input.bool(true, \"ðŸ“ˆ Ð§Ð°ÑÑ‚Ð¸Ñ‡Ð½Ñ‹Ð¹ Ñ‚ÐµÐ¹Ðº\")\npartialPct   = input.float(40.0, \"% Ð½Ð° Ð¿ÐµÑ€Ð²Ð¾Ð¼ ÑƒÑ€Ð¾Ð²Ð½Ðµ\", minval=10, maxval=90, step=5)\n\nmaxPositions = input.int(20, \"ÐœÐ°ÐºÑ Ð¾Ñ‚ÐºÑ€Ñ‹Ñ‚Ñ‹Ñ… Ð¿Ð¾Ð·Ð¸Ñ†Ð¸Ð¹\", minval=5, maxval=50)\nshowInfo     = input.bool(true, \"ðŸ“Š Ð˜Ð½Ñ„Ð¾-Ð¿Ð°Ð½ÐµÐ»ÑŒ\")\nsizeMode     = input.string(\"Original\", \"Ð Ð°Ð·Ð¼ÐµÑ€ Ð¿Ð¾Ð·Ð¸Ñ†Ð¸Ð¸\", \n               options=[\"Original\", \"Conservative\", \"Aggressive\"])\n\n//--------------------------\n// Ð˜ÐÐ”Ð˜ÐšÐÐ¢ÐžÐ Ð«\n//--------------------------\nvolumeMA = ta.sma(volume, volumeLength)\n\n//--------------------------\n// Ð”Ð˜ÐÐŸÐÐ—ÐžÐ\n//--------------------------\nhighLevel = ta.highest(high, rangeLen)\nlowLevel  = ta.lowest(low,  rangeLen)\n\ncanRange = not na(highLevel) and not na(lowLevel) and highLevel > lowLevel\n\nrangeMid = (highLevel + lowLevel) / 2.0\n\nplot(highLevel, \"Ð’ÐµÑ€Ñ…\", color=color.new(color.green, 0))\nplot(lowLevel,  \"ÐÐ¸Ð·\", color=color.new(color.red, 0))\nplot(rangeMid,  \"Ð¡ÐµÑ€ÐµÐ´Ð¸Ð½Ð°\", color=color.new(color.blue, 70))\n\n//--------------------------\n// Ð“Ð•ÐÐ•Ð ÐÐ¦Ð˜Ð¯ Ð¡Ð•Ð¢ÐšÐ˜\n//--------------------------\nstep = canRange ? (highLevel - lowLevel) / gridCount : 0.0\ncanTrade = step > 0\n\nvar float[] gridLevels = array.new_float()\narray.clear(gridLevels)\n\nif canTrade\n    for i = 0 to gridCount\n        level = lowLevel + step * i\n        array.push(gridLevels, level)\n\n//--------------------------\n// Ð ÐÐ—ÐœÐ•Ð  ÐŸÐžÐ—Ð˜Ð¦Ð˜Ð˜\n//--------------------------\nequity    = strategy.equity\nriskMoney = equity * (riskPct / 100.0)\n\nfloat divisor = 2.0\nif sizeMode == \"Conservative\"\n    divisor := 3.0\nelse if sizeMode == \"Aggressive\"\n    divisor := 1.5\n\nposSize = canTrade and step > 0 ? (riskMoney / (step * divisor)) : 0.0\n\n//--------------------------\n// Ð¤Ð˜Ð›Ð¬Ð¢Ð Ð«\n//--------------------------\nbool volumeOk = true\nif useVolumeFilter\n    volumeOk := na(volumeMA) ? true : volume > volumeMA * volumeMult\n\nbool longFiltersOk = volumeOk\n\n//--------------------------\n// ÐšÐžÐÐ¢Ð ÐžÐ›Ð¬ ÐŸÐžÐ—Ð˜Ð¦Ð˜Ð™\n//--------------------------\nvar int lossStreak = 0\n\nif strategy.closedtrades > strategy.closedtrades[1]\n    lastProfit = strategy.netprofit - strategy.netprofit[1]\n    if lastProfit < 0\n        lossStreak += 1\n    else\n        lossStreak := 0\n\nopenPositions = strategy.opentrades\ncanOpenNew    = openPositions < maxPositions and lossStreak < 3\n\n//--------------------------\n// Ð¢ÐžÐ Ð“ÐžÐ’ÐÐ¯ Ð›ÐžÐ“Ð˜ÐšÐ (Ð¢ÐžÐ›Ð¬ÐšÐž Ð›ÐžÐÐ“Ð˜, ÐÐ¡Ð˜ÐœÐœÐ•Ð¢Ð Ð˜Ð§ÐÐ«Ð™ TP)\n//--------------------------\nif canTrade and canOpenNew\n    levelsCount = array.size(gridLevels)\n    for i = 0 to levelsCount - 1\n        level = array.get(gridLevels, i)\n\n        bool longCross = close[1] > level and close <= level\n        bool levelInBuyZone = not buyLowerHalfOnly or level <= rangeMid\n\n        if longCross and longFiltersOk and levelInBuyZone\n            entryId = \"L\" + str.tostring(i)\n            strategy.entry(entryId, strategy.long, qty=posSize)\n\n            // ---- Ñ€Ð°ÑÑ‡Ñ‘Ñ‚ Ð°ÑÐ¸Ð¼Ð¼ÐµÑ‚Ñ€Ð¸Ñ‡Ð½Ð¾Ð³Ð¾ TP ----\n            // Ð±Ð°Ð·Ð¾Ð²Ñ‹Ð¹ Ð¸Ð½Ð´ÐµÐºÑ Ñ†ÐµÐ»Ð¸: i + tpLevels\n            targetIndex = i + tpLevels\n            if targetIndex > levelsCount - 1\n                targetIndex := levelsCount - 1\n\n            tpBase = array.get(gridLevels, targetIndex)\n            tpCap  = highLevel * (1 + tpPct / 100.0)\n            tpMain = math.min(tpBase, tpCap)\n\n            if usePartialTP\n                // ÐŸÐµÑ€Ð²Ð°Ñ Ñ‡Ð°ÑÑ‚ÑŒ â€” Ð½Ð° Ð±Ð»Ð¸Ð¶Ð°Ð¹ÑˆÐµÐ¼ ÑƒÑ€Ð¾Ð²Ð½Ðµ (ÐµÑÐ»Ð¸ Ð¾Ð½ ÐµÑÑ‚ÑŒ)\n                tp1Index = math.min(i + 1, levelsCount - 1)\n                tp1 = array.get(gridLevels, tp1Index)\n\n                strategy.exit(\"TP1_\" + str.tostring(i),from_entry = entryId,qty_percent = partialPct,limit = tp1)\n\n                // ÐžÑÑ‚Ð°Ñ‚Ð¾Ðº â€” Ð½Ð° ÑƒÐ´Ð°Ð»Ñ‘Ð½Ð½Ð¾Ð¹ Ñ†ÐµÐ»Ð¸\n                strategy.exit(\"TP2_\" + str.tostring(i),from_entry = entryId,limit = tpMain)\n            else\n                // Ð‘ÐµÐ· Ñ‡Ð°ÑÑ‚Ð¸Ñ‡Ð½Ð¾Ð³Ð¾ â€” Ð²ÑÑ‘ ÑÑ€Ð°Ð·Ñƒ Ð½Ð° Ð´Ð°Ð»ÑŒÐ½ÑŽÑŽ Ñ†ÐµÐ»ÑŒ\n                strategy.exit(\"TP_\" + str.tostring(i),from_entry = entryId,limit = tpMain)\n\n//--------------------------\n// ÐÐ’ÐÐ Ð˜Ð™ÐÐ«Ð• Ð’Ð«Ð¥ÐžÐ”Ð«\n//--------------------------\nif canRange and low < lowLevel * (1 - stopPct / 100.0)\n    strategy.close_all(\"ðŸ”´ Stop\")\n    lossStreak := 0\n\nif canRange and high > highLevel * (1 + tpPct / 100.0)\n    strategy.close_all(\"ðŸŸ¢ Global TP\")\n    lossStreak := 0\n\nif lossStreak >= 3 and strategy.opentrades > 0\n    strategy.close_all(\"ðŸ›‘ 3 losses\")\n    lossStreak := 0\n\n//--------------------------\n// Ð˜ÐÐ¤Ðž-ÐŸÐÐÐ•Ð›Ð¬\n//--------------------------\ncurrentPosValue = math.abs(strategy.position_size * close)\ncurrentExposure = equity > 0 ? (currentPosValue / equity) * 100 : 0\n\nvar table info = table.new(position.top_right, 2, 8, \n                           border_width=1, \n                           bgcolor=color.new(color.black, 85))\n\nif showInfo and barstate.islast\n    table.cell(info, 0, 0, \"ðŸ’° ÐšÐ°Ð¿Ð¸Ñ‚Ð°Ð»\", text_color=color.white)\n    profitColor = equity >= 10000 ? color.lime : color.red\n    table.cell(info, 1, 0, \"$\" + str.tostring(equity, \"#,###\"), text_color=profitColor)\n    \n    table.cell(info, 0, 1, \"ðŸ“Š ÐŸÐ¾Ð·Ð¸Ñ†Ð¸Ñ\", text_color=color.white)\n    table.cell(info, 1, 1, str.tostring(currentExposure, \"#.#\") + \"%\", text_color=color.aqua)\n    \n    table.cell(info, 0, 2, \"ðŸ“ Ð¨Ð°Ð³\", text_color=color.white)\n    table.cell(info, 1, 2, str.tostring(step, \"#.####\"), text_color=color.white)\n    \n    table.cell(info, 0, 3, \"ðŸŽ¯ ÐžÑ‚ÐºÑ€Ñ‹Ñ‚Ð¾\", text_color=color.white)\n    table.cell(info, 1, 3, str.tostring(openPositions), text_color=color.white)\n    \n    table.cell(info, 0, 4, \"ðŸ’¸ ÐŸÑ€Ð¸Ð±Ñ‹Ð»ÑŒ\", text_color=color.white)\n    netProfit = strategy.netprofit\n    npColor = netProfit > 0 ? color.lime : color.red\n    table.cell(info, 1, 4, \"$\" + str.tostring(netProfit, \"#,###\"), text_color=npColor)\n\n    table.cell(info, 0, 5, \"Vol Ñ„Ð¸Ð»ÑŒÑ‚Ñ€\", text_color=color.white)\n    volText  = useVolumeFilter ? (volumeOk ? \"OK\" : \"LOW\") : \"Off\"\n    volColor = not useVolumeFilter ? color.gray : (volumeOk ? color.lime : color.red)\n    table.cell(info, 1, 5, volText, text_color=volColor)\n\n    table.cell(info, 0, 6, \"TP ÑƒÑ€Ð¾Ð²Ð½Ð¸\", text_color=color.white)\n    table.cell(info, 1, 6, str.tostring(tpLevels), text_color=color.white)\n\n    table.cell(info, 0, 7, \"Ð¤Ð¸Ð»ÑŒÑ‚Ñ€Ñ‹\", text_color=color.white)\n    allOk = longFiltersOk\n    allColor = allOk ? color.lime : color.red\n    table.cell(info, 1, 7, allOk ? \"ON\" : \"OFF\", text_color=allColor)\n\n//--------------------------\n// Ð’Ð˜Ð—Ð£ÐÐ›Ð˜Ð—ÐÐ¦Ð˜Ð¯ Ð’Ð¥ÐžÐ”ÐžÐ’\n//--------------------------\nplotshape(strategy.position_size > strategy.position_size[1] and strategy.position_size > 0, \n         \"ðŸŸ¢\", shape.triangleup, location.belowbar, color.lime, size=size.tiny)\n"
  },
  {
    "url": "38ULXoLU-Oracle-Protocol-Arch-Public-Testing-Clone",
    "name": "Oracle Protocol â€” Arch Public (Testing Clone) ",
    "description": "Oracle Protocol â€” Arch Public Series (testing clone)\n\nThis model implements the Arch Public Oracle structure: a systematic accumulation-and-distribution engine built around a dynamic Accumulation Cost Base (ACB), strict profit-gate exit logic, and a capital-bounded flywheel reinvestment system.\nIt is designed for transparent execution, deterministic behaviour, and rule-based position management.\n\nCore Function Set\n1. Accumulation Framework (ACB-Driven)\n\nThe accumulation engine evaluates market movement against defined entry conditions, including:\n\nPercentage-based entry-drop triggers\n\nOptional buy-below-ACB mode\n\nCapital-gated entries tied to available ledger balance\n\nFixed-dollar and min-dollar entry rules (as seen in Arch public materials)\n\nAutomated sizing through flywheel capital\n\nRange-bounded ledger for controlled backtesting input\n\nEach qualifying buy updates the live ACB, maintains the internal ledger, and forms the next reference point for exit evaluation.\nNo forecasting mechanisms are included.\n\n2. Profit-Gate Exit System\n\nExits are governed by the standard Arch public approach:\n\nA sealed ACB reference for threshold evaluation\n\nOptional live-ACB visibility\n\nProfit-gate triggers defined per asset class\n\nCandle-confirmation integration (â€œProfitGate + Candleâ€ mode)\n\nDistribution only when the smallest active threshold is met\n\nThis provides a consistent cadence with published Arch diagrams and PDFs.\n\n3. Once-Per-Rally Governance\n\nAfter a distribution, the algorithm locks until price retraces below the most recent accumulation base.\nOnly after re-arming can the next profit gate activate.\nThis prevents over-frequency selling and aligns with the public-domain Oracle behaviour.\n\n4. Quiet-Bars & Threshold Cluster Control\n\nA volatility-stabilisation layer prevents multiple exits from micro-fluctuations or transient spikes.\nThis ensures clean execution during fast markets and high volatility.\n\n5. Flywheel Reinvestment\n\nDistribution proceeds automatically return to the capital pool where permitted, creating a closed system of:\n\nEntry sizing\n\nExit proceeds\n\nLedger-managed capital state\n\nAll sizing respects capital boundaries and does not breach dollar floors or overrides.\n\n6. Automation Hooks and Integration\n\nThe script exposes:\n\n3Commas-compatible JSON sizing\n\nEntry/exit signalling via alertcondition()\n\nDeterministic event reporting suitable for external automation\n\nThis allows consistent deployment across automated execution environments.\n\n7. Visual Tooling\n\nOptional displays include:\n\nLive ACB line\n\nExit-guide markers\n\nCapital, state, and ledger panels\n\nRealized/unrealized outcome tracking based on internal logic only\n\nVisual components do not influence execution rules.\n\nOperating Notes\n\nThis model is rule-based, deterministic, and non-predictive.\nIt executes only according to the explicit thresholds, capital limits, and state transitions defined within the script.\nNo discretionary or forward-looking logic is included.",
    "image_url": "38ULXoLU",
    "author": "gleefulJaguar47150",
    "likes": 20,
    "type": "strategy",
    "created": "2025-11-24",
    "updated": "2025-11-24",
    "source": "//@version=6\r\n// ============================================================================\r\n//  ORACLE PROTOCOL â€” ARCH PUBLIC clone (Standalone) â€” CLEAN-PUB STYLE (derived)\r\n//  Variant: v1.9v-standalone (publish-ready)  25/11/2025\r\n//  Notes:\r\n//   - Keeps your v1.9v canonical script intact (this is a separate modified copy).\r\n//   - Single exit mode: ProfitGate + Candle (per-candle) â€” no selector.\r\n//   - Live ACB plot toggle only (sealed ACB still operates internally but is not shown).\r\n//   - No freeze-point markers plotted.\r\n//   - Sizing: flywheel dynamic sizing remains the primary source but fixed-dollar entry\r\n//     and min-$ overrides remain available (as in Arch public PDFs/screenshots).\r\n//   - Volatility Engine (VE) applies ONLY to entries; exit-side VE removed.\r\n//   - Manual equity top-up removed (flywheel auto-updates cash).\r\n//   - VE ATR length and max-vol fields are fixed (not exposed in UI).\r\n// ============================================================================\r\n\r\nstrategy(\"Oracle Protocol â€” Arch Public (Clone) â€¢ v1.9v-standalone (publish)\",\r\n     overlay=true,\r\n     initial_capital=100000,\r\n     commission_type=strategy.commission.percent,\r\n     commission_value=0.1,\r\n     pyramiding=9999,\r\n     calc_on_every_tick=true,\r\n     process_orders_on_close=true)\r\n\r\n// ============================================================================\r\n// 0) BACKTEST WINDOW\r\n// ============================================================================\r\ngrp_bt   = \"Backtest Range\"\r\nbt_start = input.time(timestamp(\"2021-02-01\"), \"Backtest Start Date\", group = grp_bt)\r\nbt_end   = input.time(timestamp(\"2025-10-05\"), \"Backtest End Date\", group = grp_bt)\r\nin_range = time >= bt_start and time <= bt_end\r\n\r\n// ============================================================================\r\n// 1) PRESETS (Arch PDFs)\r\n// ============================================================================\r\ngrp_oracle  = \"Oracle â€” Core\"\r\noraclePreset = input.string(\r\n     \"BTC â€¢ Cycle Accumulation\",\r\n     \"Recipe Preset\",\r\n     options = [\r\n         \"BTC â€¢ Cycle Accumulation\",\r\n         \"BTC â€¢ Cycle Swing Arbitrage\",\r\n         \"BTC â€¢ Short Target Accumulation\",\r\n         \"BTC â€¢ Short Target Arbitrage\",\r\n         \"ETH â€¢ Volatility Harvesting\",\r\n         \"SOL â€¢ Volatility Harvesting\",\r\n         \"XRP â€¢ Volatility Harvesting\",\r\n         \"SUI â€¢ Volatility Harvesting\"\r\n     ],\r\n     group = grp_oracle)\r\n\r\nvar float longThreshPct      = 0.0\r\nvar float exitThreshPct      = 0.0\r\nvar bool  onlySellAboveCost  = true\r\nvar bool  recipe_buyBelowACB = false\r\nvar float sellProfitGatePct  = 0.0\r\nvar float entryPct           = 0.0\r\nvar float exitPct            = 0.0\r\nvar float fixedEntryUsd      = 0.0\r\nvar float fixedExitUsd       = 0.0\r\n\r\nif oraclePreset == \"BTC â€¢ Cycle Accumulation\"\r\n    longThreshPct       := 5.0\r\n    exitThreshPct       := 3.9\r\n    onlySellAboveCost   := true\r\n    recipe_buyBelowACB  := false\r\n    sellProfitGatePct   := 50.0\r\n    entryPct            := 6.0\r\n    exitPct             := 1.0\r\n    fixedEntryUsd       := 500\r\n    fixedExitUsd        := 500\r\nelse if oraclePreset == \"BTC â€¢ Cycle Swing Arbitrage\"\r\n    longThreshPct       := 5.9\r\n    exitThreshPct       := 3.5\r\n    onlySellAboveCost   := true\r\n    recipe_buyBelowACB  := false\r\n    sellProfitGatePct   := 49.0\r\n    entryPct            := 10.0\r\n    exitPct             := 50.0\r\n    fixedEntryUsd       := 10000\r\n    fixedExitUsd        := 15000\r\nelse if oraclePreset == \"BTC â€¢ Short Target Accumulation\"\r\n    longThreshPct       := 3.1\r\n    exitThreshPct       := 2.5\r\n    onlySellAboveCost   := true\r\n    recipe_buyBelowACB  := false\r\n    sellProfitGatePct   := 30.0\r\n    entryPct            := 10.0\r\n    exitPct             := 10.0\r\n    fixedEntryUsd       := 6000\r\n    fixedExitUsd        := 5000\r\nelse if oraclePreset == \"BTC â€¢ Short Target Arbitrage\"\r\n    longThreshPct       := 3.1\r\n    exitThreshPct       := 2.5\r\n    onlySellAboveCost   := true\r\n    recipe_buyBelowACB  := true\r\n    sellProfitGatePct   := 75.0\r\n    entryPct            := 10.0\r\n    exitPct             := 100.0\r\n    fixedEntryUsd       := 10000\r\n    fixedExitUsd        := 5000\r\nelse if oraclePreset == \"ETH â€¢ Volatility Harvesting\"\r\n    longThreshPct       := 4.5\r\n    exitThreshPct       := 5.0\r\n    onlySellAboveCost   := true\r\n    recipe_buyBelowACB  := true\r\n    sellProfitGatePct   := 30.0\r\n    entryPct            := 15.0\r\n    exitPct             := 40.0\r\n    fixedEntryUsd       := 6000\r\n    fixedExitUsd        := 20000\r\nelse if oraclePreset == \"SOL â€¢ Volatility Harvesting\"\r\n    longThreshPct       := 5.0\r\n    exitThreshPct       := 5.0\r\n    onlySellAboveCost   := true\r\n    recipe_buyBelowACB  := false\r\n    sellProfitGatePct   := 35.0\r\n    entryPct            := 7.0\r\n    exitPct             := 5.0\r\n    fixedEntryUsd       := 5000\r\n    fixedExitUsd        := 5000\r\nelse if oraclePreset == \"XRP â€¢ Volatility Harvesting\"\r\n    longThreshPct       := 4.5\r\n    exitThreshPct       := 10.0\r\n    onlySellAboveCost   := true\r\n    recipe_buyBelowACB  := false\r\n    sellProfitGatePct   := 10.0\r\n    entryPct            := 17.0\r\n    exitPct             := 50.0\r\n    fixedEntryUsd       := 8000\r\n    fixedExitUsd        := 5000\r\nelse if oraclePreset == \"SUI â€¢ Volatility Harvesting\"\r\n    longThreshPct       := 5.0\r\n    exitThreshPct       := 5.0\r\n    onlySellAboveCost   := true\r\n    recipe_buyBelowACB  := false\r\n    sellProfitGatePct   := 10.0\r\n    entryPct            := 5.0\r\n    exitPct             := 10.0\r\n    fixedEntryUsd       := 5000\r\n    fixedExitUsd        := 15000\r\n\r\n// ============================================================================\r\n// 2) EXTRAS & VOLATILITY SPLITS (CLEAN PUBLIC VARIANTS)\r\n//    - Volatility engine inputs are fixed and not exposed in the UI\r\n// ============================================================================\r\n// UI group for extras (keeps flywheel toggle visible)\r\ngrp_extras = \"Oracle â€” Extras\"\r\nuseFlywheel          = input.bool(true,  \"Reinvest Realized Profits (Flywheel)\", group = grp_extras)\r\n// Volatility engine: ENTRY only (VE params fixed, not shown)\r\nuseVolEngineEntry    = input.bool(true,  \"Enable Volatility Engine (Entries only)\", group = grp_extras)\r\n\r\n// Fixed/hidden VE parameters (not exposed in UI per your request)\r\natrLen_fixed = 14\r\nmaxVolAdjPct_fixed = 40.0\r\n\r\n// NOTE: manual_equity_topup removed for publish variant â€” flywheel handles auto top-up\r\n\r\nbuyBelowMode  = input.string(\r\n     \"Use Recipe Setting\",\r\n     \"Buy Below ACB Mode\",\r\n     options = [\"Use Recipe Setting\", \"Force Buy Below ACB\", \"Allow Buys Above ACB\"],\r\n     group = grp_extras)\r\n\r\n// ============================================================================\r\n// 3) QUIET BARS (cluster seal) â€” unchanged behavior, UI visible\r\n// ============================================================================\r\ngrp_qb = \"Oracle â€” Quiet Bars (Cluster Seal)\"\r\nuseQuietBars   = input.bool(true, \"Enable Quiet-Bars Seal\", group=grp_qb)\r\nquietBars      = input.int(10,   \"Quiet Bars (no eligible buys)\", minval=1, group=grp_qb)\r\n\r\n// ============================================================================\r\n// 4) SELL MODE â€” SINGLE ARCH EXIT (ProfitGate + Candle) ONLY\r\n//    (no selector; fixed behavior to match Arch public)\r\n// ============================================================================\r\ngrp_sell = \"Oracle â€” Sell Behaviour\"\r\n// no sellMode selector in this publish variant â€” fixed logic below\r\n\r\n// ============================================================================\r\n// 5) DISPLAY & PLOTS (simplified)\r\n//    - only Live ACB toggle remains visible.\r\n//    - sealed ACB and freeze points are intentionally not plotted.\r\n// ============================================================================\r\ngrp_display    = \"Oracle â€” Display\"\r\nshowLiveACB    = input.bool(true,  \"Show Live ACB\", group = grp_display)\r\nacbColor       = input.color(color.new(color.yellow, 0), \"ACB Line Color\", group = grp_display)\r\nshowExitGuides = input.bool(false, \"Show Exit Guide Lines\",  group = grp_display)\r\n\r\n// ============================================================================\r\n// 6) 3C SIZING & MINIMUMS / OVERRIDES\r\n//    - primary sizing source is flywheel (cash ledger).\r\n//    - but fixed-entry USD and min-$ overrides remain (per Arch public).\r\n// ============================================================================\r\ngrp_3c_sz = \"Oracle â€” Sizing\"\r\nuse3C  = input.bool(true, \"Enable 3Commas JSON Alerts\", group = grp_3c_sz)\r\nbotTag = input.string(\"ORACLE\", \"Bot Tag / Pair Hint\",   group = grp_3c_sz)\r\n\r\n// Keep min$/fixed entry & exit overrides visible (Arch style)\r\nuseMinEntry     = input.bool(true,  \"Use Min $ on Entry\",                  group = grp_oracle)\r\nuseMinExit      = input.bool(true,  \"Use Min $ on Exit\",                   group = grp_oracle)\r\nmanualMinEntry  = input.float(0.0,  \"Manual Min $ Entry (0 = use recipe)\", group = grp_oracle, step = 10)\r\nmanualMinExit   = input.float(0.0,  \"Manual Min $ Exit (0 = use recipe)\",  group = grp_oracle, step = 10)\r\n\r\ngrp_override      = \"Oracle â€” Amount Override\"\r\nentryUsd_override = input.float(0.0, \"Entry USD Override (0 = none)\", group = grp_override, step = 10)\r\nexitUsd_override  = input.float(0.0, \"Exit USD Override (0 = none)\",  group = grp_override, step = 10)\r\n\r\n// ============================================================================\r\n// 7) VOLATILITY ENGINE VALUES (ENTRY only)\r\n//    - VE uses fixed internal params (atrLen_fixed, maxVolAdjPct_fixed).\r\n//    - VE not applied to exits in this publish variant.\r\n// ============================================================================\r\natrVal        = ta.atr(atrLen_fixed)\r\nvolPct        = atrVal / close * 100.0\r\nvolAdj        = math.min(volPct, maxVolAdjPct_fixed)\r\nlongThreshEff = longThreshPct * (useVolEngineEntry ? (1 + volAdj/100.0) : 1)\r\n// exit threshold is NOT adjusted by VE in this variant:\r\nexitThreshEff = exitThreshPct\r\n\r\n// ============================================================================\r\n// 8) POSITION STATE & HELPERS\r\n// ============================================================================\r\nvar float q        = 0.0          // live coin quantity\r\nvar float cost     = 0.0          // live position cost ($)\r\nvar float live_acb = 0.0          // live average cost (cost / q)\r\nvar float realized = 0.0\r\n\r\n// Flywheel cash ledger (realised cash available for reinvest) â€” auto only\r\nvar float cash = na\r\nif na(cash)\r\n    cash := strategy.initial_capital\r\n\r\n// Cluster / gating state (sealed base) â€” sealed_acb still used internally but not shown\r\nvar bool  clusterOpen      = false\r\nvar float sealed_acb       = na     // frozen when a cluster seals (sealed accumulation base)\r\nvar int   lastEntryBar     = na\r\nvar int   lastEligibleBuyBar = na   // for quiet-bars seal\r\nvar int   sell_steps_done  = 0      // number of incremental exits already taken since gate armed\r\nvar float last_sell_ref    = na     // last sell price used for pullback re-arm (not used here)\r\nvar bool  mode_single_sold = false  // lock for Single per Rally (internal use)\r\n\r\n// Helpers (array returns)\r\nf_add_fill(_qty, _px, _q, _cost) =>\r\n    // returns newQty, newCost, newACB\r\n    _newCost = _cost + _qty * _px\r\n    _newQty  = _q + _qty\r\n    _newACB  = _newQty > 0 ? _newCost / _newQty : 0.0\r\n    array.from(_newQty, _newCost, _newACB)\r\n\r\nf_reduce_fill(_qty, _px, _q, _cost) =>\r\n    // returns newQty, newCost, newACB, sellVal, costReduced, proportion\r\n    _sellVal     = _qty * _px\r\n    _prop        = _q > 0 ? _qty / _q : 0.0\r\n    _costReduced = _cost * _prop\r\n    _newCost     = _cost - _costReduced\r\n    _newQty      = _q - _qty\r\n    _newACB      = _newQty > 0 ? _newCost / _newQty : 0.0\r\n    array.from(_newQty, _newCost, _newACB, _sellVal, _costReduced, _prop)\r\n\r\n// ============================================================================\r\n// 9) BUY SIGNALS & BUY-BELOW MODE\r\n// ============================================================================\r\ndropFromPrev = close[1] != 0 ? (close - close[1]) / close[1] * 100.0 : 0.0\r\nwantBuy      = dropFromPrev <= -longThreshEff\r\n\r\nneedBuyBelow = recipe_buyBelowACB\r\nif buyBelowMode == \"Force Buy Below ACB\"\r\n    needBuyBelow := true\r\nelse if buyBelowMode == \"Allow Buys Above ACB\"\r\n    needBuyBelow := false\r\ncanBuyBelow = not needBuyBelow or (needBuyBelow and (live_acb == 0 or close < live_acb))\r\n\r\n// Track â€œeligibleâ€ buys (quiet-bars gate references opportunity, not just fills)\r\nif wantBuy and canBuyBelow\r\n    lastEligibleBuyBar := bar_index\r\n\r\n// ============================================================================\r\n// 10) SIZING (flywheel-driven; keep fixed/min-dollar options for entry & exit)\r\n// ============================================================================\r\nbaseAcct   = cash  // flywheel only in this variant\r\n// entry as percentage of baseAcct (dynamic) with fixed/min-dollar fallback (Arch-style)\r\nentryUsd   = baseAcct * (entryPct / 100.0)\r\n\r\n// Entry min floor (keep manual/fixed options per Arch)\r\nif useMinEntry\r\n    entryFloor = manualMinEntry > 0 ? manualMinEntry : fixedEntryUsd\r\n    entryUsd   := math.max(entryUsd, entryFloor)\r\n\r\n// override priority\r\nentryUsd := entryUsd_override > 0 ? entryUsd_override : entryUsd\r\n\r\n// entry qty\r\neQty = close > 0 ? entryUsd / close : 0.0\r\n\r\n// Exit sizing: percentage of HOLDINGS (Arch) with min-$ fallback (unchanged)\r\nexitQty_pct = q * (exitPct / 100.0)\r\nexitFloorQty = close > 0 ? ( (manualMinExit > 0 ? manualMinExit : fixedExitUsd) / close ) : 0.0\r\nxQty_base = math.max(exitQty_pct, exitFloorQty)\r\nxQty = math.min(xQty_base, q)\r\nxQty := exitUsd_override > 0 and close > 0 ? math.min(exitUsd_override / close, q) : xQty\r\n\r\n// ============================================================================\r\n// 11) ENTRY â€” opens/extends accumulation cluster; resets SELL steps\r\n//       Cash gate: only execute buy if cash >= entryUsd and on confirmed bar close\r\n// ============================================================================\r\nnewEntry = false\r\nentryCost = eQty * close\r\nhasCash = entryCost > 0 and cash >= entryCost\r\n\r\nif barstate.isconfirmed and in_range and wantBuy and canBuyBelow and eQty > 0 and hasCash\r\n    strategy.entry(\"ORACLE-LONG\", strategy.long, qty=eQty, comment=\"ORACLE-BUY\")\r\n    _fill = f_add_fill(eQty, close, q, cost)\r\n    q     := array.get(_fill, 0)\r\n    cost  := array.get(_fill, 1)\r\n    live_acb := array.get(_fill, 2)\r\n    cash  -= entryCost\r\n    lastEntryBar       := bar_index\r\n    lastEligibleBuyBar := bar_index\r\n    if not clusterOpen\r\n        clusterOpen := true\r\n        sealed_acb := na\r\n        sell_steps_done := 0\r\n        mode_single_sold := false\r\n        last_sell_ref := na\r\n    // set sealed_acb initial for cluster if na\r\n    if na(sealed_acb)\r\n        sealed_acb := live_acb\r\n    newEntry := true\r\n\r\n// ============================================================================\r\n// 12) CLUSTER SEAL â€” Exit-Threshold OR Quiet-Bars\r\n//    - On sealing, we freeze sealed_acb internally (not plotted).\r\n// ============================================================================\r\nriseFromLiveACB   = live_acb  > 0 ? (close - live_acb ) / live_acb  * 100.0 : 0.0\r\nsealByThresh  = riseFromLiveACB >= exitThreshEff\r\nbarsSinceElig = na(lastEligibleBuyBar) ? 10000 : (bar_index - lastEligibleBuyBar)\r\nsealByQuiet   = useQuietBars and (barsSinceElig >= quietBars)\r\n\r\nsealed_changed = false\r\nif clusterOpen and (sealByThresh or sealByQuiet)\r\n    clusterOpen := false\r\n    // freeze sealed base as the last live_acb at seal time (preserve cycle anchor)\r\n    sealed_acb := live_acb\r\n    sell_steps_done := 0\r\n    mode_single_sold := false\r\n    last_sell_ref := na\r\n    sealed_changed := true\r\n\r\n// ============================================================================\r\n// 13) SELL LOGIC â€” SINGLE ARCH EXIT: ProfitGate + Candle (Per-Candle)\r\n//    - Profit gate base: use sealed refBase if present, otherwise live_acb (no toggle).\r\n//    - VE not applied to exits in this variant.\r\n// ============================================================================\r\nrefBase      = na(sealed_acb) ? live_acb : sealed_acb\r\nriseFromRef  = refBase > 0 ? (close - refBase) / refBase * 100.0 : 0.0\r\nsellAboveOK  = not onlySellAboveCost or close > live_acb\r\n\r\nprofitRefBase = refBase  // sealed if available, else live_acb (no UI toggle in this variant)\r\n\r\n// Basic profit gate price/boolean (uses profitRefBase)\r\nprofitGateLevelPrice = profitRefBase * (1 + sellProfitGatePct / 100.0)\r\nprofitGateCrossed = profitRefBase > 0 ? (close >= profitGateLevelPrice) : false\r\n\r\n// Candle-based rise (percent move relative to previous close)\r\nriseFromPrev = close[1] != 0 ? (close - close[1]) / close[1] * 100.0 : 0.0\r\ncandleRiseOK = riseFromPrev >= exitThreshEff\r\n\r\n// Final allow-sell boolean for this publish variant (ProfitGate + Candle)\r\nvar bool allowSellThisBar = false\r\nallowSellThisBar := false\r\nallowSellThisBar := profitGateCrossed and candleRiseOK and xQty > 0 and q > 0 and sellAboveOK and barstate.isconfirmed and in_range\r\n\r\n// Perform sell if allowed\r\nactualExitQty = 0.0\r\nif allowSellThisBar\r\n    actualExitQty := xQty\r\n    if actualExitQty > 0\r\n        strategy.close(\"ORACLE-LONG\", qty = actualExitQty, comment = \"ORACLE-SELL\")\r\n        _r = f_reduce_fill(actualExitQty, close, q, cost)\r\n        q       := array.get(_r, 0)\r\n        cost    := array.get(_r, 1)\r\n        live_acb := array.get(_r, 2)\r\n        sellVal =  array.get(_r, 3)\r\n        cRed    =  array.get(_r, 4)\r\n        tradePnL = sellVal - cRed\r\n        realized += tradePnL\r\n        cash     += sellVal\r\n        sell_steps_done += 1\r\n        last_sell_ref := close\r\n        mode_single_sold := true\r\n        if q <= 0\r\n            // fully sold - reset sealed base and steps (internal)\r\n            sealed_acb := na\r\n            sell_steps_done := 0\r\n            mode_single_sold := false\r\n            last_sell_ref := na\r\n\r\n// Re-arm logic (simplified): allow new sells only after retrace below refBase by exitThreshEff or if fully sold\r\nif barstate.isconfirmed and in_range\r\n    if mode_single_sold\r\n        retrace_condition = not na(refBase) ? (close < refBase * (1 - exitThreshEff/100.0)) : false\r\n        if retrace_condition or q == 0\r\n            mode_single_sold := false\r\n            sell_steps_done := 0\r\n            last_sell_ref := na\r\n\r\n// ============================================================================\r\n// 14) BALANCES & 3C JSON (flywheel-based sizing)\r\n// ============================================================================\r\ncash_on_hand = math.max(cash, 0)\r\ncoin_value   = q * close\r\ntotal_equity = cash_on_hand + coin_value\r\n\r\nbase_for_3c = cash_on_hand  // flywheel only in this publish variant\r\n\r\nentryUsd_3c = base_for_3c * (entryPct / 100.0)\r\nif useMinEntry\r\n    entryUsd_3c := math.max(entryUsd_3c, (manualMinEntry > 0 ? manualMinEntry : fixedEntryUsd))\r\nentryUsd_3c := entryUsd_override > 0 ? entryUsd_override : entryUsd_3c\r\n\r\nif use3C and newEntry\r\n    entry_json = '{\"action\":\"entry\",\"source\":\"oracle\",\"tag\":\"' + botTag + '\",\"side\":\"buy\",\"quote_size\":' + str.tostring(entryUsd_3c, format.mintick) + ',\"price\":' + str.tostring(close, format.mintick) + '}'\r\n    alert(entry_json, alert.freq_once_per_bar_close)\r\n\r\nif use3C and allowSellThisBar and actualExitQty > 0\r\n    exitNotional = actualExitQty * close\r\n    exitNotional := exitUsd_override > 0 ? exitUsd_override : exitNotional\r\n    exit_json = '{\"action\":\"exit\",\"source\":\"oracle\",\"tag\":\"' + botTag + '\",\"side\":\"sell\",\"quote_size\":' + str.tostring(exitNotional, format.mintick) + ',\"price\":' + str.tostring(close, format.mintick) + '}'\r\n    alert(exit_json, alert.freq_once_per_bar_close)\r\n\r\n// ============================================================================\r\n// 15) PLOTS (Data Window + Live ACB only + optional guides)\r\n//    - Sealed ACB and freeze markers intentionally NOT plotted in this variant.\r\n// ============================================================================\r\nplot(strategy.initial_capital, title=\"Initial Capital\",  color=color.white, display=display.data_window)\r\nplot(q,            title=\"Oracle Coin Qty\",    precision = 6,  display=display.data_window)\r\nplot(cost,         title=\"Oracle Position Cost\", display=display.data_window)\r\nplot(coin_value,   title=\"Oracle Coin Value\",    display=display.data_window)\r\nplot(cash_on_hand, title=\"Oracle Cash On Hand\",  display=display.data_window)\r\nplot(total_equity, title=\"Oracle Total Equity\",  display=display.data_window)\r\n\r\nplot(live_acb > 0 and showLiveACB ? live_acb : na, title=\"Live ACB\", color=color.new(color.orange,0), linewidth=2, style=plot.style_line)\r\n\r\n// Exit guide lines reference refBase but are optional (kept for debugging/visual confirmation)\r\nguide_exit_line = showExitGuides and not na(refBase) ? refBase * (1 + exitThreshEff/100.0) : na\r\nguide_gate_line = showExitGuides and not na(refBase) ? refBase * (1 + sellProfitGatePct/100.0) : na\r\nplot(guide_exit_line, title=\"Exit Threshold Line\", display=showExitGuides ? display.all : display.none, linewidth=1, style=plot.style_linebr)\r\nplot(guide_gate_line, title=\"Profit Gate Line (ref base)\", display=showExitGuides ? display.all : display.none, linewidth=1, style=plot.style_linebr)\r\n\r\n// Also plot the profit gate price computed from profitRefBase (if guides enabled)\r\nplot(not na(profitRefBase) and showExitGuides ? profitRefBase * (1 + sellProfitGatePct/100.0) : na, title=\"Profit Gate (ref base)\", display=showExitGuides ? display.all : display.none, linewidth=1, style=plot.style_line)\r\n\r\n// ============================================================================\r\n// 16) PANELS (compact; retains most panel fields but hides sealed-specific info)\r\n// ============================================================================\r\nvar table t_oracle = table.new(position.top_right, 1, 28, border_width = 1)\r\nif barstate.islast\r\n    table.cell(t_oracle, 0, 0, \"ORACLE PROTOCOL (v1.9v-standalone)\", text_color = color.white, bgcolor = color.new(color.blue, 0))\r\n    table.cell(t_oracle, 0, 1, \"Preset: \" + oraclePreset, text_color = color.white, bgcolor = color.new(color.blue, 75))\r\n    table.cell(t_oracle, 0, 2, \"Live ACB: \" + (live_acb > 0 ? str.tostring(live_acb, format.mintick) : \"â€”\"), text_color = color.white, bgcolor = color.new(color.blue, 85))\r\n    table.cell(t_oracle, 0, 3, \"Qty: \" + str.tostring(q, format.mintick), text_color = color.white, bgcolor = color.new(color.blue, 85))\r\n    table.cell(t_oracle, 0, 4, \"Pos Cost: \" + str.tostring(cost, format.mintick), text_color = color.white, bgcolor = color.new(color.blue, 85))\r\n    table.cell(t_oracle, 0, 5, \"Coin Val: \" + str.tostring(coin_value, format.mintick), text_color = color.white, bgcolor = color.new(color.blue, 85))\r\n    table.cell(t_oracle, 0, 6, \"Cash: \" + str.tostring(cash_on_hand, format.mintick), text_color = color.white, bgcolor = color.new(color.blue, 85))\r\n    table.cell(t_oracle, 0, 7, \"Total Eq: \" + str.tostring(total_equity, format.mintick), text_color = color.white, bgcolor = color.new(color.blue, 85))\r\n    table.cell(t_oracle, 0, 8, \"Realized: \" + str.tostring(realized, format.mintick), text_color = color.white, bgcolor = color.new(color.blue, 85))\r\n    table.cell(t_oracle, 0, 9, \"Flywheel: \" + (useFlywheel ? \"ON\" : \"OFF\"), text_color = color.white, bgcolor = color.new(color.blue, 85))\r\n    table.cell(t_oracle, 0,10, \"Vol (Entry VE): \" + (useVolEngineEntry ? \"ON\" : \"OFF\"), text_color = color.white, bgcolor = color.new(color.blue, 85))\r\n    table.cell(t_oracle, 0,11, \"BuyBelow: \" + buyBelowMode, text_color = color.white, bgcolor = color.new(color.blue, 85))\r\n    table.cell(t_oracle, 0,12, \"3C: \" + (use3C ? \"ON\" : \"OFF\") + \" / Tag: \" + botTag, text_color = color.white, bgcolor = color.new(color.blue, 85))\r\n    table.cell(t_oracle, 0,13, \"Override: E=\" + (entryUsd_override>0?str.tostring(entryUsd_override):\"â€”\") + \" X=\" + (exitUsd_override>0?str.tostring(exitUsd_override):\"â€”\"), text_color = color.white, bgcolor = color.new(color.blue, 85))\r\n    table.cell(t_oracle, 0,14, \"Min$ E=\" + (useMinEntry ? (manualMinEntry>0?str.tostring(manualMinEntry):\"recipe\") : \"off\") + \" / X=\" + (useMinExit ? (manualMinExit>0?str.tostring(manualMinExit):\"recipe\") : \"off\"), text_color = color.white, bgcolor = color.new(color.blue, 85))\r\n    table.cell(t_oracle, 0,15, \"Entry $ (last calc): \" + str.tostring(entryUsd, format.mintick), text_color = color.white, bgcolor = color.new(color.blue, 85))\r\n    table.cell(t_oracle, 0,16, \"Exit Gate: \" + str.tostring(sellProfitGatePct) + \"%\", text_color = color.white, bgcolor = color.new(color.blue, 85))\r\n    table.cell(t_oracle, 0,17, \"Exit Thresh%: \" + str.tostring(exitThreshEff) + \"%\", text_color = color.white, bgcolor = color.new(color.blue, 85))\r\n    table.cell(t_oracle, 0,18, \"Last Sell Ref: \" + (na(last_sell_ref) ? \"â€”\" : str.tostring(last_sell_ref, format.mintick)), text_color = color.white, bgcolor = color.new(color.blue, 85))\r\n    table.cell(t_oracle, 0,19, \"Steps Done: \" + str.tostring(sell_steps_done), text_color = color.white, bgcolor = color.new(color.blue, 85))\r\n    table.cell(t_oracle, 0,20, \"CandleRise%: \" + str.tostring(riseFromPrev, format.mintick) + \"%\", text_color = color.white, bgcolor = color.new(color.blue, 85))\r\n    table.cell(t_oracle, 0,21, \"Cluster: \" + (clusterOpen ? \"OPEN\" : (na(sealed_acb) ? \"â€”\" : \"SEALED (hidden)\")), text_color = color.white, bgcolor = color.new(color.blue, 85))\r\n    table.cell(t_oracle, 0,22, \"Range: \" + str.format(\"{0,date,yyyy-MM-dd} â†’ {1,date,yyyy-MM-dd}\", bt_start, bt_end), text_color = color.white, bgcolor = color.new(color.blue, 85))\r\n\r\n// ============================================================================\r\n//  END - v1.9v-standalone (publish-ready)\r\n// ============================================================================\r\n"
  },
  {
    "url": "Ca7wJzIT-CSS-LFU-v0-1",
    "name": "CSS_LFU_v0.1",
    "description": "Overview:\nA multi-factor, market-adaptive swing strategy designed for intraday and short-term crypto trading. It synthesizes momentum, volatility, and trend signals into a unified composite score over a configurable lookback window. The strategy leverages a modular, signal-weighted approach to ensure robust entry timing while remaining compatible with human-in-the-loop validation and algorithmic execution.\n\nCore Modules:\n\nAJFFRSI (RSX-based Momentum): Measures smoothed price momentum with noise-reduction filters to detect crossovers relative to the QQE trailing stop.\n\nQQE (Quantitative Qualitative Easing RSI): A modified RSI with a dynamic trailing stop that adapts to short-term volatility, identifying exhaustion and potential reversal points.\n\nKeltner Channel Zones: Determines overextension relative to trend, providing buy/sell zones based on ATR-banded EMA.\n\nWaveTrend Oscillator: Confirms short-term swings and market direction through smoothed oscillator cross signals.\n\nRolling Composite Score: Aggregates module signals over a unified lookback (e.g., 144 bars) to normalize noise and capture consistent trends.\n\nSignal Logic:\n\nEach module outputs a discrete score (+1 / 0 / -1).\n\nThe rolling composite score sums all module scores over the lookback period.\n\nLong positions trigger when the rolling score meets or exceeds the long threshold.\n\nShort positions trigger when the rolling score meets or falls below the short threshold.\n\nMulti-dimensional signal aggregation reduces false positives from single indicators.\n\nRolling lookback ensures score normalization across different volatility regimes.\n\nHighly modular: easy to adapt modules or weights to different instruments or timeframes.\n\nFully compatible with automated execution pipelines, including custom exchange screener bots.\n\nUse Case:\nIdeal for quant-driven altcoin or multi-asset strategies where high-frequency validation is critical and sequential module weighting enhances trend flip detection.",
    "image_url": "Ca7wJzIT",
    "author": "losfalco-User-1f670",
    "likes": 1,
    "type": "strategy",
    "created": "2025-11-24",
    "updated": "2025-11-24",
    "source": "//@lfu\r\n//DYOR\r\n//@version=6\r\nstrategy(\"Composite Score Strategy â€“ Unified Lookback v5\", overlay=true, max_lines_count=500, max_labels_count=500, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=10)\r\n\r\n// ============================\r\n// USER CONFIG INPUTS\r\nrsi_len    = input.int(14, \"AJFFRSI Length\")\r\nqqe_src    = input.source(close, \"QQE Source\")\r\nqqe_len    = input.int(14, \"QQE Length\")\r\nqqe_factor = input.float(4.236, \"QQE Factor\")\r\nqqe_smooth = input.int(5, \"QQE Smooth\")\r\nkeltner_src = input.source(close, \"Keltner Source\")\r\n\r\nscore_threshold_long  = input.float(1, \"Composite Score Long Threshold\")\r\nscore_threshold_short = input.float(-1, \"Composite Score Short Threshold\")\r\nlookback_bars         = input.int(144, \"Unified Lookback (bars)\")\r\ncolorbars             = input.bool(true, \"Color bars?\")\r\n\r\n// ============================\r\n// AJFFRSI MODULE\r\n_rsx_rsi(src,len)=>\r\n    src_out = 100 * src\r\n    mom0 = ta.change(src_out)\r\n    moa0 = math.abs(mom0)\r\n    Kg = 3 / (len + 2)\r\n    Hg = 1 - Kg\r\n    f28 = 0.0\r\n    f30 = 0.0\r\n    f28 := Kg * mom0 + Hg * nz(f28[1])\r\n    f30 := Kg * f28 + Hg * nz(f30[1])\r\n    mom1 = f28 * 1.5 - f30 * 0.5\r\n    f38 = 0.0\r\n    f40 = 0.0\r\n    f38 := Hg * nz(f38[1]) + Kg * mom1\r\n    f40 := Kg * f38 + Hg * nz(f40[1])\r\n    mom2 = f38 * 1.5 - f40 * 0.5\r\n    f48 = 0.0\r\n    f50 = 0.0\r\n    f48 := Hg * nz(f48[1]) + Kg * mom2\r\n    f50 := Kg * f48 + Hg * nz(f50[1])\r\n    mom_out = f48 * 1.5 - f50 * 0.5\r\n    f58 = 0.0\r\n    f60 = 0.0\r\n    f58 := Hg * nz(f58[1]) + Kg * moa0\r\n    f60 := Kg * f58 + Hg * nz(f60[1])\r\n    moa1 = f58 * 1.5 - f60 * 0.5\r\n    f68 = 0.0\r\n    f70 = 0.0\r\n    f68 := Hg * nz(f68[1]) + Kg * moa1\r\n    f70 := Kg * f68 + Hg * nz(f70[1])\r\n    moa2 = f68 * 1.5 - f70 * 0.5\r\n    f78 = 0.0\r\n    f80 = 0.0\r\n    f78 := Hg * nz(f78[1]) + Kg * moa2\r\n    f80 := Kg * f78 + Hg * nz(f80[1])\r\n    moa_out = f78 * 1.5 - f80 * 0.5\r\n    math.max(math.min((mom_out / moa_out + 1.0) * 50.0, 100.0), 0.0)\r\n\r\najf_rsi = _rsx_rsi(close, rsi_len)\r\nplot(ajf_rsi, color=color.white, linewidth=2, title=\"AJFFRSI\")\r\n\r\n// ============================\r\n// QQE MODULE\r\nvar float ts = na\r\ndelta = qqe_src - qqe_src[1]\r\nnum = ta.rma(delta, qqe_len)\r\nden = ta.rma(math.abs(delta), qqe_len)\r\nrsi_qqe = 50 * ta.ema(num / den, qqe_smooth) + 50\r\ndiff = ta.rma(math.abs(rsi_qqe - rsi_qqe[1]), qqe_len)\r\ncrossover_cond  = rsi_qqe > nz(ts) and rsi_qqe[1] <= nz(ts[1])\r\ncrossunder_cond = rsi_qqe < nz(ts) and rsi_qqe[1] >= nz(ts[1])\r\nts := na(ts) ? rsi_qqe : crossover_cond ? rsi_qqe - diff * qqe_factor : crossunder_cond ? rsi_qqe + diff * qqe_factor : ts\r\n\r\nplot(rsi_qqe, color=color.blue, title=\"QQE RSI\")\r\nplot(ts, color=rsi_qqe>ts ? color.teal : color.red, title=\"QQE Trailing Stop\")\r\n\r\n// ============================\r\n// SIGNALS\r\nbull_cross = ta.crossover(ajf_rsi, ts)\r\nbear_cross = ta.crossunder(ajf_rsi, ts)\r\n\r\n// ============================\r\n// KELTNER MODULE\r\nma = ta.ema(keltner_src, 34)\r\natr_val = ta.ema(ta.tr(true), 88)\r\nkc_mid = ma\r\nkc_top = kc_mid + atr_val * 1.5\r\nkc_bottom = kc_mid - atr_val * 1.5\r\n\r\nkc_buy_zone = close <= kc_bottom\r\nkc_sell_zone = close >= kc_top\r\n\r\nkc_cross_up_lower = ta.crossover(close, kc_bottom)\r\nkc_cross_up_upper = ta.crossover(close, kc_top)\r\n\r\n// ============================\r\n// WAVETREND MODULE\r\nwt_src = hlc3\r\nwt_movingAverage = ta.ema(wt_src, 10)\r\nwt_movingAverageChannel = ta.ema(math.abs(wt_src - wt_movingAverage), 10)\r\nwt_channelIndex = (wt_src - wt_movingAverage)/(0.015 * wt_movingAverageChannel)\r\nwt_waveTrend1 = ta.ema(wt_channelIndex, 3)\r\nwt_waveTrend2 = ta.sma(wt_waveTrend1, 3)\r\nwt_cross_up = ta.crossover(wt_waveTrend1, wt_waveTrend2)\r\nwt_cross_down = ta.crossunder(wt_waveTrend1, wt_waveTrend2)\r\n\r\n// Compute module scores\r\nbull_score = bull_cross ? 1 : 0\r\nbear_score = bear_cross ? -1 : 0\r\najf_score  = bull_score + bear_score\r\nqqe_score  = rsi_qqe > ts ? 1 : rsi_qqe < ts ? -1 : 0\r\nkc_score   = kc_buy_zone ? 1 : kc_sell_zone ? -1 : 0\r\nwt_score   = wt_cross_up ? 1 : wt_cross_down ? -1 : 0\r\n\r\n// Rolling composite score over lookback_bars (used for trade entries)\r\ncomposite_score_rolling = math.sum(ajf_score + qqe_score + kc_score + wt_score, lookback_bars)\r\n\r\n// Cumulative score (for plotting only)\r\nvar float composite_score_cum = 0\r\ncomposite_score_cum := composite_score_cum + ajf_score + qqe_score + kc_score + wt_score\r\n\r\n// Entry conditions based on rolling score\r\nif composite_score_rolling >= score_threshold_long\r\n    strategy.entry(\"Long\", strategy.long)\r\n\r\nif composite_score_rolling <= score_threshold_short\r\n    strategy.entry(\"Short\", strategy.short)\r\n\r\n// Plot cumulative score for visual reference\r\nplot(composite_score_cum, color=color.orange, title=\"Composite Score (Cumulative)\", linewidth=2)\r\n\r\nbarcolor(colorbars ? (composite_score_cum > 0 ? color.new(color.green,0) : composite_score_cum < 0 ? color.new(color.red,0) : na) : na)\r\n\r\n\r\n// ============================\r\n// ALERTS\r\nalertcondition(bull_cross, title=\"AJFFRSI Bull Cross\", message=\"AJFFRSI crossed above QQE trailing stop â€“ Bullish Signal\")\r\nalertcondition(bear_cross, title=\"AJFFRSI Bear Cross\", message=\"AJFFRSI crossed below QQE trailing stop â€“ Bearish Signal\")\r\nalertcondition(kc_buy_zone, title=\"KC Buy Zone\", message=\"Price touched Keltner support zone\")\r\nalertcondition(kc_sell_zone, title=\"KC Sell Zone\", message=\"Price touched Keltner resistance zone\")\r\nalertcondition(wt_cross_up, title=\"WT Cross Up\", message=\"WaveTrend crossed up\")\r\nalertcondition(wt_cross_down, title=\"WT Cross Down\", message=\"WaveTrend crossed down\")\r\n\r\n// ============================\r\n// TABLE\r\nvar table score_table = table.new(position.top_right, 5, 2, frame_color=color.gray, border_color=color.white)\r\ntable.cell(score_table, 0, 0, \"Signal\", text_color=color.white, bgcolor=color.gray)\r\ntable.cell(score_table, 0, 1, \"Score\", text_color=color.white, bgcolor=color.gray)\r\ntable.cell(score_table, 1, 0, \"AJFFRSI Cross\", text_color=color.green)\r\ntable.cell(score_table, 1, 1, str.tostring(ajf_score))\r\ntable.cell(score_table, 2, 0, \"QQE\", text_color=color.blue)\r\ntable.cell(score_table, 2, 1, str.tostring(qqe_score))\r\ntable.cell(score_table, 3, 0, \"Keltner Zone\", text_color=color.lime)\r\ntable.cell(score_table, 3, 1, str.tostring(kc_score))\r\ntable.cell(score_table, 4, 0, \"WaveTrend\", text_color=color.orange)\r\ntable.cell(score_table, 4, 1, str.tostring(wt_score))\r\n"
  },
  {
    "url": "xIcGFGJN-Inyerneck-Sniper-Engine-v4-2-FINAL-WORKING-2025",
    "name": "Inyerneck Sniper Engine v4.2 â€” FINAL WORKING 2025",
    "description": "Aggressive momentum sniper for pennies. Fires on volume + EMA snaps. Use small size. Alerts ready.",
    "image_url": "xIcGFGJN",
    "author": "oogabooger",
    "likes": 10,
    "type": "strategy",
    "created": "2025-11-24",
    "updated": "2025-11-24",
    "source": "//@version=5\r\nstrategy(\"Inyerneck Sniper Engine v4.2 â€” FINAL WORKING 2025\", overlay=true, \r\n         default_qty_type=strategy.percent_of_equity, default_qty_value=100,\r\n         pyramiding=0, commission_type=strategy.commission.percent, commission_value=0.075)\r\n\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ PENNY SNIPER SETTINGS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\ngroup = \"Penny Sniper Settings\"\r\n\r\nemaLen      = input.int(5,   \"EMA Length\",          minval=1,   group=group)\r\natrLen      = input.int(10,  \"ATR Length\",          minval=1,   group=group)\r\nvolLen      = input.int(20,  \"Volume Lookback\",     minval=1,   group=group)\r\n\r\nvolMult     = input.float(5.0,  \"Volume Surge Ã— Avg\",      step=0.1, group=group)\r\nbodyMin     = input.float(0.8,  \"Min Body Ã— ATR\",          step=0.05, group=group)\r\ndistMin     = input.float(0.6,  \"Min Distance EMA Ã— ATR\",  step=0.05, group=group)\r\nslopeMin    = input.float(0.08, \"Min EMA Slope Ã— ATR\",     step=0.01, group=group)\r\nblowoffMult = input.float(4.5,  \"Blowoff Range Ã— Avg\",     step=0.1, group=group)\r\n\r\nuseLongs    = input.bool(true,  \"Enable Longs\",  group=group)\r\nuseShorts   = input.bool(true,  \"Enable Shorts\", group=group)\r\n\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ CALCULATIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nema      = ta.ema(close, emaLen)\r\natr      = ta.atr(atrLen)\r\nvolEMA   = ta.ema(volume, volLen)\r\nrangeEMA = ta.ema(high - low, volLen)\r\n\r\nvolSurge   = volume > volEMA * volMult\r\nbodySize   = math.abs(close - open)\r\ndistEMA    = math.abs(close - ema)\r\nemaSlope   = math.abs(ema - ema[1])\r\n\r\nstrongBody = bodySize > atr * bodyMin\r\ngoodDist   = distEMA   > atr * distMin\r\nfastSlope  = emaSlope  > atr * slopeMin\r\nblowoff    = (high - low) > rangeEMA * blowoffMult and volSurge\r\n\r\nrawLong  = close > ema and strongBody and goodDist and fastSlope and volSurge\r\nrawShort = close < ema and strongBody and goodDist and fastSlope and volSurge\r\n\r\nlongSignal  = useLongs  and rawLong  and not blowoff\r\nshortSignal = useShorts and rawShort and not blowoff\r\n\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ENTRIES & EXITS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nif (longSignal)\r\n    strategy.entry(\"Long\", strategy.long)\r\n\r\nif (shortSignal)\r\n    strategy.entry(\"Short\", strategy.short)\r\n\r\nstrategy.exit(\"TP/SL Long\",  \"Long\",  profit=3, loss=1)\r\nstrategy.exit(\"TP/SL Short\", \"Short\", profit=3, loss=1)\r\n\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ PLOTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nplot(ema, \"EMA\", color.orange, 2)\r\n\r\nplotshape(longSignal,  title=\"LONG\",  location=location.belowbar, color=color.new(#00ff00, 0), style=shape.triangleup,   size=size.large, text=\"LONG\")\r\nplotshape(shortSignal, title=\"SHORT\", location=location.abovebar, color=color.new(#ff0000, 0), style=shape.triangledown, size=size.large, text=\"SHORT\")\r\n\r\nbgcolor(longSignal  ? color.new(#00ff00, 90) : na)\r\nbgcolor(shortSignal ? color.new(#ff0000, 90) : na)\r\n\r\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ALERTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nalertcondition(longSignal or shortSignal, title=\"Inyerneck Sniper ANY\", message=\"Inyerneck Sniper Signal\")"
  },
  {
    "url": "PnAUDW53-Inyerneck-Sniper-Engine-v4-2-FINAL-WORKING-2025",
    "name": "Inyerneck Sniper Engine v4.2 â€” FINAL WORKING 2025",
    "description": "yer momUltra-aggressive momentum sniper built for pennies & BTC.\nFires on every volume explosion + EMA snap. No mercy, no filters.\n50+ trades per month. Use small size or die trying.\nPrivate alpha â€” ",
    "image_url": "PnAUDW53",
    "author": "oogabooger",
    "likes": 14,
    "type": "strategy",
    "created": "2025-11-24",
    "updated": "2025-11-24",
    "source": "//@version=5\nstrategy(\"Inyerneck Sniper Engine v4.2 â€” FINAL WORKING 2025\", overlay=true, \n         default_qty_type=strategy.percent_of_equity, default_qty_value=100,\n         pyramiding=0, commission_type=strategy.commission.percent, commission_value=0.075)\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ PENNY SNIPER SETTINGS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\ngroup = \"Penny Sniper Settings\"\n\nemaLen      = input.int(5,   \"EMA Length\",          minval=1,   group=group)\natrLen      = input.int(10,  \"ATR Length\",          minval=1,   group=group)\nvolLen      = input.int(20,  \"Volume Lookback\",     minval=1,   group=group)\n\nvolMult     = input.float(5.0,  \"Volume Surge Ã— Avg\",      step=0.1, group=group)\nbodyMin     = input.float(0.8,  \"Min Body Ã— ATR\",          step=0.05, group=group)\ndistMin     = input.float(0.6,  \"Min Distance EMA Ã— ATR\",  step=0.05, group=group)\nslopeMin    = input.float(0.08, \"Min EMA Slope Ã— ATR\",     step=0.01, group=group)\nblowoffMult = input.float(4.5,  \"Blowoff Range Ã— Avg\",     step=0.1, group=group)\n\nuseLongs    = input.bool(true,  \"Enable Longs\",  group=group)\nuseShorts   = input.bool(true,  \"Enable Shorts\", group=group)\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ CALCULATIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nema      = ta.ema(close, emaLen)\natr      = ta.atr(atrLen)\nvolEMA   = ta.ema(volume, volLen)\nrangeEMA = ta.ema(high - low, volLen)\n\nvolSurge   = volume > volEMA * volMult\nbodySize   = math.abs(close - open)\ndistEMA    = math.abs(close - ema)\nemaSlope   = math.abs(ema - ema[1])\n\nstrongBody = bodySize > atr * bodyMin\ngoodDist   = distEMA   > atr * distMin\nfastSlope  = emaSlope  > atr * slopeMin\nblowoff    = (high - low) > rangeEMA * blowoffMult and volSurge\n\nrawLong  = close > ema and strongBody and goodDist and fastSlope and volSurge\nrawShort = close < ema and strongBody and goodDist and fastSlope and volSurge\n\nlongSignal  = useLongs  and rawLong  and not blowoff\nshortSignal = useShorts and rawShort and not blowoff\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ENTRIES & EXITS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nif (longSignal)\n    strategy.entry(\"Long\", strategy.long)\n\nif (shortSignal)\n    strategy.entry(\"Short\", strategy.short)\n\nstrategy.exit(\"TP/SL Long\",  \"Long\",  profit=3, loss=1)\nstrategy.exit(\"TP/SL Short\", \"Short\", profit=3, loss=1)\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ PLOTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nplot(ema, \"EMA\", color.orange, 2)\n\nplotshape(longSignal,  title=\"LONG\",  location=location.belowbar, color=color.new(#00ff00, 0), style=shape.triangleup,   size=size.large, text=\"LONG\")\nplotshape(shortSignal, title=\"SHORT\", location=location.abovebar, color=color.new(#ff0000, 0), style=shape.triangledown, size=size.large, text=\"SHORT\")\n\nbgcolor(longSignal  ? color.new(#00ff00, 90) : na)\nbgcolor(shortSignal ? color.new(#ff0000, 90) : na)\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ALERTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nalertcondition(longSignal or shortSignal, title=\"Inyerneck Sniper ANY\", message=\"Inyerneck Sniper Signal\")"
  },
  {
    "url": "RTPBwmJL-Inyerneck-Sniper-Engine-v4-2-FINAL-WORKING-2025",
    "name": "Inyerneck Sniper Engine v4.2 â€” FINAL WORKING 2025",
    "description": "Ultra-aggressive momentum sniper built for pennies & BTC.\nFires on every volume explosion + EMA snap. No mercy, no filters.\n50+ trades per month. Use small size or die trying.\nPrivate alpha â€” invite-only. do not change settings without first recording default settings, the default settings are great... usable on any time frame.. aaaaannd...   yer mom!",
    "image_url": "RTPBwmJL",
    "author": "oogabooger",
    "likes": 6,
    "type": "strategy",
    "created": "2025-11-24",
    "updated": "2025-11-24",
    "source": "//@version=5\nstrategy(\"Inyerneck Sniper Engine v4.2 â€” FINAL WORKING 2025\", overlay=true, \n         default_qty_type=strategy.percent_of_equity, default_qty_value=100,\n         pyramiding=0, commission_type=strategy.commission.percent, commission_value=0.075)\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ PENNY SNIPER SETTINGS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\ngroup = \"Penny Sniper Settings\"\n\nemaLen      = input.int(5,   \"EMA Length\",          minval=1,   group=group)\natrLen      = input.int(10,  \"ATR Length\",          minval=1,   group=group)\nvolLen      = input.int(20,  \"Volume Lookback\",     minval=1,   group=group)\n\nvolMult     = input.float(5.0,  \"Volume Surge Ã— Avg\",      step=0.1, group=group)\nbodyMin     = input.float(0.8,  \"Min Body Ã— ATR\",          step=0.05, group=group)\ndistMin     = input.float(0.6,  \"Min Distance EMA Ã— ATR\",  step=0.05, group=group)\nslopeMin    = input.float(0.08, \"Min EMA Slope Ã— ATR\",     step=0.01, group=group)\nblowoffMult = input.float(4.5,  \"Blowoff Range Ã— Avg\",     step=0.1, group=group)\n\nuseLongs    = input.bool(true,  \"Enable Longs\",  group=group)\nuseShorts   = input.bool(true,  \"Enable Shorts\", group=group)\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ CALCULATIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nema      = ta.ema(close, emaLen)\natr      = ta.atr(atrLen)\nvolEMA   = ta.ema(volume, volLen)\nrangeEMA = ta.ema(high - low, volLen)\n\nvolSurge   = volume > volEMA * volMult\nbodySize   = math.abs(close - open)\ndistEMA    = math.abs(close - ema)\nemaSlope   = math.abs(ema - ema[1])\n\nstrongBody = bodySize > atr * bodyMin\ngoodDist   = distEMA   > atr * distMin\nfastSlope  = emaSlope  > atr * slopeMin\nblowoff    = (high - low) > rangeEMA * blowoffMult and volSurge\n\nrawLong  = close > ema and strongBody and goodDist and fastSlope and volSurge\nrawShort = close < ema and strongBody and goodDist and fastSlope and volSurge\n\nlongSignal  = useLongs  and rawLong  and not blowoff\nshortSignal = useShorts and rawShort and not blowoff\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ENTRIES & EXITS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nif (longSignal)\n    strategy.entry(\"Long\", strategy.long)\n\nif (shortSignal)\n    strategy.entry(\"Short\", strategy.short)\n\nstrategy.exit(\"TP/SL Long\",  \"Long\",  profit=3, loss=1)\nstrategy.exit(\"TP/SL Short\", \"Short\", profit=3, loss=1)\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ PLOTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nplot(ema, \"EMA\", color.orange, 2)\n\nplotshape(longSignal,  title=\"LONG\",  location=location.belowbar, color=color.new(#00ff00, 0), style=shape.triangleup,   size=size.large, text=\"LONG\")\nplotshape(shortSignal, title=\"SHORT\", location=location.abovebar, color=color.new(#ff0000, 0), style=shape.triangledown, size=size.large, text=\"SHORT\")\n\nbgcolor(longSignal  ? color.new(#00ff00, 90) : na)\nbgcolor(shortSignal ? color.new(#ff0000, 90) : na)\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ALERTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nalertcondition(longSignal or shortSignal, title=\"Inyerneck Sniper ANY\", message=\"Inyerneck Sniper Signal\")"
  },
  {
    "url": "Xe3cLIzC",
    "name": "EMA Trend Pro [Hedging & Fixed Risk]",
    "description": "\n\nThis strategy is a comprehensive trend-following system designed to capture significant market movements while strictly managing risk. It combines multiple Exponential Moving Averages (EMAs) for trend identification, ADX for trend strength filtering, and Volume confirmation to reduce false signals.\n\nKey Features:\n\nHedging Mode Compatible: The script is designed to handle Long and Short positions independently. This is ideal for markets where trends can reverse quickly or for traders who prefer hedging logic (requires hedging=true in strategy settings).\n\nProfessional Risk Management: Unlike standard strategies that use fixed contract sizes, this script calculates Position Size based on Risk. You can define a fixed risk per trade (e.g., 1% of equity or $100 fixed risk). The script automatically adjusts the lot size based on the Stop Loss distance (ATR).\n\nMulti-Stage Take Profit: The strategy scales out positions at 3 different levels (TP1, TP2, TP3) to lock in profits while letting the remaining position ride the trend.\n\nStrategy Logic:\n\nTrend Identification:\n\nLong Entry: EMA 7 > EMA 14 > EMA 21 > EMA 144 (Bullish Alignment).\n\nShort Entry: EMA 7 < EMA 14 < EMA 21 < EMA 144 (Bearish Alignment).\n\nFilters:\n\nADX Filter: Entries are only taken if ADX (14) > Threshold (default 20) to ensure the market is trending, avoiding chopping ranging markets.\n\nVolume Filter: Current volume must exceed the 20-period SMA volume by 10% to confirm momentum.\n\nExits & Trade Management:\n\nStop Loss: Dynamic SL based on ATR (e.g., 1.8x ATR).\n\nBreakeven: Once TP1 is hit, the Stop Loss is automatically moved to Breakeven to protect capital.\n\nTake Profits:\n\nTP1: 1x Risk Distance (30% pos)\n\nTP2: 2x Risk Distance (50% pos)\n\nTP3: 3x Risk Distance (Remaining pos)\n\nSettings Guide:\n\nRisk Type: Choose between \"Percent\" (of equity) or \"Fixed Amount\" (USD).\n\nRisk Value: Input your desired risk (e.g., 1.0 for 1% risk).\n\nFee %: Set your exchange's Taker fee (e.g., 0.05 or 0.06) for accurate backtesting.\n\nADX Threshold: Adjust to filter out noise (Higher = Stricter trend requirement).\n\nDisclaimer: This script is for educational and backtesting purposes only. Past performance does not guarantee future results. Please use proper risk management.",
    "image_url": "Xe3cLIzC",
    "author": "misusu",
    "likes": 7,
    "type": "strategy",
    "created": "2025-11-28",
    "updated": "2025-11-28",
    "source": "//@version=5\r\n// Title: EMA Trend Pro [Hedging, Fixed Risk, Trend Dashboard]\r\nstrategy(\"EMA Trend Pro [Dashboard]\", overlay=true, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=100, currency=currency.USD, commission_type=strategy.commission.percent, commission_value=0.05, max_boxes_count=50, max_labels_count=200, pyramiding=20)\r\n\r\n// ==========================================\r\n// 1. Inputs (åƒæ•¸è¨­å®š)\r\n// ==========================================\r\n\r\n// Group: Indicator Settings\r\ngrp_ind   = \"Indicator Settings\"\r\nadxMin    = input.int(20, \"ADX Threshold\", minval=1, group=grp_ind)\r\nemaFast   = input.int(7, \"EMA Fast\", group=grp_ind)\r\nemaMed    = input.int(14, \"EMA Medium\", group=grp_ind)\r\nemaSlow   = input.int(21, \"EMA Slow\", group=grp_ind)\r\nemaTrend  = input.int(144, \"EMA Trend (Base)\", group=grp_ind)\r\nemaLong   = input.int(200, \"EMA Trend (Long)\", group=grp_ind)\r\n\r\n// --- Dashboard Settings (å„€è¡¨æ¿è¨­å®š) ---\r\ngrp_dash  = \"Trend Dashboard Settings\"\r\nshowTable = input.bool(true, \"Show Dashboard Table?\", group=grp_dash)\r\ntrendLen  = input.int(200, \"Trend EMA Length for Table\", group=grp_dash, tooltip=\"The EMA length used to determine 1H/4H trend in the table.\")\r\n\r\n// Group: Strategy & Risk Management\r\ngrp_strat = \"Strategy & Risk\"\r\natrMultSL = input.float(1.8, \"Stop Loss ATR Multiplier\", step=0.1, group=grp_strat)\r\nfeePct    = input.float(0.05, \"Taker Fee % (Est.)\", step=0.01, group=grp_strat)\r\nriskType  = input.string(\"Percent\", \"Risk Type\", options=[\"Fixed Amount\", \"Percent\"], group=grp_strat)\r\nriskVal   = input.float(1.0, \"Risk Value\", step=0.1, group=grp_strat)\r\n\r\n// Group: Backtest Period\r\ngrp_time  = \"Backtest Period\"\r\nuseDate   = input.bool(true, \"Use Date Filter\", group=grp_time)\r\nstartYear = input.int(2025, \"Start Year\", group=grp_time)\r\nstartMonth= input.int(10, \"Start Month\", group=grp_time)\r\nstartDate = input.int(1, \"Start Day\", group=grp_time)\r\nendYear   = input.int(2025, \"End Year\", group=grp_time)\r\nendMonth  = input.int(11, \"End Month\", group=grp_time)\r\nendDate   = input.int(30, \"End Day\", group=grp_time)\r\n\r\n// ==========================================\r\n// 2. Calculations (æŒ‡æ¨™è¨ˆç®—)\r\n// ==========================================\r\n\r\ninDateRange = not useDate or (time >= timestamp(syminfo.timezone, startYear, startMonth, startDate, 0, 0) and time <= timestamp(syminfo.timezone, endYear, endMonth, endDate, 23, 59))\r\n\r\n// Indicators (Current Chart)\r\nema7   = ta.ema(close, emaFast)\r\nema14  = ta.ema(close, emaMed)\r\nema21  = ta.ema(close, emaSlow)\r\nema144 = ta.ema(close, emaTrend)\r\nema200 = ta.ema(close, emaLong)\r\natr20  = ta.atr(20)\r\n[diPlus, diMinus, adx14] = ta.dmi(14, 14)\r\n\r\nvolOK  = volume > ta.sma(volume, 20) * 1.1\r\n\r\n// --- Table Data Calculation (ä¸å½±éŸ¿é€²å ´é‚è¼¯ï¼Œåƒ…ä¾›é¡¯ç¤º) ---\r\n// å®šç¾©è¶¨å‹¢åˆ¤æ–·å‡½æ•¸ï¼šæ”¶ç›¤åƒ¹ > EMA = å¤šé ­\r\n// --- Table Data Calculation ---\r\n\r\n// å®šç¾©è¶¨å‹¢åˆ¤æ–·å‡½æ•¸ï¼šçµåˆ SuperTrend èˆ‡ ADX\r\n// å›žå‚³å€¼: 1=å¤šé ­, -1=ç©ºé ­, 0=ç›¤æ•´\r\nget_trend_robust() =>\r\n    // 1. è¨ˆç®— SuperTrend (ä½¿ç”¨æ¨™æº–åƒæ•¸ 3, 10)\r\n    [stValue, direction] = ta.supertrend(3.0, 10) \r\n    // direction: -1=å¤š, 1=ç©º\r\n    \r\n    // 2. è¨ˆç®— ADX (åˆ¤æ–·ç›¤æ•´ç”¨)\r\n    [diP, diM, adxVal] = ta.dmi(14, 14)\r\n    \r\n    // 3. ç¶œåˆåˆ¤æ–·\r\n    if adxVal < 20\r\n        0 // ADX å¤ªä½Žï¼Œå®šç¾©ç‚ºç›¤æ•´\r\n    else if direction == -1\r\n        1 // æœ‰å‹•èƒ½ä¸” SuperTrend çœ‹å¤š\r\n    else\r\n        -1 // æœ‰å‹•èƒ½ä¸” SuperTrend çœ‹ç©º\r\n\r\n// ä½¿ç”¨ request.security æŠ“å– 1H èˆ‡ 4H çš„ç‹€æ…‹\r\ntrend1h_state = request.security(syminfo.tickerid, \"60\", get_trend_robust(), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)\r\ntrend4h_state = request.security(syminfo.tickerid, \"240\", get_trend_robust(), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)\r\n\r\n// Trend Conditions (Original)\r\nbullTrend = ema7 > ema14 and ema14 > ema21\r\nbearTrend = ema7 < ema14 and ema14 < ema21\r\n\r\n// Entry Signals (Original Strict Logic - UNTOUCHED)\r\n// ä¿æŒæ‚¨åŽŸå§‹æä¾›çš„é‚è¼¯\r\nlongCond  = (ta.crossover(ema7,ema144) or ta.crossover(ema14,ema144)) and ema7>ema14 and ema14>ema21 and diPlus > diMinus and adx14 > adxMin\r\nshortCond = (ta.crossunder(ema7,ema144) or ta.crossunder(ema14,ema144)) and ema7<ema14 and ema14<ema21 and diMinus > diPlus  and adx14 > adxMin\r\n\r\n// Plotting EMAs\r\nplot(ema7, color=color.red, title=\"EMA 7\")\r\nplot(ema14, color=color.orange, title=\"EMA 14\")\r\nplot(ema21, color=color.yellow, title=\"EMA 21\")\r\nplot(ema144, color=color.blue, linewidth=2, title=\"EMA 144\")\r\n// æ³¨æ„ï¼šé€™è£¡ä¸ç•« EMA 200 æˆ– å¤§æ™‚å€ EMAï¼Œä¿æŒç•«é¢ä¹¾æ·¨\r\n\r\n// ==========================================\r\n// 3. State Variables\r\n// ==========================================\r\n\r\nvar bool  inLong       = false\r\nvar float entryPrice_L = na\r\nvar float slDist_L     = na\r\nvar float entryQty_L   = na\r\nvar float currentSL_L  = na\r\n\r\nvar bool  inShort      = false\r\nvar float entryPrice_S = na\r\nvar float slDist_S     = na\r\nvar float entryQty_S   = na\r\nvar float currentSL_S  = na\r\n\r\nvar box[] boxes = array.new_box()\r\nfloat roundTripFee = (feePct / 100) * 2.0\r\n\r\n// ==========================================\r\n// 4. Custom Functions\r\n// ==========================================\r\n\r\ncalc_qty(sl_distance) =>\r\n    float risk_amt = 0.0\r\n    if sl_distance == 0\r\n        0.0\r\n    else\r\n        if riskType == \"Percent\"\r\n            risk_amt := strategy.equity * (riskVal / 100)\r\n        else\r\n            risk_amt := riskVal\r\n        risk_amt / sl_distance\r\n\r\ndraw_trade(e_price, tp3_price, sl_price, is_long) =>\r\n    color c_box = color.new(#00E676, 80)\r\n    color c_sl  = color.new(color.red, 80)\r\n    box btp = box.new(bar_index, math.max(e_price, tp3_price), bar_index+20, math.min(e_price, tp3_price), bgcolor=c_box, border_width=1)\r\n    array.push(boxes, btp)\r\n    box bsl = box.new(bar_index, math.max(e_price, sl_price), bar_index+20, math.min(e_price, sl_price), bgcolor=c_sl, border_width=1)\r\n    array.push(boxes, bsl)\r\n    if array.size(boxes) > 40\r\n        box.delete(array.shift(boxes))\r\n\r\n// ==========================================\r\n// 5. Strategy Execution\r\n// ==========================================\r\n\r\nif longCond and not inLong and inDateRange\r\n    float dist_L = atr20 * atrMultSL\r\n    float qty_L  = calc_qty(dist_L)\r\n    if qty_L > 0\r\n        inLong       := true\r\n        entryPrice_L := close\r\n        slDist_L     := dist_L\r\n        entryQty_L   := qty_L\r\n        currentSL_L  := entryPrice_L - slDist_L\r\n        strategy.entry(\"Long\", strategy.long, qty=entryQty_L)\r\n        draw_trade(close, close + 3 * dist_L, currentSL_L, true)\r\n\r\nif shortCond and not inShort and inDateRange\r\n    float dist_S = atr20 * atrMultSL\r\n    float qty_S  = calc_qty(dist_S)\r\n    if qty_S > 0\r\n        inShort      := true\r\n        entryPrice_S := close\r\n        slDist_S     := dist_S\r\n        entryQty_S   := qty_S\r\n        currentSL_S  := entryPrice_S + slDist_S\r\n        strategy.entry(\"Short\", strategy.short, qty=entryQty_S)\r\n        draw_trade(close, close - 3 * dist_S, currentSL_S, false)\r\n\r\n// ==========================================\r\n// 6. Exits & Management\r\n// ==========================================\r\n\r\nif inLong\r\n    float longTP1 = entryPrice_L + slDist_L\r\n    float longTP2 = entryPrice_L + slDist_L * 2\r\n    float longTP3 = entryPrice_L + slDist_L * 3\r\n    float longBreakeven = entryPrice_L * (1 + roundTripFee)\r\n    \r\n    if high >= longTP1\r\n        currentSL_L := longBreakeven \r\n    \r\n    strategy.exit(\"L_TP1\", \"Long\", qty=entryQty_L * 0.3, limit=longTP1, stop=currentSL_L)\r\n    strategy.exit(\"L_TP2\", \"Long\", qty=entryQty_L * 0.5, limit=longTP2, stop=currentSL_L)\r\n    strategy.exit(\"L_TP3\", \"Long\", limit=longTP3, stop=currentSL_L)\r\n\r\n    if not inDateRange\r\n        strategy.close(\"Long\", comment=\"End Backtest\")\r\n        inLong := false\r\n    else if high >= longTP3 or low <= currentSL_L\r\n        inLong := false\r\n\r\nif inShort\r\n    float shortTP1 = entryPrice_S - slDist_S\r\n    float shortTP2 = entryPrice_S - slDist_S * 2\r\n    float shortTP3 = entryPrice_S - slDist_S * 3\r\n    float shortBreakeven = entryPrice_S * (1 - roundTripFee)\r\n    \r\n    if low <= shortTP1\r\n        currentSL_S := shortBreakeven\r\n        \r\n    strategy.exit(\"S_TP1\", \"Short\", qty=entryQty_S * 0.3, limit=shortTP1, stop=currentSL_S)\r\n    strategy.exit(\"S_TP2\", \"Short\", qty=entryQty_S * 0.5, limit=shortTP2, stop=currentSL_S)\r\n    strategy.exit(\"S_TP3\", \"Short\", limit=shortTP3, stop=currentSL_S)\r\n\r\n    if not inDateRange\r\n        strategy.close(\"Short\", comment=\"End Backtest\")\r\n        inShort := false\r\n    else if low <= shortTP3 or high >= currentSL_S\r\n        inShort := false\r\n\r\n// ==========================================\r\n// 7. Dashboard Table (NEW)\r\n// ==========================================\r\n\r\n// å»ºç«‹ 4è¡Œ 2åˆ— çš„è¡¨æ ¼\r\nvar table dash = table.new(position.bottom_right, 2, 6, bgcolor = color.new(color.black, 40), border_width = 1)\r\n\r\nif showTable\r\n    // --- Header ---\r\n    table.cell(dash, 0, 0, \"Strategy Monitor\", text_color=color.white, bgcolor=color.new(color.blue, 60))\r\n    table.cell(dash, 1, 0, \"State\", text_color=color.white, bgcolor=color.new(color.blue, 60))\r\n\r\n    // --- 1H Trend Row ---\r\n    string t1_txt = \"N/A\"\r\n    color  t1_col = color.gray\r\n    \r\n    if trend1h_state == 0\r\n        t1_txt := \"Ranging (Flat)\"\r\n        t1_col := color.gray\r\n    else if trend1h_state == 1\r\n        t1_txt := \"BULL (Long)\"\r\n        t1_col := color.green\r\n    else\r\n        t1_txt := \"BEAR (Short)\"\r\n        t1_col := color.red\r\n\r\n    table.cell(dash, 0, 1, \"1H Trend (ST+ADX)\", text_color=color.white)\r\n    table.cell(dash, 1, 1, t1_txt, text_color=color.white, bgcolor=t1_col)\r\n\r\n    // --- 4H Trend Row ---\r\n    string t4_txt = \"N/A\"\r\n    color  t4_col = color.gray\r\n    \r\n    if trend4h_state == 0\r\n        t4_txt := \"Ranging (Flat)\"\r\n        t4_col := color.gray\r\n    else if trend4h_state == 1\r\n        t4_txt := \"BULL (Long)\"\r\n        t4_col := color.green\r\n    else\r\n        t4_txt := \"BEAR (Short)\"\r\n        t4_col := color.red\r\n\r\n    table.cell(dash, 0, 2, \"4H Trend (ST+ADX)\", text_color=color.white)\r\n    table.cell(dash, 1, 2, t4_txt, text_color=color.white, bgcolor=t4_col)"
  },
  {
    "url": "ocH9O2eR-Volume-weighted-average-price-band-strategy-Kevin-Patrick",
    "name": "Volume weighted average price band strategy [Kevin-Patrick]",
    "description": "VWAP Bands strategy, Credit  \n\nVWAP Machine Learning Bands is an advanced indicator designed to enhance trading analysis by integrating VWAP with a machine learning-inspired adaptive smoothing approach. This tool helps traders identify trend-based support and resistance zones, predict potential price movements, and generate dynamic trade signals.\n\nKey Features\nAdaptive ML VWAP Calculation: Uses a dynamically adjusted SMA-based VWAP model with volatility sensitivity for improved trend analysis.\nForecasting Mechanism: The 'Forecast' parameter shifts the ML output forward, providing predictive insights into potential price movements.\nVolatility-Based Band Adjustments: The 'Sigma' parameter fine-tunes the impact of volatility on ML smoothing, adapting to market conditions.\nMulti-Tier Standard Deviation Bands: Includes two levels of bands to define potential breakout or mean-reversion zones.\nDynamic Trend-Based Colouring: The VWAP and ML lines change colour based on their relative positions, visually indicating bullish and bearish conditions.\nCustom Signal Detection Modes: Allows traders to choose between signals from Band 1, Band 2, or both, for more tailored trade setups.\n\n+ Strategy setting by Kevin-Patrick",
    "image_url": "ocH9O2eR",
    "author": "Kevin-Patrick",
    "likes": 22,
    "type": "strategy",
    "created": "2025-11-24",
    "updated": "2025-11-24",
    "source": "//@version=6\r\nstrategy('Volume weighted average price band strategy [Kevin-Patrick]', shorttitle = 'VWAP Bands Strategy [Kevin-Patrick]', overlay = true, max_labels_count = 500, default_qty_type = strategy.percent_of_equity, default_qty_value = 100)\r\n\r\n//#region Inputs\r\ninputGroup = 'General Settings'\r\nwindow = input.int(100, minval = 10, title = 'ML Window', group = inputGroup)\r\nforecast = input.int(1, title = 'Forecast', group = inputGroup, tooltip = 'Shifts the ML output forward by the specified number of bars for predictive analysis.')\r\nsigma = input.float(0.1, step = 0.01, minval = 0, title = 'Sigma', group = inputGroup, tooltip = 'Adjusts the impact of volatility on the ML smoothing calculation.')\r\nband_multiplier = input.float(2, title = 'Band 1 Multiplier', minval = 0, group = inputGroup)\r\nband_multiplier_2 = input.float(3, title = 'Band 2 Multiplier', minval = 0, group = inputGroup)\r\nsource = input.source(close, title = 'Source', group = inputGroup)\r\n\r\n//#region Smoothing Options\r\nsmoothingGroup = 'ML Smoothing Settings'\r\nenable_smoothing = input.bool(true, title = 'Enable ML Line Smoothing', group = smoothingGroup)\r\nsmoothing_type = input.string('EMA', title = 'Smoothing Type', options = ['SMA', 'EMA', 'WMA', 'RMA', 'VWAP'], group = smoothingGroup)\r\nsmoothing_length = input.int(5, minval = 1, title = 'Smoothing Length', group = smoothingGroup, tooltip = 'Higher values = smoother line but more lag (not used for VWAP)')\r\n//#endregion\r\n\r\n//#region Strategy Settings\r\nstrategyGroup = 'Strategy Settings'\r\nentry_band = input.string('Band 1', title = 'Entry Band', options = ['Band 1', 'Band 2'], group = strategyGroup, tooltip = 'Which band to use for entry signals')\r\n\r\n// Take Profit System\r\ntp1_percent = input.float(2.0, title = 'TP1 Distance %', minval = 0.1, step = 0.1, group = strategyGroup, tooltip = 'First take profit level')\r\ntp2_percent = input.float(4.0, title = 'TP2 Distance %', minval = 0.1, step = 0.1, group = strategyGroup, tooltip = 'Second take profit level')\r\ntp3_percent = input.float(6.0, title = 'TP3 Distance %', minval = 0.1, step = 0.1, group = strategyGroup, tooltip = 'Third take profit level')\r\n\r\ntp1_qty = input.float(10.0, title = 'TP1 Quantity %', minval = 1, maxval = 100, step = 1, group = strategyGroup, tooltip = 'Percentage of position to close at TP1')\r\ntp2_qty = input.float(15.0, title = 'TP2 Quantity %', minval = 1, maxval = 100, step = 1, group = strategyGroup, tooltip = 'Percentage of position to close at TP2')\r\ntp3_qty = input.float(25.0, title = 'TP3 Quantity %', minval = 1, maxval = 100, step = 1, group = strategyGroup, tooltip = 'Percentage of position to close at TP3')\r\n\r\n// Stop Loss & Trailing Stop\r\ninitial_stop_loss = input.float(2.0, title = 'Initial Stop Loss %', minval = 0.1, step = 0.1, group = strategyGroup)\r\nenable_trailing = input.bool(true, title = 'Enable Trailing Stop After TP1', group = strategyGroup)\r\ntrailing_stop_percent = input.float(1.5, title = 'Trailing Stop %', minval = 0.1, step = 0.1, group = strategyGroup, tooltip = 'Trailing stop distance after TP1 is hit')\r\n//#endregion\r\n\r\n//#region Signal Options\r\nsignalGroup = 'Signal Options'\r\ndetection_mode = input.string('Both', title = 'Signal Detection Mode', options = ['Both', 'Band 1', 'Band 2'], group = signalGroup)\r\nlabel_size_input = input.string('default', title = 'Label Size', options = ['very small', 'small', 'default', 'large', 'very large'], group = signalGroup)\r\nshape_size_option = switch label_size_input\r\n    'very small' => size.tiny\r\n    'small' => size.small\r\n    'default' => size.normal\r\n    'large' => size.large\r\n    'very large' => size.huge\r\n//#endregion\r\n\r\n//#region Style Settings\r\nstyleGroup = 'Style Settings'\r\nvwap_color = input.color(color.blue, title = 'VWAP Color', group = styleGroup)\r\nbearColour = color.new(#f23645, 0)\r\nbullColour = color.new(#089981, 0)\r\n//#endregion\r\n\r\n//#region Candle Colours\r\ncandleGroup = 'Candle Colours'\r\nNeutralCandles = input.bool(false, title = 'Neutral', group = candleGroup)\r\ngray = #dddddd\r\nwhite = color.white\r\nneutralColours = NeutralCandles ? close > open ? white : color.gray : gray\r\n//#endregion\r\n\r\n//#region VWAP Calculation\r\nvwap = ta.vwap(source)\r\n//#endregion\r\n\r\n//#region ML Prediction with Smoothing\r\nml_base = ta.sma(source, window)\r\nml_adjusted = ml_base + sigma * (vwap - ml_base)\r\nml_raw = ml_adjusted[forecast]\r\n\r\n// Apply smoothing to ML output\r\nml_output = if enable_smoothing\r\n    switch smoothing_type\r\n        'SMA' => ta.sma(ml_raw, smoothing_length)\r\n        'EMA' => ta.ema(ml_raw, smoothing_length)\r\n        'WMA' => ta.wma(ml_raw, smoothing_length)\r\n        'RMA' => ta.rma(ml_raw, smoothing_length)\r\n        'VWAP' => vwap\r\n        => ml_raw\r\nelse\r\n    ml_raw\r\n//#endregion\r\n\r\n//#region Standard Deviation for VWAP Bands\r\nstd_dev = ta.stdev(close, window)\r\nupper_band = vwap + band_multiplier * std_dev\r\nlower_band = vwap - band_multiplier * std_dev\r\nupper_band_2 = vwap + band_multiplier_2 * std_dev\r\nlower_band_2 = vwap - band_multiplier_2 * std_dev\r\n//#endregion\r\n\r\n//#region Dynamic Zones\r\nupper_ml_band = ml_output + band_multiplier * std_dev\r\nlower_ml_band = ml_output - band_multiplier * std_dev\r\nupper_ml_band_2 = ml_output + band_multiplier_2 * std_dev\r\nlower_ml_band_2 = ml_output - band_multiplier_2 * std_dev\r\n//#endregion\r\n\r\n//#region Signals\r\nbullish_signal_band_1 = ta.crossover(source, lower_ml_band)\r\nbearish_signal_band_1 = ta.crossunder(source, upper_ml_band)\r\nbullish_signal_band_2 = ta.crossover(source, lower_ml_band_2)\r\nbearish_signal_band_2 = ta.crossunder(source, upper_ml_band_2)\r\n\r\nbullish_signal = detection_mode == 'Both' ? bullish_signal_band_1 or bullish_signal_band_2 : detection_mode == 'Band 1' ? bullish_signal_band_1 : bullish_signal_band_2\r\nbearish_signal = detection_mode == 'Both' ? bearish_signal_band_1 or bearish_signal_band_2 : detection_mode == 'Band 1' ? bearish_signal_band_1 : bearish_signal_band_2\r\n//#endregion\r\n\r\n//#region Strategy Logic\r\n// Determine entry signals based on user selection\r\nlong_entry = entry_band == 'Band 1' ? bullish_signal_band_1 : bullish_signal_band_2\r\n\r\n// Track entry price and highest price for trailing\r\nvar float entry_price = na\r\nvar float highest_price = na\r\nvar bool tp1_hit = false\r\n\r\n// Entry logic\r\nif long_entry and strategy.position_size == 0\r\n    entry_price := close\r\n    highest_price := close\r\n    tp1_hit := false\r\n    strategy.entry('Long', strategy.long)\r\n    \r\n    // Set initial exits for all take profit levels\r\n    stop_loss_price = close * (1 - initial_stop_loss / 100)\r\n    tp1_price = close * (1 + tp1_percent / 100)\r\n    tp2_price = close * (1 + tp2_percent / 100)\r\n    tp3_price = close * (1 + tp3_percent / 100)\r\n    \r\n    // TP1 exit\r\n    strategy.exit('TP1', 'Long', qty_percent = tp1_qty, limit = tp1_price, stop = stop_loss_price)\r\n    // TP2 exit\r\n    strategy.exit('TP2', 'Long', qty_percent = tp2_qty, limit = tp2_price, stop = stop_loss_price)\r\n    // TP3 exit  \r\n    strategy.exit('TP3', 'Long', qty_percent = tp3_qty, limit = tp3_price, stop = stop_loss_price)\r\n\r\n// Position management while in trade\r\nif strategy.position_size > 0 and not na(entry_price)\r\n    // Update highest price\r\n    if high > highest_price\r\n        highest_price := high\r\n    \r\n    // Check if TP1 was hit\r\n    tp1_price = entry_price * (1 + tp1_percent / 100)\r\n    if not tp1_hit and high >= tp1_price\r\n        tp1_hit := true\r\n    \r\n    // Calculate remaining quantity after TPs\r\n    remaining_qty = 100 - tp1_qty - tp2_qty - tp3_qty\r\n    \r\n    // Apply trailing stop to remaining position after TP1\r\n    if enable_trailing and tp1_hit and remaining_qty > 0\r\n        trailing_stop_price = highest_price * (1 - trailing_stop_percent / 100)\r\n        strategy.exit('Trail', 'Long', qty_percent = remaining_qty, stop = trailing_stop_price)\r\n    else if remaining_qty > 0\r\n        // Keep initial stop for remaining position\r\n        stop_loss_price = entry_price * (1 - initial_stop_loss / 100)\r\n        strategy.exit('Stop', 'Long', qty_percent = remaining_qty, stop = stop_loss_price)\r\n\r\n// Reset variables when position closes\r\nif strategy.position_size == 0\r\n    entry_price := na\r\n    highest_price := na\r\n    tp1_hit := false\r\n//#endregion\r\n\r\n//#region Plotting\r\nplot(vwap, color = vwap > ml_output ? bullColour : bearColour, linewidth = 2, title = 'VWAP')\r\nplot(ml_output, color = vwap > ml_output ? bullColour : bearColour, linewidth = 2, title = 'ML Prediction (Smoothed)')\r\nplot(upper_ml_band, color = color.new(bearColour, 50), linewidth = 1, title = 'Upper ML Band 1')\r\nplot(lower_ml_band, color = color.new(bullColour, 50), linewidth = 1, title = 'Lower ML Band 1')\r\nplot(upper_ml_band_2, color = color.new(bearColour, 30), linewidth = 1, title = 'Upper ML Band 2')\r\nplot(lower_ml_band_2, color = color.new(bullColour, 30), linewidth = 1, title = 'Lower ML Band 2')\r\n\r\n// Plot entry/exit markers\r\nif long_entry\r\n    label.new(bar_index, low, 'â–² LONG\\n' + str.tostring(close, '#.##'), yloc = yloc.belowbar, color = color.new(bullColour, 0), style = label.style_label_up, textcolor = color.white, size = shape_size_option)\r\n\r\n// Plot TP levels and stop loss when in position\r\nif strategy.position_size > 0 and not na(entry_price)\r\n    tp1_price = entry_price * (1 + tp1_percent / 100)\r\n    tp2_price = entry_price * (1 + tp2_percent / 100)\r\n    tp3_price = entry_price * (1 + tp3_percent / 100)\r\n    stop_price = entry_price * (1 - initial_stop_loss / 100)\r\n    \r\n    // Draw TP lines\r\n    var line tp1_line = na\r\n    var line tp2_line = na\r\n    var line tp3_line = na\r\n    var line stop_line = na\r\n    \r\n    line.delete(tp1_line)\r\n    line.delete(tp2_line)\r\n    line.delete(tp3_line)\r\n    line.delete(stop_line)\r\n    \r\n    tp1_line := line.new(bar_index, tp1_price, bar_index + 10, tp1_price, color = color.new(color.green, 60), width = 2, style = line.style_dashed, extend = extend.right)\r\n    tp2_line := line.new(bar_index, tp2_price, bar_index + 10, tp2_price, color = color.new(color.green, 40), width = 2, style = line.style_dashed, extend = extend.right)\r\n    tp3_line := line.new(bar_index, tp3_price, bar_index + 10, tp3_price, color = color.new(color.green, 20), width = 2, style = line.style_dashed, extend = extend.right)\r\n    \r\n    if enable_trailing and tp1_hit\r\n        trailing_stop = highest_price * (1 - trailing_stop_percent / 100)\r\n        stop_line := line.new(bar_index, trailing_stop, bar_index + 10, trailing_stop, color = color.new(color.red, 30), width = 2, style = line.style_solid, extend = extend.right)\r\n    else\r\n        stop_line := line.new(bar_index, stop_price, bar_index + 10, stop_price, color = color.new(color.red, 30), width = 2, style = line.style_solid, extend = extend.right)\r\n//#endregion\r\n\r\n//#region Candle Colours\r\nbarcolor(NeutralCandles ? neutralColours : na)\r\n//#endregion\r\n\r\n//#region Background Highlight\r\nbgcolor(source > upper_ml_band ? color.new(bullColour, 90) : source < lower_ml_band ? color.new(bearColour, 90) : na, title = 'Background Zone Highlight')\r\n//#endregion\r\n"
  },
  {
    "url": "A5WfhJfe-Stochastic-Hash-Strat-Hash-Capital-Research",
    "name": "Stochastic Hash Strat [Hash Capital Research]",
    "description": "# Stochastic Hash Strategy  by Hash Capital Research\n\n ## ðŸŽ¯ What Is This Strategy? \nThe **Stochastic Slow Strategy** is a momentum-based trading system that identifies oversold and overbought market conditions to capture mean-reversion opportunities. Think of it as a \"buy low, sell high\" approach with smart mathematical filters that remove emotion from your trading decisions.\n\nUnlike fast-moving indicators that generate excessive noise, this strategy uses **smoothed stochastic oscillators** to identify only the highest-probability setups when momentum truly shifts.\n\n---\n\n ## ðŸ’¡ Why This Strategy Works \nMost traders fail because they:\n- **Chase prices** after big moves (buying high, selling low)\n- **Overtrade** in choppy, directionless markets\n- **Exit too early** or hold losses too long\n\n This strategy solves all three problems: \n1. **Entry Discipline**: Only trades when the stochastic oscillator crosses in extreme zones (oversold for longs, overbought for shorts)\n2. **Cooldown Filter**: Prevents revenge trading by forcing a waiting period after each trade\n3. **Fixed Risk/Reward**: Pre-defined stop-loss and take-profit levels ensure consistent risk management\n\n**The Math Behind It**: The stochastic oscillator measures where the current price sits relative to its recent high-low range. When it's below 25, the market is oversold (time to buy). When above 70, it's overbought (time to sell). The crossover with its moving average confirms momentum is shifting.\n\n---\n\n## ðŸ“Š Best Markets & Timeframes\n\n### â­ OPTIMAL PERFORMANCE:\n\n**Crude Oil (WTI) - 12H Timeframe**\n- **Why it works**: Oil markets have predictable volatility patterns and respect technical levels\n\n**AAVE/USD - 4H to 12H Timeframe**\n- **Why it works**: DeFi tokens exhibit strong momentum cycles with clear extremes\n\n### âœ… Also Works Well On:\n- **BTC/USD** (12H, Daily) - Lower frequency but high win rate\n- **ETH/USD** (8H, 12H) - Balanced volatility and liquidity\n- **Gold (XAU/USD)** (Daily) - Classic mean-reversion asset\n- **EUR/USD** (4H, 8H) - Lower volatility, requires patience\n\n### âŒ Avoid Using On:\n- Timeframes below 4H (too much noise)\n- Low-liquidity altcoins (wide spreads kill performance)\n- Strongly trending markets without pullbacks (Bitcoin in 2021)\n- News-driven instruments during major events\n\n---\n\n## ðŸŽ›ï¸ Understanding The Settings\n\n### Core Stochastic Parameters\n\n**Stochastic Length (Default: 16)**\n- Controls the lookback period for price comparison\n- Lower = faster reactions, more signals (10-14 for volatile markets)\n- Higher = smoother signals, fewer trades (16-21 for stable markets)\n- **Pro tip**: Use 10 for crypto 4H, 16 for commodities 12H\n\n**Overbought Level (Default: 70)**\n- Threshold for short entries\n- Lower values (65-70) = more trades, earlier entries\n- Higher values (75-80) = fewer but higher-conviction trades\n- **Sweet spot**: 70 works for most assets\n\n**Oversold Level (Default: 25)**\n- Threshold for long entries  \n- Higher values (25-30) = more trades, earlier entries\n- Lower values (15-20) = fewer but stronger bounce setups\n- **Sweet spot**: 20-25 depending on market conditions\n\n**Smooth K & Smooth D (Default: 7 & 3)**\n- Additional smoothing to filter out whipsaws\n- K=7 makes the indicator slower and more reliable\n- D=3 is the signal line that confirms the trend\n- **Don't change these unless you know what you're doing**\n\n---\n\n### Risk Management\n\n**Stop Loss % (Default: 2.2%)**\n- Automatically exits losing trades\n- Should be 1.5x to 2x your average market volatility\n- Too tight = death by a thousand cuts\n- Too wide = uncontrolled losses\n- **Calibration**: Check ATR indicator and set SL slightly above it\n\n**Take Profit % (Default: 7%)**\n- Automatically exits winning trades\n- Should be 2.5x to 3x your stop loss (reward-to-risk ratio)\n- This default gives 7% / 2.2% = 3.18:1 R:R\n- **The golden rule**: Never have R:R below 2:1\n\n---\n\n### Trade Filters\n\n**Bar Cooldown Filter (Default: ON, 3 bars)**\n- **What it does**: Forces you to wait X bars after closing a trade before entering a new one\n- **Why it matters**: Prevents emotional revenge trading and overtrading in choppy markets\n- **Settings guide**:\n  - 3 bars = Standard (good for most cases)\n  - 5-7 bars = Conservative (oil, slow-moving assets)\n  - 1-2 bars = Aggressive (only for experienced traders)\n\n**Exit on Opposite Extreme (Default: ON)**\n- Closes your long when stochastic hits overbought (and vice versa)\n- Acts as an early profit-taking mechanism\n- **Leave this ON** unless you're testing other exit strategies\n\n**Divergence Filter (Default: OFF)**\n- Looks for price/momentum divergences for additional confirmation\n- **When to enable**: Trending markets where you want fewer but higher-quality trades\n- **Keep OFF for**: Mean-reverting markets (oil, forex, most of the time)\n\n---\n\n## ðŸš€ Quick Start Guide\n\n### Step 1: Set Up in TradingView\n\n1. Open TradingView and navigate to your chart\n2. Click \"Pine Editor\" at the bottom\n3. Copy and paste the strategy code\n4. Click \"Add to Chart\"\n5. The strategy will appear in a separate pane below your price chart\n\n### Step 2: Choose Your Market\n\n**If you're trading Crude Oil:**\n- Timeframe: 12H\n- Keep all default settings\n- Watch for signals during London/NY overlap (8am-11am EST)\n\n**If you're trading AAVE or crypto:**\n- Timeframe: 4H or 12H\n- Consider these adjustments:\n  - Stochastic Length: 10-14 (faster)\n  - Oversold: 20 (more aggressive)\n  - Take Profit: 8-10% (higher targets)\n\n### Step 3: Wait for Your First Signal\n\n**LONG Entry** (Green circle appears):\n- Stochastic crosses up below oversold level (25)\n- Price likely near recent lows\n- System places limit order at take profit and stop loss\n\n**SHORT Entry** (Red circle appears):\n- Stochastic crosses down above overbought level (70)\n- Price likely near recent highs\n- System places limit order at take profit and stop loss\n\n**EXIT** (Orange circle):\n- Position closes either at stop, target, or opposite extreme\n- Cooldown period begins\n\n### Step 4: Let It Run\n\nThe biggest mistake? **Interfering with the system.**\n\n- Don't close trades early because you're scared\n- Don't skip signals because you \"have a feeling\"\n- Don't increase position size after a big win\n- Don't revenge trade after a loss\n\n**Follow the system or don't use it at all.**\n\n---\n\n### Important Risks:\n1. **Drawdown Pain**: You WILL experience losing streaks of 5-7 trades. This is mathematically normal.\n2. **Whipsaw Markets**: Choppy, range-bound conditions can trigger multiple small losses.\n3. **Gap Risk**: Overnight gaps can cause your actual fill to be worse than the stop loss.\n4. **Slippage**: Real execution prices differ from backtested prices (factor in 0.1-0.2% slippage).\n\n---\n\n## ðŸ”§ Optimization Guide\n\n### When to Adjust Settings:\n\n**Market Volatility Increased?**\n- Widen stop loss by 0.5-1%\n- Increase take profit proportionally\n- Consider increasing cooldown to 5-7 bars\n\n**Getting Too Few Signals?**\n- Decrease stochastic length to 10-12\n- Increase oversold to 30, decrease overbought to 65\n- Reduce cooldown to 2 bars\n\n**Getting Too Many Losses?**\n- Increase stochastic length to 18-21 (slower, smoother)\n- Enable divergence filter\n- Increase cooldown to 5+ bars\n- Verify you're on the right timeframe\n\n### A/B Testing Method:\n\n1. **Run default settings for 50 trades** on your chosen market\n2. Document: Win rate, profit factor, max drawdown, emotional tolerance\n3. **Change ONE variable** (e.g., oversold from 25 to 20)\n4. Run another 50 trades\n5. Compare results\n6. Keep the better version\n\n**Never change multiple settings at once** or you won't know what worked.\n\n---\n\n## ðŸ“š Educational Resources\n\n### Key Concepts to Learn:\n\n**Stochastic Oscillator**\n- Developed by George Lane in the 1950s\n- Measures momentum by comparing closing price to price range\n- Formula: %K = (Close - Low) / (High - Low) Ã— 100\n- Similar to RSI but more sensitive to price movements\n\n**Mean Reversion vs. Trend Following**\n- This is a **mean reversion** strategy (price returns to average)\n- Works best in ranging markets with defined support/resistance\n- Fails in strong trending markets (2017 Bitcoin, 2020 Tech stocks)\n- Complement with trend filters for better results\n\n**Risk:Reward Ratio**\n- The cornerstone of profitable trading\n- Winning 40% of trades with 3:1 R:R = profitable\n- Winning 60% of trades with 1:1 R:R = breakeven (after fees)\n- **This strategy aims for 45% win rate with 2.5-3:1 R:R**\n\n### Recommended Reading:\n- *\"Trading Systems and Methods\"* by Perry Kaufman (Chapter on Oscillators)\n- *\"Mean Reversion Trading Systems\"* by Howard Bandy\n- *\"The New Trading for a Living\"* by Dr. Alexander Elder\n\n---\n\n## ðŸ› ï¸ Troubleshooting\n\n### \"I'm not seeing any signals!\"\n\n**Check:**\n- Is your timeframe 4H or higher?\n- Is the stochastic actually reaching extreme levels (check if your asset is stuck in middle range)?\n- Is cooldown still active from a previous trade?\n- Are you on a low-liquidity pair?\n\n**Solution**: Switch to a more volatile asset or lower the overbought/oversold thresholds.\n\n---\n\n### \"The strategy keeps losing money!\"\n\n**Check:**\n- What's your win rate? (Below 35% is concerning)\n- What's your profit factor? (Below 0.8 means serious issues)\n- Are you trading during major news events?\n- Is the market in a strong trend?\n\n**Solution**: \n1. Verify you're using recommended markets/timeframes\n2. Increase cooldown period to avoid choppy markets\n3. Reduce position size to 5% while you diagnose\n4. Consider switching to daily timeframe for less noise\n\n---\n\n### \"My stop losses keep getting hit!\"\n\n**Check:**\n- Is your stop loss tighter than the average ATR?\n- Are you trading during high-volatility sessions?\n- Is slippage eating into your buffer?\n\n**Solution**:\n1. Calculate the 14-period ATR\n2. Set stop loss to 1.5x the ATR value\n3. Avoid trading right after market open or major news\n4. Factor in 0.2% slippage for crypto, 0.1% for oil\n\n---\n\n## ðŸ’ª Pro Tips from the Trenches\n\n### Psychological Discipline\n\n**The Three Deadly Sins:**\n1. **Skipping signals** - \"This one doesn't feel right\"\n2. **Early exits** - \"I'll just take profit here to be safe\"\n3. **Revenge trading** - \"I need to make back that loss NOW\"\n\n**The Solution:** Treat your strategy like a business system. Would McDonald's skip making fries because the cashier \"doesn't feel like it today\"? No. Systems work because of consistency.\n\n---\n\n### Position Management\n\n**Scaling In/Out** (Advanced)\n- Enter 50% position at signal\n- Add 50% if stochastic reaches 10 (oversold) or 90 (overbought)\n- Exit 50% at 1.5x take profit, let the rest run\n\n**This is NOT for beginners.** Master the basic system first.\n\n---\n\n### Market Awareness\n\n**Oil Traders:**\n- OPEC meetings = volatility spikes (avoid or widen stops)\n- US inventory reports (Wed 10:30am EST) = avoid trading 2 hours before/after\n- Summer driving season = different patterns than winter\n\n**Crypto Traders:**\n- Monday-Tuesday = typically lower volatility (fewer signals)\n- Thursday-Sunday = higher volatility (more signals)\n- Avoid trading during exchange maintenance windows\n\n---\n\n## âš–ï¸ Legal Disclaimer\n\nThis trading strategy is provided for **educational purposes only**. \n\n- Past performance does not guarantee future results\n- Trading involves substantial risk of loss\n- Only trade with capital you can afford to lose\n- No one associated with this strategy is a licensed financial advisor\n- You are solely responsible for your trading decisions\n\n**By using this strategy, you acknowledge that you understand and accept these risks.**\n\n---\n\n## ðŸ™ Acknowledgments\n\nStrategy development inspired by:\n- George Lane's original Stochastic Oscillator work\n- Modern quantitative trading research\n- Community feedback from hundreds of backtests\n\nBuilt with â¤ï¸ for retail traders who want systematic, disciplined approaches to the markets.\n\n---\n\n**Good luck, stay disciplined, and trade the system, not your emotions.**\n",
    "image_url": "A5WfhJfe",
    "author": "Hash_Capital",
    "likes": 59,
    "type": "strategy",
    "created": "2025-11-24",
    "updated": "2025-11-24",
    "source": "//@version=6\r\nstrategy(\"Stochastic Hash Strat [Hash Capital Research]\",\r\n     overlay=false,\r\n     initial_capital=10000,\r\n     default_qty_type=strategy.percent_of_equity,\r\n     default_qty_value=10,\r\n     commission_type=strategy.commission.percent,\r\n     commission_value=0.075)\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// INPUT PARAMETERS - OPTIMIZED DEFAULTS\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n\r\n// Stochastic Settings\r\nlength      = input.int(16, \"Stochastic Length\", minval=1, group=\"Stochastic Settings\")\r\nOverBought  = input.int(70, \"Overbought Level\", minval=50, maxval=100, group=\"Stochastic Settings\")\r\nOverSold    = input.int(25, \"Oversold Level\", minval=0, maxval=50, group=\"Stochastic Settings\")\r\nsmoothK     = input.int(7, \"Smooth K\", minval=1, group=\"Stochastic Settings\")\r\nsmoothD     = input.int(3, \"Smooth D\", minval=1, group=\"Stochastic Settings\")\r\n\r\n// Risk Management\r\nstopLossPerc     = input.float(2.2, \"Stop Loss %\", minval=0.1, maxval=10, step=0.1, group=\"Risk Management\")\r\ntakeProfitPerc   = input.float(7.0, \"Take Profit %\", minval=0.1, maxval=20, step=0.1, group=\"Risk Management\")\r\n\r\n// Exit Settings\r\nexitOnOppositeExtreme = input.bool(true, \"Exit on Opposite Extreme\", group=\"Exit Settings\")\r\n\r\n// Bar Cooldown Filter\r\nuseCooldown = input.bool(true, \"Use Bar Cooldown Filter\", group=\"Trade Filters\")\r\ncooldownBars = input.int(3, \"Cooldown Bars\", minval=1, maxval=20, group=\"Trade Filters\")\r\n\r\n// Divergence Settings\r\nuseDivergence = input.bool(false, \"Use Divergence Filter\", group=\"Divergence Settings\")\r\nlookbackRight = input.int(5, \"Pivot Lookback Right\", minval=1, group=\"Divergence Settings\")\r\nlookbackLeft  = input.int(5, \"Pivot Lookback Left\", minval=1, group=\"Divergence Settings\")\r\nrangeUpper    = input.int(60, \"Max Lookback Range\", minval=1, group=\"Divergence Settings\")\r\nrangeLower    = input.int(5, \"Min Lookback Range\", minval=1, group=\"Divergence Settings\")\r\n\r\n// Visual Settings\r\nshowSignals = input.bool(true, \"Show Entry/Exit Circles\", group=\"Visual Settings\")\r\nshowDivLines = input.bool(false, \"Show Divergence Lines\", group=\"Visual Settings\")\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// STOCHASTIC CALCULATION\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n\r\nk = ta.sma(ta.stoch(close, high, low, length), smoothK)\r\nd = ta.sma(k, smoothD)\r\n\r\n// Crossover signals\r\nbullishCross = ta.crossover(k, d)\r\nbearishCross = ta.crossunder(k, d)\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// BAR COOLDOWN FILTER\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n\r\nvar int lastExitBar = na\r\nvar bool inCooldown = false\r\n\r\n// Track when position closes\r\nif strategy.position_size[1] != 0 and strategy.position_size == 0\r\n    lastExitBar := bar_index\r\n    inCooldown := true\r\n\r\n// Check if cooldown period has passed\r\nif not na(lastExitBar) and bar_index - lastExitBar >= cooldownBars\r\n    inCooldown := false\r\n\r\n// Apply cooldown filter\r\ncooldownFilter = useCooldown ? not inCooldown : true\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// DIVERGENCE DETECTION\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n\r\npriceLowPivot  = ta.pivotlow(close, lookbackLeft, lookbackRight)\r\npriceHighPivot = ta.pivothigh(close, lookbackLeft, lookbackRight)\r\nstochLowPivot  = ta.pivotlow(k, lookbackLeft, lookbackRight)\r\nstochHighPivot = ta.pivothigh(k, lookbackLeft, lookbackRight)\r\n\r\nvar float lastPriceLow = na\r\nvar float lastStochLow = na\r\nvar int lastLowBar = na\r\nvar float lastPriceHigh = na\r\nvar float lastStochHigh = na\r\nvar int lastHighBar = na\r\n\r\nbullishDiv = false\r\nbearishDiv = false\r\n\r\n// Bullish Divergence\r\nif not na(priceLowPivot) and k < OverSold\r\n    if not na(lastPriceLow) and not na(lastStochLow)\r\n        barsBack = bar_index - lastLowBar\r\n        if barsBack >= rangeLower and barsBack <= rangeUpper\r\n            if priceLowPivot < lastPriceLow and stochLowPivot > lastStochLow\r\n                bullishDiv := true\r\n    \r\n    lastPriceLow := priceLowPivot\r\n    lastStochLow := stochLowPivot\r\n    lastLowBar := bar_index - lookbackRight\r\n\r\n// Bearish Divergence\r\nif not na(priceHighPivot) and k > OverBought\r\n    if not na(lastPriceHigh) and not na(lastStochHigh)\r\n        barsBack = bar_index - lastHighBar\r\n        if barsBack >= rangeLower and barsBack <= rangeUpper\r\n            if priceHighPivot > lastPriceHigh and stochHighPivot < lastStochHigh\r\n                bearishDiv := true\r\n    \r\n    lastPriceHigh := priceHighPivot\r\n    lastStochHigh := stochHighPivot\r\n    lastHighBar := bar_index - lookbackRight\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// ENTRY CONDITIONS\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n\r\nlongCondition = if useDivergence\r\n    bullishCross and k < OverSold and bullishDiv and cooldownFilter\r\nelse\r\n    bullishCross and k < OverSold and cooldownFilter\r\n\r\nshortCondition = if useDivergence\r\n    bearishCross and k > OverBought and bearishDiv and cooldownFilter\r\nelse\r\n    bearishCross and k > OverBought and cooldownFilter\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// STRATEGY EXECUTION\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n\r\n// Long Entry\r\nif longCondition and strategy.position_size == 0\r\n    stopPrice = close * (1 - stopLossPerc / 100)\r\n    targetPrice = close * (1 + takeProfitPerc / 100)\r\n    \r\n    strategy.entry(\"Long\", strategy.long)\r\n    strategy.exit(\"Long Exit\", \"Long\", stop=stopPrice, limit=targetPrice)\r\n\r\n// Short Entry\r\nif shortCondition and strategy.position_size == 0\r\n    stopPrice = close * (1 + stopLossPerc / 100)\r\n    targetPrice = close * (1 - takeProfitPerc / 100)\r\n    \r\n    strategy.entry(\"Short\", strategy.short)\r\n    strategy.exit(\"Short Exit\", \"Short\", stop=stopPrice, limit=targetPrice)\r\n\r\n// Exit on Opposite Extreme\r\nif exitOnOppositeExtreme\r\n    if strategy.position_size > 0 and k > OverBought\r\n        strategy.close(\"Long\", comment=\"Exit OB\")\r\n    \r\n    if strategy.position_size < 0 and k < OverSold\r\n        strategy.close(\"Short\", comment=\"Exit OS\")\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// VISUAL ELEMENTS - STOCHASTIC PANE\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n\r\n// Plot stochastic lines with gradient colors\r\nkColor = k > OverBought ? color.new(#FF0055, 0) : k < OverSold ? color.new(#00FF88, 0) : color.new(#00BBFF, 0)\r\ndColor = color.new(#FFB300, 30)\r\n\r\nplot(k, \"Stochastic %K\", color=kColor, linewidth=2)\r\nplot(d, \"Stochastic %D\", color=dColor, linewidth=2)\r\n\r\n// Add glow effect to K line\r\nplot(k, \"K Glow\", color=color.new(kColor, 70), linewidth=4)\r\n\r\n// Plot levels\r\nobLine = hline(OverBought, \"Overbought\", color=color.new(#FF0055, 60), linestyle=hline.style_dashed, linewidth=1)\r\nosLine = hline(OverSold, \"Oversold\", color=color.new(#00FF88, 60), linestyle=hline.style_dashed, linewidth=1)\r\nmidLine = hline(50, \"Midline\", color=color.new(color.gray, 70), linestyle=hline.style_dotted)\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// FLUORESCENT SIGNAL CIRCLES\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n\r\n// Long signal - Bright green fluorescent circle\r\nlongSignalLevel = longCondition ? k : na\r\nplot(longSignalLevel, \"Long Signal\", color=color.new(#00FF88, 0), style=plot.style_circles, linewidth=6)\r\nplot(longSignalLevel, \"Long Glow\", color=color.new(#00FF88, 60), style=plot.style_circles, linewidth=10)\r\n\r\n// Short signal - Bright magenta fluorescent circle  \r\nshortSignalLevel = shortCondition ? k : na\r\nplot(shortSignalLevel, \"Short Signal\", color=color.new(#FF0055, 0), style=plot.style_circles, linewidth=6)\r\nplot(shortSignalLevel, \"Short Glow\", color=color.new(#FF0055, 60), style=plot.style_circles, linewidth=10)\r\n\r\n// Exit signals - Orange fluorescent circles\r\nlongExitSignal = strategy.position_size[1] > 0 and strategy.position_size == 0\r\nshortExitSignal = strategy.position_size[1] < 0 and strategy.position_size == 0\r\n\r\nexitLevel = longExitSignal or shortExitSignal ? k : na\r\nplot(exitLevel, \"Exit Signal\", color=color.new(#FF8800, 0), style=plot.style_circles, linewidth=4)\r\nplot(exitLevel, \"Exit Glow\", color=color.new(#FF8800, 70), style=plot.style_circles, linewidth=8)\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// DIVERGENCE INDICATORS\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n\r\nif showDivLines and bullishDiv\r\n    label.new(bar_index, 10, \"ðŸ”º Bull Div\", style=label.style_none, color=na, textcolor=color.new(#00FF88, 0), size=size.tiny)\r\n\r\nif showDivLines and bearishDiv\r\n    label.new(bar_index, 90, \"ðŸ”» Bear Div\", style=label.style_none, color=na, textcolor=color.new(#FF0055, 0), size=size.tiny)\r\n\r\n// Cooldown indicator\r\nif useCooldown and inCooldown\r\n    label.new(bar_index, k, \"â¸\", style=label.style_none, color=na, textcolor=color.new(color.gray, 50), size=size.tiny, tooltip=\"Cooldown Active\")"
  },
  {
    "url": "bldXp6gY-RSI-Adaptive-T3-SAR-Strategy-PrimeAutomation",
    "name": "RSI-Adaptive T3 & SAR Strategy [PrimeAutomation]",
    "description": "â¯ OVERVIEW   \nThe  RSI-Adaptive T3 and SAR Confluence Strategy  combines adaptive smoothing with dynamic trend confirmation to identify precise trend reversals and continuation opportunities. It fuses the power of an  RSI-based adaptive T3 moving average  with the  Parabolic SAR filter , aiming to trade in harmony with dominant momentum shifts while maintaining tight control through automatic stop-loss placement.\n\nThe RSI-Adaptive T3 is a precision trend-following tool built around the legendary T3 smoothing algorithm developed by Tim Tillson, designed to enhance responsiveness while reducing lag compared to traditional moving averages. Current implementation takes it a step further by dynamically adapting the smoothing length based on real-time RSI conditions â€” allowing the T3 to â€œbreatheâ€ with market volatility. This dynamic length makes the curve faster in trending moves and smoother during consolidations.\n\nTo help traders visualize volatility and directional momentum, adaptive volatility bands are plotted around the T3 line, with visual crossover markers and a dynamic info panel on the chart. Itâ€™s ideal for identifying trend shifts, spotting momentum surges, and adapting strategy execution to the pace of the market.\n\n â¯ LOGIC   \n   \n  The  T3 moving average  length dynamically adjusts based on RSI values â€” when RSI is high, the smoothing period shortens to react faster; when RSI is low, the period increases for stability in slow markets.  \n  \n  A  Parabolic SAR filter  confirms directional bias, ensuring trades only occur in alignment with the broader market trend.  \n  \n   Long Entries:  Trigger when the T3 curve crosses upward while the current price remains above the SAR â€” signaling bullish momentum alignment.  \n  \n   Short Entries:  Trigger when the T3 crosses downward while the price remains below the SAR â€” confirming bearish trend alignment.  \n  \n   Stops:  Dynamic stops are placed using the highest or lowest price over a set lookback period, adapting automatically to market volatility.  \n  \n \n\n â¯ FEATURES   \n   \n   RSI-Adaptive T3 Filter:  Adjusts smoothing in real time to market conditions, blending responsiveness with noise reduction.  \n   SAR Confluence Check:  Prevents counter-trend entries by confirming momentum direction via the Parabolic SAR.  \n   Automatic Stop Placement:  Uses recent highs or lows as stop-loss anchors, minimizing risk exposure.  \n   Color-coded Visualization:  The T3 line dynamically changes color based on slope direction, making momentum shifts visually intuitive.  \n   Smoothed Trend Structure:  Reduces market noise, allowing cleaner, more reliable trend recognition across different assets.  \n \n\n â¯ CONCLUSION   \nThe  RSI-Adaptive T3 and SAR Confluence Strategy  delivers an advanced fusion of adaptive smoothing and structural confirmation. By combining RSI-driven reactivity with Parabolic SAR trend validation, this strategy offers a balanced approach to identifying sustainable momentum reversals while maintaining strong risk management through automatic stop levels. Ideal for traders who seek precision entries aligned with adaptive trend dynamics.  \n",
    "image_url": "bldXp6gY",
    "author": "ChartPrime",
    "likes": 1569,
    "type": "strategy",
    "created": "2025-11-24",
    "updated": "2025-11-24",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// Â© PrimeAutomation\r\n//@strategy_alert_message {{strategy.order.alert_message}}\r\n\r\n//@version=6\r\nstrategy(\"RSI-Adaptive T3 & SAR Strategy [PrimeAutomation]\", overlay=true\r\n , default_qty_type = strategy.percent_of_equity\r\n , default_qty_value = 10 \r\n , commission_type = strategy.commission.percent \r\n , commission_value = 0.06 \r\n , initial_capital = 10000\r\n , margin_long = 0\r\n , margin_short = 0\r\n , process_orders_on_close = true\r\n , pyramiding = 0\r\n )\r\n\r\n\r\nstring OpSettings           = \"âžž Optimization Settings ðŸ”¸\"\r\nstring OpSettings1          = \"âžž Settings ðŸ”¸\"\r\n\r\n\r\n// Strategy Settings\r\nstartTime     = input.time(timestamp(\"01-01-2023\"), \"Strategy Start Date\", group = OpSettings1)\r\nMarketClosed  = input.bool(false ,\"Exit before market close\", group = OpSettings1)\r\n\r\n\r\nvar StartTIME = 0\r\ntotaltrades = strategy.closedtrades\r\nPNL = strategy.netprofit_percent + strategy.openprofit_percent\r\nWinRate = (strategy.wintrades / totaltrades ) * 100 \r\nMaxDraw = strategy.max_drawdown_percent\r\n\r\nCon = strategy.closedtrades == 0 and strategy.opentrades == 1 \r\nStartTIME:= ta.valuewhen(Con and not Con[1],time,0)\r\n\r\n\r\nvar float dailyPNL = na\r\nvar int maxDays = 60\r\nvar float lastNetProfit = na\r\nvar array<string> PNLS = array.new_string()\r\n\r\nnewDay = ta.change(time(\"D\")) != 0\r\ncurrentNetProfit = strategy.netprofit\r\n\r\nif newDay\r\n    if not na(lastNetProfit)\r\n        dailyPNL := currentNetProfit - lastNetProfit\r\n\r\n        if dailyPNL != 0\r\n            dateStr = str.format(\"{0,date,MM-dd}\", time)\r\n            combined = dateStr + \":\" + str.tostring(dailyPNL, \"#.##\")\r\n            array.unshift(PNLS, combined)\r\n\r\n            if array.size(PNLS) > maxDays\r\n                array.pop(PNLS)\r\n\r\n    lastNetProfit := currentNetProfit\r\n\r\n\r\n\r\n// log.error(str.tostring(PNLS))\r\n\r\nMC()=>\r\n    hr = hour == 15\r\n    min = minute == 55\r\n    _Hr = request.security(syminfo.tickerid,\"5\",hr)\r\n    _min = request.security(syminfo.tickerid,\"5\",min)\r\n    MClose = (_Hr and _min )\r\n    MClose\r\n\r\ntradesCount = strategy.closedtrades\r\n\r\n// Get PnL of last closed trade\r\nLastPNL = 0.\r\nif tradesCount > 0\r\n    LastPNL := strategy.closedtrades.profit(tradesCount - 1)\r\n\r\n\r\n\r\nmethod parseing(string st,tp = 0 , sl = 0 , size = 0 , per = 0.)=>\r\n    string ret = st\r\n    ret := str.replace_all(ret, \"{{tickerid}}\", syminfo.tickerid)\r\n    ret := str.replace_all(ret, \"{{ticker}}\", syminfo.ticker)\r\n    ret := str.replace_all(ret, \"{{exchange}}\", syminfo.prefix)\r\n    ret := str.replace_all(ret, \"{{close}}\", str.tostring(close))\r\n    ret := str.replace_all(ret, \"{{open}}\", str.tostring(open))\r\n    ret := str.replace_all(ret, \"{{high}}\", str.tostring(high))\r\n    ret := str.replace_all(ret, \"{{low}}\", str.tostring(low))\r\n    ret := str.replace_all(ret, \"{{time}}\", str.format_time(time, \"yyyy-MM-dd HH:mm\", syminfo.timezone))\r\n    ret := str.replace_all(ret, \"{{timenow}}\", str.format_time(timenow, \"yyyy-MM-dd HH:mm\", syminfo.timezone))\r\n    ret := str.replace_all(ret, \"{{volume}}\", str.tostring(volume))\r\n    ret := str.replace_all(ret, \"{{interval}}\", timeframe.period)\r\n    ret := str.replace_all(ret, \"{{country}}\", syminfo.country)\r\n    ret := str.replace_all(ret, \"{{description}}\", syminfo.description)\r\n    ret := str.replace_all(ret, \"{{root}}\", syminfo.root)\r\n    ret := str.replace_all(ret, \"{{industry}}\", syminfo.industry)\r\n    ret := str.replace_all(ret, \"{{type}}\", syminfo.type)\r\n    ret := str.replace_all(ret, \"{{tp}}\", str.tostring(tp))\r\n    ret := str.replace_all(ret, \"{{sl}}\", str.tostring(sl))\r\n    ret := str.replace_all(ret, \"{{size}}\", str.tostring(size))\r\n    ret := str.replace_all(ret, \"{{per}}\", str.tostring(per))\r\n    ret := str.replace_all(ret, \"{{TotalTrades}}\", str.tostring(strategy.closedtrades))\r\n    ret := str.replace_all(ret, \"{{PNL}}\", str.tostring(strategy.netprofit_percent + strategy.openprofit_percent,\"#.##\"))\r\n    ret := str.replace_all(ret, \"{{WinRate}}\", str.tostring((strategy.wintrades / totaltrades) * 100 ,\"#.##\"))\r\n    ret := str.replace_all(ret, \"{{MaxDraw}}\", str.tostring(strategy.max_drawdown_percent,\"#.##\" ))\r\n    ret := str.replace_all(ret, \"{{StartDate}}\", str.format(\"{0,date,medium}\",StartTIME))\r\n    ret := str.replace_all(ret, \"{{DailyPnl}}\", str.tostring(dailyPNL,\"#.##\"))\r\n    ret := str.replace_all(ret, \"{{historyPNL}}\", str.tostring(PNLS))\r\n    ret := str.replace_all(ret, \"{{LastPNL}}\", str.tostring(LastPNL))\r\n    ret\r\n\r\n\r\n\r\nLongEntryMSG   = '{\"ticker\": \"{{ticker}}\",\"action\": \"buy\",\"price\": \"{{close}}\", \"time\": \"{{timenow}}\", \"size\": \"{{size}}\",\"TotalTrades\":  \"{{TotalTrades}}\" ,\"PNL\": \"{{PNL}}\", \"WinRate\":  \"{{WinRate}}\", \"MaxDraw\": \"{{MaxDraw}}\", \"StartDate\":  \"{{StartDate}}\", \"DailyPNL\": \"{{DailyPnl}}\"}'\r\nLongExitMSG    = '{\"ticker\": \"{{ticker}}\",\"action\": \"exit_buy\",\"price\": \"{{close}}\", \"time\": \"{{timenow}}\", \"size\": \"{{size}}\", \"per\": \"{{per}}\", \"sl\": \"{{sl}}\", \"tp\": \"{{tp}}\",\"TotalTrades\":  \"{{TotalTrades}}\" ,\"PNL\": \"{{PNL}}\", \"WinRate\":  \"{{WinRate}}\", \"MaxDraw\": \"{{MaxDraw}}\", \"StartDate\":  \"{{StartDate}}\", \"DailyPNL\": \"{{DailyPnl}}\"}'\r\nShortEntryMSG  = '{\"ticker\": \"{{ticker}}\",\"action\": \"sell\",\"price\": \"{{close}}\", \"time\": \"{{timenow}}\", \"size\": \"{{size}}\",\"TotalTrades\":  \"{{TotalTrades}}\" ,\"PNL\": \"{{PNL}}\", \"WinRate\":  \"{{WinRate}}\", \"MaxDraw\": \"{{MaxDraw}}\", \"StartDate\":  \"{{StartDate}}\", \"DailyPNL\": \"{{DailyPnl}}\"}'\r\nShortExitMSG   = '{\"ticker\": \"{{ticker}}\",\"action\": \"exit_sell\",\"price\": \"{{close}}\", \"time\": \"{{timenow}}\", \"size\": \"{{size}}\", \"per\": \"{{per}}\", \"sl\": \"{{sl}}\", \"tp\": \"{{tp}}\",\"TotalTrades\":  \"{{TotalTrades}}\" ,\"PNL\": \"{{PNL}}\", \"WinRate\":  \"{{WinRate}}\", \"MaxDraw\": \"{{MaxDraw}}\", \"StartDate\":  \"{{StartDate}}\", \"DailyPNL\": \"{{DailyPnl}}\"}'\r\n\r\n\r\n\r\n\r\nvar float currentSize = na\r\nisNewTrade = strategy.opentrades > strategy.opentrades[1]\r\n\r\nif isNewTrade\r\n    currentSize := math.abs(strategy.opentrades.size(strategy.opentrades -1))\r\n\r\n\r\n\r\nMarketisClose = MC()\r\n\r\n\r\n// --------------------------------------------------------------------------------------------------------------------}\r\n// ðŸ“Œ ð™ð™Žð™€ð™ ð™„ð™‰ð™‹ð™ð™ð™Ž\r\n// --------------------------------------------------------------------------------------------------------------------{\r\n\r\nsrc         = close\r\nrsiLen      = input.int(14, 'RSI Length', group = \"T3\")\r\nminLen      = input.int(5, 'Min T3 Length', group = \"T3\")\r\nmaxLen      = input.int(50, 'Max T3 Length', group = \"T3\")\r\nv           = input.float(0.7, 'T3 Volume Factor', step = 0.01, maxval = 2, minval = 0.1, group = \"T3\")\r\n\r\nstart = input.float(0.02, step = 0.0001, group = \"SAR Filter\")\r\nincrement = input.float(0.0002, step = 0.00011, group = \"SAR Filter\")\r\nmaximum = input(0.21, group = \"SAR Filter\")\r\n\r\n\r\nstopLen = input.int(10, \"Stop Loss Length\")\r\n\r\n\r\n\r\ncolor_up    = input.color(#21b8f3, \"\", inline = \"col\")\r\ncolor_dn    = input.color(#fd761b, \"\", inline = \"col\")\r\n\r\n\r\n\r\n// --------------------------------------------------------------------------------------------------------------------}\r\n// ðŸ“Œ ð™„ð™‰ð˜¿ð™„ð˜¾ð˜¼ð™ð™Šð™ ð˜¾ð˜¼ð™‡ð˜¾ð™ð™‡ð˜¼ð™ð™„ð™Šð™‰ð™Ž\r\n// --------------------------------------------------------------------------------------------------------------------{\r\n\r\n// Step 1: Adaptive length via RSI\r\nrsi = ta.rsi(src, rsiLen)\r\nrsi_scale = 1 - rsi / 100\r\nlen = math.round(minLen + (maxLen - minLen) * rsi_scale)\r\n\r\npine_ema(src, length) =>\r\n    alpha = 2 / (length + 1)\r\n    sum = 0.0\r\n    sum := na(sum[1]) ? src : alpha * src + (1 - alpha) * nz(sum[1])\r\n    sum\r\n\r\n// Step 2: T3 with adaptive length\r\ne1 = pine_ema(src, len)\r\ne2 = pine_ema(e1, len)\r\ne3 = pine_ema(e2, len)\r\ne4 = pine_ema(e3, len)\r\ne5 = pine_ema(e4, len)\r\ne6 = pine_ema(e5, len)\r\n\r\nc1 = -v * v * v\r\nc2 = 3 * v * v + 3 * v * v * v\r\nc3 = -6 * v * v - 3 * v - 3 * v * v * v\r\nc4 = 1 + 3 * v + v * v * v + 3 * v * v\r\nt3 = c1 * e6 + c2 * e5 + c3 * e4 + c4 * e3\r\n\r\nt3_col = t3 > t3[2] ? color_up : color_dn\r\n\r\n\r\n\r\n\r\nL = ta.lowest(stopLen)\r\nH = ta.highest(stopLen)\r\n\r\nimport TradingView/ta/7 as ta\r\n\r\n\r\nsar = ta.sar(start, increment, maximum)\r\n\r\nLong = close > sar\r\n\r\nBuy  = ta.crossover(t3, t3[2]) and Long and strategy.position_size <= 0\r\nSell = ta.crossunder(t3, t3[2]) and not Long and strategy.position_size >= 0\r\n\r\nBuyExit = ta.crossunder(t3, t3[2])\r\nSellExit = ta.crossover(t3, t3[2])\r\n\r\nplot(Long != Long[1] ? float(na) : sar, \"SAR Filter\", linewidth=2, color = close > sar ? color_up : color_dn, style = plot.style_circles)\r\n\r\n\r\nplotchar(Buy or Sell ? t3 : na, \"\", \"ðŸž›\", location.absolute, t3_col)\r\npt31 = plot(t3, \"T3\", color = t3_col, linewidth = 1, editable = true)\r\npt32 = plot(t3[2], \"T3\", color = t3_col, linewidth = 1, editable = true)\r\nfill(pt31, pt32, color.new(t3_col, 90))\r\n\r\nvar stop = float(na)\r\n\r\n\r\n// Strategy Execution\r\n\r\nif time >= startTime \r\n\r\n    if strategy.opentrades == 0\r\n        stop := float(na)\r\n    // Trades\r\n    if Buy\r\n        strategy.close('Short', 'Short Exit', alert_message = ShortExitMSG.parseing(per = 100,size = math.abs(strategy.position_size)))   \r\n        strategy.entry(\"Long\", strategy.long, comment=\"Long\", alert_message =  LongEntryMSG.parseing( size = currentSize ))\r\n        stop := L\r\n    if Sell\r\n        strategy.close('Long', 'Long Exit', alert_message = LongExitMSG.parseing(per = 100,size = math.abs(strategy.position_size))) \r\n        strategy.entry(\"Short\", strategy.short, comment=\"Short\", alert_message =  ShortEntryMSG.parseing( size = currentSize))\r\n        stop := H\r\n    // Exits\r\n    // if BuyExit\r\n    //     strategy.close('Long', 'Long Exit', alert_message = LongExitMSG.parseing(per = 100,size = math.abs(strategy.position_size))) \r\n    // if SellExit\r\n    //     strategy.close('Short', 'Short Exit', alert_message = ShortExitMSG.parseing(per = 100,size = math.abs(strategy.position_size)))   \r\n\r\n    strategy.exit(\"Long Stop\", \"Long\", qty_percent = 100, stop = stop, alert_message = LongExitMSG.parseing(per = 100,size = math.abs(strategy.position_size)))\r\n    strategy.exit(\"Short Stop\", \"Short\", qty_percent = 100, stop = stop, alert_message = ShortExitMSG.parseing(per = 100,size = math.abs(strategy.position_size)))\r\n\r\n\r\nplot(stop != stop[1] ? float(na) : stop, \"Stop\", color = chart.fg_color, style = plot.style_linebr)\r\n\r\n// --------------------------------------------------------------------------------------------------------------------}\r\n\r\n"
  },
  {
    "url": "9vhWiOPw-Safe-Supertrend-Strategy-No-Repaint",
    "name": "Safe Supertrend Strategy (No Repaint)",
    "description": "Overview \nThe Safe Supertrend is a repaint-free version of the popular Supertrend trend-following indicator.\nMost Supertrend indicators appear perfect on historical charts because they flip intrabar and then repaint after the candle closes.\nThis version fixes that by using close-of-bar confirmation only, making every trend flip 100% stable, safe, and non-repainting.\n\n Why This Supertrend Doesnâ€™t Repaint \nMost Supertrend indicators calculate their trend direction using the current barâ€™s data.\nBut during a live candle:\n \n ATR expands and contracts\n The upper/lower bands move\n Price moves above/below the band temporarily\n A false flip appears â†’ then disappears when the candle closes\n \nThat is classic repainting.\nThis indicator avoids all of that by using:\nclose  > upper   \nclose  < lower \nThis means:\n \n Trend direction flips only based on the previous candle,\n No intrabar calculations,\n No flickering signals,\n No â€œperfect but fakeâ€ historical performance.\n \nEvery signal you see on the chart is exactly what was available in real-time.\n\n How It Works \n \n Calculates ATR (Average True Range) and SMA centerline\n Builds upper and lower volatility bands\n Confirms trend flips only after the previous bar closes\n Plots clear bull and bear reversal signals\n Works on all markets (crypto, stocks, forex, indices)\n \nNo repainting, no recalc, no misleading flips.\n\n Bullish Signal (Trend Up) \nA bullish trend begins only when:\n \n The previous candle closes above the upper ATR band,\n And this flip is fully confirmed.\n \nA green triangle marks the start of a new uptrend.\n\n Bearish Signal (Trend Down) \nA bearish trend begins only when:\n \n The previous candle closes below the lower ATR band,\n And the downtrend is confirmed.\n \nA red triangle signals the start of a new downtrend.\n Inputs \n \n ATR Length - default 10\n ATR Multiplier - default 3.0\n Works on all timeframes and market\n \nSimple, but powerful.\n\n Why Use This Version Instead of a Regular Supertrend? \nMost Supertrends:\n \n Look great historically\n But repaint continuously on live charts\n Give false trend flips intrabar\n Cannot be reliably used in strategies\n \nThis version:\n \n Uses strict previous-bar logic\n Never repaints trend direction\n Works perfectly in live trading\n Backtests accurately\n Is ideal for algorithmic strategies\n \nIdeal For:\n \n Trend-following strategies\n Breakout trading\n Algo trading systems\n Reversal detection\n Filtering market noise\n Swing trading & scalping\n \n\n Final Note \nThis is a safer, more reliable Supertrend designed for real-world use â€” not perfect-looking repaint illusions.\nIf you use Supertrend in your trading system, this no-repaint version ensures your signals are trustworthy and consistent.",
    "image_url": "9vhWiOPw",
    "author": "AIScripts",
    "likes": 97,
    "type": "strategy",
    "created": "2025-11-24",
    "updated": "2025-11-24",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// Â© AIScripts\n\n//@version=6\nstrategy(\"Safe Supertrend Strategy (No Repaint)\", overlay=true, margin_long=100, margin_short=100)\n\n// Inputs\natrLen  = input.int(10, \"ATR Length\")\natrMult = input.float(3.0, \"ATR Multiplier\")\n\n// Core Calculations\natr   = ta.atr(atrLen)\nma    = ta.sma(close, atrLen)\nupper = ma + atr * atrMult\nlower = ma - atr * atrMult\n\n// Direction logic (non-repainting)\n// Uses previous bar values ONLY â†’ all flips are confirmed\nvar int dir = 0\n\nif close[1] > upper[1]\n    dir := 1\nelse if close[1] < lower[1]\n    dir := -1\nelse\n    dir := dir[1]  // hold trend\n\n// Plot reversal markers\nplotshape(dir == 1 and dir[1] != 1, \n     title=\"Bull Start\", location=location.belowbar, \n     style=shape.triangleup, color=color.new(color.green, 0), size=size.small)\n\nplotshape(dir == -1 and dir[1] != -1, \n     title=\"Bear Start\", location=location.abovebar, \n     style=shape.triangledown, color=color.new(color.red, 0), size=size.small)\n\n// Strategy logic\nlongSignal  = dir == 1 and dir[1] != 1\nshortSignal = dir == -1 and dir[1] != -1\n\nif longSignal\n    strategy.entry(\"Long\", strategy.long)\n\nif shortSignal\n    strategy.entry(\"Short\", strategy.short)\n// Optional exit on reverse signals\nif strategy.position_size > 0 and shortSignal\n    strategy.close(\"Long\")\nif strategy.position_size < 0 and longSignal\n    strategy.close(\"Short\")\n"
  },
  {
    "url": "QaSYMsGS-Safe-Supertrend-Strategy-No-Repaint",
    "name": "Safe Supertrend Strategy (No Repaint)",
    "description": "Overview \nThe Safe Supertrend is a repaint-free version of the popular Supertrend trend-following indicator.\nMost Supertrend indicators appear perfect on historical charts because they flip intrabar and then repaint after the candle closes.\nThis version fixes that by using close-of-bar confirmation only, making every trend flip 100% stable, safe, and non-repainting.\n\n Why This Supertrend Doesnâ€™t Repaint \nMost Supertrend indicators calculate their trend direction using the current barâ€™s data.\nBut during a live candle:\n \n ATR expands and contracts\n The upper/lower bands move\n Price moves above/below the band temporarily\n A false flip appears â†’ then disappears when the candle closes\n \nThat is classic repainting.\n\nThis indicator avoids all of that by using:\nclose  > upper   \nclose  < lower \nThis means:\n \n Trend direction flips only based on the previous candle,\n No intrabar calculations,\n No flickering signals,\n No â€œperfect but fakeâ€ historical performance.\n \nEvery signal you see on the chart is exactly what was available in real-time.\n\n How It Works \n \n Calculates ATR (Average True Range) and SMA centerline\n Builds upper and lower volatility bands\n Confirms trend flips only after the previous bar closes\n Plots clear bull and bear reversal signals\n Works on all markets (crypto, stocks, forex, indices)\n \nNo repainting, no recalc, no misleading flips.\n\n Bullish Signal (Trend Up) \nA bullish trend begins only when:\n \n The previous candle closes above the upper ATR band,\n And this flip is fully confirmed.\n \nA green triangle marks the start of a new uptrend.\n\n Bearish Signal (Trend Down) \nA bearish trend begins only when:\n \n The previous candle closes below the lower ATR band,\n And the downtrend is confirmed.\n \nA red triangle signals the start of a new downtrend.\n\n Inputs \n \n ATR Length - default 10\n ATR Multiplier - default 3.0\n Works on all timeframes and market\n \nSimple, but powerful.\n Why Use This Version Instead of a Regular Supertrend? \nMost Supertrends:\n \n Look great historically\n But repaint continuously on live charts\n Give false trend flips intrabar\n Cannot be reliably used in strategies\n \nThis version:\n \n Uses strict previous-bar logic\n Never repaints trend direction\n Works perfectly in live trading\n Backtests accurately\n Is ideal for algorithmic strategies\n \nIdeal For:\n \n Trend-following strategies\n Breakout trading\n Algo trading systems\n Reversal detection\n Filtering market noise\n Swing trading & scalping\n \n\n Final Note \nThis is a safer, more reliable Supertrend designed for real-world use â€” not perfect-looking repaint illusions.\nIf you use Supertrend in your trading system, this no-repaint version ensures your signals are trustworthy and consistent.\n",
    "image_url": "QaSYMsGS",
    "author": "AIScripts",
    "likes": 15,
    "type": "strategy",
    "created": "2025-11-24",
    "updated": "2025-11-24",
    "source": "//@version=6\nstrategy(\"Safe Supertrend Strategy (No Repaint)\", overlay=true, margin_long=100, margin_short=100)\n\n// Inputs\natrLen  = input.int(10, \"ATR Length\")\natrMult = input.float(3.0, \"ATR Multiplier\")\n\n// Core Calculations\natr   = ta.atr(atrLen)\nma    = ta.sma(close, atrLen)\nupper = ma + atr * atrMult\nlower = ma - atr * atrMult\n\n// Direction logic (non-repainting)\n// Uses previous bar values ONLY â†’ all flips are confirmed\nvar int dir = 0\n\nif close[1] > upper[1]\n    dir := 1\nelse if close[1] < lower[1]\n    dir := -1\nelse\n    dir := dir[1]  // hold trend\n\n// Plot reversal markers\nplotshape(dir == 1 and dir[1] != 1, \n     title=\"Bull Start\", location=location.belowbar, \n     style=shape.triangleup, color=color.new(color.green, 0), size=size.small)\n\nplotshape(dir == -1 and dir[1] != -1, \n     title=\"Bear Start\", location=location.abovebar, \n     style=shape.triangledown, color=color.new(color.red, 0), size=size.small)\n\n// Strategy logic\nlongSignal  = dir == 1 and dir[1] != 1\nshortSignal = dir == -1 and dir[1] != -1\n\nif longSignal\n    strategy.entry(\"Long\", strategy.long)\n\nif shortSignal\n    strategy.entry(\"Short\", strategy.short)\n// Optional exit on reverse signals\nif strategy.position_size > 0 and shortSignal\n    strategy.close(\"Long\")\nif strategy.position_size < 0 and longSignal\n    strategy.close(\"Short\")\n"
  },
  {
    "url": "6KiUCGmJ",
    "name": "EMA Trend Pro v5.0 5M ONLY â€” ç­–ç•¥ç‰ˆï¼ˆ1:1å‡º30%+ä¿æœ¬ï¼‰",
    "description": "Here is a clear, professional English description you can copy-paste directly (suitable for sharing with friends, investors, brokers, or posting on TradingView):\nEMA Trend Pro v5.0 â€“ Strategy Overview\nThis is a trend-following strategy designed for 15-minute charts on assets like XAUUSD, NASDAQ, BTC, and ETH.\nEntry Rules\n\nBuy when the 7, 14, and 21-period EMAs are aligned upward and the 14-period EMA crosses above the 144-period EMA (with ADX > 20 and volume confirmation).\nSell short when the EMAs are aligned downward and the 14-period EMA crosses below the 144-period EMA.\n\nRisk Management\n\nInitial stop-loss is placed at 1.8 Ã— ATR below (long) or above (short) the entry price.\nPosition size is calculated to risk a fixed percentage of equity per trade.\n\nProfit-Taking & Trade Management\n\nWhen price reaches 1:1 reward-to-risk, 30% of the position is closed.\nAt the same moment, the stop-loss for the remaining 70% is moved to the entry price (breakeven).\nThe remaining position is split:\n50% targets 1:2 reward-to-risk\n50% targets 1:3 reward-to-risk (allowing big wins during strong trends)\n\n\nVisualization\n\nClean colored bars extend to the right showing entry, stop-loss, and three take-profit levels.\nPrice labels clearly display \"Entry\", \"SL\", \"TP1 1:1\", \"TP2 1:2\", and \"TP3 1:3\".\nOnly the current trade is displayed for a clean chart.\n\nKey Advantages\n\nHigh win rate due to breakeven protection after 1R\nExcellent reward-to-risk ratio that lets winners run\nFully automated, works on any market with clear trends\nProfessional look, easy to understand and explain\n\nPerfect for swing traders who want consistent profits with limited downside risk.\nFeel free to use this description on TradingView, in your trading journal, or when explaining the strategy to others!\nIf you want a shorter version (e.g., for TradingView description box) or a Chinese version, just let me know â€” Iâ€™ll give it to you right away! ðŸ˜Š",
    "image_url": "6KiUCGmJ",
    "author": "tair11123ru",
    "likes": 364,
    "type": "strategy",
    "created": "2025-11-25",
    "updated": "2025-11-25",
    "source": "//@version=5\r\nstrategy(\"EMA Trend Pro v5.0 â€” ç­–ç•¥ç‰ˆï¼ˆ1:1å‡º30%+ä¿æœ¬+åƒå¤§è¡Œæƒ…ï¼‰\", overlay=true, \r\n         default_qty_type=strategy.percent_of_equity, default_qty_value=100, \r\n         pyramiding=0, commission_type=strategy.commission.percent, commission_value=0.075)\r\n\r\n// ========= åƒæ•¸ =========\r\nadxMin     = input.int(20, \"ADX é–€æª»\")\r\natrMultSL  = input.float(1.8, \"åˆå§‹æ­¢æ ATR å€æ•¸\", step=0.1)\r\nextendBars = input.int(18, \"é•·æ¢æŸ±å»¶ä¼¸Kæ£’æ•¸\", minval=10, maxval=60)\r\n\r\n// ========= æŒ‡æ¨™ =========\r\nema7   = ta.ema(close, 7)\r\nema14  = ta.ema(close, 14)\r\nema21  = ta.ema(close, 21)\r\nema144 = ta.ema(close, 144)\r\natr20  = ta.atr(20)\r\n[diPlus, diMinus, adx14] = ta.dmi(14, 14)\r\nvolOK  = volume > ta.sma(volume, 20) * 1.1\r\n\r\nlongCond  = (ta.crossover(ema14,ema144) or ta.crossover(ema7,ema144)) and ema7>ema14 and ema14>ema21 and adx14>adxMin and diPlus>diMinus and volOK\r\nshortCond = (ta.crossunder(ema14,ema144) or ta.crossunder(ema7,ema144)) and ema7<ema14 and ema14<ema21 and adx14>adxMin and diMinus>diPlus and volOK\r\n\r\nplot(ema7,   color=#FF0000)\r\nplot(ema14,  color=#FF9800)\r\nplot(ema21,  color=#FFC107)\r\nplot(ema144, color=#2962FF, linewidth=2)\r\n\r\nplotshape(longCond,  location=location.belowbar, color=color.rgb(0, 230, 119, 67), style=shape.triangleup,   size=size.large, text=\"BUY\",  textcolor=color.white)\r\nplotshape(shortCond, location=location.abovebar, color=#ff174523, style=shape.triangledown, size=size.large, text=\"SELL\", textcolor=color.white)\r\n\r\n// ========= é€²å ´ =========\r\nif longCond and strategy.position_size == 0\r\n    strategy.entry(\"å¤šå–®\", strategy.long)\r\n\r\nif shortCond and strategy.position_size == 0\r\n    strategy.entry(\"ç©ºå–®\", strategy.short)\r\n\r\n// ========= æŒå€‰æ™‚åŸ·è¡Œ =========\r\nif strategy.position_size != 0\r\n    float entry = strategy.position_avg_price\r\n    float sl    = strategy.position_size > 0 ? entry - atr20 * atrMultSL : entry + atr20 * atrMultSL\r\n    float r     = math.abs(entry - sl)\r\n    float tp1   = entry + (strategy.position_size > 0 ? r : -r)\r\n    float tp2   = entry + (strategy.position_size > 0 ? 2*r : -2*r)\r\n    float tp3   = entry + (strategy.position_size > 0 ? 3*r : -3*r)\r\n    color mainCol = strategy.position_size > 0 ? #00E676 : #FF1744\r\n\r\n    // ä¸‰æ®µå‡ºå ´ + æ­¢æ\r\n    strategy.exit(\"TP1\", from_entry=\"å¤šå–®\", limit=tp1, qty_percent=30, comment=\"1:1å‡º30%\")\r\n    strategy.exit(\"TP1\", from_entry=\"ç©ºå–®\", limit=tp1, qty_percent=30, comment=\"1:1å‡º30%\")\r\n    strategy.exit(\"TP2\", from_entry=\"å¤šå–®\", limit=tp2, qty_percent=50, comment=\"1:2\")\r\n    strategy.exit(\"TP2\", from_entry=\"ç©ºå–®\", limit=tp2, qty_percent=50, comment=\"1:2\")\r\n    strategy.exit(\"TP3\", from_entry=\"å¤šå–®\", limit=tp3, qty_percent=100, comment=\"1:3\")\r\n    strategy.exit(\"TP3\", from_entry=\"ç©ºå–®\", limit=tp3, qty_percent=100, comment=\"1:3\")\r\n    strategy.exit(\"SL\",  from_entry=\"å¤šå–®\", stop=sl)\r\n    strategy.exit(\"SL\",  from_entry=\"ç©ºå–®\", stop=sl)\r\n\r\n    // 1:1 ä¸€è§¸åŠç«‹åˆ»ä¿æœ¬\r\n    if (strategy.position_size > 0 and high >= tp1) or (strategy.position_size < 0 and low <= tp1)\r\n        strategy.exit(\"ä¿æœ¬\", from_entry=\"å¤šå–®\", stop=entry)\r\n        strategy.exit(\"ä¿æœ¬\", from_entry=\"ç©ºå–®\", stop=entry)\r\n\r\n    // åªåœ¨æœ€å¾Œä¸€æ ¹Kæ£’ç•«é•·æ¢æŸ±èˆ‡æ¨™ç±¤ï¼ˆç•«é¢è¶…ä¹¾æ·¨ï¼‰\r\n    if barstate.islast\r\n        box.new(bar_index-1, math.max(entry,tp3,sl), bar_index+extendBars, math.min(entry,tp3,sl), bgcolor=color.new(mainCol,75), border_color=mainCol, border_width=2, extend=extend.right)\r\n        label.new(bar_index+8, entry, \"é€²å ´ \"+str.tostring(entry,\"#.##\"), style=label.style_label_left, color=mainCol, textcolor=color.white, size=size.normal)\r\n        label.new(bar_index+8, sl,    \"æ­¢æ \"+str.tostring(sl,\"#.##\"),    style=label.style_label_left  , color=#FF1744, textcolor=color.white, size=size.normal)\r\n        label.new(bar_index+8, tp1,   \"TP1 1:1\", style=label.style_label_left, color=#00E676, textcolor=color.white, size=size.normal)\r\n        label.new(bar_index+8, tp2,   \"TP2 1:2\", style=label.style_label_left, color=#00E676, textcolor=color.white, size=size.normal)\r\n        label.new(bar_index+8, tp3,   \"TP3 1:3\", style=label.style_label_left, color=#00E676, textcolor=color.white, size=size.normal)\r\n\r\n// ========= è­¦å ± =========\r\nalertcondition(longCond,  \"å¤šå–®é€²å ´\", \"EMA å¤šå–®è¨Šè™Ÿï¼\")\r\nalertcondition(shortCond, \"ç©ºå–®é€²å ´\", \"EMA ç©ºå–®è¨Šè™Ÿï¼\")"
  },
  {
    "url": "19sv9cVQ",
    "name": "Recursive WMA Angle Strategy",
    "description": "Description: This strategy utilizes a recursive Weighted Moving Average (WMA) calculation to determine the trend direction and strength based on the slope (angle) of the curve. By calculating the angle of the smoothed moving average in degrees, the script filters out noise and aims to enter trades only during strong momentum phases.\n\nHow it Works:\n\nRecursive WMA: The script calculates a series of nested WMAs (M1 to M5), creating a very smooth yet responsive curve.\n\nAngle Calculation: It measures the rate of change of this curve over a user-defined lookback period and converts it into an angle (in degrees).\n\nEntry Condition (Long): A long position is opened when the calculated angle exceeds the Min Angle for BUY threshold (default: 0.2), indicating a strong upward trend.\n\nExit Condition: The position is closed when the angle drops below the Min Angle for SELL threshold (default: -0.2), indicating a sharp trend reversal.\n\nSettings:\n\nMA Settings: Adjust the base lengths for the recursive calculation.\n\nAngle Settings: Fine-tune the sensitivity by changing the Buy/Sell angle thresholds.\n\nDate Filter: Restrict the backtest to a specific date range.\n\nNote: This strategy is designed for Long-Only setups.",
    "image_url": "19sv9cVQ",
    "author": "vahsi_bati",
    "likes": 20,
    "type": "strategy",
    "created": "2025-11-24",
    "updated": "2025-11-24",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// Â© vahsi_bati\r\n// NOTE: The username above must match your TradingView username exactly.\r\n\r\n//@version=5\r\nstrategy(\"Recursive WMA Angle Strategy\", shorttitle=\"WMA Angle Strat\", overlay=true, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=100, commission_type=strategy.commission.percent, commission_value=0.03)\r\n\r\n// --- 1. MA Settings ---\r\nGRP_MA = \"MA Settings\"\r\nfmal = input.int(1, \"First Moving Average Length\", minval=1, group=GRP_MA)\r\nsmal = input.int(1, \"Second Moving Average Length\", minval=1, group=GRP_MA)\r\n\r\n// --- 2. Angle & Exit Settings ---\r\nGRP_ANGLE = \"Angle & Exit Settings\"\r\nangleBuyThreshold = input.float(0.2, title=\"Min Angle for BUY\", step=0.1, group=GRP_ANGLE, tooltip=\"Buys if the upward trend strength (angle) is greater than this value.\")\r\nangleSellThreshold = input.float(-0.2, title=\"Min Angle for SELL (Exit)\", maxval=0.0, step=0.1, group=GRP_ANGLE, tooltip=\"Sells/Exits if the downward trend strength is lower (more negative) than this value.\")\r\nangleLookback = input.int(3, title=\"Angle Lookback Period\", minval=1, group=GRP_ANGLE)\r\n\r\n// --- 3. Date Filter Settings ---\r\nGRP_TIME = \"Backtest Date Range\"\r\nuseDateFilter = input.bool(true, \"Use Date Filter\", group=GRP_TIME)\r\n// Default: From Jan 1, 2023 to Dec 31, 2030\r\nstartTime = input.time(timestamp(\"1 Jan 2023 00:00 +0000\"), \"Start Date\", group=GRP_TIME)\r\nendTime = input.time(timestamp(\"31 Dec 2030 23:59 +0000\"), \"End Date\", group=GRP_TIME)\r\n\r\ninDateRange = useDateFilter ? (time >= startTime and time <= endTime) : true\r\n\r\n// --- 4. Recursive WMA Calculation ---\r\n// Calculating lengths for the recursive structure\r\ntmal = fmal + smal\r\nFmal = smal + tmal\r\nFtmal = tmal + Fmal\r\nSmal = Fmal + Ftmal\r\n\r\n// Data sufficiency check to prevent errors on the first few bars\r\nisValidBar = bar_index > Smal\r\n\r\nM1 = ta.wma(close, fmal)\r\nM2 = ta.wma(M1, smal)\r\nM3 = ta.wma(M2, tmal)\r\nM4 = ta.wma(M3, Fmal)\r\nM5 = ta.wma(M4, Ftmal)\r\nMAVW = ta.wma(M5, Smal) // The final smoothed Moving Average\r\n\r\n// --- 5. Angle Calculation ---\r\n// Check previous value to prevent repainting and errors\r\nmavwPrev = MAVW[angleLookback]\r\nmavwChange = MAVW - mavwPrev\r\n\r\n// Prevent division by zero error\r\nchangePercent = (not na(mavwPrev) and mavwPrev != 0) ? (mavwChange / mavwPrev) * 100 : 0\r\n\r\n// Calculate angle in degrees\r\nangleRad = math.atan(changePercent / angleLookback)\r\nmavwAngleDeg = angleRad * (180 / math.pi)\r\n\r\n// --- 6. Strategy Logic ---\r\n\r\n// Conditions\r\nisStrongBuy = mavwAngleDeg > angleBuyThreshold      // Strong Upward Trend\r\nisStrongSell = mavwAngleDeg < angleSellThreshold    // Strong Downward Trend\r\n\r\nif inDateRange and isValidBar\r\n    // BUY Signal\r\n    if isStrongBuy and strategy.opentrades == 0\r\n        strategy.entry(\"Long\", strategy.long, comment=\"BUY: \" + str.tostring(mavwAngleDeg, \"#.##\") + \"Â°\")\r\n        \r\n    // SELL (Exit) Signal\r\n    if isStrongSell and strategy.position_size > 0\r\n        strategy.close(\"Long\", comment=\"EXIT: Trend Reversal\")\r\n\r\n// --- 7. Visualization ---\r\n\r\n// Plot the Moving Average\r\ncolStrategy = strategy.position_size > 0 ? color.lime : color.gray\r\nplot(MAVW, \"Recursive WMA\", color=colStrategy, linewidth=3)\r\n\r\n// Plot Signals on Chart for Visual Verification\r\n//plotshape(isStrongBuy and strategy.opentrades == 0 and inDateRange, title=\"Buy Signal\", location=location.belowbar, color=color.lime, style=shape.labelup, text=\"BUY\", textcolor=color.white, size=size.tiny)\r\n//plotshape(isStrongSell and strategy.position_size > 0 and inDateRange, title=\"Sell Signal\", location=location.abovebar, color=color.red, style=shape.labeldown, text=\"SELL\", textcolor=color.white, size=size.tiny)\r\n\r\n// Information Table (Bottom Right)\r\nvar table infoTable = table.new(position.bottom_right, 2, 3, border_width=1, bgcolor=color.new(color.black, 60))\r\n\r\n// Update table only on the last bar to save resources\r\nif barstate.islast\r\n    table.cell(infoTable, 0, 0, \"Current Angle\", text_color=color.white)\r\n    angleColor = mavwAngleDeg > 0 ? color.lime : (mavwAngleDeg < 0 ? color.red : color.gray)\r\n    table.cell(infoTable, 1, 0, str.tostring(mavwAngleDeg, \"#.##\") + \"Â°\", text_color=angleColor)\r\n    \r\n    table.cell(infoTable, 0, 1, \"Status\", text_color=color.white)\r\n    posText = strategy.position_size > 0 ? \"LONG\" : \"FLAT\"\r\n    posColor = strategy.position_size > 0 ? color.lime : color.gray\r\n    table.cell(infoTable, 1, 1, posText, text_color=posColor)"
  },
  {
    "url": "cVAe9qx7-Super-ORB-v4-4-CONTRACTS-NUCLEAR-FIX",
    "name": "Super ORB v4 â€“ 4 CONTRACTS â€“ NUCLEAR FIX",
    "description": "ORB hands off printer, this is to gauge how few trades can happen off the ORB while not trading after hours either.  Should be in the 5% a month range 4 contracts, no more than 5 trades a month.",
    "image_url": "cVAe9qx7",
    "author": "corymgrant",
    "likes": 26,
    "type": "strategy",
    "created": "2025-11-24",
    "updated": "2025-11-24",
    "source": "//@version=5\nstrategy(\"Super ORB v4 â€“ 4 CONTRACTS â€“ NUCLEAR FIX\", overlay=true, default_qty_type=strategy.fixed, default_qty_value=4, commission_value=0, initial_capital=50000, calc_on_every_tick=true, calc_on_order_fills=true)\n\n// â€”â€”â€”â€”â€”â€”â€” Regular hours only â€”â€”â€”â€”â€”â€”â€”\nin_session = time(timeframe.period, \"0930-1600\", \"America/New_York\")\navoid_news = input.bool(false, \"Avoid News Today\")\n\n// â€”â€”â€”â€”â€”â€”â€” 15-min ORB â€”â€”â€”â€”â€”â€”â€”\nis_new_day = ta.change(time(\"D\"))\nvar float orb_high = na\nvar float orb_low  = na\nvar int   orb_bar  = na\n\nif is_new_day and not avoid_news\n    orb_high := high\n    orb_low  := low\n    orb_bar  := bar_index\n    for i = 1 to 2\n        orb_high := math.max(orb_high, high[i])\n        orb_low  := math.min(orb_low,  low[i])\n\nif not na(orb_high) and bar_index >= orb_bar + 3\n    box.new(orb_bar, orb_high, bar_index + 20, orb_low, border_color=color.blue, bgcolor=color.new(color.blue,92))\n\n// â€”â€”â€”â€”â€”â€”â€” Indicators â€”â€”â€”â€”â€”â€”â€”\nema21  = ta.ema(close, 21)\natr14  = ta.atr(14)\nstochK = ta.stoch(close, high, low, 14)\nrsi2   = ta.rsi(close, 2)\n\nplot(ema21, \"21 EMA\", color.orange, 2)\nplot(orb_high + 1.5*atr14, \"Upper Band\", color.green)\nplot(orb_low  - 1.5*atr14, \"Lower Band\", color.red)\n\n// â€”â€”â€”â€”â€”â€”â€” Setups â€”â€”â€”â€”â€”â€”â€”\nlong_setup  = high > orb_high and close > orb_high and low <= ema21 and close > ema21 and stochK < 20 and rsi2 < 30 and in_session and not avoid_news\nshort_setup = low < orb_low and close < orb_low and high >= ema21 and close < ema21 and stochK > 80 and rsi2 > 70 and in_session and not avoid_news\n\n// â€”â€”â€”â€”â€”â€”â€” NUCLEAR 4-CONTRACT ENTRIES (no qty_percent, no cache risk) â€”â€”â€”â€”â€”â€”â€”\nif long_setup and strategy.position_size == 0\n    strategy.entry(\"Long\", strategy.long, qty=4)\n    strategy.exit(\"Long TP\",  \"Long\", qty=2, limit=close + 150)   // $300 on first 2\n    strategy.exit(\"Long Rest\",\"Long\", qty=2, limit=close + 300)   // runner on last 2\n    strategy.exit(\"Long Stop\",\"Long\", qty=4, stop=orb_low - atr14)\n\nif short_setup and strategy.position_size == 0\n    strategy.entry(\"Short\", strategy.short, qty=4)\n    strategy.exit(\"Short TP\",  \"Short\", qty=2, limit=close - 150)\n    strategy.exit(\"Short Rest\",\"Short\", qty=2, limit=close - 300)\n    strategy.exit(\"Short Stop\",\"Short\", qty=4, stop=orb_high + atr14)\n\n// â€”â€”â€”â€”â€”â€”â€” Visuals & Alerts â€”â€”â€”â€”â€”â€”â€”\nplotshape(long_setup,  \"Long\",  shape.triangleup,   location.belowbar, color.lime, size=size.large)\nplotshape(short_setup, \"Short\", shape.triangledown, location.abovebar, color.red,  size=size.large)\nbgcolor(long_setup ? color.new(color.lime,80) : short_setup ? color.new(color.red,80) : na)\n\nalertcondition(long_setup,  \"LONG $300+\", \"SUPER ORB LONG â€“ 4 contracts â€“ Target $300+\")\nalertcondition(short_setup, \"SHORT $300+\", \"SUPER ORB SHORT â€“ 4 contracts â€“ Target $300+\")"
  },
  {
    "url": "wy9tFOQT-Optimized-EMA-Ribbon-Strategy-v6",
    "name": "Optimized EMA Ribbon Strategy v6 ",
    "description": "Based on EMA rotations, ADX we create a system of entering trades. Watch out for the sell and buy signals. ",
    "image_url": "wy9tFOQT",
    "author": "Gyaani",
    "likes": 27,
    "type": "strategy",
    "created": "2025-11-23",
    "updated": "2025-11-23",
    "source": "//@version=6\nstrategy(\"Optimized EMA Ribbon Strategy v6\", overlay=true, \n     initial_capital=1000, default_qty_type=strategy.percent_of_equity, default_qty_value=20,\n     commission_type=strategy.commission.percent, commission_value=0.04,\n     pyramiding=0)\n\n// === OPTIMIZED INPUT PARAMETERS ===\n// EMA Parameters\nfastLen = input.int(10, \"Fast EMA Length\", minval=1)\nslowLen = input.int(21, \"Slow EMA Length\", minval=1)\ntrendFilterLen = input.int(50, \"Trend Filter EMA\", minval=1)\n\n// ADX Parameters\nadxLen = input.int(14, \"ADX Length\", minval=1)\nadxThreshold = input.int(22, \"ADX Minimum Threshold\", minval=15)\n\n// Volume Filter\nvolLen = input.int(15, \"Volume MA Length\", minval=1)\nuseVolumeFilter = input.bool(true, \"Use Volume Filter\")\n\n// Risk Management\nriskMult = input.float(2.2, \"ATR Stop Multiplier\", minval=1.5, maxval=4.0)\nrewardMult = input.float(2.8, \"ATR Take Profit Multiplier\", minval=2.0, maxval=5.0)\nmaxRiskPercent = input.float(2.0, \"Max Risk % per Trade\", minval=0.5, maxval=3.0)\nuseStopLoss = input.bool(true, \"Use Stop Loss\")\nuseTakeProfit = input.bool(true, \"Use Take Profit\")\n\n// Exit Conditions\nuseTrailingStop = input.bool(false, \"Use Trailing Stop\")\nexitOnOppositeSignal = input.bool(true, \"Exit on Opposite Signal\")\n\n// === CALCULATIONS ===\n// EMA Ribbon with Trend Filter\nemaFast = ta.ema(close, fastLen)\nemaSlow = ta.ema(close, slowLen)\nemaTrend = ta.ema(close, trendFilterLen)\n\n// ADX with DI\n[diplus, diminus, adx] = ta.dmi(adxLen, adxLen)\n\n// Volume Filter\nvolMA = ta.sma(volume, volLen)\nvolFilter = not useVolumeFilter or volume > volMA * 1.05\n\n// ATR for Risk Management\natr = ta.atr(14)\n\n// Price Action Filters\npriceAboveTrend = close > emaTrend\npriceBelowTrend = close < emaTrend\n\n// Entry Conditions\nbullCross = ta.crossover(emaFast, emaSlow)\nbearCross = ta.crossunder(emaFast, emaSlow)\n\n// Additional Confirmation\nrsi = ta.rsi(close, 14)\nnotOverbought = rsi < 75\nnotOversold = rsi > 25\n\n// ADX condition\nstrongTrend = adx >= adxThreshold\n\n// MACD for long trade improvement\n[macdLine, macdSignal, _] = ta.macd(close, 12, 26, 9)\nmacdBullish = macdLine > macdSignal\n\n// Enhanced Entry Conditions\nlongCondition = bullCross and priceAboveTrend and strongTrend and \n               diplus > diminus and volFilter and notOverbought and macdBullish\n               \nshortCondition = bearCross and priceBelowTrend and strongTrend and diminus > diplus and volFilter and notOversold\n\n// === POSITION SIZING ===\nriskPerShare = atr * riskMult\npositionValue = strategy.equity * (maxRiskPercent / 100)\npositionSize = math.max(0.001, positionValue / riskPerShare) // Ensure positive quantity\n\n// === PLOTTING ===\nplot(emaFast, \"EMA Fast\", color=color.teal, linewidth=2)\nplot(emaSlow, \"EMA Slow\", color=color.orange, linewidth=2)\nplot(emaTrend, \"Trend Filter\", color=color.purple, linewidth=1)\n\n// Entry markers\nplotshape(longCondition and strategy.position_size == 0, \"Long Entry\", \n          location=location.belowbar, color=color.green, style=shape.triangleup, size=size.small)\nplotshape(shortCondition and strategy.position_size == 0, \"Short Entry\", \n          location=location.abovebar, color=color.red, style=shape.triangledown, size=size.small)\n\n// === STRATEGY EXECUTION ===\n// Calculate exit levels\nlongStop = useStopLoss ? close - atr * riskMult : na\nlongProfit = useTakeProfit ? close + atr * rewardMult : na\nshortStop = useStopLoss ? close + atr * riskMult : na\nshortProfit = useTakeProfit ? close - atr * rewardMult : na\n\n// Execute long trades\nif longCondition and strategy.position_size == 0\n    strategy.entry(\"Long\", strategy.long, qty=positionSize)\n    if useStopLoss\n        strategy.exit(\"Long Exit\", \"Long\", stop=longStop, limit=longProfit)\n\n// Execute short trades  \nif shortCondition and strategy.position_size == 0\n    strategy.entry(\"Short\", strategy.short, qty=positionSize)\n    if useStopLoss\n        strategy.exit(\"Short Exit\", \"Short\", stop=shortStop, limit=shortProfit)\n\n// Opposite signal exits\nif strategy.position_size > 0 and exitOnOppositeSignal and bearCross\n    strategy.close(\"Long\")\n    \nif strategy.position_size < 0 and exitOnOppositeSignal and bullCross\n    strategy.close(\"Short\")"
  },
  {
    "url": "6zYF9Xts-Hash-Supertrend-Hash-Capital-Research",
    "name": "Hash Supertrend [Hash Capital Research]",
    "description": "Hash Supertrend Strategy by Hash Capital Research\n\nOverview\nHash Supertrend is a professional-grade trend-following strategy that combines the proven Supertrend indicator with institutional visual design and flexible time filtering. \n\nThe strategy uses ATR-based volatility bands to identify trend direction and executes position reversals when the trend flips.This implementation features a distinctive fluorescent color system with customizable glow effects, making trend changes immediately visible while maintaining the clean, professional aesthetic expected in quantitative trading environments.\nEntry Signals:\n\n \n Long Entry: Price crosses above the Supertrend line (trend flips bullish)\n Short Entry: Price crosses below the Supertrend line (trend flips bearish)\n \n\nControls the lookback period for volatility calculation\nLower values (7-10): More sensitive to price changes, generates more signals\nHigher values (12-14): Smoother response, fewer signals but potentially delayed entries\nRecommended range: 7-14 depending on market volatility\nFactor (Default: 3.0)\n\nRestricts trading to specific hours\nUseful for avoiding low-liquidity sessions, overnight gaps, or known choppy periods\nWhen disabled, strategy trades 24/7\nStart Hour (Default: 9) & Start Minute (Default: 30)\n\nDefine when the trading session begins\nUses exchange timezone in 24-hour format\nExample: 9:30 = 9:30 AM\nEnd Hour (Default: 16) & End Minute (Default: 0)\n\nControls the vibrancy of the fluorescent color system\n \n 1-3: Subtle, muted colors\n 4-6: Balanced, moderate saturation\n 7-10: Bright, highly saturated fluorescent appearance\n Affects both the Supertrend line and trend zones\n Glow Effect (Default: On)\n \n\nAdds luminous halo around the Supertrend line\n \n Creates a multi-layered visual with depth\n Particularly effective during strong trends\n Glow Intensity (Default: 5.0)\n \n\nDisplays tiny fluorescent dots at entry points\n \n Green dot below bar: Long entry\n Red dot above bar: Short entry\n Provides clear visual confirmation of executed trades\n Show Trend Zone (Default: On)\n \n\n Strong trending markets (2020-style bull runs, sustained bear markets) \nMarkets with clear directional bias\nInstruments with consistent volatility patterns\nTimeframes: 15m to Daily (optimal on 1H-4H)\nChallenging Conditions:\n\n Choppy, range-bound markets \nLow volatility consolidation periods\nHighly news-driven instruments with frequent gaps\nVery low timeframes (1m-5m) prone to noise\nRecommended AssetsCryptocurrency:\n",
    "image_url": "6zYF9Xts",
    "author": "Hash_Capital",
    "likes": 38,
    "type": "strategy",
    "created": "2025-12-10",
    "updated": "2025-12-10",
    "source": "//@version=6\r\nstrategy(\"Hash Supertrend\", \r\n         shorttitle=\"Hash Supertrend\", \r\n         overlay=true, \r\n         default_qty_type=strategy.percent_of_equity, \r\n         default_qty_value=15)\r\n\r\n// Company Information - Info icon only, no text box\r\n_ = input.bool(true, \"â„¹ï¸ About Hash Capital Research\", tooltip=\"Developed by Hash Capital Partners\\n\\nFollow us on TradingView for exclusive premium indicators and cutting-edge quantitative research.\", group=\"Company Information\")\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// CORE SUPERTREND SETTINGS\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n\r\natrPeriod = input.int(16, \"ATR Length\", minval=1, group=\"Supertrend Settings\", tooltip=\"Number of bars for ATR calculation. Lower values (7-10) = more sensitive. Higher values (12-14) = smoother but slower.\")\r\nfactor = input.float(3.11, \"Factor\", step=0.01, minval=0.1, group=\"Supertrend Settings\", tooltip=\"ATR multiplier. Lower values (1.5-2.5) = more signals but more whipsaws. Higher values (3.0-4.0) = fewer but stronger signals.\")\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// TIME FILTER SETTINGS\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n\r\nuseTimeFilter = input.bool(false, \"Enable Time Filter\", group=\"Time Filter\", tooltip=\"Only trade during specified hours. Useful for avoiding choppy sessions or off-hours volatility.\")\r\nstartHour = input.int(9, \"Start Hour\", minval=0, maxval=23, group=\"Time Filter\", tooltip=\"Trading session start hour in exchange timezone (24-hour format).\")\r\nstartMinute = input.int(30, \"Start Minute\", minval=0, maxval=59, group=\"Time Filter\", tooltip=\"Trading session start minute.\")\r\nendHour = input.int(16, \"End Hour\", minval=0, maxval=23, group=\"Time Filter\", tooltip=\"Trading session end hour in exchange timezone (24-hour format).\")\r\nendMinute = input.int(0, \"End Minute\", minval=0, maxval=59, group=\"Time Filter\", tooltip=\"Trading session end minute.\")\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// VISUAL SETTINGS - HASH CAPITAL STYLE\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n\r\ncolorIntensity = input.float(7.0, \"Color Intensity\", minval=1.0, maxval=10.0, step=1.0, group=\"Visual\", tooltip=\"Controls color vibrancy. 1-3 = subtle colors, 4-6 = balanced, 7-10 = very bright and vibrant colors.\")\r\nshowGlowEffect = input.bool(true, \"Glow Effect\", group=\"Visual\", tooltip=\"Adds luminous glow around the Supertrend line. Creates a more dramatic visual effect.\")\r\nglowIntensity = input.float(5.0, \"Glow Intensity\", minval=1.0, maxval=10.0, step=1.0, group=\"Visual\", tooltip=\"Controls glow brightness. 1-3 = subtle glow, 4-6 = moderate glow, 7-10 = intense glow effect.\")\r\nshowSignals = input.bool(true, \"Show Entry Signals\", group=\"Visual\", tooltip=\"Display buy/sell signals on chart when trend changes.\")\r\nshowZone = input.bool(true, \"Show Trend Zone\", group=\"Visual\", tooltip=\"Fill area between price and Supertrend line to visualize trend zones.\")\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// SUPERTREND CALCULATION\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n\r\n[supertrend, direction] = ta.supertrend(factor, atrPeriod)\r\n\r\n// Trend state\r\nisBullish = direction < 0\r\nisBearish = direction > 0\r\n\r\n// Detect trend changes\r\ntrendChanged = ta.change(direction) != 0\r\nlongSignal = ta.change(direction) < 0\r\nshortSignal = ta.change(direction) > 0\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// TIME FILTER LOGIC\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n\r\nisInSession = true\r\n\r\nif useTimeFilter\r\n    // Get current time components\r\n    currentHour = hour(time)\r\n    currentMinute = minute(time)\r\n    \r\n    // Convert to minutes for easier comparison\r\n    currentTimeInMinutes = currentHour * 60 + currentMinute\r\n    startTimeInMinutes = startHour * 60 + startMinute\r\n    endTimeInMinutes = endHour * 60 + endMinute\r\n    \r\n    // Handle cases where session crosses midnight\r\n    if endTimeInMinutes > startTimeInMinutes\r\n        // Normal case: session within same day (e.g., 9:30 to 16:00)\r\n        isInSession := currentTimeInMinutes >= startTimeInMinutes and currentTimeInMinutes <= endTimeInMinutes\r\n    else\r\n        // Session crosses midnight (e.g., 22:00 to 02:00)\r\n        isInSession := currentTimeInMinutes >= startTimeInMinutes or currentTimeInMinutes <= endTimeInMinutes\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// HASH CAPITAL COLOR SYSTEM - FLUORESCENT GRADIENT\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n\r\ngetAdaptiveColor(bool bullish) =>\r\n    // Convert 1-10 scale to 0-1 for calculations\r\n    colorScale = colorIntensity / 10.0\r\n    \r\n    if bullish\r\n        // Bright fluorescent green spectrum for bullish\r\n        intensity = colorScale\r\n        redVal = math.round(100 * (1 - intensity))\r\n        greenVal = 255\r\n        blueVal = math.round(100 * (1 - intensity * 0.7))\r\n        alpha = math.max(0, math.round(30 * (1 - intensity)))\r\n        color.rgb(redVal, greenVal, blueVal, alpha)\r\n    else\r\n        // Bright fluorescent red spectrum for bearish\r\n        intensity = colorScale\r\n        redVal = 255\r\n        greenVal = math.round(100 * (1 - intensity))\r\n        blueVal = math.round(100 * (1 - intensity * 0.7))\r\n        alpha = math.max(0, math.round(30 * (1 - intensity)))\r\n        color.rgb(redVal, greenVal, blueVal, alpha)\r\n\r\n// Enhanced Glow effect\r\ngetGlowColor(bool bullish) =>\r\n    if showGlowEffect\r\n        // Convert 1-10 scale to usable range\r\n        glowScale = glowIntensity / 10.0\r\n        glowAlpha = math.round(100 - (60 * glowScale))\r\n        \r\n        if bullish\r\n            // Bright green glow for bullish\r\n            color.new(#00FF00, math.max(30, glowAlpha))\r\n        else\r\n            // Bright red glow for bearish\r\n            color.new(#FF0000, math.max(30, glowAlpha))\r\n    else\r\n        na\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// STRATEGY EXECUTION\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n\r\nif longSignal and isInSession\r\n    strategy.entry(\"Long\", strategy.long)\r\n\r\nif shortSignal and isInSession\r\n    strategy.entry(\"Short\", strategy.short)\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// VISUAL PLOTTING - HASH CAPITAL STYLE\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n\r\n// Main Supertrend line with adaptive color\r\nmainColor = getAdaptiveColor(isBullish)\r\nglowColor = getGlowColor(isBullish)\r\n\r\n// Plot main line with glow effect\r\nsupertrendGlow = plot(supertrend, \"Supertrend Glow\", color=glowColor, linewidth=6, display=display.all)\r\nsupertrendMain = plot(supertrend, \"Supertrend\", color=mainColor, linewidth=3, display=display.all)\r\n\r\n// Trend zone fill - area between price and Supertrend\r\npriceLinePlot = plot(close, \"Price Reference\", color=color.new(color.white, 100), display=display.none)\r\n\r\n// Fill zones conditionally\r\nbullishZoneColor = color.new(#00FF00, 92)\r\nbearishZoneColor = color.new(#FF0000, 92)\r\n\r\n// Create conditional fill colors\r\ncurrentBullFill = isBullish ? bullishZoneColor : na\r\ncurrentBearFill = isBearish ? bearishZoneColor : na\r\n\r\n// Bullish zone - green tint\r\nfill(supertrendMain, priceLinePlot, \r\n     color=currentBullFill, \r\n     title=\"Bullish Zone\")\r\n\r\n// Bearish zone - red tint\r\nfill(supertrendMain, priceLinePlot, \r\n     color=currentBearFill, \r\n     title=\"Bearish Zone\")\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// ENTRY SIGNALS - TINY FLUORESCENT DOTS\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n\r\n// Long signals - tiny bright green dot\r\nplotshape(showSignals and longSignal, \r\n          title=\"Long Signal\", \r\n          style=shape.circle, \r\n          location=location.belowbar, \r\n          color=color.new(#00FF00, 0), \r\n          size=size.tiny)\r\n\r\n// Short signals - tiny bright red dot\r\nplotshape(showSignals and shortSignal, \r\n          title=\"Short Signal\", \r\n          style=shape.circle, \r\n          location=location.abovebar, \r\n          color=color.new(#FF0000, 0), \r\n          size=size.tiny)\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// TIME FILTER VISUAL INDICATOR (OPTIONAL)\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n\r\n// Subtle background shading when outside trading hours\r\nbgcolor(useTimeFilter and not isInSession ? color.new(color.gray, 95) : na, title=\"Outside Trading Hours\")\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// ALERT SYSTEM - PROFESSIONAL, NO EMOJIS\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n\r\nalertcondition(longSignal and isInSession, \"Long Entry\", \"Supertrend flipped BULLISH - Long signal triggered\")\r\nalertcondition(shortSignal and isInSession, \"Short Entry\", \"Supertrend flipped BEARISH - Short signal triggered\")\r\nalertcondition(trendChanged and isInSession, \"Trend Change\", \"Supertrend direction changed - Position reversal\")\r\n\r\n// Additional alert for signals outside trading hours (if time filter enabled)\r\nalertcondition(useTimeFilter and longSignal and not isInSession, \"Long Signal (Filtered)\", \"Supertrend BULLISH signal outside trading hours - Not executed\")\r\nalertcondition(useTimeFilter and shortSignal and not isInSession, \"Short Signal (Filtered)\", \"Supertrend BEARISH signal outside trading hours - Not executed\")\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// BACKGROUND COLOR (OPTIONAL) - SUBTLE TREND INDICATION\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n\r\n// Uncomment below for subtle background coloring\r\n// bgcolor(isBullish ? color.new(#00FF00, 97) : color.new(#FF0000, 97), title=\"Trend Background\")"
  },
  {
    "url": "d31UlbSg",
    "name": "Paulinho Signals â€“ Cripto 5m/15m com Filtro de Lateralidade",
    "description": "This script is an automated Pine Script v6 strategy designed for short-term cryptocurrency trading, especially on 5-minute and 15-minute timeframes. It combines moving average crossovers, trend strength (ADX), volatility (ATR), and candlestick patterns to generate buy and sell signals with a fixed risk/reward management system.\n\nHow to Use:\n- Apply to cryptocurrency charts on 5m or 15m timeframes.\n- Adjust parameters to fit your preferences (EMA, RSI, ADX, ATR).\n- Use for backtesting or as a decision-support tool.\n\nDisclaimer:\nThis script is for educational purposes only and does not constitute financial advice. Always test on demo accounts before applying to live trading.\n\n",
    "image_url": "d31UlbSg",
    "author": "Pqpaulao",
    "likes": 10,
    "type": "strategy",
    "created": "2025-11-23",
    "updated": "2025-11-23",
    "source": "//@version=6\r\nstrategy(\"Paulinho Signals â€“ EstratÃ©gia Cripto 5m/15m com Filtro de Lateralidade\", overlay=true,\r\n     margin_long=100, margin_short=100,\r\n     default_qty_type=strategy.percent_of_equity, default_qty_value=10)\r\n\r\n// =============================\r\n//        PARÃ‚METROS\r\n// =============================\r\nemaFastLen = input.int(9,  \"EMA RÃ¡pida\")\r\nemaSlowLen = input.int(21, \"EMA Lenta\")\r\nemaTrend   = input.int(50, \"EMA TendÃªncia\")\r\nrsiLen     = input.int(14, \"RSI\")\r\ndiLen      = input.int(14, \"DI Length\")\r\nadxSmooth  = input.int(14, \"SuavizaÃ§Ã£o ADX\")\r\nrsiBuyMin  = input.int(50, \"RSI MÃ­nimo p/ Compra\")\r\nrsiSellMax = input.int(50, \"RSI MÃ¡ximo p/ Venda\")\r\nadxFilter  = input.int(15, \"ADX mÃ­nimo\")\r\ncooldown   = input.int(1,  \"Candles de espera apÃ³s sinal\")\r\natrLen     = input.int(14, \"ATR Length\")\r\natrFilter  = input.float(0.003, \"ATR mÃ­nimo relativo ao preÃ§o (0.003 = 0.3%)\", step=0.0001)\r\n\r\n// Valor fixo para TP/SL â€“ cerca de 0,65%\r\nsl_tp_pct = 0.0065   // 0.65%\r\n\r\n// =============================\r\n//        CÃLCULOS\r\n// =============================\r\nemaFast = ta.ema(close, emaFastLen)\r\nemaSlow = ta.ema(close, emaSlowLen)\r\nemaTrendLine = ta.ema(close, emaTrend)\r\nrsi = ta.rsi(close, rsiLen)\r\n[dmiPlus, dmiMinus, adx] = ta.dmi(diLen, adxSmooth)\r\natr = ta.atr(atrLen)\r\n\r\nbullCross = ta.crossover(emaFast, emaSlow)\r\nbearCross = ta.crossunder(emaFast, emaSlow)\r\n\r\ncandleRange = high - low\r\nbody        = math.abs(close - open)\r\nstrongBull  = close > open and body >= candleRange * 0.5\r\nstrongBear  = close < open and body >= candleRange * 0.5\r\n\r\nvolatilityOk = atr / close > atrFilter\r\n\r\nlongBase  = bullCross and rsi > rsiBuyMin  and adx > adxFilter and strongBull and close > emaTrendLine and volatilityOk\r\nshortBase = bearCross and rsi < rsiSellMax and adx > adxFilter and strongBear and close < emaTrendLine and volatilityOk\r\n\r\n// =============================\r\n//     COOLDOWN\r\n// =============================\r\nvar int lastSignalBar = na\r\nbarsSinceLast = na(lastSignalBar) ? 1e9 : (bar_index - lastSignalBar)\r\ncooldownOk    = barsSinceLast > cooldown\r\n\r\nlongSignal  = longBase and cooldownOk\r\nshortSignal = shortBase and cooldownOk\r\n\r\n// =============================\r\n//     ENTRADAS E TP/SL FIXOS\r\n// =============================\r\nif (longSignal)\r\n    sl = close * (1 - sl_tp_pct)\r\n    tp = close * (1 + sl_tp_pct)\r\n    strategy.entry(\"Long\", strategy.long)\r\n    strategy.exit(\"Long Exit\", \"Long\", stop=sl, limit=tp)\r\n    lastSignalBar := bar_index\r\n\r\n\r\nif (shortSignal)\r\n    sl = close * (1 + sl_tp_pct)\r\n    tp = close * (1 - sl_tp_pct)\r\n    strategy.entry(\"Short\", strategy.short)\r\n    strategy.exit(\"Short Exit\", \"Short\", stop=sl, limit=tp)\r\n    lastSignalBar := bar_index\r\n    \r\n\r\n// =============================\r\n//           PLOTS\r\n// =============================\r\nplot(emaFast, \"EMA 9\",  color=color.new(color.green, 0))\r\nplot(emaSlow, \"EMA 21\", color=color.new(color.red,   0))\r\nplot(emaTrendLine, \"EMA TendÃªncia\", color=color.new(color.blue, 0))\r\nplot(atr, \"ATR\", color=color.new(color.purple, 0))"
  },
  {
    "url": "Ua0HFFQR",
    "name": "Vital Wave 20-50",
    "description": "Simplicity is almost always the most effective approach, and here Iâ€™m giving you a trend-following system that exploits the bullish bias of traditional markets and their trending nature, with very basic rules.\n\n\n Rules (long entries only)   \n\n â€¢ Market entry:  When the EMA 20 crosses above the EMA 50 (from below)  \n\n â€¢ Main market exit:  When the EMA 20 crosses below the EMA 50 (from above)  \n\n â€¢ Fixed Stop Loss:  Placed at the price level of the Lower Bollinger Band at the moment the trade is entered.\n\nIn my strategy, the primary exit is when the EMA 20 crosses below the EMA 50. However, this crossover can sometimes take a while to occur, and in the meantime the price may have already dropped significantly. The Stop Loss based on the Lower Bollinger Band is designed to limit losses in case the market moves sharply against the position without giving the bearish crossover signal in time. Having two exit conditions makes the strategy much more robust in terms of risk management.\n\n\n Risk Management: \n\nâ€¢  Initial capital:  $10,000\n\nâ€¢  Position size:  10% of available capital per trade\n\nâ€¢  Commissions:  0.1% on traded volume\n\nâ€¢  Stop Loss:  Based on the Lower Bollinger Band\n\nâ€¢  Take Profit / Exit:  When EMA 20 crosses below EMA 50\n\n\nRecommended Markets:\n\n XAUUSD (OANDA) (Daily) \n\nPeriod: January 3, 1833 â€“ November 23, 2025\nTotal Profit & Loss: +$6,030.62 USD (+57.57%)\nMaximum Drawdown: $541.53 USD (3.83%)\nTotal Trades: 136\nWinning Trades (Win Rate): 36.03% (49/136)\nProfit Factor: 2.483\n\n XAUUSD (OANDA) (12-hour) \nPeriod: March 19, 2006 â€“ November 23, 2025\nTotal Profit & Loss: +$1,209.56 USD (+11.89%)\nMaximum Drawdown: $384.58 USD (3.61%)\nTotal Trades: 97\nWinning Trades (Win Rate): 35.05% (34/97)\nProfit Factor: 1.676\n\n XAUUSD (OANDA) (8-hour) \nPeriod: March 19, 2006 â€“ November 23, 2025\nTotal Profit & Loss: +$1,179.36 USD (+11.81%)\nMaximum Drawdown: $246.88 USD (2.32%)\nTotal Trades: 147\nWinning Trades (Win Rate): 31.97% (47/147)\nProfit Factor: 1.626\n\n Tesla (NASDAQ) (4-hour) \nPeriod: June 29, 2010 â€“ November 23, 2025\nTotal Profit & Loss (Absolute): +$11,687.90 USD (+116.88%)\nMaximum Drawdown: $922.05 USD (6.50%)\nTotal Trades: 68\nWinning Trades (Win Rate): 39.71% (27/68)\nProfit Factor: 4.156\n\n Tesla (NASDAQ) (3-hour) \nTotal Profit & Loss: +$11,522.33 USD (+115.22%)\nMaximum Drawdown: $1,247.60 USD (8.80%)\nTotal Trades: 114\nWinning Trades: 33.33% (38/114)\nProfit Factor: 2.811\n\n\n Additional Recommendations \n\n(These assets have shown good trending behavior with the same strategy across multiple timeframes):  \n\nâ€¢ NVDA  (15 min, 30 min, 1h, 2h, 3h, 4h, 6h, 8h, 12h, Daily)  \n\nâ€¢ NFLX  (1h, 2h, 3h, 4h, 6h, 8h, 12h, Daily)  \n\nâ€¢ MA  (1h, 2h, 3h, 4h, 6h, 8h, 12h, Daily)  \n\nâ€¢ META  (1h, 2h, 3h, 4h, 6h, 8h, 12h, Daily)  \n\nâ€¢ AAPL  (1h, 2h, 3h, 4h, 6h, 8h, 12h, Daily)  \n\nâ€¢ SPY  (12h, Daily)\n\n\n About the Code \n\nThe user can modify:\nâ€¢ EMA periods (20 and 50 by default)\nâ€¢ Bollinger Bands length (20 periods)\nâ€¢ Standard deviation (2.0)\n\n Visualization \n\nâ€¢ EMA 20: Blue line\nâ€¢ EMA 50: Red line\nâ€¢ Green background when EMA20 > EMA50 (bullish trend)\nâ€¢ Red background when EMA20 < EMA50 (bearish trend)\n\n\n Important Note: \n\nWe can significantly increase the profit factor and overall profitability by risking a fixed percentage per trade instead of a fixed amount. This would prevent losses from fluctuating with changes in volatility.\n\nThis could be implemented by reducing position size or adjusting leverage based on the volatility percentage required for each trade, but Iâ€™m not sure if this is fully possible in Pine Script. In my other script, â€œ Golden Cross 50/200 EMA ,â€ I go deeper into this topic and provide examples.\n\nI hope you enjoy this contribution. Best regards!\n",
    "image_url": "Ua0HFFQR",
    "author": "OldWave96",
    "likes": 45,
    "type": "strategy",
    "created": "2025-11-23",
    "updated": "2025-11-23",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// Â© Especulador96\r\n\r\n// @version=5\r\nstrategy(\"Vital Wave 20-50\", \r\n     overlay=true, \r\n     initial_capital=10000, \r\n     default_qty_type=strategy.percent_of_equity, \r\n     default_qty_value=10,\r\n     commission_type=strategy.commission.percent, \r\n     commission_value=0.1)\r\n\r\n// Inputs\r\nema20_length = input.int(20, \"EMA 20 Period\")\r\nema50_length = input.int(50, \"EMA 50 Period\")\r\nbb_length = input.int(20, \"Bollinger Bands Length\")\r\nbb_std = input.float(2.0, \"Bollinger Bands Std Dev\")\r\n\r\n// Calculating EMAs\r\nema20 = ta.ema(close, ema20_length)\r\nema50 = ta.ema(close, ema50_length)\r\n\r\n// Bollinger Bands\r\nbb_basis = ta.sma(close, bb_length)\r\nbb_dev = bb_std * ta.stdev(close, bb_length)\r\nbb_lower = bb_basis - bb_dev\r\n\r\n// Crossover conditions\r\nema20_cross_above_ema50 = ta.crossover(ema20, ema50)\r\nema20_cross_below_ema50 = ta.crossunder(ema20, ema50)\r\n\r\n// Stop Loss Level\r\nvar float stopLossLevel = na\r\n\r\n// Strategy Logic\r\nif (ema20_cross_above_ema50)\r\n    strategy.entry(\"Long\", strategy.long)\r\n    stopLossLevel := bb_lower\r\n    label.new(bar_index, bb_lower, \"SL\", color=color.red, style=label.style_label_up, \r\n             textcolor=color.white, size=size.small)\r\n\r\nif (ema20_cross_below_ema50)\r\n    strategy.close(\"Long\")\r\n    stopLossLevel := na\r\n\r\n// Stop Loss on TOUCH (using intrabar low)\r\nif (strategy.position_size > 0 and low <= stopLossLevel)\r\n    strategy.close(\"Long\", comment=\"Stop Loss\")\r\n    stopLossLevel := na\r\n\r\n// Plotting\r\nplot(ema20, color=color.rgb(10, 94, 163), linewidth=2, title=\"EMA 20\")\r\nplot(ema50, color=color.rgb(187, 22, 22), linewidth=2, title=\"EMA 50\")\r\nbgcolor(ema20 > ema50 ? color.new(color.green, 95) : color.new(color.red, 95))"
  },
  {
    "url": "Ikg05vOx-MTF-Scalper-alemicihan",
    "name": "MTF Scalper - alemicihan",
    "description": "Multi-Timeframe Scalper Strategy: Aligning the Big Picture for Quick Gains\n\nThis article presents a robust futures trading strategy designed for high-frequency scalping in the crypto market. Itâ€™s built on the principle of minimizing risk by ensuring that short-term entries are always aligned with the dominant, higher-timeframe trend.\n\nThe Core Concept: Alignment is Key \n\nA Balanced Trend Follower approach, now refined for rapid scalping, uses a Multi-Timeframe (MTF) confirmation system to filter out market noise and increase the probability of a successful trade.\n\nThe strategy operates on a Low Timeframe (LTF) chart (e.g., 3m, 5m, or 15m) but only executes trades if the direction is validated by three Higher Timeframes (HTF).\n\nComponentPurposeFunctionHTF (D, 4h, 1h) EMA => Trend Confirmation =>Checks if the current price is above/below all three Exponential Moving Averages (EMA 20). This provides a strong directional bias.\nLTF (5m) Stochastic RSI => Momentum Entry => Generates the actual buy/sell signal by spotting a swift crossover, indicating fresh momentum in the direction of the confirmed HTF trend.\n\nHow The Signal Is Generated\n\nTrend Alignment: The system first confirms the trend. If the price is trading above the Daily, 4-Hour, and 1-Hour EMAs, the market is deemed to be in a Strong LONG Trend. Only LONG signals are permitted.\n\nMomentum Trigger: Once the trend is confirmed, a Long Signal is generated only when the Stochastic K-Line crosses above the D-Line, indicating a momentum shift (a pullback ending) towards the main trend direction.\n\nShort Signal: The inverse logic applies to the Short Trend confirmation and entry signal.\n\nMandatory Risk Management: ATR-Based Exit\n\nGiven the high leverage nature of futures and scalping, static Stop-Loss (SL) and Take-Profit (TP) levels are inefficient. This strategy uses the Average True Range (ATR) indicator to dynamically set profit and loss targets based on current market volatility.\n\nStop Loss (SL): Set dynamically at 1.5 x ATR below (for long) or above (for short) the entry price. This gives the trade enough room to breathe without risking excessive capital.\n\nTake Profit (TP): Set dynamically at 3.0 x ATR, establishing a robust Risk-to-Reward Ratio of 1:2.\n\nFinal Thoughts on Testing\n\nThis sophisticated approach combines the reliability of MTF analysis with the speed of momentum indicators. However, data analysis is key. Backtesting these parameters (EMA, ATR Multipliers, RSI/Stochastic lengths) on your chosen asset (like BTC/USDT or ETH/USDT) and timeframe is crucial to achieving optimal performance.",
    "image_url": "Ikg05vOx",
    "author": "alemicihan",
    "likes": 17,
    "type": "strategy",
    "created": "2025-11-22",
    "updated": "2025-11-22",
    "source": "//@version=6\r\nstrategy(\"MTF Scalper - alemicihan\", overlay=true, \r\n     initial_capital=10000, default_qty_value=10, \r\n     default_qty_type=strategy.percent_of_equity, currency=currency.USD)\r\n\r\n// --- 1. Girdi Parametreleri ---\r\nhtf1_res = input.string(defval=\"60\", title=\"HTF 1 (Saatlik)\") \r\nhtf2_res = input.string(defval=\"240\", title=\"HTF 2 (4 Saatlik)\") \r\nhtf3_res = input.string(defval=\"D\", title=\"HTF 3 (GÃ¼nlÃ¼k)\") \r\nema_length = input.int(defval=20, title=\"EMA Periyodu (HTF)\", minval=1)\r\n\r\n// GiriÅŸ GÃ¶stergesi (Stokastik RSI) AyarlarÄ±\r\nrsi_length = input.int(defval=14, title=\"RSI UzunluÄŸu\", minval=1) \r\nstoch_k_length = input.int(defval=3, title=\"K UzunluÄŸu (Smoothing)\", minval=1) \r\nstoch_d_length = input.int(defval=3, title=\"D UzunluÄŸu (Signal Line)\", minval=1) \r\nstoch_fast_k_length = input.int(defval=14, title=\"Stoch K Hesaplama Periyodu\", minval=1) \r\n\r\n// Risk YÃ¶netimi \r\natr_period = input.int(defval=14, title=\"SL/TP iÃ§in ATR Periyodu\", minval=1)\r\nsl_multiplier = input.float(defval=1.5, title=\"Stop Loss ATR Ã‡arpanÄ±\", minval=0.1)\r\ntp_multiplier = input.float(defval=3.0, title=\"Take Profit ATR Ã‡arpanÄ±\", minval=0.1)\r\n\r\n// --- 2. YÃ¼ksek Zaman Dilimi (HTF) HesaplamalarÄ± ---\r\nf_get_ema(res) => \r\n    request.security(syminfo.tickerid, res, ta.ema(close, ema_length)[1])\r\n\r\nhtf1_ema = f_get_ema(htf1_res)\r\nhtf2_ema = f_get_ema(htf2_res)\r\nhtf3_ema = f_get_ema(htf3_res)\r\n\r\ntrend_long = close > htf1_ema and close > htf2_ema and close > htf3_ema\r\ntrend_short = close < htf1_ema and close < htf2_ema and close < htf3_ema\r\n\r\n// --- 3. GiriÅŸ Sinyali HesaplamalarÄ± (LTF) ---\r\n// Stokastik RSI hesaplamasÄ±\r\nrsi_value = ta.rsi(close, rsi_length)\r\nstoch_k = ta.sma(ta.stoch(rsi_value, rsi_value, rsi_value, stoch_fast_k_length), stoch_k_length)\r\nstoch_d = ta.sma(stoch_k, stoch_d_length)\r\n\r\n// --- KRÄ°TÄ°K DÃœZELTME: Crossover/Crossunder sinyallerini global deÄŸiÅŸkenlere atama ---\r\nk_cross_d_up = ta.crossover(stoch_k, stoch_d)\r\nk_cross_d_down = ta.crossunder(stoch_k, stoch_d)\r\n\r\n// Scalp GiriÅŸ KoÅŸullarÄ±\r\nlong_signal = trend_long and k_cross_d_up\r\nshort_signal = trend_short and k_cross_d_down\r\n\r\n// --- 4. Risk YÃ¶netimi HesaplamalarÄ± (ATR TabanlÄ± Dinamik SL/TP) ---\r\ncurrent_atr = ta.atr(atr_period)\r\n\r\nlong_sl_points = current_atr * sl_multiplier\r\nlong_tp_points = current_atr * tp_multiplier\r\nshort_sl_points = current_atr * sl_multiplier\r\nshort_tp_points = current_atr * tp_multiplier\r\n\r\n// --- 5. Strateji Emirlerinin GerÃ§ekleÅŸtirilmesi ---\r\n// Long Pozisyon YÃ¶netimi\r\nif long_signal and strategy.position_size == 0\r\n    long_sl_level = close - long_sl_points\r\n    long_tp_level = close + long_tp_points\r\n    \r\n    strategy.entry(\"L_Entry\", strategy.long)\r\n    strategy.exit(\"L_Exit\", from_entry=\"L_Entry\", stop=long_sl_level, limit=long_tp_level)\r\n\r\n// Short Pozisyon YÃ¶netimi\r\nif short_signal and strategy.position_size == 0\r\n    short_sl_level = close + short_sl_points\r\n    short_tp_level = close - short_tp_points\r\n    \r\n    strategy.entry(\"S_Entry\", strategy.short)\r\n    strategy.exit(\"S_Exit\", from_entry=\"S_Entry\", stop=short_sl_level, limit=short_tp_level)\r\n\r\n// --- 6. Grafiksel Ã‡izimler ---\r\nbgcolor(trend_long ? color.new(color.green, 90) : trend_short ? color.new(color.red, 90) : na)"
  },
  {
    "url": "DPaFLc0u-Hull-VWMA-Crossover-Strategy",
    "name": "Hull VWMA Crossover Strategy",
    "description": "A simple variation on the Hull Moving Average which reacts faster to high volume events, making it more responsive in those cases than even the standard Hull average -- CREDIT GOES TO Saolof -  -- Edited into a strategy with some more options that im going to continue to refine. LMK if theres any features or confluence you want me to add -- cheers! ",
    "image_url": "DPaFLc0u",
    "author": "Kevin-Patrick",
    "likes": 10,
    "type": "strategy",
    "created": "2025-11-24",
    "updated": "2025-11-24",
    "source": "//@version=6\r\nstrategy(title=\"Hull Volume Weighted Moving Average Strategy [Kevin-Patrick]\", shorttitle=\"HVWMA Strategy [Kevin-Patrick]\", overlay=true, \r\n         default_qty_type=strategy.percent_of_equity, default_qty_value=100,\r\n         initial_capital=10000, commission_type=strategy.commission.percent, commission_value=0.1,\r\n         calc_on_every_tick=false, calc_on_order_fills=false, \r\n         process_orders_on_close=false, max_bars_back=5000)\r\n\r\n// ============================================\r\n// INDICATOR SETTINGS\r\n// ============================================\r\nlen = input.int(100, minval=1, title=\"Hull VWMA Length\")\r\nsrc = input.source(close, title=\"Source\")\r\ngeometric = input.bool(false, title=\"Geometric Mean\")\r\nshow_hvwma = input.bool(true, title=\"Show Hull VWMA Line\")\r\nlinewidth = input.int(3, minval=1, title=\"Line Width\")\r\n\r\n// ============================================\r\n// VISUAL SETTINGS\r\n// ============================================\r\nshow_signals = input.bool(false, title=\"Show Buy/Sell Signals\", group=\"Visual Settings\")\r\nshow_background = input.bool(false, title=\"Show Position Background Color\", group=\"Visual Settings\")\r\nshow_trades = input.bool(false, title=\"Show Trades on Chart\", group=\"Visual Settings\")\r\nshow_labels = input.bool(false, title=\"Show Trade Labels\", group=\"Visual Settings\")\r\n\r\n// ============================================\r\n// STRATEGY SETTINGS\r\n// ============================================\r\ntrade_direction = input.string(title=\"Trade Direction\", defval=\"Long Only\", options=[\"Long Only\", \"Short Only\", \"Both\"])\r\n\r\n// Stop Loss\r\nuse_stop_loss = input.bool(true, title=\"Use Stop Loss\", group=\"Risk Management\")\r\nstop_loss_percent = input.float(2.0, title=\"Stop Loss %\", minval=0.1, step=0.1, group=\"Risk Management\")\r\n\r\n// Multiple Take Profit Levels\r\nuse_tp1 = input.bool(true, title=\"Use TP1\", group=\"Take Profit Levels\")\r\ntp1_percent = input.float(2.0, title=\"TP1 %\", minval=0.1, step=0.1, group=\"Take Profit Levels\")\r\ntp1_qty = input.float(33.0, title=\"TP1 Quantity %\", minval=1, maxval=100, step=1, group=\"Take Profit Levels\")\r\n\r\nuse_tp2 = input.bool(true, title=\"Use TP2\", group=\"Take Profit Levels\")\r\ntp2_percent = input.float(4.0, title=\"TP2 %\", minval=0.1, step=0.1, group=\"Take Profit Levels\")\r\ntp2_qty = input.float(33.0, title=\"TP2 Quantity %\", minval=1, maxval=100, step=1, group=\"Take Profit Levels\")\r\n\r\nuse_tp3 = input.bool(true, title=\"Use TP3\", group=\"Take Profit Levels\")\r\ntp3_percent = input.float(6.0, title=\"TP3 %\", minval=0.1, step=0.1, group=\"Take Profit Levels\")\r\ntp3_qty = input.float(34.0, title=\"TP3 Quantity %\", minval=1, maxval=100, step=1, group=\"Take Profit Levels\")\r\n\r\nuse_trailing_stop = input.bool(false, title=\"Use Trailing Stop\", group=\"Risk Management\")\r\ntrailing_stop_percent = input.float(1.5, title=\"Trailing Stop %\", minval=0.1, step=0.1, group=\"Risk Management\")\r\n\r\n// ============================================\r\n// ADDITIONAL FILTERS\r\n// ============================================\r\nuse_trend_filter = input.bool(false, title=\"Use Trend Filter (SMA)\", group=\"Filters\")\r\ntrend_sma_length = input.int(200, title=\"Trend SMA Length\", group=\"Filters\")\r\nuse_volatility_filter = input.bool(false, title=\"Use Volatility Filter (ATR)\", group=\"Filters\")\r\natr_length = input.int(14, title=\"ATR Length\", group=\"Filters\")\r\nmin_atr_multiplier = input.float(1.0, title=\"Minimum ATR Multiplier\", minval=0.1, step=0.1, group=\"Filters\")\r\n\r\n// ============================================\r\n// RSI CONFLUENCE SETTINGS\r\n// ============================================\r\nuse_rsi_entry = input.bool(false, title=\"Use RSI for Entry\", group=\"RSI Confluence\")\r\nrsi_length = input.int(14, title=\"RSI Length\", minval=1, group=\"RSI Confluence\")\r\nrsi_overbought = input.float(70, title=\"RSI Overbought Level\", minval=50, maxval=100, step=1, group=\"RSI Confluence\")\r\nrsi_oversold = input.float(30, title=\"RSI Oversold Level\", minval=0, maxval=50, step=1, group=\"RSI Confluence\")\r\n\r\nuse_rsi_exit = input.bool(false, title=\"Use RSI for Exit\", group=\"RSI Confluence\")\r\nrsi_exit_long = input.float(70, title=\"RSI Exit Long Level\", minval=50, maxval=100, step=1, group=\"RSI Confluence\")\r\nrsi_exit_short = input.float(30, title=\"RSI Exit Short Level\", minval=0, maxval=50, step=1, group=\"RSI Confluence\")\r\n\r\n// ============================================\r\n// DATE RANGE FILTER\r\n// ============================================\r\nuse_date_filter = input.bool(false, title=\"Use Date Range Filter\", group=\"Date Range\")\r\nstart_year = input.int(2020, title=\"Start Year\", group=\"Date Range\")\r\nstart_month = input.int(1, title=\"Start Month\", minval=1, maxval=12, group=\"Date Range\")\r\nstart_day = input.int(1, title=\"Start Day\", minval=1, maxval=31, group=\"Date Range\")\r\nend_year = input.int(2025, title=\"End Year\", group=\"Date Range\")\r\nend_month = input.int(12, title=\"End Month\", minval=1, maxval=12, group=\"Date Range\")\r\nend_day = input.int(31, title=\"End Day\", minval=1, maxval=31, group=\"Date Range\")\r\n\r\n// ============================================\r\n// HULL VWMA CALCULATION\r\n// ============================================\r\nlsrc = math.log(src)\r\ncorrvol = nz(volume) + 1  // Makes it properly handle charts where volume is only available for part of its history\r\n\r\nvolume_wma(series, length) =>\r\n    ta.wma(series * corrvol, length) / ta.wma(corrvol, length)\r\n\r\nvolume_hma(series, length) =>\r\n    ta.wma(2 * volume_wma(series, length / 2) - volume_wma(series, length), math.round(math.sqrt(length)))\r\n\r\nvolume_hullma = volume_hma(geometric ? lsrc : src, len)\r\nhvwma = geometric ? math.exp(volume_hullma) : volume_hullma\r\n\r\n// ============================================\r\n// INDICATOR VISUALIZATION\r\n// ============================================\r\noscillator_coloring(series) =>\r\n    series > 0 ? color.green : color.red\r\n\r\nplot(show_hvwma ? hvwma : na, color=oscillator_coloring(ta.change(hvwma)), \r\n     linewidth=linewidth, title=\"Hull VWMA\")\r\n\r\n// ============================================\r\n// FILTERS\r\n// ============================================\r\n// Trend Filter\r\ntrend_sma = ta.sma(close, trend_sma_length)\r\nplot(use_trend_filter ? trend_sma : na, color=color.orange, linewidth=1, title=\"Trend SMA\")\r\nlong_trend_ok = not use_trend_filter or close > trend_sma\r\nshort_trend_ok = not use_trend_filter or close < trend_sma\r\n\r\n// Volatility Filter\r\natr_value = ta.atr(atr_length)\r\nvolatility_ok = not use_volatility_filter or atr_value > (atr_value[1] * min_atr_multiplier)\r\n\r\n// RSI Confluence Filter\r\nrsi = ta.rsi(close, rsi_length)\r\nrsi_long_ok = not use_rsi_entry or rsi < rsi_oversold\r\nrsi_short_ok = not use_rsi_entry or rsi > rsi_overbought\r\n\r\n// RSI Exit Conditions\r\nrsi_exit_long_signal = use_rsi_exit and rsi > rsi_exit_long\r\nrsi_exit_short_signal = use_rsi_exit and rsi < rsi_exit_short\r\n\r\n// Date Range Filter\r\ndate_ok = true\r\nif use_date_filter\r\n    start_time = timestamp(start_year, start_month, start_day, 0, 0)\r\n    end_time = timestamp(end_year, end_month, end_day, 23, 59)\r\n    date_ok := time >= start_time and time <= end_time\r\n\r\n// ============================================\r\n// SIGNAL GENERATION\r\n// ============================================\r\n// Crossover signals\r\nprice_cross_above = ta.crossover(src, hvwma)\r\nprice_cross_below = ta.crossunder(src, hvwma)\r\n\r\n// Alternative: HVWMA slope change (momentum shift)\r\nhvwma_rising = hvwma > hvwma[1]\r\nhvwma_falling = hvwma < hvwma[1]\r\n\r\n// Combine signals with filters\r\nlong_signal = price_cross_above and long_trend_ok and volatility_ok and rsi_long_ok and date_ok\r\nshort_signal = price_cross_below and short_trend_ok and volatility_ok and rsi_short_ok and date_ok\r\n\r\n// ============================================\r\n// STRATEGY EXECUTION\r\n// ============================================\r\n// Entry conditions based on trade direction\r\ncan_long = trade_direction == \"Long Only\" or trade_direction == \"Both\"\r\ncan_short = trade_direction == \"Short Only\" or trade_direction == \"Both\"\r\n\r\n// Long Entry\r\nif (long_signal and can_long)\r\n    strategy.entry(\"Long\", strategy.long)\r\n\r\n// Short Entry\r\nif (short_signal and can_short)\r\n    strategy.entry(\"Short\", strategy.short)\r\n\r\n// Exit opposite position on crossover\r\nif (long_signal and strategy.position_size < 0)\r\n    strategy.close(\"Short\")\r\n\r\nif (short_signal and strategy.position_size > 0)\r\n    strategy.close(\"Long\")\r\n\r\n// RSI-based exits\r\nif (rsi_exit_long_signal and strategy.position_size > 0)\r\n    strategy.close(\"Long\", comment=\"RSI Exit\")\r\n\r\nif (rsi_exit_short_signal and strategy.position_size < 0)\r\n    strategy.close(\"Short\", comment=\"RSI Exit\")\r\n\r\n// ============================================\r\n// RISK MANAGEMENT - MULTIPLE TAKE PROFITS\r\n// ============================================\r\n// Calculate stop loss and take profit levels for LONG positions\r\nlong_stop_loss = strategy.position_avg_price * (1 - stop_loss_percent / 100)\r\nlong_tp1 = strategy.position_avg_price * (1 + tp1_percent / 100)\r\nlong_tp2 = strategy.position_avg_price * (1 + tp2_percent / 100)\r\nlong_tp3 = strategy.position_avg_price * (1 + tp3_percent / 100)\r\n\r\n// Calculate stop loss and take profit levels for SHORT positions\r\nshort_stop_loss = strategy.position_avg_price * (1 + stop_loss_percent / 100)\r\nshort_tp1 = strategy.position_avg_price * (1 - tp1_percent / 100)\r\nshort_tp2 = strategy.position_avg_price * (1 - tp2_percent / 100)\r\nshort_tp3 = strategy.position_avg_price * (1 - tp3_percent / 100)\r\n\r\n// Long Position Exits with Multiple TPs\r\nif (strategy.position_size > 0)\r\n    if use_stop_loss\r\n        strategy.exit(\"Long SL\", \"Long\", stop=long_stop_loss)\r\n    \r\n    if use_tp1\r\n        strategy.exit(\"Long TP1\", \"Long\", limit=long_tp1, qty_percent=tp1_qty)\r\n    \r\n    if use_tp2\r\n        strategy.exit(\"Long TP2\", \"Long\", limit=long_tp2, qty_percent=tp2_qty)\r\n    \r\n    if use_tp3\r\n        strategy.exit(\"Long TP3\", \"Long\", limit=long_tp3, qty_percent=tp3_qty)\r\n\r\n// Short Position Exits with Multiple TPs\r\nif (strategy.position_size < 0)\r\n    if use_stop_loss\r\n        strategy.exit(\"Short SL\", \"Short\", stop=short_stop_loss)\r\n    \r\n    if use_tp1\r\n        strategy.exit(\"Short TP1\", \"Short\", limit=short_tp1, qty_percent=tp1_qty)\r\n    \r\n    if use_tp2\r\n        strategy.exit(\"Short TP2\", \"Short\", limit=short_tp2, qty_percent=tp2_qty)\r\n    \r\n    if use_tp3\r\n        strategy.exit(\"Short TP3\", \"Short\", limit=short_tp3, qty_percent=tp3_qty)\r\n\r\n// ============================================\r\n// VISUAL AIDS\r\n// ============================================\r\n// Plot buy/sell signals (only if enabled)\r\nplotshape(show_signals and long_signal and can_long, title=\"Long Signal\", location=location.belowbar, \r\n          color=color.green, style=shape.triangleup, size=size.small)\r\nplotshape(show_signals and short_signal and can_short, title=\"Short Signal\", location=location.abovebar, \r\n          color=color.red, style=shape.triangledown, size=size.small)\r\n\r\n// Background color for active positions (only if enabled)\r\nbgcolor(show_background and strategy.position_size > 0 ? color.new(color.green, 95) : show_background and strategy.position_size < 0 ? color.new(color.red, 95) : na)\r\n\r\n// Plot TP levels for visualization (optional)\r\nplot(strategy.position_size > 0 and use_tp1 ? long_tp1 : na, title=\"Long TP1\", color=color.new(color.green, 70), style=plot.style_linebr, linewidth=1)\r\nplot(strategy.position_size > 0 and use_tp2 ? long_tp2 : na, title=\"Long TP2\", color=color.new(color.green, 60), style=plot.style_linebr, linewidth=1)\r\nplot(strategy.position_size > 0 and use_tp3 ? long_tp3 : na, title=\"Long TP3\", color=color.new(color.green, 50), style=plot.style_linebr, linewidth=1)\r\n\r\nplot(strategy.position_size < 0 and use_tp1 ? short_tp1 : na, title=\"Short TP1\", color=color.new(color.red, 70), style=plot.style_linebr, linewidth=1)\r\nplot(strategy.position_size < 0 and use_tp2 ? short_tp2 : na, title=\"Short TP2\", color=color.new(color.red, 60), style=plot.style_linebr, linewidth=1)\r\nplot(strategy.position_size < 0 and use_tp3 ? short_tp3 : na, title=\"Short TP3\", color=color.new(color.red, 50), style=plot.style_linebr, linewidth=1)\r\n\r\n// Plot stop loss levels\r\nplot(strategy.position_size > 0 and use_stop_loss ? long_stop_loss : na, title=\"Long SL\", color=color.new(color.red, 0), style=plot.style_linebr, linewidth=2)\r\nplot(strategy.position_size < 0 and use_stop_loss ? short_stop_loss : na, title=\"Short SL\", color=color.new(color.red, 0), style=plot.style_linebr, linewidth=2)\r\n\r\n// ============================================\r\n// ALERTS\r\n// ============================================\r\nalertcondition(long_signal, title=\"Long Signal Alert\", message=\"Hull VWMA: Long Entry Signal\")\r\nalertcondition(short_signal, title=\"Short Signal Alert\", message=\"Hull VWMA: Short Entry Signal\")\r\n"
  },
  {
    "url": "MtNGKsLA-BTC-Risk-Metric-DCA-Adapter-3Commas-Webhook-Strategy",
    "name": "BTC Risk Metric DCA Adapter (3Commas Webhook Strategy)",
    "description": "Risk Metric DCA Adapter (3Commas Webhook Strategy) - WORK IN PROGRESS\n\nThis Pine Script strategy, originally inspired by the Risk Metric Indicator, is fundamentally engineered as an Adapter to interface with external trading bots like 3Commas via Webhooks. It calculates a dynamic market risk score and translates that score into specific dollar-cost averaging (DCA) entry levels and tiered profit-taking exits.\n\nKey Features & Logic\n\nRisk Metric Calculation (Credit to The Trading Parrot):\nThe strategy incorporates a complex, multi-timeframe Risk Metric calculation based on daily and weekly moving averages (SMA) and standard deviation (StDev). This metric aims to quantify the current market overextension or compression relative to long-term historical data. The resulting score dictates the level of conviction for a new trade.\n\nTiered DCA Entry Sizing:\nThe strategy defines three distinct Buy Levels (L1, L2, L3) corresponding to increasingly favorable (lower) Risk Metric scores.\n\nL1 (Base): Risk is moderate, initiating the minimum defined trade amount.\n\nL2 (Scaled): Risk is low, initiating L1 amount + L2 amount.\n\nL3 (Aggressive): Risk is very low, initiating L1 + L2 + L3 amounts.\n\nTiered Profit-Taking Exits:\nThe strategy implements a staggered, partial profit-taking approach based on the Risk Metric rising:\n\nSell L1 & L2: Closes a percentage of the current position when the Risk Metric reaches defined high thresholds, locking in partial profits.\n\nSell L3 (Full Exit): Closes the remaining position when the Risk Metric reaches the highest defined threshold.\n\nThe Adapter Function (Webhook Integration)\n\nThis script is unique because it uses the Pine Script strategy() function to trigger Order Fills, which are necessary to access powerful placeholders in the TradingView alert system.\n\nTrigger Type: The alert must be set to trigger on Any order fill.\n\nDynamic Webhook Data: Instead of using fixed alert() commands, the strategy generates dynamic labels (e.g., BUY_ENTRY_L3_USD_1000 or SELL_L1_PCT_25) using the strategy.entry and strategy.close commands.\n\nData Transfer: The alert message then uses the placeholder {{strategy.order.comment}} to pass these dynamic labels to the 3Commas bot, allowing the bot to execute the precise action (e.g., start_deal_with_volume_in_quote_currency or close_deal_at_market_percentage).\n\nFull Strategy Webhook payload \n{\n  \"secret\": \"YOUR_3COMMAS_SECRET_KEY\",\n  \"max_lag\": \"300\",\n  \"timestamp\": \"{{timenow}}\",\n  \"trigger_price\": \"{{close}}\",\n  \"tv_exchange\": \"{{exchange}}\",\n  \"tv_instrument\": \"{{ticker}}\",\n  \"action\": \"{{strategy.order.action}}\",\n  \"bot_uuid\": \"YOUR_BOT_UUID\",\n  \"strategy_info\": {\n    \"market_position\": \"{{strategy.market_position}}\",\n    \"market_position_size\": \"{{strategy.market_position_size}}\",\n    \"prev_market_position\": \"{{strategy.prev_market_position}}\",\n    \"prev_market_position_size\": \"{{strategy.prev_market_position_size}}\"\n  },\n  \"order\": {\n    \"amount\": \"{{strategy.order.contracts}}\",\n    \"currency_type\": \"base\",\n    \"comment\": \"{{strategy.order.comment}}\" \n  }\n}\n\n\nDisclaimer: This script is an adapter tool and does not guarantee profit. Trading requires manual configuration of risk settings, bot parameters, and adherence to platform-specific setup instructions.",
    "image_url": "MtNGKsLA",
    "author": "nakphanan",
    "likes": 24,
    "type": "strategy",
    "created": "2025-11-22",
    "updated": "2025-11-22",
    "source": "//@version=5\r\nstrategy(\"BTC Risk Metric DCA buy/sell\", overlay=true, initial_capital=1000, default_qty_type=strategy.cash, process_orders_on_close=false, max_bars_back=5000)\r\n// This script is optimized to ONLY generate strategy order fills (buys/sells) \r\n// for the TradingView alert system. All webhook details (UUID, Secret, Action) \r\n// are now handled by the JSON message pasted in the alert configuration.\r\n\r\n// â”€â”€ SETTINGS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Removed all webhook inputs (secretKey, botUUID, sendBuys/Sells) and backtestMode.\r\n\r\nfreq = input.string(\"Day\", \"Signal Frequency\", options=[\"Once per bar\", \"Hour\", \"Day\", \"Week\", \"Month\"], group=\"Mode\")\r\nnewPeriod = switch freq\r\n    \"Once per bar\" => true\r\n    \"Hour\" => ta.change(time(\"60\"))\r\n    \"Day\" => ta.change(time(\"D\"))\r\n    \"Week\" => ta.change(time(\"W\"))\r\n    \"Month\" => ta.change(time(\"M\"))\r\n    => false\r\n\r\ntradingPair = input.string(\"BTC_USD\", \"3Commas Pair (For reference)\", group=\"Strategy Info\")\r\n\r\n// â”€â”€ OPTIMIZED RISK METRIC (combined security calls with proper tuple destructuring) â”€â”€\r\n[d_close, d_sma1460, d_stdev1460, d_sma50] = request.security(syminfo.tickerid, \"D\", [close, ta.sma(close, 1460), ta.stdev(close, 1460), ta.sma(close, 50)], lookahead=barmerge.lookahead_on, gaps=barmerge.gaps_off)\r\n\r\n[w_sma20, w_sma50] = request.security(syminfo.tickerid, \"W\", [ta.sma(close, 20), ta.sma(close, 50)], lookahead=barmerge.lookahead_on, gaps=barmerge.gaps_off)\r\n\r\nriskOne = d_stdev1460 != 0 ? ((d_close - d_sma1460) / d_stdev1460) / (-38.12 * math.log(time) + 1078.5) : na\r\nriskTwo = w_sma20 != 0 ? (math.log(d_close / w_sma20) + (-3.719*math.log(time) + 105)) / (-6e-12*time + 10.93) : na\r\nriskThree = w_sma50 != 0 ? (d_sma50 / w_sma50) / (-12.55*math.log(time) + 355.15) : na\r\n\r\nriskMetric = nz((riskOne + riskTwo + riskThree) / 3, 1.0)\r\nriskStr = str.tostring(riskMetric, \"0.00\")\r\n\r\n// â”€â”€ INPUTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nbuyL3_thresh = input.float(0.20, \"Buy L3 Threshold\", group=\"Buy Levels\")\r\nbuyL2_thresh = input.float(0.40, \"Buy L2 Threshold\", group=\"Buy Levels\")\r\nbuyL1_thresh = input.float(0.50, \"Buy L1 Threshold\", group=\"Buy Levels\")\r\nbuyL1_usd    = input.float(100, \"Buy L1 $ Amount\", group=\"Buy Amounts\")\r\nbuyL2_usd    = input.float(300, \"Buy L2 $ Amount\", group=\"Buy Amounts\")\r\nbuyL3_usd    = input.float(600, \"Buy L3 $ Amount\", group=\"Buy Amounts\")\r\n\r\nsellL1_thresh = input.float(0.70, \"Sell L1 Threshold\", group=\"Sell Levels\")\r\nsellL2_thresh = input.float(0.80, \"Sell L2 Threshold\", group=\"Sell Levels\")\r\nsellL3_thresh = input.float(0.90, \"Sell L3 Threshold\", group=\"Sell Levels\")\r\nsellL1_pct    = input.float(25, \"Sell L1 %\", group=\"Sell %\")\r\nsellL2_pct    = input.float(35, \"Sell L2 %\", group=\"Sell %\")\r\n\r\n// â”€â”€ STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nvar bool sellL1_done = false\r\nvar bool sellL2_done = false\r\nvar int  lastSignalBar = -1000\r\n\r\n// Reset sell flags on new entry\r\nif strategy.position_size > strategy.position_size[1]\r\n    sellL1_done := false\r\n    sellL2_done := false\r\n\r\n// â”€â”€ BUY LOGIC â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\ntotalUsd = 0.0\r\nlevel    = \"\"\r\nif riskMetric <= buyL3_thresh\r\n    totalUsd := buyL1_usd + buyL2_usd + buyL3_usd\r\n    level    := \"L3\"\r\nelse if riskMetric <= buyL2_thresh\r\n    totalUsd := buyL1_usd + buyL2_usd\r\n    level    := \"L2\"\r\nelse if riskMetric <= buyL1_thresh\r\n    totalUsd := buyL1_usd\r\n    level    := \"L1\"\r\n\r\n// â”€â”€ CONDITIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nbuyCond   = totalUsd > 0 and newPeriod and bar_index > lastSignalBar\r\nsell1Cond = strategy.position_size > 0 and newPeriod and bar_index > lastSignalBar and not sellL1_done and riskMetric >= sellL1_thresh\r\nsell2Cond = strategy.position_size > 0 and newPeriod and bar_index > lastSignalBar and sellL1_done and not sellL2_done and riskMetric >= sellL2_thresh\r\nsell3Cond = strategy.position_size > 0 and newPeriod and bar_index > lastSignalBar and sellL2_done and riskMetric >= sellL3_thresh\r\n\r\n// â”€â”€ EXECUTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n\r\nif buyCond\r\n    // CRITICAL: Convert USD amount to contracts/shares quantity for strategy.entry\r\n    qtyContracts = totalUsd / close \r\n    comment = \"BUY_ENTRY_\" + level + \"_USD_\" + str.tostring(totalUsd) \r\n    strategy.entry(\"BUY_ENTRY\", strategy.long, qty=qtyContracts, comment=comment)\r\n    lastSignalBar := bar_index\r\n\r\nif sell1Cond\r\n    comment = \"SELL_L1_PCT_\" + str.tostring(sellL1_pct)\r\n    strategy.close(\"BUY_ENTRY\", qty_percent=sellL1_pct, comment=comment)\r\n    sellL1_done := true\r\n    lastSignalBar := bar_index\r\n\r\nif sell2Cond\r\n    comment = \"SELL_L2_PCT_\" + str.tostring(sellL2_pct)\r\n    strategy.close(\"BUY_ENTRY\", qty_percent=sellL2_pct, comment=comment)\r\n    sellL2_done := true\r\n    lastSignalBar := bar_index\r\n\r\nif sell3Cond\r\n    comment = \"SELL_L3_EXIT_100_PCT\"\r\n    strategy.close_all(comment=comment)\r\n    lastSignalBar := bar_index\r\n\r\n// â”€â”€ PLOTS & LABELS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nplotshape(buyCond,   location=location.belowbar, color=color.green,   style=shape.triangleup,   size=size.large)\r\nplotshape(sell1Cond, location=location.abovebar, color=color.red,     style=shape.triangledown, size=size.large)\r\nplotshape(sell2Cond, location=location.abovebar, color=color.orange,  style=shape.triangledown, size=size.large)\r\nplotshape(sell3Cond, location=location.abovebar, color=color.maroon,  style=shape.triangledown, size=size.large)\r\n\r\n// Note: Plotting uses the same logic as your original script\r\nif buyCond\r\n    label.new(bar_index, low * 0.984, \"BUY \" + level + \"\\nRisk: \" + riskStr + \"\\n$\" + str.tostring(totalUsd, \"#,###\"), style=label.style_label_up, color=color.green, textcolor=color.white, yloc=yloc.price)\r\n\r\nif sell1Cond\r\n    usd = strategy.position_size * close * (sellL1_pct / 100)\r\n    label.new(bar_index, high, \"SELL L1\\nRisk: \" + riskStr + \"\\n~$\" + str.tostring(usd, \"#,###\"), style=label.style_label_down, color=color.red, textcolor=color.white, yloc=yloc.abovebar)\r\n\r\nif sell2Cond\r\n    usd = strategy.position_size * close * (sellL2_pct / 100)\r\n    label.new(bar_index, high, \"SELL L2\\nRisk: \" + riskStr + \"\\n~$\" + str.tostring(usd, \"#,###\"), style=label.style_label_down, color=color.orange, textcolor=color.white, yloc=yloc.abovebar)\r\n\r\nif sell3Cond\r\n    usd = strategy.position_size * close\r\n    label.new(bar_index, high, \"SELL L3 EXIT\\nRisk: \" + riskStr + \"\\n~$\" + str.tostring(usd, \"#,###\"), style=label.style_label_down, color=color.maroon, textcolor=color.white, yloc=yloc.abovebar)\r\n\r\n// â”€â”€ RISK PLOT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nplot(riskMetric, \"Risk Metric\", color=color.blue, linewidth=2)\r\nhline(buyL3_thresh, \"Buy L3\", color=color.green)\r\nhline(buyL2_thresh, \"Buy L2\", color=color.lime)\r\nhline(buyL1_thresh, \"Buy L1\", color=color.yellow)\r\nhline(sellL1_thresh, \"Sell L1\", color=color.orange)\r\nhline(sellL2_thresh, \"Sell L2\", color=color.red)\r\nhline(sellL3_thresh, \"Sell L3\", color=color.maroon)\r\n\r\n"
  },
  {
    "url": "5XDDPulh",
    "name": "Wavelet Alligator â€“ Separate Entry/Exit Experts & Wavelets-V2",
    "description": "\nWavelet Alligator â€“ Strategy Explanation & How to Use\n\n1. Concept Overview\nThe Wavelet Alligator strategy combines:\n- Wavelet transforms (Daubechies, Haar, Symlet, Mexican Hat, Morlet)\n- Fractional calculus kernels: Caputo-Fabrizio (CF) and Atangana-Baleanu (AB)\n- Three-layer â€œalligator-likeâ€ wavelet smoothing (soft â†’ medium â†’ strong)\n- Expert-based entry/exit routing (RAW, CF, AB, or Majority vote)\n- Independent wavelets for ENTRY and EXIT\n- Main trend defined by AB wavelet ordering\n\nThis creates a multi-structure, multi-kernel trend engine capable of capturing extended moves with high signal quality.\n\n2. Wavelet Alligator Structure\nEach source (RAW, CF, AB) is transformed into three wavelet layers:\nSoft = fastest reaction\nMedium = mid smoothing\nStrong = trend backbone\n\nWavelets:\n- Daubechies: stable trend\n- Haar: fast impulse detection\n- Symlet: balanced\n- Mexican Hat: curvature and reversal detection\n- Morlet: cyclic, oscillatory\n\n3. Entry Logic\nLong entry occurs when:\n- AB wavelet shows bullish structure (soft > medium > strong, medium rising)\n- Selected entry expert approves (RAW / CF / AB / Majority)\n- Wavelet condition: soft > strong AND medium crosses above strong\n\n4. Exit Logic\nExit is independent from entry:\n- Controlled by chosen exit expert\n- Wavelet reversal condition: soft < strong AND medium crosses below strong\n- Forced exit when AB trend turns neutral or bearish\n\n5. Background Color (Regime)\n- Green: bullish AB regime\n- Red: bearish AB regime\n- Gray: neutral/transition\n\n6. How to Use\nStep 1 â€“ Choose entry wavelet\nDaubechies: stable trend\nHaar: breakout scalping\nMexican Hat: early reversals\nSymlet: balanced\nMorlet: cyclic markets\n\nStep 2 â€“ Choose exit wavelet\nMexican Hat: best precision\nDaubechies: smooth exits\nHaar: aggressive exits\n\nStep 3 â€“ Select entry/exit experts\nCF only â€“ fast fractional trend\nAB only â€“ stable long-memory trend\nRAW only â€“ pure price structure\nMajority â€“ safest, noise-filtered\n\nStep 4 â€“ Run the strategy\nEntries occur only during AB bullish trend.\nExits occur on wavelet reversal or AB trend failure.\n\n7. Why This Strategy Works\nIt fuses:\n- Fractional calculus (memory)\n- Wavelets (shape/curvature)\n- Alligator ordering (trend hierarchy)\n\nResult: high-quality entries, strong trend holding, noise-resistant signals.\n\n",
    "image_url": "5XDDPulh",
    "author": "wojlucz",
    "likes": 25,
    "type": "strategy",
    "created": "2025-11-22",
    "updated": "2025-11-22",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// Â© wojlucz\n\n//@version=5\nstrategy(\"Wavelet Alligator â€“ Separate Entry/Exit Experts & Wavelets-V2\",\n     overlay = true,\n     initial_capital = 10000,\n     default_qty_type = strategy.percent_of_equity,\n     default_qty_value = 100,\n     pyramiding = 0,\n     process_orders_on_close = true)\n\n// â”€ SETTINGS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nsrc               = input.source(close, \"Base source (price)\")\nshowRAW_Alligator = input.bool(false, \"Show RAW Alligator (entry)\")\nshowCF_Alligator  = input.bool(true,  \"Show CF Alligator (entry)\")\nshowAB_Alligator  = input.bool(true,  \"Show AB Alligator (entry)\")\nshowBgState       = input.bool(true,  \"Show background by AB trend (main trend)\")\n\n// Wavelet for ENTRY and EXIT (independent)\nentryWaveletType = input.string(\"Daubechies\", \"Wavelet for entry\",\n     options = [\"Daubechies\",\"Haar\",\"Symlet\",\"Mexican Hat\",\"Morlet\"])\nexitWaveletType  = input.string(\"Daubechies\", \"Wavelet for exit\",\n     options = [\"Daubechies\",\"Haar\",\"Symlet\",\"Mexican Hat\",\"Morlet\"])\n\n// Expert for entry\nentryExpertMode = input.string(\"CF only\", \"Entry expert\",\n     options = [\"RAW only\",\"CF only\",\"AB only\",\"Majority (N of 3)\"])\n\n// Expert for exit (can be the same or different)\nexitExpertMode  = input.string(\"Same as entry\", \"Exit expert\",\n     options = [\"Same as entry\",\"RAW only\",\"CF only\",\"AB only\",\"Majority (N of 3)\"])\n\n// MoE parameters (used only in Majority mode)\nminExpertsEnter = input.int(2, \"Min experts for entry (MoE)\", minval = 1, maxval = 3)\nminExpertsExit  = input.int(2, \"Min experts for exit (MoE)\",  minval = 1, maxval = 3)\n\n// CF / AB kernel parameters\ncfLength = input.int(50, \"CF: memory length\", minval = 2, maxval = 300)\ncfAlpha  = input.float(0.5, \"CF: alpha (0â€“1)\", minval = 0.01, maxval = 0.99)\n\nabLength = input.int(50, \"AB: memory length\", minval = 2, maxval = 300)\nabAlpha  = input.float(0.5, \"AB: alpha (0â€“1)\", minval = 0.01, maxval = 0.99)\n\n// â”€ CF AND AB KERNELS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nf_cf_kernel(series float x, float a, int L) =>\n    float num = 0.0\n    float wsum = 0.0\n    float lambdaCF = a / (1.0 - a + 1e-6)\n    for i = 0 to L - 1\n        float v = x[i]\n        if not na(v)\n            float w = math.exp(-lambdaCF * i)\n            num  += w * v\n            wsum += w\n    wsum != 0.0 ? num / wsum : x\n\nf_ab_kernel(series float x, float a, int L) =>\n    float num = 0.0\n    float wsum = 0.0\n    float lambdaAB = a\n    for i = 0 to L - 1\n        float v = x[i]\n        if not na(v)\n            float t = i == 0 ? 0.0 : math.pow(i, a)\n            float w = math.exp(-lambdaAB * t)\n            num  += w * v\n            wsum += w\n    wsum != 0.0 ? num / wsum : x\n\nraw_src = src\ncf_src  = f_cf_kernel(src, cfAlpha, cfLength)\nab_src  = f_ab_kernel(src, abAlpha, abLength)\n\n// â”€ WAVELETS â€“ LOW-PASS / CURVATURE APPROX â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nf_wavelet_lp(series float s, string wType) =>\n    float out = na\n    if wType == \"Daubechies\"\n        float k0 = -0.03125\n        float k1 = -0.00000000003\n        float k2 =  0.28125\n        float k3 =  0.5\n        float k4 =  0.28125\n        float k5 = -0.00000000003\n        float k6 = -0.03125\n        out := k0*s + k1*s[1] + k2*s[2] + k3*s[3] + k4*s[4] + k5*s[5] + k6*s[6]\n    else if wType == \"Haar\"\n        // Simple step wavelet â€“ fast impulsive filter\n        out := 0.5 * (s + s[1])\n    else if wType == \"Symlet\"\n        // Smoother, symmetric filter (5-tap approximation)\n        float c0 = -0.125\n        float c1 =  0.25\n        float c2 =  0.75\n        float c3 =  0.25\n        float c4 = -0.125\n        out := c0*s[4] + c1*s[3] + c2*s[2] + c3*s[1] + c4*s\n    else if wType == \"Mexican Hat\"\n        // Approx second derivative (peak / curvature detector)\n        out := s - 2.0*s[1] + s[2]\n    else\n        // Morlet â€“ soft, slightly cyclic low-pass (simplified)\n        out := (s + 2.0*s[1] + s[2]) / 4.0\n    out\n\n// â”€ ENTRY ALLIGATORS (ENTRY WAVELET) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// RAW entry\nraw_e_soft   = f_wavelet_lp(raw_src, entryWaveletType)\nraw_e_medium = f_wavelet_lp(raw_e_soft, entryWaveletType)\nraw_e_strong = f_wavelet_lp(raw_e_medium, entryWaveletType)\n\n// CF entry\ncf_e_soft   = f_wavelet_lp(cf_src, entryWaveletType)\ncf_e_medium = f_wavelet_lp(cf_e_soft, entryWaveletType)\ncf_e_strong = f_wavelet_lp(cf_e_medium, entryWaveletType)\n\n// AB entry\nab_e_soft   = f_wavelet_lp(ab_src, entryWaveletType)\nab_e_medium = f_wavelet_lp(ab_e_soft, entryWaveletType)\nab_e_strong = f_wavelet_lp(ab_e_medium, entryWaveletType)\n\n// â”€ EXIT ALLIGATORS (EXIT WAVELET) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// RAW exit\nraw_x_soft   = f_wavelet_lp(raw_src, exitWaveletType)\nraw_x_medium = f_wavelet_lp(raw_x_soft, exitWaveletType)\nraw_x_strong = f_wavelet_lp(raw_x_medium, exitWaveletType)\n\n// CF exit\ncf_x_soft   = f_wavelet_lp(cf_src, exitWaveletType)\ncf_x_medium = f_wavelet_lp(cf_x_soft, exitWaveletType)\ncf_x_strong = f_wavelet_lp(cf_x_medium, exitWaveletType)\n\n// AB exit\nab_x_soft   = f_wavelet_lp(ab_src, exitWaveletType)\nab_x_medium = f_wavelet_lp(ab_x_soft, exitWaveletType)\nab_x_strong = f_wavelet_lp(ab_x_medium, exitWaveletType)\n\n// â”€ MAIN TREND = AB (ENTRY WAVELET) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nbullOrderAB = ab_e_soft > ab_e_medium and ab_e_medium > ab_e_strong\nbearOrderAB = ab_e_soft < ab_e_medium and ab_e_medium < ab_e_strong\ntrendUpAB   = ab_e_medium > ab_e_medium[1]\n\nalligatorBullAB = bullOrderAB and trendUpAB\n\n// â”€ ENTRY SIGNALS (ENTRY WAVELET) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// Rule: long: soft > strong AND crossover(medium, strong)\nlongSignalRAW_entry = raw_e_soft > raw_e_strong and ta.crossover(raw_e_medium, raw_e_strong)\nlongSignalCF_entry  = cf_e_soft  > cf_e_strong  and ta.crossover(cf_e_medium,  cf_e_strong)\nlongSignalAB_entry  = ab_e_soft  > ab_e_strong  and ta.crossover(ab_e_medium,  ab_e_strong)\n\n// MoE for entry\nlongCountEntry = (longSignalRAW_entry ? 1 : 0) + (longSignalCF_entry ? 1 : 0) + (longSignalAB_entry ? 1 : 0)\n\n// â”€ EXIT SIGNALS (EXIT WAVELET) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// Rule: exit: soft < strong AND crossunder(medium, strong)\nexitSignalRAW_exit = raw_x_soft < raw_x_strong and ta.crossunder(raw_x_medium, raw_x_strong)\nexitSignalCF_exit  = cf_x_soft  < cf_x_strong  and ta.crossunder(cf_x_medium,  cf_x_strong)\nexitSignalAB_exit  = ab_x_soft  < ab_x_strong  and ta.crossunder(ab_x_medium,  ab_x_strong)\n\n// MoE for exit\nexitCountExit = (exitSignalRAW_exit ? 1 : 0) + (exitSignalCF_exit ? 1 : 0) + (exitSignalAB_exit ? 1 : 0)\n\n// â”€ EXPERT ROUTING â€“ ENTRY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nbool entrySignal = false\n\nif entryExpertMode == \"RAW only\"\n    entrySignal := longSignalRAW_entry\nelse if entryExpertMode == \"CF only\"\n    entrySignal := longSignalCF_entry\nelse if entryExpertMode == \"AB only\"\n    entrySignal := longSignalAB_entry\nelse\n    entrySignal := longCountEntry >= minExpertsEnter  // Majority (N of 3)\n\n// â”€ EXPERT ROUTING â€“ EXIT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nbool exitSignal = false\nstring effectiveExitMode = exitExpertMode == \"Same as entry\" ? entryExpertMode : exitExpertMode\n\nif effectiveExitMode == \"RAW only\"\n    exitSignal := exitSignalRAW_exit\nelse if effectiveExitMode == \"CF only\"\n    exitSignal := exitSignalCF_exit\nelse if effectiveExitMode == \"AB only\"\n    exitSignal := exitSignalAB_exit\nelse\n    exitSignal := exitCountExit >= minExpertsExit      // Majority (N of 3)\n\n// â”€ TRADE LOGIC â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// Entry: AB bull trend + selected expert entry signal\nlongEntry = alligatorBullAB and entrySignal and strategy.position_size <= 0\n\n// Exit: selected expert exit signal OR end of AB bull trend\nlongExit = strategy.position_size > 0 and (exitSignal or not alligatorBullAB)\n\n// â”€ ORDERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nif longEntry\n    strategy.entry(\"Long\", strategy.long)\n\nif longExit\n    strategy.close(\"Long\")\n\n// â”€ VISUALIZATION (ENTRY WAVELET) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// RAW (entry wavelet)\nplot(showRAW_Alligator ? raw_e_soft   : na, \"RAW soft (entry)\",   color=color.new(color.blue,60),   linewidth=1)\nplot(showRAW_Alligator ? raw_e_medium : na, \"RAW medium (entry)\", color=color.new(color.blue,20),   linewidth=2)\nplot(showRAW_Alligator ? raw_e_strong : na, \"RAW strong (entry)\", color=color.new(color.navy,  0),  linewidth=2)\n\n// CF (entry wavelet)\nplot(showCF_Alligator ? cf_e_soft   : na, \"CF soft (entry)\",   color=color.new(color.teal,0),   linewidth=1)\nplot(showCF_Alligator ? cf_e_medium : na, \"CF medium (entry)\", color=color.new(color.orange,0), linewidth=2)\nplot(showCF_Alligator ? cf_e_strong : na, \"CF strong (entry)\", color=color.new(color.purple,0), linewidth=2)\n\n// AB (entry wavelet)\nplot(showAB_Alligator ? ab_e_soft   : na, \"AB soft (entry)\",   color=color.new(color.teal,70),   linewidth=1)\nplot(showAB_Alligator ? ab_e_medium : na, \"AB medium (entry)\", color=color.new(color.orange,70), linewidth=2)\nplot(showAB_Alligator ? ab_e_strong : na, \"AB strong (entry)\", color=color.new(color.purple,70), linewidth=2)\n\n// Entry / exit markers\nplotshape(longEntry, title=\"Entry\",  style=shape.triangleup,   location=location.belowbar, color=color.lime, size=size.tiny)\nplotshape(longExit,  title=\"Exit\",   style=shape.triangledown, location=location.abovebar, color=color.red,  size=size.tiny)\n\n// Background = AB trend state (entry wavelet)\nbgcolor(showBgState ? (bullOrderAB ? color.new(color.green,85) : bearOrderAB ? color.new(color.red,85) : color.new(color.gray,90)) : na)"
  },
  {
    "url": "5jjbawKL-HPAS-mean-reversion-strategy-tester",
    "name": "HPAS mean reversion strategy tester",
    "description": "Takes Krown HPAS values hardcoded and simulates longs and short with configurable standard deviation multiplier TP/SL. Best used on lower timeframes",
    "image_url": "5jjbawKL",
    "author": "nigelmcintyre",
    "likes": 7,
    "type": "strategy",
    "created": "2025-11-22",
    "updated": "2025-11-22",
    "source": "//@version=5\r\nstrategy(\"HPAS mean reversion strategy\", overlay=true, pyramiding=0, process_orders_on_close=true)\r\n\r\n// === CONFIGURABLE MULTIPLIERS ===\r\nlong_tp_mult   = input.float(1.0, \"Long TP StdDev Multiplier\", step=0.1, minval=0.1)\r\nlong_sl_mult   = input.float(1.0, \"Long SL StdDev Multiplier\", step=0.1, minval=0.1)\r\nshort_tp_mult  = input.float(1.0, \"Short TP StdDev Multiplier\", step=0.1, minval=0.1)\r\nshort_sl_mult  = input.float(1.0, \"Short SL StdDev Multiplier\", step=0.1, minval=0.1)\r\n\r\n// ---- HARDCODED TABLE VALUES by weekday (0=Sunday, ... 6=Saturday) ----\r\ngain_avg     = array.from(1.59, 2.34, 1.98, 2.57, 1.91, 2.03, 0.74)\r\ngain_stdev   = array.from(1.68, 2.40, 1.55, 2.34, 1.84, 1.89, 0.84)\r\nloss_avg_abs = array.from(1.22, 1.92, 1.78, 1.67, 1.86, 1.78, 0.66)\r\nloss_stdev   = array.from(1.32, 1.81, 1.71, 1.29, 1.54, 1.65, 0.98)\r\n\r\n// Day-of-week: Sunday=0, ..., Saturday=6\r\nd = dayofweek - 1\r\nif d < 0\r\n    d := 6\r\n\r\n// Fetch daily table values\r\ntoday_gain    = array.get(gain_avg, d)\r\ntoday_gain_sd = array.get(gain_stdev, d)\r\ntoday_loss    = array.get(loss_avg_abs, d)\r\ntoday_loss_sd = array.get(loss_stdev, d)\r\n\r\n// --- Sticky daily open for each UTC day ---\r\nvar float daily_open = na\r\nif ta.change(time(\"D\"))\r\n    daily_open := open\r\ntoday_open = na(daily_open) ? open : daily_open\r\n\r\n// --- Entry and TP/SL calculations using stdev_mult ---\r\nlong_entry  = today_open * (1 - today_loss / 100)\r\nshort_entry = today_open * (1 + today_gain / 100)\r\nlong_tp     = long_entry * (1 + long_tp_mult * today_loss_sd / 100)\r\nlong_sl     = long_entry * (1 - long_sl_mult * today_loss_sd / 100)\r\nshort_tp    = short_entry * (1 - short_tp_mult * today_gain_sd / 100)\r\nshort_sl    = short_entry * (1 + short_sl_mult * today_gain_sd / 100)\r\n\r\n// --- One limit order per day logic ---\r\nyear_   = year(time)\r\nmonth_  = month(time)\r\nday_    = dayofmonth(time)\r\ntoday_key = year_ * 10000 + month_ * 100 + day_\r\n\r\nvar int last_trade_key = na\r\ncan_trade_today = na(last_trade_key) or today_key != last_trade_key\r\n\r\n// --- Place independent limit orders if flat and it's a new day ---\r\nif can_trade_today and strategy.position_size == 0\r\n    strategy.order(\"Long\", strategy.long, limit=long_entry, comment=\"Long Limit\")\r\n    strategy.order(\"Short\", strategy.short, limit=short_entry, comment=\"Short Limit\")\r\n    last_trade_key := today_key\r\n\r\n// --- Exits by TP/SL (at your level) ---\r\nif strategy.position_size > 0\r\n    strategy.exit(\"Long Exit\", \"Long\", limit=long_tp, stop=long_sl, comment=\"Long TP/SL\")\r\nif strategy.position_size < 0\r\n    strategy.exit(\"Short Exit\", \"Short\", limit=short_tp, stop=short_sl, comment=\"Short TP/SL\")\r\n\r\n// --- EOD robust close: always flat on first bar of new UTC day, any timeframe ---\r\nif ta.change(time(\"D\")) and strategy.position_size != 0\r\n    strategy.close_all(comment=\"EOD Close\")\r\n\r\n// --- Plot for visualization ---\r\nplot(long_entry,  \"Long Entry\",  color=color.green)\r\nplot(long_tp,     \"Long TP\",     color=color.aqua)\r\nplot(long_sl,     \"Long SL\",     color=color.maroon)\r\nplot(short_entry, \"Short Entry\", color=color.red)\r\nplot(short_tp,    \"Short TP\",    color=color.orange)\r\nplot(short_sl,    \"Short SL\",    color=color.purple)\r\n"
  },
  {
    "url": "PhbzRBYo",
    "name": "Daily vs Intraday Candle Match Strategy",
    "description": "ê³ ì£  í›ˆì˜ ì°¨íŠ¸ê³µë¶€ë°©\nGojo Hoonâ€™s Trading Room\n\nì „ì¼ ì¢…ê°€ ëŒ€ë¹„ í˜„ìž¬ ì¼ë´‰ ë°©í–¥ê³¼ ì‹œê°„ë´‰ ë°©í–¥ì´ ì¼ì¹˜í•  ë•Œ ì§„ìž…\nTrade when current daily direction (vs. previous close) matches the hourly/15-minute candle direction.",
    "image_url": "PhbzRBYo",
    "author": "Lab106",
    "likes": 14,
    "type": "strategy",
    "created": "2025-11-22",
    "updated": "2025-11-22",
    "source": "//@version=5\r\nstrategy(\"Daily vs Intraday Candle Match Strategy\", overlay=true, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=100)\r\n\r\n// ===== íŒŒë¼ë¯¸í„° ì„¤ì • =====\r\nentry_timeframe = input.string(\"60\", \"ì§„ìž… íƒ€ìž„í”„ë ˆìž„\", options=[\"15\", \"60\"])\r\nuse_stop_loss = input.bool(true, \"ì†ì ˆ ì‚¬ìš©\")\r\nstop_loss_pct = input.float(2.0, \"ì†ì ˆ %\", minval=0.1, maxval=10.0)\r\nuse_take_profit = input.bool(true, \"ìµì ˆ ì‚¬ìš©\")\r\ntake_profit_pct = input.float(4.0, \"ìµì ˆ %\", minval=0.1, maxval=20.0)\r\nclose_eod = input.bool(true, \"ìž¥ ë§ˆê° ì „ ì²­ì‚° (14:50)\")\r\n\r\n// ===== ì‹œê°„ ì„¤ì • =====\r\nkst_timezone = \"Asia/Seoul\"\r\nkst_hour = hour(time, kst_timezone)\r\nkst_minute = minute(time, kst_timezone)\r\nkst_dayofweek = dayofweek(time, kst_timezone)\r\n\r\n// í‰ì¼ ì²´í¬\r\nis_trading_day = kst_dayofweek >= 2 and kst_dayofweek <= 6\r\nis_close_time = kst_hour == 14 and kst_minute >= 50\r\n\r\n// ===== ì¼ë´‰ ë°©í–¥ ê³„ì‚° (ì „ë‚  ì¢…ê°€ vs í˜„ìž¬) =====\r\nvar float prev_day_close = na\r\nvar bool daily_bullish = na\r\nvar bool traded_today = false\r\n\r\n// ìƒˆë¡œìš´ ë‚  ì‹œìž‘ (9ì‹œ)\r\nnew_day = ta.change(dayofmonth(time, kst_timezone))\r\nif new_day and kst_hour >= 9\r\n    prev_day_close := close[1]\r\n    traded_today := false\r\n\r\n// ìž¥ ì‹œìž‘ í›„ ì¼ë´‰ ë°©í–¥ ì§€ì† ì—…ë°ì´íŠ¸\r\nif not na(prev_day_close)\r\n    daily_bullish := close > prev_day_close\r\n\r\n// ===== ì§„ìž… íƒ€ìž„í”„ë ˆìž„ ìº”ë“¤ ë°©í–¥ =====\r\nis_entry_candle_close = false\r\ncandle_bullish = close > open\r\n\r\n// 1ì‹œê°„ë´‰: ë§¤ì‹œ ì •ê°\r\nif entry_timeframe == \"60\"\r\n    is_entry_candle_close := kst_minute == 0 and kst_hour > 9\r\n\r\n// 15ë¶„ë´‰: 00, 15, 30, 45ë¶„\r\nif entry_timeframe == \"15\"\r\n    is_entry_candle_close := (kst_minute == 0 or kst_minute == 15 or kst_minute == 30 or kst_minute == 45) and kst_hour >= 9\r\n\r\n// ===== ì§„ìž… ì¡°ê±´: ì¼ë´‰ ë°©í–¥ == íƒ€ìž„í”„ë ˆìž„ ìº”ë“¤ ë°©í–¥ =====\r\nlong_signal = is_trading_day and not na(daily_bullish) and daily_bullish and candle_bullish and is_entry_candle_close and not traded_today and kst_hour < 14\r\nshort_signal = is_trading_day and not na(daily_bullish) and not daily_bullish and not candle_bullish and is_entry_candle_close and not traded_today and kst_hour < 14\r\n\r\n// ===== í¬ì§€ì…˜ ì§„ìž… =====\r\nif long_signal and strategy.position_size == 0\r\n    strategy.entry(\"Long\", strategy.long, comment=\"ì¼ë´‰â†‘ + \" + entry_timeframe + \"Mâ†‘\")\r\n    traded_today := true\r\n    if use_stop_loss\r\n        strategy.exit(\"Long Exit\", \"Long\", stop=close * (1 - stop_loss_pct/100), limit=use_take_profit ? close * (1 + take_profit_pct/100) : na, comment=\"SL/TP\")\r\n\r\nif short_signal and strategy.position_size == 0\r\n    strategy.entry(\"Short\", strategy.short, comment=\"ì¼ë´‰â†“ + \" + entry_timeframe + \"Mâ†“\")\r\n    traded_today := true\r\n    if use_stop_loss\r\n        strategy.exit(\"Short Exit\", \"Short\", stop=close * (1 + stop_loss_pct/100), limit=use_take_profit ? close * (1 - take_profit_pct/100) : na, comment=\"SL/TP\")\r\n\r\n// ===== ìž¥ ë§ˆê° ì²­ì‚° =====\r\nif close_eod and is_close_time and strategy.position_size != 0\r\n    strategy.close_all(comment=\"ìž¥ ë§ˆê° ì²­ì‚°\")\r\n\r\n// ===== ë‹¤ìŒ ë‚  ì´ˆê¸°í™” =====\r\nif new_day\r\n    if strategy.position_size != 0\r\n        strategy.close_all(comment=\"ì¼ë´‰ ì¢…ë£Œ ì²­ì‚°\")\r\n\r\n// ===== ì‹œê°í™” =====\r\n// ì¼ë´‰ ë°©í–¥ ë°°ê²½ìƒ‰\r\nbgcolor(not na(daily_bullish) and daily_bullish ? color.new(color.green, 97) : not na(daily_bullish) ? color.new(color.red, 97) : na, title=\"ì¼ë´‰ ë°©í–¥\")\r\n\r\n// ì§„ìž… ì‹ í˜¸\r\nplotshape(long_signal, \"ë¡± ì§„ìž…\", shape.triangleup, location.belowbar, color.new(color.green, 0), size=size.small)\r\nplotshape(short_signal, \"ìˆ ì§„ìž…\", shape.triangledown, location.abovebar, color.new(color.red, 0), size=size.small)\r\n\r\n// ì „ë‚  ì¢…ê°€ ë¼ì¸\r\nplot(prev_day_close, \"ì „ë‚  ì¢…ê°€\", color=color.new(color.blue, 0), linewidth=2, style=plot.style_linebr)\r\n\r\n// ===== ì„±ê³¼ í…Œì´ë¸” =====\r\nvar table perf_table = table.new(position.bottom_right, 2, 8, border_width=1)\r\n\r\nif barstate.islast\r\n    table.cell(perf_table, 0, 0, \"ê±°ëž˜ì¼\", bgcolor=color.new(color.gray, 70), text_color=color.white, text_size=size.small)\r\n    table.cell(perf_table, 1, 0, is_trading_day ? \"í‰ì¼ âœ“\" : \"ì£¼ë§ âœ—\", bgcolor=is_trading_day ? color.new(color.green, 70) : color.new(color.red, 70), text_color=color.white, text_size=size.small)\r\n    \r\n    table.cell(perf_table, 0, 1, \"ì „ë‚  ì¢…ê°€\", bgcolor=color.new(color.gray, 70), text_color=color.white, text_size=size.small)\r\n    table.cell(perf_table, 1, 1, na(prev_day_close) ? \"N/A\" : str.tostring(math.round(prev_day_close, 2)), text_color=color.white, text_size=size.small)\r\n    \r\n    table.cell(perf_table, 0, 2, \"ì¼ë´‰ ë°©í–¥\", bgcolor=color.new(color.gray, 70), text_color=color.white, text_size=size.small)\r\n    table.cell(perf_table, 1, 2, na(daily_bullish) ? \"ëŒ€ê¸°\" : (daily_bullish ? \"ì–‘ â–²\" : \"ìŒ â–¼\"), bgcolor=na(daily_bullish) ? color.new(color.gray, 70) : (daily_bullish ? color.new(color.green, 70) : color.new(color.red, 70)), text_color=color.white, text_size=size.small)\r\n    \r\n    table.cell(perf_table, 0, 3, \"ì§„ìž… TF\", bgcolor=color.new(color.gray, 70), text_color=color.white, text_size=size.small)\r\n    table.cell(perf_table, 1, 3, entry_timeframe + \"ë¶„\", text_color=color.white, text_size=size.small)\r\n    \r\n    table.cell(perf_table, 0, 4, \"ì˜¤ëŠ˜ ê±°ëž˜\", bgcolor=color.new(color.gray, 70), text_color=color.white, text_size=size.small)\r\n    table.cell(perf_table, 1, 4, traded_today ? \"ì™„ë£Œ\" : \"ëŒ€ê¸°\", bgcolor=traded_today ? color.new(color.blue, 70) : color.new(color.gray, 70), text_color=color.white, text_size=size.small)\r\n    \r\n    table.cell(perf_table, 0, 5, \"ì´ ê±°ëž˜\", bgcolor=color.new(color.blue, 80), text_color=color.white, text_size=size.small)\r\n    table.cell(perf_table, 1, 5, str.tostring(strategy.closedtrades), text_color=color.white, text_size=size.small)\r\n    \r\n    table.cell(perf_table, 0, 6, \"ìŠ¹ë¥ \", bgcolor=color.new(color.blue, 80), text_color=color.white, text_size=size.small)\r\n    win_rate = strategy.closedtrades > 0 ? strategy.wintrades / strategy.closedtrades * 100 : 0\r\n    table.cell(perf_table, 1, 6, str.tostring(math.round(win_rate, 2)) + \"%\", text_color=win_rate >= 50 ? color.lime : color.orange, text_size=size.small)\r\n    \r\n    table.cell(perf_table, 0, 7, \"ìˆ˜ìµë¥ \", bgcolor=color.new(color.blue, 80), text_color=color.white, text_size=size.small)\r\n    total_return = strategy.initial_capital > 0 ? (strategy.netprofit / strategy.initial_capital) * 100 : 0\r\n    table.cell(perf_table, 1, 7, str.tostring(math.round(total_return, 2)) + \"%\", text_color=total_return > 0 ? color.lime : color.red, text_size=size.small)"
  },
  {
    "url": "MKmgZG1P",
    "name": "Kill Zone Strategy - Exact Match",
    "description": "ê³ ì£  í›ˆì˜ ì°¨íŠ¸ê³µë¶€ë°©\nGojo Hoonâ€™s Trading Room\n\nKill Zone ì‹œê°„ëŒ€ ë°©í–¥ì„±ê³¼ ì¼ì¤‘ ì¶”ì„¸ì˜ ìƒê´€ê´€ê³„\nThe 9â€“10 AM Kill Zone candle on the KOSPI chart determines the dayâ€™s long or short trading direction.ï»¿",
    "image_url": "MKmgZG1P",
    "author": "Lab106",
    "likes": 12,
    "type": "strategy",
    "created": "2025-11-22",
    "updated": "2025-11-22",
    "source": "//@version=5\r\nstrategy(\"Kill Zone Strategy - Exact Match\", \r\n         overlay=true, \r\n         initial_capital=10000,\r\n         default_qty_type=strategy.percent_of_equity,\r\n         default_qty_value=100,\r\n         commission_type=strategy.commission.percent,\r\n         commission_value=0.04)\r\n\r\n// ============================================================================\r\n// ì„¤ì •\r\n// ============================================================================\r\ni_timezone = input.string(\"Asia/Seoul\", \"Timezone\")\r\ni_entry_type = input.string(\"1H Close\", \"Entry Price\", options=[\"1H Close\", \"15M Close\"])\r\ni_close_eod = input.bool(true, \"Close at End of Day\")\r\ni_eod_hour = input.int(15, \"EOD Hour\", minval=0, maxval=23)\r\ni_show_labels = input.bool(true, \"Show Entry/Exit Labels\")\r\n\r\n// ============================================================================\r\n// Kill Zone 1ì‹œê°„ë´‰ ë°ì´í„° ê°€ì ¸ì˜¤ê¸° (ì •í™•ížˆ 9-10ì‹œ)\r\n// ============================================================================\r\n// request.securityë¡œ 1ì‹œê°„ë´‰ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°\r\n[h1_time, h1_open, h1_high, h1_low, h1_close] = request.security(\r\n     syminfo.tickerid, \r\n     \"60\", \r\n     [time, open, high, low, close],\r\n     lookahead=barmerge.lookahead_off)\r\n\r\n// 15ë¶„ë´‰ ë°ì´í„°\r\n[m15_close] = request.security(\r\n     syminfo.tickerid, \r\n     \"15\", \r\n     [close],\r\n     lookahead=barmerge.lookahead_off)\r\n\r\n// ============================================================================\r\n// ì‹œê°„ í™•ì¸\r\n// ============================================================================\r\nget_hour(t) =>\r\n    hour(t, i_timezone)\r\n\r\n// í˜„ìž¬ ìº”ë“¤ì´ Kill Zone ì‹œê°„ëŒ€(9ì‹œ)ì¸ì§€ í™•ì¸\r\nis_killzone_hour(t) =>\r\n    h = get_hour(t)\r\n    h == 9\r\n\r\n// 10ì‹œ ì²« ìº”ë“¤ ê°ì§€ (ì§„ìž… ì‹œì )\r\nis_entry_time(t) =>\r\n    h = get_hour(t)\r\n    h == 10\r\n\r\n// ì²­ì‚° ì‹œê°„\r\nis_exit_time(t) =>\r\n    h = get_hour(t)\r\n    h >= i_eod_hour\r\n\r\n// ============================================================================\r\n// Kill Zone ë°©í–¥ íŒë‹¨\r\n// ============================================================================\r\nvar int kz_direction = 0  // 1=long, -1=short, 0=neutral\r\nvar float entry_price = 0.0\r\nvar bool position_opened = false\r\n\r\n// ë§¤ì¼ ì´ˆê¸°í™”\r\nif ta.change(dayofmonth(time, i_timezone))\r\n    kz_direction := 0\r\n    entry_price := 0.0\r\n    position_opened := false\r\n\r\n// Kill Zone 1ì‹œê°„ë´‰ì´ ì™„ì„±ë˜ëŠ” ì‹œì  (10ì‹œ ì²« ìº”ë“¤)\r\nif is_entry_time(time) and is_entry_time(time[1]) == false\r\n    // ì´ì „ 1ì‹œê°„ë´‰(9ì‹œ)ì˜ ë°ì´í„° ì‚¬ìš©\r\n    prev_h1_open = h1_open[1]\r\n    prev_h1_close = h1_close[1]\r\n    \r\n    // ë°©í–¥ ê²°ì •\r\n    if prev_h1_close > prev_h1_open\r\n        kz_direction := 1  // ì–‘ë´‰ = LONG\r\n    else if prev_h1_close < prev_h1_open\r\n        kz_direction := -1  // ìŒë´‰ = SHORT\r\n    \r\n    // ì§„ìž… ê°€ê²© ê²°ì •\r\n    if i_entry_type == \"1H Close\"\r\n        entry_price := prev_h1_close  // 9ì‹œ 1ì‹œê°„ë´‰ ì¢…ê°€\r\n    else\r\n        entry_price := m15_close[1]   // 9:45 15ë¶„ë´‰ ì¢…ê°€\r\n    \r\n    // ë””ë²„ê·¸ ë¼ë²¨\r\n    if i_show_labels\r\n        dir_text = kz_direction == 1 ? \"LONG\" : kz_direction == -1 ? \"SHORT\" : \"NEUTRAL\"\r\n        label.new(bar_index, high, \r\n                 \"KZ: \" + dir_text + \"\\nì§„ìž…ê°€: \" + str.tostring(entry_price, \"#.##\"),\r\n                 color=kz_direction == 1 ? color.green : color.red,\r\n                 textcolor=color.white,\r\n                 style=label.style_label_down,\r\n                 size=size.small)\r\n\r\n// ============================================================================\r\n// ì§„ìž… ì¡°ê±´\r\n// ============================================================================\r\nlong_condition = kz_direction == 1 and not position_opened and strategy.position_size == 0\r\nshort_condition = kz_direction == -1 and not position_opened and strategy.position_size == 0\r\n\r\n// ============================================================================\r\n// ì£¼ë¬¸ ì‹¤í–‰\r\n// ============================================================================\r\nif long_condition\r\n    strategy.entry(\"Long\", strategy.long, comment=\"KZ Long @ \" + str.tostring(entry_price))\r\n    position_opened := true\r\n    \r\n    if i_show_labels\r\n        label.new(bar_index, low,\r\n                 \"âœ“ LONG Entry\\n\" + str.tostring(close, \"#.##\"),\r\n                 color=color.new(color.green, 0),\r\n                 textcolor=color.white,\r\n                 style=label.style_label_up,\r\n                 size=size.normal)\r\n\r\nif short_condition\r\n    strategy.entry(\"Short\", strategy.short, comment=\"KZ Short @ \" + str.tostring(entry_price))\r\n    position_opened := true\r\n    \r\n    if i_show_labels\r\n        label.new(bar_index, high,\r\n                 \"âœ“ SHORT Entry\\n\" + str.tostring(close, \"#.##\"),\r\n                 color=color.new(color.red, 0),\r\n                 textcolor=color.white,\r\n                 style=label.style_label_down,\r\n                 size=size.normal)\r\n\r\n// ============================================================================\r\n// ì²­ì‚° (ë‹¹ì¼ ì¢…ê°€)\r\n// ============================================================================\r\nif i_close_eod and is_exit_time(time)\r\n    if strategy.position_size != 0\r\n        strategy.close_all(comment=\"EOD Close\")\r\n        \r\n        if i_show_labels\r\n            label.new(bar_index, close,\r\n                     \"EOD Close\\n\" + str.tostring(close, \"#.##\"),\r\n                     color=color.orange,\r\n                     textcolor=color.white,\r\n                     style=label.style_circle,\r\n                     size=size.small)\r\n\r\n// ============================================================================\r\n// ì‹œê°í™”\r\n// ============================================================================\r\n// Kill Zone ì‹œê°„ í•˜ì´ë¼ì´íŠ¸\r\nbgcolor(is_killzone_hour(time) ? color.new(color.yellow, 90) : na)\r\n\r\n// ============================================================================\r\n// í†µê³„ í…Œì´ë¸”\r\n// ============================================================================\r\nvar table stats = table.new(position.top_right, 2, 8, \r\n                           bgcolor=color.new(color.black, 85), \r\n                           border_width=1)\r\n\r\nif barstate.islast\r\n    table.cell(stats, 0, 0, \"Kill Zone Strategy\", text_size=size.normal, text_color=color.white)\r\n    table.merge_cells(stats, 0, 0, 1, 0)\r\n    \r\n    table.cell(stats, 0, 1, \"Entry Type\", text_color=color.gray, text_size=size.small)\r\n    table.cell(stats, 1, 1, i_entry_type, text_color=color.white, text_size=size.small)\r\n    \r\n    table.cell(stats, 0, 2, \"Total Trades\", text_color=color.gray, text_size=size.small)\r\n    table.cell(stats, 1, 2, str.tostring(strategy.closedtrades), text_color=color.white, text_size=size.small)\r\n    \r\n    table.cell(stats, 0, 3, \"Wins\", text_color=color.gray, text_size=size.small)\r\n    table.cell(stats, 1, 3, str.tostring(strategy.wintrades), text_color=color.green, text_size=size.small)\r\n    \r\n    table.cell(stats, 0, 4, \"Losses\", text_color=color.gray, text_size=size.small)\r\n    table.cell(stats, 1, 4, str.tostring(strategy.losstrades), text_color=color.red, text_size=size.small)\r\n    \r\n    table.cell(stats, 0, 5, \"Win Rate\", text_color=color.gray, text_size=size.small)\r\n    wr = strategy.closedtrades > 0 ? (strategy.wintrades / strategy.closedtrades) * 100 : 0\r\n    table.cell(stats, 1, 5, str.tostring(wr, \"#.#\") + \"%\", text_color=color.white, text_size=size.small)\r\n    \r\n    table.cell(stats, 0, 6, \"Net Profit\", text_color=color.gray, text_size=size.small)\r\n    np_color = strategy.netprofit > 0 ? color.green : color.red\r\n    table.cell(stats, 1, 6, str.tostring(strategy.netprofit, \"#.##\"), text_color=np_color, text_size=size.small)\r\n    \r\n    table.cell(stats, 0, 7, \"Today Direction\", text_color=color.gray, text_size=size.small)\r\n    dir_text = kz_direction == 1 ? \"LONG â–²\" : kz_direction == -1 ? \"SHORT â–¼\" : \"-\"\r\n    dir_color = kz_direction == 1 ? color.green : kz_direction == -1 ? color.red : color.gray\r\n    table.cell(stats, 1, 7, dir_text, text_color=dir_color, text_size=size.small)\r\n"
  },
  {
    "url": "1fhLYOqm-RSI-55-EMA-Volume-SL-Marked-No-Engulfing",
    "name": "RSI + 55 EMA + Volume (SL Marked, No Engulfing)",
    "description": "This is to help entering in trades by considering 50 EMA and RSI indicators, Volume is used for confirmations",
    "image_url": "1fhLYOqm",
    "author": "bvdatar8",
    "likes": 22,
    "type": "strategy",
    "created": "2025-11-22",
    "updated": "2025-11-22",
    "source": "//@version=5\nstrategy(\"RSI + 55 EMA + Volume (SL Marked, No Engulfing)\", \n     overlay = true, margin_long = 100, margin_short = 100, initial_capital = 100000)\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// INPUTS\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nemaLength  = input.int(55,  \"EMA Length\")\nrsiLength  = input.int(14,  \"RSI Length\")\nvolLen     = input.int(20,  \"Volume SMA Length\")\nrsiLong    = input.float(55, \"RSI > for Long\")\nrsiShort   = input.float(45, \"RSI < for Short\")\nvolMult    = input.float(1.3, \"Volume Multiplier for Entry Candle\")\n\nslPerc = input.float(0.8, \"Stop Loss %\", step = 0.1)\ntpPerc = input.float(1.0, \"Take Profit %\", step = 0.1)\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// INDICATORS\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nema55 = ta.ema(close, emaLength)\nrsi   = ta.rsi(close, rsiLength)\nvolMA = ta.sma(volume, volLen)\n\n// Simple rejection candle logic (no engulfing)\n// Bullish rejection: green candle with decent lower wick near EMA\nbullRejection = close > open and (close - low) > (open - close)\n\n// Bearish rejection: red candle with decent upper wick near EMA\nbearRejection = close < open and (high - close) > (close - open)\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// LONG CONDITIONS\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nlongTrend    = close > ema55                      // price above EMA â†’ uptrend\nlongMomentum = rsi > rsiLong                      // RSI filter\n// price pulls back to EMA zone (Â±0.3%)\nlongPullback = low <= ema55 * 1.003 and low >= ema55 * 0.997\n// rejection candle near EMA\nlongSignalCandle = bullRejection\n// volume confirmation\nlongVolume   = volume >= volMA * volMult\n\nlongSignal   = longTrend and longMomentum and longPullback and longSignalCandle and longVolume\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// SHORT CONDITIONS\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nshortTrend    = close < ema55                     // price below EMA â†’ downtrend\nshortMomentum = rsi < rsiShort\nshortPullback = high >= ema55 * 0.997 and high <= ema55 * 1.003\nshortSignalCandle = bearRejection\nshortVolume   = volume >= volMA * volMult\n\nshortSignal   = shortTrend and shortMomentum and shortPullback and shortSignalCandle and shortVolume\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// EXECUTION\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nif longSignal\n    strategy.entry(\"Long\", strategy.long)\n\nif shortSignal\n    strategy.entry(\"Short\", strategy.short)\n\n// Exit levels (current bar, used by engine)\nlongStopPrice  = strategy.position_avg_price * (1 - slPerc/100)\nlongTpPrice    = strategy.position_avg_price * (1 + tpPerc/100)\nshortStopPrice = strategy.position_avg_price * (1 + slPerc/100)\nshortTpPrice   = strategy.position_avg_price * (1 - tpPerc/100)\n\nstrategy.exit(\"Exit Long\",  \"Long\",  stop = longStopPrice,  limit = longTpPrice)\nstrategy.exit(\"Exit Short\", \"Short\", stop = shortStopPrice, limit = shortTpPrice)\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// STOP-LOSS MARKERS (CANDLE + LEVEL)\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nwasLongPrev  = strategy.position_size[1] > 0\nwasShortPrev = strategy.position_size[1] < 0\nflatNow      = strategy.position_size == 0\n\n// Use previous bar's average price to reconstruct that trade's SL/TP\nlongStopPrev  = strategy.position_avg_price[1] * (1 - slPerc/100)\nlongTpPrev    = strategy.position_avg_price[1] * (1 + tpPerc/100)\nshortStopPrev = strategy.position_avg_price[1] * (1 + slPerc/100)\nshortTpPrev   = strategy.position_avg_price[1] * (1 - tpPerc/100)\n\n// Long SL hit: we were long, now flat, low pierced stop and bar did not reach TP\nlongSlHit  = wasLongPrev and flatNow and not na(strategy.position_avg_price[1]) and low <= longStopPrev and high < longTpPrev\n\n// Short SL hit: we were short, now flat, high pierced stop and bar did not reach TP\nshortSlHit = wasShortPrev and flatNow and not na(strategy.position_avg_price[1]) and high >= shortStopPrev and low > shortTpPrev\n\n// Draw labels\nif longSlHit\n    // Candle label (below bar)\n    label.new(\n         bar_index, low, \"SL\",\n         style     = label.style_label_down,\n         color     = color.new(color.red, 0),\n         textcolor = color.white,\n         size      = size.tiny)\n    // Price-level label\n    label.new(\n         bar_index, longStopPrev, \"SL\",\n         style     = label.style_label_left,\n         color     = color.new(color.red, 0),\n         textcolor = color.white,\n         size      = size.tiny)\n\nif shortSlHit\n    // Candle label (above bar)\n    label.new(\n         bar_index, high, \"SL\",\n         style     = label.style_label_up,\n         color     = color.new(color.red, 0),\n         textcolor = color.white,\n         size      = size.tiny)\n    // Price-level label\n    label.new(\n         bar_index, shortStopPrev, \"SL\",\n         style     = label.style_label_left,\n         color     = color.new(color.red, 0),\n         textcolor = color.white,\n         size      = size.tiny)\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// VISUALS\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nplot(ema55, \"EMA 55\", color = color.new(color.blue, 0), linewidth = 2)\n\nplotshape(longSignal,  title = \"BUY\", \n     text     = \"BUY\",  \n     style    = shape.labelup, \n     color    = color.new(color.green, 0), \n     size     = size.small, \n     location = location.belowbar)\n\nplotshape(shortSignal, title = \"SELL\", \n     text     = \"SELL\", \n     style    = shape.labeldown, \n     color    = color.new(color.red, 0), \n     size     = size.small, \n     location = location.abovebar)\n\n// Trend background shading\nbgcolor(longTrend  ? color.new(color.green, 92) : na)\nbgcolor(shortTrend ? color.new(color.red,   92) : na)\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// ALERTS\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nalertcondition(longSignal,  \"Long Entry\",  \"RSI+EMA+Volume LONG\")\nalertcondition(shortSignal, \"Short Entry\", \"RSI+EMA+Volume SHORT\")\n"
  },
  {
    "url": "pBCSZ5V6-ParabolicSAR-EMA-TS-Indie",
    "name": "ParabolicSAR+EMA[TS_Indie]",
    "description": "ðŸš€  EMA + Parabolic SAR Reversal Trading Strategy \nThis trading system effectively combines the use of  Exponential Moving Averages (EMA)  with the  Parabolic SAR  to identify both price trends and key reversal points. The EMA Fast is used to signal the primary short-term trend, while the EMA Slow acts as a filter for the long-term trend direction. The Parabolic SAR then helps to confirm the reversal signals.\n\nðŸ› ï¸  Tools Used \n1. EMA Fast  â€“ Primary Short-Term Trend\n2. EMA Slow  â€“ Long-Term Trend Filter\n3. Parabolic SAR  â€“ Reversal Confirmation\n\nðŸŽ¯  Entry Rules \n  \nðŸ“ˆ  Buy Setup \n1. Trend Filter:  EMA Fast > EMA Slow â†’  Uptrend \n2. Pullback:  Price pulls back and closes  below  the EMA Fast line.\n3. Reversal:  Price reverses/pulls back up and closes  above  the EMA Fast line.\n4. SAR Confirmation:  The  previous  Parabolic SAR dot is  above  the high, and the dot in the  current  candle is  below  the low â†’  Reversal signal confirmed. \n5. Entry:  Enter Buy immediately.\n\n  \nðŸ“‰  Sell Setup \n1. Trend Filter:  EMA Fast < EMA Slow â†’  Downtrend \n2. Pullback:  Price pulls back and closes  above  the EMA Fast line.\n3. Reversal:  Price reverses/pulls back down and closes  below  the EMA Fast line.\n4. SAR Confirmation:  The  previous  Parabolic SAR dot is  below  the low, and the dot in the  current  candle is  above  the high â†’  Reversal signal confirmed. \n5. Entry:  Enter Sell immediately.\n\nðŸ’°  Exit Management (Entry, Stop Loss, Take Profit) \n1. Entry:  Enter the order at the  closing price  of the signal candle.\n2. Stop Loss (SL):  Set the Stop Loss at the  Parabolic SAR  dot.\n3. Take Profit (TP):  Calculated from the Entry and Stop Loss points, multiplied by the  Risk Reward Ratio. \n\nâš™ï¸  Optional Parameters \n  \nâž­ Custom Risk/Reward Ratio for Take Profit.\nâž­ Option to add an  ATR buffer  to the Stop Loss.\nâž­ Adjustable EMA Fast period.\nâž­ Adjustable EMA Slow period.\nâž­ Adjustable Parabolic SAR parameters.\nâž­ Option to enable Long-only / Short-only positions.\nâž­ Customizable Backtest start and end date.\nâž­ Customizable trading session time.\n\nðŸ”” Alert Function\nAlerts display:\nâž­ Entry Price\nâž­ Stop Loss Price\nâž­ Take Profit Price\n\nðŸ’¡ This strategy allows for many parameter adjustments, such as the MA type, adding/subtracting from the Stop Loss using ATR, and selecting specific sessions for backtesting. If you find interesting or profitable results after adjusting the parameters, please share your comments with other traders!\n\nâš ï¸  Disclaimer \nThis indicator is designed for  educational and research purposes only.  It does not guarantee profits and should not be considered financial advice. Trading in financial markets involves  significant risk , including the potential loss of capital.\n",
    "image_url": "pBCSZ5V6",
    "author": "Truth_Strategy_Indie",
    "likes": 149,
    "type": "strategy",
    "created": "2025-11-22",
    "updated": "2025-11-22",
    "source": "//@version=6\r\nstrategy(\"ParabolicSAR+EMA[TS_Indie]\", overlay=true, max_labels_count=500 , max_lines_count = 500 ,max_boxes_count = 500, max_bars_back = 5000 , margin_long=0, margin_short=0 ,  initial_capital=10000 , process_orders_on_close = true)\r\n\r\nGROUP_1 = \"====== Conditions Entry ======\"\r\nGROUP_2 = \"====== Setup Risk Reward Ratio ======\"\r\nGROUP_3 = \"====== Setup Stop loss ATR ======\"\r\n\r\n// === Input Parameters ===\r\nrr_ratio = input.float(1.5, \"Risk Reward Ratio\", step=0.1 , inline=\"1\" , group = GROUP_2 )\r\nlength_atr = input.int(title=\"Length ATR\", defval=14, minval=1 , inline=\"2\" , group = GROUP_3 )\r\nx_ATR = input.float( 0 , \"x ATR\", step=0.1 , inline=\"2\" , group = GROUP_3 )\r\n\r\nlong_t = input(true,\"Entry Longã…¤ã…¤\", inline=\"1\" , group = GROUP_3 )\r\nshort_t = input(true, \"Entry Short\" , inline=\"1\" , group = GROUP_3 )\r\n\r\nmaTypeInput_fast = input.string(\"EMA\", \"Type MA Fast\", options = [\"EMA\", \"SMA\", \"SMMA (RMA)\", \"WMA\", \"VWMA\"], group = GROUP_1 , inline=\"3\" , display = display.data_window)\r\nema_fast_len = input.int(100, \"Length Fast\" , inline=\"3.5\" , group = GROUP_1 )\r\nsrc_1 = input(close, \"Source\" , inline=\"3.5\" , group = GROUP_1 )\r\n\r\nmaTypeInput_slow = input.string(\"EMA\", \"Type MA Slow\", options = [\"EMA\", \"SMA\", \"SMMA (RMA)\", \"WMA\", \"VWMA\"], group = GROUP_1 , inline=\"4\", display = display.data_window)\r\nema_slow_len = input.int(150, \"Length Slow\", inline=\"4.5\" , group = GROUP_1 )\r\nsrc_2 = input(close, \"Source\" , inline=\"4.5\" , group = GROUP_1 )\r\n\r\nParabolic_SAR = \" ====== Parabolic SAR ====== \"\r\nstart = input.float(0.02  , step=0.01 , inline=\"5\"  , group = Parabolic_SAR )\r\nincrement = input.float(0.012 , step=0.01 , inline=\"6\" , group = Parabolic_SAR )\r\nmaximum = input.float(0.15 , step=0.01 , inline=\"7\" , group = Parabolic_SAR )\r\n\r\n//====== Time Filter ======\r\nTime_Filter = \"====== Time Filter ======\"\r\ns_date = input.time(timestamp(\"01 Jan 1970\"),\"Start\" , inline=\"1\" , group = Time_Filter )\r\nen_date = input.time(timestamp(\"01 Jan 2500\"), \"End \" , inline=\"2\" , group = Time_Filter )\r\n\r\ncon_date = time >= s_date and time <= en_date\r\n//======== session ======== \r\n_session(sess) =>\r\n    not na(time(timeframe.period, sess, \"UTC+0\" ))\r\n\r\ns_New_York = input.bool( false ,\"New York\" , inline = \"3\" , group = Time_Filter )\r\nt_New = input.session( '1300-2200', \"\" , inline = \"3\" , group = Time_Filter )\r\nSession_1 = _session(t_New) , cf_ses1 = s_New_York ? Session_1 : false\r\n\r\ns_London = input.bool( false ,\"London\" , inline = \"4\" , group = Time_Filter )\r\nt_Lon = input.session( '0700-1600' , \"\" , inline = \"4\" , group = Time_Filter )\r\nSession_2 = _session(t_Lon) , cf_ses2 = s_London ? Session_2 : false\r\n\r\ns_Tokyo = input.bool( false ,\"Tokyo\" , inline = \"5\" , group = Time_Filter )\r\nt_Tokyo = input.session( '0000-0900' , \"\" , inline = \"5\" , group = Time_Filter )\r\nSession_3 = _session(t_Tokyo) , cf_ses3 = s_Tokyo ? Session_3 : false\r\n\r\ns_Sydney = input.bool( false ,\"Sydney\" , inline = \"6\" , group = Time_Filter )\r\nt_Syd = input.session( '2100-0600' , \"\" , inline = \"6\" , group = Time_Filter )\r\nSession_4 = _session(t_Syd) , cf_ses4 = s_Sydney ? Session_4 : false\r\n\r\nses_check = s_New_York or s_London or s_Tokyo or s_Sydney\r\ntime_con = cf_ses1 or cf_ses2 or cf_ses3 or cf_ses4\r\ncon_time = ses_check ? time_con : true\r\n\r\n//======== Table ======== \r\nposition(select) =>\r\n    switch select\r\n        \"bottom_right\"  => position.bottom_right\r\n        \"bottom_center\" => position.bottom_center\r\n        \"bottom_left\"   => position.bottom_left\r\n        \"top_center\"    => position.top_center\r\n        \"top_left\"      => position.top_left\r\n        \"top_right\"     => position.top_right\r\n        \"mid_center\"    => position.middle_center\r\n        \"mid_left\"      => position.middle_left\r\n        \"mid_right\"     => position.middle_right\r\n\r\nresult_group = \"====== Trading Result Table ======\"\r\nShow_result = input.bool( true ,\"Show Result\" , inline = \"1\" , group = result_group ,tooltip = \"The Profit Factor here is calculated using the formula:\\n\\(Number of Wins x Risk-Reward Ratio) / Number of Losses\\n\\This formula is based on the assumption that the risk per losing trade is fixed â€” for example, every losing trade costs exactly 1% of the account.\\n\\Because of this assumption, the calculated Profit Factor will not match TradingViewâ€™s result, since TradingView uses:\\n\\Gross Profit / Gross Loss\\n\\And in actual TradingView trades, the loss amount of each trade is not always equal, because the system doesnâ€™t enforce a fixed-risk rule for every losing trade. \" )\r\nselect_position = input.string(\"bottom_right\", \"\", options = [\"bottom_right\", \"bottom_center\", \"bottom_left\", \"top_center\", \"top_left\" , \"top_right\" , \"mid_center\" , \"mid_left\" , \"mid_right\" ], group = result_group  , inline=\"1\" , display = display.data_window)\r\nFactor_up = input.float( 1.3 ,\"Profit Factor > \" , step=0.1 , inline = \"2\" , group = result_group )\r\nFactor_up_color = input(title = \"   \" , defval = #a5d6a7  , inline = \"2\" , group = result_group)\r\nFactor_donw = input.float( 1 ,\"Profit Factor < \" , step=0.1 , inline = \"3\" , group = result_group )\r\nFactor_donw_color = input(title = \"   \" , defval = #faa1a4  , inline = \"3\" , group = result_group)\r\n\r\n// MA Calculation\r\nma(source, length, MAtype) =>\r\n\tswitch MAtype\r\n\t\t\"SMA\"                   => ta.sma(source, length)\r\n\t\t\"EMA\"                   => ta.ema(source, length)\r\n\t\t\"SMMA (RMA)\"            => ta.rma(source, length)\r\n\t\t\"WMA\"                   => ta.wma(source, length)\r\n\t\t\"VWMA\"                  => ta.vwma(source, length)\r\n\r\natr_sl = ta.ema(ta.tr(true), length_atr)\r\n\r\nvar int c_order_buy = 0 , var int c_order_sell = 0\r\nbool pending_buy = false , bool pending_sell = false\r\nvar float stop_loss_long = 0 , var float stop_loss_short = 0\r\nvar float take_profit_long = 0 , var float take_profit_short = 0\r\nvar float open_long = 0 , var float open_short = 0\r\nvar int time_buy = 0 , var int time_sell = 0\r\n// === Indicator Calculation ===\r\nema_fast = ma(src_1, ema_fast_len, maTypeInput_fast)\r\nema_slow = ma(src_2, ema_slow_len, maTypeInput_slow)\r\n\r\n// === Trend Filter ===\r\nuptrend = ema_fast > ema_slow\r\ndowntrend = ema_fast < ema_slow\r\n// ParabolicSAR\r\nParabolicSAR = ta.sar(start, increment, maximum)\r\n\r\n//Condition Buy\r\nvar bool Con_1 = false , bool Con_2 = false\r\nif not Con_1 and  close <= ema_fast and uptrend and strategy.position_size == 0\r\n    Con_1 := true\r\nif downtrend\r\n    Con_1 := false\r\nif Con_1 and close >= ema_fast and uptrend and (ParabolicSAR < low and ParabolicSAR[1] > high[1])\r\n    Con_2 := true\r\n    Con_1 := false\r\n\r\n//Condition Sell\r\nvar bool S_Con_1 = false , bool S_Con_2 = false\r\nif not S_Con_1 and close >= ema_fast and downtrend and strategy.position_size == 0\r\n    S_Con_1 := true\r\nif uptrend\r\n    S_Con_1 := false\r\nif S_Con_1 and close <= ema_fast and downtrend and (ParabolicSAR > high and ParabolicSAR[1] < low[1])\r\n    S_Con_2 := true\r\n    S_Con_1 := false\r\n\r\n// === Entry Conditions ===\r\nbuy_signal = barstate.isconfirmed and long_t and Con_2 and con_time and con_date and strategy.position_size == 0\r\nsell_signal = barstate.isconfirmed and short_t and S_Con_2 and con_time and con_date and strategy.position_size == 0\r\n\r\n// === Position Size ===\r\nrisk_pips = atr_sl * x_ATR\r\nvalue_remove2(va1 , va2 , size) =>\r\n    array.remove(va1,size) , array.remove(va2,size)\r\nvar tp_buy = array.new_float(0,na) , var sl_buy = array.new_float(0,na)  \r\nvar tp_sell = array.new_float(0,na) , var sl_sell = array.new_float(0,na)  \r\n\r\n// === Long Entry ===\r\nif buy_signal\r\n    sl_cal_long = ParabolicSAR\r\n    stop_loss_long := sl_cal_long - risk_pips\r\n    take_profit_long := close + (close - stop_loss_long)*rr_ratio\r\n    c_order_buy += 1 \r\n    cs_buy = str.tostring(c_order_buy)\r\n    strategy.entry(\"Long \"+cs_buy, strategy.long , na , limit = close , stop = close )\r\n    strategy.exit(\"Long Exit \"+cs_buy , \"Long \"+cs_buy , stop = stop_loss_long , limit = take_profit_long , comment_profit = \"Long(Tp) \"+cs_buy ,comment_loss = \"Long(SL) \"+cs_buy )\r\n    p_entry = \"\\n\\nEntry price = \"+str.tostring( close , format.mintick)\r\n    p_sl = \"\\n\\nStop loss = \"+str.tostring(stop_loss_long, format.mintick)\r\n    p_tp = \"\\n\\nTarget profit = \"+str.tostring(take_profit_long, format.mintick)\r\n    alert(\"Long_\"+p_entry+p_sl+p_tp, alert.freq_all)\r\n    pending_buy := true , open_long := close , time_buy := time\r\n    array.unshift(tp_buy, take_profit_long) , array.unshift(sl_buy,stop_loss_long)\r\n\r\n// === Short Entry ===\r\nif sell_signal\r\n    sl_cal_short = ParabolicSAR\r\n    stop_loss_short := sl_cal_short + risk_pips\r\n    take_profit_short := close - (stop_loss_short - close)*rr_ratio\r\n    c_order_sell += 1\r\n    cs_sell = str.tostring(c_order_sell)\r\n    strategy.entry(\"Short \"+cs_sell, strategy.short , na , limit = close , stop = close )\r\n    strategy.exit(\"Short Exit \"+cs_sell ,\"Short \"+cs_sell , stop = stop_loss_short , limit = take_profit_short , comment_profit = \"Short(Tp) \"+cs_sell ,comment_loss = \"Short(SL) \"+cs_sell )\r\n    p_entry = \"\\n\\nEntry price = \"+str.tostring( close , format.mintick)\r\n    p_sl = \"\\n\\nStop loss = \"+str.tostring(stop_loss_short, format.mintick)\r\n    p_tp = \"\\n\\nTarget profit = \"+str.tostring(take_profit_short, format.mintick)\r\n    alert(\"Short_\"+p_entry+p_sl+p_tp, alert.freq_all)\r\n    pending_sell := true  , open_short := close  , time_sell := time\r\n    array.unshift(tp_sell, take_profit_short) , array.unshift(sl_sell,stop_loss_short)\r\n\r\n//show pending\r\nn_time = timeframe.in_seconds(timeframe.period) * 1000 * 5\r\ncol_1 = color.rgb(8, 153, 129, 80), col_2 = color.rgb(242, 54, 70, 80) \r\ntext_line2_col = #ffffff , TRANSP = #ffffff00\r\n\r\nbox box_entrybuy_1_his = na , box box_entrybuy_2_his = na\r\nbox box_entrysell_1_his = na , box box_entrysell_2_his = na\r\nlabel lbl_entry_his = na , label lbl_tp_his = na , label lbl_sl_his = na\r\n//show Buy\r\nif pending_buy or strategy.position_size > 0\r\n    box.delete(box_entrybuy_1_his[1]) , box.delete(box_entrybuy_2_his[1]) , label.delete(lbl_entry_his[1]) , label.delete(lbl_tp_his[1]) , label.delete(lbl_sl_his[1])\r\n    box_entrybuy_1_his := box.new(xloc = xloc.bar_time ,left = time_buy , top = take_profit_long, right = time+n_time , bottom = open_long , border_color = col_1 ,bgcolor = col_1)\r\n    box_entrybuy_2_his := box.new(xloc = xloc.bar_time ,left = time_buy , top = open_long, right = time+n_time , bottom = stop_loss_long , border_color = col_2 ,bgcolor = col_2)\r\n    lbl_entry_his := label.new(time+n_time, open_long , str.tostring(open_long,format.mintick) ,xloc = xloc.bar_time, color = TRANSP, textcolor = text_line2_col, style = label.style_label_center, size = size.small)\r\n    lbl_tp_his := label.new(time+n_time, take_profit_long , str.tostring(take_profit_long,format.mintick),xloc = xloc.bar_time, color = TRANSP, textcolor = text_line2_col, style = label.style_label_center, size = size.small)\r\n    lbl_sl_his := label.new(time+n_time, stop_loss_long , str.tostring(stop_loss_long,format.mintick) ,xloc = xloc.bar_time, color = TRANSP, textcolor = text_line2_col, style = label.style_label_center, size = size.small)\r\n\r\n//show sell\r\nif  pending_sell or strategy.position_size < 0\r\n    box.delete(box_entrysell_1_his[1]) , box.delete(box_entrysell_2_his[1]) , label.delete(lbl_entry_his[1]) , label.delete(lbl_tp_his[1]) , label.delete(lbl_sl_his[1])\r\n    box_entrysell_1_his := box.new(xloc = xloc.bar_time , left = time_sell , top = take_profit_short, right = time+n_time  , bottom = open_short , border_color = col_1 ,bgcolor = col_1)\r\n    box_entrysell_2_his := box.new(xloc = xloc.bar_time , left = time_sell , top = open_short, right = time+n_time  , bottom = stop_loss_short , border_color = col_2 ,bgcolor = col_2)\r\n    lbl_entry_his := label.new(time+n_time , open_short , str.tostring(open_short,format.mintick) ,xloc = xloc.bar_time, color = TRANSP, textcolor = text_line2_col, style = label.style_label_center, size = size.small)\r\n    lbl_tp_his := label.new(time+n_time , take_profit_short , str.tostring(take_profit_short,format.mintick),xloc = xloc.bar_time, color = TRANSP, textcolor = text_line2_col, style = label.style_label_center, size = size.small)\r\n    lbl_sl_his := label.new(time+n_time , stop_loss_short , str.tostring(stop_loss_short,format.mintick) ,xloc = xloc.bar_time, color = TRANSP, textcolor = text_line2_col, style = label.style_label_center, size = size.small)\r\n\r\n\r\nvar int Loss_Buy = 0 , var int Win_Buy = 0 , var float sl_trade_buy = na , var float tp_trade_buy = na\r\nvar int Loss_Sell = 0 , var int Win_Sell = 0 , var float sl_trade_sell = na , var float tp_trade_sell = na\r\nif Show_result\r\n    //Check SL buy\r\n    if array.size(sl_buy) > 0 and not na(array.get(sl_buy,0))\r\n        sl_trade_buy := array.get(sl_buy,0)\r\n    if low <= sl_trade_buy and ( strategy.position_size[1] > 0 or buy_signal[1] ) and array.size(sl_buy) > 0\r\n        sl_trade_buy := na\r\n        for i = array.size(sl_buy)-1 to 0\r\n            if low <= array.get(sl_buy,i) and not na(array.get(sl_buy,i))\r\n                Loss_Buy += 1\r\n                value_remove2( tp_buy , sl_buy , i)\r\n    //check TP buy\r\n    if array.size(tp_buy) > 0 and not na(array.get(tp_buy,0))\r\n        tp_trade_buy := array.get(tp_buy,0)\r\n    if high >= tp_trade_buy and ( strategy.position_size[1] > 0 or buy_signal[1] ) and array.size(tp_buy) > 0\r\n        tp_trade_buy := na\r\n        for i = array.size(tp_buy)-1 to 0\r\n            if high >= array.get(tp_buy,i) and not na(array.get(tp_buy,i))\r\n                Win_Buy += 1 \r\n                value_remove2( tp_buy , sl_buy , i)\r\n\r\n    //Check SL Sell\r\n    if array.size(sl_sell) > 0 and not na(array.get(sl_sell,0))\r\n        sl_trade_sell := array.get(sl_sell,0)\r\n    if high >= sl_trade_sell and ( strategy.position_size[1] < 0 or sell_signal[1] ) and array.size(sl_sell) > 0\r\n        sl_trade_sell := na\r\n        for i = array.size(sl_sell)-1 to 0\r\n            if high >= array.get(sl_sell,i) and not na(array.get(sl_sell,i))\r\n                Loss_Sell += 1\r\n                value_remove2( tp_sell , sl_sell , i)\r\n    //check TP Sell\r\n    if array.size(tp_sell) > 0 and not na(array.get(tp_sell,0))\r\n        tp_trade_sell := array.get(tp_sell,0)\r\n    if low <= tp_trade_sell and ( strategy.position_size[1] < 0 or sell_signal[1] ) and array.size(tp_sell) > 0\r\n        tp_trade_sell := na\r\n        for i = array.size(tp_sell)-1 to 0\r\n            if low <= array.get(tp_sell,i) and not na(array.get(tp_sell,i))\r\n                Win_Sell += 1 \r\n                value_remove2( tp_sell , sl_sell , i)\r\n\r\n// === Plotting ===\r\np1 = plot(ema_fast, color= #f23645, title=\"EMA fast\")\r\np2 = plot(ema_slow, color=#ffee58, title=\"EMA slow\")\r\n\r\nfill(p1, p2, color = ema_fast > ema_slow ? color.rgb(67, 160, 72, 85) : color.rgb(244, 67, 54, 85))\r\nplot(ParabolicSAR, \"ParabolicSAR\", style=plot.style_cross, color=#2962FF)\r\n\r\nbarcolor( Con_1 ? color.blue : na ,title = \"Prepare Buy\")\r\nbarcolor( buy_signal ? color.orange  : na ,title = \"buy_signal\")\r\n\r\nbarcolor( S_Con_1 ? color.aqua : na ,title = \"Prepare Sell\")\r\nbarcolor( sell_signal ? color.fuchsia : na ,title = \"sell_signal\")\r\n\r\nbgcolor(s_New_York and cf_ses1 ? color.rgb(255, 251, 0, 92) : na ,title = \"New York\")\r\nbgcolor(s_London and cf_ses2 ? color.rgb(255, 0, 255, 92) : na ,title = \"London\")\r\nbgcolor(s_Tokyo and cf_ses3? color.rgb(111, 255, 82, 92) : na ,title = \"Tokyo\")\r\nbgcolor(s_Sydney and cf_ses4? color.rgb(82, 122, 255, 92) : na ,title = \"Sydney\")\r\n\r\nLocation_session = ((9*60*60) / timeframe.in_seconds(timeframe.period)) / 2 \r\nLbl_New_York = not cf_ses1 and cf_ses1 != cf_ses1[1] and s_New_York and t_New == '1300-2200' and timeframe.in_seconds(timeframe.period) <= 32400\r\nplotshape( Lbl_New_York , \"Session New York\", shape.labeldown, location.bottom, na , offset = -Location_session  , text = \"New York\", textcolor = #fffb00, size = size.tiny, display = display.all - display.status_line, editable = false)\r\nLbl_London = not cf_ses2 and cf_ses2 != cf_ses2[1] and s_London and t_Lon == '0700-1600' and timeframe.in_seconds(timeframe.period) <= 32400\r\nplotshape( Lbl_London , \"Session London\", shape.labeldown, location.bottom, na , offset = -Location_session  , text = \"London\", textcolor = #ff00ff , size = size.tiny, display = display.all - display.status_line, editable = false)\r\nLbl_Tokyo = not cf_ses3 and cf_ses3 != cf_ses3[1] and s_Tokyo and t_Tokyo == '0000-0900' and timeframe.in_seconds(timeframe.period) <= 32400\r\nplotshape( Lbl_Tokyo , \"Session Tokyo\", shape.labeldown, location.bottom, na , offset = -Location_session  , text = \"Tokyo\", textcolor = #6fff52 , size = size.tiny, display = display.all - display.status_line, editable = false)\r\nLbl_Sydney = not cf_ses4 and cf_ses4 != cf_ses4[1] and s_Sydney and t_Syd == '2100-0600' and timeframe.in_seconds(timeframe.period) <= 32400\r\nplotshape( Lbl_Sydney , \"Session Sydney\", shape.labeldown, location.bottom, na , offset = -Location_session  , text = \"Sydney\", textcolor = #527aff , size = size.tiny, display = display.all - display.status_line, editable = false)\r\n\r\nvar table Balane_status = table.new( position(select_position) , 6 , 6 , border_width = 1)\r\n\r\nTotal_all = Win_Buy + Loss_Buy + Win_Sell + Loss_Sell\r\nif Show_result and (Total_all > Total_all[1])\r\n    Long_all = Win_Buy + Loss_Buy , Short_all = Win_Sell + Loss_Sell\r\n    Total_win = Win_Buy + Win_Sell , Total_loss = Loss_Buy + Loss_Sell\r\n    Factor_all = (Total_win*rr_ratio)/Total_loss\r\n    Factor_buy = (Win_Buy*rr_ratio)/Loss_Buy\r\n    Factor_sell = (Win_Sell*rr_ratio)/Loss_Sell\r\n    txt1_1 = str.tostring(Total_all,format.volume)\r\n    txt1_2 = str.tostring(Long_all,format.volume)\r\n    txt1_3 = str.tostring(Short_all,format.volume)\r\n    txt2_1 = str.tostring(Total_win,format.volume)\r\n    txt3_1 = str.tostring(Total_loss,format.volume)\r\n    txt4_1 = str.tostring((Total_win/Total_all)*100,format.percent)\r\n    txt5_1 = str.format(\"{0,number,#.##}\", Factor_all )\r\n\r\n    txt2_2 = str.tostring(Win_Buy,format.volume)\r\n    txt3_2 = str.tostring(Loss_Buy,format.volume)\r\n    txt4_2 = str.tostring((Win_Buy/Long_all)*100,format.percent)\r\n    txt5_2 = str.format(\"{0,number,#.##}\", Factor_buy )\r\n\r\n    txt2_3 = str.tostring(Win_Sell,format.volume)\r\n    txt3_3 = str.tostring(Loss_Sell,format.volume)\r\n    txt4_3 = str.tostring((Win_Sell/Short_all)*100,format.percent)\r\n    txt5_3 = str.format(\"{0,number,#.##}\", Factor_sell)\r\n\r\n    Factor_all_color = Factor_all > Factor_up ? Factor_up_color : Factor_all < Factor_donw ? Factor_donw_color : color.white \r\n    Factor_buy_color = Factor_buy > Factor_up ? Factor_up_color : Factor_buy < Factor_donw ? Factor_donw_color : color.white \r\n    Factor_sell_color = Factor_sell > Factor_up ? Factor_up_color : Factor_sell < Factor_donw ? Factor_donw_color : color.white \r\n\r\n    table.cell(Balane_status , 1 , 1 , txt1_1 , bgcolor = color.black , text_color = Factor_all_color )\r\n    table.cell(Balane_status , 2 , 1 , txt2_1 , bgcolor = color.black , text_color = Factor_all_color )\r\n    table.cell(Balane_status , 3 , 1 , txt3_1 , bgcolor = color.black , text_color = Factor_all_color )\r\n    table.cell(Balane_status , 4 , 1 , txt4_1 , bgcolor = color.black , text_color = Factor_all_color )\r\n    table.cell(Balane_status , 5 , 1 , txt5_1 , bgcolor = color.black , text_color = Factor_all_color )\r\n\r\n    table.cell(Balane_status , 1 , 2 , txt1_2 , bgcolor = color.black , text_color = Factor_buy_color )\r\n    table.cell(Balane_status , 2 , 2 , txt2_2 , bgcolor = color.black , text_color = Factor_buy_color )\r\n    table.cell(Balane_status , 3 , 2 , txt3_2 , bgcolor = color.black , text_color = Factor_buy_color )\r\n    table.cell(Balane_status , 4 , 2 , txt4_2 , bgcolor = color.black , text_color = Factor_buy_color )\r\n    table.cell(Balane_status , 5 , 2 , txt5_2 , bgcolor = color.black , text_color = Factor_buy_color )\r\n    \r\n    table.cell(Balane_status , 1 , 3 , txt1_3 , bgcolor = color.black , text_color = Factor_sell_color )\r\n    table.cell(Balane_status , 2 , 3 , txt2_3 , bgcolor = color.black , text_color = Factor_sell_color )\r\n    table.cell(Balane_status , 3 , 3 , txt3_3 , bgcolor = color.black , text_color = Factor_sell_color )\r\n    table.cell(Balane_status , 4 , 3 , txt4_3 , bgcolor = color.black , text_color = Factor_sell_color )\r\n    table.cell(Balane_status , 5 , 3 , txt5_3 , bgcolor = color.black , text_color = Factor_sell_color )\r\n\r\n    table.cell(Balane_status , 0 , 1 , \"Total\" , bgcolor = color.black , text_color = color.white )\r\n    table.cell(Balane_status , 0 , 2 , \"Long\" , bgcolor = color.black , text_color = color.white )\r\n    table.cell(Balane_status , 0 , 3 , \"Short\" , bgcolor = color.black , text_color = color.white )\r\n    table.cell(Balane_status , 1 , 0 , \"All\" , bgcolor = color.black , text_color = color.white )\r\n    table.cell(Balane_status , 2 , 0 , \"Win\" , bgcolor = color.black , text_color = color.white )\r\n    table.cell(Balane_status , 3 , 0 , \"Loss\" , bgcolor = color.black , text_color = color.white )\r\n    table.cell(Balane_status , 4 , 0 , \"Winrate\" , bgcolor = color.black , text_color = color.white )\r\n    table.cell(Balane_status , 5 , 0 , \"Profit\\n\\Factor\" , bgcolor = color.black , text_color = color.white )"
  },
  {
    "url": "oz7OBFyA-Simple-MA-Crossover-w-SLTP",
    "name": "Simple MA Crossover w/ SLTP",
    "description": "Picture two cheetahs on a racetrack made of price candles. One cheetah is fast and twitchy (the short-term EMA). The other is chill, lumbering, and takes its sweet time (the long-term EMA). When the twitchy cheetah sprints ahead and crosses above the chill one â†’ â€œBUY, YOU MAGNIFICENT DEGEN!â€ When the twitchy one gets tired, slows down, and gets lapped from above â†’ â€œSELL before this turns into a horror movie!â€\nThat, my friend, is the EMA crossover strategy in its purest, most dramatic form.",
    "image_url": "oz7OBFyA",
    "author": "Thighighs",
    "likes": 3,
    "type": "strategy",
    "created": "2025-11-22",
    "updated": "2025-11-22",
    "source": "//@version=6\r\nstrategy('Simple MA Crossover w/ SLTP', overlay = true, pyramiding = 0, default_qty_type = strategy.percent_of_equity, default_qty_value = 10)\r\n\r\n// â€”â€”â€” Inputs â€”â€”â€”\r\nmaType = input.string(defval = 'EMA', title = 'MA Type', options = ['EMA', 'SMA'])\r\nfastLen = input.int(9, title = 'Fast MA Length', minval = 1)\r\nslowLen = input.int(21, title = 'Slow MA Length', minval = 1)\r\nslPerc = input.float(1.0, title = 'Stop Loss (%)', step = 0.1)\r\ntpPerc = input.float(2.0, title = 'Take Profit (%)', step = 0.1)\r\n\r\n// â€”â€”â€” Helper MA â€”â€”â€”\r\nma(src, length) =>\r\n    maType == 'EMA' ? ta.ema(src, length) : ta.sma(src, length)\r\n\r\n// â€”â€”â€” Core MAs â€”â€”â€”\r\nfastMA = ma(close, fastLen)\r\nslowMA = ma(close, slowLen)\r\n\r\n// â€”â€”â€” Signals â€”â€”â€”\r\nlongSignal = ta.crossover(fastMA, slowMA)\r\nshortSignal = ta.crossunder(fastMA, slowMA)\r\n\r\n// â€”â€”â€” Entries â€”â€”â€”\r\nif longSignal\r\n    if strategy.position_size < 0\r\n        strategy.close('Short')\r\n    strategy.entry('Long', strategy.long)\r\n\r\nif shortSignal\r\n    if strategy.position_size > 0\r\n        strategy.close('Long')\r\n    strategy.entry('Short', strategy.short)\r\n\r\n// â€”â€”â€” Dynamic SL/TP (percent from avg price) â€”â€”â€”\r\nlongStop = strategy.position_avg_price * (1 - slPerc / 100)\r\nlongTarget = strategy.position_avg_price * (1 + tpPerc / 100)\r\nshortStop = strategy.position_avg_price * (1 + slPerc / 100)\r\nshortTarget = strategy.position_avg_price * (1 - tpPerc / 100)\r\n\r\nif strategy.position_size > 0\r\n    strategy.exit('Exit Long', 'Long', stop = longStop, limit = longTarget)\r\nif strategy.position_size < 0\r\n    strategy.exit('Exit Short', 'Short', stop = shortStop, limit = shortTarget)\r\n\r\n// â€”â€”â€” Plots â€”â€”â€”\r\nplot(fastMA, color = color.new(color.blue, 0), title = 'Fast MA')\r\nplot(slowMA, color = color.new(color.orange, 0), title = 'Slow MA')\r\n\r\nplot(strategy.position_size > 0 ? longStop : na, color = color.new(color.green, 0), title = 'Long SL')\r\nplot(strategy.position_size > 0 ? longTarget : na, color = color.new(color.green, 60), title = 'Long TP')\r\nplot(strategy.position_size < 0 ? shortStop : na, color = color.new(color.red, 0), title = 'Short SL')\r\nplot(strategy.position_size < 0 ? shortTarget : na, color = color.new(color.red, 60), title = 'Short TP')\r\n\r\n// â€”â€”â€” Entry markers â€”â€”â€”\r\nplotshape(longSignal, title = 'Long Entry', location = location.belowbar, style = shape.triangleup, color = color.new(color.lime, 0), size = size.tiny, text = 'BUY')\r\nplotshape(shortSignal, title = 'Short Entry', location = location.abovebar, style = shape.triangledown, color = color.new(color.red, 0), size = size.tiny, text = 'SELL')\r\n\r\n// â€”â€”â€” Alerts â€”â€”â€”\r\nalertcondition(longSignal, title = 'Long Entry', message = 'LONG')\r\nalertcondition(shortSignal, title = 'Short Entry', message = 'SHORT')\r\n"
  },
  {
    "url": "Hkt6skOv",
    "name": "ATHëŒ€ë¹„ ì§€ì •í•˜ë½ë¥ ì— ë„ì°© ì‹œ ë§¤ìˆ˜ - ìž¥ê¸°í™€ë”© ì„ ë¬¼ ì „ëžµ(ATH Drawdown Re-Buy Long Only)",
    "description": "ë³¸ ìŠ¤í¬ë¦½íŠ¸ëŠ” ê³¼ê±° í•˜ë½ ë°ì´í„°ë¥¼ ì´ìš©í•˜ì—¬, ì •í•´ì§„ í•˜ë½ %ê°€ ë°œìƒí•˜ëŠ” ê²½ìš° ìžê¸° ìžë³¸ì˜ ì •í•´ì§„ %ë§Œí¼ì„ ì§„ìž…í•˜ê²Œ ì„¤ê³„ë˜ì–´ì§„ ìŠ¤íŠ¸ë ˆí‹°ì§€ìž…ë‹ˆë‹¤.\në ˆë²„ë¦¬ì§€ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìžˆìœ¼ë©° ê¸°ë³¸ì ìœ¼ë¡œ ì…‹íŒ…í•´ë‘” ê°’ì´ ë‚´ìž¥ë˜ì–´ìžˆìŠµë‹ˆë‹¤.(ìžìœ ë¡­ê²Œ ë°”ê¿”ì„œ ì“°ì‹œë©´ ë©ë‹ˆë‹¤.) ì¶”ê°€ì ìœ¼ë¡œ 2ë²ˆì˜ ì§„ìž… ì™¸ì—ë„ ë‹¤ë¥¸ ì§„ìž… ê¸°ì¤€, ì§„ìž… %ë¥¼ ì„¤ì •í•˜ì‹¤ ìˆ˜ ìžˆìœ¼ë©° - ChatGPTì—ê²Œ ìš”ì²­í•˜ë©´ ìˆ˜ì •í•´ì¤„ ê²ƒìž…ë‹ˆë‹¤.\nì‹¤ì œ ì‚¬ìš©ìš©ë„ë¡œëŠ” KillSwitch ê¸°ëŠ¥ì„ êº¼ì£¼ì„¸ìš”. ë°” ë‹ë³´ê¸° ê¸°ëŠ¥ì„ ì¼œì£¼ì„¸ìš”.\n\nATH Drawdown Re-Buy Long Only ì „ëžµ ì„¤ëª…\n1. ì „ëžµ ê°œìš”\n\nATH Drawdown Re-Buy Long Only ì „ëžµì€ ìžì‚°ì˜ ì—­ëŒ€ ìµœê³ ê°€(ATH, All-Time High)ë¥¼ ê¸°ì¤€ìœ¼ë¡œ í•œ í•˜ë½í­(ë“œë¡œìš°ë‹¤ìš´)ì„ í™œìš©í•˜ì—¬,\níŠ¹ì • êµ¬ê°„ë§ˆë‹¤ ë‹¨ê³„ì ìœ¼ë¡œ ë¡± í¬ì§€ì…˜ì„ êµ¬ì¶•í•˜ëŠ” ìžë™ ìž¬ë§¤ìˆ˜(Long Only) ì „ëžµìž…ë‹ˆë‹¤.\n\në³¸ ì „ëžµì€ ë‹¤ìŒê³¼ ê°™ì€ ëª©ì ì„ ê°€ì§€ê³  ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤.\n\nê¸‰ê²©í•œ ì¡°ì • êµ¬ê°„ì—ì„œ ì²´ê³„ì ì¸ ë¶„í•  ë§¤ìˆ˜ ë° ë ˆë²„ë¦¬ì§€ í™œìš©\n\nATHë¥¼ ê¸°ì¤€ìœ¼ë¡œ í•œ ëª…í™•í•œ ì§„ìž… ê·œì¹™ ì œê³µ\n\nì‹¤ì‹œê°„ìœ¼ë¡œ\n\ní‰ë‹¨ê°€\n\në ˆë²„ë¦¬ì§€\n\nì²­ì‚°ê°€ ì¶”ì •\n\nê³„ì¢Œ MDD\n\nìˆ˜ìµë¥ \në“±ì„ ì‹œê°ì ìœ¼ë¡œ ì œê³µí•˜ì—¬ ë¦¬ìŠ¤í¬ì™€ í¬ì§€ì…˜ ìƒíƒœë¥¼ ì§ê´€ì ìœ¼ë¡œ í™•ì¸í•  ìˆ˜ ìžˆë„ë¡ ì§€ì›\n\nâ€» ë³¸ ì „ëžµì€ êµìœ¡Â·ì—°êµ¬Â·ë°±í…ŒìŠ¤íŠ¸ ìš©ë„ë¡œ ì œê³µë˜ë©°,\nì–´ë– í•œ í˜•íƒœì˜ íˆ¬ìž ê¶Œìœ  ë˜ëŠ” ìˆ˜ìµì„ ë³´ìž¥í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\n\n2. ì „ëžµì˜ í•µì‹¬ ê°œë…\n2-1. ATH(ì—­ëŒ€ ìµœê³ ê°€) ê¸°ì¤€ ë“œë¡œìš°ë‹¤ìš´\n\nì „ëžµì€ ì°¨íŠ¸ ìƒì—ì„œ í•­ìƒ ê°€ìž¥ ë†’ì€ ê³ ê°€(High)ë¥¼ ATHë¡œ ê¸°ë¡í•©ë‹ˆë‹¤.\nìƒˆë¡œìš´ ê³ ì ì´ í˜•ì„±ë  ë•Œë§ˆë‹¤ ATHë¥¼ ê°±ì‹ í•˜ê³ , í•´ë‹¹ ATHë¥¼ ê¸°ì¤€ìœ¼ë¡œ ë‹¤ìŒì„ ê³„ì‚°í•©ë‹ˆë‹¤.\n\ní˜„ìž¬ ë°”ì˜ ì €ê°€(Low)ê°€ ATHì—ì„œ ëª‡ % í•˜ë½í–ˆëŠ”ì§€\n\ní˜„ìž¬ ë°”ì˜ ì¢…ê°€(Close)ê°€ ATHì—ì„œ ëª‡ % í•˜ë½í–ˆëŠ”ì§€\n\nê·¸ë¦¬ê³  ì‚¬ì „ì— ì„¤ì •í•œ ë‘ ê°œì˜ ë“œë¡œìš°ë‹¤ìš´ êµ¬ê°„ì—ì„œ ë§¤ìˆ˜ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤.\n\n1ì°¨ ì§„ìž… êµ¬ê°„: ATH ëŒ€ë¹„ X% í•˜ë½ ì‹œ\n\n2ì°¨ ì§„ìž… êµ¬ê°„: ATH ëŒ€ë¹„ Y% í•˜ë½ ì‹œ\n\nê° êµ¬ê°„ì€ ATHê°€ ìƒˆë¡œ ê°±ì‹ ë  ë•Œë§ˆë‹¤ í•œ ë²ˆì”©ë§Œ ìž‘ë™í•˜ë©°,\nìƒˆë¡œìš´ ATHê°€ ìƒì„±ë˜ë©´ ë‹¤ì‹œ â€œ1ì°¨ / 2ì°¨ ì§„ìž… ê°€ëŠ¥ ìƒíƒœâ€ë¡œ ì´ˆê¸°í™”ë©ë‹ˆë‹¤.\n\n2-2. ì²« í¬ì§€ì…˜ 100% / 300% íŠ¹ìˆ˜ ê·œì¹™\n\nì´ ì „ëžµì˜ ì¤‘ìš”í•œ íŠ¹ì§•ì€ **â€œì²« í¬ì§€ì…˜ ì§„ìž… ì‹œì˜ ì˜ˆì™¸ ê·œì¹™â€**ìž…ë‹ˆë‹¤.\n\nì „ëžµì´ í˜„ìž¬ ì–´ë– í•œ í¬ì§€ì…˜ë„ ë“¤ê³  ìžˆì§€ ì•Šì€ ìƒíƒœì—ì„œ\nìµœì´ˆë¡œ ë¡± í¬ì§€ì…˜ì„ ì§„ìž…í•˜ëŠ” ì‹œì (ì²« í¬ì§€ì…˜)ì— ëŒ€í•´:\n\nê¸°ë³¸ì ìœ¼ë¡œëŠ” **ìžì‚°ì˜ 100%**ë¥¼ ê¸°ì¤€ìœ¼ë¡œ í¬ì§€ì…˜ì„ êµ¬ì¶•í•˜ì§€ë§Œ,\n\në§Œì•½ ê·¸ ìˆœê°„ì˜ ê°€ê²©ì´ ATH ëŒ€ë¹„ ì„¤ì •ê°’ ì´ìƒ(ì˜ˆ: ì•½ â€“72.5% ì´ìƒ í•˜ë½í•œ ìƒí™©) ì´ë¼ë©´\nâ†’ ìžì‚°ì˜ 300% ê·œëª¨ë¡œ ì²« í¬ì§€ì…˜ì„ ì§„ìž…í•˜ë„ë¡ ì„¤ê³„ë˜ì–´ ìžˆìŠµë‹ˆë‹¤.\n\nì´ ê·œì¹™ì€ ë‹¤ìŒê³¼ ê°™ì´ ë™ìž‘í•©ë‹ˆë‹¤.\n\nì²« ì§„ìž…ì´ 1ì°¨ ë“œë¡œìš°ë‹¤ìš´ êµ¬ê°„ì—ì„œ ë°œìƒí•˜ë“ ,\nì²« ì§„ìž…ì´ 2ì°¨ ë“œë¡œìš°ë‹¤ìš´ êµ¬ê°„ì—ì„œ ë°œìƒí•˜ë“ ,\n\ní˜„ìž¬ í•˜ë½í­ì´ ì„¤ì •ëœ ê¸°ì¤€ ì´ìƒ(ì˜ˆ: â€“72.5% ì´ìƒ) ì´ë¼ë©´\nâ†’ â€œì´ ì •ë„ í•˜ë½ì´ë©´ ì²« ì§„ìž…ë¶€í„° ë” ê³µê²©ì ìœ¼ë¡œ ë“¤ì–´ê°„ë‹¤â€ëŠ” ì˜ë¯¸ë¡œ 300% ê·œëª¨ë¡œ ì§„ìž…\n\nê·¸ ì´í•˜ì˜ í•˜ë½í­ì´ë¼ë©´\nâ†’ ì²« ì§„ìž…ì€ 100% ê·œëª¨ë¡œ ì œí•œ\n\nì¦‰, ì „ëžµì€ ë‹¤ìŒ ë‘ ê°€ì§€ ëª¨ë“œë¡œ ë™ìž‘í•©ë‹ˆë‹¤.\n\nì¼ë°˜ì ì¸ ìƒí™©ì˜ ì²« ì§„ìž…: ìžì‚°ì˜ 100%\n\nì‹¬ê°í•œ ë“œë¡œìš°ë‹¤ìš´ êµ¬ê°„ì—ì„œì˜ ì²« ì§„ìž…: ìžì‚°ì˜ 300%\n\nì´ íŠ¹ìˆ˜ ê·œì¹™ì€ ê¹Šì€ í•˜ë½ì—ì„œëŠ” ê³µê²©ì ìœ¼ë¡œ, í‰ì†Œì—ëŠ” ìƒëŒ€ì ìœ¼ë¡œ ë³´ìˆ˜ì ìœ¼ë¡œ ì§„ìž…í•˜ë„ë¡ ì„¤ê³„ëœ ê²ƒìž…ë‹ˆë‹¤.\n\n3. ì „ëžµ ë™ìž‘ êµ¬ì¡°\n3-1. ë§¤ìˆ˜ ì¡°ê±´\n\nì°¨íŠ¸ ìƒ High ê¸°ì¤€ìœ¼ë¡œ ATHë¥¼ ì¶”ì í•©ë‹ˆë‹¤.\n\nê° ë°”ë§ˆë‹¤ í•´ë‹¹ ATHì—ì„œì˜ í•˜ë½ë¥ ì„ ê³„ì‚°í•©ë‹ˆë‹¤.\n\nì‚¬ìš©ìžê°€ ì„¤ì •í•œ ë‘ ê°œì˜ ë“œë¡œìš°ë‹¤ìš´ êµ¬ê°„(ì˜ˆì‹œ):\n\n1ì°¨ êµ¬ê°„: ì˜ˆë¥¼ ë“¤ì–´ ATH â€“ 50%\n\n2ì°¨ êµ¬ê°„: ì˜ˆë¥¼ ë“¤ì–´ ATH â€“ 72.5%\n\nê° êµ¬ê°„ì— ëŒ€í•´ ë‹¤ìŒê³¼ ê°™ì€ ì¡°ê±´ì„ í™•ì¸í•©ë‹ˆë‹¤.\n\nâ€œì´ë²ˆ ATH êµ¬ê°„ì—ì„œ ì•„ì§ í•´ë‹¹ êµ¬ê°„ ë§¤ìˆ˜ë¥¼ í•œ ì ì´ ì—†ëŠ” ìƒíƒœâ€ì´ê³ ,\n\ní˜„ìž¬ ë°”ì˜ ì €ê°€(Low)ê°€ í•´ë‹¹ êµ¬ê°„ ê°€ê²© ì´í•˜ë¥¼ ì°ëŠ” ìˆœê°„\nâ†’ í•´ë‹¹ ë°”ì—ì„œ ë§¤ìˆ˜ ì¡°ê±´ ì¶©ì¡±ìœ¼ë¡œ ê°„ì£¼\n\nì‹¤ì œ ì£¼ë¬¸ì€:\n\ní•´ë‹¹ êµ¬ê°„ ê°€ê²©ì— ë§žì¶° ë¡± í¬ì§€ì…˜ ì§„ìž…(ë¦¬ë°‹/ì‹œìž¥ê°€ ê¸°ë°˜ ì‹œë®¬ë ˆì´ì…˜) ìœ¼ë¡œ ì²˜ë¦¬ë©ë‹ˆë‹¤.\n\n3-2. ATH ê°±ì‹ ê³¼ ì§„ìž… ê¸°íšŒ ë¦¬ì…‹\n\nì°¨íŠ¸ ìƒì—ì„œ ìƒˆë¡œìš´ ê³ ì (High)ì´ ê¸°ì¡´ ATHë¥¼ ë„˜ì–´ì„œëŠ” ìˆœê°„,\n\nATHê°€ ê°±ì‹ ë˜ê³ ,\n\n1ì°¨ / 2ì°¨ ì§„ìž… ì—¬ë¶€ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ë‚´ë¶€ í”Œëž˜ê·¸ê°€ ì´ˆê¸°í™”ë©ë‹ˆë‹¤.\n\nì´ë¥¼ í†µí•´, ì‹œìž¥ì´ ìƒˆë¡œìš´ ê³ ì ì„ ëŒíŒŒí•´ ë‚˜ê°ˆ ë•Œë§ˆë‹¤,\n\ní•´ë‹¹ êµ¬ê°„ì—ì„œ ë‹¤ì‹œ í•œ ë²ˆì”© 1ì°¨Â·2ì°¨ ë“œë¡œìš°ë‹¤ìš´ ì§„ìž… ê¸°íšŒë¥¼ ê°–ê²Œ ë©ë‹ˆë‹¤.\n\n4. í¬ì§€ì…˜ ì‚¬ì´ì§• ë° ë ˆë²„ë¦¬ì§€\n4-1. ê³„ì¢Œ ìžì‚°(Equity) ê¸°ì¤€ í¬ì§€ì…˜ í¬ê¸° ê²°ì •\n\nì „ëžµì€ í˜„ìž¬ ê³„ì¢Œ ìžì‚°ì„ ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜í•˜ì—¬ ì‚¬ìš©í•©ë‹ˆë‹¤.\n\ní˜„ìž¬ ìžì‚° = ì´ˆê¸° ìžë³¸ + ì‹¤í˜„ ì†ìµ + ë¯¸ì‹¤í˜„ ì†ìµ\n\nê° ì§„ìž… êµ¬ê°„ì—ì„œì˜ í¬ì§€ì…˜ ê°€ì¹˜ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ê²°ì •ë©ë‹ˆë‹¤.\n\n1ì°¨ ì§„ìž… êµ¬ê°„:\n\nâ€œìžì‚°ì˜ ëª‡ %ë¥¼ ì‚¬ìš©í• ì§€â€ë¥¼ ì„¤ì •ê°’ìœ¼ë¡œ ìž…ë ¥\n\nì„¤ì •ëœ í¼ì„¼íŠ¸ë¥¼ ê³„ì¢Œ ìžì‚°ì— ê³±í•œ ë’¤,\në‹¤ì‹œ ì „ëžµ ë‚´ ë ˆë²„ë¦¬ì§€ ë°°ìˆ˜(Leverage) ë¥¼ ê³±í•˜ì—¬ ì‹¤ì œ í¬ì§€ì…˜ ê°€ì¹˜ë¥¼ ê³„ì‚°\n\n2ì°¨ ì§„ìž… êµ¬ê°„:\n\në™ì¼í•œ ë°©ì‹ìœ¼ë¡œ, ë…ë¦½ëœ í¼ì„¼íŠ¸ ì„¤ì •ê°’ì„ ì‚¬ìš©\n\nì¦‰, í¬ì§€ì…˜ ê°€ì¹˜ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ê³„ì‚°ë©ë‹ˆë‹¤.\n\ní¬ì§€ì…˜ ê°€ì¹˜ = í˜„ìž¬ ìžì‚° Ã— (í•´ë‹¹ êµ¬ê°„ ì„¤ì • % / 100) Ã— ë ˆë²„ë¦¬ì§€ ë°°ìˆ˜\n\nê·¸ë¦¬ê³  ì´ë¥¼ í•´ë‹¹ êµ¬ê°„ì˜ ì§„ìž… ê°€ê²©ìœ¼ë¡œ ë‚˜ëˆ„ì–´ ì‹¤ì œ ìˆ˜ëŸ‰(í† í° ë‹¨ìœ„) ë¥¼ ì‚°ì¶œí•©ë‹ˆë‹¤.\n\n4-2. ì²« í¬ì§€ì…˜ì˜ ì˜ˆì™¸ ì²˜ë¦¬ (100% / 300%)\n\nì²« í¬ì§€ì…˜ì— ëŒ€í•´ì„œëŠ” ìœ„ì˜ ì¼ë°˜ì ì¸ í¼ì„¼íŠ¸ ì„¤ì • ëŒ€ì‹ ,\në‹¤ìŒê³¼ ê°™ì€ ê³ ì • ë¹„ìœ¨ì´ ì‚¬ìš©ë©ë‹ˆë‹¤.\n\nê¸°ë³¸: ìžì‚°ì˜ 100% ê·œëª¨ë¡œ ì²« í¬ì§€ì…˜ ì§„ìž…\n\në‹¨, ì§„ìž… ì‹œì ì˜ ATH ëŒ€ë¹„ í•˜ë½ë¥ ì´ ì„¤ì •ê°’ ì´ìƒ(ì˜ˆ: â€“72.5% ì´ìƒ) ì¼ ê²½ìš°\nâ†’ ìžì‚°ì˜ 300% ê·œëª¨ë¡œ ì²« í¬ì§€ì…˜ ì§„ìž…\n\nì´ë•Œ ì—­ì‹œ ë‹¤ìŒ ê³µì‹ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.\n\ní¬ì§€ì…˜ ê°€ì¹˜ = í˜„ìž¬ ìžì‚° Ã— (100% ë˜ëŠ” 300%) Ã— ë ˆë²„ë¦¬ì§€\n\nê·¸ë¦¬ê³  ì´ë¥¼ ê°€ê²©ìœ¼ë¡œ ë‚˜ëˆ„ì–´ ì‹¤ì œ ì§„ìž… ìˆ˜ëŸ‰ì„ ê³„ì‚°í•©ë‹ˆë‹¤.\n\nì´ ê·œì¹™ì€:\n\nì²« ì§„ìž…ì´ 1ì°¨ êµ¬ê°„ì´ë“  2ì°¨ êµ¬ê°„ì´ë“  ë™ì¼í•˜ê²Œ ì ìš©ë˜ë©°,\n\nâ€œì¶©ë¶„ížˆ ê¹Šì€ í•˜ë½ êµ¬ê°„ì—ì„œëŠ” ì²« ì§„ìž…ë¶€í„° ë” í¬ê²Œ,\ní‰ì†Œì—ëŠ” ë¹„êµì  ë³´ìˆ˜ì ìœ¼ë¡œâ€ ë¼ëŠ” ìš´ìš© ì² í•™ì„ ë°˜ì˜í•©ë‹ˆë‹¤.\n\n4-3. ì‹¤ë ˆë²„ë¦¬ì§€(Real Leverage)ì˜ ì¶”ì \n\nì „ëžµì€ ê° ë°” ë‹¨ìœ„ë¡œ ë‹¤ìŒì„ ì¶”ì í•©ë‹ˆë‹¤.\n\në°”ê°€ ì‹œìž‘í•  ë•Œì˜ ê¸°ì¡´ í¬ì§€ì…˜ í¬ê¸°\n\ní•´ë‹¹ ë°”ì—ì„œ ìƒˆë¡œ ì§„ìž…í•œ ìˆ˜ëŸ‰\n\nì´ë¥¼ ë°”íƒ•ìœ¼ë¡œ, ì§„ìž…ì´ ë°œìƒí•œ ì‹œì ì— ë‹¤ìŒì„ ê³„ì‚°í•©ë‹ˆë‹¤.\n\nì‹¤ì œ ë ˆë²„ë¦¬ì§€ = (í¬ì§€ì…˜ ê°€ì¹˜ / í˜„ìž¬ ìžì‚°)\n\nê·¸ë¦¬ê³  ì°¨íŠ¸ ìƒì— ì˜ˆë¥¼ ë“¤ì–´:\n\nLev 2.53x ì™€ ê°™ì€ í˜•ì‹ì˜ ë ˆì´ë¸”ë¡œ í‘œì‹œí•©ë‹ˆë‹¤.\n\nì´ë¥¼ í†µí•´, ë§¤ìˆ˜ ì‹œì ë§ˆë‹¤ ì‹¤ì œ ê³„ì¢Œ ë ˆë²„ë¦¬ì§€ê°€ ì–´ëŠ ì •ë„ì˜€ëŠ”ì§€ë¥¼ ì§ê´€ì ìœ¼ë¡œ í™•ì¸í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.\n\n5. ì‹œê°í™” ë° ëª¨ë‹ˆí„°ë§ ìš”ì†Œ\n5-1. ì°¨íŠ¸ ìƒ ì‹œê° ìš”ì†Œ\n\nì „ëžµì€ ì°¨íŠ¸ ìœ„ì— ë‹¤ìŒê³¼ ê°™ì€ ì •ë³´ë¥¼ ì§ì ‘ í‘œì‹œí•©ë‹ˆë‹¤.\n\nATH ë¼ì¸\nHigh ê¸°ì¤€ìœ¼ë¡œ ê³„ì‚°ëœ ì—­ëŒ€ ìµœê³ ê°€ë¥¼ ì£¼í™©ìƒ‰ ì„ ìœ¼ë¡œ í‘œì‹œ\n\ní‰ë‹¨ê°€(í‰ê·  ì§„ìž…ê°€) ë¼ì¸\ní˜„ìž¬ ë³´ìœ  í¬ì§€ì…˜ì´ ìžˆì„ ë•Œ,\ní•´ë‹¹ í¬ì§€ì…˜ì˜ í‰ê·  ì§„ìž…ê°€ë¥¼ ë…¸ëž€ìƒ‰ ì„ ìœ¼ë¡œ í‘œì‹œ\n\nì¶”ì • ì²­ì‚°ê°€(ê³ ì •í˜• ì²­ì‚°ê°€) ë¼ì¸\n\ní¬ì§€ì…˜ ìˆ˜ëŸ‰ì´ ë³€í™”í•˜ëŠ” ì‹œì ì„ ê°ì§€í•˜ì—¬,\n\në‹¹ì‹œì˜ í‰ë‹¨ê°€ì™€ ì‹¤ì œ ë ˆë²„ë¦¬ì§€ë¥¼ ì´ìš©í•´ ê·¼ì‚¬ì ì¸ ì²­ì‚°ê°€ë¥¼ ê³„ì‚°\n\nì´ë¥¼ ë¹¨ê°„ìƒ‰ ì„ ìœ¼ë¡œ ì°¨íŠ¸ì— ê³ ì • í‘œì‹œ\n\ní¬ì§€ì…˜ì´ ì—†ê±°ë‚˜ ë ˆë²„ë¦¬ì§€ê°€ 1ë°° ì´í•˜ì¸ ê²½ìš°ì—ëŠ” ì²­ì‚°ê°€ ë¼ì¸ì„ ì œê±°\n\në§¤ìˆ˜ ë§ˆì»¤ ë° ë ˆì´ë¸”\n\n1ì°¨/2ì°¨ ë§¤ìˆ˜ ì¡°ê±´ì´ ì¶©ì¡±ë  ë•Œë§ˆë‹¤ í•´ë‹¹ ì§€ì ì— ë§¤ìˆ˜ ë§ˆì»¤ë¥¼ í‘œì‹œ\n\n\"Buy XX% @ ê°€ê²©\", \"Lev XXx\" í˜•íƒœì˜ ë¼ë²¨ë¡œ\nì§„ìž… ë¹„ìœ¨ê³¼ ë‹¹ì‹œ ë ˆë²„ë¦¬ì§€ë¥¼ í•¨ê»˜ ì‹œê°í™”\n\në ˆì´ë¸”ì˜ ìœ„ì¹˜ëŠ” ì„¤ì •ì—ì„œ ì„ íƒ ê°€ëŠ¥:\n\në°” ì•„ëž˜ (Below Bar)\n\në°” ìœ„ (Above Bar)\n\nì‹¤ì œ ê°€ê²© ìœ„ì¹˜ (At Price)\n\n5-2. ìš°ì¸¡ ìƒë‹¨ ì •ë³´ í…Œì´ë¸”\n\nì°¨íŠ¸ ìš°ì¸¡ ìƒë‹¨ì—ëŠ” í˜„ìž¬ ê³„ì¢ŒÂ·í¬ì§€ì…˜ ìƒíƒœë¥¼ ìš”ì•½í•œ ì •ë³´ í…Œì´ë¸”ì´ í‘œì‹œë©ë‹ˆë‹¤.\nëŒ€í‘œì ìœ¼ë¡œ ë‹¤ìŒ í•­ëª©ë“¤ì´ í¬í•¨ë©ë‹ˆë‹¤.\n\nPos Qty (Token)\ní˜„ìž¬ ë³´ìœ  ì¤‘ì¸ í¬ì§€ì…˜ ìˆ˜ëŸ‰(í† í° ê¸°ì¤€, ì ˆëŒ€ê°’ ê¸°ì¤€)\n\nPos Value (USDT)\ní˜„ìž¬ í¬ì§€ì…˜ì˜ ì‹œìž¥ ê°€ì¹˜ (ìˆ˜ëŸ‰ Ã— í˜„ìž¬ ê°€ê²©)\n\nLeverage (Now)\ní˜„ìž¬ ì‹¤ë ˆë²„ë¦¬ì§€ (í¬ì§€ì…˜ ê°€ì¹˜ / í˜„ìž¬ ìžì‚°)\n\nDD from ATH (%)\ní˜„ìž¬ ê°€ê²© ê¸°ì¤€, ìµœê·¼ ATHì—ì„œì˜ í•˜ë½ë¥ (%)\n\nAvg Entry\ní˜„ìž¬ í¬ì§€ì…˜ì˜ í‰ê·  ì§„ìž… ê°€ê²©\n\nPnL (%)\ní˜„ìž¬ í¬ì§€ì…˜ ê¸°ì¤€ ë¯¸ì‹¤í˜„ ì†ìµë¥ (%)\n\nMax DD (Equity %)\nì „ëžµ ì „ì²´ ê¸°ê°„ ë™ì•ˆ ê¸°ë¡ëœ ê³„ì¢Œ ê¸°ì¤€ ìµœëŒ€ ì†ì‹¤(MDD, Max Drawdown)\n\nLast Entry Price\nê°€ìž¥ ìµœê·¼ì— í¬ì§€ì…˜ì„ ì¶”ê°€ë¡œ ì§„ìž…í•œ ì§í›„ì˜ í‰ê·  ì§„ìž… ê°€ê²©\n\nLast Entry Lev\nìœ„ â€œLast Entry Priceâ€ ì‹œì ì—ì„œì˜ ì‹¤ë ˆë²„ë¦¬ì§€\n\nLiq Price (Fixed)\nìœ„ì—ì„œ ì„¤ëª…í•œ ê³ ì •í˜• ì¶”ì • ì²­ì‚°ê°€\n\nReturn from Start (%)\nì „ëžµ ì‹œìž‘ ì‹œì (ì´ˆê¸° ìžë³¸) ëŒ€ë¹„ í˜„ìž¬ ê³„ì¢Œ ìžì‚°ì˜ ì´ ìˆ˜ìµë¥ (%)\n\nì´ í…Œì´ë¸”ì„ í†µí•´ ì‚¬ìš©ìžëŠ”:\n\ní˜„ìž¬ ê³„ì¢Œì™€ í¬ì§€ì…˜ì˜ ìƒíƒœ\n\në¦¬ìŠ¤í¬ ìˆ˜ì¤€\n\nëˆ„ì  ì„±ê³¼\n\në¥¼ ì§ê´€ì ìœ¼ë¡œ íŒŒì•…í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.\n\n6. ì‹œê°„ í•„í„° ë° ë¼ë²¨ ì˜µì…˜\n6-1. ì „ëžµ ë™ìž‘ ê¸°ê°„ ì„¤ì •\n\nì „ëžµì€ ì˜µì…˜ìœ¼ë¡œ íŠ¹ì • ê¸°ê°„ì—ë§Œ ì „ëžµì„ ë™ìž‘ì‹œí‚¤ëŠ” ì‹œê°„ í•„í„°ë¥¼ ì œê³µí•©ë‹ˆë‹¤.\n\nâ€œUse Date Rangeâ€ ì˜µì…˜ì„ í™œì„±í™”í•˜ë©´:\n\nì‹œìž‘ ì‹œê°ê³¼ ì¢…ë£Œ ì‹œê°ì„ ì§€ì •í•˜ì—¬\n\ní•´ë‹¹ êµ¬ê°„ì— í•œí•´ì„œë§Œ ë§¤ë§¤ê°€ ë°œìƒí•˜ë„ë¡ ì œí•œ\n\nì˜µì…˜ì„ ë¹„í™œì„±í™”í•˜ë©´:\n\nì „ëžµì€ ì „ì²´ ì°¨íŠ¸ êµ¬ê°„ì—ì„œ ìžìœ ë¡­ê²Œ ë™ìž‘\n\n6-2. ì§„ìž… ë¼ë²¨ ìœ„ì¹˜ ì„¤ì •\n\nì‚¬ìš©ìžëŠ” ë§¤ìˆ˜/ë ˆë²„ë¦¬ì§€ ë¼ë²¨ì˜ ìœ„ì¹˜ë¥¼ ì„ íƒí•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.\n\në°” ì•„ëž˜ (Below Bar)\n\në°” ìœ„ (Above Bar)\n\nì‹¤ì œ ê°€ê²© ìœ„ì¹˜ (At Price)\n\nì´ë¥¼ í†µí•´ ê°œì¸ ì·¨í–¥ ë° ì°¨íŠ¸ ê°€ë…ì„±ì— ë§žì¶”ì–´\nì‹œê°í™” ë°©ì‹ì„ ìœ ì—°í•˜ê²Œ ì¡°ì •í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.\n\n7. í™œìš© ëŒ€ìƒ ë° ì‚¬ìš© ì˜ˆì‹œ\n\në³¸ ì „ëžµì€ ë‹¤ìŒê³¼ ê°™ì€ ëª©ì ì— ì í•©í•©ë‹ˆë‹¤.\n\ní˜„ë¬¼ ë˜ëŠ” ì„ ë¬¼ ë¡± í¬ì§€ì…˜ ê¸°ì¤€ ìž¥ê¸°Â·ìŠ¤ìœ™ ê´€ì  ì¶”ë§¤ ì „ëžµ ë°±í…ŒìŠ¤íŠ¸\n\nâ€œê³ ì  ëŒ€ë¹„ í•˜ë½ë¥ â€ì„ ê¸°ì¤€ìœ¼ë¡œ í•œ ê·œì¹™ ê¸°ë°˜ ìš´ìš© ì•„ì´ë””ì–´ ê²€ì¦\n\në ˆë²„ë¦¬ì§€ ì‚¬ìš© ì‹œ\nê³„ì¢Œ ë ˆë²„ë¦¬ì§€Â·ì²­ì‚°ê°€Â·MDDë¥¼ ë™ì‹œì— ëª¨ë‹ˆí„°ë§í•˜ê³ ìž í•˜ëŠ” ê²½ìš°\n\níŠ¹ì • ìžì‚°ì— ëŒ€í•´\n\nâ€œìƒˆë¡œìš´ ê³ ì ì´ í˜•ì„±ë  ë•Œë§ˆë‹¤\nì¼ì •í•œ ê·œì¹™ìœ¼ë¡œ ê¹Šì€ ì¡°ì • êµ¬ê°„ì—ì„œë§Œ ë¶„í•  ì§„ìž…í•˜ê³ ìž í•  ë•Œâ€\n\nì‹¤ê±°ëž˜ì— ê·¸ëŒ€ë¡œ ì ìš©í•˜ê¸°ë³´ë‹¤ëŠ”,\nì „ëžµ ì•„ì´ë””ì–´ ê²€ì¦ ë° ë¦¬ìŠ¤í¬ í”„ë¡œíŒŒì¼ ë¶„ì„,\nìžì‹ ì˜ ì„±í–¥ì— ë§žëŠ” íŒŒë¼ë¯¸í„° íƒìƒ‰ ìš©ë„ë¡œ ì‚¬ìš©í•˜ëŠ” ê²ƒì„ ê¶Œìž¥í•©ë‹ˆë‹¤.\n\n8. í•œê³„ ë° ìœ ì˜ì‚¬í•­\n\në°±í…ŒìŠ¤íŠ¸ ê²°ê³¼ëŠ” ë¯¸ëž˜ ì„±ê³¼ë¥¼ ë³´ìž¥í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.\n\nê³¼ê±° ë°ì´í„°ì— ê¸°ë°˜í•œ ì‹œë®¬ë ˆì´ì…˜ì¼ ë¿ì´ë©°,\nì‹¤ì œ ì‹œìž¥ì—ì„œëŠ”\n\nìœ ë™ì„±\n\nìŠ¬ë¦¬í”¼ì§€\n\nìˆ˜ìˆ˜ë£Œ ì²´ê³„\n\nê°•ì œì²­ì‚° ê·œì¹™\në“± ë‹¤ì–‘í•œ ë³€ìˆ˜ê°€ ì¡´ìž¬í•©ë‹ˆë‹¤.\n\nì²­ì‚°ê°€ëŠ” ë‹¨ìˆœí™”ëœ ê³µì‹ì— ë”°ë¥¸ ì¶”ì •ì¹˜ìž…ë‹ˆë‹¤.\n\nê±°ëž˜ì†Œë³„ ì‹¤ì œ ì²­ì‚° ê·œì¹™, ìœ ì§€ ì¦ê±°ê¸ˆ, ìˆ˜ìˆ˜ë£Œ, íŽ€ë”©ë¹„ ë“±ì€\në³¸ ì „ëžµì˜ ê³„ì‚°ê³¼ ë‹¤ë¥¼ ìˆ˜ ìžˆìœ¼ë©°,\nì²­ì‚°ê°€ ì¶”ì • ë¼ì¸ì€ ì°¸ê³ ìš© ì§€í‘œì¼ ë¿ìž…ë‹ˆë‹¤.\n\në ˆë²„ë¦¬ì§€ ë° ì§„ìž… ë¹„ìœ¨ ì„¤ì •ì— ë”°ë¼ ì†ì‹¤ í­ì´ ë§¤ìš° ì»¤ì§ˆ ìˆ˜ ìžˆìŠµë‹ˆë‹¤.\n\níŠ¹ížˆ **â€œì²« í¬ì§€ì…˜ 300% ì§„ìž…â€**ê³¼ ê°™ì´ ë§¤ìš° ê³µê²©ì ì¸ ì„¤ì •ì€\nì‹œìž¥ ê¸‰ë½ ì‹œ ê³„ì¢Œ ì†ì‹¤ê³¼ ì²­ì‚° ë¦¬ìŠ¤í¬ë¥¼ í¬ê²Œ ì¦ê°€ì‹œí‚¬ ìˆ˜ ìžˆìœ¼ë¯€ë¡œ\nì‹ ì¤‘í•œ ê²€í† ê°€ í•„ìš”í•©ë‹ˆë‹¤.\n\nì‹¤ê±°ëž˜ ì—°ë™ ì‹œì—ëŠ” ë³„ë„ì˜ ë¦¬ìŠ¤í¬ ê´€ë¦¬ê°€ í•„ìˆ˜ìž…ë‹ˆë‹¤.\n\nê°œë³„ ì†ì ˆ ê¸°ì¤€\n\ní¬ì§€ì…˜ ìƒí•œì„ \n\nì „ì²´ í¬íŠ¸í´ë¦¬ì˜¤ ë‚´ ë¹„ì¤‘ ê´€ë¦¬ ë“±\në³¸ ì „ëžµ ì™¸ë¶€ì—ì„œ ì¶”ê°€ì ì¸ ì•ˆì „ìž¥ì¹˜ê°€ í•„ìš”í•©ë‹ˆë‹¤.\n\n9. ê²°ë¡ \n\nATH Drawdown Re-Buy Long Only ì „ëžµì€ ë‹¨ìˆœí•œ â€œì €ê°€ ë§¤ìˆ˜â€ë¥¼ ë„˜ì–´ì„œ,\n\nATH ê¸°ì¤€ìœ¼ë¡œ ë“œë¡œìš°ë‹¤ìš´ì„ êµ¬ì¡°ì ìœ¼ë¡œ í™œìš©í•˜ê³ ,\n\nì²« í¬ì§€ì…˜ì— ëŒ€í•œ **íŠ¹ìˆ˜ ê·œì¹™(100% / 300%)**ì„ ì ìš©í•˜ë©°,\n\në ˆë²„ë¦¬ì§€Â·ì²­ì‚°ê°€Â·MDDÂ·ìˆ˜ìµë¥ ì„ í†µí•©ì ìœ¼ë¡œ ì‹œê°í™”í•¨ìœ¼ë¡œì¨,\n\ní•˜ë½ êµ¬ê°„ì—ì„œì˜ ê·œì¹™ ê¸°ë°˜ ë¡± í¬ì§€ì…˜ êµ¬ì¶•ê³¼\në¦¬ìŠ¤í¬ ëª¨ë‹ˆí„°ë§ì„ ë™ì‹œì— ì§€ì›í•˜ëŠ” ì „ëžµìž…ë‹ˆë‹¤.\n\nì‚¬ìš©ìžëŠ” ë³¸ ì „ëžµì„ í†µí•´:\n\nìžì‹ ì˜ ì‹œìž¥ ê´€ì ê³¼ ë¦¬ìŠ¤í¬ í—ˆìš© ë²”ìœ„ì— ë§žëŠ”\n\në“œë¡œìš°ë‹¤ìš´ êµ¬ê°„\n\nì§„ìž… ë¹„ìœ¨\n\në ˆë²„ë¦¬ì§€ ì„¤ì •\n\në‹¤ì–‘í•œ ì‹œë‚˜ë¦¬ì˜¤ì— ëŒ€í•œ ë°±í…ŒìŠ¤íŠ¸ì™€ ë¶„ì„\n\nì„ ìˆ˜í–‰í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.\n\në‹¤ì‹œ í•œ ë²ˆ ê°•ì¡°í•˜ì§€ë§Œ,\në³¸ ì „ëžµì€ ì—°êµ¬Â·í•™ìŠµÂ·ë°±í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•œ ë„êµ¬ì´ë©°,\nì‹¤ì œ íˆ¬ìž íŒë‹¨ê³¼ ì±…ìž„ì€ ì „ì ìœ¼ë¡œ ì‚¬ìš©ìž ë³¸ì¸ì—ê²Œ ìžˆìŠµë‹ˆë‹¤.\n\n/ENG Version.\n\nThis script is designed to use historical drawdown data and automatically enter positions when a predefined percentage drop from the all-time high occurs, using a predefined percentage of your account equity.\n\nYou can use leverage, and default parameter values are provided out of the box (you can freely change them to suit your style).\nIn addition to the two main entry levels, you can add more entry conditions and custom entry percentages â€“ just ask ChatGPT to modify the script.\n\nFor actual/live usage, please turn OFF the KillSwitch function and turn ON the Bar Magnifier feature.\n\nATH Drawdown Re-Buy Long Only Strategy\n1. Strategy Overview\n\nThe ATH Drawdown Re-Buy Long Only strategy is an automatic re-buy (Long Only) system that builds long positions step-by-step at specific drawdown levels, based on the assetâ€™s all-time high (ATH) and its subsequent drawdown.\n\nThis strategy is designed with the following goals:\n\nSystematic scaled buying and leverage usage during sharp correction periods\n\nClear, rule-based entry logic using drawdowns from ATH\n\nReal-time visualization of:\n\nAverage entry price\n\nLeverage\n\nEstimated liquidation price\n\nAccount MDD (Max Drawdown)\n\nReturn / performance\n\nThis allows traders to intuitively monitor both risk and position status.\n\nâ€» This strategy is provided for educational, research, and backtesting purposes only.\nIt does not constitute investment advice and does not guarantee any profits.\n\n2. Core Concepts\n2-1. Drawdown from ATH (All-Time High)\n\nOn the chart, the strategy always tracks the highest high as the ATH.\nWhenever a new high is made, ATH is updated, and based on that ATH the following are calculated:\n\nHow many percent the current barâ€™s Low is below the ATH\n\nHow many percent the current barâ€™s Close is below the ATH\n\nUsing these, the strategy executes buys at two predefined drawdown zones:\n\n1st entry zone: When price drops X% from ATH\n\n2nd entry zone: When price drops Y% from ATH\n\nEach zone is allowed to trigger only once per ATH cycle.\nWhen a new ATH is created, the â€œ1st / 2nd entry possibleâ€ flags are reset, and new opportunities open up for that ATH leg.\n\n2-2. Special Rule for the First Position (100% / 300%)\n\nA key feature of this strategy is the special rule for the very first position.\n\nWhen the strategy currently holds no position and is about to open the first long position:\n\nUnder normal conditions, it builds the position using 100% of account equity.\n\nHowever, if at that moment the price has dropped by at least a predefined threshold from ATH (e.g. around â€“72.5% or more),\nâ†’ the strategy will open the first position using 300% of account equity.\n\nThis rule works as follows:\n\nWhether the first entry happens at the 1st drawdown zone or at the 2nd drawdown zone,\n\nIf the current drawdown from ATH is at or below the threshold (e.g. â€“72.5% or worse),\nâ†’ the strategy interprets this as â€œa sufficiently deep crashâ€ and opens the initial position with 300% of equity.\n\nIf the drawdown is less severe than the threshold,\nâ†’ the first entry is capped at 100% of equity.\n\nSo the strategy has two modes for the first entry:\n\nNormal market conditions: 100% of equity\n\nDeep drawdown conditions: 300% of equity\n\nThis special rule is intended to be aggressive in extremely deep crashes while staying more conservative in normal corrections.\n\n3. Strategy Logic & Execution\n3-1. Entry Conditions\n\nThe strategy tracks the ATH using the High price.\n\nFor each bar, it calculates the drawdown from ATH.\n\nThe user defines two drawdown zones, for example:\n\n1st zone: ATH â€“ 50%\n\n2nd zone: ATH â€“ 72.5%\n\nFor each zone, the strategy checks:\n\nIf no buy has been executed yet for that zone in the current ATH leg, and\n\nIf the current barâ€™s Low touches or falls below that zoneâ€™s price level,\nâ†’ That bar is considered to have triggered a buy condition.\n\nOrder simulation:\n\nThe strategy simulates entering a long position at that zoneâ€™s price level\n(using a limit/market-like approximation for backtesting).\n\n3-2. ATH Reset & Entry Opportunity Reset\n\nWhen a new High goes above the previous ATH:\n\nThe ATH is updated to this new high.\n\nInternal flags that track whether the 1st and 2nd entries have been used are reset.\n\nThis means:\n\nEach time the market makes a new ATH,\n\nThe strategy once again has a fresh opportunity to execute 1st and 2nd drawdown entries for that new ATH leg.\n\n4. Position Sizing & Leverage\n4-1. Position Size Based on Account Equity\n\nThe strategy defines current equity as:\n\nCurrent Equity = Initial Capital + Realized PnL + Unrealized PnL\n\nFor each entry zone, the position value is calculated as follows:\n\nThe user inputs:\n\nâ€œWhat % of equity to use at this zoneâ€\n\nThe strategy:\n\nMultiplies current equity by that percentage\n\nThen multiplies by the strategyâ€™s leverage factor\n\nThus:\n\nPosition Value = Current Equity Ã— (Zone % / 100) Ã— Leverage\n\nFinally, this position value is divided by the entry price to determine the actual position size in tokens.\n\n4-2. Exception for the First Position (100% / 300%)\n\nFor the very first position (when there is no open position),\nthe strategy does not use the zone % parameters. Instead, it uses fixed ratios:\n\nDefault: Enter the first position with 100% of equity.\n\nIf the drawdown from ATH at that moment is greater than or equal to a predefined threshold (e.g. â€“72.5% or more)\nâ†’ Enter the first position with 300% of equity.\n\nThe position value is computed as:\n\nPosition Value = Current Equity Ã— (100% or 300%) Ã— Leverage\n\nThen it is divided by the entry price to obtain the token quantity.\n\nThis rule:\n\nApplies regardless of whether the first entry occurs at the 1st zone or 2nd zone.\n\nEmbeds the philosophy:\nâ€œIn very deep crashes, go much larger on the first entry; otherwise, stay more conservative.â€\n\n4-3. Tracking Real Leverage\n\nOn each bar, the strategy tracks:\n\nThe existing position size at the start of the bar\n\nThe newly added size (if any) on that bar\n\nWhen a new entry occurs, it calculates the real leverage at that moment:\n\nReal Leverage = (Position Value / Current Equity)\n\nThis is then displayed on the chart as a label, for example:\n\nLev 2.53x\n\nThis makes it easy to see the actual leverage level at each entry point.\n\n5. Visualization & Monitoring\n5-1. On-Chart Visual Elements\n\nThe strategy plots the following directly on the chart:\n\nATH Line\n\nThe all-time high (based on High) is plotted as an orange line.\n\nAverage Entry Price Line\n\nWhen a position is open, the average entry price of that position is plotted as a yellow line.\n\nEstimated Liquidation Price (Fixed) Line\n\nThe strategy detects when the position size changes.\n\nAt each size change, it uses the current average entry price and real leverage to compute an approximate liquidation price.\n\nThis â€œfixed liquidation priceâ€ is then plotted as a red line on the chart.\n\nIf there is no position, or if leverage is 1x or lower, the liquidation line is removed.\n\nEntry Markers & Labels\n\nWhen 1st/2nd entry conditions are met, the strategy:\n\nMarks the entry point on the chart.\n\nDisplays labels such as \"Buy XX% @ Price\" and \"Lev XXx\",\nshowing both entry percentage and real leverage at that time.\n\nThe label placement is configurable:\n\nBelow Bar\n\nAbove Bar\n\nAt Price\n\n5-2. Information Table (Top-Right Panel)\n\nIn the top-right corner of the chart, the strategy displays a summary table of the current account and position status. It typically includes:\n\nPos Qty (Token)\nAbsolute size of the current position (in tokens)\n\nPos Value (USDT)\nMarket value of the current position (qty Ã— current price)\n\nLeverage (Now)\nCurrent real leverage (position value / current equity)\n\nDD from ATH (%)\nCurrent drawdown (%) from the latest ATH, based on current price\n\nAvg Entry\nAverage entry price of the current position\n\nPnL (%)\nUnrealized profit/loss (%) of the current position\n\nMax DD (Equity %)\nThe maximum equity drawdown (MDD) recorded over the entire backtest period\n\nLast Entry Price\nAverage entry price immediately after the most recent add-on entry\n\nLast Entry Lev\nReal leverage at the time of the most recent entry\n\nLiq Price (Fixed)\nThe fixed estimated liquidation price described above\n\nReturn from Start (%)\nTotal return (%) of equity compared to the initial capital\n\nThrough this table, users can quickly grasp:\n\nCurrent account and position status\n\nCurrent risk level\n\nCumulative performance\n\n6. Time Filters & Label Options\n6-1. Strategy Date Range Filter\n\nThe strategy provides an option to restrict trading to a specific time range.\n\nWhen â€œUse Date Rangeâ€ is enabled:\n\nYou can specify start and end timestamps.\n\nThe strategy will only execute trades within that range.\n\nWhen this option is disabled:\n\nThe strategy operates over the entire chart history.\n\n6-2. Entry Label Placement\n\nUsers can customize where entry/leverage labels are drawn:\n\nBelow Bar (Below Bar)\n\nAbove Bar (Above Bar)\n\nAt the actual price level (At Price)\n\nThis allows you to adjust visualization according to personal preference and chart readability.\n\n7. Use Cases & Applications\n\nThis strategy is suitable for the following purposes:\n\nLong-term / swing-style re-buy strategies for spot or futures long positions\n\nTesting rule-based strategies that rely on â€œdrawdown from ATHâ€ as a main signal\n\nMonitoring account leverage, liquidation price, and MDD when using leverage\n\nHandling situations where, for a given asset:\n\nâ€œEvery time a new ATH is formed,\nyou want to wait for deep corrections and enter only at specific drawdown zonesâ€\n\nIt is generally recommended to use this strategy not as a direct plug-and-play live system, but as a tool for:\n\nStrategy idea validation\n\nRisk profile analysis\n\nParameter exploration to match your personal risk tolerance and style\n\n8. Limitations & Warnings\n\nBacktest results do not guarantee future performance.\n\nThey are based on historical data only.\n\nIn live markets, additional factors exist:\n\nLiquidity\n\nSlippage\n\nFee structures\n\nExchange-specific liquidation rules\n\nFunding fees, etc.\n\nThe liquidation price is only an approximate estimate, derived from a simplified formula.\n\nActual liquidation rules, maintenance margin requirements, fees, and other details differ by exchange.\n\nThe liquidation line should be treated as a reference indicator, not an exact guarantee.\n\nDepending on the configured leverage and entry percentages, losses can be very large.\n\nIn particular, extremely aggressive settings such as â€œfirst position 300% of equityâ€ can greatly increase the risk of large account drawdowns and liquidation during sharp market crashes.\n\nUse such settings with extreme caution.\n\nFor live trading, additional risk management is essential:\n\nYour own stop-loss rules\n\nMaximum position size limits\n\nPortfolio-level exposure controls\n\nAnd other external safety mechanisms beyond this strategy\n\n9. Conclusion\n\nThe ATH Drawdown Re-Buy Long Only strategy goes beyond simple â€œbuy the dipâ€ logic. It:\n\nSystematically utilizes drawdowns from ATH as a structural signal\n\nApplies a special first-position rule (100% / 300%)\n\nIntegrates visualization of leverage, liquidation price, MDD, and returns\n\nAll of this supports rule-based long position building in drawdown phases and comprehensive risk monitoring.\n\nWith this strategy, users can:\n\nExplore different:\n\nDrawdown zones\n\nEntry percentages\n\nLeverage levels\n\nRun various backtests and scenario analyses\n\nBetter understand the risk/return profile that fits their own market view and risk tolerance\n\nOnce again, this strategy is intended for research, learning, and backtesting only.\nAll real trading decisions and their consequences are solely the responsibility of the user.",
    "image_url": "Hkt6skOv",
    "author": "White_light_",
    "likes": 27,
    "type": "strategy",
    "created": "2025-11-21",
    "updated": "2025-11-21",
    "source": "//@version=5\r\n// Use a single-line declaration to avoid multiline parsing issues around closing parenthesis\r\nstrategy(\"ATH Drawdown Re-Buy Long Only\", overlay=true, initial_capital=10000, default_qty_type=strategy.fixed, pyramiding=200, calc_on_every_tick=true, calc_on_order_fills=true, process_orders_on_close=false, commission_type=strategy.commission.percent, commission_value=0.05)\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// User-configurable inputs\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nleverageInput   = input.int(1, \"Leverage\", minval=1)\r\ndrawdownBuy1    = input.float(50.0, \"Buy %-from-ATH (first)\",  minval=0.1, maxval=99.9, tooltip=\"Percentage drawdown from ATH(HIGH) to place the first buy.\")\r\ndrawdownBuy2    = input.float(72.5, \"Buy %-from-ATH (second)\", minval=0.1, maxval=99.9, tooltip=\"Percentage drawdown from ATH(HIGH) to place the second buy.\")\r\nbuy1Pct         = input.float(10.0,  \"Equity % to Buy on first drop\",  minval=0.1, maxval=400.0)\r\nbuy2Pct         = input.float(300.0, \"Equity % to Buy on second drop\", minval=0.1, maxval=400.0)\r\n\r\n// ì²« í¬ì§€ì…˜ íŠ¹ìˆ˜ ê·œì¹™ìš© (72.5% ì´ìƒ í•˜ë½ ì‹œ ì²« ì§„ìž…ì„ 300%ë¡œ)\r\nfirstEntryHighDD = input.float(72.5, \"First Entry High DD %\", minval=0.0, maxval=99.9, tooltip=\"If FIRST position entry and drawdown from ATH is >= this %, enter with 300% of equity instead of 100%.\")\r\n\r\n// ë§¤ìˆ˜/ë ˆë²„ë¦¬ì§€ ë¼ë²¨ ìœ„ì¹˜ ì„¤ì •\r\nlabelPosOpt = input.string(\"Below Bar\", \"Entry Label Position\",\r\n     options = [\"Below Bar\", \"Above Bar\", \"At Price\"],\r\n     tooltip = \"Position of labels shown on entry (Buy / Lev labels).\")\r\nentryLabelYloc = labelPosOpt == \"Below Bar\" ? yloc.belowbar :\r\n     labelPosOpt == \"Above Bar\" ? yloc.abovebar : yloc.price\r\n\r\n// ê¸´ê¸‰ í¬ì§€ì…˜ ì²­ì‚° ìŠ¤ìœ„ì¹˜\r\nforceCloseAll = input.bool(false, \"Force Close All Positions (Kill Switch)\", tooltip=\"ONì´ë©´ í˜„ìž¬ ë§ˆì§€ë§‰ ë°” ê¸°ì¤€ìœ¼ë¡œ ëª¨ë“  í¬ì§€ì…˜ì„ ì²­ì‚°í•˜ê³ , ì´í›„ ìƒˆë¡œìš´ ì§„ìž…ì„ ë§‰ìŠµë‹ˆë‹¤.\")\r\n\r\n// ê¸°ê°„ ì œí•œ ì„¤ì • (ì „ëžµì´ ìž‘ë™í•˜ëŠ” ì‹œê°„ êµ¬ê°„)\r\n// ë¬¸ìžì—´ í•˜ë‚˜ì§œë¦¬ timestamp()ë¥¼ ì¨ì•¼ const int ë¡œ ì¸ì‹ë˜ì–´ input.time ê¸°ë³¸ê°’ì— ì‚¬ìš© ê°€ëŠ¥\r\nuseDateFilter = input.bool(false, \"Limit Strategy to Date Range?\")\r\nstartTime     = input.time(timestamp(\"01 Jan 2020 00:00 +0000\"), \"Start Date/Time\")\r\nendTime       = input.time(timestamp(\"01 Jan 2030 00:00 +0000\"), \"End Date/Time\")\r\ninTradeWindow = not useDateFilter or (time >= startTime and time <= endTime)\r\n\r\n// ì´ ë°”ì—ì„œ ì‹¤ì œë¡œ Kill ìŠ¤ìœ„ì¹˜ë¥¼ ìž‘ë™ì‹œí‚¬ì§€ ì—¬ë¶€ (í˜„ìž¬ ížˆìŠ¤í† ë¦¬ì˜ ë§ˆì§€ë§‰ ë°”ì—ì„œë§Œ ON)\r\nkillActiveThisBar = forceCloseAll and barstate.islast\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Track the current all-time high (ATH) â†’ HIGH ê¸°ì¤€\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nvar float ath = high\r\nprevAth       = ath\r\nath           := math.max(ath, high)\r\n\r\n// ìƒˆ ATHê°€ ìƒê¸°ë©´ í•´ë‹¹ ATH ê¸°ì¤€ìœ¼ë¡œ ë‹¤ì‹œ ë§¤ìˆ˜ í—ˆìš©\r\nvar bool buy1Done = false\r\nvar bool buy2Done = false\r\nif ath > prevAth\r\n    buy1Done := false\r\n    buy2Done := false\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Drawdown from ATH\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// LOW ê¸°ì¤€ ë“œë¡œìš°ë‹¤ìš´ (ëª¨ë‹ˆí„°ë§ìš©)\r\npercentFromATH = (low / ath - 1.0) * 100.0\r\n\r\n// í˜„ìž¬ê°€(ì¢…ê°€) ê¸°ì¤€ ATH ëŒ€ë¹„ í•˜ë½ë¥  (ì²« í¬ì§€ì…˜ 100%/300% íŒë‹¨ & í…Œì´ë¸”ìš©)\r\npercentFromATHNow = (close / ath - 1.0) * 100.0\r\n\r\n// ì‹¤ì œ íŠ¸ë¦¬ê±° ê°€ê²© (ATH ê¸°ì¤€ í¼ì„¼íŠ¸ í•˜ë½ ê°€ê²©)\r\ntriggerPrice1 = ath * (1.0 - drawdownBuy1 / 100.0)\r\ntriggerPrice2 = ath * (1.0 - drawdownBuy2 / 100.0)\r\n\r\n// low ê°€ íŠ¸ë¦¬ê±° ê°€ê²©ì„ ì°ëŠ” ìˆœê°„ ì¡°ê±´ ì„±ë¦½\r\nfirstBuyCond  = not buy1Done and low <= triggerPrice1\r\nsecondBuyCond = not buy2Done and low <= triggerPrice2\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Position sizing (equity ê¸°ë°˜, ë ˆë²„ë¦¬ì§€ ë°˜ì˜)\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nequityNow     = strategy.initial_capital + strategy.netprofit + strategy.openprofit\r\norderValue1   = equityNow * (buy1Pct / 100.0) * leverageInput\r\norderValue2   = equityNow * (buy2Pct / 100.0) * leverageInput\r\n\r\n// íŠ¸ë¦¬ê±° ê°€ê²© ê¸°ì¤€ í¬ì§€ì…˜ ìˆ˜ëŸ‰ (ì‹¤ì œ ì²´ê²° ê°€ê²© ê¸°ì¤€ìœ¼ë¡œ ê³„ì‚°)\r\neffectiveBuy1Qty = triggerPrice1 > 0 ? orderValue1 / triggerPrice1 : 0\r\neffectiveBuy2Qty = triggerPrice2 > 0 ? orderValue2 / triggerPrice2 : 0\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Max Drawdown (Equity ê¸°ì¤€ MDD) ê³„ì‚°\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nvar float equityPeak = equityNow\r\nvar float maxDDPerc  = 0.0 // 0ì—ì„œ ì‹œìž‘, ì´í›„ ë” ìŒìˆ˜ë¡œ ë‚´ë ¤ê°(ì†ì‹¤)\r\n\r\nequityPeak := math.max(equityPeak, equityNow)\r\nfloat ddNowEquity = equityPeak != 0.0 ? (equityNow / equityPeak - 1.0) * 100.0 : 0.0\r\nmaxDDPerc := math.min(maxDDPerc, ddNowEquity) // ê°€ìž¥ í° ì†ì‹¤(ê°€ìž¥ ìž‘ì€ ê°’) ì €ìž¥\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Bar-level state for ì‹¤ì œ ë ˆë²„ë¦¬ì§€ ê³„ì‚°\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nvar float posSizeBeforeBar  = na\r\nvar float newLongQtyThisBar = 0.0\r\n\r\nif barstate.isnew\r\n    posSizeBeforeBar  := math.abs(strategy.position_size)\r\n    newLongQtyThisBar := 0.0\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// ê¸´ê¸‰ í¬ì§€ì…˜ ì²­ì‚° ë¡œì§\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nif killActiveThisBar and strategy.position_size != 0\r\n    strategy.close_all(comment=\"Force Close All (Kill Switch)\")\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Entries + ì‹¤ì œ ë ˆë²„ë¦¬ì§€ í…ìŠ¤íŠ¸ / Buy ë¼ë²¨\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nif not killActiveThisBar and inTradeWindow\r\n    if firstBuyCond\r\n        // ì´ ë°”ì—ì„œ \"ì²« í¬ì§€ì…˜\"ì¸ì§€ ì—¬ë¶€ (ë°” ì‹œìž‘ ì‹œ í¬ì§€ì…˜ 0 & ì•„ì§ ìƒˆ ë§¤ìˆ˜ ì—†ìŒ)\r\n        bool  isFirstPositionEntry1 = posSizeBeforeBar == 0 and newLongQtyThisBar == 0\r\n        float usedQty1 = 0.0\r\n        float usedPct1 = na\r\n\r\n        if isFirstPositionEntry1\r\n            // ì²« í¬ì§€ì…˜: ê¸°ë³¸ 100%, ë‹¤ë§Œ í˜„ìž¬ ATH ëŒ€ë¹„ í•˜ë½ë¥ ì´ ì„¤ì •ê°’ ì´ìƒì´ë©´ 300%\r\n            float firstEntryPct1   = percentFromATHNow <= -firstEntryHighDD ? 300.0 : 100.0\r\n            float orderValueFirst1 = equityNow * (firstEntryPct1 / 100.0) * leverageInput\r\n            usedQty1 := triggerPrice1 > 0 ? orderValueFirst1 / triggerPrice1 : 0\r\n            usedPct1 := firstEntryPct1\r\n        else\r\n            usedQty1 := effectiveBuy1Qty\r\n            usedPct1 := buy1Pct\r\n\r\n        // ì´ ë°”ì—ì„œ ìƒˆë¡œ ì§„ìž…í•˜ëŠ” ìˆ˜ëŸ‰ ëˆ„ì \r\n        newLongQtyThisBar += usedQty1\r\n\r\n        // ì§„ìž… ì´í›„ ì˜ˆìƒ í¬ì§€ì…˜ ê°€ì¹˜ì™€ ì‹¤ì œ ë ˆë²„ë¦¬ì§€(í¬ì§€ì…˜ ê°€ì¹˜ / í˜„ìž¬ ìžì‚°)\r\n        posValueAfter = (posSizeBeforeBar + newLongQtyThisBar) * triggerPrice1\r\n        realLevAfter  = equityNow != 0 ? posValueAfter / equityNow : na\r\n        realLevText   = not na(realLevAfter) ? math.round(realLevAfter * 100.0) / 100.0 : na\r\n\r\n        if usedQty1 > 0\r\n            // ë ˆë²„ë¦¬ì§€ ë¼ë²¨\r\n            if not na(realLevText)\r\n                label.new(\r\n                     bar_index, low,\r\n                     text      = \"Lev \" + str.tostring(realLevText) + \"x\",\r\n                     yloc      = entryLabelYloc,\r\n                     style     = label.style_label_down,\r\n                     size      = size.large,\r\n                     color     = color.new(color.gray, 0),\r\n                     textcolor = color.white)\r\n\r\n            // Buy ë¼ë²¨\r\n            if not na(usedPct1)\r\n                label.new(\r\n                     bar_index, low,\r\n                     text      = \"Buy \" + str.tostring(usedPct1, format.mintick) + \"% @ \" + str.tostring(triggerPrice1, format.mintick),\r\n                     yloc      = entryLabelYloc,\r\n                     style     = label.style_label_up,\r\n                     color     = color.new(color.lime, 10),\r\n                     textcolor = color.black,\r\n                     size      = size.large)\r\n\r\n        // íŠ¸ë¦¬ê±° ê°€ê²©ì— ë¦¬ë°‹ ì£¼ë¬¸\r\n        strategy.entry(\"Buy_1\", strategy.long, qty=usedQty1, limit=triggerPrice1,\r\n             comment=\"ATH -\" + str.tostring(drawdownBuy1) + \"%\")\r\n        buy1Done := true\r\n\r\n\r\n    if secondBuyCond\r\n        bool  isFirstPositionEntry2 = posSizeBeforeBar == 0 and newLongQtyThisBar == 0\r\n        float usedQty2 = 0.0\r\n        float usedPct2 = na\r\n\r\n        if isFirstPositionEntry2\r\n            // ì²« í¬ì§€ì…˜ì´ 2ì°¨ ë“œë¡œìš°ë‹¤ìš´ì—ì„œ ìž¡ížˆëŠ” ê²½ìš°ì—ë„ ë™ì¼ ê·œì¹™ ì ìš©\r\n            float firstEntryPct2   = percentFromATHNow <= -firstEntryHighDD ? 300.0 : 100.0\r\n            float orderValueFirst2 = equityNow * (firstEntryPct2 / 100.0) * leverageInput\r\n            usedQty2 := triggerPrice2 > 0 ? orderValueFirst2 / triggerPrice2 : 0\r\n            usedPct2 := firstEntryPct2\r\n        else\r\n            usedQty2 := effectiveBuy2Qty\r\n            usedPct2 := buy2Pct\r\n\r\n        newLongQtyThisBar += usedQty2\r\n\r\n        posValueAfter2 = (posSizeBeforeBar + newLongQtyThisBar) * triggerPrice2\r\n        realLevAfter2  = equityNow != 0 ? posValueAfter2 / equityNow : na\r\n        realLevText2   = not na(realLevAfter2) ? math.round(realLevAfter2 * 100.0) / 100.0 : na\r\n\r\n        if usedQty2 > 0\r\n            // ë ˆë²„ë¦¬ì§€ ë¼ë²¨\r\n            if not na(realLevText2)\r\n                label.new(\r\n                     bar_index, low,\r\n                     text      = \"Lev \" + str.tostring(realLevText2) + \"x\",\r\n                     yloc      = entryLabelYloc,\r\n                     style     = label.style_label_down,\r\n                     size      = size.large,\r\n                     color     = color.new(color.gray, 0),\r\n                     textcolor = color.white)\r\n\r\n            // Buy ë¼ë²¨\r\n            if not na(usedPct2)\r\n                label.new(\r\n                     bar_index, low,\r\n                     text      = \"Buy \" + str.tostring(usedPct2, format.mintick) + \"% @ \" + str.tostring(triggerPrice2, format.mintick),\r\n                     yloc      = entryLabelYloc,\r\n                     style     = label.style_label_up,\r\n                     color     = color.new(color.teal, 10),\r\n                     textcolor = color.black,\r\n                     size      = size.large)\r\n\r\n        strategy.entry(\"Buy_2\", strategy.long, qty=usedQty2, limit=triggerPrice2,\r\n             comment=\"ATH -\" + str.tostring(drawdownBuy2) + \"%\")\r\n        buy2Done := true\r\n\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// í‰ë‹¨ê°€(í¬ì§€ì…˜ í‰ê·  ì§„ìž…ê°€) ê³„ì‚° ë° í”Œë¡œíŒ…\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\navgEntryPrice = strategy.position_size != 0 ? strategy.position_avg_price : na\r\nplot(avgEntryPrice, title=\"Avg Entry Price (í‰ë‹¨ê°€)\", color=color.yellow, linewidth=2)\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// í˜„ìž¬ í¬ì§€ì…˜ / ë ˆë²„ë¦¬ì§€ / \"ê³ ì •\" ì²­ì‚°ê°€\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nposQtyNow     = strategy.position_size\r\nposQtyAbsNow  = math.abs(posQtyNow)\r\nposValueNow   = posQtyAbsNow * close\r\nrealLevNow    = equityNow != 0 ? posValueNow / equityNow : na\r\n\r\n// ë§ˆì§€ë§‰ í¬ì§€ì…˜ ìƒíƒœ ê¸°ì¤€ìœ¼ë¡œ ê³ ì •í•  ì²­ì‚°ê°€\r\nvar float liqPriceFixed = na\r\n// ì´ì „ í¬ì§€ì…˜ ìˆ˜ëŸ‰ ì €ìž¥ìš©\r\nvar float prevPosSize = 0.0\r\n\r\n// âœ… ìµœê·¼ í¬ì§€ì…˜ ì§„ìž… ì •ë³´ ì €ìž¥ìš© (í…Œì´ë¸”ì—ì„œ ì“°ëŠ” ê°’)\r\nvar float lastEntryPrice = na\r\nvar float lastEntryLev   = na\r\n\r\nif barstate.isnew\r\n    // í¬ì§€ì…˜ ìˆ˜ëŸ‰ ë³€í™” ê°ì§€\r\n    bool posChanged = posQtyNow != prevPosSize\r\n\r\n    if posChanged\r\n        // í¬ì§€ì…˜ì´ ìƒˆë¡œ ìƒê¸°ê±°ë‚˜ / ëŠ˜ì–´ë‚˜ê±°ë‚˜ / ì¤„ì–´ë“  ì‹œì ë§ˆë‹¤ í•œ ë²ˆë§Œ ì²­ì‚°ê°€ ìž¬ê³„ì‚°\r\n        if posQtyNow > 0 and not na(avgEntryPrice) and not na(realLevNow) and realLevNow > 1\r\n            // ì‹¤ë ˆë²„ë¦¬ì§€(realLevNow) + í‰ë‹¨ ê¸°ì¤€ ì²­ì‚°ê°€ (ê·¼ì‚¬ì¹˜)\r\n            liqPriceFixed := avgEntryPrice * (1.0 - 1.0 / realLevNow)\r\n        else\r\n            // í¬ì§€ì…˜ì´ ì—†ì–´ì¡Œê±°ë‚˜ 1ë°° ì´í•˜ë©´ ë¼ì¸ ì œê±°\r\n            liqPriceFixed := na\r\n\r\n        // âœ… ìµœê·¼ í¬ì§€ì…˜ ì§„ìž… ì •ë³´ ì—…ë°ì´íŠ¸\r\n        if posQtyNow > prevPosSize and posQtyNow > 0\r\n            // ìƒˆë¡œ ì§„ìž…(ì¦ëŸ‰)ëœ ê²½ìš°ì—ë§Œ ì—…ë°ì´íŠ¸\r\n            lastEntryPrice := avgEntryPrice\r\n            float posValAfterFill = math.abs(posQtyNow) * avgEntryPrice\r\n            lastEntryLev   := equityNow != 0 ? posValAfterFill / equityNow : na\r\n        else if posQtyNow <= 0\r\n            // í¬ì§€ì…˜ì´ ì—†ì–´ì§€ë©´ ì´ˆê¸°í™”\r\n            lastEntryPrice := na\r\n            lastEntryLev   := na\r\n\r\n        // í˜„ìž¬ í¬ì§€ì…˜ ì‚¬ì´ì¦ˆë¥¼ ë‹¤ìŒ ë°” ë¹„êµìš©ìœ¼ë¡œ ì €ìž¥\r\n        prevPosSize := posQtyNow\r\n\r\n\r\n// ì°¨íŠ¸ì— ë¹¨ê°„ìƒ‰ ì„ ìœ¼ë¡œ í‘œì‹œ (ê³ ì •í˜• ì²­ì‚°ê°€)\r\nplot(liqPriceFixed, title=\"Estimated Liquidation Price (ê³ ì •í˜• ì²­ì‚°ê°€)\", color=color.red, linewidth=2, style=plot.style_linebr)\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Visuals: ATH, buy markers\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nplot(ath, color=color.orange, linewidth=2, title=\"ATH (HIGH ê¸°ë°˜)\")\r\n\r\nplotshape(firstBuyCond and not killActiveThisBar and inTradeWindow,  title=\"First Buy\",  style=shape.triangleup, color=color.lime, size=size.tiny,  location=location.belowbar, text=\"Buy\")\r\nplotshape(secondBuyCond and not killActiveThisBar and inTradeWindow, title=\"Second Buy\", style=shape.triangleup, color=color.teal, size=size.small, location=location.belowbar, text=\"Buy\")\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// Info table (í˜„ìž¬ í¬ì§€ì…˜ ì •ë³´ + ë“œë¡œìš°ë‹¤ìš´ + ìˆ˜ìµë¥  + MDD)\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nvar table info = table.new(position.top_right, 2, 11, border_width=1)\r\n\r\nif barstate.islast\r\n    // í˜„ìž¬ í¬ì§€ì…˜ ê´€ë ¨ ì •ë³´ ê³„ì‚°\r\n    posQty       = strategy.position_size\r\n    posQtyAbs    = math.abs(posQty)\r\n    posValueNowT = posQtyAbs * close\r\n    realLevNowT  = equityNow != 0 ? posValueNowT / equityNow : na\r\n    ddFromAthNow = percentFromATHNow\r\n    avgPrice     = avgEntryPrice\r\n    posCost      = posQtyAbs * avgPrice\r\n    pnlPerc      = posCost != 0 ? strategy.openprofit / posCost * 100.0 : na\r\n\r\n    // ê³„ì¢Œ ì „ì²´ ìˆ˜ìµë¥  (í˜„ìž¬ ì†ì‹¤ í¬í•¨)\r\n    equityReturnPerc = strategy.initial_capital != 0 ? (equityNow / strategy.initial_capital - 1.0) * 100.0 : na\r\n\r\n    bg  = color.new(color.blue, 0)\r\n    txt = color.white\r\n\r\n    // 0í–‰: í† í° ìˆ˜ëŸ‰\r\n    table.cell(info, 0, 0, \"Pos Qty (Token)\", bgcolor=bg, text_color=txt)\r\n    table.cell(info, 1, 0, posQtyAbs != 0 ? str.tostring(posQtyAbs, format.mintick) : \"0\", bgcolor=bg, text_color=txt)\r\n\r\n    // 1í–‰: í¬ì§€ì…˜ ê°€ì¹˜ (USDT)\r\n    table.cell(info, 0, 1, \"Pos Value (USDT)\", bgcolor=bg, text_color=txt)\r\n    table.cell(info, 1, 1, posValueNowT != 0 ? str.tostring(posValueNowT, format.mintick) : \"0\", bgcolor=bg, text_color=txt)\r\n\r\n    // 2í–‰: í˜„ìž¬ ë ˆë²„ë¦¬ì§€\r\n    table.cell(info, 0, 2, \"Leverage (Now)\", bgcolor=bg, text_color=txt)\r\n    table.cell(info, 1, 2, not na(realLevNowT) ? str.tostring(realLevNowT, format.mintick) + \"x\" : \"0x\", bgcolor=bg, text_color=txt)\r\n\r\n    // 3í–‰: ìµœê·¼ ATH ëŒ€ë¹„ í•˜ë½ë¥  (í˜„ìž¬ê°€ ê¸°ì¤€)\r\n    table.cell(info, 0, 3, \"DD from ATH (%)\", bgcolor=bg, text_color=txt)\r\n    table.cell(info, 1, 3, not na(ddFromAthNow) ? str.tostring(ddFromAthNow, format.mintick) : \"N/A\", bgcolor=bg, text_color=txt)\r\n\r\n    // 4í–‰: í˜„ìž¬ í¬ì§€ì…˜ í‰ë‹¨ê°€\r\n    table.cell(info, 0, 4, \"Avg Entry\", bgcolor=bg, text_color=txt)\r\n    table.cell(info, 1, 4, not na(avgPrice) ? str.tostring(avgPrice, format.mintick) : \"N/A\", bgcolor=bg, text_color=txt)\r\n\r\n    // 5í–‰: ê³„ì¢Œ ì „ì²´ ìˆ˜ìµë¥  (Equity ê¸°ì¤€, í˜„ìž¬ ì†ì‹¤ í¬í•¨)\r\n    table.cell(info, 0, 5, \"Equity Return (%)\", bgcolor=bg, text_color=txt)\r\n    table.cell(info, 1, 5, not na(equityReturnPerc) ? str.tostring(equityReturnPerc, format.mintick) : \"N/A\", bgcolor=bg, text_color=txt)\r\n\r\n    // 6í–‰: í˜„ìž¬ í¬ì§€ì…˜ ìˆ˜ìµë¥  (%)\r\n    table.cell(info, 0, 6, \"Pos PnL (%)\", bgcolor=bg, text_color=txt)\r\n    table.cell(info, 1, 6, not na(pnlPerc) ? str.tostring(pnlPerc, format.mintick) : \"N/A\", bgcolor=bg, text_color=txt)\r\n\r\n    // 7í–‰: í¬ì§€ì…˜/ê³„ì¢Œ ê¸°ì¤€ ì—­ëŒ€ ìµœëŒ€ ì†ì‹¤ MDD (Equity ê¸°ì¤€)\r\n    table.cell(info, 0, 7, \"Max DD (Equity %)\", bgcolor=bg, text_color=txt)\r\n    table.cell(info, 1, 7, str.tostring(maxDDPerc, format.mintick), bgcolor=bg, text_color=txt)\r\n\r\n    // 8í–‰: ìµœê·¼ í¬ì§€ì…˜ ì§„ìž… ê°€ê²©\r\n    table.cell(info, 0, 8, \"Last Entry Price\", bgcolor=bg, text_color=txt)\r\n    table.cell(info, 1, 8, not na(lastEntryPrice) ? str.tostring(lastEntryPrice, format.mintick) : \"N/A\", bgcolor=bg, text_color=txt)\r\n\r\n    // 9í–‰: ìµœê·¼ í¬ì§€ì…˜ ì§„ìž… ì‹œ ë ˆë²„ë¦¬ì§€\r\n    table.cell(info, 0, 9, \"Last Entry Lev\", bgcolor=bg, text_color=txt)\r\n    table.cell(info, 1, 9, not na(lastEntryLev) ? str.tostring(lastEntryLev, format.mintick) + \"x\" : \"N/A\", bgcolor=bg, text_color=txt)\r\n\r\n    // 10í–‰: ê³ ì •í˜• ì²­ì‚°ê°€\r\n    table.cell(info, 0, 10, \"Liq Price (Fixed)\", bgcolor=bg, text_color=txt)\r\n    table.cell(info, 1, 10, not na(liqPriceFixed) ? str.tostring(liqPriceFixed, format.mintick) : \"N/A\", bgcolor=bg, text_color=txt)\r\n"
  },
  {
    "url": "eCimD9eX-15m-ORB-FVG-Strategy-ChadAnt",
    "name": "15m ORB + FVG Strategy (ChadAnt)",
    "description": "Core Logic\nThe indicator's logic revolves around three main phases:\n1. Defining the 15-Minute Opening Range (ORB)\nThe script calculates the highest high (rangeHigh) and lowest low (rangeLow) that occurred during the first 15 minutes of the trading day.\nThis time window is defined by the sessionStr input, which defaults to 0930-0945 (exchange time).\nThe high and low of this range are plotted as small gray dots once the session ends (rangeSet = true).\n\n2. Identifying a Fair Value Gap (FVG) Setup\nAfter the 15-minute range is set, the indicator waits for a breakout of either the range high or range low.\nA \"Strict FVG breakout\" requires two conditions on the first candle that closes beyond the range:\nThe candle before the breakout candle (  bars ago) must have been inside the range.\nThe breakout candle (  bar ago) must have closed outside the range.\nA Fair Value Gap (FVG) must form on the most recent three candles (the current bar and the two previous bars).\nBullish FVG (Long Setup): The low of the current bar (low) is greater than the high of the bar two periods prior (high ). This FVG represents a price inefficiency that the trade expects to fill.\nBearish FVG (Short Setup): The high of the current bar (high) is less than the low of the bar two periods prior (low ).\nIf a valid FVG setup occurs, the indicator marks a pending setup and draws a colored box to highlight the FVG area (Green for Bullish FVG, Red for Bearish FVG).\n\n3. Trade Entry and Management\nIf a pending setup is identified, the trade is structured as a re-entry trade into the FVG zone:\nEntry Price: Set at the outer boundary of the FVG, which is the low of the current bar for a Long setup, or the high of the current bar for a Short setup.\nStop Loss (SL): Set at the opposite boundary of the FVG, which is the low  for a Long setup, or the high  for a Short setup.\nThe trade is triggered (tradeActive = true) once the price retraces to the pendingEntry level.\nRisk/Reward (RR) Targets: Three Take Profit (TP) levels are calculated based on the distance between the Entry and Stop Loss:\n$$\\text{Risk} = | \\text{Entry} - \\text{SL} |$$\n$$\\text{TP}n = \\text{Entry} \\pm (\\text{Risk} \\times \\text{RR}n)$$\nwhere $n$ is 1, 2, or 3, corresponding to the input $\\text{RR}1$, $\\text{RR}2$, and $\\text{RR}3$ values (defaults: 1.0, 1.5, and 2.0).\nTrade Lines: Upon triggering, lines for the Entry, Stop Loss, and three Take Profit levels are drawn on the chart for a specified length (lineLength).\n\nA crucial feature is the directional lock (highBroken / lowBroken):\n\nIf the price breaks a range level (e.g., simpleBrokeHigh) but without a valid FVG setup, the corresponding directional flag (e.g., highBroken) is set to true permanently for the day.\n\nThis prevents the indicator from looking for any subsequent trade setups in that direction for the rest of the day, suggesting that the initial move, without an FVG, exhausted the opportunity.\nOpen-source script\n\nIn true TradingView spirit, the creator of this script has made it open-source, so that traders can review and verify its functionality. Kudos to the author! While you can use it for free, remember that republishing the code is subject to our House Rules.\n\n\nChadAnt\nDisclaimer\nThe information and publications are not meant to be, and do not constitute, financial, investment, trading, or other types of advice or recommendations supplied ",
    "image_url": "eCimD9eX",
    "author": "ChadAnt",
    "likes": 60,
    "type": "strategy",
    "created": "2025-11-21",
    "updated": "2025-11-21",
    "source": "//@version=5\nstrategy(\"15m ORB + FVG Strategy (ChadAnt)\", overlay=true, default_qty_type=strategy.percent_of_equity, default_qty_value=100)\n\n// --- INPUTS: STRATEGY ---\ngrp_strat    = \"Strategy Settings\"\nsessionStr   = input.session(\"0930-0945\", \"First 15 Min Session (Exchange Time)\", group=grp_strat)\nexpiryTime   = input.session(\"1200-1201\", \"Entry Expiration Time\", group=grp_strat)\nuseExpiry    = input.bool(true, \"Use Expiration Time?\", group=grp_strat)\ncloseEOD     = input.bool(true, \"Close Position at End of Day?\", group=grp_strat)\neodTime      = input.session(\"1555-1556\", \"End of Day Close Time\", group=grp_strat)\nrr1          = input.float(1.0, \"Risk Reward 1\", group=grp_strat)\nrr2          = input.float(1.5, \"Risk Reward 2\", group=grp_strat)\nrr3          = input.float(2.0, \"Risk Reward 3\", group=grp_strat)\ntpLevel      = input.string(\"TP1\", \"Take Profit Level\", options=[\"TP1\", \"TP2\", \"TP3\"], group=grp_strat)\n\n// --- INPUTS: FVG APPEARANCE ---\ngrp_fvg      = \"FVG Appearance\"\nfvgBullColor = input.color(color.new(color.green, 80), \"Bullish FVG Color\", group=grp_fvg)\nfvgBearColor = input.color(color.new(color.red, 80), \"Bearish FVG Color\", group=grp_fvg)\nfvgLength    = input.int(10, \"FVG Box Length (bars)\", minval=1, group=grp_fvg)\n\n// --- INPUTS: LINE APPEARANCE ---\ngrp_look     = \"Line Appearance\"\nlineLength   = input.int(10, \"Line Length (bars)\", minval=1, group=grp_look)\n\nentryColor   = input.color(color.blue, \"Entry Color\", group=grp_look)\nentryStyle   = input.string(\"Solid\", \"Entry Style\", options=[\"Solid\", \"Dashed\", \"Dotted\"], group=grp_look)\nentryWidth   = input.int(2, \"Entry Width\", minval=1, group=grp_look)\n\nslColor      = input.color(color.red, \"Stop Loss Color\", group=grp_look)\nslStyle      = input.string(\"Solid\", \"Stop Loss Style\", options=[\"Solid\", \"Dashed\", \"Dotted\"], group=grp_look)\nslWidth      = input.int(2, \"Stop Loss Width\", minval=1, group=grp_look)\n\ntpColor      = input.color(color.green, \"TP Color\", group=grp_look)\ntpStyle      = input.string(\"Dashed\", \"TP Style\", options=[\"Solid\", \"Dashed\", \"Dotted\"], group=grp_look)\ntpWidth      = input.int(1, \"TP Width\", minval=1, group=grp_look)\n\ngetStyle(styleStr) =>\n    styleStr == \"Solid\" ? line.style_solid : styleStr == \"Dashed\" ? line.style_dashed : line.style_dotted\n\n// --- STATE VARIABLES ---\nvar float rangeHigh = na\nvar float rangeLow = na\nvar bool rangeSet = false\n\n// Directional flags - locks when price crosses the level\nvar bool highBroken = false\nvar bool lowBroken = false\n\n// Trade States\nvar bool orderPlaced = false\nvar string setupType = na              \n\nvar float pendingEntry = na        \nvar float pendingSL = na           \nvar float pendingTP = na\n\n// --- SESSION LOGIC ---\nisInSession = time(timeframe.period, sessionStr)\nisNewDay = ta.change(time(\"D\"))\nisEOD = time(timeframe.period, eodTime)\n\n// Reset everything at start of new day\nif isNewDay\n    rangeHigh := na\n    rangeLow := na\n    rangeSet := false\n    orderPlaced := false\n    highBroken := false\n    lowBroken := false\n    setupType := na\n    pendingEntry := na\n    pendingSL := na\n    pendingTP := na\n\n// --- CLOSE AT END OF DAY ---\nif closeEOD and isEOD and strategy.position_size != 0\n    strategy.close_all(\"EOD Close\")\n\n// --- CANCEL ORDERS AT END OF DAY ---\nif closeEOD and isEOD and orderPlaced and strategy.position_size == 0\n    strategy.cancel_all()\n    orderPlaced := false\n\n// --- CALCULATE 15 MIN RANGE ---\nif isInSession\n    rangeHigh := na(rangeHigh) ? high : math.max(rangeHigh, high)\n    rangeLow  := na(rangeLow) ? low : math.min(rangeLow, low)\nelse\n    if not na(rangeHigh) and not rangeSet\n        rangeSet := true\n\n// Plot Range Dots\nplot(rangeSet ? rangeHigh : na, color=color.new(color.gray, 50), style=plot.style_circles, title=\"15m High\")\nplot(rangeSet ? rangeLow : na, color=color.new(color.gray, 50), style=plot.style_circles, title=\"15m Low\")\n\n// --- FVG DEFINITIONS ---\nisBullFVG = low > high[2]\nisBearFVG = high < low[2]\n\n// STRICT FVG breakout condition\nbrokeHighStrict = close[1] > rangeHigh and high[2] <= rangeHigh\nbrokeLowStrict  = close[1] < rangeLow and low[2] >= rangeLow\n\n// Simple breakout for locking\nsimpleBrokeHigh = close[1] > rangeHigh\nsimpleBrokeLow  = close[1] < rangeLow\n\n// --- GET SELECTED TP LEVEL ---\ngetSelectedTP(entry, sl, isLong) =>\n    risk = math.abs(entry - sl)\n    rr = tpLevel == \"TP1\" ? rr1 : tpLevel == \"TP2\" ? rr2 : rr3\n    isLong ? entry + (risk * rr) : entry - (risk * rr)\n\n// --- UNIFIED DETECTION BLOCK ---\nif rangeSet and not orderPlaced and barstate.isconfirmed\n\n    // --- LONG SIDE ---\n    if not highBroken\n        if brokeHighStrict and isBullFVG\n            setupType := \"Long\"\n            pendingEntry := low      \n            pendingSL := low[2]   \n            pendingTP := getSelectedTP(pendingEntry, pendingSL, true)\n\n            box.new(bar_index[2], high[2], bar_index + fvgLength, low, border_color=na, bgcolor=fvgBullColor)\n            \n            line.new(bar_index, pendingEntry, bar_index + lineLength, pendingEntry, color=entryColor, style=getStyle(entryStyle), width=entryWidth)\n            line.new(bar_index, pendingSL, bar_index + lineLength, pendingSL, color=slColor, style=getStyle(slStyle), width=slWidth)\n            line.new(bar_index, pendingEntry + (pendingEntry - pendingSL) * rr1, bar_index + lineLength, pendingEntry + (pendingEntry - pendingSL) * rr1, color=tpColor, style=getStyle(tpStyle), width=tpWidth)\n            line.new(bar_index, pendingEntry + (pendingEntry - pendingSL) * rr2, bar_index + lineLength, pendingEntry + (pendingEntry - pendingSL) * rr2, color=tpColor, style=getStyle(tpStyle), width=tpWidth)\n            line.new(bar_index, pendingEntry + (pendingEntry - pendingSL) * rr3, bar_index + lineLength, pendingEntry + (pendingEntry - pendingSL) * rr3, color=tpColor, style=getStyle(tpStyle), width=tpWidth)\n            \n            strategy.entry(\"Long\", strategy.long, limit=pendingEntry)\n            strategy.exit(\"Long Exit\", \"Long\", stop=pendingSL, limit=pendingTP)\n            \n            orderPlaced := true\n            highBroken := true\n            \n        else if simpleBrokeHigh\n            highBroken := true\n\n    // --- SHORT SIDE ---\n    if not lowBroken\n        if brokeLowStrict and isBearFVG\n            setupType := \"Short\"\n            pendingEntry := high     \n            pendingSL := high[2]  \n            pendingTP := getSelectedTP(pendingEntry, pendingSL, false)\n\n            box.new(bar_index[2], low[2], bar_index + fvgLength, high, border_color=na, bgcolor=fvgBearColor)\n            \n            line.new(bar_index, pendingEntry, bar_index + lineLength, pendingEntry, color=entryColor, style=getStyle(entryStyle), width=entryWidth)\n            line.new(bar_index, pendingSL, bar_index + lineLength, pendingSL, color=slColor, style=getStyle(slStyle), width=slWidth)\n            line.new(bar_index, pendingEntry - (pendingSL - pendingEntry) * rr1, bar_index + lineLength, pendingEntry - (pendingSL - pendingEntry) * rr1, color=tpColor, style=getStyle(tpStyle), width=tpWidth)\n            line.new(bar_index, pendingEntry - (pendingSL - pendingEntry) * rr2, bar_index + lineLength, pendingEntry - (pendingSL - pendingEntry) * rr2, color=tpColor, style=getStyle(tpStyle), width=tpWidth)\n            line.new(bar_index, pendingEntry - (pendingSL - pendingEntry) * rr3, bar_index + lineLength, pendingEntry - (pendingSL - pendingEntry) * rr3, color=tpColor, style=getStyle(tpStyle), width=tpWidth)\n            \n            strategy.entry(\"Short\", strategy.short, limit=pendingEntry)\n            strategy.exit(\"Short Exit\", \"Short\", stop=pendingSL, limit=pendingTP)\n            \n            orderPlaced := true\n            lowBroken := true\n            \n        else if simpleBrokeLow\n            lowBroken := true\n\n// --- CHECK EXPIRATION ---\nif useExpiry and orderPlaced and strategy.position_size == 0\n    if time(timeframe.period, expiryTime)\n        strategy.cancel_all()\n        orderPlaced := false"
  },
  {
    "url": "2lReWXAY-Risk-Managed-Strategy",
    "name": "Risk-Managed Strategy",
    "description": "Risk-Managed Strategy is a complete algorithmic trading framework that blends multiple technical systemsâ€”RSI, MACD, EMA crossover, Bollinger Bands, and SuperTrendâ€”into a unified signal engine.\n\nThe script dynamically calculates position size based on capital, risk percentage, ATR-based stop loss, and reward-ratio targets.\n\nIt features:\n-Multi-indicator signal voting (BUY / SELL / NEUTRAL)\n- Dynamic capital tracking across trades\n- Automatic position sizing based on risk amount\n- Auto-generated Stop Loss and Take Profit using recent highs/lows\n- On-chart SL, TP, and CMP plotting for clarity\n\nThis strategy is designed for traders who want a professional, rule-based system that balances accuracy, risk control, and automation.\n\n\nDisclaimer:\nThe information provided is for educational and informational purposes only. It does not constitute financial or investment advice. Trading and investing in stocks involves risk, including the possible loss of capital. Any decisions to buy, sell, or hold securities are the sole responsibility of the reader. Past performance is not indicative of future results. Always do your own research and, if necessary, consult with a licensed financial advisor before making investment decisions.\n",
    "image_url": "2lReWXAY",
    "author": "AlphaFox-Traders",
    "likes": 3,
    "type": "strategy",
    "created": "2025-11-21",
    "updated": "2025-11-21",
    "source": "//@version=6\r\nstrategy(\"Fox Strategy\", overlay=true, fill_orders_on_standard_ohlc = true, calc_on_every_tick = true, max_labels_count=500)\r\n\r\n\r\nshow_rsi   = input.bool(true,  \"RSI\")\r\nshow_macd  = input.bool(true,  \"MACD\")\r\nshow_ema   = input.bool(true,  \"EMA\")\r\nshow_bb    = input.bool(true,  \"Bollinger Bands\")\r\nshow_supertrend = input.bool(true,  \"Super Trend\")\r\n\r\ncmp = close\r\ncapital           = input.float(10000.0, \"Total Capital (SAR)\", group = \"Capital Details\")\r\nrisk_percent      = input.float(1.0, \"Risk per Trade (%)\", step=0.1, group = \"Capital Details\")\r\nreward_ratio      = input.float(2.0, \"Risk:Reward Ratio\", step=0.1, group = \"Capital Details\")\r\nlookback_high_low = input.int(10, \"Lookback Period for High/Low\", minval=1, group = \"Capital Details\")\r\nmin_stocks           = input.float(1.0, \"Minimum Stocks\", group = \"Capital Details\")\r\n\r\natrPeriod = input(10, \"ATR Length\", group = \"Super Trend\")\r\nfactor = input.float(3.0, \"Factor\", step = 0.01, group = \"Super Trend\")\r\n\r\nrsi_len       = input.int(14, \"RSI length\", group = \"RSI\")\r\n\r\nmacd_fast     = input.int(12, \"MACD fast\", group = \"MACD\")\r\nmacd_slow     = input.int(26, \"MACD slow\", group = \"MACD\")\r\nmacd_smoothing  = input.int(9,  \"MACD signal Smoothing\", group = \"MACD\")\r\nema_short_len = input.int(20, \"EMA short\", group = \"Moving Averages\")\r\nema_long_len  = input.int(50, \"EMA long\", group = \"Moving Averages\")\r\nbb_len        = input.int(20, \"BB length\", group = \"Bolinger Bands\")\r\nbb_mult       = input.float(2.0, \"BB multiplier\", group = \"Bolinger Bands\")\r\n\r\n\r\n\r\nrecentHigh  = ta.highest(high, lookback_high_low)\r\nrecentLow   = ta.lowest(low, lookback_high_low)\r\n\r\nstop_loss    = recentLow\r\ntake_profit  = cmp + (cmp - recentLow) * reward_ratio//recentHigh//cmp + (cmp - recentLow) * reward_ratio\r\n\r\ntotal_closed_profit = 0.0\r\nfor i = 0 to strategy.closedtrades - 1\r\n    total_closed_profit += strategy.closedtrades.profit(i)\r\n\r\nopen_profit = strategy.opentrades > 0 ? strategy.opentrades.profit(0) : 0.0\r\nnew_capital = capital + total_closed_profit + open_profit\r\n\r\n\r\nrisk_amount = new_capital * (risk_percent / 100.0)\r\nrisk_per_unit  = math.abs(cmp - stop_loss)\r\nqty_raw  = risk_per_unit > 0 ? (risk_amount / risk_per_unit) : 0.0\r\nroundQty(q) =>\r\n    if min_stocks >= 1.0\r\n        math.max(math.round(q), 0)\r\n    else\r\n        step = min_stocks\r\n        rounded = math.round(q / step) * step\r\n        math.max(rounded, 0.0)\r\n\r\nqty  = roundQty(qty_raw)\r\n//qty = qty_raw\r\n\r\n\r\nfloat s_close = close\r\ns_high  = high \r\ns_low   = low \r\n\r\nrsi_val = show_rsi ? ta.rsi(close, rsi_len) : na\r\n\r\n[_, direction] = ta.supertrend(factor, atrPeriod)\r\n\r\nsuper_trend = show_supertrend ? direction : na\r\n\r\nmacd_line = show_macd ? ta.ema(close, macd_fast) - ta.ema(close, macd_slow) : na\r\nmacd_sig  = show_macd ? ta.ema(macd_line, macd_smoothing) : na\r\nmacd_hist = show_macd ? macd_line - macd_sig : na\r\n\r\nema_short = show_ema ? ta.ema(close, ema_short_len) : na\r\nema_long  = show_ema ? ta.ema(close, ema_long_len) : na\r\nema_diff  = show_ema ? ema_short - ema_long : na\r\n\r\nbb_basis = show_bb ? ta.sma(close, bb_len) : na\r\nbb_dev   = show_bb ? ta.stdev(close, bb_len) : na\r\nbb_upper = show_bb ? bb_basis + bb_mult * bb_dev : na\r\nbb_lower = show_bb ? bb_basis - bb_mult * bb_dev : na\r\n\r\n\r\n\r\nsuptrnd_signal = show_supertrend and not na(super_trend) ? (super_trend <0 ? \"BUY\" : super_trend > 0 ? \"SELL\" : \"NEUTRAL\") : \"OFF\"\r\nrsi_signal  = show_rsi and not na(rsi_val) ? (rsi_val < 30 ? \"BUY\" : rsi_val > 70 ? \"SELL\" : \"NEUTRAL\") : \"OFF\"\r\nmacd_signal = show_macd and not na(macd_hist) ? (macd_hist > 0 ? \"BUY\" : macd_hist < 0 ? \"SELL\" : \"NEUTRAL\") : \"OFF\"\r\nema_signal  = show_ema and not na(ema_diff) ? (ema_diff > 0 ? \"BUY\" : ema_diff < 0 ? \"SELL\" : \"NEUTRAL\") : \"OFF\"\r\nbb_signal   = show_bb and not na(bb_basis) ? (s_close < bb_lower ? \"BUY\" : s_close > bb_upper ? \"SELL\" : \"NEUTRAL\") : \"OFF\"\r\n\r\n\r\n\r\n\r\nbuyCount  = (rsi_signal == \"BUY\" ? 1 : 0) + (macd_signal == \"BUY\" ? 1 : 0) + (ema_signal == \"BUY\" ? 1 : 0) + (bb_signal == \"BUY\" ? 1 : 0) + (suptrnd_signal == \"BUY\" ? 1 : 0)\r\nsellCount = (rsi_signal == \"SELL\" ? 1 : 0) + (macd_signal == \"SELL\" ? 1 : 0) + (ema_signal == \"SELL\" ? 1 : 0) + (bb_signal == \"SELL\" ? 1 : 0)+ (suptrnd_signal == \"SELL\" ? 1 : 0)\r\ntotal_signal = buyCount > sellCount ? \"BUY\" : sellCount > buyCount ? \"SELL\" : \"NEUTRAL\"\r\n\r\n\r\nif(total_signal == \"BUY\") and (qty > 0)\r\n    strategy.entry(\"Buy\", strategy.long, qty,comment = str.tostring(new_capital)  )\r\n    strategy.exit(\"Sell\", from_entry=\"Buy\", stop=stop_loss, limit=take_profit)\r\n\r\nplot(cmp, \"CMP\", color=color.new(color.blue, 0))\r\nplot(stop_loss, \"Stop Loss\", color=color.new(color.red, 0))\r\nplot(take_profit, \"Take Profit\", color=color.new(color.green, 0))\r\n\r\nif barstate.islast\r\n    current_profit = strategy.netprofit\r\n    total_with_profit = capital + current_profit\r\n    info_text = \"Capital: \" + str.tostring(capital, format.volume) + \"\\n\" + \"Total Capital: \" + str.tostring(total_with_profit, format.volume) + \"\\n\" + \"Net Profit: \" + str.tostring(current_profit, format.volume) + \"\\n\" + \"Risk %: \" + str.tostring(risk_percent, format.percent) + \"\\n\" + \"Risk Amount: \" + str.tostring(risk_amount, format.volume) + \"\\n\" + \"Qty Long: \" + str.tostring(qty, format.volume) + \"\\n\" + \"SL: \" + str.tostring(stop_loss, format.mintick) + \"\\n\" + \"TP: \" + str.tostring(take_profit, format.mintick)\r\n \r\n\r\nalertTitle = \"Trading Alert!\" \r\ncurrentPrice = str.tostring(s_close, format.mintick)\r\nalertDescription = \"BUY Call @ CMP\"\r\ndiscordJSON = '{\"username\": \"TradingView Bot\", \"embeds\":[{\"title\": \"' + alertTitle + '\",\"description\": \"' + alertDescription + '\\\\nCurrent Price: ' + currentPrice + '\",\"color\": 3066993}]}'\r\n\r\nif (total_signal == \"BUY\")\r\n    alert(discordJSON, alert.freq_once_per_bar_close)\r\n\r\n"
  },
  {
    "url": "SKEvwrNo",
    "name": "CNN Fear and Greed Strategy",
    "description": "Adaptation of the CNN Fear and Greed Index Indicator (Original by EdgeTools)\n\n\nThe following changes have been implemented:\n \n Put/Call Ratio Data Source: The data source for the Put/Call Ratio has been updated.\n Bond Data Source: The data sources for the bond components (Safe Haven Demand and Junk Bond Demand) have been updated.\n Normalization Adjustment: The normalization method has been adjusted to allow the CNN Fear and Greed Index to display over a longer historical period, optimizing it for backtesting purposes.\n Style Modification: The display style has been modified for a simpler and cleaner appearance.\n Strategy Logic Addition: Added a new strategy entry condition: index >= 25 AND index crosses over its 5-period Simple Moving Average (SMA), and a corresponding exit condition of holding the position for 252 bars (days).\n \n\nCNN Fear & Greed Backtest Strategy (Adapted)\nThis script is an adaptation of the popular CNN Fear & Greed Index, originally created by EdgeTools, with significant modifications to optimize it for long-term backtesting on the TradingView platform.\n\nThe core function of the Fear & Greed Index is to measure the current emotional state of the stock market, ranging from 0 (Extreme Fear) to 100 (Extreme Greed). It operates on the principle that excessive fear drives prices too low (a potential buying opportunity), and excessive greed drives them too high (a potential selling opportunity).\n\nKey Components of the Index (7 Factors)\nThe composite index is calculated as a weighted average of seven market indicators, each normalized to a score between 0 and 100:\n\nMarket Momentum: S&P 500's current level vs. its 125-day Moving Average.\n\nStock Price Strength: Stocks hitting 52-week highs vs. those hitting 52-week lows.\n\nStock Price Breadth: Measured by the McClellan Volume Summation Index (or similar volume/breadth metric).\n\nPut/Call Ratio: The relationship between volume of put options (bearish bets) and call options (bullish bets).\n\nMarket Volatility: The CBOE VIX Index relative to its 50-day Moving Average.\n\nSafe Haven Demand: The relative performance of stocks (S&P 500) vs. bonds.\n\nJunk Bond Demand: The spread between high-yield (junk) bonds and U.S. Treasury yields.\n\nCritical Adaptations for Backtesting\nTo improve the index's utility for quantitative analysis, the following changes were made:\n\nLong-Term Normalization: The original normalization method (ta.stdev over a short LENGTH) has been replaced or adjusted to use longer historical data. This change ensures the index generates consistent and comparable sentiment scores across decades of market history, which is crucial for reliable backtesting results.\n\nUpdated Data Sources: Specific ticker requests for the Put/Call Ratio and Bond components (Safe Haven and Junk Bond Demand) have been updated to use the most reliable and long-running data available on TradingView, reducing data gaps and improving chart continuity.\n\nSimplified Visuals: The chart display is streamlined, focusing only on the final Fear & Greed Index line and key threshold levels (25, 50, 75) for quick visual assessment.\n\nIntegrated Trading Strategy\nThis script also includes a simple, rules-based strategy designed to test the counter-trend philosophy of the index:\n\nEntry Logic (Long Position): A long position is initiated when the market shows increasing fear, specifically when the index score is less than or equal to the configurable FEAR_LEVEL (default 25) and the index crosses above its own short-term 5-period Simple Moving Average (SMA). This crossover acts as a confirmation that sentiment may be starting to turn around from peak fear.\n\nExit Logic (Time-Based): All positions are subject to a time-based exit after holding for 252 trading days (approximately one year). This fixed holding period aims to capture the typical duration of a cyclical market recovery following a major panic event.",
    "image_url": "SKEvwrNo",
    "author": "rwanwan",
    "likes": 18,
    "type": "strategy",
    "created": "2025-11-21",
    "updated": "2025-11-21",
    "source": "// This Pine Scriptâ„¢ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// Â© EdgeTools\r\n\r\n//@version=6\r\n//indicator(\"CNN Fear and Greed Index\", overlay=false)\r\nstrategy(\"CNN Fear and Greed Strategy\", overlay=false)\r\n\r\n// Equal weights as in the original CNN Index\r\nmomentum_weight = 1.0\r\nstrength_weight = 1.0\r\nbreadth_weight = 1.0\r\nput_call_weight = 1.0\r\nvix_weight = 1.0\r\nsafe_haven_weight = 1.0\r\njunk_bond_weight = 1.0\r\n\r\nSCALING_FACTOR = 16.7\r\nLENGTH = 100\r\n\r\n// Momentum: S&P 500 vs 125-SMA\r\nsp500 = request.security(\"SP:SPX\", \"D\", close)\r\nmomentum = (sp500 / ta.sma(sp500, 125) - 1) * 100\r\nmomentum_std = ta.stdev(momentum, LENGTH)\r\nmomentum_normalized_score_raw = 50 + (momentum / momentum_std) * SCALING_FACTOR\r\nmomentum_score = math.min(100, math.max(0, momentum_normalized_score_raw))\r\n\r\n// Strength: 52-week highs vs lows (Number of stocks with highs vs lows)\r\nhighs_count = request.security(\"INDEX:HIGN\", \"D\", close)\r\nlows_count = request.security(\"INDEX:LOWN\", \"D\", close)\r\nstrength = (highs_count / (highs_count + lows_count + 1e-9))*100 // Avoid division by 0\r\nstrength_std = ta.stdev(strength, LENGTH)\r\nstrength_avg = ta.sma(strength, LENGTH)\r\nstrength_normalized_score_raw = 50 + ((strength - strength_avg) / strength_std) * SCALING_FACTOR\r\nstrength_score = math.min(100, math.max(0, strength_normalized_score_raw))\r\n\r\n// Breadth: McClellan Volume Summation Index\r\nvolume_up = request.security(\"USI:UVOL\", \"D\", close)\r\nvolume_down = request.security(\"USI:DVOL\", \"D\", close)\r\nnet_volume = volume_up - volume_down\r\nmclellan_oscillator = ta.ema(net_volume, 19) - ta.ema(net_volume, 39)\r\n//mclellan_summation = ta.cum(mclellan_oscillator)\r\nmco_std = ta.stdev(mclellan_oscillator, LENGTH)\r\nmco_avg = ta.sma(mclellan_oscillator, LENGTH)\r\nmclellan_normalized_score_raw = 50 + ((mclellan_oscillator-mco_avg) / mco_std) * SCALING_FACTOR\r\nbreadth_score = math.min(100, math.max(0, mclellan_normalized_score_raw))\r\n\r\n\r\n// Put/Call Ratio (5-day average)\r\nput_call_ratio = ta.sma(request.security(\"INDEX:CPCI\", \"D\", close), 5)\r\npcr_std = ta.stdev(put_call_ratio, LENGTH)\r\npcr_avg = ta.sma(put_call_ratio, LENGTH)\r\npcr_normalized_score_raw = 50 + ((pcr_avg-put_call_ratio) / pcr_std) * SCALING_FACTOR\r\npcr_score = math.min(100, math.max(0, pcr_normalized_score_raw))\r\n\r\n// VIX with historical comparison\r\nvix = request.security(\"CBOE:VIX\", \"D\", close)\r\nvix_ma = ta.sma(vix, 50)\r\nvix_diff = (vix / vix_ma -1)*100\r\nvix_diff_std = ta.stdev(vix_diff, LENGTH)\r\nvix_normalized_score_raw = 50 + (-vix_diff / vix_diff_std) * SCALING_FACTOR\r\nvolatility_score = math.min(100, math.max(0, vix_normalized_score_raw))\r\n\r\n// Safe Haven Demand (Stocks vs. Bonds)\r\nstock_returns = ta.roc(sp500, 20)\r\nbond_price = request.security(\"BND\", \"D\", close)\r\nbond_returns = ta.roc(bond_price, 20)\r\nsafe_haven_demand = stock_returns - bond_returns\r\ndemand_std = ta.stdev(safe_haven_demand, LENGTH)\r\ndemand_avg = ta.sma(safe_haven_demand, LENGTH)\r\ndemand_normalized_score_raw = 50 + ((safe_haven_demand - demand_avg)/ demand_std) * SCALING_FACTOR\r\ndemand_score = math.min(100, math.max(0, demand_normalized_score_raw))\r\n\r\n// Junk Bond Demand (High-yield vs. Treasury spread)\r\njunk_yield = request.security(\"FRED:BAMLH0A0HYM2EY\", \"D\", close)\r\ntreasury_yield = request.security(\"FRED:DGS10\", \"D\", close)\r\njunk_bond_demand = junk_yield - treasury_yield\r\nJB_std = ta.stdev(junk_bond_demand, LENGTH)\r\nJB_avg = ta.sma(junk_bond_demand, LENGTH)\r\nJB_normalized_score_raw = 50 + ((JB_avg-junk_bond_demand) / JB_std) * SCALING_FACTOR\r\nJB_score = math.min(100, math.max(0, JB_normalized_score_raw))\r\n\r\n// Total index\r\nfear_greed = (momentum_score * momentum_weight + strength_score * strength_weight + breadth_score * breadth_weight + pcr_score * put_call_weight + volatility_score * vix_weight + demand_score * safe_haven_weight + JB_score * junk_bond_weight) / (momentum_weight + strength_weight + breadth_weight + put_call_weight + vix_weight + safe_haven_weight + junk_bond_weight)\r\n\r\n// Color gradient\r\ncolor_gradient = color.from_gradient(fear_greed, 0, 100, color.red, color.green)\r\n\r\nplot(fear_greed, title=\"Fear & Greed\", color=color_gradient, linewidth=2)\r\nhline(25, \"Extreme Fear\", color=color.rgb(255, 0, 0, 0), linestyle=hline.style_dashed)\r\nhline(50, \"Neutral\", color=color.blue, linestyle=hline.style_dashed)\r\nhline(75, \"Extreme Greed\", color=color.green, linestyle=hline.style_dashed)\r\n\r\n// Background colors for each zone\r\nbgcolor(fear_greed <= 25 ? color.new(color.red, 90) : na, title=\"Extreme Fear Zone\")\r\nbgcolor(fear_greed >= 75 ? color.new(color.green, 90) : na, title=\"Extreme Greed Zone\")\r\n\r\n\r\n// Define Strategy Parameters\r\nFEAR_LEVEL = input.int(25, \"Buy Fear Level (FEAR_LEVEL)\", minval=0, maxval=50)\r\nEXIT_BARS = input.int(252, \"Exit Period (K Bars)\", minval=1)\r\nMA_LENGTH = input.int(5, \"Crossover MA Period\", minval=2)\r\n\r\n// Tracking Variables\r\nvar float entry_bar_index = na\r\nvar bool in_long_position = false\r\n\r\n// --- Strategy Calculation ---\r\n\r\n// 1. Calculate the N-day MA of the F&G Index\r\nfear_greed_sma = ta.sma(fear_greed, MA_LENGTH)\r\n\r\n// 2. Define Entry Condition\r\nlong_entry_condition = fear_greed < FEAR_LEVEL and ta.crossover(fear_greed, fear_greed_sma)\r\n\r\n// --- Execute Trade Commands ---\r\n\r\n// 1. Entry\r\nif long_entry_condition and not in_long_position // Ensure no duplicate entry\r\n    strategy.entry(\"Long_Entry\", strategy.long)\r\n    entry_bar_index := bar_index\r\n    in_long_position := true\r\n\r\n// 2. Exit\r\ntime_exit_condition = in_long_position and (bar_index >= entry_bar_index + EXIT_BARS)\r\n\r\nif time_exit_condition\r\n    strategy.close(\"Long_Entry\", comment=\"Time_Exit\")\r\n    in_long_position := false // Reset position status"
  },
  {
    "url": "9fyYkXvO",
    "name": "VIX Counter-Trend Strategy",
    "description": "VIX Panic Index VOO Bottom-Fishing Strategy\n\nðŸ“Š Strategy Overview\nThis strategy utilizes the VIX (Volatility Index) as a market sentiment indicator to help investors rationally enter positions during periods of extreme market panic, using objective technical signals to avoid emotional decision-making. It is designed to capture rebound opportunities in VOO (or other US equity ETFs) following panic-driven selloffs.\n\nðŸŽ¯ Entry and Exit Conditions\n\nEntry Conditions (both must be met):\nVIX reaches or exceeds the set threshold (default 25, adjustable)\nVIX death crosses below its moving average (default 5-day MA), confirming panic sentiment is beginning to recede\n\n\nExit Conditions (three modes available):\nHolding Period Mode: Exit after holding for the set number of days (default 100 days)\nVIX Decline Mode: Exit when VIX falls below the set threshold (default 20)\nEither Condition Mode: Exit when either condition is met\n\n\nâš ï¸ Important Warnings\nNot Suitable for Leveraged ETF Bottom-Fishing: VIX reflects market volatility. Using leveraged ETFs (such as TQQQ, SOXL) increases risk due to decay effects and greater volatility, potentially causing larger losses during panic periods.\nBear Market Inaccuracy Risk: This strategy assumes markets will rebound from panic. However, during prolonged bear markets or systemic risks (such as the 2008 financial crisis or 2022 rate hike cycle), VIX may remain elevated for extended periods, triggering multiple buy signals while prices continue declining, rendering the strategy ineffective.\nRecommended to Combine with Market Trend Analysis: Works better in bull market conditions. In bear markets, consider raising VIX thresholds or suspending use.\nFor Reference Only, Not Investment Advice: Historical performance does not guarantee future results. Please use cautiously according to your personal risk tolerance.\n\nVIX ææ…ŒæŒ‡æ•¸ VOO æŠ„åº•ç­–ç•¥\nðŸ“Š ç­–ç•¥ç›®çš„\næœ¬ç­–ç•¥åˆ©ç”¨ VIX ææ…ŒæŒ‡æ•¸ä½œç‚ºå¸‚å ´æƒ…ç·’æŒ‡æ¨™ï¼Œå¹«åŠ©æŠ•è³‡äººåœ¨å¸‚å ´æ¥µåº¦ææ…Œæ™‚ç†æ€§é€²å ´æŠ„åº•ï¼Œä¸¦é€éŽå®¢è§€çš„æŠ€è¡“è¨Šè™Ÿé¿å…æƒ…ç·’åŒ–æ“ä½œã€‚é©åˆç”¨æ–¼æ•æ‰ VOOï¼ˆæˆ–å…¶ä»–ç¾Žè‚¡ ETFï¼‰åœ¨ææ…Œæ€§ä¸‹è·Œå¾Œçš„åå½ˆæ©Ÿæœƒã€‚\nðŸŽ¯ é€²å‡ºå ´æ¢ä»¶\né€²å ´æ¢ä»¶ï¼ˆåŒæ™‚æ»¿è¶³ï¼‰ï¼š\nVIX æŒ‡æ•¸é”åˆ°è¨­å®šé–€æª»ä»¥ä¸Šï¼ˆé è¨­ 25ï¼Œå¯èª¿æ•´ï¼‰\nVIX æ­»äº¡äº¤å‰å…¶å‡ç·šï¼ˆé è¨­ 5 æ—¥å‡ç·šï¼‰ï¼Œç¢ºèªææ…Œæƒ…ç·’é–‹å§‹å›žè½\n\nå‡ºå ´æ¢ä»¶ï¼ˆä¸‰ç¨®æ¨¡å¼å¯é¸ï¼‰ï¼š\næŒæœ‰å¤©æ•¸æ¨¡å¼ï¼šæŒæœ‰é”åˆ°è¨­å®šå¤©æ•¸å¾Œå‡ºå ´ï¼ˆé è¨­ 100 å¤©ï¼‰\nVIX å›žè½æ¨¡å¼ï¼šVIX é™è‡³è¨­å®šé–€æª»ä»¥ä¸‹æ™‚å‡ºå ´ï¼ˆé è¨­ 20ï¼‰\nå…©è€…çš†å¯æ¨¡å¼ï¼šä»»ä¸€æ¢ä»¶æ»¿è¶³å³å‡ºå ´\n\nâš ï¸ é‡è¦è­¦èªž\nä¸é©åˆæ§“æ¡¿åž‹ ETF æŠ„åº•ï¼šVIX åæ˜ çš„æ˜¯å¸‚å ´æ³¢å‹•åº¦ï¼Œä½¿ç”¨æ§“æ¡¿ ETFï¼ˆå¦‚ TQQQã€SOXLï¼‰æœƒå› ç‚ºè¡°æ¸›æ•ˆæ‡‰å’Œæ›´å¤§æ³¢å‹•è€Œå¢žåŠ é¢¨éšªï¼Œå¯èƒ½åœ¨ææ…ŒæœŸé–“é€ æˆæ›´å¤§è™§æã€‚\nç©ºé ­å¸‚å ´å¤±æº–é¢¨éšªï¼šæœ¬ç­–ç•¥å‡è¨­å¸‚å ´æœƒå¾žææ…Œä¸­åå½ˆï¼Œä½†åœ¨é•·æœŸç©ºé ­æˆ–ç³»çµ±æ€§é¢¨éšªï¼ˆå¦‚ 2008 é‡‘èžå±æ©Ÿã€2022 å‡æ¯å¾ªç’°ï¼‰ä¸­ï¼ŒVIX å¯èƒ½é•·æœŸè™•æ–¼é«˜æª”ï¼Œå¤šæ¬¡è§¸ç™¼è²·å…¥è¨Šè™Ÿå»æŒçºŒä¸‹è·Œï¼Œå°Žè‡´ç­–ç•¥å¤±æ•ˆã€‚\nå»ºè­°æ­é…å¤§ç›¤è¶¨å‹¢åˆ¤æ–·ï¼šåœ¨å¤šé ­æ ¼å±€ä¸­ä½¿ç”¨æ•ˆæžœè¼ƒä½³ï¼Œç©ºé ­æ ¼å±€å»ºè­°æé«˜ VIX é–€æª»æˆ–æš«åœä½¿ç”¨ã€‚\nåƒ…ä¾›åƒè€ƒï¼ŒéžæŠ•è³‡å»ºè­°ï¼šæ­·å²ç¸¾æ•ˆä¸ä»£è¡¨æœªä¾†è¡¨ç¾ï¼Œè«‹ä¾å€‹äººé¢¨éšªæ‰¿å—åº¦è¬¹æ…Žä½¿ç”¨ã€‚",
    "image_url": "9fyYkXvO",
    "author": "rwanwan",
    "likes": 16,
    "type": "strategy",
    "created": "2025-11-21",
    "updated": "2025-11-21",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// Â© rwanwan\r\n\r\n//@version=6\r\nstrategy(\"VIX Counter-Trend Strategy\", overlay=true)\r\n\r\n// --- 1. Define Parameters (Adjustable buying the dip and exit thresholds) ---\r\n// VIX Buy Threshold: VIX reaching or exceeding this value is considered extreme panic\r\nvix_buy_threshold = input.float(25.0, \"VIX Buy Threshold (Panic Value)\", minval=20.0)\r\n// VIX Moving Average Period\r\nvix_ma_period = input.int(5, \"VIX MA Period\", minval=1)\r\n\r\n// Exit Condition Selection\r\nexit_mode = input.string(\"Holding Days\", \"Exit Condition\", options=[\"Holding Days\", \"VIX Retreat\", \"Both\"])\r\n// Exit Days: Number of days after purchase to force exit\r\nexit_days = input.int(100, \"Forced Exit Days After Purchase\", minval=1)\r\n// VIX Sell Threshold\r\nvix_sell_threshold = input.float(20.0, \"VIX Sell Threshold (Calm Value)\", minval=10.0)\r\n\r\n// --- 2. Get VIX Data ---\r\n// The VIX ticker on TradingView is usually TVC:VIX\r\n// Use request.security() function to fetch the VIX daily close price on the VOO chart\r\nvix_data = request.security(\"TVC:VIX\", \"D\", close)\r\n\r\n// Calculate the 5-day Moving Average of VIX\r\nvix_ma = request.security(\"TVC:VIX\", \"D\", ta.sma(close, vix_ma_period))\r\n\r\n// --- 3. Strategy Logic: Buy Condition ---\r\n// Determine if VIX has reached the buying the dip threshold AND VIX crosses under the 5-day MA\r\n// Cross Under: VIX drops below the MA from above\r\n// Use [1] to ensure data is confirmed (i.e., cross occurred on the previous bar)\r\nvix_cross_under = ta.crossunder(vix_data, vix_ma)\r\nbuy_condition = vix_data[1] >= vix_buy_threshold and vix_cross_under[1]\r\n\r\n// Execute Buy Entry\r\nif buy_condition\r\n    strategy.entry(\"BuyVOO\", strategy.long, comment=\"VIX Panic Dip Buy\")\r\n\r\n// --- 4. Strategy Logic: Sell Condition ---\r\n// Calculate the number of holding bars\r\nvar int bars_since_entry = 0\r\nif strategy.position_size > 0\r\n    bars_since_entry := bars_since_entry + 1\r\nelse\r\n    bars_since_entry := 0\r\n\r\n// Determine various exit conditions\r\ntime_exit = bars_since_entry >= exit_days\r\nvix_exit = vix_data <= vix_sell_threshold\r\n\r\n// Execute Sell based on user's selected mode\r\nif exit_mode == \"Holding Days\"\r\n    if time_exit\r\n        strategy.close(\"BuyVOO\", comment=\"Holding Period Exceeded\")\r\nelse if exit_mode == \"VIX Retreat\"\r\n    if vix_exit\r\n        strategy.close(\"BuyVOO\", comment=\"VIX Below \" + str.tostring(vix_sell_threshold))\r\nelse if exit_mode == \"Both\"\r\n    if time_exit or vix_exit\r\n        strategy.close(\"BuyVOO\", comment=time_exit ? \"Holding Period Exceeded\" : \"VIX Below \" + str.tostring(vix_sell_threshold))\r\n"
  },
  {
    "url": "UDNlq5ow-Macketings-1min-Scalping",
    "name": "Macketings 1min Scalping",
    "description": "This is a hyper-reactive scalping strategy designed for the 1-minute chart. It utilizes a strict four-EMA hierarchy (80/90/340/500) to ensure trades are only taken in the strongest aligned market trend. The strategy is built to be extremely tight on risk and focuses on capturing the immediate, high-momentum swing that follows a confirmed EMA retest or breakout.\n\nKey Mechanics (How it Works):\nStrict Trend Alignment: Entry is only permitted when the faster EMA band (80/90) and the price action are correctly aligned with the slow trend (340/500).\n\nLong: EMA 80/90 must be above EMA 340/500, AND EMA 340 must be above EMA 500. (And vice-versa for Short.)\n\nExpanded Retest Entry: The strategy waits for the price to retest or briefly enter the 80/90 band, then immediately enters upon the confirmed momentum breakout from that band.\n\nDynamic Risk Management (Tight Ride): The strategy is engineered to ride the wave aggressively while protecting capital immediately:\n\nExtremely Tight Initial Stop Loss (0.2% default): Limits initial risk instantly.\n\nBreak-Even Security: Once profit hits 0.3%, the Stop Loss is automatically trailed to secure 0.2% profit (a risk-free trade).\n\nAggressive Exit Logic: Positions are closed not only upon hitting the Take Profit target (2.5%) but also immediately if the 80/90 EMA band crosses the 340 EMA, signaling a critical loss of momentum.\nDisclaimer:\nThis strategy requires high-liquidity instruments and is best used on low timeframes (1-minute) due to its dependency on fast momentum shifts and tight stops. Backtesting and forward testing are crucial before deployment.",
    "image_url": "UDNlq5ow",
    "author": "Macketing1337",
    "likes": 393,
    "type": "strategy",
    "created": "2025-12-01",
    "updated": "2025-12-01",
    "source": "//@version=6\r\nstrategy(\"Macketings 1min Scalping [Smart Exit + Time]\", shorttitle=\"Macketing Time\", overlay=true, pyramiding=0, initial_capital=10000, default_qty_value=100, default_qty_type=strategy.percent_of_equity)\r\n\r\n// --- 1. INSTÃ„LLNINGAR ---\r\nlen80 = input.int(80, title=\"EMA 80 Length\")\r\nlen90 = input.int(90, title=\"EMA 90 Length\")\r\nlen340 = input.int(340, title=\"EMA 340 Length\")\r\nlen500 = input.int(500, title=\"EMA 500 Length\")\r\nlenSafety = input.int(325, title=\"SMA Safety Filter\")\r\n\r\n// FILTER (Cooldown & Tid)\r\ncooldown_bars = input.int(100, title=\"Cooldown Bars (Vila efter exit)\", group=\"Filter\")\r\n\r\n// NYTT: TIDSFILTER\r\nuse_time_filter = input.bool(true, title=\"Aktivera Tidsfilter?\", group=\"Filter\")\r\n// Formatet \"0900-2359\" betyder att handel Ã¤r tillÃ¥ten frÃ¥n 09:00 till 23:59.\r\n// Resten av tiden (00:00-09:00) tas inga nya positioner.\r\ntrading_session = input.session(\"0900-2359\", title=\"TillÃ¥ten Handelstid\", group=\"Filter\")\r\n\r\n// RISK (Stop Loss & TP)\r\nsl_perc = input.float(0.2, title=\"Initial Stop Loss (%)\", step=0.1, group=\"Risk\") / 100 \r\nbe_trigger_perc = input.float(0.3, title=\"Breakeven Trigger (%)\", step=0.1, group=\"Risk\") / 100 \r\nbe_profit_perc = input.float(0.2, title=\"Secured Profit (%)\", step=0.1, group=\"Risk\") / 100 \r\ntp_perc = input.float(1.5, title=\"Take Profit (%)\", step=0.5, group=\"Risk\") / 100 \r\n\r\n// SMART BAND EXIT\r\nuse_smart_exit = input.bool(true, title=\"AnvÃ¤nd Smart Band Exit?\", group=\"Smart Band Exit\")\r\nsmart_exit_min_profit = input.float(0.3, title=\"Min Vinst fÃ¶r att aktivera (%)\", step=0.1, group=\"Smart Band Exit\") / 100\r\n\r\n// --- 2. INDIKATORER ---\r\nema80 = ta.ema(close, len80)\r\nema90 = ta.ema(close, len90)\r\nema340 = ta.ema(close, len340)\r\nema500 = ta.ema(close, len500)\r\nsmaSafety = ta.sma(close, lenSafety)\r\n\r\n// --- 3. COOLDOWN & TIDS LOGIK ---\r\n// A) Cooldown\r\nvar int last_exit_bar = 0\r\nif strategy.position_size[1] != 0 and strategy.position_size == 0\r\n    last_exit_bar := bar_index\r\n\r\nis_cooldown_ok = (bar_index - last_exit_bar) >= cooldown_bars\r\n\r\n// B) Tidsfilter\r\n// time(timeframe.period, session) returnerar \"na\" om vi Ã¤r utanfÃ¶r sessionen\r\n// Om use_time_filter Ã¤r false, ignorerar vi tiden (alltid true).\r\nis_time_ok = not use_time_filter or not na(time(timeframe.period, trading_session))\r\n\r\n// --- 4. HANDELSVILLKOR ---\r\nmid_band_low = math.min(ema80, ema90)\r\nmid_band_high = math.max(ema80, ema90)\r\n\r\n// Retest\r\nretest_in_band = (close >= mid_band_low) and (close <= mid_band_high)\r\nretest_or_breakout_long = retest_in_band or ta.crossover(close, mid_band_high)\r\nretest_or_breakout_short = retest_in_band or ta.crossunder(close, mid_band_low)\r\n\r\nlong_conf = close > close[1]\r\nshort_conf = close < close[1]\r\n\r\n// ENTRY RULES (Nu med is_time_ok)\r\nlong_trend_ok = (ema340 > ema500) and (mid_band_low > ema500)\r\n// Lade till \"and is_time_ok\"\r\nlong_entry_signal = long_trend_ok and retest_or_breakout_long and long_conf and (close > smaSafety) and is_cooldown_ok and is_time_ok\r\n\r\nshort_trend_ok = (ema340 < ema500) and (mid_band_high < ema500)\r\n// Lade till \"and is_time_ok\"\r\nshort_entry_signal = short_trend_ok and retest_or_breakout_short and short_conf and (close < smaSafety) and is_cooldown_ok\r\n\r\n// --- 5. EXEKVERING ---\r\nif long_entry_signal and strategy.position_size == 0\r\n    strategy.entry(\"Long_E\", strategy.long, comment=\"Long | CD/Time OK\")\r\n\r\nif short_entry_signal and strategy.position_size == 0\r\n    strategy.entry(\"Short_E\", strategy.short, comment=\"Short | CD/Time OK\")\r\n\r\n// --- 6. STOP LOSS & EXIT ---\r\nvar float current_stop_price_long = na\r\nvar float current_stop_price_short = na\r\n\r\nis_in_long = strategy.position_size > 0\r\nis_in_short = strategy.position_size < 0\r\n\r\n// --- SMART BAND EXIT LOGIK ---\r\nband_break_down = ta.crossunder(close, mid_band_low)\r\nband_break_up = ta.crossover(close, mid_band_high)\r\n\r\nexit_long_trend_change = ta.crossunder(ema340, ema500)\r\nexit_short_trend_change = ta.crossover(ema340, ema500)\r\n\r\n// 1. Long Exit\r\nif is_in_long\r\n    entry_price = strategy.position_avg_price\r\n    can_use_band_exit = use_smart_exit and (close >= entry_price * (1 + smart_exit_min_profit))\r\n    \r\n    if (band_break_down and can_use_band_exit) or exit_long_trend_change\r\n        strategy.close(\"Long_E\", comment=\"Exit Long: Smart/Trend\")\r\n        current_stop_price_long := na \r\n\r\n// 2. Short Exit\r\nif is_in_short\r\n    entry_price = strategy.position_avg_price\r\n    can_use_band_exit = use_smart_exit and (close <= entry_price * (1 - smart_exit_min_profit))\r\n    \r\n    if (band_break_up and can_use_band_exit) or exit_short_trend_change\r\n        strategy.close(\"Short_E\", comment=\"Exit Short: Smart/Trend\")\r\n        current_stop_price_short := na\r\n\r\n// Update SL Logic (Breakeven & Hard SL)\r\nif is_in_long\r\n    entry_price = strategy.position_avg_price\r\n    if na(current_stop_price_long)\r\n        current_stop_price_long := entry_price * (1 - sl_perc)\r\n    // Breakeven\r\n    if close >= entry_price * (1 + be_trigger_perc)\r\n        new_sl_price = entry_price * (1 + be_profit_perc)\r\n        if new_sl_price > current_stop_price_long\r\n            current_stop_price_long := new_sl_price\r\n\r\nif is_in_short\r\n    entry_price = strategy.position_avg_price\r\n    if na(current_stop_price_short)\r\n        current_stop_price_short := entry_price * (1 + sl_perc)\r\n    // Breakeven\r\n    if close <= entry_price * (1 - be_trigger_perc)\r\n        new_sl_price = entry_price * (1 - be_profit_perc)\r\n        if new_sl_price < current_stop_price_short\r\n            current_stop_price_short := new_sl_price\r\n\r\n// Exit 1: Dynamic SL & Hard TP\r\nif is_in_long\r\n    long_limit_price = strategy.position_avg_price * (1 + tp_perc)\r\n    strategy.exit(\"Exit_Risk\", from_entry=\"Long_E\", stop=current_stop_price_long, limit=long_limit_price)\r\n\r\nif is_in_short\r\n    short_limit_price = strategy.position_avg_price * (1 - tp_perc)\r\n    strategy.exit(\"Exit_Risk\", from_entry=\"Short_E\", stop=current_stop_price_short, limit=short_limit_price)\r\n\r\n// Reset\r\nif strategy.position_size[1] != 0 and strategy.position_size == 0\r\n    current_stop_price_long := na\r\n    current_stop_price_short := na\r\n\r\n// --- 7. VISUALS ---\r\ntrend_color = long_trend_ok ? color.rgb(0, 150, 0) : short_trend_ok ? color.rgb(255, 0, 0) : color.gray\r\n\r\nplot(ema80, color=color.new(color.blue, 0), linewidth=2, title=\"EMA 80\")\r\nplot(ema90, color=color.new(color.blue, 20), linewidth=2, title=\"EMA 90\")\r\nplot(ema340, color=trend_color, linewidth=2, title=\"EMA 340\")\r\nplot(ema500, color=trend_color, linewidth=1, style=plot.style_stepline, title=\"EMA 500\")\r\nplot(smaSafety, color=color.orange, linewidth=3, title=\"SMA 325 Safety\")\r\n\r\n// Visa bakgrundsfÃ¤rg nÃ¤r vi INTE fÃ¥r handla pga tid eller cooldown\r\nbgcolor((not is_cooldown_ok or not is_time_ok) ? color.new(color.gray, 80) : na, title=\"No Trade Zone\")"
  },
  {
    "url": "eTdXC6bw-Premarket-Breakout-TP1-BE-ATR-Trail",
    "name": "Premarket Breakout (TP1 â†’ BE â†’ ATR Trail)",
    "description": "this is the best ever you will really like i t and it does a lot its a really good scirpt please use it to make trades",
    "image_url": "eTdXC6bw",
    "author": "abbs0723",
    "likes": 5,
    "type": "strategy",
    "created": "2025-11-20",
    "updated": "2025-11-20",
    "source": "//@version=6\r\nstrategy(\"Premarket Breakout (TP1 â†’ BE â†’ ATR Trail)\", \r\n     overlay=true, \r\n     default_qty_type=strategy.cash, \r\n     default_qty_value=10000)\r\n\r\n// === Inputs ===\r\nemaLen        = input.int(21, \"EMA Length\")\r\nlookbackHigh  = input.int(10, \"Breakout Lookback\")\r\nvolMult       = input.float(1.5, \"Volume Ã— Avg Volume\")\r\nstopPct       = input.float(1.0, \"Stop %\")\r\natrMult       = input.float(1.5, \"ATR Trail Multiplier\")\r\n\r\n// === Indicators ===\r\nema = ta.ema(close, emaLen)\r\nhh  = ta.highest(high[1], lookbackHigh)\r\navgVol = ta.sma(volume, 20)\r\n\r\nvolOK = volume > avgVol * volMult\r\nbreakout = close > hh\r\ntrendOK = close > ema\r\n\r\nenterLong = breakout and trendOK and volOK\r\n\r\n// === SL/TP1 ===\r\natr = ta.atr(14)\r\n\r\nvar float entryPrice = na\r\nvar float stopPrice  = na\r\nvar float tp1Price   = na\r\nvar float trailStop  = na\r\nvar bool tp1Hit      = false\r\n\r\nif enterLong and strategy.position_size == 0\r\n    strategy.entry(\"Long\", strategy.long)\r\n    entryPrice := close\r\n    stopPrice := entryPrice * (1 - stopPct / 100)\r\n\r\n    risk = entryPrice - stopPrice\r\n    tp1Price := entryPrice + risk * 1.0\r\n\r\n    tp1Hit := false\r\n    trailStop := na\r\n\r\n// === TP1 HIT ===\r\nif strategy.position_size > 0 and not tp1Hit and high >= tp1Price\r\n    tp1Hit := true\r\n    trailStop := entryPrice   // move to breakeven\r\n\r\n// === ATR TRAIL AFTER TP1 ===\r\nif strategy.position_size > 0 and tp1Hit\r\n    newTS = close - atrMult * atr\r\n    trailStop := na(trailStop) ? newTS : math.max(trailStop, newTS)\r\n\r\n// === EXIT ===\r\nif strategy.position_size > 0\r\n    dynSL = tp1Hit ? trailStop : stopPrice\r\n    strategy.exit(\"Exit\", from_entry=\"Long\", stop=dynSL)\r\n\r\n// === Plots ===\r\nplot(ema, color=color.orange)\r\nplotshape(enterLong, style=shape.triangleup, color=color.lime, location=location.belowbar)\r\nplot(trailStop, color=color.red, style=plot.style_linebr)\r\n"
  },
  {
    "url": "BAtVOXqQ-Mirror-Blocks-Strategy",
    "name": "Mirror Blocks: Strategy",
    "description": "Mirror Blocks is an educational structural-wave model built around a unique concept:\nthe interaction of mirrored weighted moving averages (â€œblocksâ€) that reflect shifts in market structure as price transitions between layered symmetry zones.\n\nRather than attempting to â€œpredictâ€ markets, the Mirror Blocks framework visualizes how price behaves when it expands away from, contracts toward, or flips across stacked WMA structures. These mirrored layers form a wave-like block system that highlights transitional zones in a clean, mechanical way.\n\nThis strategy version allows you to study how these structural transitions behave in different environments and on different timeframes.\nThe goal is understanding wave structure, not generating signals.\n\nHow It Works\n\nMirror Blocks builds three mirrored layers:\n\nTop Block (Structural High Symmetry)\n\nBase Block (Neutral Wave)\n\nBottom Block (Structural Low Symmetry)\n\nThe relative position of these blocks â€” and how price interacts with them â€” helps visualize:\n\nCompression and expansion\n\nReversal zones\n\nWave stability\n\nMomentum transitions\n\nStructure flips\n\nA structure is considered bullish-stack aligned when:\n\nTop > Base > Bottom\n\n\nand bearish-stack aligned when:\n\nBottom > Base > Top\n\n\nThese formations create the core of the Mirror Blocks wave engine.\n\nWhat the Strategy Version Adds\n\nThis version includes:\n\nLong Only, Short Only, or Long & Short modes\n\nAdjustable symmetry distance (Mirror Distance)\n\nConfigurable WMA smoothing length\n\nOptional trend filter using fast/slow MA comparison\n\nENTER / EXIT / LONG / SHORT labels for structural transitions\n\nFixed stop-loss controls for research\n\nA clean, transparent structure with no hidden components\n\nIt is optimized for educational chart study, not automated signals.\n\nIntended Purpose\n\nMirror Blocks is meant to help traders:\n\nStudy structural transitions\n\nUnderstand symmetry-based wave models\n\nExplore how price interacts with mirrored layers\n\nExamine reversals and expansions from a mechanical perspective\n\nConduct long and short backtesting for research\n\nDevelop a deeper sense of market rhythm\n\nThis is not a prediction model.\nIt is a visual and structural framework for understanding movement.\n\nBacktesting Disclaimer\n\nBacktest results can vary depending on:\n\nSlippage settings\n\nCommission settings\n\nTimeframe\n\nAsset volatility\n\nStructural sensitivity parameters\n\nPast performance does not guarantee future results.\nUse this as a research tool only.\n\nWarnings & Compliance \n\nThis script is educational.\n\nIt is not financial advice.\n\nIt does not provide signals.\n\nIt does not promise profitability.\n\nThe purpose is to help visualize structure, not predict price.\n\nThe strategy features are simply here to help users study how structural transitions behave under various conditions.\n\nLicense\n\nReleased under the Michael Culpepper Gratitude License (2025).\nUse and modify freely for education and research with attribution.\nNo resale.\nNo promises of profitability.\nPurpose is understanding, not signals.",
    "image_url": "BAtVOXqQ",
    "author": "mikeyc747",
    "likes": 70,
    "type": "strategy",
    "created": "2025-11-20",
    "updated": "2025-11-20",
    "source": "//@version=6\r\nstrategy(\"Mirror Blocks: Strategy\",\r\n     overlay = true,\r\n     initial_capital = 1000,\r\n     commission_type = strategy.commission.percent,\r\n     commission_value = 0.1,\r\n     calc_on_every_tick = true,\r\n     pyramiding = 0)\r\n\r\n// === Inputs ===\r\nlen  = input.int(3,  \"Smoothing Length\")\r\namp  = input.float(1.0, \"Mirror Distance\")\r\n\r\nfastLen  = input.int(8,  \"Fast EMA Length\")\r\nslowLen  = input.int(21, \"Slow MA Length\")\r\nslowType = input.string(\"EMA\", \"Slow MA Type\", options = [\"EMA\", \"SMA\", \"WMA\", \"RMA\"])\r\n\r\nuseTrendGate   = input.bool(false, \"Use Trend Filter (Gate)\")\r\nshowTrendLines = input.bool(false, \"Show Trend Lines\")\r\n\r\n// Trade direction mode\r\ntradeMode = input.string(\"Long Only\", \"Trade Mode\", options = [\"Long Only\", \"Long & Short\", \"Short Only\"])\r\n\r\n// Fixed stops (percent from entry)\r\nlongSLPct  = input.float(13.0, \"Long Fixed Stop (%)\",  step = 0.1)\r\nshortSLPct = input.float(13.0, \"Short Fixed Stop (%)\", step = 0.1)\r\n\r\n// === Price Source (No Heiken Ashi) ===\r\nsrc = (high + low) / 2.0\r\n\r\n// === DNA Mirror Lines ===\r\nbase = ta.wma(ta.wma(src, len), len)\r\ntop  = base + (base - ta.wma(base, len)) * amp  // Red\r\nbot  = base - (base - ta.wma(base, len)) * amp  // Yellow\r\n\r\n// === Stack Logic ===\r\nisBuy  = top > base and base > bot  // Bullish DNA stack\r\nisSell = bot > base and base > top  // Bearish DNA stack\r\n\r\n// === Trend Lines (Fast EMA + Slow MA Type) ===\r\nemaFast = ta.ema(close, fastLen)\r\nslowMA  = slowType == \"EMA\" ? ta.ema(close, slowLen) :\r\n          slowType == \"SMA\" ? ta.sma(close, slowLen) :\r\n          slowType == \"WMA\" ? ta.wma(close, slowLen) :\r\n          ta.rma(close, slowLen)\r\n\r\ntrendUp = emaFast > slowMA\r\n\r\n// === Position State ===\r\nposSize = strategy.position_size\r\ninLong  = posSize > 0\r\ninShort = posSize < 0\r\nflat    = posSize == 0\r\n\r\n// Previous-bar state (for exit label detection)\r\ninLongPrev  = bar_index > 0 ? inLong[1]  : false\r\ninShortPrev = bar_index > 0 ? inShort[1] : false\r\n\r\nexitLongBar  = inLongPrev  and not inLong\r\nexitShortBar = inShortPrev and not inShort\r\n\r\n// === Base DNA signal logic (before mode) ===\r\nlongCondBase  = isBuy  and (not useTrendGate or trendUp)\r\nshortCondBase = isSell\r\n\r\n// === Trade Mode Helpers ===\r\nisLongOnly   = tradeMode == \"Long Only\"\r\nisShortOnly  = tradeMode == \"Short Only\"\r\nisLongShort  = tradeMode == \"Long & Short\"\r\n\r\nuseLongs  = isLongOnly or isLongShort\r\nuseShorts = isShortOnly or isLongShort\r\n\r\n// === Entry conditions per mode ===\r\n//\r\n// Long entries allowed when:\r\n// - Long trading enabled\r\n// - DNA long condition is true\r\n// - Either flat, or (in L&S mode) we may flip from short\r\nlongEntryCond  = useLongs  and longCondBase  and (flat or inShort)\r\n\r\n// Short entries allowed when:\r\n// - Short trading enabled\r\n// - DNA short condition is true\r\n// - Either flat, or (in L&S mode) we may flip from long\r\nshortEntryCond = useShorts and shortCondBase and (flat or inLong)\r\n\r\n// === Fixed Stop Levels (from average entry price) ===\r\navgPrice = strategy.position_avg_price\r\n\r\n// Long stop (13% default below entry)\r\nlongStopPrice  = inLong  and longSLPct  > 0 ? avgPrice * (1.0 - longSLPct  / 100.0) : na\r\n// Short stop (13% default above entry)\r\nshortStopPrice = inShort and shortSLPct > 0 ? avgPrice * (1.0 + shortSLPct / 100.0) : na\r\n\r\n// Attach exits to positions (fixed stops)\r\nstrategy.exit(\"Long Stop\",  from_entry = \"Long\",  stop = longStopPrice)\r\nstrategy.exit(\"Short Stop\", from_entry = \"Short\", stop = shortStopPrice)\r\n\r\n// === Order Logic ===\r\nif longEntryCond\r\n    // If currently short and in Long & Short mode, flip: close short then go long\r\n    if inShort\r\n        strategy.close(\"Short\")\r\n    if flat or inShort\r\n        strategy.entry(\"Long\", strategy.long)\r\n\r\nif shortEntryCond\r\n    // If currently long and in Long & Short mode, flip: close long then go short\r\n    if inLong\r\n        strategy.close(\"Long\")\r\n    if flat or inLong\r\n        strategy.entry(\"Short\", strategy.short)\r\n\r\n// === DNA-based exits (never gated by trend) ===\r\n// Long side: exit long on DNA short flip (in modes that use longs)\r\nif useLongs and inLong and shortCondBase\r\n    strategy.close(\"Long\")\r\n\r\n// Short side: exit short on DNA long flip (in modes that use shorts)\r\nif useShorts and inShort and longCondBase\r\n    strategy.close(\"Short\")\r\n\r\n// === Plots ===\r\nplot(top,  \"Top (Red)\",        color = color.red,   style = plot.style_stepline)\r\nplot(base, \"Base (Green)\",     color = color.green, style = plot.style_stepline)\r\nplot(bot,  \"Bottom (Yellow)\",  color = color.yellow, style = plot.style_stepline)\r\n\r\n// Trend lines (optional visual)\r\nplot(showTrendLines ? emaFast : na, \"Fast EMA\", color = color.new(color.blue,  0))\r\nplot(showTrendLines ? slowMA  : na, \"Slow MA\",  color = color.new(color.purple, 0))\r\n\r\n// === Labels (mode-dependent text) ===\r\n//\r\n// Long & Short mode:\r\n//  - LONG label on long entries\r\n//  - SHORT label on short entries\r\n//\r\n// Long Only mode:\r\n//  - ENTER label on long entries\r\n//  - EXIT  label when long closes\r\n//\r\n// Short Only mode:\r\n//  - SHORT label on short entries\r\n//  - EXIT  label when short closes\r\n\r\n// Entry labels\r\nlongShort_LongLabel  = isLongShort and longEntryCond\r\nlongShort_ShortLabel = isLongShort and shortEntryCond\r\n\r\nlongOnly_EnterLabel  = isLongOnly  and longEntryCond\r\nshortOnly_ShortLabel = isShortOnly and shortEntryCond\r\n\r\n// Exit labels\r\nlongOnly_ExitLabel   = isLongOnly  and exitLongBar\r\nshortOnly_ExitLabel  = isShortOnly and exitShortBar\r\n\r\n// Plot labels\r\n// Long & Short mode entries\r\nplotshape(longShort_LongLabel,\r\n          title = \"Long Entry (L&S)\",\r\n          location = location.belowbar,\r\n          color = color.green,\r\n          style = shape.labelup,\r\n          text = \"LONG\")\r\n\r\nplotshape(longShort_ShortLabel,\r\n          title = \"Short Entry (L&S)\",\r\n          location = location.abovebar,\r\n          color = color.red,\r\n          style = shape.labeldown,\r\n          text = \"SHORT\")\r\n\r\n// Long Only mode: ENTER / EXIT\r\nplotshape(longOnly_EnterLabel,\r\n          title = \"Enter (Long Only)\",\r\n          location = location.belowbar,\r\n          color = color.green,\r\n          style = shape.labelup,\r\n          text = \"ENTER\")\r\n\r\nplotshape(longOnly_ExitLabel,\r\n          title = \"Exit (Long Only)\",\r\n          location = location.abovebar,\r\n          color = color.orange,\r\n          style = shape.labeldown,\r\n          text = \"EXIT\")\r\n\r\n// Short Only mode: SHORT / EXIT\r\nplotshape(shortOnly_ShortLabel,\r\n          title = \"Short Entry (Short Only)\",\r\n          location = location.abovebar,\r\n          color = color.red,\r\n          style = shape.labeldown,\r\n          text = \"SHORT\")\r\n\r\nplotshape(shortOnly_ExitLabel,\r\n          title = \"Exit (Short Only)\",\r\n          location = location.belowbar,\r\n          color = color.orange,\r\n          style = shape.labelup,\r\n          text = \"EXIT\")\r\n"
  },
  {
    "url": "jI7LLTxk-Premarket-Breakout-TP1-BE-ATR-Trail",
    "name": "Premarket Breakout (TP1 â†’ BE â†’ ATR Trail)",
    "description": "the best one you can find a very good indicator and strategy to help with al l trading needs in every way",
    "image_url": "jI7LLTxk",
    "author": "abbs0723",
    "likes": 10,
    "type": "strategy",
    "created": "2025-11-20",
    "updated": "2025-11-20",
    "source": "//@version=6\r\nstrategy(\"Premarket Breakout (TP1 â†’ BE â†’ ATR Trail)\", \r\n     overlay=true, \r\n     default_qty_type=strategy.cash, \r\n     default_qty_value=10000)\r\n\r\n// === Inputs ===\r\nemaLen        = input.int(21, \"EMA Length\")\r\nlookbackHigh  = input.int(10, \"Breakout Lookback\")\r\nvolMult       = input.float(1.5, \"Volume Ã— Avg Volume\")\r\nstopPct       = input.float(1.0, \"Stop %\")\r\natrMult       = input.float(1.5, \"ATR Trail Multiplier\")\r\n\r\n// === Indicators ===\r\nema = ta.ema(close, emaLen)\r\nhh  = ta.highest(high[1], lookbackHigh)\r\navgVol = ta.sma(volume, 20)\r\n\r\nvolOK = volume > avgVol * volMult\r\nbreakout = close > hh\r\ntrendOK = close > ema\r\n\r\nenterLong = breakout and trendOK and volOK\r\n\r\n// === SL/TP1 ===\r\natr = ta.atr(14)\r\n\r\nvar float entryPrice = na\r\nvar float stopPrice  = na\r\nvar float tp1Price   = na\r\nvar float trailStop  = na\r\nvar bool tp1Hit      = false\r\n\r\nif enterLong and strategy.position_size == 0\r\n    strategy.entry(\"Long\", strategy.long)\r\n    entryPrice := close\r\n    stopPrice := entryPrice * (1 - stopPct / 100)\r\n\r\n    risk = entryPrice - stopPrice\r\n    tp1Price := entryPrice + risk * 1.0\r\n\r\n    tp1Hit := false\r\n    trailStop := na\r\n\r\n// === TP1 HIT ===\r\nif strategy.position_size > 0 and not tp1Hit and high >= tp1Price\r\n    tp1Hit := true\r\n    trailStop := entryPrice   // move to breakeven\r\n\r\n// === ATR TRAIL AFTER TP1 ===\r\nif strategy.position_size > 0 and tp1Hit\r\n    newTS = close - atrMult * atr\r\n    trailStop := na(trailStop) ? newTS : math.max(trailStop, newTS)\r\n\r\n// === EXIT ===\r\nif strategy.position_size > 0\r\n    dynSL = tp1Hit ? trailStop : stopPrice\r\n    strategy.exit(\"Exit\", from_entry=\"Long\", stop=dynSL)\r\n\r\n// === Plots ===\r\nplot(ema, color=color.orange)\r\nplotshape(enterLong, style=shape.triangleup, color=color.lime, location=location.belowbar)\r\nplot(trailStop, color=color.red, style=plot.style_linebr)\r\n"
  },
  {
    "url": "L6VNlhiV-Hash-Momentum-Strategy",
    "name": "Hash Momentum Strategy",
    "description": "# Hash Momentum Strategy\n\n## ðŸ“Š Overview\n\nThe **Hash Momentum Strategy** is a professional-grade momentum trading system designed to capture strong directional price movements with precision timing and intelligent risk management. Unlike traditional EMA crossover strategies, this system uses momentum acceleration as its primary signal, resulting in earlier entries and better risk-to-reward ratios.\n\n---\n\n## âš¡ What Makes This Strategy Unique\n\n### 1. Momentum-Based Entry System\nMost strategies rely on lagging indicators like moving average crossovers. This strategy captures momentum *acceleration* - entering when price movement is gaining strength, not after the move has already happened.\n\n### 2. Programmable Risk-to-Reward\nSet your exact R:R ratio (1:2, 1:2.5, 1:3, etc.) and the strategy automatically calculates stop loss and take profit levels. No more guessing or manual calculations.\n\n### 3. Smart Partial Profit Taking\nLock in profits at multiple stages:\n- **First TP**: Take 50% off at 2R\n- **Second TP**: Take 40% off at 2.5R\n- **Final TP**: Let 10% ride to maximum target\n\nThis approach locks in gains while letting winners run.\n\n### 4. Dynamic Momentum Threshold\nUses ATR (Average True Range) multiplied by your threshold setting to adapt to market volatility. Volatile markets = higher threshold. Quiet markets = lower threshold.\n\n### 5. Trade Cooldown System\nPrevents overtrading and revenge trading by enforcing a cooldown period between trades. Configurable from 1-24 bars.\n\n### 6. Optional Session & Weekend Filters\nFilter trades by Tokyo, London, and New York sessions. Optional weekend-off toggle to avoid low-liquidity periods.\n\n---\n\n## ðŸŽ¯ How It Works\n\n### Signal Generation\n\n**STEP 1: Calculate Momentum**\n- Momentum = Current Price - Price  \n- Check if Momentum > ATR Ã— Threshold Multiplier\n- Momentum must be accelerating (positive change in momentum)\n\n**STEP 2: Confirm with EMA Trend Filter**\n- Long: Price must be above EMA\n- Short: Price must be below EMA\n\n**STEP 3: Check Filters**\n- Not in cooldown period\n- Valid session (if enabled)\n- Not weekend (if enabled)\n\n**STEP 4: ENTRY SIGNAL TRIGGERED**\n\n### Risk Management Example\n\n**Example Long Trade:**\n- Entry: $100\n- Stop Loss: $97.80 (2.2% risk)\n- Risk Amount: $2.20\n\n**Take Profit Levels:**\n- TP1: $104.40 (2R = $4.40) â†’ Close 50%\n- TP2: $105.50 (2.5R = $5.50) â†’ Close 40%\n- Final: $105.50 (2.5R) â†’ Close remaining 10%\n\n---\n\n## âš™ï¸ Settings Guide\n\n### Core Strategy\n\n**Momentum Length** (Default: 13)\nNumber of bars for momentum calculation. Higher = stronger but fewer signals.\n\n**Momentum Threshold** (Default: 2.25)\nATR multiplier. Higher = only trade biggest moves.\n\n**Use EMA Trend Filter** (Default: ON)\nOnly long above EMA, short below EMA.\n\n**EMA Length** (Default: 28)\nPeriod for trend-confirming EMA.\n\n### Filters\n\n**Use Trading Session Filter** (Default: OFF)\nRestrict trading to specific sessions.\n\n**Tokyo Session** (Default: OFF)\nTrade during Asian hours (00:00-09:00 JST).\n\n**London Session** (Default: OFF)\nTrade during European hours (08:00-17:00 GMT).\n\n**New York Session** (Default: OFF)\nTrade during US hours (08:00-17:00 EST).\n\n**Weekend Off** (Default: OFF)\nDisable trading on Saturdays and Sundays.\n\n### Risk Management\n\n**Stop Loss %** (Default: 2.2)\nFixed percentage stop loss from entry.\n\n**Risk:Reward Ratio** (Default: 2.5)\nYour target reward as multiple of risk.\n\n**Use Partial Profit Taking** (Default: ON)\nTake profits in stages.\n\n**First TP R:R** (Default: 2.0)\nFirst target as multiple of risk.\n\n**First TP Size %** (Default: 50)\nPercentage of position to close at TP1.\n\n**Second TP R:R** (Default: 2.5)\nSecond target as multiple of risk.\n\n**Second TP Size %** (Default: 40)\nPercentage of position to close at TP2.\n\n### Trade Management\n\n**Use Trade Cooldown** (Default: ON)\nPrevent overtrading.\n\n**Cooldown Bars** (Default: 6)\nBars to wait after closing a trade.\n\n---\n\n## ðŸŽ¨ Visual Elements\n\n### Chart Indicators\n\nðŸŸ¢ **Green Dot** (below bar) = Long entry signal\nðŸ”´ **Red Dot** (above bar) = Short entry signal\nðŸ”µ **Blue X** (above bar) = Long position closed\nðŸŸ  **Orange X** (below bar) = Short position closed\n\n**EMA Line** = Trend direction (green when bullish, red when bearish)\n**White Line** = Entry price\n**Red Line** = Stop loss level\n**Green Lines** = Take profit levels (TP1, TP2, Final)\n\n### Dashboard\n\nWhen not in real-time mode, a dashboard displays:\n- Current position (LONG/SHORT/FLAT)\n- Entry price\n- Stop loss price\n- Take profit price\n- R:R ratio\n- Current momentum strength\n- Total trades\n- Win rate\n- Net profit %\n\n---\n\n## ðŸ“ˆ Recommended Settings by Timeframe\n\n### 1-Hour Timeframe (Default)\n- Momentum Length: 13\n- Momentum Threshold: 2.25\n- EMA Length: 28\n- Stop Loss: 2.2%\n- R:R Ratio: 2.5\n- Cooldown: 6 bars\n\n### 4-Hour Timeframe\n- Momentum Length: 24-36\n- Momentum Threshold: 2.5\n- EMA Length: 50\n- Stop Loss: 3-4%\n- R:R Ratio: 2.0-2.5\n- Cooldown: 6-8 bars\n\n### 15-Minute Timeframe\n- Momentum Length: 8-10\n- Momentum Threshold: 2.0\n- EMA Length: 20\n- Stop Loss: 1.5-2%\n- R:R Ratio: 2.0\n- Cooldown: 4-6 bars\n\n---\n\n## ðŸ”§ Optimization Tips\n\n### Want More Trades?\n- Decrease Momentum Threshold (2.0 instead of 2.25)\n- Decrease Momentum Length (10 instead of 13)\n- Decrease Cooldown Bars (4 instead of 6)\n\n### Want Higher Quality Trades?\n- Increase Momentum Threshold (2.5-3.0)\n- Increase Momentum Length (18-24)\n- Increase Cooldown Bars (8-10)\n\n### Want Lower Drawdown?\n- Increase Cooldown Bars\n- Use tighter stop loss\n- Enable session filters (trade only high-liquidity sessions)\n- Enable Weekend Off\n\n### Want Higher Win Rate?\n- Increase R:R Ratio (may reduce total profit)\n- Increase Momentum Threshold (fewer but stronger signals)\n- Use longer EMA for trend confirmation\n\n---\n\n## ðŸ“Š Performance Expectations\n\nBased on typical backtesting results:\n\n- **Win Rate**: 35-45%\n- **Profit Factor**: 1.5-2.0\n- **Risk:Reward**: 1:2.5 (configurable)\n- **Max Drawdown**: 10-20%\n- **Trades/Month**: 8-15 (1H timeframe)\n\n**Note:** Win rate may appear low, but with 2.5:1 R:R, you only need ~29% win rate to break even. The strategy aims for quality over quantity.\n\n---\n\n## ðŸŽ“ Strategy Logic Explained\n\n### Why Momentum > EMA Crossover?\n\n**EMA Crossover Problems:**\n- Signals lag behind price\n- Late entries = poor R:R\n- Many false signals in ranging markets\n\n**Momentum Advantages:**\n- Catches moves as they start accelerating\n- Earlier entries = better R:R\n- Adapts to volatility via ATR\n\n### Why Partial Profit Taking?\n\n**Without Partial TPs:**\n- All-or-nothing approach\n- Winners often turn to losers\n- High stress watching open positions\n\n**With Partial TPs:**\n- Lock in 50% at first target\n- Reduce risk to breakeven\n- Let remainder ride for bigger gains\n- Lower psychological pressure\n\n### Why Trade Cooldown?\n\n**Without Cooldown:**\n- Revenge trading after losses\n- Overtrading in choppy markets\n- Emotional decision-making\n\n**With Cooldown:**\n- Forces discipline\n- Waits for new setup to develop\n- Reduces transaction costs\n- Better signal quality\n\n---\n\n## âš ï¸ Important Notes\n\n1. **This is a momentum strategy, not an EMA strategy**\n   The EMA only confirms trend direction. Momentum generates the actual signals.\n\n2. **Backtest thoroughly before live trading**\n   Past performance â‰  future results. Test on your specific asset and timeframe.\n\n3. **Use proper position sizing**\n   Risk 1-2% of account per trade maximum. The strategy uses 100% equity by default (adjust in Properties).\n\n4. **Dashboard auto-hides in real-time**\n   Clean chart for live trading. Visible during backtesting.\n\n5. **Customize for your trading style**\n   All settings are fully adjustable. No single \"best\" configuration.\n\n---\n\n## ðŸš€ Quick Start Guide\n\n1. **Add to Chart**: Apply to your preferred asset and timeframe\n2. **Keep Defaults**: Start with default settings\n3. **Backtest**: Review historical performance\n4. **Paper Trade**: Test with simulated money first\n5. **Go Live**: Start small and scale up\n\n---\n\n## ðŸ’¡ Pro Tips\n\n**Tip 1: Combine Timeframes**\nUse higher timeframe (4H) for trend direction, lower timeframe (1H) for entries.\n\n**Tip 2: Avoid News Events**\nMajor news can cause whipsaws. Consider manual intervention during high-impact events.\n\n**Tip 3: Monitor Momentum Strength**\nDashboard shows momentum in sigma (Ïƒ). Values >1.0Ïƒ indicate very strong momentum.\n\n**Tip 4: Adjust for Volatility**\nIn high-volatility markets, increase threshold and stop loss. In quiet markets, decrease them.\n\n**Tip 5: Review Losing Trades**\nCheck if losses are hitting stop loss or reversing. Adjust stop accordingly.\n\n---\n\n## ðŸ“ Changelog\n\n**v1.0** - Initial Release\n- Momentum-based signal generation\n- EMA trend filter\n- Programmable R:R ratio\n- Partial profit taking (3 stages)\n- Trade cooldown system\n- Session filters (Tokyo/London/New York)\n- Weekend off toggle\n- Smart dashboard (auto-hides in real-time)\n- Clean visual design\n\n---\n\n## ðŸ™ Credits\n\nDeveloped by **Hash Capital Research**\n\nIf you find this strategy useful, please give it a like and share with others!\n\n---\n\n## âš–ï¸ Disclaimer\n\nThis strategy is for educational purposes only. Trading involves substantial risk of loss and is not suitable for all investors. Past performance is not indicative of future results. Always do your own research and consult with a qualified financial advisor before trading.\n\n---\n\n## ðŸ“¬ Feedback\n\nHave suggestions or found a bug? Leave a comment below! I'm continuously improving this strategy based on community feedback.\n\n---\n\n**Happy Trading! ðŸš€ðŸ“ˆ**",
    "image_url": "L6VNlhiV",
    "author": "Hash_Capital",
    "likes": 390,
    "type": "strategy",
    "created": "2025-11-20",
    "updated": "2025-11-20",
    "source": "//@version=6\r\nstrategy(\"Hash Momentum Strategy\", \r\n         overlay=true, \r\n         default_qty_type=strategy.percent_of_equity, \r\n         default_qty_value=100,\r\n         initial_capital=10000,\r\n         commission_type=strategy.commission.percent,\r\n         commission_value=0.075,\r\n         slippage=5,\r\n         margin_long=0,\r\n         margin_short=0,\r\n         pyramiding=0,\r\n         process_orders_on_close=true)\r\n\r\n// ============================================\r\n// ðŸ“Š CORE STRATEGY SETTINGS\r\n// ============================================\r\n// Momentum Settings\r\nmomLength = input.int(13, \"Momentum Length\", minval=6, maxval=60, group=\"Core Strategy\", tooltip=\"Higher = stronger signals, fewer trades\")\r\nmomThreshold = input.float(2.25, \"Momentum Threshold (ATR Multiplier)\", minval=0.5, maxval=5.0, step=0.25, group=\"Core Strategy\", tooltip=\"Higher = only strongest momentum moves\")\r\n\r\n// EMA Trend Filter\r\nuseTrendFilter = input.bool(true, \"Use EMA Trend Filter\", group=\"Core Strategy\", tooltip=\"Only trade with EMA trend direction\")\r\nemaLength = input.int(28, \"EMA Length\", minval=20, maxval=200, group=\"Core Strategy\", tooltip=\"Trend reference - stay above for longs, below for shorts\")\r\n\r\n// Session Filters\r\nuseSessionFilter = input.bool(false, \"Use Trading Session Filter\", group=\"Filters\", tooltip=\"Only trade during specific sessions\")\r\nallowTokyo = input.bool(false, \"Tokyo Session (00:00-09:00 JST)\", group=\"Filters\", tooltip=\"Asian session - lower volatility\")\r\nallowLondon = input.bool(false, \"London Session (08:00-17:00 GMT)\", group=\"Filters\", tooltip=\"European session - high volume\")\r\nallowNewYork = input.bool(false, \"New York Session (08:00-17:00 EST)\", group=\"Filters\", tooltip=\"US session - highest liquidity\")\r\n\r\n// Weekend Filter\r\nuseWeekendOff = input.bool(false, \"Weekend Off (No Trading)\", group=\"Filters\", tooltip=\"Disable trading on weekends (Sat-Sun) to avoid low liquidity\")\r\n\r\n// ============================================\r\n// ðŸ’° RISK MANAGEMENT - PERCENTAGE BASED\r\n// ============================================\r\nstopLossPerc = input.float(2.2, \"Stop Loss %\", minval=0.5, maxval=10, step=0.1, group=\"Risk Management\", tooltip=\"Fixed percentage stop loss\")\r\n\r\n// Risk:Reward Ratio\r\nriskRewardRatio = input.float(2.5, \"Risk:Reward Ratio\", minval=1.0, maxval=5.0, step=0.5, group=\"Risk Management\", tooltip=\"1.5 = 1.5x reward for 1x risk | 2.0 = 2x reward | 3.0 = 3x reward\")\r\n\r\n// Partial Profit Taking\r\nusePartialTp = input.bool(true, \"Use Partial Profit Taking\", group=\"Risk Management\", tooltip=\"Take profits in stages to lock in gains\")\r\ntp1Ratio = input.float(2.0, \"First TP R:R\", minval=0.5, maxval=3.0, step=0.5, group=\"Risk Management\", tooltip=\"First target as multiple of risk\")\r\ntp1Percent = input.int(50, \"First TP Size %\", minval=10, maxval=90, group=\"Risk Management\")\r\ntp2Ratio = input.float(2.5, \"Second TP R:R\", minval=0.5, maxval=4.0, step=0.5, group=\"Risk Management\")\r\ntp2Percent = input.int(40, \"Second TP Size %\", minval=10, maxval=90, group=\"Risk Management\")\r\n\r\n// Trade Management\r\nuseCooldown = input.bool(true, \"Use Trade Cooldown\", group=\"Trade Management\", tooltip=\"Prevent overtrading\")\r\ncooldownBars = input.int(6, \"Cooldown Bars\", minval=1, maxval=24, group=\"Trade Management\")\r\n\r\n// ============================================\r\n// ðŸ“ˆ CALCULATIONS\r\n// ============================================\r\n// Momentum\r\nmomentum(src, len) => src - src[len]\r\nmom0 = momentum(close, momLength)\r\nmom1 = momentum(mom0, 1)\r\nmomStdev = ta.stdev(mom0, momLength * 3)\r\nmomNormalized = momStdev > 0 ? mom0 / momStdev : 0\r\n\r\n// EMA Trend\r\nema = ta.ema(close, emaLength)\r\nbullishTrend = close > ema\r\nbearishTrend = close < ema\r\n\r\n// ATR for momentum threshold only\r\natr = ta.atr(14)\r\ndynamicThreshold = atr * momThreshold\r\n\r\n// Cooldown tracking\r\nvar int lastTradeBar = 0\r\nvar bool inCooldown = false\r\nif strategy.closedtrades > strategy.closedtrades[1]\r\n    lastTradeBar := bar_index\r\ninCooldown := useCooldown and (bar_index - lastTradeBar) < cooldownBars\r\n\r\n// Session detection (using hour in UTC)\r\n// Tokyo: 00:00-09:00 JST = 15:00-00:00 UTC (previous day) \r\n// London: 08:00-17:00 GMT = 08:00-17:00 UTC\r\n// New York: 08:00-17:00 EST = 13:00-22:00 UTC\r\ntokyoSession = (hour >= 15 or hour < 0)  // 15:00 UTC - 00:00 UTC (next day)\r\nlondonSession = (hour >= 8 and hour < 17)\r\nnewYorkSession = (hour >= 13 and hour < 22)\r\n\r\n// Check if current time matches allowed sessions\r\nvalidSession = true\r\nif useSessionFilter\r\n    validSession := (allowTokyo and tokyoSession) or (allowLondon and londonSession) or (allowNewYork and newYorkSession)\r\n\r\n// Weekend detection (Saturday = 7, Sunday = 1 in Pine Script)\r\nisWeekend = dayofweek == 7 or dayofweek == 1\r\nallowWeekend = useWeekendOff ? not isWeekend : true\r\n\r\n// ============================================\r\n// ðŸŽ¯ SIGNAL LOGIC\r\n// ============================================\r\n// Core momentum conditions\r\nlongMomentum = mom0 > dynamicThreshold and mom1 > 0 and momNormalized > 0.5 and close > close[1]\r\nshortMomentum = mom0 < -dynamicThreshold and mom1 < 0 and momNormalized < -0.5 and close < close[1]\r\n\r\n// Apply trend filter\r\ntrendCheck = useTrendFilter ? (longMomentum ? bullishTrend : shortMomentum ? bearishTrend : false) : true\r\n\r\n// Apply session filter\r\nsessionCheck = useSessionFilter ? validSession : true\r\n\r\n// Apply weekend filter\r\nweekendCheck = allowWeekend\r\n\r\n// Final signals\r\nlongSignal = longMomentum and trendCheck and sessionCheck and weekendCheck and not inCooldown and strategy.position_size == 0\r\nshortSignal = shortMomentum and trendCheck and sessionCheck and weekendCheck and not inCooldown and strategy.position_size == 0\r\n\r\n// ============================================\r\n// ðŸ’µ POSITION MANAGEMENT\r\n// ============================================\r\nvar float entryPrice = 0.0\r\nvar float stopLoss = 0.0\r\nvar float takeProfit = 0.0\r\nvar float riskAmount = 0.0\r\n\r\n// Calculate stops and targets (percentage-based)\r\ncalcLongStop() => close * (1 - stopLossPerc / 100)\r\ncalcShortStop() => close * (1 + stopLossPerc / 100)\r\n\r\n// ============================================\r\n// ðŸ“ ENTRY LOGIC\r\n// ============================================\r\nif longSignal\r\n    entryPrice := close\r\n    stopLoss := calcLongStop()\r\n    riskAmount := entryPrice - stopLoss\r\n    takeProfit := entryPrice + (riskAmount * riskRewardRatio)\r\n    \r\n    strategy.entry(\"Long\", strategy.long, comment=\"LONG\")\r\n    \r\n    if usePartialTp\r\n        tp1Price = entryPrice + (riskAmount * tp1Ratio)\r\n        tp2Price = entryPrice + (riskAmount * tp2Ratio)\r\n        \r\n        strategy.exit(\"TP1\", \"Long\", qty_percent=tp1Percent, limit=tp1Price, stop=stopLoss, comment=\"TP1\")\r\n        strategy.exit(\"TP2\", \"Long\", qty_percent=tp2Percent, limit=tp2Price, stop=stopLoss, comment=\"TP2\")\r\n        strategy.exit(\"TP Final\", \"Long\", limit=takeProfit, stop=stopLoss, comment=\"TP Final\")\r\n    else\r\n        strategy.exit(\"Exit\", \"Long\", limit=takeProfit, stop=stopLoss, comment=\"Exit\")\r\n\r\nif shortSignal\r\n    entryPrice := close\r\n    stopLoss := calcShortStop()\r\n    riskAmount := stopLoss - entryPrice\r\n    takeProfit := entryPrice - (riskAmount * riskRewardRatio)\r\n    \r\n    strategy.entry(\"Short\", strategy.short, comment=\"SHORT\")\r\n    \r\n    if usePartialTp\r\n        tp1Price = entryPrice - (riskAmount * tp1Ratio)\r\n        tp2Price = entryPrice - (riskAmount * tp2Ratio)\r\n        \r\n        strategy.exit(\"TP1\", \"Short\", qty_percent=tp1Percent, limit=tp1Price, stop=stopLoss, comment=\"TP1\")\r\n        strategy.exit(\"TP2\", \"Short\", qty_percent=tp2Percent, limit=tp2Price, stop=stopLoss, comment=\"TP2\")\r\n        strategy.exit(\"TP Final\", \"Short\", limit=takeProfit, stop=stopLoss, comment=\"TP Final\")\r\n    else\r\n        strategy.exit(\"Exit\", \"Short\", limit=takeProfit, stop=stopLoss, comment=\"Exit\")\r\n\r\n// Exit on opposite signals\r\nvar bool longExited = false\r\nvar bool shortExited = false\r\n\r\nif strategy.position_size > 0 and shortSignal\r\n    strategy.close(\"Long\", comment=\"Reverse\")\r\n    longExited := true\r\nelse\r\n    longExited := false\r\n\r\nif strategy.position_size < 0 and longSignal\r\n    strategy.close(\"Short\", comment=\"Reverse\")\r\n    shortExited := true\r\nelse\r\n    shortExited := false\r\n\r\n// Track regular exits (TP/SL)\r\nif strategy.position_size == 0 and strategy.position_size[1] > 0\r\n    longExited := true\r\nif strategy.position_size == 0 and strategy.position_size[1] < 0\r\n    shortExited := true\r\n\r\n// ============================================\r\n// ðŸŽ¨ VISUAL ENHANCEMENTS\r\n// ============================================\r\n// EMA with gradient color based on trend strength\r\nemaColor = bullishTrend ? color.new(#00ff41, 30) : bearishTrend ? color.new(#ff1744, 30) : color.new(color.gray, 50)\r\nplot(ema, \"EMA Trend\", color=emaColor, linewidth=2)\r\n\r\n// Entry signals - tiny fluorescent dots\r\nplotshape(longSignal, \"Long Entry\", shape.circle, location.belowbar, color.new(#00ff41, 0), size=size.tiny)\r\nplotshape(shortSignal, \"Short Entry\", shape.circle, location.abovebar, color.new(#ff1744, 0), size=size.tiny)\r\n\r\n// Exit signals - X markers\r\nplotshape(longExited, \"Long Exit\", shape.xcross, location.abovebar, color.new(#00bfff, 0), size=size.tiny)\r\nplotshape(shortExited, \"Short Exit\", shape.xcross, location.belowbar, color.new(#ffa500, 0), size=size.tiny)\r\n\r\n// Position lines\r\nisLong = strategy.position_size > 0\r\nisShort = strategy.position_size < 0\r\nplot(isLong or isShort ? entryPrice : na, \"Entry\", color.new(color.white, 40), style=plot.style_linebr, linewidth=1)\r\nplot(isLong or isShort ? stopLoss : na, \"Stop Loss\", color.new(color.red, 20), style=plot.style_linebr, linewidth=2)\r\nplot(isLong or isShort ? takeProfit : na, \"Take Profit\", color.new(color.lime, 20), style=plot.style_linebr, linewidth=2)\r\n\r\n// Partial TP levels - calculate outside if blocks\r\ntp1Price = (isLong or isShort) ? (isLong ? entryPrice + (riskAmount * tp1Ratio) : entryPrice - (riskAmount * tp1Ratio)) : na\r\ntp2Price = (isLong or isShort) ? (isLong ? entryPrice + (riskAmount * tp2Ratio) : entryPrice - (riskAmount * tp2Ratio)) : na\r\n\r\n// Plot TP levels (only show when partial TP is enabled and in position)\r\nplot(usePartialTp and (isLong or isShort) ? tp1Price : na, \"TP1\", color.new(color.green, 50), style=plot.style_linebr, linewidth=1)\r\nplot(usePartialTp and (isLong or isShort) ? tp2Price : na, \"TP2\", color.new(color.green, 50), style=plot.style_linebr, linewidth=1)\r\n\r\n// ============================================\r\n// ðŸ“Š DASHBOARD (Hidden when \"On every tick\" is enabled)\r\n// ============================================\r\nvar table dashboard = table.new(position.top_right, 2, 11, border_width=1)\r\n\r\n// Only show dashboard when NOT calculating on every tick\r\nif barstate.islast and not barstate.isrealtime\r\n    // Header\r\n    table.cell(dashboard, 0, 0, \"Hash Momentum\", bgcolor=color.new(#1e1e1e, 10), text_color=#00ff41, text_size=size.normal)\r\n    table.cell(dashboard, 1, 0, \"\", bgcolor=color.new(#1e1e1e, 10))\r\n    \r\n    // Position\r\n    table.cell(dashboard, 0, 1, \"Position\", text_color=color.gray, text_size=size.small)\r\n    posText = isLong ? \"LONG\" : isShort ? \"SHORT\" : \"FLAT\"\r\n    posColor = isLong ? #00ff41 : isShort ? #ff1744 : color.gray\r\n    table.cell(dashboard, 1, 1, posText, text_color=posColor, text_size=size.small)\r\n    \r\n    row_offset = 0\r\n    \r\n    if isLong or isShort\r\n        table.cell(dashboard, 0, 2 + row_offset, \"Entry\", text_color=color.gray, text_size=size.small)\r\n        table.cell(dashboard, 1, 2 + row_offset, str.tostring(math.round(entryPrice, 2)), text_color=color.white, text_size=size.small)\r\n        \r\n        // Stop Loss\r\n        table.cell(dashboard, 0, 3 + row_offset, \"Stop Loss\", text_color=color.gray, text_size=size.small)\r\n        table.cell(dashboard, 1, 3 + row_offset, str.tostring(math.round(stopLoss, 2)), text_color=color.red, text_size=size.small)\r\n        \r\n        // Take Profit\r\n        table.cell(dashboard, 0, 4 + row_offset, \"Take Profit\", text_color=color.gray, text_size=size.small)\r\n        table.cell(dashboard, 1, 4 + row_offset, str.tostring(math.round(takeProfit, 2)), text_color=color.lime, text_size=size.small)\r\n        \r\n        // Risk:Reward\r\n        table.cell(dashboard, 0, 5 + row_offset, \"R:R Ratio\", text_color=color.gray, text_size=size.small)\r\n        table.cell(dashboard, 1, 5 + row_offset, \"1:\" + str.tostring(riskRewardRatio), text_color=#00ff41, text_size=size.small)\r\n    \r\n    // Momentum\r\n    table.cell(dashboard, 0, 6 + row_offset, \"Momentum\", text_color=color.gray, text_size=size.small)\r\n    momText = str.tostring(math.round(momNormalized, 2)) + \"Ïƒ\"\r\n    momColor = math.abs(momNormalized) > 0.5 ? (momNormalized > 0 ? #00ff41 : #ff1744) : color.gray\r\n    table.cell(dashboard, 1, 6 + row_offset, momText, text_color=momColor, text_size=size.small)\r\n    \r\n    // Stats\r\n    table.cell(dashboard, 0, 7 + row_offset, \"Trades\", text_color=color.gray, text_size=size.small)\r\n    table.cell(dashboard, 1, 7 + row_offset, str.tostring(strategy.closedtrades), text_color=color.white, text_size=size.small)\r\n    \r\n    winRate = strategy.closedtrades > 0 ? (strategy.wintrades / strategy.closedtrades) * 100 : 0\r\n    table.cell(dashboard, 0, 8 + row_offset, \"Win Rate\", text_color=color.gray, text_size=size.small)\r\n    winColor = winRate >= 50 ? #00ff41 : winRate >= 40 ? color.yellow : #ff1744\r\n    table.cell(dashboard, 1, 8 + row_offset, str.tostring(math.round(winRate, 1)) + \"%\", text_color=winColor, text_size=size.small)\r\n    \r\n    netProfitPerc = strategy.initial_capital > 0 ? (strategy.netprofit / strategy.initial_capital) * 100 : 0\r\n    table.cell(dashboard, 0, 9 + row_offset, \"Profit\", text_color=color.gray, text_size=size.small)\r\n    profitColor = netProfitPerc > 0 ? #00ff41 : #ff1744\r\n    table.cell(dashboard, 1, 9 + row_offset, str.tostring(math.round(netProfitPerc, 1)) + \"%\", text_color=profitColor, text_size=size.small)\r\n\r\n// ============================================\r\n// ðŸ”” ALERTS\r\n// ============================================\r\nalertcondition(longSignal, title=\"Long Signal\", message=\"LONG: {{ticker}} @ {{close}}\")\r\nalertcondition(shortSignal, title=\"Short Signal\", message=\"SHORT: {{ticker}} @ {{close}}\")\r\nalertcondition(strategy.position_size > strategy.position_size[1], title=\"Position Opened\", message=\"Position opened on {{ticker}}\")\r\nalertcondition(strategy.position_size == 0 and strategy.position_size[1] != 0, title=\"Position Closed\", message=\"Position closed on {{ticker}}\")\r\n"
  },
  {
    "url": "ER2j409r-Pivot-Fib-4H-EA",
    "name": "Pivot Fib 4H â€” EA",
    "description": "Strategy uses the pivot standard to open position, it has well define entry and exit point with SL, it also has a proper money management plan, maximum 4 trades a day, each trade risk 0.5% of the account, I have it EA version of it also.",
    "image_url": "ER2j409r",
    "author": "kennwes_okoth",
    "likes": 31,
    "type": "strategy",
    "created": "2025-11-20",
    "updated": "2025-11-20",
    "source": "//@version=5\nstrategy(\"Pivot Fib 4H â€” S1/S3 R1/R3 (30-pip SL, High/Low entry, SL/TP labels)\", overlay=true, pyramiding=4, default_qty_type=strategy.fixed, default_qty_value=1)\n\n// -------------------- INPUTS --------------------\nnear_threshold_pct     = input.float(0.2,   \"Near threshold (%)\", step=0.01)\nrisk_pct               = input.float(0.5,   \"Risk % per trade\",    step=0.1)\ndaily_max_loss_pct     = input.float(2.0,   \"Daily max loss %\",    step=0.1)\ncontract_size          = input.float(1.0,   \"Contract size multiplier\", step=0.01)\npip_size               = input.float(0.0001,\"One pip in price units (e.g., 0.0001 for most FX, 0.01 for JPY)\")\nsame_bar_prefers_tp    = input.bool(false,  \"If TP & SL in same bar, prefer TP?\")\nmax_positions_per_day  = input.int(4,       \"Max positions per day\", minval=1)\n\n// -------------------- DAILY PIVOTS (Fibonacci) --------------------\n// request daily values (uses today's daily high/low/close for pivots)\nres = \"D\"\n[d_high, d_low, d_close] = request.security(syminfo.tickerid, res, [high, low, close], lookahead = barmerge.lookahead_on)\npp  = (d_high + d_low + d_close) / 3.0\nrng = d_high - d_low\nr1  = pp + 0.382 * rng\nr2  = pp + 0.618 * rng\nr3  = pp + rng\ns1  = pp - 0.382 * rng\ns2  = pp - 0.618 * rng\ns3  = pp - rng\n\n// Optional: draw pivots on chart\nplot(pp, title=\"PP\", linewidth=1, color=color.gray)\nplot(r1, title=\"R1\", linewidth=1, color=color.orange)\nplot(r2, title=\"R2\", linewidth=1, color=color.orange)\nplot(r3, title=\"R3\", linewidth=1, color=color.orange)\nplot(s1, title=\"S1\", linewidth=1, color=color.blue)\nplot(s2, title=\"S2\", linewidth=1, color=color.blue)\nplot(s3, title=\"S3\", linewidth=1, color=color.blue)\n\n// -------------------- SIGNAL RULES --------------------\nisMonday = dayofweek == dayofweek.monday\nopen_near_s1 = not na(s1) and math.abs(open - s1) <= (s1 * (near_threshold_pct / 100.0))\nopen_near_r1 = not na(r1) and math.abs(open - r1) <= (r1 * (near_threshold_pct / 100.0))\n\nbuy_s1 = isMonday and open_near_s1 and high > s1 and close > s1\nbuy_s3 = not na(s3) and low < s3 and close > s3\n\nsell_r1 = isMonday and open_near_r1 and low < r1 and close < r1\nsell_r3 = not na(r3) and high > r3 and close < r3\n\n// Trigger only when the boolean becomes true on this bar (prevents multiple entries while condition persists)\nsig_long_boolean  = buy_s1 or buy_s3\nsig_short_boolean = sell_r1 or sell_r3\nsig_long_trigger  = sig_long_boolean and not nz(sig_long_boolean[1], false)\nsig_short_trigger = sig_short_boolean and not nz(sig_short_boolean[1], false)\nsig_trigger       = sig_long_trigger or sig_short_trigger\n\n// Determine signal text (use only for labeling)\nsig_text = sig_long_trigger ? (buy_s1 ? \"BUY_S1\" : \"BUY_S3\") : sig_short_trigger ? (sell_r1 ? \"SELL_R1\" : \"SELL_R3\") : \"\"\n\n// -------------------- SL/TP RULES (30 pips) --------------------\npip_offset = 30.0 * pip_size\nfloat sl_price = na\nfloat tp_price = na\n\nif sig_long_trigger\n    // choose which long signal triggered\n    if buy_s1\n        sl_price := s1 - pip_offset\n        tp_price := pp\n    else\n        // BUY_S3\n        sl_price := s3 - pip_offset\n        tp_price := s1\nelse if sig_short_trigger\n    if sell_r1\n        sl_price := r1 + pip_offset\n        tp_price := pp\n    else\n        // SELL_R3\n        sl_price := r3 + pip_offset\n        tp_price := r1\n\n// -------------------- ENTRY PRICE (High for BUY, Low for SELL) --------------------\nfloat entry_price = na\nif sig_long_trigger\n    entry_price := high    // buy at signal candle HIGH\nelse if sig_short_trigger\n    entry_price := low     // sell at signal candle LOW\n\n// -------------------- POSITION SIZING --------------------\nfloat price_diff = na\nprice_diff := nz(math.abs(entry_price - sl_price))\nfloat qty = na\nif sig_trigger and not na(price_diff) and price_diff > 0\n    float risk_amount = strategy.equity * (risk_pct / 100.0)\n    float qty_calc = (risk_amount / price_diff) * contract_size\n    qty := qty_calc > 0 ? qty_calc : na\n\n// -------------------- DAILY COUNTERS & LIMITS --------------------\nvar int trades_today = 0\nvar int last_day = 0\nint curr_day = year * 10000 + month * 100 + dayofmonth\n\n// When the day changes, reset counters and set start_of_day equity\nvar float start_equity_daily = na\nif curr_day != last_day\n    trades_today := 0\n    last_day := curr_day\n    start_equity_daily := strategy.equity\n\n// daily drawdown percent since start of day\nfloat daily_drawdown_pct = na\ndaily_drawdown_pct := start_equity_daily == 0 ? 0.0 : (start_equity_daily - strategy.equity) / start_equity_daily * 100.0\nbool daily_stop_hit = daily_drawdown_pct >= daily_max_loss_pct\n\nbool can_enter = trades_today < max_positions_per_day\n\n// Arrays to hold labels so they persist (optional)\nvar label[] labels_sl = array.new<label>()\nvar label[] labels_tp = array.new<label>()\n\n// typed label variables (declare before using)\nlabel label_sl = na\nlabel label_tp = na\n\nif sig_trigger and not daily_stop_hit and can_enter and not na(qty)\n    // place orders\n    if sig_long_trigger\n        strategy.entry(\"Long_\"+sig_text, strategy.long, qty=qty)\n        strategy.exit(\"Exit_Long_\"+sig_text, \"Long_\"+sig_text, stop=sl_price, limit=tp_price)\n    else\n        strategy.entry(\"Short_\"+sig_text, strategy.short, qty=qty)\n        strategy.exit(\"Exit_Short_\"+sig_text, \"Short_\"+sig_text, stop=sl_price, limit=tp_price)\n\n    trades_today += 1\n\n    // create SL and TP labels at this bar (use := to assign to previously-declared label variables)\n    string sl_txt = \"SL: \" + str.tostring(sl_price, format.mintick)\n    string tp_txt = \"TP: \" + str.tostring(tp_price, format.mintick)\n    if sig_long_trigger\n        label_sl := label.new(bar_index, sl_price, sl_txt, xloc=xloc.bar_index, yloc=yloc.price,\n                              style=label.style_label_down, color=color.new(color.red, 0), textcolor=color.white)\n        label_tp := label.new(bar_index, tp_price, tp_txt, xloc=xloc.bar_index, yloc=yloc.price,\n                              style=label.style_label_up, color=color.new(color.green, 0), textcolor=color.white)\n    else\n        label_sl := label.new(bar_index, sl_price, sl_txt, xloc=xloc.bar_index, yloc=yloc.price,\n                              style=label.style_label_up, color=color.new(color.red, 0), textcolor=color.white)\n        label_tp := label.new(bar_index, tp_price, tp_txt, xloc=xloc.bar_index, yloc=yloc.price,\n                              style=label.style_label_down, color=color.new(color.green, 0), textcolor=color.white)\n\n    array.push(labels_sl, label_sl)\n    array.push(labels_tp, label_tp)\n\n// -------------------- VISUAL SIGNALS --------------------\nplotshape(buy_s1, title=\"Buy S1\", location=location.belowbar, color=color.green, style=shape.labelup, text=\"BUY S1\")\nplotshape(buy_s3, title=\"Buy S3\", location=location.belowbar, color=color.lime,  style=shape.labelup, text=\"BUY S3\")\nplotshape(sell_r1, title=\"Sell R1\", location=location.abovebar, color=color.red,   style=shape.labeldown, text=\"SELL R1\")\nplotshape(sell_r3, title=\"Sell R3\", location=location.abovebar, color=color.maroon, style=shape.labeldown, text=\"SELL R3\")\n\n// Optional info label (last bar)\nif barstate.islast\n    string info_text = \"Near%: \" + str.tostring(near_threshold_pct) + \"  Pip size: \" + str.tostring(pip_size) + \"  Risk%: \" + str.tostring(risk_pct) + \"  Max/day: \" + str.tostring(max_positions_per_day)\n    label.new(bar_index, high, info_text, xloc=xloc.bar_index, yloc=yloc.abovebar, style=label.style_label_left, color=color.new(color.black, 80), textcolor=color.white)\n"
  },
  {
    "url": "kPMkolMU-ILM-IFVG-Strategy",
    "name": "ILM & IFVG Strategy",
    "description": "Please feel free to adjust in any way possible. Let me know if you can create something better from this initial coding.\n\n//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n//                 Inverted Liquidity Model (ILM) â€“ Strategy\n//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n//\n//  The **Inverted Liquidity Model (ILM)** is a liquidity-based algorithm \n//  built to capture high-probability reversals after:\n//\n//      â€¢ A liquidity sweep (SSL/BSL taken)  \n//      â€¢ Rejection back inside the range  \n//      â€¢ A Fair Value Gap (FVG) forms  \n//      â€¢ That FVG becomes invalidated â†’ becomes an IFVG entry zone  \n//\n//  ILM combines:\n//      â€¢ LTF BOS / CHOCH structure confirmation  \n//      â€¢ HTF structure (expansion) filtering  \n//      â€¢ Premium / Discount filter (17:00 CST session midline)  \n//      â€¢ Optional ATR volatility filter  \n//      â€¢ Optional trading session restrictions  \n//      â€¢ Optional partial profit-taking + runners  \n//\n//  When all conditions align, the strategy enters:\n//      âœ” Long after sweep of SSL + valid long IFVG + trend confirmation  \n//      âœ” Short after sweep of BSL + valid short IFVG + trend confirmation  \n//\n//  Stops are placed at the sweep wick.  \n//  Full target is set at the next structural high/low.  \n//  Optional partial TP sends a runner to full target.\n//\n//  Visual tools (labels, sweep lines, IFVG boxes, midline) assist \n//  with review and forward testing.\n//\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n//                    USER CONFIGURABLE FEATURES\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n//\n//  â€¢ **Liquidity & Structure**\n//      - pivotLen                â†’ swing length for pivots / liquidity\n//      - htfOn                   â†’ toggle higher-timeframe pivots\n//      - htfTF                   â†’ timeframe for HTF structure/liquidity\n//      - useStructureFilter      â†’ enforce LTF BOS/CHOCH trend\n//      - useHtfExpansionFilter   â†’ enforce HTF trend\n//      - showStructureLabels     â†’ show BOS/CHOCH labels\n//      - showHtfStructureLabels  â†’ show HTF BOS/CHOCH labels\n//\n//  â€¢ **Premium / Discount Midline**\n//      - usePremiumDiscountFilter  â†’ only long in discount / short in premium\n//      - pdSession                 â†’ session used for midline (default 17:00 CST)\n//      - showPdMidLine             â†’ show 50% midline\n//\n//  â€¢ **FVG / IFVG Detection**\n//      - useBodyGapFVG           â†’ FVG uses candle bodies instead of wicks\n//      - useDisplacementFVG      â†’ require displacement bar\n//      - dispAtrMult             â†’ minimum ATR threshold for displacement\n//      - showIFVG                â†’ draw IFVG boxes\n//\n//  â€¢ **ATR / Volatility / Sessions**\n//      - useRangeFilter          â†’ require minimum ATR%\n//      - atrLen                  â†’ ATR period\n//      - minAtrPerc              â†’ minimum ATR% of price\n//      - useSessionFilter        â†’ restrict trading hours\n//      - sessionTimes            â†’ allowed trading session\n//\n//  â€¢ **Sweep Visualization**\n//      - showSweepLines          â†’ draw sweep lines at SSL/BSL sweeps\n//      - sweepLineWidth          â†’ thickness of sweep lines\n//\n//  â€¢ **Exits: Partial Targets & Runners**\n//      - usePartialTargets       â†’ enable partial TP logic\n//      - tp1QtyPercent           â†’ percent closed at TP1\n//      - tp1FractionOfPath       â†’ TP1 relative to path to full target\n//\n//  â€¢ **Formatting / Visibility**\n//      - labelFontSizeInput      â†’ tiny / small / normal / large / huge\n//      - showEntries             â†’ entry markers\n//      - showTargets             â†’ target lines\n//\n//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n//                      END OF STRATEGY DESCRIPTION\n//â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n",
    "image_url": "kPMkolMU",
    "author": "jettrader45",
    "likes": 13,
    "type": "strategy",
    "created": "2025-11-20",
    "updated": "2025-11-20",
    "source": "//@version=6\nstrategy(\"ILM v6 + BOS/CHOCH + HTF + Sweeps + IFVG + Partials + FontSize + PD Filter\",\n     overlay = true,\n     fill_orders_on_standard_ohlc = true)\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// INPUTS\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\npivotLen          = input.int(2, \"Swing length (SSL/BSL)\", minval = 1)\nhtfOn             = input.bool(true, \"Use HTF Liquidity?\")\nhtfTF             = input.timeframe(\"15\", \"HTF Timeframe (Liquidity & Filter)\")\nbarsAfterSweepMax = input.int(40, \"Max bars after sweep\", minval = 5)\n\nuseSessionFilter  = input.bool(false, \"Use session filter?\")\nsessionTimes      = input.session(\"0700-1700\", \"Session (exchange time)\")\n\nuseRangeFilter    = input.bool(true, \"Use ATR filter?\")\natrLen            = input.int(14, \"ATR Length\", minval = 1)\nminAtrPerc        = input.float(0.1, \"Min ATR% of price (0 = off)\", minval = 0.0, step = 0.1)\n\n// LTF structure filter & labels\nuseStructureFilter   = input.bool(true, \"Use LTF BOS/CHOCH structure filter?\")\nshowStructureLabels  = input.bool(true, \"Show LTF BOS/CHOCH labels?\")\n\n// HTF expansion / structure filter\nuseHtfExpansionFilter  = input.bool(true, \"Use HTF expansion (structure) filter?\")\nshowHtfStructureLabels = input.bool(false, \"Show HTF BOS/CHOCH labels?\")\n\n// Sweep lines\nshowSweepLines = input.bool(true, \"Show sweep lines?\")\nsweepLineWidth = input.int(2, \"Sweep line width\", minval = 1, maxval = 5)\n\n// Improved FVG / IFVG detection\nuseBodyGapFVG      = input.bool(true, \"FVG uses body gaps (vs wicks)?\")\nuseDisplacementFVG = input.bool(true, \"Require displacement candle for FVG?\")\ndispAtrMult        = input.float(1.0, \"Min displacement (ATR multiples)\", minval = 0.0, step = 0.1)\n\n// Partial targets / runner\nusePartialTargets  = input.bool(true, \"Use partial targets / runner?\")\ntp1QtyPercent      = input.float(50.0, \"TP1 quantity %\", minval = 1.0, maxval = 99.0)\ntp1FractionOfPath  = input.float(0.5, \"TP1 fraction between entry & final target\", minval = 0.1, maxval = 0.9, step = 0.05)\n\n// Label font size\nlabelFontSizeInput = input.string(\"small\", \"Label Font Size\",\n     options = [\"tiny\", \"small\", \"normal\", \"large\", \"huge\"])\n\nlabelFontSize =\n     labelFontSizeInput == \"tiny\"  ? size.tiny  :\n     labelFontSizeInput == \"small\" ? size.small :\n     labelFontSizeInput == \"normal\" ? size.normal :\n     labelFontSizeInput == \"large\" ? size.large :\n     size.huge\n\n// NEW: Premium/Discount filter (17:00 CST session midline)\nusePremiumDiscountFilter = input.bool(true, \"Use premium/discount filter?\")\npdSession                = input.session(\"1700-1659\", \"Premium/Discount session (exchange time)\")\nshowPdMidLine            = input.bool(true, \"Show premium/discount 50% line?\")\n\nshowIFVG    = input.bool(true, \"Show IFVG boxes?\")\nshowEntries = input.bool(true, \"Show entries?\")\nshowTargets = input.bool(true, \"Show targets?\")\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// SESSION & RANGE FILTERS\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\ninSession = useSessionFilter ? not na(time(timeframe.period, sessionTimes)) : true\n\natrValue = ta.atr(atrLen)\natrPerc  = atrValue / close * 100.0\nrangeOk  = not useRangeFilter or (minAtrPerc <= 0.0 or atrPerc >= minAtrPerc)\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// PREMIUM / DISCOUNT MIDLINE (17:00 CST STYLE SESSION)\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\npdSessTime = time(timeframe.period, pdSession)\n// New PD session when time() for that session changes from 0â†’non-zero\nnewPdSession = ta.change(pdSessTime) > 0\n\nvar float pdHigh = na\nvar float pdLow  = na\n\nif newPdSession or na(pdHigh) or na(pdLow)\n    // First bar of the PD session: reset range\n    pdHigh := high\n    pdLow  := low\nelse if pdSessTime != 0\n    // Inside PD session: extend range\n    pdHigh := math.max(pdHigh, high)\n    pdLow  := math.min(pdLow, low)\n\n// Midline\npdMid = (pdHigh + pdLow) / 2.0\n\n// Plot PD midline\nplot(showPdMidLine and not na(pdMid) ? pdMid : na,\n     title = \"Premium/Discount Mid (17:00 session)\",\n     style = plot.style_linebr,\n     color = color.new(color.yellow, 0),\n     linewidth = 2)\n\n// PD filters for entries\npdOkLong  = not usePremiumDiscountFilter or (not na(pdMid) and close < pdMid)  // discount\npdOkShort = not usePremiumDiscountFilter or (not na(pdMid) and close > pdMid)  // premium\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// LIQUIDITY LEVELS (SSL / BSL)\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\npivHigh = ta.pivothigh(high, pivotLen, pivotLen)\npivLow  = ta.pivotlow(low, pivotLen, pivotLen)\n\nhtfHigh = htfOn ? request.security(syminfo.tickerid, htfTF, ta.pivothigh(high, pivotLen, pivotLen)) : na\nhtfLow  = htfOn ? request.security(syminfo.tickerid, htfTF, ta.pivotlow(low, pivotLen, pivotLen))  : na\n\nvar float ssl = na\nvar float bsl = na\n\nif htfOn\n    if not na(htfLow)\n        ssl := htfLow\n    if not na(htfHigh)\n        bsl := htfHigh\nelse\n    if not na(pivLow)\n        ssl := pivLow\n    if not na(pivHigh)\n        bsl := pivHigh\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// LTF BOS / CHOCH STRUCTURE DETECTION\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nvar float structHigh   = na\nvar float structLow    = na\nvar int   structTrend  = 0   // 1 = uptrend, -1 = downtrend, 0 = unknown\n\nvar bool bosUp     = false\nvar bool bosDown   = false\nvar bool chochUp   = false\nvar bool chochDown = false\n\nif not na(pivHigh)\n    structHigh := pivHigh\nif not na(pivLow)\n    structLow := pivLow\n\nbosUp     := false\nbosDown   := false\nchochUp   := false\nchochDown := false\n\nif not na(structHigh) and close > structHigh\n    if structTrend == -1\n        chochUp := true\n    else\n        bosUp := true\n    structTrend := 1\n    structHigh := close\n\nif not na(structLow) and close < structLow\n    if structTrend == 1\n        chochDown := true\n    else\n        bosDown := true\n    structTrend := -1\n    structLow := close\n\nif showStructureLabels and bosUp\n    label.new(bar_index, high, \"BOSâ†‘\",\n        style = label.style_label_down,\n        color = color.new(color.green, 0),\n        textcolor = color.white,\n        size = labelFontSize)\n\nif showStructureLabels and bosDown\n    label.new(bar_index, low, \"BOSâ†“\",\n        style = label.style_label_up,\n        color = color.new(color.red, 0),\n        textcolor = color.white,\n        size = labelFontSize)\n\nif showStructureLabels and chochUp\n    label.new(bar_index, high, \"CHOCHâ†‘\",\n        style = label.style_label_down,\n        color = color.new(color.teal, 0),\n        textcolor = color.white,\n        size = labelFontSize)\n\nif showStructureLabels and chochDown\n    label.new(bar_index, low, \"CHOCHâ†“\",\n        style = label.style_label_up,\n        color = color.new(color.orange, 0),\n        textcolor = color.white,\n        size = labelFontSize)\n\nstructureOkLong  = not useStructureFilter or structTrend == 1\nstructureOkShort = not useStructureFilter or structTrend == -1\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// HTF BOS / CHOCH STRUCTURE (EXPANSION FILTER)\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nhtfClose   = request.security(syminfo.tickerid, htfTF, close)\nhtfPivHigh = request.security(syminfo.tickerid, htfTF, ta.pivothigh(high, pivotLen, pivotLen))\nhtfPivLow  = request.security(syminfo.tickerid, htfTF, ta.pivotlow(low, pivotLen, pivotLen))\n\nvar float htfStructHigh  = na\nvar float htfStructLow   = na\nvar int   htfStructTrend = 0   // 1 = up, -1 = down, 0 = unknown\n\nvar bool htfBosUp     = false\nvar bool htfBosDown   = false\nvar bool htfChochUp   = false\nvar bool htfChochDown = false\n\nif not na(htfPivHigh)\n    htfStructHigh := htfPivHigh\nif not na(htfPivLow)\n    htfStructLow := htfPivLow\n\nhtfBosUp     := false\nhtfBosDown   := false\nhtfChochUp   := false\nhtfChochDown := false\n\nif not na(htfStructHigh) and htfClose > htfStructHigh\n    if htfStructTrend == -1\n        htfChochUp := true\n    else\n        htfBosUp := true\n    htfStructTrend := 1\n    htfStructHigh := htfClose\n\nif not na(htfStructLow) and htfClose < htfStructLow\n    if htfStructTrend == 1\n        htfChochDown := true\n    else\n        htfBosDown := true\n    htfStructTrend := -1\n    htfStructLow := htfClose\n\nif showHtfStructureLabels and htfBosUp\n    label.new(bar_index, high, \"HTF BOSâ†‘\",\n        style = label.style_label_down,\n        color = color.new(color.green, 60),\n        textcolor = color.white,\n        size = labelFontSize)\n\nif showHtfStructureLabels and htfBosDown\n    label.new(bar_index, low, \"HTF BOSâ†“\",\n        style = label.style_label_up,\n        color = color.new(color.red, 60),\n        textcolor = color.white,\n        size = labelFontSize)\n\nif showHtfStructureLabels and htfChochUp\n    label.new(bar_index, high, \"HTF CHOCHâ†‘\",\n        style = label.style_label_down,\n        color = color.new(color.teal, 60),\n        textcolor = color.white,\n        size = labelFontSize)\n\nif showHtfStructureLabels and htfChochDown\n    label.new(bar_index, low, \"HTF CHOCHâ†“\",\n        style = label.style_label_up,\n        color = color.new(color.orange, 60),\n        textcolor = color.white,\n        size = labelFontSize)\n\nhtfOkLong  = not useHtfExpansionFilter or htfStructTrend == 1\nhtfOkShort = not useHtfExpansionFilter or htfStructTrend == -1\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// IMPROVED FVG -> IFVG DETECTION\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nmidRange = high[1] - low[1]\ndispOk   = not useDisplacementFVG or midRange >= ta.atr(atrLen) * dispAtrMult\n\nbullFVG_raw = low[1] > high[2]\nbearFVG_raw = high[1] < low[2]\n\nbullFVG_body = math.min(open[1], close[1]) > high[2]\nbearFVG_body = math.max(open[1], close[1]) < low[2]\n\nbullFVG = (useBodyGapFVG ? bullFVG_body : bullFVG_raw) and dispOk\nbearFVG = (useBodyGapFVG ? bearFVG_body : bearFVG_raw) and dispOk\n\nvar float bfTop = na\nvar float bfBot = na\nvar float sfTop = na\nvar float sfBot = na\n\nif bullFVG\n    bfTop := low[1]\n    bfBot := high[2]\n\nif bearFVG\n    sfTop := high[1]\n    sfBot := low[2]\n\nvar bool  ifvgLong  = false\nvar float ifvgLT    = na\nvar float ifvgLB    = na\n\nvar bool  ifvgShort = false\nvar float ifvgST    = na\nvar float ifvgSB    = na\n\nif not na(sfTop) and close > sfTop\n    ifvgLong := true\n    ifvgLT   := sfTop\n    ifvgLB   := sfBot\n\nif not na(bfBot) and close < bfBot\n    ifvgShort := true\n    ifvgST    := bfTop\n    ifvgSB    := bfBot\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// DRAW IFVG BOXES\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nvar box longBox  = na\nvar box shortBox = na\n\nif showIFVG and ifvgLong and not na(ifvgLT) and not na(ifvgLB)\n    if na(longBox)\n        longBox := box.new(\n            left   = bar_index - 1,\n            top    = ifvgLT,\n            right  = bar_index,\n            bottom = ifvgLB,\n            xloc   = xloc.bar_index,\n            bgcolor      = color.new(color.lime, 80),\n            border_color = color.new(color.lime, 0))\n    else\n        box.set_left(longBox, bar_index - 1)\n        box.set_right(longBox, bar_index)\n        box.set_top(longBox, ifvgLT)\n        box.set_bottom(longBox, ifvgLB)\nelse\n    if not na(longBox)\n        box.delete(longBox)\n        longBox := na\n\nif showIFVG and ifvgShort and not na(ifvgST) and not na(ifvgSB)\n    if na(shortBox)\n        shortBox := box.new(\n            left   = bar_index - 1,\n            top    = ifvgST,\n            right  = bar_index,\n            bottom = ifvgSB,\n            xloc   = xloc.bar_index,\n            bgcolor      = color.new(color.red, 80),\n            border_color = color.new(color.red, 0))\n    else\n        box.set_left(shortBox, bar_index - 1)\n        box.set_right(shortBox, bar_index)\n        box.set_top(shortBox, ifvgST)\n        box.set_bottom(shortBox, ifvgSB)\nelse\n    if not na(shortBox)\n        box.delete(shortBox)\n        shortBox := na\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// LIQUIDITY SWEEPS, SWEEP LINES & TARGETS\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nvar bool  sweptLong   = false\nvar bool  sweptShort  = false\nvar float sweepLow    = na\nvar float sweepHigh   = na\nvar int   sweepLongBar  = na\nvar int   sweepShortBar = na\n\nvar float longTarget  = na\nvar float shortTarget = na\n\nvar line sslSweepLine = na\nvar line bslSweepLine = na\n\n// SSL sweep â†’ long bias\nlongSweep = not na(ssl) and low < ssl and close > ssl\n\nif longSweep\n    sweptLong    := true\n    sweepLongBar := bar_index\n    sweepLow     := low\n    longTarget   := na\n\n    if showSweepLines\n        if not na(sslSweepLine)\n            line.delete(sslSweepLine)\n        sslSweepLine := line.new(\n            x1 = bar_index,\n            y1 = sweepLow,\n            x2 = bar_index + 1,\n            y2 = sweepLow,\n            xloc = xloc.bar_index,\n            extend = extend.right,\n            color = color.new(color.teal, 0),\n            width = sweepLineWidth)\n\n// BSL sweep â†’ short bias\nshortSweep = not na(bsl) and high > bsl and close < bsl\n\nif shortSweep\n    sweptShort     := true\n    sweepShortBar  := bar_index\n    sweepHigh      := high\n    shortTarget    := na\n\n    if showSweepLines\n        if not na(bslSweepLine)\n            line.delete(bslSweepLine)\n        bslSweepLine := line.new(\n            x1 = bar_index,\n            y1 = sweepHigh,\n            x2 = bar_index + 1,\n            y2 = sweepHigh,\n            xloc = xloc.bar_index,\n            extend = extend.right,\n            color = color.new(color.orange, 0),\n            width = sweepLineWidth)\n\n// Targets from next swing high/low\nif sweptLong and not na(pivHigh) and bar_index > sweepLongBar\n    longTarget := pivHigh\n\nif sweptShort and not na(pivLow) and bar_index > sweepShortBar\n    shortTarget := pivLow\n\n// Timeout sweeps\nif sweptLong and bar_index - sweepLongBar > barsAfterSweepMax\n    sweptLong    := false\n    sweepLongBar := na\n    sweepLow     := na\n    longTarget   := na\n    if not na(sslSweepLine)\n        line.delete(sslSweepLine)\n        sslSweepLine := na\n\nif sweptShort and bar_index - sweepShortBar > barsAfterSweepMax\n    sweptShort     := false\n    sweepShortBar  := na\n    sweepHigh      := na\n    shortTarget    := na\n    if not na(bslSweepLine)\n        line.delete(bslSweepLine)\n        bslSweepLine := na\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// ENTRY CONDITIONS\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nbaseFilter = inSession and rangeOk\n\nlongRetest  = sweptLong  and ifvgLong  and not na(ifvgLT) and not na(ifvgLB) and high >= ifvgLB and low <= ifvgLT\nshortRetest = sweptShort and ifvgShort and not na(ifvgST) and not na(ifvgSB) and high >= ifvgSB and low <= ifvgST\n\n// Add PD filter to the stack\nlongSignal  = baseFilter and structureOkLong  and htfOkLong  and pdOkLong  and longRetest  and not na(longTarget)  and close > open\nshortSignal = baseFilter and structureOkShort and htfOkShort and pdOkShort and shortRetest and not na(shortTarget) and close < open\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// EXECUTION â€“ PARTIAL TARGETS + RUNNER\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nif longSignal and not na(sweepLow) and not na(longTarget)\n    longStop = sweepLow - syminfo.mintick\n\n    if usePartialTargets\n        longTp1 = close + (longTarget - close) * tp1FractionOfPath\n\n        strategy.entry(\"ILM Long\", strategy.long)\n        strategy.exit(\"ILM L TP1\", \"ILM Long\",\n            stop        = longStop,\n            limit       = longTp1,\n            qty_percent = tp1QtyPercent)\n        strategy.exit(\"ILM L TP2\", \"ILM Long\",\n            stop        = longStop,\n            limit       = longTarget,\n            qty_percent = 100)\n    else\n        strategy.entry(\"ILM Long\", strategy.long)\n        strategy.exit(\"ILM L TP/SL\", \"ILM Long\",\n            stop  = longStop,\n            limit = longTarget)\n\n    sweptLong    := false\n    sweepLongBar := na\n    longTarget   := na\n    sweepLow     := na\n    if not na(sslSweepLine)\n        line.delete(sslSweepLine)\n        sslSweepLine := na\n\nif shortSignal and not na(sweepHigh) and not na(shortTarget)\n    shortStop = sweepHigh + syminfo.mintick\n\n    if usePartialTargets\n        shortTp1 = close + (shortTarget - close) * tp1FractionOfPath\n\n        strategy.entry(\"ILM Short\", strategy.short)\n        strategy.exit(\"ILM S TP1\", \"ILM Short\",\n            stop        = shortStop,\n            limit       = shortTp1,\n            qty_percent = tp1QtyPercent)\n        strategy.exit(\"ILM S TP2\", \"ILM Short\",\n            stop        = shortStop,\n            limit       = shortTarget,\n            qty_percent = 100)\n    else\n        strategy.entry(\"ILM Short\", strategy.short)\n        strategy.exit(\"ILM S TP/SL\", \"ILM Short\",\n            stop  = shortStop,\n            limit = shortTarget)\n\n    sweptShort    := false\n    sweepShortBar := na\n    shortTarget   := na\n    sweepHigh     := na\n    if not na(bslSweepLine)\n        line.delete(bslSweepLine)\n        bslSweepLine := na\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// VISUALS\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nplotshape(showEntries and longSignal,\n     title     = \"ILM Long Entry\",\n     location  = location.belowbar,\n     style     = shape.triangleup,\n     color     = color.new(color.lime, 0),\n     text      = \"ILM L\",\n     size      = size.small,\n     textcolor = color.black)\n\nplotshape(showEntries and shortSignal,\n     title     = \"ILM Short Entry\",\n     location  = location.abovebar,\n     style     = shape.triangledown,\n     color     = color.new(color.red, 0),\n     text      = \"ILM S\",\n     size      = size.small,\n     textcolor = color.white)\n\nplot(showTargets and not na(longTarget)  ? longTarget  : na,\n     title = \"ILM Long Target\",\n     style = plot.style_linebr,\n     linewidth = 1,\n     color = color.new(color.green, 0))\n\nplot(showTargets and not na(shortTarget) ? shortTarget : na,\n     title = \"ILM Short Target\",\n     style = plot.style_linebr,\n     linewidth = 1,\n     color = color.new(color.maroon, 0))\n"
  },
  {
    "url": "s9UGbAOv-Crude-Oil-Time-Fix-Catalyst-Strategy",
    "name": "Crude Oil Time + Fix Catalyst Strategy",
    "description": "Hybrid Workflow: Event-Driven Macro + Market DNA Micro\n1. Macro Catalyst Layer (Your Overlays)\nEvent Mapping: Fed decisions, LBMA fixes, EIA releases, OPEC+ meetings.\n\nRegime Filters: Risk-on/off, volatility regimes, macro bias (hawkish/dovish).\n\nVolatility Scaling: ATR-based position sizing, adaptive overlays for London/NY sessions.\n\nGovernance: Max trades/day, cool-down logic, session boundaries.\n\nðŸ‘‰ This layer answers when and why to engage.\n\n2. Micro Execution Layer (Market DNA)\nOrder Flow Confirmation: Tape reading (Level II, time & sales, bid/ask).\n\nLiquidity Zones: Identify support/resistance pools where buyers/sellers cluster.\n\nImbalance Detection: Aggressive buyers/sellers overwhelming the other side.\n\nPrecision Entry: Only trigger trades when order flow confirms macro catalyst bias.\n\nRisk Discipline: Tight stops beyond liquidity zones, conviction-based scaling.\n\nðŸ‘‰ This layer answers how and where to engage.\n\n3. Unified Playbook\nStep\tMacro Overlay (Your Edge)\tMarket DNA (Jayâ€™s Edge)\tResult\nEvent Trigger\tFed/LBMA/OPEC+ catalyst flagged\tâ€”\tVolatility window opens\nBias Filter\tHawkish/dovish regime filter\tâ€”\tDirectional bias set\nSizing\tATR volatility scaling\tâ€”\tPosition size calibrated\nExecution\tâ€”\tTape confirms liquidity imbalance\tPrecision entry\nRisk Control\tGovernance rules (cool-down, max trades)\tTight stops beyond liquidity zones\tDisciplined exits\n4. Gold & Silver Use Case\nGold (Fed Day):\n\nOverlay flags volatility window â†’ bias hawkish.\n\nMarket DNA shows sellers hitting bids at resistance.\n\nEnter short with volatility-scaled size, stop just above liquidity zone.\n\nSilver (LBMA Fix):\n\nOverlay highlights fix window â†’ bias neutral.\n\nMarket DNA shows buyers stepping in at support.\n\nEnter long with adaptive size, HUD displays risk metrics.\n\n5. HUD Integration\nMacro Dashboard: Catalyst timeline, regime filter status, volatility bands.\n\nMicro Dashboard: Live tape imbalance meter, liquidity zone map, conviction score.\n\nUnified View: Macro tells you when to look, micro tells you when to pull the trigger.\n\nâš¡ This hybrid workflow gives you macro awareness + micro precision. Your overlays act as the radar, Jayâ€™s Market DNA acts as the laser scope. Together, they create a disciplined, event-aware, volatility-scaled playbook for gold and silver.\n\nAntonio â€” do you want me to draft this into a compile-safe Pine Script v6 template that embeds the macro overlay logic, while leaving hooks for Market DNA-style execution (order flow confirmation)? That way youâ€™d have a production-ready skeleton to extend across TradingView, TradeStation, and NinjaTrader.\n\nAntonio â€” do you want me to draft this into a compile-safe Pine Script v6 template that embeds the macro overlay logic, while leaving hooks for Market DNA-style execution (order flow confirmation)? That way youâ€™d have a production-ready skeleton to extend across TradingView, TradeStation, and NinjaTrader.",
    "image_url": "s9UGbAOv",
    "author": "bettencourt_antonio37",
    "likes": 4,
    "type": "strategy",
    "created": "2025-11-18",
    "updated": "2025-11-18",
    "source": "//@version=6\r\nstrategy(\"Crude Oil Time + Fix Catalyst Strategy\",\r\n     overlay = true,\r\n     margin_long = 100,\r\n     margin_short = 100,\r\n     fill_orders_on_standard_ohlc = true)\r\n\r\n// ================================\r\n//           INPUTS\r\n// ================================\r\nGoldFixThreshold   = input.float(10.0,  \"Gold Fix Threshold ($)\")\r\nSilverFixThreshold = input.float(0.25, \"Silver Fix Threshold ($)\")\r\nSurpriseThreshold  = input.float(0.30, \"Macro Surprise Threshold (%)\")\r\nUseCrossAssetConfirm = input.bool(false, \"Use Cross-Asset Confirmation\")\r\n\r\n// Fix timestamps (minutes from midnight)\r\nAMFixGold   = input.int(0,   \"AM Fix Gold (min after midnight)\", minval=0, maxval=1440)\r\nPMFixGold   = input.int(0,   \"PM Fix Gold (min after midnight)\", minval=0, maxval=1440)\r\nAMFixSilver = input.int(0,   \"AM Fix Silver (min after midnight)\", minval=0, maxval=1440)\r\nPMFixSilver = input.int(0,   \"PM Fix Silver (min after midnight)\", minval=0, maxval=1440)\r\n\r\n// Catalyst controls\r\nCatalystActive = input.bool(false, \"Catalyst Active?\")\r\nCatalystBias   = input.int(0, \"Catalyst Direction (-1=hawkish, +1=dovish)\", minval=-1, maxval=1)\r\nSurprise       = input.float(0.0, \"Macro Surprise (%)\")\r\n\r\n// Cross-asset inputs\r\nusdDown_in = input.bool(false, \"USD Down?\")\r\nyieldsUp_in = input.bool(false, \"Yields Up?\")\r\noilUp_in = input.bool(false, \"Oil Up?\")\r\n\r\n// Use persistent runtime vars\r\nvar bool usdDown = usdDown_in\r\nvar bool yieldsUp = yieldsUp_in\r\nvar bool oilUp = oilUp_in\r\n\r\nif barstate.isfirst\r\n    usdDown := usdDown_in\r\n    yieldsUp := yieldsUp_in\r\n    oilUp := oilUp_in\r\n\r\n\r\n// ================================\r\n//        TIME WINDOW FUNCTION\r\n// ================================\r\ninTime(startH, startM, endH, endM) =>\r\n    t = time(timeframe.period)\r\n    sessStart = timestamp(\"GMT-5\", year, month, dayofweek, startH, startM)\r\n    sessEnd   = timestamp(\"GMT-5\", year, month, dayofweek, endH, endM)\r\n    t >= sessStart and t < sessEnd\r\n\r\n\r\n\r\n// ================================\r\n//    FIX PRICE PLACEHOLDERS\r\n// Replace these with your GetGV() or CSV imports\r\n// ================================\r\ngoldAM   = AMFixGold\r\ngoldPM   = PMFixGold\r\nsilverAM = AMFixSilver\r\nsilverPM = PMFixSilver\r\n\r\n\r\n// ================================\r\n//       SIGNAL CONSTRUCTION\r\n// ================================\r\nvar int SignalGold = 0\r\nvar int SignalSilver = 0\r\n\r\nSignalGold := 0\r\nSignalSilver := 0\r\n\r\nif CatalystActive\r\n    // ---------------- G O L D -----------------\r\n    if CatalystBias == +1 and (goldPM > goldAM + GoldFixThreshold)\r\n        if not UseCrossAssetConfirm or usdDown or yieldsUp\r\n            SignalGold := +1\r\n\r\n    if CatalystBias == -1 and (goldPM < goldAM - GoldFixThreshold)\r\n        if not UseCrossAssetConfirm or not usdDown\r\n            SignalGold := -1\r\n\r\n    // ---------------- S I L V E R -----------------\r\n    if CatalystBias == +1 and (silverPM > silverAM + SilverFixThreshold)\r\n        if not UseCrossAssetConfirm or usdDown or oilUp\r\n            SignalSilver := +1\r\n\r\n    if CatalystBias == -1 and (silverPM < silverAM - SilverFixThreshold)\r\n        if not UseCrossAssetConfirm or not usdDown\r\n            SignalSilver := -1\r\n\r\n\r\n// ================================\r\n//        EXECUTION LOGIC\r\n// ================================\r\nif SignalGold == +1\r\n    strategy.entry(\"Gold Long\", strategy.long)\r\n\r\nif SignalGold == -1\r\n    strategy.entry(\"Gold Short\", strategy.short)\r\n\r\nif SignalSilver == +1\r\n    strategy.entry(\"Silver Long\", strategy.long)\r\n\r\nif SignalSilver == -1\r\n    strategy.entry(\"Silver Short\", strategy.short)\r\n\r\n\r\n// ================================\r\n//        TIME-BASED TRADES\r\n// ================================\r\n\r\n// --- LONG ENTRY WINDOW ---\r\nif inTime(12, 0, 13, 0)\r\n    strategy.entry(\"LE\", strategy.long)\r\n\r\n// --- LONG EXIT WINDOW ---\r\nif inTime(16, 45, 17, 0)\r\n    strategy.close(\"LE\")\r\n\r\n// --- SHORT ENTRY WINDOW ---\r\nif inTime(19, 0, 20, 0)\r\n    strategy.entry(\"SE\", strategy.short)\r\n\r\n// --- SHORT EXIT WINDOW ---\r\nif inTime(12, 0, 13, 0)\r\n    strategy.close(\"SE\")\r\n\r\n\r\n// ================================\r\n//  SIMPLE MA CROSS EXAMPLE (kept from your original)\r\n// ================================\r\nlongCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))\r\nif longCondition\r\n    strategy.entry(\"MA Long\", strategy.long)\r\n\r\nshortCondition = ta.crossunder(ta.sma(close, 14), ta.sma(close, 28))\r\nif shortCondition\r\n    strategy.entry(\"MA Short\", strategy.short)\r\n"
  },
  {
    "url": "AWa1tWoJ-Liquidity-Sweep-BOS-Retest-System-Prop-Firm-Edition",
    "name": "Liquidity Sweep + BOS Retest System â€” Prop Firm Edition",
    "description": "ðŸŸ¦ Liquidity Sweep + BOS Retest System â€” Prop Firm Edition\nA High-Probability Smart Money Strategy Built for NQ, ES, and Funding Accounts\n\nðŸš€ Overview\nThe Liquidity Sweep + BOS Retest System (Prop Firm Edition) is a precision-engineered SMC strategy built specifically for prop firm traders. It mirrors institutional liquidity behavior and combines it with strict account-safe entry rules to help traders pass and maintain funding accounts with consistency.\nUnlike typical indicators, this system waits for three confirmations â€” liquidity sweep, displacement, and a clean retest â€” before executing any trade. Every component is optimized for low drawdown, high R:R, and prop-firm-approved risk management.\nWhether youâ€™re trading Apex, TakeProfitTrader, FFF, or OneUp Trader, this system gives you a powerful mechanical framework that keeps you within rules while identifying the marketâ€™s highest-probability reversal zones.\n\nðŸ”¥ Key Features\n1. Liquidity Sweep Detection (Stop Hunt Logic)\nAutomatically identifies when price clears a previous swing high/low with a sweep confirmation candle.\nâœ” Filters noise\nâœ” Eliminates early entries\nâœ” Locks onto true liquidity grabs\n\n2. Automatic Break of Structure (BOS) Confirmation\nPrice must show true displacement by breaking structure opposite the sweep direction.\nâœ” Confirms momentum shift\nâœ” Removes fake reversals\nâœ” Ensures institutional intent\n\n3. Precision Retest Entry Model\nThe strategy enters only when price retests the BOS level at premium/discount pricing.\nâœ” Zero chasing\nâœ” Extremely tight stop loss placement\nâœ” Prop-firm-friendly controlled risk\n\n4. Built-In Risk & Trade Management\n\n\nSL set at swept liquidity\n\n\nTP set by user-defined R:R multiplier\n\n\nOptional session filter (NY Open by default)\n\n\nOne trade at a time (no pyramiding)\n\n\nAutomatically resets logic after each trade\n\n\nThis prevents overtrading â€” the #1 cause of evaluation and account breaches.\n\n5. Designed for Prop Firm Futures Trading\nThis script is optimized for:\n\n\nTrailing/static drawdown accounts\n\n\nMicro contract precision\n\n\nFunding evaluations\n\n\nLow-risk, high-probability setups\n\n\nStructured, rule-based execution\n\n\nIt reduces randomness and emotional trading by automating the highest-quality SMC sequence.\n\nðŸŽ¯ The Trading Model Behind the System\nStep 1 â€” Liquidity Sweep\nPrice must take out a recent high/low and close back inside structure.\nThis confirms stop-hunting behavior and marks the beginning of a potential reversal.\nStep 2 â€” BOS (Break of Structure)\nPrice must break the opposite side swing with a displacement candle. This validates a directional shift.\nStep 3 â€” Retest Entry\nThe system waits for price to retrace into the BOS level and signal continuation.\nThis creates optimal R:R entry with minimal drawdown.\n\nðŸ“ˆ Best Markets\n\n\nNQ (NASDAQ Futures) â€“ Highly recommended\n\n\nES, YM, RTY\n\n\nGold (XAUUSD)\n\n\nFX majors\n\n\nCrypto (with high volatility)\n\n\nWorks best on 1m, 2m, 5m, or 15m depending on your trading style.\n\nðŸ§  Why Traders Love This System\nâœ” No signals until all confirmations align\nâœ” Reduces overtrading and emotional decisions\nâœ” Follows market structure instead of random indicators\nâœ” Perfect for maintaining long-term funded accounts\nâœ” Built around institutional-grade concepts\nâœ” Makes your trading consistent, calm, and rules-based\n\nâš™ï¸ Recommended Settings\n\n\nSession: 06:30â€“08:00 MST (NY Open)\n\n\nR:R: 1.5R â€“ 3R\n\n\nContracts: Start with 1â€“2 micros\n\n\nMarkets: NQ for best structure & volume\n\n\n\nðŸ“¦ Whatâ€™s Included\n\n\nComplete strategy logic\n\n\nAll plots, labels, sweep markers & BOS alerts\n\n\nBOS retest entry automation\n\n\nSession filtering\n\n\nStop loss & take profit system\n\n\nFull SMC logic pipeline\n\n\n\nðŸ Summary\nThe Liquidity Sweep + BOS Retest System is a complete, prop-firm-ready, structure-based strategy that automates one of the cleanest and most reliable SMC entry models. It is designed to keep you safe, consistent, and rule-compliant while capturing premium institutional setups.\nIf you want to trade with confidence, discipline, and prop-firm precision â€” this system is for you. \n\nGood Luck -BG",
    "image_url": "AWa1tWoJ",
    "author": "christopher33g",
    "likes": 27,
    "type": "strategy",
    "created": "2025-11-18",
    "updated": "2025-11-18",
    "source": "//@version=5\r\nstrategy(\"Prop Firm Liquidity Sweep + BOS Retest Model\",\r\n     overlay          = true,\r\n     initial_capital  = 100000,\r\n     commission_type  = strategy.commission.cash_per_contract,\r\n     commission_value = 2.0,\r\n     pyramiding       = 0,\r\n     margin_long      = 100,\r\n     margin_short     = 100,\r\n     process_orders_on_close = true)\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// INPUTS\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nleftBars  = input.int(2, \"Pivot Left Bars\",  minval = 1)\r\nrightBars = input.int(2, \"Pivot Right Bars\", minval = 1)\r\n\r\nsessionIn = input.session(\"0630-0800\", \"Trading Session (exchange time)\")\r\nuseSessionFilter = input.bool(true, \"Use Session Filter\")\r\n\r\nrr         = input.float(2.0, \"Reward : Risk (R)\", minval = 0.5, step = 0.25)\r\ncontracts  = input.float(1.0, \"Contracts\", minval = 0.1, step = 0.1)\r\n\r\nplotSweeps = input.bool(true, \"Show Liquidity Sweeps\")\r\nplotBOS    = input.bool(true, \"Show BOS Labels\")\r\nplotLevels = input.bool(true, \"Show Structure Levels\")\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// SESSION FILTER\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\ninSession = not na(time(timeframe.period, sessionIn))\r\ntradeAllowed = useSessionFilter ? inSession : true\r\n\r\nbgcolor(useSessionFilter and inSession ? color.new(color.teal, 92) : na)\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// PIVOTS (STRUCTURE LEVELS)\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\npivotHigh = ta.pivothigh(high, leftBars, rightBars)  // value on pivot bar\r\npivotLow  = ta.pivotlow(low,  leftBars, rightBars)\r\n\r\nvar float lastSwingHigh = na\r\nvar float lastSwingLow  = na\r\n\r\nif not na(pivotHigh)\r\n    lastSwingHigh := pivotHigh\r\n\r\nif not na(pivotLow)\r\n    lastSwingLow := pivotLow\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// LIQUIDITY SWEEPS\r\n//  - Long side sweep: price breaks below last swing low and closes back above it\r\n//  - Short side sweep: price breaks above last swing high and closes back below it\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nliqSweepLong  = not na(lastSwingLow)  and low  < lastSwingLow and close > lastSwingLow\r\nliqSweepShort = not na(lastSwingHigh) and high > lastSwingHigh and close < lastSwingHigh\r\n\r\nvar bool  haveLiqSweepLong  = false\r\nvar bool  haveLiqSweepShort = false\r\nvar float sweptLow          = na\r\nvar float sweptHigh         = na\r\n\r\nif liqSweepLong\r\n    haveLiqSweepLong := true\r\n    sweptLow         := low\r\n\r\nif liqSweepShort\r\n    haveLiqSweepShort := true\r\n    sweptHigh         := high\r\n\r\n// Plot sweeps\r\nif plotSweeps and liqSweepLong\r\n    label.new(bar_index, low, \"Sweep â¬‡ï¸\", style = label.style_label_down,\r\n              textcolor = color.white, color = color.new(color.green, 0), size = size.tiny)\r\n\r\nif plotSweeps and liqSweepShort\r\n    label.new(bar_index, high, \"Sweep â¬†ï¸\", style = label.style_label_up,\r\n              textcolor = color.white, color = color.new(color.red, 0), size = size.tiny)\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// BREAK OF STRUCTURE (BOS)\r\n//  - Long BOS: after a downside sweep, close > last swing high\r\n//  - Short BOS: after an upside sweep, close < last swing low\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nbosLong  = haveLiqSweepLong  and not na(lastSwingHigh) and close > lastSwingHigh\r\nbosShort = haveLiqSweepShort and not na(lastSwingLow)  and close < lastSwingLow\r\n\r\nvar bool  bosLongActive   = false\r\nvar bool  bosShortActive  = false\r\nvar float bosLongLevel    = na\r\nvar float bosShortLevel   = na\r\n\r\nif bosLong\r\n    bosLongActive := true\r\n    bosLongLevel  := lastSwingHigh\r\n    if plotBOS\r\n        label.new(bar_index, close, \"BOS Long\",\r\n                  style = label.style_label_up,\r\n                  textcolor = color.white,\r\n                  color = color.new(color.green, 0),\r\n                  size = size.tiny)\r\n\r\nif bosShort\r\n    bosShortActive := true\r\n    bosShortLevel  := lastSwingLow\r\n    if plotBOS\r\n        label.new(bar_index, close, \"BOS Short\",\r\n                  style = label.style_label_down,\r\n                  textcolor = color.white,\r\n                  color = color.new(color.red, 0),\r\n                  size = size.tiny)\r\n\r\n// Visual structure levels\r\nplot(plotLevels and not na(bosLongLevel)  ? bosLongLevel  : na, \"BOS Long Level\",  color.new(color.green, 60), style = plot.style_linebr)\r\nplot(plotLevels and not na(bosShortLevel) ? bosShortLevel : na, \"BOS Short Level\", color.new(color.red,   60), style = plot.style_linebr)\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// ENTRY LOGIC: RETEST OF BROKEN STRUCTURE\r\n//  - Long: after BOS long, wait for retest into/through BOS level & bounce\r\n//  - Short: after BOS short, wait for retest into/through BOS level & rejection\r\n//  - SL at swept liquidity, TP by R:R\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nflat = strategy.position_size == 0\r\n\r\n// LONG RETEST:\r\n// Price trades back to/through bosLongLevel, then closes back above it\r\nlongRetest = bosLongActive and haveLiqSweepLong and not na(bosLongLevel) and flat and tradeAllowed and low <= bosLongLevel and close > bosLongLevel\r\n\r\nif longRetest and not na(sweptLow)\r\n    longEntryPrice = close\r\n    longStopPrice  = sweptLow - syminfo.mintick * 2.0\r\n    riskPerUnit    = longEntryPrice - longStopPrice\r\n    \r\n    // Guard: only valid if risk distance > 0\r\n    if riskPerUnit > 0\r\n        longTPPrice = longEntryPrice + riskPerUnit * rr\r\n\r\n        strategy.entry(\"Long\", strategy.long, qty = contracts)\r\n\r\n        strategy.exit(\"Long TP/SL\", \"Long\",\r\n                      stop  = longStopPrice,\r\n                      limit = longTPPrice)\r\n\r\n        // Reset state after creating a valid trade\r\n        bosLongActive    := false\r\n        haveLiqSweepLong := false\r\n\r\n// SHORT RETEST:\r\n// Price trades back to/through bosShortLevel, then closes back below it\r\nshortRetest = bosShortActive and haveLiqSweepShort and not na(bosShortLevel) and flat and tradeAllowed and high >= bosShortLevel and close < bosShortLevel\r\n\r\nif shortRetest and not na(sweptHigh)\r\n    shortEntryPrice = close\r\n    shortStopPrice  = sweptHigh + syminfo.mintick * 2.0\r\n    riskPerUnit     = shortStopPrice - shortEntryPrice\r\n    \r\n    if riskPerUnit > 0\r\n        shortTPPrice = shortEntryPrice - riskPerUnit * rr\r\n\r\n        strategy.entry(\"Short\", strategy.short, qty = contracts)\r\n\r\n        strategy.exit(\"Short TP/SL\", \"Short\",\r\n                      stop  = shortStopPrice,\r\n                      limit = shortTPPrice)\r\n\r\n        bosShortActive     := false\r\n        haveLiqSweepShort  := false\r\n\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\n// SAFETY: RESET STATES IF POSITION IS OPEN (DON'T STACK LOGIC)\r\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nif not flat\r\n    bosLongActive    := false\r\n    bosShortActive   := false\r\n    haveLiqSweepLong := haveLiqSweepLong  and strategy.position_size > 0 ? haveLiqSweepLong  : haveLiqSweepLong\r\n    haveLiqSweepShort:= haveLiqSweepShort and strategy.position_size > 0 ? haveLiqSweepShort : haveLiqSweepShort\r\n"
  },
  {
    "url": "uzIbAimb-Rasta-Long-Short-Strategy",
    "name": "Rasta Long/Short â€” Strategy",
    "description": "The Rasta Long/Short Strategy is a visual and educational framework designed to help traders study momentum shifts that appear when a fast EMA interacts with a slower smoothed baseline.\nIt is not a signal service. Instead, it is a research tool that helps you observe transitions, structure, and behavior across different market conditions and smoothing contexts.\n\nThe script plots:\n\nA primary EMA line (fast reaction wave).\n\nA Smoothed line (your chosen smoothing method).\n\nColor-coded fog regions showing directional bias.\n\nOptional DNA rung connections between the two lines for structural comparison.\n\nTogether, these allow a deeper study of how momentum pushes, volatility compression, expansions, and drift emerge around fast/slow EMA interactions.\n\nâœ¦ Core Idea\n\nThe Rasta Long/Short mechanism studies how price behaves when the fast EMA crosses above or below a smoothed anchor.\nRather than predicting price, it reveals where transitions occur across different structures, timeframes, and smoothing techniques.\n\nThe Long/Short logic simply highlights flips in directional structure.\nIt is not intended for real-time signals or automated execution; it is intended for understanding market movement.\n\nâœ¦ Smoothing Types (Explained)\n\nThe strategy allows experimenting with several smoothing families to observe how they transform the fast EMA:\n\nSMA (Simple Moving Average)\n\nAveraged, slower response. Good for stability comparisons.\n\nEMA (Exponential)\n\nFaster reaction, more responsive, smoother behavior during momentum.\n\nRMA (Wilderâ€™s)\n\nUsed in RSI calculations; steady, well-balanced response.\n\nWMA (Weighted)\n\nMore weight to recent bars; bridges SMA and EMA dynamics.\n\nNone\n\nRaw EMA vs EMA interaction with no secondary smoothing.\n\nEach smoothing type provides unique structural information and can lead to different interpretations.\n\nâœ¦ Modes of Study\n\nDesigned for multi-timeframe research:\n\n1H / 4H â€” Momentum flow mapping and structural identification.\n\nDaily / Weekly â€” Higher-timeframe rotations, macro structure transitions.\n\n1â€“15m â€” Microstructure studies, noise vs trend emergence.\n\nUse the built-in Strategy Tester to explore entry/exit context, but treat results as research, not predictive performance.\n\nâœ¦ Components (Visual Study Tools)\nEMA Line (Fast)\n\nPrimary reactive wave. Shows fast directional shifts.\n\nSmoothed Line (Slow)\n\nTrend baseline / reference structure.\n\nFog Region\n\nHighlights fast-vs-smoothed directional alignment.\n\nDNA Rungs (Optional)\n\nStructural â€œbridgesâ€ showing the exact relationship between waves on each bar.\nUseful for studying separation, compression, and expansions.\n\nâœ¦ Educational Insights\n\nThis strategy helps illuminate:\n\nHow fast and slow EMAs interact dynamically.\n\nHow structure changes precede trend emergence.\n\nWhere volatility compresses before expansion.\n\nHow noise, drift, and clean reversals differ.\n\nHow different smoothers alter the interpretation of the same price data.\n\nThe goal is clarity â€” not prediction.\n\nâœ¦ How to Use\n\nApply to any timeframe or instrument.\n\nEnable or disable fog depending on preferred visibility.\n\nUse DNA rungs for close structural comparison.\n\nObserve long/short flips as educational reference points â€” not signals.\n\nStudy transitions visually, then backtest using the Strategy Tester for pattern research.\n\nâœ¦ Disclaimer\n\nThis script is provided for educational and research purposes only.\nIt does not provide trading signals, financial advice, or recommendations.\nPast behavior does not indicate future performance.\nAlways practice risk-aware study and consult qualified financial professionals when needed.\n\nâœ¦ Author\n\nMichael Culpepper (mikeyc747)\nCreator of the Rasta framework and related market structure studies.",
    "image_url": "uzIbAimb",
    "author": "mikeyc747",
    "likes": 278,
    "type": "strategy",
    "created": "2025-11-28",
    "updated": "2025-11-28",
    "source": "//@version=5\r\nstrategy(\"Rasta Long/Short â€” Strategy\",\r\n     overlay=true, max_lines_count=500,\r\n\r\n     // --- Defaults to match your screenshots\r\n     initial_capital     = 100,\r\n     currency            = currency.USD,\r\n     default_qty_type    = strategy.cash,     // order size in USD\r\n     default_qty_value   = 100,\r\n     pyramiding          = 0,\r\n     commission_type     = strategy.commission.percent,\r\n     commission_value    = 0.25,\r\n     slippage            = 0,\r\n     calc_on_every_tick  = true,\r\n     calc_on_order_fills = true)\r\n\r\n/// ========= Inputs (same as indicator)\r\ngroupInp   = \"Inputs\"\r\nemaLen     = input.int(5, \"Length\", minval=1, group=groupInp)\r\nsrc        = input.source(close, \"Source\", group=groupInp)\r\noffsetBars = input.int(0, \"Offset\", group=groupInp)\r\n\r\ngroupSm    = \"Smoothing\"\r\nsmType     = input.string(\"SMA\", \"Type\",\r\n              options=[\"SMA\",\"EMA\",\"RMA\",\"WMA\",\"None\"], group=groupSm)\r\nsmLen      = input.int(5, \"Length\", minval=1, group=groupSm)\r\n\r\ngroupViz   = \"Visualization\"\r\nshowLabels = input.bool(true, \"Show Long/Short Labels\", group=groupViz)\r\nshowFog    = input.bool(true, \"Show Colored Fog Between Lines\", group=groupViz)\r\nfogTransp  = input.int(55, \"Fog Opacity (0=solid, 100=hidden)\", minval=0, maxval=100, group=groupViz)\r\n\r\ngroupRung  = \"DNA Rungs\"\r\nshowRungs  = input.bool(true, \"Show DNA Rungs (EMA â†” Smoothed)\", group=groupRung)\r\nrungWidth  = input.int(3, \"Rung Width\", minval=1, maxval=5, group=groupRung)\r\nmaxKeep    = input.int(420, \"Max Rungs to Keep (<= 450)\", minval=100, maxval=450, step=10, group=groupRung)\r\nrungColorMode = input.string(\"Direction\", \"Rung Color\",\r\n     options=[\"Fixed Green\",\"Direction\"], group=groupRung)\r\nrungFixedCol  = input.color(color.lime, \"Fixed Rung Color\", group=groupRung)\r\n\r\n/// ========== EMA 8/21 Filter (same as Rasta, LONGS ONLY)\r\ngroupFilt        = \"EMA 8/21 Filter\"\r\nuseEmaFilter     = input.bool(true,  \"Enable EMA 8/21 Filter (Longs Only)\", group=groupFilt)\r\nemaFastLenSw     = input.int(8,      \"Fast EMA\",  minval=1, group=groupFilt)\r\nemaSlowLenSw     = input.int(21,     \"Slow EMA\",  minval=1, group=groupFilt)\r\nplotFilterEMAs   = input.bool(false, \"Plot Filter EMAs\", group=groupFilt)\r\nadaptiveOnFlip   = input.bool(true,  \"Adaptive long entry when filter flips ON\", group=groupFilt)\r\n\r\nema8        = ta.ema(close, emaFastLenSw)\r\nema21       = ta.ema(close, emaSlowLenSw)\r\nupTrend     = ema8 > ema21\r\nfilterFlipOn= ta.crossover(ema8, ema21)\r\n\r\n/// ========== Independent Fixed Stop-Losses\r\ngroupRisk   = \"Risk\"\r\nslLongPct   = input.float(13.0, \"Long Stop Loss (%)\",  minval=0.1, step=0.1, group=groupRisk) / 100.0\r\nslShortPct  = input.float(13.0, \"Short Stop Loss (%)\", minval=0.1, step=0.1, group=groupRisk) / 100.0\r\n\r\n/// ========== Core calc\r\nemaLine = ta.ema(src, emaLen)\r\n\r\nf_smooth(series float s, string t, int l) =>\r\n    float out = switch t\r\n        \"SMA\"  => ta.sma(s, l)\r\n        \"EMA\"  => ta.ema(s, l)\r\n        \"RMA\"  => ta.rma(s, l)\r\n        \"WMA\"  => ta.wma(s, l)\r\n        => s\r\n    out\r\n\r\nsmoothed = f_smooth(emaLine, smType, smLen)\r\ndirUp   = emaLine > smoothed\r\n\r\n/// ========== Tick-by-tick signals with per-bar lock\r\nvar bool barLock = false\r\nif barstate.isnew\r\n    barLock := false\r\n\r\nbuyRaw  = ta.crossover(emaLine, smoothed)\r\nsellRaw = ta.crossunder(emaLine, smoothed)\r\n\r\n// BASE fires (like your original)\r\nbuyFireBase  = buyRaw  and not barLock\r\nsellFireBase = sellRaw and not barLock\r\n\r\n// EMA 8/21 gating â€” LONGS ONLY (same logic as Rasta)\r\nbuyAllowed  = (not useEmaFilter) or upTrend\r\nsellAllowed = true\r\n\r\nadaptiveBuy = useEmaFilter and adaptiveOnFlip and filterFlipOn and not barLock and (emaLine > smoothed)\r\n\r\n// Final realtime fires (Rasta-style gate on buys only)\r\nbuyFire  = ((buyFireBase and buyAllowed) or adaptiveBuy)\r\nsellFire =  (sellFireBase and sellAllowed)\r\n\r\n// Close-only backup â€” buy gated, sell NOT gated\r\nbuyFireClose  = barstate.isconfirmed and ta.crossover(emaLine, smoothed) and buyAllowed\r\nsellFireClose = barstate.isconfirmed and ta.crossunder(emaLine, smoothed)\r\n\r\nbuySig  = buyFire  or buyFireClose\r\nsellSig = sellFire or sellFireClose\r\n\r\nif buyFire or sellFire\r\n    barLock := true\r\n\r\n// ========= Flip events: one clean LONG â†’ SHORT â†’ LONG sequence\r\nlongFlip  = buySig  and strategy.position_size <= 0   // flat or short â†’ go long\r\nshortFlip = sellSig and strategy.position_size >= 0   // flat or long  â†’ go short\r\n\r\n/// ========== Strategy orders â€” FLIP LOGIC (1 long, 1 short alternating)\r\nif longFlip\r\n    if strategy.position_size < 0\r\n        strategy.close(\"SHORT\")\r\n    strategy.entry(\"LONG\", strategy.long)\r\n\r\nif shortFlip\r\n    if strategy.position_size > 0\r\n        strategy.close(\"LONG\")\r\n    strategy.entry(\"SHORT\", strategy.short)\r\n\r\n/// ========== Fixed stop-loss (independent long/short)\r\nif strategy.position_size > 0\r\n    slLong = strategy.position_avg_price * (1.0 - slLongPct)\r\n    strategy.exit(\"SL_LONG\", from_entry=\"LONG\", stop=slLong)\r\n\r\nif strategy.position_size < 0\r\n    slShort = strategy.position_avg_price * (1.0 + slShortPct)\r\n    strategy.exit(\"SL_SHORT\", from_entry=\"SHORT\", stop=slShort)\r\n\r\n/// ========== Plots & labels\r\npEMA = plot(emaLine, \"EMA\", color=color.new(color.red, 0), offset=offsetBars, linewidth=2)\r\npSM  = plot(smoothed, \"Smoothed\", color=color.new(color.yellow, 0), offset=offsetBars, linewidth=2)\r\n\r\n// Plot Rasta filter EMAs if desired\r\nplot(plotFilterEMAs ? ema8  : na, \"EMA 8 (Filter)\",  color=color.new(color.teal,  0), linewidth=1)\r\nplot(plotFilterEMAs ? ema21 : na, \"EMA 21 (Filter)\", color=color.new(color.orange,0), linewidth=1)\r\n\r\n// Use flip events for labels so they match actual trade flips\r\nif showLabels and longFlip\r\n    label.new(bar_index, low, \"LONG\",  style=label.style_label_up,   textcolor=color.white, color=color.new(color.teal, 0))\r\nif showLabels and shortFlip\r\n    label.new(bar_index, high, \"SHORT\", style=label.style_label_down, textcolor=color.white, color=color.new(color.red, 0))\r\n\r\n// Fog\r\ncolFog = showFog ? (dirUp ? color.new(color.lime, fogTransp) : color.new(color.red, fogTransp)) : na\r\nfill(pEMA, pSM, color=colFog)\r\n\r\n// DNA rungs\r\ntopR = math.max(emaLine, smoothed)\r\nbotR = math.min(emaLine, smoothed)\r\nrungCol = rungColorMode == \"Direction\" ? (dirUp ? color.lime : color.red) : rungFixedCol\r\nvar line curRung = na\r\nvar line[] rungBuf = array.new_line()\r\nif showRungs\r\n    if barstate.isnew\r\n        curRung := line.new(bar_index, botR, bar_index, topR,\r\n                             xloc=xloc.bar_index, extend=extend.none,\r\n                             color=rungCol, width=rungWidth)\r\n        array.push(rungBuf, curRung)\r\n        if array.size(rungBuf) > maxKeep\r\n            line.delete(array.shift(rungBuf))\r\n    if not na(curRung)\r\n        line.set_y1(curRung, botR)\r\n        line.set_y2(curRung, topR)\r\n        line.set_width(curRung, rungWidth)\r\n        line.set_color(curRung, rungCol)\r\n"
  },
  {
    "url": "UmbC5swm-Faraz-Perfect-Structure-XL-XS-Trend-Filtered",
    "name": "Faraz Perfect Structure XL / XS (Trend-Filtered)",
    "description": "Farazâ€™s Perfect Structure XL/XS identifies premium trend continuation and reversal setups using a three-filter system:\n\nstructural breakouts using dynamic swing-based support/resistance,\n\ntrend confirmation via 200-EMA slope,\n\nmomentum validation through RSI and MACD.\n\nSignals only trigger when all factors align, eliminating noise, chop, and false signals. \n\nDesigned for traders who want clean, high-probability long (XL) and short (XS) entries.",
    "image_url": "UmbC5swm",
    "author": "fsaleem03",
    "likes": 15,
    "type": "strategy",
    "created": "2025-11-18",
    "updated": "2025-11-18",
    "source": "//@version=6\r\nstrategy(\r\n     \"Faraz Perfect Structure XL / XS (Trend-Filtered)\",\r\n     overlay = true,\r\n     max_labels_count = 500,\r\n     initial_capital = 50000,\r\n     default_qty_type = strategy.percent_of_equity,\r\n     default_qty_value = 10,\r\n     pyramiding = 0,\r\n     process_orders_on_close = true)\r\n\r\n// =====================\r\n// INPUTS\r\n// =====================\r\npivotLen         = input.int(5,  \"Swing Pivot Length (both sides)\", minval = 2)\r\nlookbackBreakout = input.int(10, \"Breakout / Breakdown Lookback\",   minval = 3)\r\n\r\nrsiLen           = input.int(14, \"RSI Length\")\r\nrsiLongTrig      = input.float(40.0, \"Base RSI Long Trigger\",  minval = 5,  maxval = 95)\r\nrsiShortTrig     = input.float(60.0, \"Base RSI Short Trigger\", minval = 5,  maxval = 95)\r\n\r\nrsiPerfectLong   = input.float(50.0, \"Perfect Long RSI Min\",   minval = 5,  maxval = 95)\r\nrsiPerfectShort  = input.float(50.0, \"Perfect Short RSI Max\",  minval = 5,  maxval = 95)\r\n\r\nuseMACD          = input.bool(true, \"Use MACD filter?\")\r\nriskBufferPts    = input.float(5.0, \"Stop buffer (points)\")\r\n\r\n// Trend filter settings (200 EMA)\r\nemaLenTrend      = input.int(200, \"Trend EMA length\", minval = 20)\r\ntrendLookback    = input.int(10,  \"Trend slope lookback bars\", minval = 1)\r\nminSlopePts      = input.float(5.0, \"Min EMA slope (points)\",  minval = 0.0)\r\n\r\n// =====================\r\n// STRUCTURE LEVELS\r\n// =====================\r\n\r\n// Structure low for longs\r\npivotLow      = ta.pivotlow(low, pivotLen, pivotLen)\r\npivotLowPrice = ta.valuewhen(not na(pivotLow), low[pivotLen], 0)\r\nlowest50      = ta.lowest(low, 50)\r\nstructLow     = na(pivotLowPrice) ? lowest50 : pivotLowPrice\r\nlongStopLevel = structLow - riskBufferPts\r\n\r\n// Structure high for shorts\r\npivotHigh      = ta.pivothigh(high, pivotLen, pivotLen)\r\npivotHighPrice = ta.valuewhen(not na(pivotHigh), high[pivotLen], 0)\r\nhighest50      = ta.highest(high, 50)\r\nstructHigh     = na(pivotHighPrice) ? highest50 : pivotHighPrice\r\nshortStopLevel = structHigh + riskBufferPts\r\n\r\n// Breakout / breakdown levels (exclude current bar)\r\nbreakoutLvl  = ta.highest(high, lookbackBreakout)[1]   // long breakout\r\nbreakdownLvl = ta.lowest(low,  lookbackBreakout)[1]    // short breakdown\r\n\r\n// =====================\r\n// MOMENTUM FILTERS\r\n// =====================\r\nrsi = ta.rsi(close, rsiLen)\r\n\r\n[macdLine, macdSignal, macdHist] = ta.macd(close, 12, 26, 9)\r\nmacdUp   = macdHist > macdHist[1]\r\nmacdDown = macdHist < macdHist[1]\r\n\r\n// Simple RSI slope\r\nrsiUp   = rsi > rsi[1]\r\nrsiDown = rsi < rsi[1]\r\n\r\n// =====================\r\n// TREND FILTER (200 EMA)\r\n// =====================\r\nemaTrend   = ta.ema(close, emaLenTrend)\r\nemaTrendPB = nz(emaTrend[trendLookback], emaTrend)\r\nemaSlope   = emaTrend - emaTrendPB\r\n\r\nupTrend    = emaTrend > emaTrendPB and emaSlope >  minSlopePts\r\ndownTrend  = emaTrend < emaTrendPB and emaSlope < -minSlopePts\r\n\r\n// =====================\r\n// BASE SIGNALS\r\n// =====================\r\nbaseLong =\r\n     close > breakoutLvl and\r\n     close > structLow  and\r\n     rsi   > rsiLongTrig and\r\n     (not useMACD or macdUp)\r\n\r\nbaseShort =\r\n     close < breakdownLvl and\r\n     close < structHigh   and\r\n     rsi   < rsiShortTrig and\r\n     (not useMACD or macdDown)\r\n\r\n// Price relative to structure channel\r\ntrendLongOnly =\r\n     close > structHigh and\r\n     close > breakoutLvl\r\n\r\ntrendShortOnly =\r\n     close < structLow and\r\n     close < breakdownLvl\r\n\r\n// =====================\r\n// \"PERFECT\" XL / XS SETUPS\r\n// =====================\r\n\r\n// Long: breakout + structure + RSI/MACD + above EMA + EMA sloping up\r\nperfectLong =\r\n     baseLong and\r\n     trendLongOnly and\r\n     rsi >= rsiPerfectLong and\r\n     rsiUp and\r\n     upTrend and\r\n     close > emaTrend\r\n\r\n// Short: breakdown + structure + RSI/MACD + below EMA + EMA sloping down\r\nperfectShort =\r\n     baseShort and\r\n     trendShortOnly and\r\n     rsi <= rsiPerfectShort and\r\n     rsiDown and\r\n     downTrend and\r\n     close < emaTrend\r\n\r\n// =====================\r\n// VISUALS\r\n// =====================\r\n\r\n// No-add zone (between structure and breakout / breakdown)\r\nlongNoAddZone  = close > structLow  and close < breakoutLvl\r\nshortNoAddZone = close < structHigh and close > breakdownLvl\r\ninNoAddZone    = longNoAddZone or shortNoAddZone\r\n\r\nbgcolor(inNoAddZone ? color.new(color.orange, 88) : na)\r\n\r\n// Bar colors â€“ only highlight perfect bars\r\nbarcolor(\r\n     perfectLong  ? color.new(color.green, 0) :\r\n     perfectShort ? color.new(color.red,   0) :\r\n     na)\r\n\r\n// Tiny base signals (L / S) â€“ optional\r\nplotshape(baseLong,\r\n     title     = \"Base Long\",\r\n     style     = shape.triangleup,\r\n     text      = \"L\",\r\n     color     = color.new(color.lime, 0),\r\n     textcolor = color.black,\r\n     location  = location.belowbar,\r\n     size      = size.tiny)\r\n\r\nplotshape(baseShort,\r\n     title     = \"Base Short\",\r\n     style     = shape.triangledown,\r\n     text      = \"S\",\r\n     color     = color.new(color.red, 0),\r\n     textcolor = color.white,\r\n     location  = location.abovebar,\r\n     size      = size.tiny)\r\n\r\n// XL / XS \"perfect\" labels\r\nplotshape(perfectLong,\r\n     title     = \"Faraz Perfect Long (XL)\",\r\n     style     = shape.labelup,\r\n     text      = \"XL\",\r\n     color     = color.new(color.green, 0),\r\n     textcolor = color.black,\r\n     location  = location.belowbar,\r\n     size      = size.small)\r\n\r\nplotshape(perfectShort,\r\n     title     = \"Faraz Perfect Short (XS)\",\r\n     style     = shape.labeldown,\r\n     text      = \"XS\",\r\n     color     = color.new(color.red, 0),\r\n     textcolor = color.white,\r\n     location  = location.abovebar,\r\n     size      = size.small)\r\n\r\n// Structure plots\r\nplot(structLow,\r\n     title     = \"Structure Low (Red)\",\r\n     color     = color.new(color.red, 0),\r\n     style     = plot.style_linebr,\r\n     linewidth = 2)\r\n\r\nplot(longStopLevel,\r\n     title     = \"Long Stop Level\",\r\n     color     = color.new(color.red, 60),\r\n     style     = plot.style_linebr,\r\n     linewidth = 1)\r\n\r\nplot(breakoutLvl,\r\n     title     = \"Long Breakout (Green)\",\r\n     color     = color.new(color.lime, 0),\r\n     style     = plot.style_linebr,\r\n     linewidth = 2)\r\n\r\nplot(structHigh,\r\n     title     = \"Structure High (Blue)\",\r\n     color     = color.new(color.blue, 0),\r\n     style     = plot.style_linebr,\r\n     linewidth = 2)\r\n\r\nplot(shortStopLevel,\r\n     title     = \"Short Stop Level\",\r\n     color     = color.new(color.blue, 60),\r\n     style     = plot.style_linebr,\r\n     linewidth = 1)\r\n\r\nplot(breakdownLvl,\r\n     title     = \"Short Breakdown (Orange)\",\r\n     color     = color.new(color.orange, 0),\r\n     style     = plot.style_linebr,\r\n     linewidth = 2)\r\n\r\n// =====================\r\n// STRATEGY ORDERS\r\n// =====================\r\n\r\n// Enter / flip long on perfect XL\r\nif perfectLong and strategy.position_size <= 0\r\n    strategy.entry(\"XL Long\", strategy.long)\r\n\r\n// Enter / flip short on perfect XS\r\nif perfectShort and strategy.position_size >= 0\r\n    strategy.entry(\"XS Short\", strategy.short)\r\n\r\n// Long stop\r\nif strategy.position_size > 0\r\n    strategy.exit(\"XL Long SL\", from_entry = \"XL Long\", stop = longStopLevel)\r\n\r\n// Short stop\r\nif strategy.position_size < 0\r\n    strategy.exit(\"XS Short SL\", from_entry = \"XS Short\", stop = shortStopLevel)\r\n\r\n// Alerts\r\nalertcondition(perfectLong,  title = \"Faraz Perfect Long (XL)\",  message = \"XL long setup confirmed.\")\r\nalertcondition(perfectShort, title = \"Faraz Perfect Short (XS)\", message = \"XS short setup confirmed.\")\r\n"
  },
  {
    "url": "oVG24ByQ-EMA-50-200-Pullback-RSI-BTC-USDT-15m-2-Bar-Logic",
    "name": "EMA 50/200 Pullback + RSI (BTC/USDT 15m - 2 Bar Logic)",
    "description": "I recognize that combining indicators requires clear justification on how the components interact Therefore the new scripts description will explicitly detail the strategys operational logic\n\nObjective The strategy is a Trend Following Pullback System designed for high frequency time frames 15m\n\nSynergy The EMA50 EMA200 defines the primary Trend Direction Trend Filter It then utilizes a 2 Bar Pullback Logic to find an entry point where the price has momentarily reversed against the trendline and the RSI 14 serves as a Momentum Filter RSI greater than 50 for Long RSI less than 50 for Short to minimize false signals",
    "image_url": "oVG24ByQ",
    "author": "nookloves26",
    "likes": 6,
    "type": "strategy",
    "created": "2025-11-18",
    "updated": "2025-11-18",
    "source": "//@version=5\r\nstrategy(\"EMA 50/200 Pullback + RSI (BTC/USDT 15m - 2 Bar Logic)\", overlay=true, \r\n     initial_capital=582, currency=currency.USDT, default_qty_value=10, default_qty_type=strategy.percent_of_equity)\r\n\r\n// ============== 1. INPUTS & PARAMETERS ==============\r\n// --- Indicator Lengths ---\r\nlen_ema_short = input.int(50, title=\"EMA Short Length\")\r\nlen_ema_long = input.int(200, title=\"EMA Long Length\")\r\nlen_rsi = input.int(14, title=\"RSI Length\")\r\n\r\n// --- Risk Management ---\r\nrisk_per_trade = input.float(1.0, title=\"Risk % of Equity (Margin Used)\", minval=0.1) // 1%\r\nstop_loss_percent = input.float(0.49, title=\"Stop Loss % from Entry\", minval=0.01) // 0.49% SL\r\nrr_ratio = input.float(5.0, title=\"Risk:Reward Ratio\", minval=1.0) // 1:5\r\nleverage = input.int(1, title=\"Leverage Multiplier\", minval=1) // 10x\r\n\r\n// ============== 2. INDICATOR CALCULATIONS ==============\r\nema50 = ta.ema(close, len_ema_short)\r\nema200 = ta.ema(close, len_ema_long)\r\nrsi14 = ta.rsi(close, len_rsi)\r\n\r\n// ============== 3. POSITION SIZING & RISK MANAGEMENT ==============\r\n// Notional Value = 1% (Margin Used) * 10x (Leverage) = 10% à¸‚à¸­à¸‡ Equity\r\nposition_notional_value = strategy.initial_capital * (risk_per_trade / 100) * leverage\r\ncontracts = position_notional_value / close\r\n\r\n// ============== 4. LONG ENTRY LOGIC (Buy Signal) ==============\r\n\r\n// 1. Trend: EMA 50 à¹€à¸«à¸™à¸·à¸­ EMA 200\r\ntrend_is_up = ema50 > ema200\r\n\r\n// 2. Pullback & Entry (2 à¹à¸—à¹ˆà¸‡):\r\n// C[1]: à¸£à¸²à¸„à¸²à¸›à¸´à¸”à¹à¸—à¹ˆà¸‡à¸à¹ˆà¸­à¸™à¸«à¸™à¹‰à¸² à¸•à¹‰à¸­à¸‡à¸­à¸¢à¸¹à¹ˆà¹ƒà¸•à¹‰ EMA 50 (Pullback)\r\npullback_close_below = close[1] < ema50[1]\r\n// C[0]: à¸£à¸²à¸„à¸²à¸›à¸´à¸”à¹à¸—à¹ˆà¸‡à¸›à¸±à¸ˆà¸ˆà¸¸à¸šà¸±à¸™ à¸”à¸µà¸”à¸à¸¥à¸±à¸šà¸¡à¸²à¸­à¸¢à¸¹à¹ˆà¹€à¸«à¸™à¸·à¸­ EMA 50 (Entry)\r\nentry_close_above = close > ema50\r\n\r\n// 3. RSI Filter: RSI à¸¡à¸²à¸à¸à¸§à¹ˆà¸² 50 à¹ƒà¸™à¹à¸—à¹ˆà¸‡à¸›à¸±à¸ˆà¸ˆà¸¸à¸šà¸±à¸™\r\nrsi_is_bullish = rsi14 > 50\r\n\r\n// à¸ªà¸±à¸à¸à¸²à¸“à¹€à¸‚à¹‰à¸² Long\r\nlong_entry_condition = strategy.position_size == 0 and trend_is_up and pullback_close_below and entry_close_above and rsi_is_bullish\r\n\r\n// ============== 5. SHORT ENTRY LOGIC (Sell Signal) ==============\r\n\r\n// 1. Trend: EMA 50 à¹ƒà¸•à¹‰ EMA 200\r\ntrend_is_down = ema50 < ema200\r\n\r\n// 2. Pullback & Entry (2 à¹à¸—à¹ˆà¸‡):\r\n// C[1]: à¸£à¸²à¸„à¸²à¸›à¸´à¸”à¹à¸—à¹ˆà¸‡à¸à¹ˆà¸­à¸™à¸«à¸™à¹‰à¸² à¸•à¹‰à¸­à¸‡à¸­à¸¢à¸¹à¹ˆà¹€à¸«à¸™à¸·à¸­ EMA 50 (Pullback)\r\npullback_close_above = close[1] > ema50[1]\r\n// C[0]: à¸£à¸²à¸„à¸²à¸›à¸´à¸”à¹à¸—à¹ˆà¸‡à¸›à¸±à¸ˆà¸ˆà¸¸à¸šà¸±à¸™ à¸—à¸¸à¸šà¸¥à¸‡à¸¡à¸²à¸­à¸¢à¸¹à¹ˆà¹ƒà¸•à¹‰ EMA 50 (Entry)\r\nentry_close_below = close < ema50\r\n\r\n// 3. RSI Filter: RSI à¸™à¹‰à¸­à¸¢à¸à¸§à¹ˆà¸² 50 à¹ƒà¸™à¹à¸—à¹ˆà¸‡à¸›à¸±à¸ˆà¸ˆà¸¸à¸šà¸±à¸™\r\nrsi_is_bearish = rsi14 < 50\r\n\r\n// à¸ªà¸±à¸à¸à¸²à¸“à¹€à¸‚à¹‰à¸² Short\r\nshort_entry_condition = strategy.position_size == 0 and trend_is_down and pullback_close_above and entry_close_below and rsi_is_bearish\r\n\r\n// ============== 6. EXECUTION & SINGLE POSITION CONSTRAINT ==============\r\n\r\nif long_entry_condition\r\n    // 6.1 à¸„à¸³à¸™à¸§à¸“ SL & TP Price\r\n    long_stop_loss_price = close * (1 - (stop_loss_percent / 100))\r\n    long_take_profit_price = close * (1 + (stop_loss_percent / 100) * rr_ratio)\r\n\r\n    // 6.2 à¸ªà¹ˆà¸‡à¸„à¸³à¸ªà¸±à¹ˆà¸‡ Long\r\n    strategy.entry(\"Long\", strategy.long, qty=contracts)\r\n    \r\n    // 6.3 à¸•à¸±à¹‰à¸‡ SL/TP (Exit Order)\r\n    strategy.exit(\"Exit Long\", from_entry=\"Long\", stop=long_stop_loss_price, limit=long_take_profit_price)\r\n\r\n\r\nif short_entry_condition\r\n    // 6.1 à¸„à¸³à¸™à¸§à¸“ SL & TP Price\r\n    short_stop_loss_price = close * (1 + (stop_loss_percent / 100))\r\n    short_take_profit_price = close * (1 - (stop_loss_percent / 100) * rr_ratio)\r\n\r\n    // 6.2 à¸ªà¹ˆà¸‡à¸„à¸³à¸ªà¸±à¹ˆà¸‡ Short\r\n    strategy.entry(\"Short\", strategy.short, qty=contracts)\r\n    \r\n    // 6.3 à¸•à¸±à¹‰à¸‡ SL/TP (Exit Order)\r\n    strategy.exit(\"Exit Short\", from_entry=\"Short\", stop=short_stop_loss_price, limit=short_take_profit_price)\r\n    \r\n// ============== 7. PLOTTING (Optional) ==============\r\nplot(ema50, color=color.blue, title=\"EMA 50\")\r\nplot(ema200, color=color.red, title=\"EMA 200\")"
  },
  {
    "url": "OHRNZUG6-Trinity-ATR-Strategy-Saty-Backtest-Edition",
    "name": "Trinity ATR Strategy (Saty) - Backtest Edition",
    "description": "This is not supposed to be a standalone indicator, but releasing this to give a general overview of what it could do, each commodity and timeframe would need to be back tested. Use in conjunction with other indicators and price action.  This is not financial advice and is not a guarantee of financial results. ",
    "image_url": "OHRNZUG6",
    "author": "EMA34TRADER",
    "likes": 23,
    "type": "strategy",
    "created": "2025-11-18",
    "updated": "2025-11-18",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// Â© EMA34TRADER\n\n//@version=5\nstrategy(\"Trinity ATR Strategy (Saty) - Backtest Edition\", \n     overlay=true, \n     default_qty_type=strategy.percent_of_equity, \n     default_qty_value=100, \n     initial_capital=1000, \n     commission_type=strategy.commission.percent, \n     commission_value=0.04,  // realistic slippage + fees\n     pyramiding=0,           // no multiple entries in same direction\n     calc_on_order_fills=true,\n     calc_on_every_tick=false)\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// â”€â”€â”€ ALL YOUR ORIGINAL INPUTS (unchanged + dropdowns)\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\ngroup_style = \"â‹† TRADING STYLE & TIMEFRAME\"\ntrading_type = input.string(\"Day\", \"Select Trading Type\", \n     options=[\"Day\", \"Multiday\", \"Swing\", \"Position\", \"Long-term\"], group=group_style)\n\ngroup_levels = \"â‹† TRIGGER & TARGET SETTINGS\"\ntrigger_pct = input.float(0.236, \"Trigger % (Breakout Sensitivity)\", \n     options=[0.10, 0.15, 0.20, 0.236, 0.25, 0.30, 0.382], group=group_levels)\n\ntarget_mult = input.float(1.0, \"Take Profit Distance (Ã—ATR)\", \n     options=[0.5, 0.8, 1.0, 1.272, 1.5, 1.618, 2.0, 2.618, 3.0], group=group_levels)\n\natr_length = input.int(14, \"ATR Length\", minval=1, group=group_levels)\n\ngroup_visual = \"â‹† VISUAL OPTIONS\"\nuse_options_labels = input.bool(true, \"Use Options Labels (Calls/Puts)\", group=group_visual)\nshow_all_fib = input.bool(true, \"Show Fib Levels\", group=group_visual)\nshow_ext     = input.bool(false, \"Show Extensions\", group=group_visual)\nlevel_size   = input.int(2, \"Line Thickness\", minval=1, maxval=5, group=group_visual)\n\n// Table & Box settings (still fully customizable)\ngroup_table = \"â‹† INFO TABLE\"\nshow_info = input.bool(true, \"Show Info Table\", group=group_table)\ntable_position = input.string(\"Top Right\", \"Table Position\", options=[\"Top Right\", \"Bottom Right\", \"Bottom Left\"], group=group_table)\ntable_size = input.string(\"Normal\", \"Table Text Size\", options=[\"Tiny\", \"Small\", \"Normal\", \"Large\"], group=group_table)\n\ngroup_targetbox = \"â‹† TARGET BOX\"\nbox_size = input.string(\"Normal\", \"Target Box Size\", options=[\"Disabled\", \"Tiny\", \"Small\", \"Normal\", \"Large\"], group=group_targetbox)\n\n// Colors (same as before)\ncol_prev = color.white\ncol_low_tr = color.red\ncol_up_tr  = color.green\ncol_618    = color.silver\ncol_atr1   = color.white\n\n// â”€â”€â”€ HIGHER TIMEFRAME DATA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\ntf = trading_type == \"Day\" ? \"D\" :\n     trading_type == \"Multiday\" ? \"W\" :\n     trading_type == \"Swing\" ? \"M\" :\n     trading_type == \"Position\" ? \"3M\" : \"12M\"\n\nsrc_close = request.security(syminfo.tickerid, tf, close[1], lookahead=barmerge.lookahead_on)  // previous HTF close\natr_val   = request.security(syminfo.tickerid, tf, ta.atr(atr_length)[1], lookahead=barmerge.lookahead_on)\n\n// â”€â”€â”€ LEVELS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nlower_trig = src_close - trigger_pct * atr_val\nupper_trig = src_close + trigger_pct * atr_val\n\nlong_tp  = src_close + atr_val * target_mult\nshort_tp = src_close - atr_val * target_mult\nlong_sl  = strategy.position_avg_price - atr_val\nshort_sl = strategy.position_avg_price + atr_val\n\n// â”€â”€â”€ ENTRY CONDITIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nlongTrigger  = ta.crossover(close, upper_trig)\nshortTrigger = ta.crossunder(close, lower_trig)\n\n// â”€â”€â”€ EXECUTE TRADES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nif (longTrigger)\n    strategy.entry(\"Long\", strategy.long)\n    strategy.exit(\"TP/SL Long\", from_entry=\"Long\", limit=long_tp, stop=long_sl)\n\nif (shortTrigger)\n    strategy.entry(\"Short\", strategy.short)\n    strategy.exit(\"TP/SL Short\", from_entry=\"Short\", limit=short_tp, stop=short_sl)\n\n// â”€â”€â”€ PLOTS & VISUALS (exactly like your indicator) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nplot(src_close, \"Ref Close\", color=color.new(col_prev, 40), linewidth=level_size + 1)\nplot(upper_trig, \"Upper Trigger\", color=color.new(col_up_tr, 0), linewidth=level_size)\nplot(lower_trig, \"Lower Trigger\", color=color.new(col_low_tr, 0), linewidth=level_size)\n\n// Optional fibs\nplot(show_all_fib ? src_close + atr_val * 0.618 : na, color=color.new(col_618, 30), linewidth=level_size + 1)\nplot(show_all_fib ? src_close - atr_val * 0.618 : na, color=color.new(col_618, 30), linewidth=level_size + 1)\n\n// Target & SL lines (only when in position)\nplot(strategy.position_size > 0 ? long_tp : na, \"Long TP\", color=color.green, style=plot.style_linebr, linewidth=2)\nplot(strategy.position_size < 0 ? short_tp : na, \"Short TP\", color=color.red, style=plot.style_linebr, linewidth=2)\nplot(strategy.position_size != 0 ? strategy.position_avg_price - atr_val : na, \"SL -1ATR\", color=color.red, style=plot.style_circles)\nplot(strategy.position_size != 0 ? strategy.position_avg_price + atr_val : na, \"SL +1ATR\", color=color.red, style=plot.style_circles)\n\n// â”€â”€â”€ INFO TABLE (same beautiful table you love) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\npos = table_position == \"Top Right\" ? position.top_right :\n      table_position == \"Bottom Right\" ? position.bottom_right : position.bottom_left\n\ntxt_size = table_size == \"Tiny\" ? size.tiny :\n           table_size == \"Small\" ? size.small :\n           table_size == \"Large\" ? size.large : size.normal\n\nvar table info_table = table.new(pos, 1, 4, bgcolor=color.new(color.black, 80), frame_color=color.gray)\n\nif show_info and barstate.islast\n    trend_col = close > ta.ema(close, 34) ? color.green : color.red\n    range_col = (high - low) / atr_val * 100 < 80 ? color.green : color.red\n\n    table.cell(info_table, 0, 0, \"Trinity Strategy Live\", bgcolor=trend_col, text_color=color.white, text_size=txt_size)\n    table.cell(info_table, 0, 1, trading_type + \" ATR: $\" + str.tostring(atr_val, \"#.##\"), bgcolor=color.navy, text_color=color.white, text_size=txt_size)\n    table.cell(info_table, 0, 2, (use_options_labels ? \"Calls\" : \"Long\") + \" > $\" + str.tostring(upper_trig, \"#.##\") + \"\\nTP $\" + str.tostring(long_tp, \"#.##\"), bgcolor=col_up_tr, text_color=color.white, text_size=txt_size)\n    table.cell(info_table, 0, 3, (use_options_labels ? \"Puts\" : \"Short\") + \" < $\" + str.tostring(lower_trig, \"#.##\") + \"\\nTP $\" + str.tostring(short_tp, \"#.##\"), bgcolor=col_low_tr, text_color=color.white, text_size=txt_size)\n\n// â”€â”€â”€ OPTIONAL TARGET BOX (still there if you want visuals) â”€â”€â”€\nvar box tgt_box = na\nif barstate.islast and box_size != \"Disabled\"\n    box.delete(tgt_box)\n    float h = box_size == \"Tiny\" ? atr_val*0.08 : box_size == \"Small\" ? atr_val*0.15 : box_size == \"Large\" ? atr_val*0.40 : atr_val*0.25\n    if close > upper_trig\n        tgt_box := box.new(bar_index-6, long_tp + h, bar_index+25, long_tp - h, text=\"LONG TP\", bgcolor=color.new(color.green,15), border_color=color.green, text_color=color.white, xloc=xloc.bar_index)\n    if close < lower_trig\n        tgt_box := box.new(bar_index-6, short_tp + h, bar_index+25, short_tp - h, text=\"SHORT TP\", bgcolor=color.new(color.red,15), border_color=color.red, text_color=color.white, xloc=xloc.bar_index)\n\n"
  },
  {
    "url": "aglHJmZc-EMA-Cross-Strategy-v5-30-lots-15-min-candle-only-safe-flip",
    "name": "EMA Cross Strategy v5 (30 lots) (15 min candle only)- safe flip",
    "description": "ðŸš€ EMA Cross Strategy v5 (30 Lots) (15 min candle only)â€” Safe Flip Edition\nFully Automated | Fast | Reliable | Battle-tested\n\nWelcome to a clean, powerful, and automation-friendly EMA crossover system.\nThis strategy is built for traders who want consistent trend-based entries without the risk of unwanted pyramiding or doubled positions.\n\nðŸ”¥ How It Works\n\nThis strategy uses a fast EMA (10) crossing a slow EMA (20) to detect trend shifts:\n\nBullish Crossover â†’ LONG (30 lots)\n\nBearish Crossover â†’ SHORT (30 lots)\n\nEvery opposite signal safely flips the position by first closing the current trade, then opening a fresh position of exactly 30 lots.\n\nNo doubling.\nNo runaway position size.\nNo surprises.\n\nJust clean, mechanical trend-following.\n\nðŸ“ˆ Why This Strategy Stands Out\n\nUnlike basic EMA crossbots, this version:\n\nâœ” Prevents unintended pyramiding\nâœ” Never over-allocates capital\nâœ” Works perfectly with webhook-based automation\nâœ” Produces stable, systematic entries\nâœ” Executes directional flips with precision\n\nðŸ” Backtest Highlights (1-Year)\n\n(Backtests will vary by instrument/timeframe)\n\n1,500+ trades executed\n\nProfit factor above 1.27\n\nStrong trend performance\n\nBalanced long/short behavior\n\nNo margin calls\n\nConsistent trade execution\n\nThis strategy thrives in trending markets and maintains strict discipline even in choppy conditions.\n\nâš™ï¸ Automation Ready\n\nDesigned for automated execution via webhook and API setups on supported platforms.\nJust connect, run, and let the bot follow the rules without hesitation.\n\nNo emotions.\nNo overtrading.\nNo fear or greed.\nPure logic.",
    "image_url": "aglHJmZc",
    "author": "kulkarniabhishek38",
    "likes": 47,
    "type": "strategy",
    "created": "2025-11-17",
    "updated": "2025-11-17",
    "source": "//@version=5\nstrategy(\"EMA Cross Strategy v5 (30 lots) - safe flip\",\n     overlay = true,\n     calc_on_every_tick = true,\n     initial_capital = 10000)\n\n// INPUTS\nemaFast = input.int(title=\"Fast EMA\", defval=10, minval=1)\nemaSlow = input.int(title=\"Slow EMA\", defval=20, minval=1)\ntradeDirection = input.string(title=\"Trade Direction\", defval=\"Both\", options=[\"Long\",\"Short\",\"Both\"])\n\n// CALCS\nfastEMA = ta.ema(close, emaFast)\nslowEMA = ta.ema(close, emaSlow)\n\nplot(fastEMA, color=color.orange, linewidth=2)\nplot(slowEMA, color=color.blue, linewidth=2)\n\n// SIGNALS\nlongOK  = (tradeDirection == \"Long\") or (tradeDirection == \"Both\")\nshortOK = (tradeDirection == \"Short\") or (tradeDirection == \"Both\")\n\nlongSignal  = ta.crossover(fastEMA, slowEMA)\nshortSignal = ta.crossunder(fastEMA, slowEMA)\n\n// SAFE ORDER LOGIC (no doubling)\nqty = 30\n\nif longSignal and longOK\n    // If currently short, close first and then enter long\n    if strategy.position_size < 0\n        strategy.close(\"short\")\n        strategy.entry(\"long\", strategy.long, qty=qty)\n    // If currently flat, enter long\n    else if strategy.position_size == 0\n        strategy.entry(\"long\", strategy.long, qty=qty)\n    // If already long, do nothing (prevents doubling)\n\nif shortSignal and shortOK\n    // If currently long, close first and then enter short\n    if strategy.position_size > 0\n        strategy.close(\"long\")\n        strategy.entry(\"short\", strategy.short, qty=qty)\n    // If currently flat, enter short\n    else if strategy.position_size == 0\n        strategy.entry(\"short\", strategy.short, qty=qty)\n    // If already short, do nothing\n\n// EXIT ON OPPOSITE handled above by close()\nalertcondition(longSignal, title=\"LONG Signal\", message=\"LONG\")\nalertcondition(shortSignal, title=\"SHORT Signal\", message=\"SHORT\")\n"
  },
  {
    "url": "eFPQkfkz",
    "name": "XiaoJiu_RSI_5m_Drop1_DCA",
    "description": "âœ” Automatic buy when RSI < 30\n\nâœ” Automatic averaging down for every 1 point drop in RSI (maximum 21 times)\n\nâœ” Automatic liquidation when RSI > 70\n\nâœ” 28U per average averaging down\n\nâœ” Automatically calculates weighted average cost\n\nâœ” Automatically displays actual profit\n\nâœ” Can be tested on any coin and at any time\n\nâœ” Complete DCA model",
    "image_url": "eFPQkfkz",
    "author": "xiaojiu9",
    "likes": 5,
    "type": "strategy",
    "created": "2025-11-17",
    "updated": "2025-11-17",
    "source": "//@version=5\nstrategy(\"XiaoJiu_RSI_5m_Drop1_DCA\", overlay=true,\n     initial_capital=600, \n     commission_type=strategy.commission.percent,\n     commission_value=0.1)\n\n// === RSI ===\nrsi = ta.rsi(close, 14)\n\n// === å‚æ•° ===\nsingleBuy = 28.0           // æ¯æ¬¡ä¹°å…¥é‡‘é¢\nmaxTimes  = 21             // æœ€å¤§ä¹°å…¥æ¬¡æ•°\nvar buyCount = 0           // ä¹°å…¥æ¬¡æ•°\nvar lastRSI = 100.0        // ä¸Šä¸€æ¬¡ä¹°å…¥/è¡¥ä»“æ—¶çš„ RSI\nvar totalQty = 0.0         // æ€»ä¹°å…¥æ•°é‡\n\n// === é¦–æ¬¡ä¹°å…¥æ¡ä»¶ ===\n// 5m RSI < 30\nbuyCond = (rsi < 30) and (buyCount == 0)\n\n// === è¡¥ä»“æ¡ä»¶ ===\n// 5m RSI æ¯”ä¸Šä¸€æ¬¡ä¹°å…¥ RSI å†ä½Ž 1\naddCond = (buyCount > 0) and (rsi <= lastRSI - 1) and (buyCount < maxTimes)\n\n// === ä¹°å…¥é€»è¾‘ ===\nif buyCond\n    qty = singleBuy / close\n    strategy.entry(\"Long\", strategy.long, qty=qty)\n    buyCount += 1\n    lastRSI := rsi\n    totalQty += qty\n\n// === è¡¥ä»“é€»è¾‘ ===\nif addCond\n    qty = singleBuy / close\n    strategy.entry(\"Add\" + str.tostring(buyCount), strategy.long, qty=qty)\n    buyCount += 1\n    lastRSI := rsi\n    totalQty += qty\n\n// === å–å‡ºæ¡ä»¶ ===\nsellCond = (rsi > 70)\n\n// === å–å‡ºé€»è¾‘ ===\nif sellCond and buyCount > 0\n    strategy.close_all()\n    buyCount := 0\n    totalQty := 0\n    lastRSI := 100\n\n// === å›¾å½¢è¾…åŠ© ===\nplot(rsi, color=color.new(color.blue, 0), title=\"RSI 5m\")\nhline(30, \"RSI 30\", color=color.red)\nhline(70, \"RSI 70\", color=color.green)\n"
  },
  {
    "url": "SkaynRYJ-ZH1-5-Min-Opening-Range-Breakout-Strategy-with-Market-Bias",
    "name": "ZH1/5-Min Opening Range Breakout Strategy with Market Bias",
    "description": "x.com\n\"ZH1/5-Min Opening Range Breakout Strategy with Market Bias\"\n\n",
    "image_url": "SkaynRYJ",
    "author": "TheHedgedOne",
    "likes": 45,
    "type": "strategy",
    "created": "2025-11-17",
    "updated": "2025-11-17",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// Â© TheHedgedOne\r\n\r\n\r\n//@version=6\r\nstrategy(\r\n     title             = \"ZH1/5-Min Opening Range Breakout Strategy with Market Bias\",\r\n     shorttitle        = \"ZH1/5ORB\",\r\n     overlay           = true,\r\n     initial_capital   = 10000,\r\n     currency          = currency.USD,\r\n     default_qty_type  = strategy.fixed,\r\n     default_qty_value = 1)\r\n\r\n// =====================================================\r\n// INPUTS\r\n// =====================================================\r\nopeningRangeMin   = input.int(5,   \"Opening Range Minutes\", minval = 1, maxval = 120)\r\n\r\n// Opening Range session + timezone\r\norSession   = input.session(\"0930-1600\", \"Opening Range Time Period\")\r\norTimezone  = input.string(\r\n     \"America/New_York\",\r\n     \"Timezone\",\r\n     options = [\r\n         \"America/New_York\",\"America/Los_Angeles\",\"America/Chicago\",\"America/Phoenix\",\r\n         \"America/Toronto\",\"America/Vancouver\",\"America/Argentina/Buenos_Aires\",\r\n         \"America/El_Salvador\",\"America/Sao_Paulo\",\"America/Bogota\",\r\n         \"Europe/Moscow\",\"Europe/Athens\",\"Europe/Berlin\",\"Europe/London\",\r\n         \"Europe/Madrid\",\"Europe/Paris\",\"Europe/Warsaw\",\r\n         \"Australia/Sydney\",\"Australia/Brisbane\",\"Australia/Adelaide\",\"Australia/ACT\",\r\n         \"Asia/Almaty\",\"Asia/Tokyo\",\"Asia/Taipei\",\"Asia/Singapore\",\r\n         \"Asia/Shanghai\",\"Asia/Seoul\",\"Asia/Tehran\",\"Asia/Dubai\",\"Asia/Kolkata\",\r\n         \"Asia/Hong_Kong\",\"Asia/Bangkok\",\r\n         \"Pacific/Auckland\",\"Pacific/Honolulu\"\r\n     ])\r\n\r\nshowLabels        = input.bool(true,  \"Show Debug Labels\")\r\nshowRangeBox      = input.bool(true,  \"Show OR Box\")\r\nshowSignals       = input.bool(true,  \"Show Signals\")\r\natrMultStop       = input.float(1.5,  \"ATR Multiplier Stop\", step = 0.1)\r\natrLength         = input.int(14,     \"ATR Length\", minval = 1)\r\nminMomentumLong   = input.int(100,    \"Min Momentum Long (Score)\")\r\nmaxMomentumShort  = input.int(100,    \"Max Momentum Short (Score)\")\r\nminAdx            = input.int(20,     \"Min ADX for Trend\")\r\n\r\n// Bias / Momentum inputs\r\nsmaLength         = input.int(100,  \"SMA Length\")\r\nemaLength         = input.int(1000, \"EMA Length\")\r\nrsiLength         = input.int(14,   \"RSI Length\")\r\nrsiOverbought     = input.float(70, \"RSI Overbought\")\r\nrsiOversold       = input.float(30, \"RSI Oversold\")\r\n\r\nvwmoLength        = input.int(20,   \"VWMO Length\")\r\n\r\nadxLenInput       = input.int(14,   \"ADX / DI Length\")\r\n\r\nstochLength       = input.int(14,   \"Stoch Length\")\r\nstochD            = input.int(3,    \"Stoch D\")\r\nstochOverbought   = input.float(80, \"Stoch Overbought\")\r\nstochOversold     = input.float(20, \"Stoch Oversold\")\r\n\r\ncciLength         = input.int(14,   \"CCI Length\")\r\ncciOverbought     = input.float(100,   \"CCI Overbought\")\r\ncciOversold       = input.float(-100,  \"CCI Oversold\")\r\n\r\nmfiLength         = input.int(14,   \"MFI Length\")\r\nvolSmaLength      = input.int(20,   \"Vol SMA Length\")\r\n\r\n// =====================================================\r\n// OPENING RANGE: Session + Minutes\r\n// =====================================================\r\n\r\n// Ð±Ð°Ñ€Ñ‹ Ð²Ð½ÑƒÑ‚Ñ€Ð¸ Ð·Ð°Ð´Ð°Ð½Ð½Ð¾Ð¹ ÑÐµÑÑÐ¸Ð¸/Ñ‚Ð°Ð¹Ð¼Ð·Ð¾Ð½Ñ‹\r\ninSession   = not na(time(timeframe.period, orSession, orTimezone))\r\nnewSession  = inSession and not inSession[1]\r\nsessionEnd  = not inSession and inSession[1]\r\n\r\n// ÑÐºÐ¾Ð»ÑŒÐºÐ¾ Ð±Ð°Ñ€Ð¾Ð² Ð² Ñ‚ÐµÐºÑƒÑ‰ÐµÐ¼ Ð¢Ð¤\r\ntfSec  = timeframe.in_seconds()\r\norBars = math.max(1, math.round(openingRangeMin * 60.0 / tfSec))\r\n\r\n// ÑÑ‡Ñ‘Ñ‚Ñ‡Ð¸Ðº Ð±Ð°Ñ€Ð¾Ð² Ð¸ OR\r\nvar int   barsFromOpen = na\r\nvar bool  orDone       = false\r\nvar float orHigh       = na\r\nvar float orLow        = na\r\n\r\nif newSession\r\n    // Ð½Ð¾Ð²Ñ‹Ð¹ Ð´ÐµÐ½ÑŒ/ÑÐµÑÑÐ¸Ñ\r\n    barsFromOpen := 0\r\n    orDone       := false\r\n    orHigh       := high\r\n    orLow        := low\r\nelse if inSession and not orDone\r\n    barsFromOpen := nz(barsFromOpen) + 1\r\n    orHigh       := math.max(orHigh, high)\r\n    orLow        := math.min(orLow,  low)\r\n\r\nif sessionEnd\r\n    // Ð²Ñ‹Ñ…Ð¾Ð´Ð¸Ð¼ Ð¸Ð· ÑÐµÑÑÐ¸Ð¸ â€” ÑÐ±Ñ€Ð°ÑÑ‹Ð²Ð°ÐµÐ¼ Ð²ÑÑ‘\r\n    barsFromOpen := na\r\n    orDone       := false\r\n    orHigh       := na\r\n    orLow        := na\r\n\r\n// Ð´Ð¸Ð°Ð¿Ð°Ð·Ð¾Ð½ Ñ„Ð¾Ñ€Ð¼Ð¸Ñ€ÑƒÐµÑ‚ÑÑ, Ð¿Ð¾ÐºÐ° Ð½Ðµ Ð½Ð°Ð±Ñ€Ð°Ð»Ð¸ Ð½ÑƒÐ¶Ð½Ð¾Ðµ Ñ‡Ð¸ÑÐ»Ð¾ Ð±Ð°Ñ€Ð¾Ð²\r\nisOpeningRange      = inSession and not orDone and barsFromOpen < orBars\r\n\r\n// ÐºÐ°Ðº Ñ‚Ð¾Ð»ÑŒÐºÐ¾ OR Ð·Ð°ÐºÐ¾Ð½Ñ‡Ð¸Ð»ÑÑ â€” Ñ„Ð¸ÐºÑÐ¸Ñ€ÑƒÐµÐ¼ ÐµÐ³Ð¾ Ð´Ð¾ ÐºÐ¾Ð½Ñ†Ð° ÑÐµÑÑÐ¸Ð¸\r\nif inSession and not isOpeningRange and not orDone and barsFromOpen >= orBars\r\n    orDone := true\r\n\r\n// Ñ„Ð¸Ð½Ð°Ð»ÑŒÐ½Ñ‹Ðµ Ð»Ð¸Ð½Ð¸Ð¸ OR Ð¿Ð¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÐ¼ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð²Ð½ÑƒÑ‚Ñ€Ð¸ ÑÐµÑÑÐ¸Ð¸\r\nopeningHigh = orDone and inSession ? orHigh : na\r\nopeningLow  = orDone and inSession ? orLow  : na\r\norRange     = orHigh - orLow\r\n\r\n// Ð»Ð¸Ð½Ð¸Ð¸ OR\r\norHighPlot = plot(openingHigh, title=\"OR High\", color=color.yellow)\r\norLowPlot  = plot(openingLow,  title=\"OR Low\",  color=color.yellow)\r\n\r\n// Ð¤Ð¸Ð±Ð¾-Ñ‚Ð°Ñ€Ð³ÐµÑ‚Ñ‹ 2.0 Ð¸ 2.618 Ð¾Ñ‚ Ð´Ð¸Ð°Ð¿Ð°Ð·Ð¾Ð½Ð° OR (Ñ‚Ð¾Ð¶Ðµ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð² ÑÐµÑÑÐ¸Ð¸)\r\nfib200Up  = orDone and inSession and not na(orHigh) ? orHigh + orRange * 2.0   : na\r\nfib2618Up = orDone and inSession and not na(orHigh) ? orHigh + orRange * 2.618 : na\r\nfib200Dn  = orDone and inSession and not na(orLow)  ? orLow  - orRange * 2.0   : na\r\nfib2618Dn = orDone and inSession and not na(orLow)  ? orLow  - orRange * 2.618 : na\r\n\r\nplot(fib200Up,  title=\"Fib 2.0 Up\",   color=color.new(color.lime,  0))\r\nplot(fib2618Up, title=\"Fib 2.618 Up\", color=color.new(color.lime, 40))\r\nplot(fib200Dn,  title=\"Fib 2.0 Dn\",   color=color.new(color.red,   0))\r\nplot(fib2618Dn, title=\"Fib 2.618 Dn\", color=color.new(color.red,  40))\r\n\r\n// Ð¿Ð¾Ð´ÑÐ²ÐµÑ‚ÐºÐ° OR Ð²Ð¾ Ð²Ñ€ÐµÐ¼Ñ Ñ„Ð¾Ñ€Ð¼Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ\r\norTop = showRangeBox and isOpeningRange ? high : na\r\norBot = showRangeBox and isOpeningRange ? low  : na\r\npTop  = plot(orTop, title=\"OR Top\", display=display.none)\r\npBot  = plot(orBot, title=\"OR Bot\", display=display.none)\r\nfill(pTop, pBot, color=color.new(color.gray, 80))\r\n\r\n// Ð¸Ð½Ñ„Ð¾-Ð»ÐµÐ¹Ð±Ð» Ð¿Ð¾ OR â€” Ð¾Ð´Ð¸Ð½ Ñ€Ð°Ð·, Ð² Ð¼Ð¾Ð¼ÐµÐ½Ñ‚ Ñ„Ð¸ÐºÑÐ°Ñ†Ð¸Ð¸ Ð´Ð¸Ð°Ð¿Ð°Ð·Ð¾Ð½Ð°\r\nvar label orLabel = na\r\nif not showLabels and not na(orLabel)\r\n    label.delete(orLabel)\r\n    orLabel := na\r\n\r\nif showLabels and orDone and not orDone[1]\r\n    if not na(orLabel)\r\n        label.delete(orLabel)\r\n    orLabel := label.new(bar_index, orHigh,text      = \"OR \" + str.tostring(orLow, format.mintick) + \"â€“\" + str.tostring(orHigh, format.mintick) +\" | Rng: \" + str.tostring(orRange, format.mintick),style     = label.style_label_down,color     = color.new(color.black, 0),textcolor = color.white)\r\n\r\n// =====================================================\r\n// ADX / DMI helpers\r\n// =====================================================\r\ndirmov(len) =>\r\n    up      = ta.change(high)\r\n    down    = -ta.change(low)\r\n    plusDM  = na(up)   ? na : (up   > down and up   > 0 ? up   : 0)\r\n    minusDM = na(down) ? na : (down > up   and down > 0 ? down : 0)\r\n    trur    = ta.rma(ta.tr(true), len)\r\n    plus    = fixnan(100 * ta.rma(plusDM,  len) / trur)\r\n    minus   = fixnan(100 * ta.rma(minusDM, len) / trur)\r\n    [plus, minus]\r\n\r\nadxAll(lenDI, lenADX) =>\r\n    [plus, minus] = dirmov(lenDI)\r\n    sum   = plus + minus\r\n    adx   = 100 * ta.rma(math.abs(plus - minus) / (sum == 0 ? 1 : sum), lenADX)\r\n    [adx, plus, minus]\r\n\r\n// Ñ€Ð°ÑÑ‡Ñ‘Ñ‚ ADX Ð¸ DI\r\n[adxVal, diPlus, diMinus] = adxAll(adxLenInput, adxLenInput)\r\nbullishDMI  = diPlus > diMinus\r\nbearishDMI  = diMinus > diPlus\r\n\r\n// =====================================================\r\n// BIAS & MOMENTUM\r\n// =====================================================\r\nsma100   = ta.sma(close, smaLength)\r\nema1000  = ta.ema(close, emaLength)\r\nvwapDay  = ta.vwap(hlc3)\r\n\r\npriceAboveAll = close > sma100 and close > ema1000 and close > vwapDay\r\npriceBelowAll = close < sma100 and close < ema1000 and close < vwapDay\r\n\r\nrsiVal = ta.rsi(close, rsiLength)\r\n\r\n// VWMO ÐºÐ°Ðº Ñ€Ð°Ð·Ð½Ð¸Ñ†Ð° VWMA\r\nvwmaCurr = ta.vwma(close, vwmoLength)\r\nvwmaPast = vwmaCurr[vwmoLength]\r\nvwmo     = vwmaPast == 0 ? 0.0 : (vwmaCurr - vwmaPast) / vwmaPast * 100.0\r\n\r\nkRaw       = ta.stoch(high, low, close, stochLength)\r\nstochFullK = ta.sma(kRaw, stochD)\r\n\r\ncciVal = ta.cci(hlc3, cciLength)\r\n\r\nmfiVal     = ta.mfi(hlc3, mfiLength)\r\nmfiBullish = mfiVal > 50\r\nmfiBearish = mfiVal < 50\r\n\r\ndeltaVol        = close > close[1] ? volume : close < close[1] ? -volume : 0.0\r\ncumDelta        = ta.cum(deltaVol)\r\ncumDeltaRising  = cumDelta > cumDelta[1]\r\ncumDeltaFalling = cumDelta < cumDelta[1]\r\n\r\nvolSma         = ta.sma(volume, volSmaLength)\r\nhighVolume     = volume > volSma * 1.5\r\natrVal         = ta.atr(atrLength)\r\natrAvg         = ta.sma(atrVal, 20)\r\nhighVolatility = atrVal > atrAvg * 1.5\r\n\r\n// =====================================================\r\n// MOMENTUM SCORE (0â€“200)\r\n// =====================================================\r\npriceScore =\r\n     priceAboveAll ? 50 :\r\n     priceBelowAll ? 0  : 25\r\n\r\nrsiScore =\r\n     rsiVal > rsiOverbought ? 25 :\r\n     rsiVal < rsiOversold   ? 0  :\r\n     rsiVal > 50            ? 15 : 5\r\n\r\nvwmoScore =\r\n     vwmo > 1  ? 25 :\r\n     vwmo < -1 ? 0  :\r\n     vwmo > 0  ? 15 : 5\r\n\r\nadxScore =\r\n     adxVal > 40 ? 20 :\r\n     adxVal > 25 ? 10 : 0\r\n\r\nstochScore =\r\n     stochFullK > stochOverbought ? 20 :\r\n     stochFullK < stochOversold   ? 0  :\r\n     stochFullK > 50              ? 12 : 4\r\n\r\ncciScore =\r\n     cciVal >  cciOverbought ? 20 :\r\n     cciVal <  cciOversold   ? 0  :\r\n     cciVal >  0             ? 12 : 4\r\n\r\nmfiScore =\r\n     mfiVal > 80 ? 15 :\r\n     mfiVal < 20 ? 0  :\r\n     mfiVal > 50 ? 10 : 3\r\n\r\nvolScore       = highVolatility ? 10 : 5\r\ncumDeltaScore  =\r\n     cumDeltaRising  ? 15 :\r\n     cumDeltaFalling ? 0  : 8\r\n\r\nmomentumScore =\r\n     priceScore + rsiScore + vwmoScore + adxScore +\r\n     stochScore + cciScore + mfiScore + volScore + cumDeltaScore\r\n\r\nstrongTrend = adxVal > minAdx\r\n\r\nmarketBias =\r\n     momentumScore > 155 ? 5 :\r\n     momentumScore > 115 ? 4 :\r\n     momentumScore < 45  ? 1 :\r\n     momentumScore < 75  ? 2 : 3\r\n\r\n// =====================================================\r\n// DEBUG LABEL (Ð¾Ð´Ð¸Ð½, Ð¾Ð±Ð½Ð¾Ð²Ð»ÑÐµÐ¼Ñ‹Ð¹)\r\n// =====================================================\r\nbiasColor =\r\n     marketBias >= 4 ? color.green :\r\n     marketBias <= 2 ? color.red   : color.yellow\r\n\r\nbiasText =\r\n     marketBias == 5 ? \"STRONG BULL\" :\r\n     marketBias == 4 ? \"BULLISH\"    :\r\n     marketBias == 1 ? \"STRONG BEAR\":\r\n     marketBias == 2 ? \"BEARISH\"    : \"NEUTRAL\"\r\n\r\nvar label debugLabel = na\r\n\r\n// ÐµÑÐ»Ð¸ Ð²Ñ‹ÐºÐ»ÑŽÑ‡Ð¸Ð»Ð¸ Ð³Ð°Ð»ÐºÑƒ â€” ÑƒÐ´Ð°Ð»ÑÐµÐ¼\r\nif not showLabels and not na(debugLabel)\r\n    label.delete(debugLabel)\r\n    debugLabel := na\r\n\r\n// Ð¾Ð´Ð¸Ð½ Ð»ÐµÐ¹Ð±Ð» Ð½Ð° Ð¿Ð¾ÑÐ»ÐµÐ´Ð½ÐµÐ¼ Ð±Ð°Ñ€Ðµ: Ð¾Ð±Ð½Ð¾Ð²Ð»ÑÐµÐ¼ ÐºÐ¾Ð¾Ñ€Ð´Ð¸Ð½Ð°Ñ‚Ñ‹/Ñ‚ÐµÐºÑÑ‚\r\nif showLabels and barstate.islast\r\n    txt = biasText + \" | Score: \" + str.tostring(momentumScore, \"#\")\r\n    if na(debugLabel)\r\n        debugLabel := label.new(bar_index, high,text      = txt,style     = label.style_label_down,color     = color.new(color.black, 0),textcolor = biasColor)\r\n    else\r\n        label.set_xy(debugLabel, bar_index, high)\r\n        label.set_text(debugLabel, txt)\r\n        label.set_textcolor(debugLabel, biasColor)\r\n        label.set_color(debugLabel, color.new(color.black, 0))\r\n\r\n// =====================================================\r\n// ENTRY LOGIC\r\n// =====================================================\r\nbullCandle = close > open\r\nbearCandle = close < open\r\n\r\nlongBreakout  = orDone and inSession and not na(orHigh) and close[1] <= orHigh and close > orHigh and highVolume and bullCandle\r\nshortBreakout = orDone and inSession and not na(orLow)  and close[1] >= orLow  and close < orLow  and highVolume and bearCandle\r\n\r\nlongBiasCond  = marketBias >= 3 and momentumScore >= minMomentumLong  and strongTrend and bullishDMI\r\nshortBiasCond = marketBias <= 3 and momentumScore <= maxMomentumShort and strongTrend and bearishDMI\r\n\r\nlongEntry  = longBreakout  and longBiasCond\r\nshortEntry = shortBreakout and shortBiasCond\r\n\r\nplotshape(showSignals and longBreakout,  title=\"Debug Long Break\",  style=shape.triangleup,   color=color.new(color.lime, 0), size=size.tiny, location=location.belowbar)\r\nplotshape(showSignals and shortBreakout, title=\"Debug Short Break\", style=shape.triangledown, color=color.new(color.red,  0), size=size.tiny, location=location.abovebar)\r\n\r\n// =====================================================\r\n// EXIT LOGIC (Fib 2.0 / 2.618 + ATR-ÑÑ‚Ð¾Ð¿)\r\n// =====================================================\r\nlongTarget1  = orDone and inSession and high >= fib200Up\r\nlongTarget2  = orDone and inSession and high >= fib2618Up\r\nshortTarget1 = orDone and inSession and low  <= fib200Dn\r\nshortTarget2 = orDone and inSession and low  <= fib2618Dn\r\n\r\nlongStop  = orDone and inSession and low  <= orLow  - atrVal * atrMultStop\r\nshortStop = orDone and inSession and high >= orHigh + atrVal * atrMultStop\r\n\r\nlongExit  = longTarget1  or longTarget2  or longStop\r\nshortExit = shortTarget1 or shortTarget2 or shortStop\r\n\r\n// =====================================================\r\n// Ð¡Ð˜Ð“ÐÐÐ›Ð« ÐÐ Ð“Ð ÐÐ¤Ð˜ÐšÐ•\r\n// =====================================================\r\nplotshape(showSignals and longEntry,  title=\"Long Entry\",  style=shape.triangleup,   color=color.lime,  size=size.small, location=location.belowbar)\r\nplotshape(showSignals and shortEntry, title=\"Short Entry\", style=shape.triangledown, color=color.red,   size=size.small, location=location.abovebar)\r\n\r\n// =====================================================\r\n// ORDERS (1 ÐºÐ¾Ð½Ñ‚Ñ€Ð°ÐºÑ‚)\r\n// =====================================================\r\nif longEntry\r\n    strategy.entry(\"ORB Long\", strategy.long)\r\n\r\nif longExit\r\n    strategy.close(\"ORB Long\")\r\n\r\nif shortEntry\r\n    strategy.entry(\"ORB Short\", strategy.short)\r\n\r\nif shortExit\r\n    strategy.close(\"ORB Short\")\r\n"
  },
  {
    "url": "gMdx2jrl",
    "name": "Golden Cross 50/200 EMA",
    "description": "Trend-following systems are characterized by having a low win rate, yet in the right circumstances (trending markets and higher timeframes) they can deliver returns that even surpass those of systems with a high win rate.\n\nBelow, I show you a simple bullish trend-following system with clear execution rules:\n\n System Rules \n\n-Long entries when the 50-period EMA crosses above the 200-period EMA.\n\n-Stop Loss (SL) placed at the lowest low of the 15 candles prior to the entry candle.\n\n-Take Profit (TP) triggered when the 50-period EMA crosses below the 200-period EMA.\n\n\n Risk Management \n\n-Initial capital: $10,000\n\n-Position size: 10% of capital per trade\n\n-Commissions: 0.1% per trade\n\n Important Note: \n\nIn the code, the stop loss is defined using the swing low (15 candles), but the position size is not adjusted based on the distance to the stop loss. In other words, 10% of the equity is risked on each trade, but the actual loss on the trade is not controlled by a maximum fixed percentage of the account â€” it depends entirely on the stop loss level. This means the loss on a single trade could be significantly higher or lower than 10% of the account equity, depending on volatility.\n\nImplementing leverage or reducing position size based on volatility is something I havenâ€™t been able to include in the code, but it would dramatically improve the systemâ€™s performance. It would fix a consistent percentage loss per trade, preventing losses from fluctuating wildly with changes in volatility.\n\nFor example, we can maintain a fixed loss percentage when volatility is low by using the following formula:\n Leverage = % of SL youâ€™re willing to risk / % volatility from entry point to stop loss \n\nAnd when volatility is high and would exceed the fixed percentage we want to expose per trade (if the SL is hit), we could reduce the position size accordingly.\n\nPractical example:\n\nImagine we only want to risk 15% of the position value if the stop loss is triggered on Tesla (which has high volatility), but the distance to the SL represents a potential 23.57% drop. In this case, we subtract the desired risk (15%) from the actual volatility-based loss (23.57%):\n\n23.57% âˆ’ 15% = 8.57%\n\nNow suppose we normally use $200 per trade.\n\nTo calculate 8.57% of $200:\n\n200 Ã— (8.57 / 100) = $17.14\n\nThen subtract that amount from the original position size:\n\n$200 âˆ’ $17.14 = $182.86\n\nIn summary:\n\nIf we reduce the position size to $182.86 (instead of the usual $200), even if Tesla moves 23.57% against us and hits the stop loss, we would still only lose approximately 15% of the original $200 position â€” exactly the risk level we defined. This way, we strictly respect our risk management rules regardless of volatility swings.\n\nI hope this clearly explains the importance of capping losses at a fixed percentage per trade. This keeps risk under control while maintaining a consistent percentage of capital invested per trade â€” preventing both statistical distortion of the system and the potential destruction of the account.\n\n About the code: \n\n Strategy declaration: \n\nThe strategy is named 'Golden Cross 50/200 EMA'.\n\noverlay=true means it will be drawn directly on the price chart.\n\ninitial_capital=10000 sets the initial capital to $10,000.\n\ndefault_qty_type=strategy.percent_of_equity and default_qty_value=10 means each trade uses 10% of available equity.\n\nmargin_long=0 indicates no margin is used for long positions (this is likely for simulation purposes only; in real trading, margin would be required).\n\ncommission_type=strategy.commission.percent and commission_value=0.1 sets a 0.1% commission per trade.\n\n Indicators: \n\nCalculates two EMAs: a 50-period EMA (ema50) and a 200-period EMA (ema200).\n\n Crossover detection: \n\nbullCross is triggered when the 50-period EMA crosses above the 200-period EMA (Golden Cross).\n\nbearCross is triggered when the 50-period EMA crosses below the 200-period EMA (Death Cross).\n\n Recent swing: \n\nswingLow calculates the lowest low of the previous 15 periods.\n\n Stop Loss: \n\nentryStopLoss is a variable initialized as na (not available) and is updated to the current swingLow value whenever a bullCross occurs.\n\n Entry and exit conditions: \n\nEntry: When a bullCross occurs, the initial stop loss is set to the current swingLow and a long position is opened.\n\nExit on opposite signal: When a bearCross occurs, the long position is closed.\n\nExit on stop loss: If the price falls below entryStopLoss while a position is open, the position is closed.\n\n Visualization: \n\nBoth EMAs are plotted (50-period in blue, 200-period in red).\n\nGreen triangles are plotted below the bar on a bullCross, and red triangles above the bar on a bearCross.\n\nA horizontal orange line is drawn that shows the stop loss level whenever a position is open.\n\n Alerts: \n\nAlerts are created for:Long entry\n\nExit on bearish crossover (Death Cross)\n\nExit triggered by stop loss\n\n\n Favorable Conditions: \n\n Tesla (45-minute timeframe) \nJune 29, 2010 â€“ November 17, 2025\nTotal net profit: $12,458.73 or +124.59%\nMaximum drawdown: $1,210.40 or 8.29%\nTotal trades: 107\nWinning trades: 27.10% (29/107)\nProfit factor: 3.141\n\n Tesla (1-hour timeframe) \nJune 29, 2010 â€“ November 17, 2025\nTotal net profit: $7,681.83 or +76.82%\nMaximum drawdown: $993.36 or 7.30%\nTotal trades: 75\nWinning trades: 29.33% (22/75)\nProfit factor: 3.157\n\n Netflix (45-minute timeframe) \nMay 23, 2002 â€“ November 17, 2025\nTotal net profit: $11,380.73 or +113.81%\nMaximum drawdown: $699.45 or 5.98%\nTotal trades: 134\nWinning trades: 36.57% (49/134)\nProfit factor: 2.885\n\n Netflix (1-hour timeframe) \nMay 23, 2002 â€“ November 17, 2025\nTotal net profit: $11,689.05 or +116.89%\nMaximum drawdown: $844.55 or 7.24%\nTotal trades: 107\nWinning trades: 37.38% (40/107)\nProfit factor: 2.915\n\n Netflix (2-hour timeframe) \nMay 23, 2002 â€“ November 17, 2025\nTotal net profit: $12,807.71 or +128.10%\nMaximum drawdown: $866.52 or 6.03%\nTotal trades: 56\nWinning trades: 41.07% (23/56)\nProfit factor: 3.891\n\n Meta (45-minute timeframe) \nMay 18, 2012 â€“ November 17, 2025\nTotal net profit: $2,370.02 or +23.70%\nMaximum drawdown: $365.27 or 3.50%\nTotal trades: 83\nWinning trades: 31.33% (26/83)\nProfit factor: 2.419\n\n Apple (45-minute timeframe) \nJanuary 3, 2000 â€“ November 17, 2025\nTotal net profit: $8,232.55 or +80.59%\nMaximum drawdown: $581.11 or 3.16%\nTotal trades: 140\nWinning trades: 34.29% (48/140)\nProfit factor: 3.009\n\n Apple (1-hour timeframe) \nJanuary 3, 2000 â€“ November 17, 2025\nTotal net profit: $9,685.89 or +94.93%\nMaximum drawdown: $374.69 or 2.26%\nTotal trades: 118\nWinning trades: 35.59% (42/118)\nProfit factor: 3.463\n\n Apple (2-hour timeframe) \nJanuary 3, 2000 â€“ November 17, 2025\nTotal net profit: $8,001.28 or +77.99%\nMaximum drawdown: $755.84 or 7.56%\nTotal trades: 67\nWinning trades: 41.79% (28/67)\nProfit factor: 3.825\n\n NVDA (15-minute timeframe) \nJanuary 3, 2000 â€“ November 17, 2025\nTotal net profit: $11,828.56 or +118.29%\nMaximum drawdown: $1,275.43 or 8.06%\nTotal trades: 466\nWinning trades: 28.11% (131/466)\nProfit factor: 2.033\n\n NVDA (30-minute timeframe) \nJanuary 3, 2000 â€“ November 17, 2025\nTotal net profit: $12,203.21 or +122.03%\nMaximum drawdown: $1,661.86 or 10.35%\nTotal trades: 245\nWinning trades: 28.98% (71/245)\nProfit factor: 2.291\n\n NVDA (45-minute timeframe) \nJanuary 3, 2000 â€“ November 17, 2025\nTotal net profit: $16,793.48 or +167.93%\nMaximum drawdown: $1,458.81 or 8.40%\nTotal trades: 172\nWinning trades: 33.14% (57/172)\nProfit factor: 2.927\n",
    "image_url": "gMdx2jrl",
    "author": "OldWave96",
    "likes": 24,
    "type": "strategy",
    "created": "2025-11-17",
    "updated": "2025-11-17",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// Â© Especulador96\n\n//@version=6\nstrategy('Golden Cross 50/200 EMA', \n     overlay=true, \n     initial_capital=10000, \n     default_qty_type=strategy.percent_of_equity, \n     default_qty_value=10,\n     margin_long=0,\n     commission_type=strategy.commission.percent, \n     commission_value=0.1)\n\n// EMA Parameters\nema50 = ta.ema(close, 50)\nema200 = ta.ema(close, 200)\n\n// Detect crosses\nbullCross = ta.crossover(ema50, ema200)\nbearCross = ta.crossunder(ema50, ema200)\n\n// Calculate recent swing low\nswingLow = ta.lowest(low, 15)\n\n// Variable to store swing low at crossover moment\nvar float entryStopLoss = na\n\n// IMPROVED ENTRY CONDITION\nif bullCross\n    entryStopLoss := swingLow\n    strategy.entry('Long', strategy.long, comment='EMA Cross Entry')\n\n// EXIT CONDITIONS\nif bearCross\n    strategy.close('Long', comment='Exit Bear Cross')\n\nif strategy.position_size > 0 and low < entryStopLoss\n    strategy.close('Long', comment='SL Hit')\n\n// VISUALIZATION\nplot(ema50, color=color.new(#0a477c, 0), title='EMA 50', linewidth=2)\nplot(ema200, color=color.new(#a91a1a, 0), title='EMA 200', linewidth=2)\n\nplotshape(bullCross, style=shape.triangleup, location=location.belowbar, \n          color=color.new(color.green, 0), size=size.normal, title='Buy Signal')\nplotshape(bearCross, style=shape.triangledown, location=location.abovebar, \n          color=color.new(color.red, 0), size=size.normal, title='Sell Signal')\n\n// Stop Loss Line\nplot(strategy.position_size > 0 ? entryStopLoss : na, \n     color=color.new(#c88212, 0), style=plot.style_linebr, \n     linewidth=2, title='Stop Loss Level')\n\n// Alerts\nalertcondition(bullCross, title='Long Entry', \n               message='EMA Cross - Long entry with 10% capital')\nalertcondition(bearCross, title='Bearish Cross Exit', \n               message='Bearish cross - Position close')\nalertcondition(strategy.position_size > 0 and low < entryStopLoss, \n               title='Stop Loss Triggered', \n               message='Stop Loss reached')"
  },
  {
    "url": "qSth3L3x-ZH1-ORB-Momentum-System",
    "name": "ZH1/ORB Momentum System",
    "description": "x.com\nZH1/ORB Momentum System",
    "image_url": "qSth3L3x",
    "author": "TheHedgedOne",
    "likes": 30,
    "type": "strategy",
    "created": "2025-11-17",
    "updated": "2025-11-17",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// Â© TheHedgedOne\r\n\r\n//@version=6\r\nstrategy(title             = \"ZH1/ORB Momentum System (1 Contract)\",shorttitle        = \"ZH1/ORB System\",overlay           = true,initial_capital   = 10000,currency          = currency.USD,default_qty_type  = strategy.fixed,default_qty_value = 1)\r\n\r\n// =====================================================\r\n// INPUTS\r\n// =====================================================\r\n\r\n// --- Opening Range ---\r\nopeningRangeMin   = input.int(5,   \"Opening Range Minutes\")   // Ð¾ÑÑ‚Ð°Ð²Ð¸Ñ‚ÑŒ\r\nuseSessionOR      = input.bool(false, \"Use Opening Range Time Period?\")\r\n\r\norSession         = input.session(\"0930-0935\", \"Opening Range Time Period\")\r\norTimezone        = input.string(\"America/New_York\",\"Timezone\",options = [\"America/New_York\",\"America/Chicago\",\"America/Los_Angeles\",\"Europe/London\",\"Europe/Berlin\",\"Europe/Moscow\",\"Asia/Almaty\",\"Asia/Dubai\",\"Asia/Singapore\",\"Asia/Tokyo\"])\r\n\r\nshowRangeBox      = input.bool(true,  \"Show OR Box\")\r\nshowSignals       = input.bool(true,  \"Show Signals\")\r\natrMultStop       = input.float(1.5,  \"ATR Multiplier Stop\")\r\natrLength         = input.int(14,     \"ATR Length\")\r\nminMomentumLong   = input.int(100,    \"Min Momentum Long\")\r\nmaxMomentumShort  = input.int(100,    \"Max Momentum Short\")\r\nminAdx            = input.int(20,     \"Min ADX for Trend\")\r\ntrendPercent      = input.float(1.0,  \"Trend Target %\")\r\n\r\n// Bias / Momentum inputs\r\nsmaLength         = input.int(100,  \"SMA Length\")\r\nemaLength         = input.int(1000, \"EMA Length\")\r\nrsiLength         = input.int(14,   \"RSI Length\")\r\nstochLength       = input.int(14,   \"Stoch Length\")\r\nstochD            = input.int(3,    \"Stoch D\")\r\ncciLength         = input.int(14,   \"CCI Length\")\r\nmfiLength         = input.int(14,   \"MFI Length\")\r\nvolSmaLength      = input.int(20,   \"Vol SMA Length\")\r\nadxLenInput       = input.int(14,   \"ADX / DI Length\")\r\n\r\n// =====================================================\r\n// OPENING RANGE: MINUTES Ð˜Ð›Ð˜ Ð’Ð Ð•ÐœÐ•ÐÐÐžÐ™ Ð˜ÐÐ¢Ð•Ð Ð’ÐÐ›\r\n// =====================================================\r\n\r\n// ÐÐ¾Ð²Ñ‹Ð¹ Ð´ÐµÐ½ÑŒ Ð¿Ð¾ daily-Ñ‚Ð°Ð¹Ð¼ÑÑ‚Ð°Ð¼Ð¿Ñƒ\r\nnewDay = ta.change(time(\"D\")) != 0\r\n\r\n// ---------- Ð’ÐÐ Ð˜ÐÐÐ¢ 1: OpeningRangeMinutes Ð¾Ñ‚ Ð¾Ñ‚ÐºÑ€Ñ‹Ñ‚Ð¸Ñ Ð´Ð½Ñ ----------\r\nvar int barsFromOpen = na\r\nif newDay\r\n    barsFromOpen := 0\r\nelse\r\n    barsFromOpen := na(barsFromOpen) ? na : barsFromOpen + 1\r\n\r\ntfSec  = timeframe.in_seconds()\r\norBars = math.max(1, math.round(openingRangeMin * 60.0 / tfSec))\r\n\r\nisOR_min      = not useSessionOR and not na(barsFromOpen) and barsFromOpen <  orBars\r\nisAfterOR_min = not useSessionOR and not na(barsFromOpen) and barsFromOpen >= orBars\r\n\r\n// ---------- Ð’ÐÐ Ð˜ÐÐÐ¢ 2: Opening Range Time Period + Timezone ----------\r\nsessTime   = time(timeframe.period, orSession, orTimezone)\r\ninSessRaw  = not na(sessTime)\r\n\r\norStart_sess = useSessionOR and inSessRaw and not inSessRaw[1]\r\norEnd_sess   = useSessionOR and not inSessRaw and inSessRaw[1]\r\n\r\nvar bool inSess      = false\r\nvar bool afterSess   = false\r\n\r\nif newDay\r\n    inSess    := false\r\n    afterSess := false\r\nelse\r\n    if orStart_sess\r\n        inSess    := true\r\n        afterSess := false\r\n    else if orEnd_sess\r\n        inSess    := false\r\n        afterSess := true\r\n\r\nisOR_sess      = useSessionOR and inSess\r\nisAfterOR_sess = useSessionOR and afterSess\r\n\r\n// ---------- Ð˜Ð¢ÐžÐ“ÐžÐ’Ð«Ð• Ð¤Ð›ÐÐ“Ð˜ OR ----------\r\nisOpeningRange      = useSessionOR ? isOR_sess      : isOR_min\r\nisAfterOpeningRange = useSessionOR ? isAfterOR_sess : isAfterOR_min\r\n\r\n// =====================================================\r\n// OR HIGH / LOW\r\n// =====================================================\r\nvar float orHigh = na\r\nvar float orLow  = na\r\n\r\nif useSessionOR\r\n    if newDay\r\n        orHigh := na\r\n        orLow  := na\r\n    else if orStart_sess\r\n        orHigh := high\r\n        orLow  := low\r\n    else if isOpeningRange\r\n        orHigh := na(orHigh) ? high : math.max(orHigh, high)\r\n        orLow  := na(orLow)  ? low  : math.min(orLow,  low)\r\nelse\r\n    if newDay\r\n        orHigh := high\r\n        orLow  := low\r\n    else if isOpeningRange\r\n        orHigh := math.max(orHigh, high)\r\n        orLow  := math.min(orLow,  low)\r\n\r\n// =====================================================\r\n// OR LINES & TARGETS\r\n// =====================================================\r\norHighPlot = plot(isAfterOpeningRange ? orHigh : na, title=\"OR High\", color=color.yellow)\r\norLowPlot  = plot(isAfterOpeningRange ? orLow  : na, title=\"OR Low\",  color=color.yellow)\r\n\r\npct      = trendPercent * 0.01\r\ntargetUp = orHigh * (1 + pct)\r\ntargetDn = orLow  * (1 - pct)\r\n\r\nplot(isAfterOpeningRange ? targetUp : na, title=\"Target Up\", color=color.lime)\r\nplot(isAfterOpeningRange ? targetDn : na, title=\"Target Dn\", color=color.fuchsia)\r\n\r\n// Ð—Ð°Ð»Ð¸Ð²ÐºÐ° OR Ð¿Ñ€Ð¸ Ñ„Ð¾Ñ€Ð¼Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ð¸\r\norTop = showRangeBox and isOpeningRange ? high : na\r\norBot = showRangeBox and isOpeningRange ? low  : na\r\npTop  = plot(orTop, title=\"OR Top\", display=display.none)\r\npBot  = plot(orBot, title=\"OR Bot\", display=display.none)\r\nfill(pTop, pBot, color=color.new(color.gray, 80))\r\n\r\n// =====================================================\r\n// ÐšÐÐ¡Ð¢ÐžÐœÐÐ«Ð™ ADX / DMI\r\n// =====================================================\r\ndirmov(len) =>\r\n    up      = ta.change(high)\r\n    down    = -ta.change(low)\r\n    plusDM  = na(up)   ? na : (up   > down and up   > 0 ? up   : 0)\r\n    minusDM = na(down) ? na : (down > up   and down > 0 ? down : 0)\r\n    trur    = ta.rma(ta.tr(true), len)\r\n    plus    = fixnan(100 * ta.rma(plusDM,  len) / trur)\r\n    minus   = fixnan(100 * ta.rma(minusDM, len) / trur)\r\n    [plus, minus]\r\n\r\nadxCalc(lenDI, lenADX) =>\r\n    [plus, minus] = dirmov(lenDI)\r\n    sum = plus + minus\r\n    adx = 100 * ta.rma(math.abs(plus - minus) / (sum == 0 ? 1 : sum), lenADX)\r\n    [adx, plus, minus]\r\n\r\n[adxVal, diPlus, diMinus] = adxCalc(adxLenInput, adxLenInput)\r\nbullishDMI = diPlus > diMinus\r\n\r\n// =====================================================\r\n// BIAS & MOMENTUM\r\n// =====================================================\r\nsma100   = ta.sma(close, smaLength)\r\nema1000  = ta.ema(close, emaLength)\r\nvwapDay  = ta.vwap(hlc3)\r\n\r\npriceAboveAll = close > sma100 and close > ema1000 and close > vwapDay\r\npriceBelowAll = close < sma100 and close < ema1000 and close < vwapDay\r\n\r\nrsiVal = ta.rsi(close, rsiLength)\r\n\r\nkRaw       = ta.stoch(high, low, close, stochLength)\r\nstochFullK = ta.sma(kRaw, stochD)\r\n\r\ncciVal = ta.cci(hlc3, cciLength)\r\nmfiVal = ta.mfi(hlc3, mfiLength)\r\n\r\ndeltaVol       = close > close[1] ? volume : close < close[1] ? -volume : 0.0\r\ncumDelta       = ta.cum(deltaVol)\r\ncumDeltaRising = cumDelta > cumDelta[1]\r\n\r\n// Momentum score (Ð±ÐµÐ· VWMO)\r\npriceScore = priceAboveAll ? 50 : priceBelowAll ? 0 : 25\r\nrsiScore   = rsiVal > 50 ? 15 : 5\r\nadxScore   = adxVal > 40 ? 20 : adxVal > 25 ? 10 : 0\r\nstochScore = stochFullK > 50 ? 12 : 4\r\ncciScore   = cciVal > 0 ? 12 : 4\r\nmfiScore   = mfiVal > 50 ? 10 : 3\r\ncumScore   = cumDeltaRising ? 15 : 8\r\n\r\nmomentumScore = priceScore + rsiScore + adxScore + stochScore + cciScore + mfiScore + cumScore\r\nstrongTrend   = adxVal > minAdx\r\n\r\nmarketBias =\r\n     momentumScore > 155 ? 5 :\r\n     momentumScore > 115 ? 4 :\r\n     momentumScore < 45  ? 1 :\r\n     momentumScore < 75  ? 2 : 3\r\n\r\n// =====================================================\r\n// ENTRY LOGIC\r\n// =====================================================\r\nvolSma     = ta.sma(volume, volSmaLength)\r\nhighVolume = volume > volSma * 1.5\r\n\r\nbullCandle = close > open\r\nbearCandle = close < open\r\n\r\nlongBreakout  = isAfterOpeningRange and not na(orHigh) and close[1] <= orHigh and close > orHigh and highVolume and bullCandle\r\nshortBreakout = isAfterOpeningRange and not na(orLow)  and close[1] >= orLow  and close < orLow  and highVolume and bearCandle\r\n\r\nlongBias  = marketBias >= 3 and momentumScore >= minMomentumLong  and strongTrend and bullishDMI\r\nshortBias = marketBias <= 3 and momentumScore <= maxMomentumShort and strongTrend and not bullishDMI\r\n\r\nlongEntry  = longBreakout  and longBias\r\nshortEntry = shortBreakout and shortBias\r\n\r\n// =====================================================\r\n// EXIT LOGIC (1% + ATR STOP)\r\n// =====================================================\r\natrVal = ta.atr(atrLength)\r\n\r\nlongTargetHit  = isAfterOpeningRange and high >= targetUp\r\nshortTargetHit = isAfterOpeningRange and low  <= targetDn\r\n\r\nlongStopHit  = isAfterOpeningRange and low  <= orLow  - atrVal * atrMultStop\r\nshortStopHit = isAfterOpeningRange and high >= orHigh + atrVal * atrMultStop\r\n\r\nlongExit  = longTargetHit  or longStopHit\r\nshortExit = shortTargetHit or shortStopHit\r\n\r\n// =====================================================\r\n// Ð¡Ð˜Ð“ÐÐÐ›Ð«\r\n// =====================================================\r\nplotshape(showSignals and longEntry,  title=\"Long Signal\",  style=shape.triangleup,   color=color.lime,  size=size.small, location=location.belowbar)\r\nplotshape(showSignals and shortEntry, title=\"Short Signal\", style=shape.triangledown, color=color.red,   size=size.small, location=location.abovebar)\r\n\r\n// =====================================================\r\n// ORDERS (1 ÐºÐ¾Ð½Ñ‚Ñ€Ð°ÐºÑ‚)\r\n// =====================================================\r\nif longEntry\r\n    strategy.entry(\"ORB Long\", strategy.long)\r\n\r\nif longExit\r\n    strategy.close(\"ORB Long\")\r\n\r\nif shortEntry\r\n    strategy.entry(\"ORB Short\", strategy.short)\r\n\r\nif shortExit\r\n    strategy.close(\"ORB Short\")\r\n"
  },
  {
    "url": "9JyXE791-ATR-Trend-RSI-Pullback-Strategy-Profit-Focused",
    "name": "ATR Trend + RSI Pullback Strategy [Profit-Focused]",
    "description": "This strategy is designed to catch high-probability pullbacks during strong trends using a combination of ATR-based volatility filters, RSI exhaustion levels, and a trend-following entry model.\n\n Strategy Logic \n\nRather than relying on lagging crossovers, this model waits for RSI to dip into oversold zones (below 40) while price remains above a long-term EMA (default: 200). This setup captures pullbacks in strong uptrends, allowing traders to enter early in a move while controlling risk dynamically.\n\nTo avoid entries during low-volatility conditions or sideways price action, it applies a minimum ATR filter. The ATR also defines both the stop-loss and take-profit levels, allowing the model to adapt to changing market conditions.\n\nExit logic includes:\n\n \n A take-profit at 3Ã— the ATR distance\n A stop-loss at 1.5Ã— the ATR distance\n An optional early exit if RSI crosses above 70, signaling overbought conditions\n \n\n Technical Details \n\n \n Trend Filter: 200 EMA â€“ must be rising and price must be above it\n Entry Signal: RSI dips below 40 during an uptrend\n Volatility Filter: ATR must be above a user-defined minimum threshold\n Stop-Loss: 1.5Ã— ATR below entry price\n Take-Profit: 3.0Ã— ATR above entry price\n Exit on Overbought: RSI > 70 (optional early exit)\n \n\n Backtest Settings \n\n \n Initial Capital: $10,000\n Position Sizing: 5% of equity per trade\n Slippage: 1 tick\n Commission: 0.075% per trade\n Trade Direction: Long only\n Timeframes Tested: 15m, 1H, and 30m on trending assets like BTCUSD, NAS100, ETHUSD\n \n\nThis model is tuned for positive P&L across trending environments and volatile markets.\n\n Educational Use Only \nThis strategy is for educational purposes only and should not be considered financial advice. Past performance does not guarantee future results. Always validate performance on multiple markets and timeframes before using it in live trading.",
    "image_url": "9JyXE791",
    "author": "AIScripts",
    "likes": 188,
    "type": "strategy",
    "created": "2025-11-17",
    "updated": "2025-11-17",
    "source": "//@version=5\nstrategy(\"ATR Trend + RSI Pullback Strategy [Profit-Focused]\", overlay=true, default_qty_type=strategy.percent_of_equity, default_qty_value=5, initial_capital=10000, commission_type=strategy.commission.percent, commission_value=0.075, slippage=1)\n\n// === Inputs ===\natrLen         = input.int(14, title=\"ATR Period\")\nstopMult       = input.float(1.5, title=\"Stop Multiplier\")\ntpMult         = input.float(3.0, title=\"Take-Profit Multiplier\")\nrsiLen         = input.int(14, title=\"RSI Period\")\nrsiEntry       = input.int(40, title=\"RSI Pullback Level\")\ntrendLen       = input.int(200, title=\"Trend EMA Length\")\nminAtr         = input.float(0.5, title=\"Min ATR (Volatility Filter)\")\n\n// === Indicators ===\natr = ta.atr(atrLen)\nemaTrend = ta.ema(close, trendLen)\nrsi = ta.rsi(close, rsiLen)\npriceAboveTrend = close > emaTrend\nrsiPullback = rsi < rsiEntry\nvolOk = atr > minAtr\n\n// === Entry Condition ===\nlongCondition = priceAboveTrend and rsiPullback and volOk\nvar float lastEntryBar = na\ncanEnter = na(lastEntryBar) or (bar_index - lastEntryBar > 20)\n\nif (longCondition and canEnter)\n    strategy.entry(\"Long\", strategy.long)\n    lastEntryBar := bar_index\n\n// === Exit Logic ===\nstopLevel = close - stopMult * atr\ntakeLevel = close + tpMult * atr\nstrategy.exit(\"TP/SL Exit\", from_entry=\"Long\", stop=stopLevel, limit=takeLevel)\n\n// === Optional Exit on RSI Overbought\nexitRSI = ta.rsi(close, rsiLen) > 70\nif exitRSI\n    strategy.close(\"Long\", comment=\"RSI Exit\")\n\n// === Plotting ===\nplotshape(longCondition, title=\"Buy\", location=location.belowbar, color=color.green, style=shape.triangleup, size=size.small)\nplotshape(exitRSI, title=\"RSI Exit\", location=location.abovebar, color=color.red, style=shape.triangledown, size=size.tiny)\n"
  },
  {
    "url": "XqFimuXl-RSI-BREAKOUT-SIGNALS",
    "name": "RSI BREAKOUT SIGNALS",
    "description": "This BB + RSI Breakout indicator is designed to help traders identify potential buy and sell opportunities based on price movements relative to the Donchian channel (or Bollinger-type channel) and momentum conditions. It calculates the highest high and lowest low over a user-defined length to form a dynamic channel, and then it checks whether the current price breaks above the upper band (for a buy signal) or below the lower band (for a sell signal). To avoid repeated signals in a row, the indicator uses a state system: after a buy signal occurs, it will not generate another buy until a sell occurs, and vice versa. When a buy signal is triggered, it automatically calculates a take-profit price a certain percentage above the buy candle and displays this price below the candle as a â€œTPâ€ label. Sell signals are displayed above the candle, and any previous TP label is cleared. The indicator updates in real time, so the signals move with the chart, giving a clear and lag-free visualization of entry points and potential profit targets.",
    "image_url": "XqFimuXl",
    "author": "gabrielcoracinidesouza07",
    "likes": 405,
    "type": "strategy",
    "created": "2025-11-17",
    "updated": "2025-11-17",
    "source": "//@version=5\r\nstrategy(\"BB + RSI Breakout Strategy (3% TP, No SL)\", overlay=true, initial_capital=1000)\r\n\r\n// â€”â€”â€”â€”â€” Inputs â€”â€”â€”â€”â€”\r\nbbLength = input.int(30, \"BB Length\")\r\nbbMult   = input.float(2.0, \"BB Multiplier\")\r\nrsiLen   = input.int(13, \"RSI Length\")\r\nrsiOB    = input.int(70, \"RSI Overbought Level\")\r\nrsiOS    = input.int(30, \"RSI Oversold Level\")\r\n\r\ntakeProfitPercent = input.float(3.0, \"Take Profit %\")\r\n\r\n// â€”â€”â€”â€”â€” Bollinger Bands â€”â€”â€”â€”â€”\r\nbasis = ta.sma(close, bbLength)\r\ndev = bbMult * ta.stdev(close, bbLength)\r\nupper = basis + dev\r\nlower = basis - dev\r\n\r\nplot(basis, \"BB Basis\", color=color.blue)\r\nplot(upper, \"BB Upper\", color=color.red)\r\nplot(lower, \"BB Lower\", color=color.green)\r\n\r\n// â€”â€”â€”â€”â€” RSI â€”â€”â€”â€”â€”\r\nrsi = ta.rsi(close, rsiLen)\r\n\r\n// â€”â€”â€”â€”â€” Buy & Sell Conditions â€”â€”â€”â€”â€”\r\nbuySignal  = close < lower and rsi < rsiOS\r\nsellSignal = close > upper and rsi > rsiOB\r\n\r\n// â€”â€”â€”â€”â€” Entries â€”â€”â€”â€”â€”\r\nif (buySignal)\r\n    strategy.entry(\"BUY\", strategy.long)\r\n\r\nif (sellSignal)\r\n    strategy.entry(\"SELL\", strategy.short)\r\n\r\n// â€”â€”â€”â€”â€” 3% Take Profit (NO STOP LOSS) â€”â€”â€”â€”â€”\r\ntpLong  = strategy.position_avg_price * (1 + takeProfitPercent / 100)\r\ntpShort = strategy.position_avg_price * (1 - takeProfitPercent / 100)\r\n\r\nstrategy.exit(\"TP Long\",  from_entry=\"BUY\",  limit=tpLong)\r\nstrategy.exit(\"TP Short\", from_entry=\"SELL\", limit=tpShort)  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"
  },
  {
    "url": "3oRCg8s3-BTC-EMA-5-9-Flip-Strategy-Autobot",
    "name": "BTC EMA 5-9 Flip Strategy Autobot",
    "description": "This strategy is designed for fast and accurate trend-following trades on Bitcoin.\nIt uses a crossover between EMA 5 and EMA 9 to detect instant trend reversals and automatically flips between Long and Short positions.\n\nHow the strategy works\n\nEMA 5 crossing above EMA 9 â†’ Long\n\nEMA 5 crossing below EMA 9 â†’ Short\n\nAutomatically closes the opposite trade during a flip\n\nExecutes trades only on candle close\n\nPrevents double entries with internal position-state logic\n\nFully compatible with automated trading via webhooks (Delta Exchange)\n\nWhy this strategy works\n\nEMA 5â€“9 is extremely responsive for BTCâ€™s volatility\n\nCaptures trend reversals early\n\nWorks best on 15-minute timeframe\n\nClean, simple logic without over-filtering reduces missed opportunities\n\nPerforms well in both uptrends and downtrends\n\nAutomation Ready\n\nThis strategy includes alert conditions and webhook-ready JSON for automated execution.\n\nThis is a fast-reacting BTC bot designed for intraday and swing crypto trend trading.",
    "image_url": "3oRCg8s3",
    "author": "kulkarniabhishek38",
    "likes": 18,
    "type": "strategy",
    "created": "2025-11-17",
    "updated": "2025-11-17",
    "source": "//@version=5\nstrategy(\"SAFE PUBLIC â€“ BTC EMA 5/9 Trend Strategy (Delta Ready)\",\n     overlay=true,\n     calc_on_every_tick=false,\n     process_orders_on_close=true,\n     initial_capital=100000,\n     default_qty_type=strategy.fixed,\n     default_qty_value=20)  // always fixed lots, never increases automatically\n\n// ===== INPUTS =====\norderQty = input.int(20, \"Order Quantity (Lots)\") // safe fixed quantity\nuseATR   = input.bool(true, \"Use ATR Volatility Filter\")\nuseST    = input.bool(true, \"Use Supertrend Filter\")\nuseHTF   = input.bool(true, \"Use Higher Timeframe Trend Filter\")\n\n// ===== BASE EMAs =====\nfastEMA = ta.ema(close, 5)\nslowEMA = ta.ema(close, 9)\nema20   = ta.ema(close, 20)\nema50   = ta.ema(close, 50)\n\nplot(fastEMA, color=color.new(color.green, 0), title=\"EMA 5\")\nplot(slowEMA, color=color.new(color.red,   0), title=\"EMA 9\")\nplot(ema20,  color=color.yellow, title=\"EMA 20\")\nplot(ema50,  color=color.blue,   title=\"EMA 50\")\n\n// ===== HIGHER TIMEFRAME TREND (1 HOUR) =====\nhtfEMA20 = request.security(syminfo.tickerid, \"60\", ta.ema(close, 20))\nhtfEMA50 = request.security(syminfo.tickerid, \"60\", ta.ema(close, 50))\nhtfUp    = htfEMA20 > htfEMA50\nhtfDown  = htfEMA20 < htfEMA50\n\n// ===== SUPERTREND FILTER =====\n[stLine, stDir] = ta.supertrend(3, 10)\nstBuy  = stDir == 1\nstSell = stDir == -1\n\n// ===== ATR VOLATILITY FILTER =====\natr = ta.atr(14)\natrPerc = (atr / close) * 100\natrOK = atrPerc > 0.30   // safe threshold: avoid low volatility days\n\n// ===== TREND CONDITIONS =====\nupTrend   = ema20 > ema50\ndownTrend = ema20 < ema50\n\n// ===== SIGNALS =====\nbullCross = ta.crossover(fastEMA, slowEMA) and barstate.isconfirmed\nbearCross = ta.crossunder(fastEMA, slowEMA) and barstate.isconfirmed\n\n// ===== FINAL SAFE ENTRY CONDITIONS =====\nbuyAllowed  = upTrend and htfUp and stBuy and atrOK\nsellAllowed = downTrend and htfDown and stSell and atrOK\n\n// ===== SAFE ENTRY / EXIT LOGIC =====\n\n// BUY LOGIC\nif bullCross\n    // Always close old trade first\n    if strategy.position_size < 0\n        strategy.close(\"Short\")\n    // Enter long only if all filters pass\n    if buyAllowed\n        strategy.close_all()\n        strategy.entry(\"Long\", strategy.long, qty=orderQty)\n\n// SELL LOGIC\nif bearCross\n    // Always close old trade first\n    if strategy.position_size > 0\n        strategy.close(\"Long\")\n    // Enter short only if all filters pass\n    if sellAllowed\n        strategy.close_all()\n        strategy.entry(\"Short\", strategy.short, qty=orderQty)\n\n// ===== ALERTS =====\nalertcondition(bullCross and buyAllowed, \"BUY\", \"BUY\")\nalertcondition(bearCross and sellAllowed, \"SELL\", \"SELL\")\n"
  },
  {
    "url": "nAFtM2lb-BB-RSI-Breakout-Strategy",
    "name": "BB + RSI Breakout Strategy ",
    "description": "RSI PLUS BB Really good strategy with a tp of 3% win rate is 95\n",
    "image_url": "nAFtM2lb",
    "author": "gabrielcoracinidesouza07",
    "likes": 235,
    "type": "strategy",
    "created": "2025-11-16",
    "updated": "2025-11-16",
    "source": "//@version=5\nstrategy(\"BB + RSI Breakout Strategy (3% TP, No SL)\", overlay=true, initial_capital=1000)\n\n// â€”â€”â€”â€”â€” Inputs â€”â€”â€”â€”â€”\nbbLength = input.int(30, \"BB Length\")\nbbMult   = input.float(2.0, \"BB Multiplier\")\nrsiLen   = input.int(13, \"RSI Length\")\nrsiOB    = input.int(70, \"RSI Overbought Level\")\nrsiOS    = input.int(30, \"RSI Oversold Level\")\n\ntakeProfitPercent = input.float(3.0, \"Take Profit %\")\n\n// â€”â€”â€”â€”â€” Bollinger Bands â€”â€”â€”â€”â€”\nbasis = ta.sma(close, bbLength)\ndev = bbMult * ta.stdev(close, bbLength)\nupper = basis + dev\nlower = basis - dev\n\nplot(basis, \"BB Basis\", color=color.blue)\nplot(upper, \"BB Upper\", color=color.red)\nplot(lower, \"BB Lower\", color=color.green)\n\n// â€”â€”â€”â€”â€” RSI â€”â€”â€”â€”â€”\nrsi = ta.rsi(close, rsiLen)\n\n// â€”â€”â€”â€”â€” Buy & Sell Conditions â€”â€”â€”â€”â€”\nbuySignal  = close < lower and rsi < rsiOS\nsellSignal = close > upper and rsi > rsiOB\n\n// â€”â€”â€”â€”â€” Entries â€”â€”â€”â€”â€”\nif (buySignal)\n    strategy.entry(\"BUY\", strategy.long)\n\nif (sellSignal)\n    strategy.entry(\"SELL\", strategy.short)\n\n// â€”â€”â€”â€”â€” 3% Take Profit (NO STOP LOSS) â€”â€”â€”â€”â€”\ntpLong  = strategy.position_avg_price * (1 + takeProfitPercent / 100)\ntpShort = strategy.position_avg_price * (1 - takeProfitPercent / 100)\n\nstrategy.exit(\"TP Long\",  from_entry=\"BUY\",  limit=tpLong)\nstrategy.exit(\"TP Short\", from_entry=\"SELL\", limit=tpShort)\n\n\n\n\n"
  },
  {
    "url": "J1U1NNgx-SP500-Session-Gap-Fade-Strategy",
    "name": "SP500 Session Gap Fade Strategy",
    "description": "Summary in one paragraph\n SPX Session Gap Fade is an intraday gap fade strategy for index futures, designed around regular cash sessions on five minute charts. It helps you participate only when there is a full overnight or pre session gap and a valid intraday session window, instead of trading every open. The original part is the gap distance engine which anchors both stop and optional target to the previous session reference close at a configurable flat time, so every tradeâ€™s risk scales with the actual gap size rather than a fixed tick stop. \n\n Scope and intent \nâ€¢ Markets. Primarily index futures such as ES, NQ, YM, and liquid index CFDs that exhibit overnight gaps and regular cash hours.\nâ€¢ Timeframes. Intraday timeframes from one minute to fifteen minutes. Default usage is five minute bars.\nâ€¢ Default demo used in the publication. Symbol CME:ES1! on a five minute chart.\nâ€¢ Purpose. Provide a simple, transparent way to trade opening gaps with a session anchored risk model and forced flat exit so you are not holding into the last part of the session.\nâ€¢ Limits. This is a strategy. Orders are simulated on standard candles only.\n\n Originality and usefulness \nâ€¢ Unique concept or fusion. The core novelty is the combination of a strict â€œfull gapâ€ entry condition with a session anchored reference close and a gap distance based TP and SL engine. The stop and optional target are symmetric multiples of the actual gap distance from the previous sessionâ€™s flat close, rather than fixed ticks.\nâ€¢ Failure mode it addresses. Fixed sized stops do not scale when gaps are unusually small or unusually large, which can either under risk or over risk the account. The session flat logic also reduces the chance of holding residual positions into late session liquidity and news.\nâ€¢ Testability. All key pieces are explicit in the Inputs: session window, minutes before session end, whether to use gap exits, whether TP or SL are active, and whether to allow candle based closes and forced flat. You can toggle each component and see how it changes entries and exits.\nâ€¢ Portable yardstick. The main unit is the absolute price gap between the entry bar open and the previous session reference close. tp_mult and sl_mult are multiples of that gap, which makes the risk model portable across contracts and volatility regimes.\n\n\n Method overview in plain language \nThe strategy first defines a trading session using exchange time, for example 08:30 to 15:30 for ES day hours. It also defines a â€œflatâ€ time a fixed number of minutes before session end. At the flat bar, any open position is closed and the barâ€™s close price is stored as the reference close for the next session. Inside the session, the strategy looks for a full gap bar relative to the prior bar: a gap down where todayâ€™s high is below yesterdayâ€™s low, or a gap up where todayâ€™s low is above yesterdayâ€™s high. A full gap down generates a long entry; a full gap up generates a short entry. If the gap risk engine is enabled and a valid reference close exists, the strategy measures the distance between the entry bar open and that reference close. It then sets a stop and optional target as configurable multiples of that gap distance and manages them with strategy.exit. Additional exits can be triggered by a candle color flip or by the forced flat time.\n\n Base measures \nâ€¢ Range basis. The main unit is the absolute difference between the current entry bar open and the stored reference close from the previous session flat bar. That value is used as a â€œgap unitâ€ and scaled by tp_mult and sl_mult to build the target and stop.\n\n Components \nâ€¢ Component one: Gap Direction. Detects full gap up or full gap down by comparing the current high and low to the previous barâ€™s high and low. Gap down signals a long fade, gap up signals a short fade. There is no smoothing; it is a strict structural condition.\nâ€¢ Component two: Session Window. Only allows entries when the current time is within the configured session window. It also defines a flat time before the session end where positions are forced flat and the reference close is updated.\nâ€¢ Component three: Gap Distance Risk Engine. Computes the absolute distance between the entry open and the stored reference close. The stop and optional target are placed as entry Â± gap_distance Ã— multiplier so that risk scales with gap size.\nâ€¢ Optional component: Candle Exit. If enabled, a bullish bar closes short positions and a bearish bar closes long positions, which can shorten holding time when price reverses quickly inside the session.\nâ€¢ Session windows. Session logic uses the exchange time of the chart symbol. When changing symbols or venues, verify that the session time string still matches the new instrumentâ€™s cash hours.\n\n Fusion rule \nAll gates are hard conditions rather than weighted scores. A trade can only open if the session window is active and the full gap condition is true. The gap distance engine only activates if a valid reference close exists and use_gap_risk is on. TP and SL are controlled by separate booleans so you can use SL only, TP only, or both. Long and short are symmetric by construction: long trades fade full gap downs, short trades fade full gap ups with mirrored TP and SL logic.\n\n Signal rule\n â€¢ Long entry. Inside the active session, when the current bar shows a full gap down relative to the previous bar (current high below prior low), the strategy opens a long position. If the gap risk engine is active, it places a gap based stop below the entry and an optional target above it.\nâ€¢ Short entry. Inside the active session, when the current bar shows a full gap up relative to the previous bar (current low above prior high), the strategy opens a short position. If the gap risk engine is active, it places a gap based stop above the entry and an optional target below it.\nâ€¢ Forced flat. At the configured flat time before session end, any open position is closed and the close price of that bar becomes the new reference close for the following session.\nâ€¢ Candle based exit. If enabled, a bearish bar closes longs, and a bullish bar closes shorts, regardless of where TP or SL sit, as long as a position is open.\n\n What you will see on the chart \nâ€¢ Markers on entry bars. Standard strategy entry markers labeled â€œlongâ€ and â€œshortâ€ on the gap bars where trades open.\nâ€¢ Exit markers. Standard exit markers on bars where either the gap stop or target are hit, or where a candle exit or forced flat close occurs. Exit IDs â€œlong_gapâ€ and â€œshort_gapâ€ label gap based exits.\nâ€¢ Reference levels. Horizontal lines for the current long TP, long SL, short TP, and short SL while a position is open and the gap engine is enabled. They update when a new trade opens and disappear when flat.\nâ€¢ Session background. This version does not add background shading for the session; session logic runs internally based on time.\nâ€¢ No on chart table. All decisions are visible through orders and exit levels. Use the Strategy Tester for performance metrics.\n\n\n Inputs with guidance\n \nSession Settings\nâ€¢ Trading session (sess). Session window in exchange time. Typical value uses the regular cash session for each contract, for example â€œ0830-1530â€ for ES. Adjust if your broker or symbol uses different hours.\nâ€¢ Minutes before session end to force exit (flat_before_min). Minutes before the session end where positions are forced flat and the reference close is stored. Typical range is 15 to 120. Raising it closes trades earlier in the day; lowering it allows trades later in the session.\n\nGap Risk\nâ€¢ Enable gap based TP/SL (use_gap_risk). Master switch for the gap distance exit engine. Turning it off keeps entries and forced flat logic but removes automatic TP and SL placement.\nâ€¢ Use TP limit from gap (use_gap_tp). Enables gap based profit targets. Typical values are true for structured exits or false if you want to manage exits manually and only keep a stop.\nâ€¢ Use SL stop from gap (use_gap_sl). Enables gap based stop losses. This should normally remain true so that each trade has a defined initial risk in ticks.\nâ€¢ TP multiplier of gap distance (tp_mult). Multiplier applied to the gap distance for the target. Typical range is 0.5 to 2.0. Raising it places the target further away and reduces hit frequency.\nâ€¢ SL multiplier of gap distance (sl_mult). Multiplier applied to the gap distance for the stop. Typical range is 0.5 to 2.0. Raising it widens the stop and increases risk per trade; lowering it tightens the stop and may increase the number of small losses.\n\nExit Controls\nâ€¢ Exit with candle logic (use_candle_exit). If true, closes shorts on bullish candles and longs on bearish candles. Useful when you want to react to intraday reversal bars even if TP or SL have not been reached.\nâ€¢ Force flat before session end (use_forced_flat). If true, guarantees you are flat by the configured flat time and updates the reference close. Turn this off only if you understand the impact on overnight risk.\n\nFilters\nThere is no separate trend or volatility filter in this version. All trades depend on the presence of a full gap bar inside the session. If you need extra filtering such as ATR, volume, or higher timeframe bias, they should be added explicitly and documented in your own fork.\n\n\n Usage recipes\n \nIntraday conservative gap fade\nâ€¢ Timeframe. Five minute chart on ES regular session.\nâ€¢ Gap risk. use_gap_risk = true, use_gap_tp = true, use_gap_sl = true.\nâ€¢ Multipliers. tp_mult around 0.7 to 1.0 and sl_mult around 1.0.\nâ€¢ Exits. use_candle_exit = false, use_forced_flat = true. Focus on the structured TP and SL around the gap.\n\nIntraday aggressive gap fade\nâ€¢ Timeframe. Five minute chart.\nâ€¢ Gap risk. use_gap_risk = true, use_gap_tp = false, use_gap_sl = true.\nâ€¢ Multipliers. sl_mult around 0.7 to 1.0.\nâ€¢ Exits. use_candle_exit = true, use_forced_flat = true. Entries fade full gaps, stops are tight, and candle color flips flatten trades early.\n\nHigher timeframe gap tests\nâ€¢ Timeframe. Fifteen minute or sixty minute charts on instruments with regular gaps.\nâ€¢ Gap risk. Keep use_gap_risk = true. Consider slightly higher sl_mult if gaps are structurally wider on the higher timeframe.\nâ€¢ Note. Expect fewer trades and be careful with sample size; multi year data is recommended.\n\n\n\nProperties visible in this publication\nâ€¢ On average our risk for each position over the last 200 trades is 0.4% with a max intraday loss of 1.5% of the total equity in this case of 100k $ with 1 contract ES. For other assets, recalculations and customizations has to be applied.\nâ€¢ Initial capital. 100 000.\nâ€¢ Base currency. USD.\nâ€¢ Default order size method. Fixed with size 1 contract.\nâ€¢ Pyramiding. 0.\nâ€¢ Commission. Flat 2 USD per order in the Strategy Tester Properties. (2$ buying +  2$selling)\nâ€¢ Slippage. One tick in the Strategy Tester Properties.\nâ€¢ Process orders on close. ON.\n\n\n Realism and responsible publication\n â€¢ No performance claims are made. Past results do not guarantee future outcomes.\nâ€¢ Costs use a realistic flat commission and one tick of slippage per trade for ES class futures.\nâ€¢ Default sizing with one contract on a 100 000 reference account targets modest per trade risk. In practice, extreme slippage or gap through events can exceed this, so treat the one and a half percent risk target as a design goal, not a guarantee.\nâ€¢ All orders are simulated on standard candles. Shapes can move while a bar is forming and settle on bar close.\n\n Honest limitations and failure modes\n â€¢ Economic releases, thin liquidity, and limit conditions can break the assumptions behind the simple gap model and lead to slippage or skipped fills.\nâ€¢ Symbols with very frequent or very large gaps may require adjusted multipliers or alternative risk handling, especially in high volatility regimes.\nâ€¢ Very quiet periods without clean gaps will produce few or no trades. This is expected behavior, not a bug.\nâ€¢ Session windows follow the exchange time of the chart. Always confirm that the configured session matches the symbol.\nâ€¢ When both the stop and target lie inside the same barâ€™s range, the TradingView engine decides which is hit first based on its internal intrabar assumptions. Without bar magnifier, tie handling is approximate.\n\n\n Legal \nEducation and research only. This strategy is not investment advice. You remain responsible for all trading decisions. Always test on historical data and in simulation with realistic costs before considering any live use.\n\n",
    "image_url": "J1U1NNgx",
    "author": "exlux",
    "likes": 57,
    "type": "strategy",
    "created": "2025-11-16",
    "updated": "2025-11-16",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// Â© exlux\r\n//@version=6\r\nstrategy(     \"SP500 Session Gap Fade Strategy\",     shorttitle = \"SPX Gap Fade\",     overlay = true)\r\n\r\n//================= SESSION SETTINGS =================//\r\ngroup_sess      = \"Session Settings\"\r\nsess            = input.session(\"0830-1530\", \"Trading session (exchange time)\", group = group_sess)\r\nflat_before_min = input.int(60, \"Minutes before session end to force exit\", minval = 1, maxval = 300, group = group_sess)\r\n\r\n// Parse \"HHMM-HHMM\" from sess (kept same logic as original)\r\nint colon_pos   = str.pos(sess, \":\")\r\nstring core     = na(colon_pos) ? sess : str.substring(sess, 0, colon_pos)\r\n\r\nint dash_pos     = str.pos(core, \"-\")\r\nstring start_str = na(dash_pos) ? \"0000\" : str.substring(core, 0, dash_pos)\r\nstring end_str   = na(dash_pos) ? \"2359\" : str.substring(core, dash_pos + 1, str.length(core))\r\n\r\nint start_hour  = int(str.tonumber(str.substring(start_str, 0, 2)))\r\nint start_min   = int(str.tonumber(str.substring(start_str, 2, 4)))\r\nint end_hour    = int(str.tonumber(str.substring(end_str,   0, 2)))\r\nint end_min     = int(str.tonumber(str.substring(end_str,   2, 4)))\r\n\r\nint sess_start_total = start_hour * 60 + start_min\r\nint sess_end_total   = end_hour   * 60 + end_min\r\nint sess_len_total   = sess_end_total - sess_start_total\r\n\r\n// clamp flat_before to session length\r\nint fb_minutes = flat_before_min > sess_len_total ? sess_len_total : flat_before_min\r\nint flat_total = sess_end_total - fb_minutes\r\nint flat_hour  = flat_total / 60\r\nint flat_min   = flat_total % 60\r\n\r\n//================= GAP RISK CONFIG =================//\r\ngroup_risk     = \"Gap Risk\"\r\nuse_gap_risk   = input.bool(true,  \"Enable gap based TP/SL\",  group = group_risk)\r\nuse_gap_tp     = input.bool(false, \"Use TP limit from gap\",   group = group_risk)\r\nuse_gap_sl     = input.bool(true,  \"Use SL stop from gap\",    group = group_risk)\r\ntp_mult        = input.float(1.0, \"TP multiplier of gap distance\",  minval = 0.0, step = 0.1, group = group_risk)\r\nsl_mult        = input.float(1.0, \"SL multiplier of gap distance\",  minval = 0.0, step = 0.1, group = group_risk)\r\n\r\n//================= EXIT BEHAVIOR CONFIG =================//\r\ngroup_exit      = \"Exit Controls\"\r\nuse_candle_exit = input.bool(false, \"Exit with candle logic (strategy.close)\", group = group_exit, tooltip = \"If enabled, long closes on bearish bar and short closes on bullish bar.\")\r\nuse_forced_flat = input.bool(true,  \"Force flat before session end\",           group = group_exit, tooltip = \"Close all positions at flat time and store reference close.\")\r\n\r\n//================= GLOBAL TP/SL SERIES =================//\r\nvar float long_tp_price  = na\r\nvar float long_sl_price  = na\r\nvar float short_tp_price = na\r\nvar float short_sl_price = na\r\n\r\n// previous EOD reference close (at flat time)\r\nvar float prev_eod_close = na\r\n\r\n//================= TIME STATE PER BAR =================//\r\nint cur_hour  = hour(time)\r\nint cur_min   = minute(time)\r\nint cur_total = cur_hour * 60 + cur_min\r\n\r\nbool in_session = cur_total >= sess_start_total and cur_total <= sess_end_total\r\nbool flat_bar   = in_session and cur_hour == flat_hour and cur_min == flat_min\r\n\r\n//================= GAP SIGNALS =================//\r\nbool gap_down_full = high < low[1]\r\nbool gap_up_full   = low  > high[1]\r\nbool bull_bar      = close > open\r\nbool bear_bar      = close < open\r\n\r\nbool long_cond  = in_session and gap_down_full     // and bull_bar\r\nbool short_cond = in_session and gap_up_full       // and bear_bar\r\n\r\n//================= ENTRY + GAP TP/SL (USING prev_eod_close) =================//\r\n// distance = |open - prev_eod_close|, TP and SL symmetric around entry\r\n\r\nif long_cond\r\n    if use_gap_risk and not na(prev_eod_close)\r\n        float gap_dist   = math.abs(open - prev_eod_close)\r\n        if gap_dist > 0\r\n            float entry_open = open\r\n            long_tp_price  := entry_open + gap_dist * tp_mult\r\n            long_sl_price  := entry_open - gap_dist * sl_mult\r\n            short_tp_price := na\r\n            short_sl_price := na\r\n    strategy.entry(\"long\", strategy.long)\r\n\r\nif short_cond\r\n    if use_gap_risk and not na(prev_eod_close)\r\n        float gap_dist   = math.abs(open - prev_eod_close)\r\n        if gap_dist > 0\r\n            float entry_open = open\r\n            short_tp_price := entry_open - gap_dist * tp_mult\r\n            short_sl_price := entry_open + gap_dist * sl_mult\r\n            long_tp_price  := na\r\n            long_sl_price  := na\r\n    strategy.entry(\"short\", strategy.short)\r\n\r\n//================= CANDLE-BASED CLOSE (OPTIONAL) =================//\r\nif use_candle_exit\r\n    if close > open\r\n        strategy.close(\"short\")\r\n    if close < open\r\n        strategy.close(\"long\")\r\n\r\n//================= FORCED FLAT AND EOD REFERENCE CLOSE =================//\r\nif flat_bar and use_forced_flat\r\n    prev_eod_close := close\r\n    strategy.close(\"long\")\r\n    strategy.close(\"short\")\r\n\r\n//================= APPLY TP/SL ORDERS =================//\r\nif use_gap_risk\r\n    bool has_tp = use_gap_tp\r\n    bool has_sl = use_gap_sl\r\n\r\n    // long side\r\n    if strategy.position_size > 0 and not na(long_tp_price) and not na(long_sl_price) and (has_tp or has_sl)\r\n        float tp_long = has_tp ? long_tp_price : na\r\n        float sl_long = has_sl ? long_sl_price : na\r\n        strategy.exit(\"long_gap\", \"long\", stop = sl_long, limit = tp_long)\r\n\r\n    // short side\r\n    if strategy.position_size < 0 and not na(short_tp_price) and not na(short_sl_price) and (has_tp or has_sl)\r\n        float tp_short = has_tp ? short_tp_price : na\r\n        float sl_short = has_sl ? short_sl_price : na\r\n        strategy.exit(\"short_gap\", \"short\", stop = sl_short, limit = tp_short)\r\n\r\n//================= RESET WHEN FLAT =================//\r\nbool flat_now  = strategy.position_size == 0\r\nbool flat_prev = strategy.position_size[1] != 0\r\nif flat_now and flat_prev\r\n    long_tp_price  := na\r\n    long_sl_price  := na\r\n    short_tp_price := na\r\n    short_sl_price := na\r\n\r\n//================= PLOTS (GLOBAL SCOPE) =================//\r\nplot(strategy.position_size > 0 ? long_tp_price  : na, \"Long TP\",  color = color.new(color.lime, 0),  style = plot.style_linebr)\r\nplot(strategy.position_size > 0 ? long_sl_price  : na, \"Long SL\",  color = color.new(color.red,  0),  style = plot.style_linebr)\r\nplot(strategy.position_size < 0 ? short_tp_price : na, \"Short TP\", color = color.new(color.lime, 60), style = plot.style_linebr)\r\nplot(strategy.position_size < 0 ? short_sl_price : na, \"Short SL\", color = color.new(color.red,  60), style = plot.style_linebr)\r\n"
  },
  {
    "url": "wwi02rpz-Moving-Average-Band-Strategy",
    "name": "Moving Average Band Strategy",
    "description": "Overview\n\nThe Moving Average Band Strategy is a fully customizable breakout and trend-continuation system designed for traders who need both simplicity and control.\nThe strategy creates adaptive bands around a user-selected moving average and executes trades when price breaks out of these bands, with advanced risk-management settings including optional Risk:Reward targets.\n\nThis script is suitable for intraday, swing, and positional traders across all markets â€” equities, futures, crypto, and forex.\n\nKey Features\nâœ” Six Moving Average Types\n\nChoose the MA that best matches your trading style:\n\nSMA\n\nEMA\n\nWMA\n\nHMA\n\nVWMA\n\nRMA\n\nâœ” Dynamic Bands\n\nUpper Band built from MA of highs\n\nLower Band built from MA of lows\n\nAdjustable band offset (%)\n\nColor-coded band fill indicating price position\n\nâœ” Configurable Strategy Preferences\n\nToggle Long and/or Short trades\n\nToggle Risk:Reward Take-Profit\n\nAdjustable Risk:Reward Ratio\n\nDefault position sizing: % of equity (configurable via strategy settings)\n\nEntry Conditions\nLong Entry\n\nA long trade triggers when:\n\nPrice crosses above the Upper Band\n\nLong trades are enabled\n\nNo existing long position is active\n\nShort Entry\n\nA short trade triggers when:\n\nPrice crosses below the Lower Band\n\nShort trades are enabled\n\nNo existing short position is active\n\nClear entry markers and price labels appear on the chart.\n\n Risk Management\n\nThis strategy includes a complete set of risk-controls:\n\nStop-Loss (Fixed at Entry)\n\nLong SL: Lower Band\n\nShort SL: Upper Band\n\nThese levels remain constant for the entire trade.\n\nOptional Risk:Reward Take-Profit\n\nEnabled/disabled using a toggle switch.\n\nWhen enabled:\n\nLong TP = Entry + (Risk Ã— Risk:Reward Ratio)\n\nShort TP = Entry â€“ (Risk Ã— Risk:Reward Ratio)\n\nWhen disabled:\n\nExits are handled by reverse crossover signals.\n\nExit Conditions\nLong Exit\n\nStop-Loss Hit (touch-based)\n\nTake-Profit Hit (if enabled)\n\nReverse Band Crossover (if TP disabled)\n\nShort Exit\n\nStop-Loss Hit (touch-based)\n\nTake-Profit Hit (if enabled)\n\nReverse Band Crossover (if TP disabled)\n\nExit markers and price labels are plotted automatically.\n\nVisual Tools\n\nTo improve clarity:\n\nUpper & Lower Band (blue, adjustable width)\n\nMiddle Line\n\nDynamic band fill (green/red/yellow)\n\nSL & TP line plotting when in position\n\nEntry/Exit markers\n\nPrice labels for all executed trades\n\nThese are built to help users visually follow the strategy logic.\n\nAlerts Included\n\nEvery trading event is covered:\n\nLong Entry\n\nShort Entry\n\nLong SL / TP / Cross Exit\n\nShort SL / TP / Cross Exit\n\nCombined Alert for webhook/automation (JSON-formatted)\n\nPerfect for algo trading, Discord bots, or automation platforms.\n\nBest For\n\nThis strategy performs best in:\n\nTrending markets\n\nBreakout environments\n\nHigh-momentum instruments\n\nClean intraday swings\n\nWorks seamlessly on:\n\nStocks\n\nIndex futures\n\nCommodities\n\nCrypto\n\nForex\n\nâš ï¸ Important Disclaimer\n\nThis script is for educational purposes only.\nTrading involves risk. Backtest results are not indicative of future performance.\nAlways validate settings and use proper position sizing.",
    "image_url": "wwi02rpz",
    "author": "ravi_matrix",
    "likes": 1412,
    "type": "strategy",
    "created": "2025-11-16",
    "updated": "2025-11-16",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// Â© ravi_matrix\n\n//@version=6\nstrategy('Moving Average Band Strategy', shorttitle = 'MA Band strategy', overlay = true, default_qty_type = strategy.percent_of_equity, default_qty_value = 100)\n\n// ============================================================================\n// INPUTS\n// ============================================================================\n\n// MA Type Selection\nmaTypeInput = input.string('SMA', 'Moving Average Type', options = ['SMA', 'EMA', 'WMA', 'HMA', 'VWMA', 'RMA'])\n\n// MA Length\nmaLength = input.int(40, 'MA Length', minval = 1)\n\n// Band Offset (optional - can add multiplier if needed)\nbandOffset = input.float(0.0, 'Band Offset %', minval = 0.0, step = 0.1) / 100\n\n// Strategy Settings\nlongEnabled = input.bool(true, 'Enable Long Trades', group = 'Strategy Settings')\nshortEnabled = input.bool(true, 'Enable Short Trades', group = 'Strategy Settings')\nuseRiskReward = input.bool(true, 'Use Risk:Reward Target', group = 'Strategy Settings')\nriskRewardRatio = input.float(3.0, 'Risk:Reward Ratio', minval = 0.5, step = 0.5, group = 'Strategy Settings')\n\n// ============================================================================\n// MOVING AVERAGE FUNCTION\n// ============================================================================\n\nma(source, length, maType) =>\n    switch maType\n        'SMA' => ta.sma(source, length)\n        'EMA' => ta.ema(source, length)\n        'WMA' => ta.wma(source, length)\n        'HMA' => ta.hma(source, length)\n        'VWMA' => ta.vwma(source, length)\n        'RMA' => ta.rma(source, length)\n        => ta.sma(source, length)\n\n// ============================================================================\n// CALCULATE BANDS\n// ============================================================================\n\n// Upper Band based on HIGH\nupperBand = ma(high, maLength, maTypeInput) * (1 + bandOffset)\n\n// Lower Band based on LOW\nlowerBand = ma(low, maLength, maTypeInput) * (1 - bandOffset)\n\n// Middle Line (optional reference)\nmiddleLine = (upperBand + lowerBand) / 2\n\n// ============================================================================\n// PRICE POSITION & BAND COLORING\n// ============================================================================\n\n// Determine price position relative to bands\npriceAboveBand = close > upperBand\npriceBelowBand = close < lowerBand\npriceBetweenBand = not priceAboveBand and not priceBelowBand\n\n// Band fill colors based on price position\nbandColor = priceAboveBand ? color.new(color.green, 85) : priceBelowBand ? color.new(color.red, 85) : color.new(color.yellow, 85)\n\n// ============================================================================\n// PLOTTING BANDS\n// ============================================================================\n\n// Plot the upper and lower bands\np1 = plot(upperBand, title = 'Upper Band', color = color.blue, linewidth = 2)\np2 = plot(lowerBand, title = 'Lower Band', color = color.blue, linewidth = 2)\n\n// Fill area between bands\nfill(p1, p2, color = bandColor, title = 'Band Fill')\n\n// Plot middle line\nplot(middleLine, title = 'Middle Line', color = color.gray, linewidth = 1, style = plot.style_circles)\n\n// ============================================================================\n// STRATEGY LOGIC\n// ============================================================================\n\n// Entry Conditions - prevent entries in same direction if already in position\nlongCondition = ta.crossover(close, upperBand) and longEnabled and strategy.position_size <= 0\nshortCondition = ta.crossunder(close, lowerBand) and shortEnabled and strategy.position_size >= 0\n\n// Variables to store entry price and calculate SL/TP\nvar float longEntryPrice = na\nvar float shortEntryPrice = na\nvar float longStopLoss = na\nvar float shortStopLoss = na\nvar float longTakeProfit = na\nvar float shortTakeProfit = na\nvar float exitPrice = na\n\n// Calculate SL and TP for Long trades\nif longCondition\n    longEntryPrice := close\n    longStopLoss := lowerBand // SL at lower band (fixed at entry)\n    riskPerTrade = longEntryPrice - longStopLoss\n    longTakeProfit := useRiskReward ? longEntryPrice + riskPerTrade * riskRewardRatio : na // TP based on risk:reward\n    strategy.entry('Long', strategy.long)\n    // Entry price label\n    label.new(bar_index, longEntryPrice, text = str.tostring(longEntryPrice, format.mintick), style = label.style_none, textcolor = color.green, size = size.small)\n\n// Calculate SL and TP for Short trades\nif shortCondition\n    shortEntryPrice := close\n    shortStopLoss := upperBand // SL at upper band (fixed at entry)\n    riskPerTrade = shortStopLoss - shortEntryPrice\n    shortTakeProfit := useRiskReward ? shortEntryPrice - riskPerTrade * riskRewardRatio : na // TP based on risk:reward\n    strategy.entry('Short', strategy.short)\n    // Entry price label\n    label.new(bar_index, shortEntryPrice, text = str.tostring(shortEntryPrice, format.mintick), style = label.style_none, textcolor = color.red, size = size.small)\n\n// Exit Conditions for Long - using LOW for SL and HIGH for TP (touch based)\nlongSLHit = strategy.position_size > 0 and low <= longStopLoss\nlongTPHit = useRiskReward and strategy.position_size > 0 and not na(longTakeProfit) and high >= longTakeProfit\nlongCrossExit = not useRiskReward and strategy.position_size > 0 and ta.crossunder(close, lowerBand)\n\n// Exit Conditions for Short - using HIGH for SL and LOW for TP (touch based)\nshortSLHit = strategy.position_size < 0 and high >= shortStopLoss\nshortTPHit = useRiskReward and strategy.position_size < 0 and not na(shortTakeProfit) and low <= shortTakeProfit\nshortCrossExit = not useRiskReward and strategy.position_size < 0 and ta.crossover(close, upperBand)\n\n// Execute Exits\nif longSLHit\n    exitPrice = longStopLoss\n    strategy.close('Long', comment = 'SL Hit')\n    label.new(bar_index, exitPrice, text = str.tostring(exitPrice, format.mintick), style = label.style_none, textcolor = color.red, size = size.small)\n\nif longTPHit\n    exitPrice = longTakeProfit\n    strategy.close('Long', comment = 'TP Hit')\n    label.new(bar_index, exitPrice, text = str.tostring(exitPrice, format.mintick), style = label.style_none, textcolor = color.green, size = size.small)\n\nif longCrossExit\n    exitPrice = close\n    strategy.close('Long', comment = 'Cross Exit')\n    label.new(bar_index, exitPrice, text = str.tostring(exitPrice, format.mintick), style = label.style_none, textcolor = color.orange, size = size.small)\n\nif shortSLHit\n    exitPrice = shortStopLoss\n    strategy.close('Short', comment = 'SL Hit')\n    label.new(bar_index, exitPrice, text = str.tostring(exitPrice, format.mintick), style = label.style_none, textcolor = color.red, size = size.small)\n\nif shortTPHit\n    exitPrice = shortTakeProfit\n    strategy.close('Short', comment = 'TP Hit')\n    label.new(bar_index, exitPrice, text = str.tostring(exitPrice, format.mintick), style = label.style_none, textcolor = color.green, size = size.small)\n\nif shortCrossExit\n    exitPrice = close\n    strategy.close('Short', comment = 'Cross Exit')\n    label.new(bar_index, exitPrice, text = str.tostring(exitPrice, format.mintick), style = label.style_none, textcolor = color.orange, size = size.small)\n\n// Reset levels AFTER exits are processed\nif strategy.position_size[1] != 0 and strategy.position_size == 0\n    longStopLoss := na\n    longTakeProfit := na\n    shortStopLoss := na\n    shortTakeProfit := na\n    shortTakeProfit\n\n// ============================================================================\n// ALERTS\n// ============================================================================\n\n// Alert conditions\nalertcondition(longCondition, title = 'Long Entry Signal', message = 'MA Band Strategy: LONG Entry - Price crossed above upper band')\nalertcondition(shortCondition, title = 'Short Entry Signal', message = 'MA Band Strategy: SHORT Entry - Price crossed below lower band')\nalertcondition(longSLHit, title = 'Long SL Hit', message = 'MA Band Strategy: Long STOP LOSS Hit')\nalertcondition(longTPHit, title = 'Long TP Hit', message = 'MA Band Strategy: Long TAKE PROFIT Hit')\nalertcondition(longCrossExit, title = 'Long Cross Exit', message = 'MA Band Strategy: Long EXIT - Crossed below lower band')\nalertcondition(shortSLHit, title = 'Short SL Hit', message = 'MA Band Strategy: Short STOP LOSS Hit')\nalertcondition(shortTPHit, title = 'Short TP Hit', message = 'MA Band Strategy: Short TAKE PROFIT Hit')\nalertcondition(shortCrossExit, title = 'Short Cross Exit', message = 'MA Band Strategy: Short EXIT - Crossed above upper band')\n\n// Combined alert for webhook integration\nalertcondition(longCondition or shortCondition or longSLHit or longTPHit or longCrossExit or shortSLHit or shortTPHit or shortCrossExit, title = 'Any Signal', message = '{\"strategy\":\"MA_Band\",\"action\":\"{{strategy.order.action}}\",\"price\":\"{{close}}\",\"time\":\"{{timenow}}\"}')\n\n// ============================================================================\n// VISUAL INDICATORS\n// ============================================================================\n\n// Plot entry/exit markers\nplotshape(longCondition, title = 'Long Entry', location = location.belowbar, color = color.new(color.green, 0), style = shape.triangleup, size = size.small)\nplotshape(shortCondition, title = 'Short Entry', location = location.abovebar, color = color.new(color.red, 0), style = shape.triangledown, size = size.small)\nplotshape(longSLHit, title = 'Long SL', location = location.abovebar, color = color.new(color.red, 0), style = shape.xcross, size = size.small, text = 'SL')\nplotshape(longTPHit, title = 'Long TP', location = location.abovebar, color = color.new(color.green, 0), style = shape.xcross, size = size.small, text = 'TP')\nplotshape(longCrossExit, title = 'Long Cross Exit', location = location.abovebar, color = color.new(color.orange, 0), style = shape.xcross, size = size.small, text = 'X')\nplotshape(shortSLHit, title = 'Short SL', location = location.belowbar, color = color.new(color.red, 0), style = shape.xcross, size = size.small, text = 'SL')\nplotshape(shortTPHit, title = 'Short TP', location = location.belowbar, color = color.new(color.green, 0), style = shape.xcross, size = size.small, text = 'TP')\nplotshape(shortCrossExit, title = 'Short Cross Exit', location = location.belowbar, color = color.new(color.orange, 0), style = shape.xcross, size = size.small, text = 'X')\n\n// Plot SL and TP lines for active positions\nplot(strategy.position_size > 0 ? longStopLoss : na, title = 'Long SL', color = color.red, linewidth = 2, style = plot.style_linebr)\nplot(strategy.position_size > 0 and useRiskReward ? longTakeProfit : na, title = 'Long TP', color = color.green, linewidth = 2, style = plot.style_linebr)\nplot(strategy.position_size < 0 ? shortStopLoss : na, title = 'Short SL', color = color.red, linewidth = 2, style = plot.style_linebr)\nplot(strategy.position_size < 0 and useRiskReward ? shortTakeProfit : na, title = 'Short TP', color = color.green, linewidth = 2, style = plot.style_linebr)\n"
  },
  {
    "url": "LfN8ZHEx-FX-Swing-Compact-Auto-Sizing-Fixed",
    "name": "FX Swing â€” Compact Auto-Sizing (Fixed)",
    "description": "A compact Forex swing-trading strategy that combines higher-timeframe EMA trend bias, EMA pullback confirmation, and RSI momentum filtering. It automatically sizes positions using either risk-percentage or fixed-risk, adapts pip values for JPY and non-JPY pairs, and generates clear SL/TP levels with partial take-profit exits. The script also sends structured JSON alerts for webhooks or WhatsApp automation, making it ideal for fast, disciplined, and risk-controlled swing entries.",
    "image_url": "LfN8ZHEx",
    "author": "Shrihari78",
    "likes": 5,
    "type": "strategy",
    "created": "2025-11-16",
    "updated": "2025-11-16",
    "source": " //@version=6\nstrategy(\"FX Swing â€” Compact Auto-Sizing (Fixed)\", overlay=true, default_qty_type=strategy.fixed, default_qty_value=1.0)\n\n// === Inputs\nhtf = input.timeframe(\"D\", \"Higher TF\")\nhtfE1 = input.int(50, \"HTF EMA 1\")\nhtfE2 = input.int(200, \"HTF EMA 2\")\nema_tf = input.int(50, \"Chart EMA\")\nrsi_len = input.int(14, \"RSI\")\nrsi_thr = input.float(45.0, \"RSI Threshold\")\n\npair_type = input.string(\"Auto\", \"Pair Type\", options=[\"Auto\",\"Non-JPY\",\"JPY\"])\npullback_pips = input.int(25, \"Pullback (pips)\")\nsl_buffer_pips = input.int(5, \"SL buffer (pips)\")\nsl_lookback = input.int(20, \"SL lookback\")\n\ntp_rr1 = input.float(2.0, \"TP1 R:R\")\ntp_rr2 = input.float(3.0, \"TP2 R:R\")\nenable_long = input.bool(true, \"Longs\")\nenable_short = input.bool(false, \"Shorts\")\nshow_labels = input.bool(true, \"Labels\")\n\nuse_fixed = input.bool(false, \"Use fixed risk\")\nrisk_pct = input.float(1.0, \"Risk %\")\nfixed_amt = input.float(100.0, \"Fixed risk amount\")\nmin_qty = input.float(0.0, \"Min qty\")\ncontract_override = input.float(0.0, \"Contract cash value (0 = use syminfo.pointvalue)\")\nround_qty = input.bool(true, \"Round qty\")\n\n// === Pair/pip detection\nis_jpy = pair_type == \"JPY\" ? true : (pair_type == \"Non-JPY\" ? false : str.contains(syminfo.tickerid, \"JPY\"))\npip = is_jpy ? 0.01 : 0.0001\npullback_tol = pullback_pips * pip\nsl_buffer = sl_buffer_pips * pip\n\n// === Indicators / bias\nhtf_e1 = request.security(syminfo.tickerid, htf, ta.ema(close, htfE1))\nhtf_e2 = request.security(syminfo.tickerid, htf, ta.ema(close, htfE2))\nbias_up = htf_e1 > htf_e2\nbias_down = htf_e1 < htf_e2\n\nema_c = ta.ema(close, ema_tf)\nrsi = ta.rsi(close, rsi_len)\n\n// === Setup conditions\ntouched_low = ta.lowest(low, 3) <= ema_c * (1 + pullback_tol)\ntouched_high = ta.highest(high, 3) >= ema_c * (1 - pullback_tol)\nlong_setup = enable_long and bias_up and touched_low and close > ema_c and rsi > rsi_thr\nshort_setup = enable_short and bias_down and touched_high and close < ema_c and rsi < (100 - rsi_thr)\n\n// === SL/TP\ns_low = ta.lowest(low, sl_lookback)\ns_high = ta.highest(high, sl_lookback)\nlong_sl = s_low - sl_buffer\nshort_sl = s_high + sl_buffer\nlong_risk = math.max(1e-12, close - long_sl)\nshort_risk = math.max(1e-12, short_sl - close)\ntp1_long = close + long_risk * tp_rr1\ntp2_long = close + long_risk * tp_rr2\ntp1_short = close - short_risk * tp_rr1\ntp2_short = close - short_risk * tp_rr2\n\n// === Position sizing\npoint_val = contract_override > 0.0 ? contract_override : nz(syminfo.pointvalue, syminfo.mintick)\nlong_stop_cash = long_risk * point_val\nshort_stop_cash = short_risk * point_val\nrisk_amount = use_fixed ? fixed_amt : strategy.equity * (risk_pct / 100.0)\nlong_qty = long_stop_cash > 0 ? risk_amount / long_stop_cash : 0.0\nshort_qty = short_stop_cash > 0 ? risk_amount / short_stop_cash : 0.0\nif round_qty\n    long_qty := math.floor(long_qty)\n    short_qty := math.floor(short_qty)\nif min_qty > 0\n    long_qty := math.max(long_qty, min_qty)\n    short_qty := math.max(short_qty, min_qty)\nlong_qty := math.max(0.0, nz(long_qty, 0.0))\nshort_qty := math.max(0.0, nz(short_qty, 0.0))\n\n// === Entries / orders / alerts\nnoPos = strategy.position_size == 0\nif (long_setup and noPos and long_qty > 0)\n    strategy.entry(\"Long\", strategy.long, qty=long_qty)\n    json = '{\"type\":\"signal\",\"symbol\":\"' + syminfo.tickerid + '\",\"side\":\"LONG\",\"entry\":' + str.tostring(close, format.mintick) + ',\"sl\":' + str.tostring(long_sl, format.mintick) + ',\"tp1\":' + str.tostring(tp1_long, format.mintick) + ',\"tp2\":' + str.tostring(tp2_long, format.mintick) + ',\"qty\":' + str.tostring(long_qty, format.mintick) + ',\"mode\":\"' + (use_fixed ? \"Fixed\" : \"Pct\") + '\"}'\n    alert(json, alert.freq_once_per_bar_close)\n\nif (short_setup and noPos and short_qty > 0)\n    strategy.entry(\"Short\", strategy.short, qty=short_qty)\n    jsons = '{\"type\":\"signal\",\"symbol\":\"' + syminfo.tickerid + '\",\"side\":\"SHORT\",\"entry\":' + str.tostring(close, format.mintick) + ',\"sl\":' + str.tostring(short_sl, format.mintick) + ',\"tp1\":' + str.tostring(tp1_short, format.mintick) + ',\"tp2\":' + str.tostring(tp2_short, format.mintick) + ',\"qty\":' + str.tostring(short_qty, format.mintick) + ',\"mode\":\"' + (use_fixed ? \"Fixed\" : \"Pct\") + '\"}'\n    alert(jsons, alert.freq_once_per_bar_close)\n\n// Exits\nif strategy.position_size > 0\n    strategy.exit(\"LongTP1\", from_entry=\"Long\", limit=tp1_long, qty_percent=50)\n    strategy.exit(\"LongFinal\", from_entry=\"Long\", limit=tp2_long, stop=long_sl)\nif strategy.position_size < 0\n    strategy.exit(\"ShortTP1\", from_entry=\"Short\", limit=tp1_short, qty_percent=50)\n    strategy.exit(\"ShortFinal\", from_entry=\"Short\", limit=tp2_short, stop=short_sl)\n\n// === Plots (fixed boolean logic for plotting)\nplot((noPos or strategy.position_size > 0) ? long_sl : na, \"SL\", color=color.new(color.red,40), linewidth=2)\nplot((noPos or strategy.position_size > 0) ? tp1_long : na, \"TP1\", color=color.new(color.green,40), linewidth=2)\nplot((noPos or strategy.position_size > 0) ? tp2_long : na, \"TP2\", color=color.new(color.green,65), linewidth=2)\nplot(htf_e1, \"HTF EMA1\", color=color.new(color.orange,80))\nplot(htf_e2, \"HTF EMA2\", color=color.new(color.purple,80))\nplot(ema_c, \"EMA\", color=color.new(color.blue,0))\n\n// alertconditions (constant messages)\nalertcondition(long_setup and noPos and long_qty>0, title=\"LongSignal\", message=\"FX Swing Long â€” see webhook payload\")\nalertcondition(short_setup and noPos and short_qty>0, title=\"ShortSignal\", message=\"FX Swing Short â€” see webhook payload\")\n\n// labels\nif show_labels and long_setup and noPos\n    label.new(bar_index, high, \"LONG | Qty:\" + str.tostring(long_qty, format.mintick) + \" | SL:\" + str.tostring(long_sl, format.mintick) + \" | TP1:\" + str.tostring(tp1_long, format.mintick), style=label.style_label_up, color=color.new(color.green,50))\nif show_labels and short_setup and noPos\n    label.new(bar_index, low, \"SHORT | Qty:\" + str.tostring(short_qty, format.mintick) + \" | SL:\" + str.tostring(short_sl, format.mintick) + \" | TP1:\" + str.tostring(tp1_short, format.mintick), style=label.style_label_down, color=color.new(color.red,50))\n\n\n\n\n\n\n"
  },
  {
    "url": "HFBT7MWQ-MOMO-Imbalance-Trend-SIMPLE-BUY-SELL",
    "name": "MOMO â€“ Imbalance Trend (SIMPLE BUY/SELL)",
    "description": "MOMO â€“ Imbalance Trend (SIMPLE BUY/SELL)\nThis strategy combines trend breaks, imbalance detection, and first-tap supply/demand entries to create a clean and disciplined trading model.\nIt automatically highlights imbalance candles, draws fresh zones, and waits for the first retest to deliver precise BUY and SELL signals.\n\nPerformance\n\nOn optimized settings, this strategy shows an estimated 57%â€“70% win-rate, depending on the asset and timeframe.\nActual performance may vary, but the model is built for consistency, discipline, and improved decision-making.\n\nHow it works\n\nDetects trend structure shifts (BOS / Break of Trend)\n\nIdentifies displacement (imbalance) candles\n\nCreates supply and demand zones from imbalance origin\n\nWaits for first tap only (no second chances)\n\nConfirms direction using trend logic\n\nGenerates clean BUY/SELL arrows\n\nAutomatic SL/TP based on user settings\n\nFeatures\n\nClean BUY/SELL markers\n\nAuto-drawn supply & demand zones\n\nTrend break markers\n\nImbalance tags\n\nSmart first-tap confirmation\n\nCustomizable stop loss & take profit\n\nWorks on crypto, gold, forex, indices\n\nBest on M5â€“H1 for day trading\n\nNote\n\nThis strategy is designed for day traders who want clarity, structure, and zero emotional trading.\nUse it with discipline â€” and it will serve you well.\n\nGood luck, soldier.",
    "image_url": "HFBT7MWQ",
    "author": "mohamed030402",
    "likes": 106,
    "type": "strategy",
    "created": "2025-11-16",
    "updated": "2025-11-16",
    "source": "//@version=5\nstrategy(\"MOMO â€“ Imbalance Trend (SIMPLE BUY/SELL)\",\n     overlay = true,\n     initial_capital = 10000,\n     margin_long = 100,\n     margin_short = 100,\n     process_orders_on_close = true)\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// 0. INPUTS\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nslP = input.float(0.8, \"SL %\", step = 0.1) / 100\ntpP = input.float(1.8, \"TP %\", step = 0.1) / 100\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// 1. TREND (HH/HL vs LH/LL)\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nswh = ta.pivothigh(high, 2, 2)\nswl = ta.pivotlow(low, 2, 2)\n\nvar float lastHigh = na\nvar float lastLow  = na\n\nif not na(swh)\n    lastHigh := swh\nif not na(swl)\n    lastLow := swl\n\nupNow   = not na(lastHigh) and close > lastHigh\ndownNow = not na(lastLow)  and close < lastLow\n\nvar int trend = 0        // 1 = up, -1 = down, 0 = range\nint newTrend = trend\nif upNow\n    newTrend := 1\nelse if downNow\n    newTrend := -1\n\nbullBreak = trend == -1 and newTrend == 1\nbearBreak = trend == 1  and newTrend == -1\ntrend := newTrend\n\nplotshape(bullBreak, title = \"TrendBreakUp\",\n          location = location.belowbar, style = shape.labelup,\n          text = \"Breakâ†‘\", color = color.green, textcolor = color.white, size = size.small)\nplotshape(bearBreak, title = \"TrendBreakDown\",\n          location = location.abovebar, style = shape.labeldown,\n          text = \"Breakâ†“\", color = color.red, textcolor = color.white, size = size.small)\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// 2. IMBALANCE (DISPLACEMENT CANDLES)\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nbullBody    = close - open\nbearBody    = open - close\ncandleRange = high - low\n\nbullDisp = bullBody > 0 and bullBody > candleRange * 0.6\nbearDisp = bearBody > 0 and bearBody > candleRange * 0.6\n\nplotshape(bullDisp, title = \"BullImb\",\n          location = location.belowbar, style = shape.triangleup,\n          text = \"IMB\", color = color.green, size = size.tiny)\nplotshape(bearDisp, title = \"BearImb\",\n          location = location.abovebar, style = shape.triangledown,\n          text = \"IMB\", color = color.red, size = size.tiny)\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// 3. DEMAND ZONE (BULLISH IMB)\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nvar float dLow  = na\nvar float dHigh = na\nvar bool  dUsed = false\nvar box   dBox  = na\n\nif bullDisp\n    dLow  := low\n    dHigh := open\n    dUsed := false\n    if not na(dBox)\n        box.delete(dBox)\n    dBox := box.new(bar_index, dHigh, bar_index + 1, dLow)\n    box.set_bgcolor(dBox, color.new(color.teal, 85))\n    box.set_border_color(dBox, color.new(color.teal, 40))\n\nif not na(dBox) and not dUsed\n    box.set_right(dBox, bar_index)\n\n// FIRST TAP into demand (not imbalance candle)\nfirstTapDemand = not dUsed and not bullDisp and not na(dLow) and low <= dHigh and low >= dLow\n\nif firstTapDemand\n    dUsed := true\n    if not na(dBox)\n        box.delete(dBox)\n        dBox := na\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// 4. SUPPLY ZONE (BEARISH IMB)\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nvar float sLow  = na\nvar float sHigh = na\nvar bool  sUsed = false\nvar box   sBox  = na\n\nif bearDisp\n    sHigh := high\n    sLow  := open\n    sUsed := false\n    if not na(sBox)\n        box.delete(sBox)\n    sBox := box.new(bar_index, sHigh, bar_index + 1, sLow)\n    box.set_bgcolor(sBox, color.new(color.red, 85))\n    box.set_border_color(sBox, color.new(color.red, 40))\n\nif not na(sBox) and not sUsed\n    box.set_right(sBox, bar_index)\n\n// FIRST TAP into supply (not imbalance candle)\nfirstTapSupply = not sUsed and not bearDisp and not na(sHigh) and high >= sLow and high <= sHigh\n\nif firstTapSupply\n    sUsed := true\n    if not na(sBox)\n        box.delete(sBox)\n        sBox := na\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// 5. ENTRY CONDITIONS (SIMPLE)\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// Only trend + first tap\nlongEntry  = trend == 1  and firstTapDemand\nshortEntry = trend == -1 and firstTapSupply\n\n// Big BUY / SELL arrows\nplotshape(longEntry,  title = \"BUY\",\n          location = location.belowbar, style = shape.labelup,\n          size = size.large, color = color.green, text = \"BUY\", textcolor = color.white)\nplotshape(shortEntry, title = \"SELL\",\n          location = location.abovebar, style = shape.labeldown,\n          size = size.large, color = color.red, text = \"SELL\", textcolor = color.white)\n\n// Extra labels so they *always* show\nif longEntry\n    label.new(bar_index, low, \"BUY\",\n              style = label.style_label_up,\n              color = color.green, textcolor = color.white)\nif shortEntry\n    label.new(bar_index, high, \"SELL\",\n              style = label.style_label_down,\n              color = color.red, textcolor = color.white)\n\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// 6. STRATEGY ORDERS (ENTRY + EXIT)\n//â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nif longEntry\n    strategy.entry(\"Long\", strategy.long)\n\nif shortEntry\n    strategy.entry(\"Short\", strategy.short)\n\nif strategy.position_size > 0\n    strategy.exit(\"Exit L\", \"Long\",\n                  stop  = strategy.position_avg_price * (1 - slP),\n                  limit = strategy.position_avg_price * (1 + tpP))\n\nif strategy.position_size < 0\n    strategy.exit(\"Exit S\", \"Short\",\n                  stop  = strategy.position_avg_price * (1 + slP),\n                  limit = strategy.position_avg_price * (1 - tpP))\n"
  },
  {
    "url": "AZ6wYHDz",
    "name": "Fractional Candlestick Long Only Experimental V10",
    "description": "Fractional Candlestick Long-Only Strategy â€“ Technical Description\n\nThis document provides a professional English description of the \"Fractional Candlestick Long Only Experimental V6\" strategy using pure CF/AB fractional kernels and wavelet-based filtering.\n\n1. Fractional Candlesticks (CF / AB)\nThe strategy computes two fractional representations of price using Caputoâ€“Fabrizio (CF) and Atanganaâ€“Baleanu (AB) kernels. These provide long-memory filtering without EMA approximations. Both CF and AB versions are applied to O/H/L/C, producing fractional candlesticks and fractional Heikin-Ashi variants.\n\n2. Trend Stack Logic\nTrend confirmation is based on a 4-component stack:\n- CF close > AB close\n- HA_CF close > HA_AB close\n- HA_CF bullish\n- HA_AB bullish\nThe user selects how many components must align (4, 3, or any 2).\n\n3. Wavelet Filtering\nA wavelet transform (Haar, Daubechies-4, Mexican Hat) is applied to a chosen source (e.g., HA_CF close). The wavelet response is used as:\n- entry filter (4 modes)\n- exit filter (4 modes)\nWavelet modes: off, confirm, wavelet-only, block adverse signals.\n\n4. Trailing System\nTrailing stop uses fractional AB low Ã— buffer, providing long-memory dynamic trailing behavior. A fractional trend channel (CF/AB lows vs HA highs) is also plotted.\n\n5. Exit Framework\nExit options include: stack flip, CF",
    "image_url": "AZ6wYHDz",
    "author": "wojlucz",
    "likes": 21,
    "type": "strategy",
    "created": "2025-11-15",
    "updated": "2025-11-15",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// Â© wojlucz\n\n//@version=5\nstrategy(\"Fractional Candlestick Long Only Experimental V10 \",\n     overlay=true,\n     default_qty_type=strategy.percent_of_equity,initial_capital=10000, default_qty_value=100,\n     pyramiding=0, process_orders_on_close=true, calc_on_every_tick=false)\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ DISPLAY SETTINGS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nshowStandardCandles = input.bool(true,  \"Show standard candles\")\nshowHA_CF           = input.bool(true,  \"Show Fractional HA from CF\")\nshowHA_AB           = input.bool(true,  \"Show Fractional HA from AB\")\nshowCFCandles       = input.bool(true,  \"Show Fractional Candlestick CF\")\nshowABCandles       = input.bool(true,  \"Show Fractional Candlestick AB\")\nshowDebugLines      = input.bool(true,  \"Show helper lines (HA close only)\")\nshowTrailLine       = input.bool(true,  \"Show trailing stop line\")\nshowTrailHit        = input.bool(true,  \"Show trailing stop hit marker\")\nshowTrailChannel    = input.bool(true,  \"Show fractional trend/trailing channel\")\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ FRACTIONAL KERNEL SETTINGS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nord_cf_candle  = input.float(0.20, \"CF order (Candlestick)\", minval=0.01, maxval=0.99)\nlen_cf_candle  = input.int(  20,   \"CF length (Candlestick)\", minval=1, maxval=300)\nord_ab_candle  = input.float(0.10, \"AB order (Candlestick)\", minval=0.01, maxval=0.99)\nlen_ab_candle  = input.int(  20,   \"AB length (Candlestick)\", minval=1, maxval=300)\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ STACK LOGIC (ENTRY BASE) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nstackMode      = input.string(\"Stack-4 (strongest)\", \"Stack strength mode\",\n     options=[\"Stack-4 (strongest)\",\"Stack-3 (strong)\",\"Any-2 (loose)\"])\nconfirmNextBar = input.bool(true, \"Confirm entry on next bar\")\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ EXIT MODES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nexitMode    = input.string(\"Order flip (CF/HA stack)\", \"Base exit mode\",\n     options=[\"Order flip (CF/HA stack)\",\"CF<AB\",\"HA flip\",\"Kernel trailing\"])\ntrailBufPct = input.float(0.20, \"Trailing buffer [% of price] (Kernel trailing)\", minval=0.0, maxval=5.0)\nuseSLTP     = input.bool(false, \"Enable SL/TP [%]\")\nslPct       = input.float(3.0, \"Stop Loss [%]\", minval=0.1, maxval=50.0)\ntpPct       = input.float(6.0, \"Take Profit [%]\", minval=0.1, maxval=200.0)\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ WAVELET FILTER (ENTRY & EXIT) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nwaveletType      = input.string(\"Haar\", \"Wavelet type\",\n     options=[\"Haar\",\"Daubechies-4\",\"Mexican Hat (Red Hat)\"])\nwaveletSourceOpt = input.string(\"HA_CF close\", \"Wavelet source\",\n     options=[\"HA_CF close\",\"HA_AB close\",\"CF close\",\"AB close\"])\n\n// Single base threshold â€“ used symmetrically for up/down\nwaveletThreshold = input.float(0.0, \"Base wavelet threshold (|value|)\", minval=-10.0, maxval=10.0)\n\n// Entry wavelet modes (analogue to exit)\nentryWaveletMode = input.string(\"Off\", \"ENTRY wavelet filter mode\",\n     options=[\"Off\",\"Confirm entry\",\"Wavelet-only entry\",\"Block adverse entries\"])\n\n// Exit wavelet modes\nexitWaveletMode = input.string(\"Off\", \"EXIT wavelet filter mode\",\n     options=[\"Off\",\"Confirm exit\",\"Wavelet-only exit\",\"Block false exits\"])\nwaveletExitThreshold = input.float(0.0, \"EXIT threshold (wavelet < value)\", minval=-10.0, maxval=10.0)\n\nshowWaveletDebug = input.bool(false, \"Show wavelet response (debug)\")\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ LANCZOS GAMMA & FRACTIONAL KERNELS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\npi_const = 3.141592653589793\n\n// Lanczos Gamma approximation for x >= 1\ngamma_lanczos(x) =>\n    var float[] p = array.from(0.99999999999980993,676.5203681218851,-1259.1392167224028,771.32342877765313, -176.61502916214059,12.507343278686905,-0.13857109526572012,9.9843695780195716e-6,1.5056327351493116e-7)\n    z1 = x - 1.0\n    acc = array.get(p, 0)\n    for i = 1 to array.size(p) - 1\n        acc += array.get(p, i) / (z1 + i)\n    t = z1 + 7.5\n    math.sqrt(2.0 * pi_const) * math.pow(t, z1 + 0.5) * math.exp(-t) * acc\n\n// Mittagâ€“Leffler E_a(x) truncated series\nmittag_leffler_Ea(ord, x) =>\n    int K = 30\n    s = 0.0\n    powx = 1.0\n    for k = 0 to K\n        g = gamma_lanczos(ord * k + 1.0)\n        term = powx / g\n        s += term\n        powx := powx * x\n    s\n\n// Caputoâ€“Fabrizio-like exponential kernel\ncf_kernel_full(i, ord) =>\n    beta = ord / (1.0 - ord)\n    ((1.0 - ord) / ord) * math.exp(-beta * i)\n\n// Atanganaâ€“Baleanu-like kernel via Mittagâ€“Leffler\nab_kernel_full(i, ord) =>\n    lambda = ord / (1.0 - ord)\n    t_pow = i == 0 ? 0.0 : math.pow(i, ord)\n    mittag_leffler_Ea(ord, -(lambda * t_pow))\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ FRACTIONAL FILTERS (CONVOLUTION) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nfrac_filter_cf(src, length, ord) =>\n    _sum  = 0.0\n    _norm = 0.0\n    for i = 0 to length\n        w = cf_kernel_full(i, ord)\n        _sum  += nz(src[i]) * w\n        _norm += w\n    _norm != 0.0 ? _sum / _norm : nz(src)\n\nfrac_filter_ab(src, length, ord) =>\n    _sum  = 0.0\n    _norm = 0.0\n    for i = 0 to length\n        w = ab_kernel_full(i, ord)\n        _sum  += nz(src[i]) * w\n        _norm += w\n    _norm != 0.0 ? _sum / _norm : nz(src)\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ FRACTIONAL CANDLESTICKS (PURE KERNELS) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\ncf_open  = frac_filter_cf(open,  len_cf_candle, ord_cf_candle)\ncf_high  = frac_filter_cf(high,  len_cf_candle, ord_cf_candle)\ncf_low   = frac_filter_cf(low,   len_cf_candle, ord_cf_candle)\ncf_close = frac_filter_cf(close, len_cf_candle, ord_cf_candle)\n\nab_open  = frac_filter_ab(open,  len_ab_candle, ord_ab_candle)\nab_high  = frac_filter_ab(high,  len_ab_candle, ord_ab_candle)\nab_low   = frac_filter_ab(low,   len_ab_candle, ord_ab_candle)\nab_close = frac_filter_ab(close, len_ab_candle, ord_ab_candle)\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ FRACTIONAL HEIKIN-ASHI FROM CF / AB â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\ncf_HA_close = (cf_open + cf_high + cf_low + cf_close) / 4.0\nvar float cf_HA_open = na\ncf_HA_open := na(cf_HA_open[1]) ? (cf_open + cf_close) / 2.0 : (cf_HA_open[1] + cf_HA_close[1]) / 2.0\ncf_HA_high = math.max(cf_high, math.max(cf_HA_open, cf_HA_close))\ncf_HA_low  = math.min(cf_low,  math.min(cf_HA_open, cf_HA_close))\n\nab_HA_close = (ab_open + ab_high + ab_low + ab_close) / 4.0\nvar float ab_HA_open = na\nab_HA_open := na(ab_HA_open[1]) ? (ab_open + ab_close) / 2.0 : (ab_HA_open[1] + ab_HA_close[1]) / 2.0\nab_HA_high = math.max(ab_high, math.max(ab_HA_open, ab_HA_close))\nab_HA_low  = math.min(ab_low,  math.min(ab_HA_open, ab_HA_close))\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ COLORS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nstdBullColor = color.new(color.lime, 0)\nstdBearColor = color.new(color.red,  0)\ncf_col       = cf_close >= cf_open ? color.new(color.teal, 0)   : color.new(color.blue, 0)\nab_col       = ab_close >= ab_open ? color.new(color.orange, 0) : color.new(color.red, 0)\ncf_HA_col    = cf_HA_close >= cf_HA_open ? color.new(color.green, 75) : color.new(color.red, 75)\nab_HA_col    = ab_HA_close >= ab_HA_open ? color.new(color.blue,  75) : color.new(color.orange, 75)\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ STANDARD & FRACTIONAL CANDLES PLOTTING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nplotcandle(open, high, low, close, title=\"Standard candles\",\n     color     = showStandardCandles ? (open <= close ? stdBullColor : stdBearColor) : na,\n     wickcolor = showStandardCandles ? color.new(color.gray, 0) : na,\n     display   = showStandardCandles ? display.all : display.none)\n\nplotcandle(cf_open, cf_high, cf_low, cf_close, title=\"Fractional Candlestick CF\",\n     color      = showCFCandles ? cf_col : na,\n     wickcolor  = showCFCandles ? cf_col : na,\n     bordercolor= showCFCandles ? cf_col : na,\n     display    = showCFCandles ? display.all : display.none)\n\nplotcandle(ab_open, ab_high, ab_low, ab_close, title=\"Fractional Candlestick AB\",\n     color      = showABCandles ? ab_col : na,\n     wickcolor  = showABCandles ? ab_col : na,\n     bordercolor= showABCandles ? ab_col : na,\n     display    = showABCandles ? display.all : display.none)\n\nplotcandle(cf_HA_open, cf_HA_high, cf_HA_low, cf_HA_close, title=\"Fractional HA from CF\",\n     color     = showHA_CF ? cf_HA_col : na,\n     wickcolor = showHA_CF ? color.new(cf_HA_col,0) : na,\n     display   = showHA_CF ? display.all : display.none)\n\nplotcandle(ab_HA_open, ab_HA_high, ab_HA_low, ab_HA_close, title=\"Fractional HA from AB\",\n     color     = showHA_AB ? ab_HA_col : na,\n     wickcolor = showHA_AB ? color.new(ab_HA_col,0) : na,\n     display   = showHA_AB ? display.all : display.none)\n\n// Debug lines for HA closes\nplot(showDebugLines and showHA_CF ? cf_HA_close : na, title=\"HA_CF close\", color=color.fuchsia, linewidth=2)\nplot(showDebugLines and showHA_AB ? ab_HA_close : na, title=\"HA_AB close\", color=color.aqua, linewidth=2)\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ STACK RELATIONS (CF / AB / HA) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nr1_cfAboveAb     = cf_close > ab_close\nr2_haCfAboveHaAb = cf_HA_close > ab_HA_close\nr3_haCfBull      = cf_HA_close >= cf_HA_open\nr4_haAbBull      = ab_HA_close >= ab_HA_open\n\nscore     = (r1_cfAboveAb ? 1 : 0) + (r2_haCfAboveHaAb ? 1 : 0) + (r3_haCfBull ? 1 : 0) + (r4_haAbBull ? 1 : 0)\nneedScore = stackMode == \"Stack-4 (strongest)\" ? 4 : stackMode == \"Stack-3 (strong)\" ? 3 : 2\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ WAVELET RESPONSE (HAAR / D4 / MEXICAN HAT) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nwavelet_response(src, kind) =>\n    w = 0.0\n    if kind == \"Haar\"\n        // Simple Haar detail: right-half minus left-half\n        w := -0.5 * nz(src[3]) - 0.5 * nz(src[2]) + 0.5 * nz(src[1]) + 0.5 * nz(src)\n    else\n        if kind == \"Daubechies-4\"\n            // High-pass part of Daubechies-4 (simplified coefficients)\n            c0 = -0.1294095226\n            c1 = -0.2241438680\n            c2 =  0.8365163037\n            c3 = -0.4829629131\n            w := c0 * nz(src) + c1 * nz(src[1]) + c2 * nz(src[2]) + c3 * nz(src[3])\n        else\n            // Mexican Hat (Red Hat) â€“ discrete 2nd derivative of Gaussian (approx)\n            w := -0.25 * nz(src) + 0.5 * nz(src[1]) - 0.25 * nz(src[2])\n    w\n\n// Select source for wavelet\nwaveletSource =\n     waveletSourceOpt == \"HA_CF close\" ? cf_HA_close :\n     waveletSourceOpt == \"HA_AB close\" ? ab_HA_close :\n     waveletSourceOpt == \"CF close\"    ? cf_close :\n     ab_close\n\nwaveletVal = wavelet_response(waveletSource, waveletType)\n\n// Use absolute thresholds so sign encodes direction\nthrEntry = math.abs(waveletThreshold)\nthrExit  = math.abs(waveletExitThreshold)\n\nentryUp   = waveletVal >  thrEntry      // wavelet supports up-move\nentryDown = waveletVal < -thrEntry      // wavelet suggests down-move\nwaveletExitHit = waveletVal < -thrExit  // exit condition from wavelet\n\nplot(showWaveletDebug ? waveletVal : na, title=\"Wavelet response\", color=color.yellow)\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ ENTRY LOGIC (STACK + WAVELET MODES) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nbaseLongRaw = score >= needScore\nstackLong   = confirmNextBar\n     ? (nz(baseLongRaw[1]) and not nz(baseLongRaw[2]))\n     : (nz(baseLongRaw) and not nz(baseLongRaw[1]))\n\n// ENTRY modes:\n// \"Off\"                 -> stack-only\n// \"Confirm entry\"       -> stack AND wavelet up\n// \"Wavelet-only entry\"  -> wavelet up only\n// \"Block adverse entries\" -> stack AND NOT (strong opposite impulse)\nlongCondition =\n     entryWaveletMode == \"Off\"                 ? stackLong :\n     entryWaveletMode == \"Confirm entry\"       ? (stackLong and entryUp) :\n     entryWaveletMode == \"Wavelet-only entry\"  ? entryUp :\n     (stackLong and not entryDown)\n\nbgcolor(longCondition ? color.new(color.lime, 85) : na)\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ POSITION MANAGEMENT / CHANNEL / TRAILING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nvar inPos = false\ninPos := strategy.position_size > 0\n\nif longCondition and not inPos\n    strategy.entry(\"LongBull\", strategy.long)\n\n// Kernel-based trailing level from AB low\ntrailLevel = ab_low * (1.0 - trailBufPct/100.0)\n\n// Fractional channel: CF/AB lows vs HA highs\nchanLower = math.min(cf_low, ab_low)\nchanUpper = math.max(cf_HA_high, ab_HA_high)\n\npChanUpper = plot(showTrailChannel and inPos ? chanUpper : na,\n     title=\"Fractional Channel Upper\",\n     color=color.new(color.green, 20), linewidth=1)\n\npChanLower = plot(showTrailChannel and inPos ? chanLower : na,\n     title=\"Fractional Channel Lower\",\n     color=color.new(color.orange, 20), linewidth=1)\n\nfill(pChanUpper, pChanLower, color=color.new(color.teal, 85), title=\"Fractional Trend Channel\")\n\nplot(showTrailLine and inPos ? trailLevel : na,\n     title=\"Trailing Level\", linewidth=2, style=plot.style_line, color=color.new(color.yellow, 0))\n\nplotshape(showTrailHit and inPos and close < trailLevel,\n     title=\"Trailing Hit\", style=shape.cross, size=size.small, color=color.red, text=\"TS\")\n\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ EXIT LOGIC (BASE MODES + WAVELET EXIT MODES) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// Base exit signals (without wavelet)\ncfCrossDown   = cf_close < ab_close and cf_close[1] >= ab_close[1]\nhaFlipDown    = cf_HA_close < cf_HA_open and cf_HA_close[1] >= cf_HA_open[1]\norderFlipDown = score < needScore\n\nbaseExitSignal =\n     exitMode == \"Order flip (CF/HA stack)\" ? orderFlipDown :\n     exitMode == \"CF<AB\"                    ? cfCrossDown :\n     exitMode == \"HA flip\"                  ? haFlipDown :\n     exitMode == \"Kernel trailing\"          ? (close < trailLevel) : false\n\n// EXIT wavelet modes:\n// \"Off\"                 -> baseExitSignal only\n// \"Confirm exit\"        -> baseExitSignal AND waveletExitHit (down)\n// \"Wavelet-only exit\"   -> waveletExitHit only\n// \"Block false exits\"   -> baseExitSignal AND NOT strong up wavelet\nexitSignal =\n     exitWaveletMode == \"Off\"               ? baseExitSignal :\n     exitWaveletMode == \"Confirm exit\"      ? (baseExitSignal and waveletExitHit) :\n     exitWaveletMode == \"Wavelet-only exit\" ? waveletExitHit :\n     (baseExitSignal and not (waveletVal > thrExit))\n\nif inPos and exitSignal\n    strategy.close(\"LongBull\", comment=exitMode + \" + wavelet\")\n\n// Optional SL/TP in %\nif useSLTP\n    slPrice = strategy.position_avg_price * (1.0 - slPct/100.0)\n    tpPrice = strategy.position_avg_price * (1.0 + tpPct/100.0)\n    strategy.exit(\"LongBull-X\", from_entry=\"LongBull\", stop=slPrice, limit=tpPrice)"
  },
  {
    "url": "2xLrvuYu-Positional-Supertrend-Strategy-1D-Filter-2H-Entry",
    "name": "Positional Supertrend Strategy (1D Filter + 2H Entry)",
    "description": "Positional Supertrend Strategy (1D Filter + 2H Entry)",
    "image_url": "2xLrvuYu",
    "author": "phantomscharts",
    "likes": 66,
    "type": "strategy",
    "created": "2025-11-15",
    "updated": "2025-11-15",
    "source": "//@version=5\nstrategy(\"Positional Supertrend Strategy (1D Filter + 2H Entry)\", overlay=true, default_qty_type=strategy.percent_of_equity, default_qty_value=100, process_orders_on_close=true)\n\n/// --- Supertrend Inputs ---\natrLen  = 10\nmult    = 3.0\n\n/// --- 2H Supertrend (Chart timeframe) ---\n[st2h, dir2h] = ta.supertrend(mult, atrLen)  // dir2h: 1 = BUY, -1 = SELL\n\n/// --- Daily Supertrend (Trend Filter) ---\n[_, dirDaily] = request.security(syminfo.tickerid, \"D\", ta.supertrend(mult, atrLen))\nisDailyBuy = dirDaily == 1\n\n/// --- Detect 2H Supertrend Flips ---\nflipToBuy  = dir2h == 1 and dir2h[1] == -1\nflipToSell = dir2h == -1 and dir2h[1] == 1\n\n/// --- Entry Condition ---\nif flipToBuy and isDailyBuy\n    strategy.entry(\"Long\", strategy.long, comment=\"Entry ST Buy\")\n\n/// --- Exit Condition ---\nif flipToSell\n    strategy.close(\"Long\", comment=\"Exit ST Sell\")\n\n/// --- Plotting ---\nplot(st2h, title=\"2H Supertrend\", color=dir2h == 1 ? color.green : color.red, linewidth=2)\nplotshape(flipToBuy, title=\"Buy Signal\", location=location.belowbar, color=color.green, style=shape.triangleup)\nplotshape(flipToSell, title=\"Sell Signal\", location=location.abovebar, color=color.red, style=shape.triangledown)\n"
  },
  {
    "url": "7m7IVw9Q-ASHOK-15-Nov",
    "name": "ASHOK 15 Nov",
    "description": "ashok trial 15 nov 1845h\n\n I have created this strategy to convert my chart pattern and MACD, EMA observations to tradeable logic.",
    "image_url": "7m7IVw9Q",
    "author": "ashokkkkkk",
    "likes": 11,
    "type": "strategy",
    "created": "2025-11-15",
    "updated": "2025-11-15",
    "source": "//@version=5\nstrategy(\"Nifty Options MACD + EMA Strategy with SL/TP\", overlay=true)\n\n// MACD parameters\nfastLength = 12\nslowLength = 26\nsignalLength = 9\n\n// Calculate MACD\n[macdLine, signalLine, _] = ta.macd(close, fastLength, slowLength, signalLength)\n\n// Calculate EMAs\nema20 = ta.ema(close, 20)\nema50 = ta.ema(close, 50)\nema100 = ta.ema(close, 100)\nema200 = ta.ema(close, 200)\n\n// Minimum difference threshold for EMA gaps\nminDiff = 0.2  // Adjust based on price scale\n\n// Conditions for EMA sequence with minimum difference\nemaSeqCondition = (ema20 > ema50) and (ema50 > ema100) and (ema100 > ema200) and \n                  ((ema20 - ema50) > minDiff) and ((ema50 - ema100) > minDiff) and ((ema100 - ema200) > minDiff)\n\n// Buy condition 1: MACD crosses zero line upwards\nbuyCondition1 = ta.crossover(macdLine, 0)\n\n// Buy condition 2: EMA sequence condition is true\nbuyCondition2 = emaSeqCondition\n\n// Overall buy signal\nbuySignal = buyCondition1 or buyCondition2\n\n// Sell condition: MACD line crosses below signal line\nsellSignal = ta.crossunder(macdLine, signalLine)\n\n// Parameters for stop loss and take profit (percent)\nstopLossPercent = input.float(10.0, \"Stop Loss %\", step=0.1)  // Updated default 10%\ntakeProfitPercent = input.float(20.0, \"Take Profit %\", step=0.1)  // Updated default 20%\n\n// Calculate stop loss and take profit prices\nstopLossPrice = strategy.position_avg_price * (1 - stopLossPercent / 100)\ntakeProfitPrice = strategy.position_avg_price * (1 + takeProfitPercent / 100)\n\n// Execute trades with stop loss and take profit\nif (buySignal and strategy.position_size == 0)\n    strategy.entry(\"Long\", strategy.long)\n\nif (strategy.position_size > 0)\n    strategy.exit(\"Exit Long\", from_entry=\"Long\", stop=stopLossPrice, limit=takeProfitPrice)\n\nif (sellSignal)\n    strategy.close(\"Long\")\n\n// Plot MACD and signal line for reference\nplot(macdLine, color=color.blue, title=\"MACD Line\")\nplot(signalLine, color=color.orange, title=\"Signal Line\")\n\n// Plot EMAs for visual reference\nplot(ema20, color=color.yellow, title=\"EMA 20\")\nplot(ema50, color=color.red, title=\"EMA 50\")\nplot(ema100, color=color.purple, title=\"EMA 100\")\nplot(ema200, color=color.green, title=\"EMA 200\")\nif (buySignal)\n    alert(\"BUY\", alert.freq_once_per_bar_close)\n\nif (sellSignal)\n    alert(\"SELL\", alert.freq_once_per_bar_close)\n"
  },
  {
    "url": "ObzvAcGK-any-strategy-backtest",
    "name": "Any Strategy Backtest",
    "description": "A simple script for backtesting your strategies with TP and SL settings. For this to work, your indicators must have sources for long and short conditions.\n",
    "image_url": "ObzvAcGK",
    "author": "A-Swift",
    "likes": 61,
    "type": "strategy",
    "created": "2025-11-14",
    "updated": "2025-11-14",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// Â© A-Swift\r\n\r\n//@version=6\r\nstrategy(\"Any Strategy Backtest\", \"ASB\", overlay=true, margin_long=100, margin_short=100, commission_type=strategy.commission.percent, commission_value=0.1)\r\n\r\n// Ð’Ñ…Ð¾Ð´Ð½Ñ‹Ðµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹\r\n// Ð£ÑÐ»Ð¾Ð²Ð¸Ñ Ð²Ñ…Ð¾Ð´Ð°\r\nlongCondition = input.source(title=\"Ð£ÑÐ»Ð¾Ð²Ð¸Ðµ Long\", defval=close)\r\nshortCondition = input.source(title=\"Ð£ÑÐ»Ð¾Ð²Ð¸Ðµ Short\", defval=close)\r\n\r\n// ÐŸÐ°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ ÑƒÐ¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸Ñ Ñ€Ð¸ÑÐºÐ°Ð¼Ð¸\r\nstopLossPercent = input.float(title=\"Ð¡Ñ‚Ð¾Ð¿-Ð»Ð¾ÑÑ (%)\", minval=0.0, step=0.1, defval=2.0) / 100\r\ntakeProfitPercent = input.float(title=\"Ð¢ÐµÐ¹Ðº-Ð¿Ñ€Ð¾Ñ„Ð¸Ñ‚ (%)\", minval=0.0, step=0.1, defval=4.0) / 100\r\nriskPercent = input.float(title=\"Ð Ð¸ÑÐº Ð¾Ñ‚ ÐºÐ°Ð¿Ð¸Ñ‚Ð°Ð»Ð° (%)\", minval=0.1, step=0.1, defval=1.0) / 100\r\n\r\n// Ð Ð°ÑÑ‡ÐµÑ‚ Ñ€Ð°Ð·Ð¼ÐµÑ€Ð° Ð¿Ð¾Ð·Ð¸Ñ†Ð¸Ð¸\r\ncalcPositionSize() =>\r\n    // Ð Ð°ÑÑ‡ÐµÑ‚ Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ Ñ€Ð¸ÑÐºÐ° Ð¾Ñ‚ ÐºÐ°Ð¿Ð¸Ñ‚Ð°Ð»Ð°\r\n    equity = strategy.initial_capital + strategy.netprofit\r\n    riskAmount = equity * riskPercent\r\n    stopLossAmount = strategy.position_avg_price * stopLossPercent\r\n    riskAmount / stopLossAmount\r\n\r\n// Ð£ÑÐ»Ð¾Ð²Ð¸Ñ Ð´Ð»Ñ Ð²Ñ…Ð¾Ð´Ð° (Ð¿Ñ€ÐµÐ¾Ð±Ñ€Ð°Ð·ÑƒÐµÐ¼ source Ð² boolean)\r\nlongSignal = ta.change(longCondition) > 0\r\nshortSignal = ta.change(shortCondition) > 0\r\n\r\n// Ð Ð°ÑÑ‡ÐµÑ‚ ÑƒÑ€Ð¾Ð²Ð½ÐµÐ¹ ÑÑ‚Ð¾Ð¿-Ð»Ð¾ÑÑÐ° Ð¸ Ñ‚ÐµÐ¹Ðº-Ð¿Ñ€Ð¾Ñ„Ð¸Ñ‚Ð°\r\ncalcLongStopPrice() => \r\n    strategy.position_avg_price * (1 - stopLossPercent)\r\n\r\ncalcLongTakeProfit() => \r\n    strategy.position_avg_price * (1 + takeProfitPercent)\r\n\r\ncalcShortStopPrice() => \r\n    strategy.position_avg_price * (1 + stopLossPercent)\r\n\r\ncalcShortTakeProfit() => \r\n    strategy.position_avg_price * (1 - takeProfitPercent)\r\n\r\n// Ð›Ð¾Ð³Ð¸ÐºÐ° Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ Ð¾Ñ€Ð´ÐµÑ€Ð¾Ð²\r\nif longSignal and strategy.position_size == 0\r\n    strategy.entry(\"Long\", strategy.long, qty=calcPositionSize())\r\n    \r\nif shortSignal and strategy.position_size == 0\r\n    strategy.entry(\"Short\", strategy.short, qty=calcPositionSize())\r\n\r\n// Ð’Ñ‹Ñ…Ð¾Ð´ Ð¿Ð¾ ÑÑ‚Ð¾Ð¿-Ð»Ð¾ÑÑÑƒ Ð¸ Ñ‚ÐµÐ¹Ðº-Ð¿Ñ€Ð¾Ñ„Ð¸Ñ‚Ñƒ Ð´Ð»Ñ long\r\nif strategy.position_size > 0\r\n    strategy.exit(\"Long Exit\", \"Long\", \r\n         stop=calcLongStopPrice(), \r\n         limit=calcLongTakeProfit())\r\n\r\n// Ð’Ñ‹Ñ…Ð¾Ð´ Ð¿Ð¾ ÑÑ‚Ð¾Ð¿-Ð»Ð¾ÑÑÑƒ Ð¸ Ñ‚ÐµÐ¹Ðº-Ð¿Ñ€Ð¾Ñ„Ð¸Ñ‚Ñƒ Ð´Ð»Ñ short\r\nif strategy.position_size < 0\r\n    strategy.exit(\"Short Exit\", \"Short\", \r\n         stop=calcShortStopPrice(), \r\n         limit=calcShortTakeProfit())\r\n\r\n// ÐžÑ‚Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ ÑƒÑ€Ð¾Ð²Ð½ÐµÐ¹ Ð½Ð° Ð³Ñ€Ð°Ñ„Ð¸ÐºÐµ\r\nplot(strategy.position_size > 0 ? calcLongStopPrice() : na, \r\n     \"Long Stop\", color=color.red, style=plot.style_linebr)\r\nplot(strategy.position_size > 0 ? calcLongTakeProfit() : na, \r\n     \"Long TP\", color=color.green, style=plot.style_linebr)\r\nplot(strategy.position_size < 0 ? calcShortStopPrice() : na, \r\n     \"Short Stop\", color=color.red, style=plot.style_linebr)\r\nplot(strategy.position_size < 0 ? calcShortTakeProfit() : na, \r\n     \"Short TP\", color=color.green, style=plot.style_linebr)\r\n\r\n// ÐžÑ‚Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ Ñ‚Ð¾Ñ‡ÐµÐº Ð²Ñ…Ð¾Ð´Ð°\r\nplotshape(longSignal and strategy.position_size == 0 ? low : na, \r\n          \"Long Entry\", shape.triangleup, location.belowbar, color=color.green, size=size.small)\r\nplotshape(shortSignal and strategy.position_size == 0 ? high : na, \r\n          \"Short Entry\", shape.triangledown, location.abovebar, color=color.red, size=size.small)"
  },
  {
    "url": "0rVYn2c4",
    "name": "Qullamagi EMA Breakout Autotrade (Crypto Futures L+S)",
    "description": "Title:  Qullamagi EMA Breakout â€“ Crypto Autotrade \n\n Overview \n\n A crypto-focused, Qullamagi-style EMA breakout strategy built for autotrading on futures and perpetual swaps. \n\nIt combines a 5-MA trend stack (EMA 10/20, SMA 50/100/200), volatility contraction boxes, volume spikes and an optional higher-timeframe 200-MA filter. The script supports both long and short trades, partial take profit, trailing MA exits and percent-of-equity position sizing for automated crypto futures trading.\n\n Key Features (Crypto) \n \n Qullamagi MA Breakout Engine  â€“ trades only when price is aligned with a strong EMA/SMA trend and breaks out of a tight consolidation range. Longs use: Close > EMA10 > EMA20 > SMA50 > SMA100 > SMA200. Shorts are the mirror condition with all MAs sloping in the trend direction.\n Strict vs Loose Modes  â€“ Strict (Daily) is designed for cleaner swing trades on 1Hâ€“4H (full MA stack, box+ATR and volume filters, optional HTF filter). Loose (Intraday) focuses on 10/20/50 alignment with relaxed filters for more frequent 15mâ€“30m signals.\n Volatility & Volume Filters for Crypto  â€“ ATR-based box height limit to detect volatility contraction, wide-candle filter to avoid chasing exhausted breakouts, and a volume spike condition requiring current volume to exceed an SMA of volume.\n Higher-Timeframe Trend Filter (Optional)  â€“ uses a 200-period SMA on a higher timeframe (default: 1D). Longs only when HTF close is above the HTF 200-SMA, shorts only when it is below, helping avoid trading against dominant crypto trends.\n Autotrade-Oriented Trade Management  â€“ position size as % of equity, initial stop anchored to a chosen MA (EMA10 / EMA20 / SMA50) with optional buffer, partial take profit at a configurable R-multiple, trailing MA exit for the remainder, and an optional cooldown after a full exit.\n \n\n Markets & Timeframes \n \n Best suited for BTC, ETH and major altcoin futures/perpetuals (Binance, Bybit, OKX, etc.).\n Strict preset: 1Hâ€“4H charts for classic Qullamagi-style trend structure and fewer fake breakouts.\n Loose preset: 15mâ€“30m charts for higher trade frequency and more active intraday trading.\n Always retune ATR length, box length, volume multiplier and position size for each symbol and exchange.\n \n\n Strategy Logic (Quick Summary) \n \n Long (Strict):  MA stack in bullish alignment with all MAs sloping up â†’ tight volatility box (ATR-based) â†’ volume spike above SMA(volume) Ã— multiplier â†’ breakout above box high (close or intrabar) â†’ optional HTF close above 200-SMA.\n\n Short:  Mirror logic: bearish MA stack, tight box, volume spike and breakdown below box low with optional HTF downtrend.\n \n\n Best Practices for Crypto \n \n Backtest on each symbol and timeframe you plan to autotrade, including commissions and slippage.\n Start on higher timeframes (1H/4H) to learn the behavior, then move to 15mâ€“30m if you want more signals.\n Use the higher-timeframe filter when markets are strongly trending to reduce counter-trend trades.\n Keep position-size percentage conservative until you fully understand the drawdowns.\n Forward-test / paper trade before connecting to live futures accounts.\n \n\n Webhook / Autotrade Integration \n \n Designed to work with TradingView webhooks and external crypto trading bots.\n Alert messages include structured fields such as: EVENT=ENTRY / SCALE_OUT / EXIT, SIDE=LONG / SHORT, STRATEGY=Qullamagi_MA.\n Map each EVENT + SIDE combination to your bot logic (open long/short, partial close, full close, etc.) on your preferred exchange.\n \n\n Important Notes & Disclaimer \n \nCrypto markets are highly volatile and can change regime quickly. Backtest and forward-test thoroughly before using real capital. Higher timeframes generally produce cleaner MA structures and fewer fake breakouts.\n\nThis strategy is for educational and informational purposes only and does not constitute financial advice. Trading leveraged crypto products involves substantial risk of loss. Always do your own research, manage risk carefully, and never trade with money you cannot afford to lose.\n \n",
    "image_url": "0rVYn2c4",
    "author": "asefzxizexvsadf",
    "likes": 46,
    "type": "strategy",
    "created": "2025-11-28",
    "updated": "2025-11-28",
    "source": "//@version=6\r\n//@strategy_alert_message {{strategy.order.alert_message}};TICKER={{ticker}};TF={{interval}};PRICE={{strategy.order.price}};QTY={{strategy.order.contracts}};TIME={{timenow}}\r\nstrategy(\"Qullamaggie MA Breakout L+S v2.5\",\r\n     overlay = true,\r\n     initial_capital = 100000,\r\n     pyramiding = 0,\r\n     calc_on_order_fills = false,\r\n     calc_on_every_tick = false,\r\n     max_labels_count = 500)\r\n\r\n// ========= Quick Preset =========\r\ngrpPreset   = \"Quick Preset\"\r\npreset      = input.string(\"Loose (Intraday)\", \"Mode\", options = [\"Strict (Daily)\", \"Loose (Intraday)\"], group = grpPreset)\r\nshowDebug   = input.bool(true, \"Show Entry/Exit Markers\", group = grpPreset)\r\nshowStats   = input.bool(true, \"Show Performance Stats Table\", group = grpPreset)\r\n\r\n// ========= Backtest Date Range =========\r\ngrpDate = \"Backtest Date Range\"\r\nuseStartDate = input.bool(true, \"Use Start Date\", group = grpDate)\r\nstartYear = input.int(2018, \"Start Year\", minval=2000, maxval=2100, group=grpDate)\r\nstartMonth = input.int(1, \"Start Month\", minval=1, maxval=12, group=grpDate)\r\nstartDay = input.int(1, \"Start Day\", minval=1, maxval=31, group=grpDate)\r\n\r\nuseEndDate = input.bool(false, \"Use End Date\", group = grpDate)\r\nendYear = input.int(2025, \"End Year\", minval=2000, maxval=2100, group=grpDate)\r\nendMonth = input.int(12, \"End Month\", minval=1, maxval=12, group=grpDate)\r\nendDay = input.int(31, \"End Day\", minval=1, maxval=31, group=grpDate)\r\n\r\n// ========= Moving Averages =========\r\ngrpMA    = \"Moving Averages\"\r\nlen10    = input.int(10,  \"1st MA (Fastest)\",  group = grpMA, minval = 1)\r\nlen20    = input.int(20,  \"2nd MA\",            group = grpMA, minval = 1)\r\nlen50    = input.int(50,  \"3rd MA\",            group = grpMA, minval = 1)\r\nlen100   = input.int(100, \"4th MA\",            group = grpMA, minval = 1)\r\nlen200   = input.int(200, \"5th MA (Slowest)\",  group = grpMA, minval = 1)\r\n\r\n// ========= Trend Filter =========\r\ngrpFilt         = \"Trend Filter\"\r\nusePerfectOrder = input.bool(true,  \"Require Perfect Order (Long: 1>2>3>4>5 / Short: Reverse)\", group = grpFilt)\r\nrequireSlope    = input.bool(true,  \"Require All MA Slopes Aligned (Long=Up, Short=Down)\",  group = grpFilt)\r\n\r\n// ========= ADX Trend Strength Filter =========\r\ngrpADX       = \"ADX Trend Strength Filter\"\r\nuseADX       = input.bool(true, \"Use ADX Filter\", group = grpADX)\r\nadxLen       = input.int(14, \"ADX Length\", group = grpADX, minval = 1)\r\nadxMinLong   = input.float(20.0, \"Min ADX for Long\", group = grpADX, minval = 0, step = 1)\r\nadxMinShort  = input.float(25.0, \"Min ADX for Short (Stricter)\", group = grpADX, minval = 0, step = 1)\r\nadxMaxEntry  = input.float(50.0, \"Max ADX (Exclude Overheated)\", group = grpADX, minval = 30, step = 1)\r\n\r\n// ========= RSI Filter =========\r\ngrpRSI       = \"RSI Filter\"\r\nuseRSI       = input.bool(false, \"Use RSI Filter\", group = grpRSI)\r\nrsiLen       = input.int(14, \"RSI Length\", group = grpRSI, minval = 1)\r\nrsiOBLevel   = input.float(70.0, \"Exclude Long Above RSI (Overbought)\", group = grpRSI, minval = 50, step = 1)\r\nrsiOSLevel   = input.float(30.0, \"Exclude Short Below RSI (Oversold)\", group = grpRSI, minval = 10, step = 1)\r\n\r\n// ========= Higher Timeframe Trend Filter =========\r\ngrpHTF       = \"Higher Timeframe Trend Filter\"\r\nuseHtfTrend  = input.bool(false, \"Use HTF Trend Filter\", group = grpHTF)\r\nhtfTf        = input.timeframe(\"D\", \"HTF Timeframe\", group = grpHTF)\r\nhtfMaLen     = input.int(200, \"HTF MA Length\", group = grpHTF, minval = 1)\r\n\r\n// ========= Box (Base) & Breakout =========\r\ngrpBase          = \"Box (Base) & Breakout\"\r\nuseBaseFilter    = input.bool(false,  \"Use Box/Contraction Filter\", group = grpBase)\r\nbaseLen          = input.int(10,      \"Box Length (Bars)\",      group = grpBase, minval = 5)\r\nbaseAtrLen       = input.int(14,      \"ATR Length\",           group = grpBase, minval = 1)\r\nbaseAtrMult      = input.float(2.0,   \"Box Height <= ATR x\",   group = grpBase, step = 0.1)\r\nmustHoldAbove50  = input.bool(false,  \"Box Must Hold Above 3rd MA (Long)\", group = grpBase)\r\nuseBreakoutClose = input.bool(true,   \"Confirm Breakout on Close\", group = grpBase)\r\n\r\n// ========= Pullback Entry =========\r\ngrpPullback       = \"Pullback Entry\"\r\nusePullbackEntry  = input.bool(true, \"Allow Pullback Entry\", group = grpPullback)\r\npullbackMA        = input.string(\"2nd MA\", \"Pullback Reference Line\", options = [\"1st MA\",\"2nd MA\",\"3rd MA\"], group = grpPullback)\r\npullbackLookback  = input.int(20, \"Recent Breakout Lookback (Bars)\", group = grpPullback, minval = 5, maxval = 50)\r\nrequireBounce     = input.bool(true, \"Require Bounce Candle (Close > Open)\", group = grpPullback)\r\npullbackAtrMult   = input.float(0.5, \"MA Proximity Tolerance (ATR x)\", group = grpPullback, step = 0.1)\r\n\r\n// ========= Volume Filter =========\r\ngrpVol        = \"Volume Filter\"\r\nuseVolFilter  = input.bool(true,   \"Use Volume Filter\", group = grpVol)\r\nvolLen        = input.int(20,      \"Volume SMA Length\", group = grpVol, minval = 1)\r\nvolMult       = input.float(1.2,   \"Volume Spike Multiplier (> SMA x)\", group = grpVol, step = 0.1)\r\npullbackVolMult = input.float(0.8, \"Pullback Volume Multiplier (Lower)\", group = grpVol, step = 0.1)\r\n\r\n// ========= Entry Additional Filter =========\r\ngrpEntry          = \"Entry Additional Filter\"\r\nuseWideCandleFilt = input.bool(true, \"Exclude Wide Breakout Candles (ATR Based)\", group = grpEntry)\r\nmaxBreakoutAtr    = input.float(2.5, \"Max Breakout Candle Range <= ATR x\", group = grpEntry, step = 0.1)\r\n\r\n// ========= Entry & Exit (Risk) =========\r\ngrpRisk        = \"Entry & Exit\"\r\ntrailMALen     = input.int(20, \"Trailing Stop MA Length\", group = grpRisk, minval = 1)\r\ntrailMAType    = input.string(\"EMA\", \"Trailing Stop MA Type\", options = [\"EMA\", \"SMA\"], group = grpRisk)\r\nstopBufferPct  = input.float(0.3,  \"Stop Buffer (Long=Below, Short=Above, %)\", step = 0.1, group = grpRisk)\r\nuseScaleOut    = input.bool(true,  \"Use Partial Take Profit (Scale Out)\", group = grpRisk)\r\nscaleRR        = input.float(1.0,  \"Scale Out RR (Risk Multiple)\", step = 0.1, group = grpRisk)\r\nscaleQtyPct    = input.float(10.0, \"Scale Out Qty (%)\", step = 1, group = grpRisk, minval = 1, maxval = 100)\r\nposSizePct     = input.float(20.0, \"Position Size (% of Equity)\", step = 1, group = grpRisk, minval = 1, maxval = 100)\r\n\r\n// ========= Hard Stop (Max Loss) =========\r\ngrpHardStop      = \"Hard Stop (Max Loss)\"\r\nuseHardStop      = input.bool(true, \"Use Hard Stop\", group = grpHardStop)\r\nhardStopPct      = input.float(2.5, \"Max Loss % (From Entry)\", group = grpHardStop, step = 0.1)\r\n\r\n// ========= Time Based Exit =========\r\ngrpTimeExit     = \"Time Based Exit\"\r\nuseTimeExit     = input.bool(false, \"Use Time Based Exit\", group = grpTimeExit)\r\nmaxBarsInTrade  = input.int(48, \"Max Bars in Trade (If Losing)\", group = grpTimeExit, minval = 10)\r\n\r\n// ========= Breakeven Stop =========\r\ngrpBE          = \"Breakeven Stop\"\r\nuseBreakeven   = input.bool(true,  \"Use Breakeven Stop\", group = grpBE)\r\nbeActivateRR   = input.float(0.8,  \"BE Activation RR\", step = 0.1, group = grpBE)\r\nbeOffsetPct    = input.float(0.1,  \"BE Offset (%)\", step = 0.05, group = grpBE)\r\n\r\n// ========= Position Direction & Cooldown =========\r\ngrpRisk2      = \"Position Direction & Cooldown\"\r\ntradeLong     = input.bool(true,  \"Allow Long\", group = grpRisk2)\r\ntradeShort    = input.bool(true,  \"Allow Short\", group = grpRisk2)\r\ncooldownBars  = input.int(3, \"Cooldown After Exit (Bars, 0=Disabled)\", group = grpRisk2, minval = 0)\r\n\r\n// ========= Short Only Strict Filter =========\r\ngrpShortFilter      = \"Short Only Strict Filter\"\r\nshortRequireHTF     = input.bool(false, \"Short Requires HTF Downtrend\", group = grpShortFilter)\r\nshortMinConsecRed   = input.int(2, \"Min Consecutive Red Candles Before Short\", group = grpShortFilter, minval = 0, maxval = 5)\r\nshortRequireMA5Below = input.bool(false, \"Short Requires Price Below 5th MA\", group = grpShortFilter)\r\n\r\n// ========= Calculate Moving Averages =========\r\nma1  = ta.ema(close, len10)\r\nma2  = ta.ema(close, len20)\r\nma3  = ta.sma(close, len50)\r\nma4  = ta.sma(close, len100)\r\nma5  = ta.sma(close, len200)\r\n\r\n// ========= ADX Calculation =========\r\n[diPlus, diMinus, adxValue] = ta.dmi(adxLen, adxLen)\r\nadxOK_long  = (not useADX) or (adxValue >= adxMinLong and adxValue <= adxMaxEntry)\r\nadxOK_short = (not useADX) or (adxValue >= adxMinShort and adxValue <= adxMaxEntry)\r\n\r\n// ========= RSI Calculation =========\r\nrsiValue = ta.rsi(close, rsiLen)\r\nrsiOK_long  = (not useRSI) or (rsiValue < rsiOBLevel)\r\nrsiOK_short = (not useRSI) or (rsiValue > rsiOSLevel)\r\n\r\n// ========= Trend / Perfect Order =========\r\nperfectOrder_long_strict = close > ma1 and ma1 > ma2 and ma2 > ma3 and ma3 > ma4 and ma4 > ma5\r\nslopeUpAll               = ma1 > ma1[1] and ma2 > ma2[1] and ma3 > ma3[1] and ma4 > ma4[1] and ma5 > ma5[1]\r\ntrendOK_long_strict      = (not usePerfectOrder or perfectOrder_long_strict) and (not requireSlope or slopeUpAll)\r\n\r\nperfectOrder_short_strict = close < ma1 and ma1 < ma2 and ma2 < ma3 and ma3 < ma4 and ma4 < ma5\r\nslopeDownAll              = ma1 < ma1[1] and ma2 < ma2[1] and ma3 < ma3[1] and ma4 < ma4[1] and ma5 < ma5[1]\r\ntrendOK_short_strict      = (not usePerfectOrder or perfectOrder_short_strict) and (not requireSlope or slopeDownAll)\r\n\r\nperfectOrder_long_loose  = close > ma1 and ma1 > ma2 and ma2 > ma3\r\ntrendOK_long_loose       = perfectOrder_long_loose\r\n\r\nperfectOrder_short_loose = close < ma1 and ma1 < ma2 and ma2 < ma3\r\ntrendOK_short_loose      = perfectOrder_short_loose\r\n\r\n// ========= Pullback Relaxed Trend Conditions =========\r\nperfectOrder_long_pullback  = ma1 > ma2 and ma2 > ma3 and ma3 > ma4 and ma4 > ma5\r\ntrendOK_long_pullback       = (not usePerfectOrder or perfectOrder_long_pullback)\r\n\r\nperfectOrder_short_pullback = ma1 < ma2 and ma2 < ma3 and ma3 < ma4 and ma4 < ma5\r\ntrendOK_short_pullback      = (not usePerfectOrder or perfectOrder_short_pullback)\r\n\r\nperfectOrder_long_pullback_loose  = ma1 > ma2 and ma2 > ma3\r\ntrendOK_long_pullback_loose       = perfectOrder_long_pullback_loose\r\n\r\nperfectOrder_short_pullback_loose = ma1 < ma2 and ma2 < ma3\r\ntrendOK_short_pullback_loose      = perfectOrder_short_pullback_loose\r\n\r\n// ========= Higher Timeframe Trend Filter =========\r\nhtfClose = request.security(syminfo.tickerid, htfTf, close)\r\nhtfMa    = ta.sma(htfClose, htfMaLen)\r\nhtfUp    = htfClose > htfMa\r\nhtfDown  = htfClose < htfMa\r\n\r\nhtfOK_long  = (not useHtfTrend) or htfUp\r\nhtfOK_short = (not useHtfTrend) or htfDown\r\n\r\n// ========= Short Only Extra Filter =========\r\nconsecRedCandles = 0\r\nfor i = 1 to shortMinConsecRed\r\n    if close[i] < open[i]\r\n        consecRedCandles += 1\r\n\r\nshortConsecRedOK = shortMinConsecRed == 0 or consecRedCandles >= shortMinConsecRed\r\nshortBelowMA5 = (not shortRequireMA5Below) or close < ma5\r\nshortHTFRequired = (not shortRequireHTF) or htfDown\r\nshortExtraFilter = shortConsecRedOK and shortBelowMA5 and shortHTFRequired\r\n\r\n// ========= Box & Breakout =========\r\nboxHi   = ta.highest(high, baseLen)[1]\r\nboxLo   = ta.lowest(low,  baseLen)[1]\r\nboxHgt  = boxHi - boxLo\r\natrVal  = ta.atr(baseAtrLen)\r\ntightBox = boxHgt <= atrVal * baseAtrMult\r\nholdAbove50 = ta.lowest(low, baseLen)[1] > ma3[1]\r\n\r\nbreakoutCrossUp    = ta.crossover(close, boxHi)\r\nbreakoutIntraUp    = (high > boxHi) and (nz(close[1]) <= boxHi)\r\n\r\nbreakoutCrossDown  = ta.crossunder(close, boxLo)\r\nbreakoutIntraDown  = (low < boxLo) and (nz(close[1]) >= boxLo)\r\n\r\nbaseOK_strict = (not useBaseFilter) or (tightBox and (not mustHoldAbove50 or holdAbove50))\r\nbaseOK_loose  = true\r\n\r\n// ========= Pullback Reference Line =========\r\npullbackLine = pullbackMA == \"1st MA\" ? ma1 : pullbackMA == \"2nd MA\" ? ma2 : ma3\r\n\r\n// ========= Recent Breakout Check =========\r\nhadRecentBreakoutUp   = ta.highest(high, pullbackLookback) > boxHi\r\nhadRecentBreakoutDown = ta.lowest(low, pullbackLookback) < boxLo\r\n\r\n// ========= Pullback Conditions =========\r\nnearPullbackLineLong  = low <= pullbackLine * (1 + pullbackAtrMult * atrVal / close) and low >= pullbackLine * (1 - pullbackAtrMult * atrVal / close)\r\nbounceUpCandle        = close > open\r\npullbackBounceOK_long = (not requireBounce) or bounceUpCandle\r\ncloseAbovePullbackLine = close > pullbackLine\r\npullbackLongCond = usePullbackEntry and nearPullbackLineLong and pullbackBounceOK_long and closeAbovePullbackLine and hadRecentBreakoutUp\r\n\r\nnearPullbackLineShort  = high >= pullbackLine * (1 - pullbackAtrMult * atrVal / close) and high <= pullbackLine * (1 + pullbackAtrMult * atrVal / close)\r\nbounceDownCandle       = close < open\r\npullbackBounceOK_short = (not requireBounce) or bounceDownCandle\r\ncloseBelowPullbackLine = close < pullbackLine\r\npullbackShortCond = usePullbackEntry and nearPullbackLineShort and pullbackBounceOK_short and closeBelowPullbackLine and hadRecentBreakoutDown\r\n\r\n// ========= Volume Filter =========\r\nvolSma       = ta.sma(volume, volLen)\r\nvolOK_strict = (not useVolFilter) or (volume > volSma * volMult)\r\nvolOK_loose  = (not useVolFilter) or (volume > volSma * 1.1)\r\nvolOK_pullback = (not useVolFilter) or (volume > volSma * pullbackVolMult)\r\n\r\n// ========= Wide Candle Filter =========\r\ncandleRange   = high - low\r\nwideCandleOK  = (not useWideCandleFilt) or (candleRange <= atrVal * maxBreakoutAtr)\r\n\r\n// ========= Cooldown =========\r\nvar int lastFlatBar = na\r\nif strategy.position_size[1] != 0 and strategy.position_size == 0\r\n    lastFlatBar := bar_index\r\n\r\ncooldownOK = (cooldownBars == 0) or na(lastFlatBar) or (bar_index - lastFlatBar > cooldownBars)\r\n\r\n// ========= Date Range Filter =========\r\nstartTime = timestamp(startYear, startMonth, startDay, 0, 0)\r\nendTime = timestamp(endYear, endMonth, endDay, 23, 59)\r\ninDateRange = (useStartDate ? time >= startTime : true) and (useEndDate ? time <= endTime : true)\r\n\r\n// ========= Entry Conditions by Mode =========\r\nenterLongBreakoutStrict = tradeLong and trendOK_long_strict and baseOK_strict and (useBreakoutClose ? breakoutCrossUp : breakoutIntraUp) and volOK_strict and htfOK_long and wideCandleOK and cooldownOK and adxOK_long and rsiOK_long and inDateRange\r\nenterLongBreakoutLoose  = tradeLong and trendOK_long_loose  and baseOK_loose  and breakoutIntraUp and volOK_loose and htfOK_long and wideCandleOK and cooldownOK and adxOK_long and rsiOK_long and inDateRange\r\nenterLongBreakout       = (preset == \"Strict (Daily)\" ? enterLongBreakoutStrict : enterLongBreakoutLoose)\r\n\r\nenterShortBreakoutStrict = tradeShort and trendOK_short_strict and baseOK_strict and (useBreakoutClose ? breakoutCrossDown : breakoutIntraDown) and volOK_strict and htfOK_short and wideCandleOK and cooldownOK and adxOK_short and rsiOK_short and shortExtraFilter and inDateRange\r\nenterShortBreakoutLoose  = tradeShort and trendOK_short_loose  and baseOK_loose  and breakoutIntraDown and volOK_loose and htfOK_short and wideCandleOK and cooldownOK and adxOK_short and rsiOK_short and shortExtraFilter and inDateRange\r\nenterShortBreakout       = (preset == \"Strict (Daily)\" ? enterShortBreakoutStrict : enterShortBreakoutLoose)\r\n\r\nenterLongPullbackStrict = tradeLong and trendOK_long_pullback and pullbackLongCond and volOK_pullback and htfOK_long and wideCandleOK and cooldownOK and adxOK_long and rsiOK_long and inDateRange\r\nenterLongPullbackLoose  = tradeLong and trendOK_long_pullback_loose and pullbackLongCond and volOK_pullback and htfOK_long and wideCandleOK and cooldownOK and adxOK_long and rsiOK_long and inDateRange\r\nenterLongPullback       = (preset == \"Strict (Daily)\" ? enterLongPullbackStrict : enterLongPullbackLoose)\r\n\r\nenterShortPullbackStrict = tradeShort and trendOK_short_pullback and pullbackShortCond and volOK_pullback and htfOK_short and wideCandleOK and cooldownOK and adxOK_short and rsiOK_short and shortExtraFilter and inDateRange\r\nenterShortPullbackLoose  = tradeShort and trendOK_short_pullback_loose and pullbackShortCond and volOK_pullback and htfOK_short and wideCandleOK and cooldownOK and adxOK_short and rsiOK_short and shortExtraFilter and inDateRange\r\nenterShortPullback       = (preset == \"Strict (Daily)\" ? enterShortPullbackStrict : enterShortPullbackLoose)\r\n\r\nenterLong  = (enterLongBreakout or enterLongPullback) and strategy.position_size == 0\r\nenterShort = (enterShortBreakout or enterShortPullback) and strategy.position_size == 0\r\n\r\n// ========= Trailing Stop Line =========\r\ntrailLine = trailMAType == \"EMA\" ? ta.ema(close, trailMALen) : ta.sma(close, trailMALen)\r\n\r\nstopLineLong  = trailLine * (1.0 - stopBufferPct / 100.0)\r\nstopLineShort = trailLine * (1.0 + stopBufferPct / 100.0)\r\n\r\n// ========= State Variables =========\r\nvar float entryPriceLong      = na\r\nvar float initStopLong        = na\r\nvar bool  scaledLong          = false\r\nvar string entryTypeLong      = na\r\nvar bool  beActivatedLong     = false\r\nvar int   barsInTradeLong     = 0\r\n\r\nvar float entryPriceShort     = na\r\nvar float initStopShort       = na\r\nvar bool  scaledShort         = false\r\nvar string entryTypeShort     = na\r\nvar bool  beActivatedShort    = false\r\nvar int   barsInTradeShort    = 0\r\n\r\n// ========= Performance Tracking Variables =========\r\nvar int long_wins = 0\r\nvar int long_losses = 0\r\nvar int short_wins = 0\r\nvar int short_losses = 0\r\nvar float[] trade_returns = array.new_float(0)\r\nvar float[] daily_returns = array.new_float(0)\r\nvar float start_price = na\r\nvar float prev_day_equity = strategy.initial_capital\r\nvar int prev_day = 0\r\n\r\n// ì‹œìž‘ ê°€ê²© ì €ìž¥\r\nif na(start_price) and strategy.position_size != 0\r\n    start_price := close\r\n\r\n// ê±°ëž˜ ì¢…ë£Œ ì‹œ ìˆ˜ìµë¥  ê¸°ë¡\r\nif strategy.closedtrades > strategy.closedtrades[1]\r\n    float exit_price = strategy.closedtrades.exit_price(strategy.closedtrades - 1)\r\n    float entry_price = strategy.closedtrades.entry_price(strategy.closedtrades - 1)\r\n    float trade_size = strategy.closedtrades.size(strategy.closedtrades - 1)\r\n    \r\n    float trade_pct = 0.0\r\n    if trade_size > 0  // ë¡±\r\n        trade_pct := entry_price != 0 ? (exit_price - entry_price) / entry_price * 100 : 0.0\r\n        if trade_pct > 0\r\n            long_wins += 1\r\n        else\r\n            long_losses += 1\r\n    else  // ìˆ\r\n        trade_pct := entry_price != 0 ? (entry_price - exit_price) / entry_price * 100 : 0.0\r\n        if trade_pct > 0\r\n            short_wins += 1\r\n        else\r\n            short_losses += 1\r\n    \r\n    array.push(trade_returns, trade_pct)\r\n\r\n// ì¼ê°„ ìˆ˜ìµë¥  ê¸°ë¡\r\nint current_day = dayofmonth(time)\r\nif current_day != prev_day\r\n    if prev_day != 0 and prev_day_equity > 0\r\n        float daily_ret = (strategy.equity - prev_day_equity) / prev_day_equity\r\n        array.push(daily_returns, daily_ret)\r\n    prev_day_equity := strategy.equity\r\n    prev_day := current_day\r\n\r\n// ========= Entry Orders =========\r\nif enterLong and strategy.position_size == 0\r\n    qty_value = strategy.equity * (posSizePct / 100.0) / close\r\n    entryType = enterLongBreakout ? \"BREAKOUT\" : \"PULLBACK\"\r\n    strategy.entry(\"LONG\", strategy.long, qty = qty_value,\r\n                   alert_message = \"EVENT=ENTRY;SIDE=LONG;TYPE=\" + entryType + \";STRATEGY=Qullamaggie_MA\")\r\n    entryTypeLong := entryType\r\n\r\nif enterShort and strategy.position_size == 0\r\n    qty_value = strategy.equity * (posSizePct / 100.0) / close\r\n    entryType = enterShortBreakout ? \"BREAKOUT\" : \"PULLBACK\"\r\n    strategy.entry(\"SHORT\", strategy.short, qty = qty_value,\r\n                   alert_message = \"EVENT=ENTRY;SIDE=SHORT;TYPE=\" + entryType + \";STRATEGY=Qullamaggie_MA\")\r\n    entryTypeShort := entryType\r\n\r\n// ========= Position Entry Variable Setup =========\r\njustEnteredLong = strategy.position_size > 0 and strategy.position_size[1] == 0\r\nif justEnteredLong\r\n    entryPriceLong  := strategy.position_avg_price\r\n    initStopLong    := stopLineLong\r\n    scaledLong      := false\r\n    beActivatedLong := false\r\n    barsInTradeLong := 0\r\n\r\njustEnteredShort = strategy.position_size < 0 and strategy.position_size[1] == 0\r\nif justEnteredShort\r\n    entryPriceShort  := strategy.position_avg_price\r\n    initStopShort    := stopLineShort\r\n    scaledShort      := false\r\n    beActivatedShort := false\r\n    barsInTradeShort := 0\r\n\r\n// ========= Bars in Trade Counter =========\r\nif strategy.position_size > 0\r\n    barsInTradeLong += 1\r\n\r\nif strategy.position_size < 0\r\n    barsInTradeShort += 1\r\n\r\n// Reset on Position Close\r\nif strategy.position_size == 0 and strategy.position_size[1] != 0\r\n    entryPriceLong   := na\r\n    initStopLong     := na\r\n    scaledLong       := false\r\n    entryTypeLong    := na\r\n    beActivatedLong  := false\r\n    barsInTradeLong  := 0\r\n\r\n    entryPriceShort  := na\r\n    initStopShort    := na\r\n    scaledShort      := false\r\n    entryTypeShort   := na\r\n    beActivatedShort := false\r\n    barsInTradeShort := 0\r\n\r\n// ========= Breakeven Stop Activation =========\r\nriskLong  = not na(entryPriceLong) and not na(initStopLong) ? entryPriceLong - initStopLong : na\r\nriskShort = not na(entryPriceShort) and not na(initStopShort) ? initStopShort - entryPriceShort : na\r\n\r\nbeTargetLong  = not na(riskLong) ? entryPriceLong + riskLong * beActivateRR : na\r\nbeTargetShort = not na(riskShort) ? entryPriceShort - riskShort * beActivateRR : na\r\n\r\nif useBreakeven and strategy.position_size > 0 and not beActivatedLong and not na(beTargetLong)\r\n    if high >= beTargetLong\r\n        beActivatedLong := true\r\n\r\nif useBreakeven and strategy.position_size < 0 and not beActivatedShort and not na(beTargetShort)\r\n    if low <= beTargetShort\r\n        beActivatedShort := true\r\n\r\n// ========= Breakeven Applied Stop Line =========\r\nbeStopLong  = not na(entryPriceLong) ? entryPriceLong * (1 + beOffsetPct / 100) : na\r\nbeStopShort = not na(entryPriceShort) ? entryPriceShort * (1 - beOffsetPct / 100) : na\r\n\r\nfinalStopLong  = beActivatedLong and not na(beStopLong) ? math.max(stopLineLong, beStopLong) : stopLineLong\r\nfinalStopShort = beActivatedShort and not na(beStopShort) ? math.min(stopLineShort, beStopShort) : stopLineShort\r\n\r\n// ========= Hard Stop Calculation =========\r\nhardStopLong  = not na(entryPriceLong) ? entryPriceLong * (1 - hardStopPct / 100) : na\r\nhardStopShort = not na(entryPriceShort) ? entryPriceShort * (1 + hardStopPct / 100) : na\r\n\r\neffectiveStopLong  = useHardStop and not na(hardStopLong) ? math.max(finalStopLong, hardStopLong) : finalStopLong\r\neffectiveStopShort = useHardStop and not na(hardStopShort) ? math.min(finalStopShort, hardStopShort) : finalStopShort\r\n\r\n// ========= Partial Take Profit (Long) =========\r\ncanScaleLong   = useScaleOut and strategy.position_size > 0 and not na(entryPriceLong) and not na(initStopLong) and (not scaledLong) and not na(riskLong) and riskLong > 0\r\ntarget1Long    = not na(riskLong) ? entryPriceLong + riskLong * scaleRR : na\r\nscaleCondLong  = canScaleLong and not na(target1Long) and close >= target1Long\r\n\r\nif scaleCondLong\r\n    strategy.close(\"LONG\", qty_percent = scaleQtyPct,\r\n                   alert_message = \"EVENT=SCALE_OUT;SIDE=LONG;STRATEGY=Qullamaggie_MA\")\r\n    scaledLong := true\r\n\r\n// ========= Partial Take Profit (Short) =========\r\ncanScaleShort  = useScaleOut and strategy.position_size < 0 and not na(entryPriceShort) and not na(initStopShort) and (not scaledShort) and not na(riskShort) and riskShort > 0\r\ntarget1Short   = not na(riskShort) ? entryPriceShort - riskShort * scaleRR : na\r\nscaleCondShort = canScaleShort and not na(target1Short) and close <= target1Short\r\n\r\nif scaleCondShort\r\n    strategy.close(\"SHORT\", qty_percent = scaleQtyPct,\r\n                   alert_message = \"EVENT=SCALE_OUT;SIDE=SHORT;STRATEGY=Qullamaggie_MA\")\r\n    scaledShort := true\r\n\r\n// ========= Time Based Exit =========\r\ntimeExitLong  = useTimeExit and strategy.position_size > 0 and barsInTradeLong >= maxBarsInTrade and not na(entryPriceLong) and close < entryPriceLong\r\ntimeExitShort = useTimeExit and strategy.position_size < 0 and barsInTradeShort >= maxBarsInTrade and not na(entryPriceShort) and close > entryPriceShort\r\n\r\n// ========= Final Exit =========\r\nexitLong  = strategy.position_size > 0 and (close < effectiveStopLong or timeExitLong)\r\nexitShort = strategy.position_size < 0 and (close > effectiveStopShort or timeExitShort)\r\n\r\nif exitLong\r\n    strategy.close(\"LONG\",\r\n                   alert_message = \"EVENT=EXIT;SIDE=LONG;STRATEGY=Qullamaggie_MA\")\r\n\r\nif exitShort\r\n    strategy.close(\"SHORT\",\r\n                   alert_message = \"EVENT=EXIT;SIDE=SHORT;STRATEGY=Qullamaggie_MA\")\r\n\r\n// ========= Exit Type Classification =========\r\nexitLongTP   = exitLong  and not na(entryPriceLong)  and close >= entryPriceLong\r\nexitLongSL   = exitLong  and not na(entryPriceLong)  and close <  entryPriceLong\r\nexitShortTP  = exitShort and not na(entryPriceShort) and close <= entryPriceShort\r\nexitShortSL  = exitShort and not na(entryPriceShort) and close >  entryPriceShort\r\n\r\n// ========= Statistics Functions =========\r\nf_avg(arr) =>\r\n    array.size(arr) > 0 ? array.avg(arr) : 0.0\r\n\r\nf_stdev(arr) =>\r\n    array.size(arr) > 1 ? array.stdev(arr) : 0.0\r\n\r\nf_downside_std(arr) =>\r\n    cnt = array.size(arr)\r\n    if cnt > 1\r\n        neg_arr = array.new_float(0)\r\n        for i = 0 to cnt - 1\r\n            val = array.get(arr, i)\r\n            if val < 0\r\n                array.push(neg_arr, val)\r\n        array.size(neg_arr) > 1 ? array.stdev(neg_arr) : 0.0\r\n    else\r\n        0.0\r\n\r\nf_skewness(arr, avg, std) =>\r\n    cnt = array.size(arr)\r\n    if cnt > 0 and std > 0.000001\r\n        sum_cube_diff = 0.0\r\n        for i = 0 to cnt - 1\r\n            diff = array.get(arr, i) - avg\r\n            sum_cube_diff += math.pow(diff, 3)\r\n        (sum_cube_diff / cnt) / math.pow(std, 3)\r\n    else\r\n        0.0\r\n\r\nf_sharpe(arr) =>\r\n    cnt = array.size(arr)\r\n    if cnt > 1\r\n        avg_ret = array.avg(arr)\r\n        std_ret = array.stdev(arr)\r\n        std_ret > 0 ? (avg_ret / std_ret) * math.sqrt(252.0) : 0.0\r\n    else\r\n        0.0\r\n\r\nf_sortino(arr) =>\r\n    cnt = array.size(arr)\r\n    if cnt > 1\r\n        avg_ret = array.avg(arr)\r\n        down_std = f_downside_std(arr)\r\n        down_std > 0 ? (avg_ret / down_std) * math.sqrt(252.0) : 0.0\r\n    else\r\n        0.0\r\n\r\n// ========= Plots =========\r\nplot(ma1,  \"1st MA (Fast)\",  color = #00C853, linewidth = 2)\r\nplot(ma2,  \"2nd MA\",         color = #1DE9B6, linewidth = 2)\r\nplot(ma3,  \"3rd MA\",         color = #2962FF, linewidth = 2)\r\nplot(ma4,  \"4th MA\",         color = #7C4DFF, linewidth = 2)\r\nplot(ma5,  \"5th MA (Slow)\",  color = #FF6D00, linewidth = 2)\r\n\r\nplot(useBaseFilter ? boxHi : na, \"Box High\", color = color.new(color.gray, 40), style = plot.style_linebr)\r\nplot(useBaseFilter ? boxLo : na, \"Box Low\",  color = color.new(color.gray, 70), style = plot.style_linebr)\r\n\r\nstopLinePlot = strategy.position_size > 0 ? effectiveStopLong : strategy.position_size < 0 ? effectiveStopShort : na\r\nplot(stopLinePlot, \"Trailing Stop\", color = color.new(color.red, 0), linewidth = 2)\r\n\r\nhardStopPlot = strategy.position_size > 0 ? hardStopLong : strategy.position_size < 0 ? hardStopShort : na\r\nplot(useHardStop ? hardStopPlot : na, \"Hard Stop\", color = color.new(color.orange, 0), style = plot.style_linebr, linewidth = 1)\r\n\r\nbePlot = strategy.position_size > 0 and beActivatedLong ? beStopLong : \r\n         strategy.position_size < 0 and beActivatedShort ? beStopShort : na\r\nplot(bePlot, \"BE Stop\", color = color.new(color.lime, 0), style = plot.style_circles, linewidth = 2)\r\n\r\ntp1Plot = strategy.position_size > 0 and not scaledLong ? target1Long :\r\n          strategy.position_size < 0 and not scaledShort ? target1Short : na\r\nplot(tp1Plot, \"TP1 Target\", color = color.new(color.yellow, 0), style = plot.style_linebr, linewidth = 1)\r\n\r\nplot(usePullbackEntry ? pullbackLine : na, \"Pullback Line\", color = color.new(color.aqua, 50), style = plot.style_circles)\r\n\r\n// ========= Markers =========\r\nplotshape(enterLongBreakout and strategy.position_size[1] == 0 and showDebug,\r\n          title = \"ENTRY LONG BREAKOUT\", style = shape.triangleup, location = location.belowbar,\r\n          text = \"BRK\", size = size.large, color = color.new(color.lime, 0), textcolor = color.black)\r\n\r\nplotshape(enterShortBreakout and strategy.position_size[1] == 0 and showDebug,\r\n          title = \"ENTRY SHORT BREAKOUT\", style = shape.triangledown, location = location.abovebar,\r\n          text = \"BRK\", size = size.large, color = color.new(color.red, 0), textcolor = color.white)\r\n\r\nplotshape(enterLongPullback and strategy.position_size[1] == 0 and showDebug,\r\n          title = \"ENTRY LONG PULLBACK\", style = shape.triangleup, location = location.belowbar,\r\n          text = \"PB\", size = size.large, color = color.new(color.aqua, 0), textcolor = color.black)\r\n\r\nplotshape(enterShortPullback and strategy.position_size[1] == 0 and showDebug,\r\n          title = \"ENTRY SHORT PULLBACK\", style = shape.triangledown, location = location.abovebar,\r\n          text = \"PB\", size = size.large, color = color.new(color.fuchsia, 0), textcolor = color.white)\r\n\r\nplotshape(scaleCondLong and showDebug,\r\n          title = \"TP1 LONG\", style = shape.diamond, location = location.abovebar,\r\n          text = \"TP1\", size = size.small, color = color.new(color.yellow, 0), textcolor = color.black)\r\n\r\nplotshape(scaleCondShort and showDebug,\r\n          title = \"TP1 SHORT\", style = shape.diamond, location = location.belowbar,\r\n          text = \"TP1\", size = size.small, color = color.new(color.yellow, 0), textcolor = color.black)\r\n\r\nplotshape(beActivatedLong and beActivatedLong[1] == false and showDebug,\r\n          title = \"BE ACTIVATED LONG\", style = shape.circle, location = location.abovebar,\r\n          text = \"BE\", size = size.tiny, color = color.new(color.lime, 0), textcolor = color.white)\r\n\r\nplotshape(beActivatedShort and beActivatedShort[1] == false and showDebug,\r\n          title = \"BE ACTIVATED SHORT\", style = shape.circle, location = location.belowbar,\r\n          text = \"BE\", size = size.tiny, color = color.new(color.lime, 0), textcolor = color.white)\r\n\r\nplotshape(exitLongTP and showDebug,\r\n          title = \"TP2 LONG\", style = shape.flag, location = location.abovebar,\r\n          text = \"TP2\", size = size.small, color = color.new(color.teal, 0), textcolor = color.white)\r\n\r\nplotshape(exitShortTP and showDebug,\r\n          title = \"TP2 SHORT\", style = shape.flag, location = location.belowbar,\r\n          text = \"TP2\", size = size.small, color = color.new(color.teal, 0), textcolor = color.white)\r\n\r\nplotshape(exitLongSL and showDebug,\r\n          title = \"SL LONG\", style = shape.xcross, location = location.belowbar,\r\n          text = \"SL\", size = size.tiny, color = color.new(color.orange, 0), textcolor = color.white)\r\n\r\nplotshape(exitShortSL and showDebug,\r\n          title = \"SL SHORT\", style = shape.xcross, location = location.abovebar,\r\n          text = \"SL\", size = size.tiny, color = color.new(color.orange, 0), textcolor = color.white)\r\n\r\nplotshape(timeExitLong and showDebug,\r\n          title = \"TIME EXIT LONG\", style = shape.xcross, location = location.belowbar,\r\n          text = \"TIME\", size = size.tiny, color = color.new(color.purple, 0), textcolor = color.white)\r\n\r\nplotshape(timeExitShort and showDebug,\r\n          title = \"TIME EXIT SHORT\", style = shape.xcross, location = location.abovebar,\r\n          text = \"TIME\", size = size.tiny, color = color.new(color.purple, 0), textcolor = color.white)\r\n\r\n// ========= Debug Table (Right Side - Middle) =========\r\nvar table debugTable = table.new(position.bottom_right, 2, 14, bgcolor = color.new(color.black, 80))\r\n\r\nif barstate.islast and showDebug\r\n    table.cell(debugTable, 0, 0, \"Entry Type\", text_color = color.white)\r\n    table.cell(debugTable, 1, 0, strategy.position_size > 0 ? (na(entryTypeLong) ? \"N/A\" : entryTypeLong) : strategy.position_size < 0 ? (na(entryTypeShort) ? \"N/A\" : entryTypeShort) : \"None\", text_color = color.aqua)\r\n    \r\n    table.cell(debugTable, 0, 1, \"Entry Price\", text_color = color.white)\r\n    table.cell(debugTable, 1, 1, strategy.position_size > 0 ? str.tostring(entryPriceLong, \"#.##\") : strategy.position_size < 0 ? str.tostring(entryPriceShort, \"#.##\") : \"N/A\", text_color = color.lime)\r\n    \r\n    table.cell(debugTable, 0, 2, \"Init Stop\", text_color = color.white)\r\n    table.cell(debugTable, 1, 2, strategy.position_size > 0 ? str.tostring(initStopLong, \"#.##\") : strategy.position_size < 0 ? str.tostring(initStopShort, \"#.##\") : \"N/A\", text_color = color.red)\r\n    \r\n    table.cell(debugTable, 0, 3, \"Risk (R)\", text_color = color.white)\r\n    table.cell(debugTable, 1, 3, strategy.position_size > 0 ? str.tostring(riskLong, \"#.##\") : strategy.position_size < 0 ? str.tostring(riskShort, \"#.##\") : \"N/A\", text_color = color.yellow)\r\n    \r\n    table.cell(debugTable, 0, 4, \"TP1 Target\", text_color = color.white)\r\n    table.cell(debugTable, 1, 4, strategy.position_size > 0 ? str.tostring(target1Long, \"#.##\") : strategy.position_size < 0 ? str.tostring(target1Short, \"#.##\") : \"N/A\", text_color = color.yellow)\r\n    \r\n    table.cell(debugTable, 0, 5, \"Scaled Out\", text_color = color.white)\r\n    table.cell(debugTable, 1, 5, strategy.position_size > 0 ? str.tostring(scaledLong) : strategy.position_size < 0 ? str.tostring(scaledShort) : \"N/A\", text_color = color.yellow)\r\n    \r\n    table.cell(debugTable, 0, 6, \"BE Active\", text_color = color.white)\r\n    table.cell(debugTable, 1, 6, strategy.position_size > 0 ? str.tostring(beActivatedLong) : strategy.position_size < 0 ? str.tostring(beActivatedShort) : \"N/A\", text_color = color.lime)\r\n    \r\n    table.cell(debugTable, 0, 7, \"Current Price\", text_color = color.white)\r\n    table.cell(debugTable, 1, 7, str.tostring(close, \"#.##\"), text_color = color.white)\r\n    \r\n    table.cell(debugTable, 0, 8, \"Current Stop\", text_color = color.white)\r\n    table.cell(debugTable, 1, 8, strategy.position_size > 0 ? str.tostring(effectiveStopLong, \"#.##\") : strategy.position_size < 0 ? str.tostring(effectiveStopShort, \"#.##\") : \"N/A\", text_color = color.red)\r\n    \r\n    table.cell(debugTable, 0, 9, \"Hard Stop\", text_color = color.white)\r\n    table.cell(debugTable, 1, 9, strategy.position_size > 0 ? str.tostring(hardStopLong, \"#.##\") : strategy.position_size < 0 ? str.tostring(hardStopShort, \"#.##\") : \"N/A\", text_color = color.orange)\r\n    \r\n    table.cell(debugTable, 0, 10, \"Bars in Trade\", text_color = color.white)\r\n    table.cell(debugTable, 1, 10, strategy.position_size > 0 ? str.tostring(barsInTradeLong) : strategy.position_size < 0 ? str.tostring(barsInTradeShort) : \"0\", text_color = color.white)\r\n    \r\n    table.cell(debugTable, 0, 11, \"ADX\", text_color = color.white)\r\n    table.cell(debugTable, 1, 11, str.tostring(adxValue, \"#.#\"), text_color = color.yellow)\r\n    \r\n    table.cell(debugTable, 0, 12, \"RSI\", text_color = color.white)\r\n    table.cell(debugTable, 1, 12, str.tostring(rsiValue, \"#.#\"), text_color = color.yellow)\r\n    \r\n    table.cell(debugTable, 0, 13, \"ATR\", text_color = color.white)\r\n    table.cell(debugTable, 1, 13, str.tostring(atrVal, \"#.##\"), text_color = color.yellow)\r\n\r\n// ========= Performance Stats Table (Right Side) =========\r\nvar table statsTable = na\r\nif showStats and na(statsTable)\r\n    statsTable := table.new(position.top_right, 4, 12, bgcolor = color.new(color.black, 80), border_width = 1, border_color = color.new(color.gray, 0))\r\n\r\nif showStats and not na(statsTable)\r\n    // í†µê³„ ê³„ì‚°\r\n    float mdd = strategy.max_drawdown_percent\r\n    float avg_trade = f_avg(trade_returns)\r\n    float std_trade = f_stdev(trade_returns)\r\n    float pf = strategy.grossloss != 0 ? strategy.grossprofit / strategy.grossloss : 0\r\n    \r\n    float sharpe = f_sharpe(daily_returns)\r\n    float sortino = f_sortino(daily_returns)\r\n    float skew = f_skewness(trade_returns, avg_trade, std_trade)\r\n    \r\n    // CAGR ê³„ì‚° (ì•ˆì „í•˜ê²Œ)\r\n    float total_days = 0.0\r\n    float total_years = 0.0\r\n    if strategy.closedtrades > 0\r\n        total_days := (timenow - strategy.closedtrades.entry_time(0)) / (1000 * 60 * 60 * 24)\r\n        total_years := total_days / 365.0\r\n    \r\n    float total_return = strategy.equity / strategy.initial_capital\r\n    float cagr = (total_years > 0.1 and total_return > 0) ? (math.pow(total_return, 1.0 / total_years) - 1.0) * 100 : 0.0\r\n    \r\n    float bh_return = not na(start_price) and start_price > 0 ? close / start_price : 1.0\r\n    float bh_cagr = (total_years > 0.1 and bh_return > 0) ? (math.pow(bh_return, 1.0 / total_years) - 1.0) * 100 : 0.0\r\n    \r\n    float calmar = mdd != 0 ? cagr / mdd : 0.0\r\n    \r\n    // ìŠ¹ë¥ \r\n    int total_wins = long_wins + short_wins\r\n    int total_losses = long_losses + short_losses\r\n    float winRate = (total_wins + total_losses) > 0 ? total_wins / (total_wins + total_losses) * 100.0 : 0.0\r\n    float long_winRate = (long_wins + long_losses) > 0 ? long_wins / (long_wins + long_losses) * 100.0 : 0.0\r\n    float short_winRate = (short_wins + short_losses) > 0 ? short_wins / (short_wins + short_losses) * 100.0 : 0.0\r\n    \r\n    // ê¸°ì¤€ ì¶©ì¡± ì—¬ë¶€\r\n    bool winRate_ok = winRate >= 50\r\n    bool cagr_ok = cagr > bh_cagr\r\n    bool pf_ok = pf >= 1.5\r\n    bool calmar_ok = calmar >= 2\r\n    bool mdd_ok = mdd < 30\r\n    bool sharpe_ok = sharpe >= 1\r\n    bool sortino_ok = sortino >= 2\r\n    bool skew_ok = skew > 2.5\r\n    bool avg_ok = avg_trade >= 1.2\r\n    \r\n    color bg1 = color.new(color.black, 20)\r\n    color bg2 = color.new(color.black, 35)\r\n    color c_value = color.new(color.white, 0)\r\n    color c_label = color.new(color.white, 20)\r\n    \r\n    // í—¤ë”\r\n    table.cell(statsTable, 0, 0, \"Performance Stats\", text_color = color.white, text_halign = text.align_center, bgcolor = color.new(color.blue, 35))\r\n    table.cell(statsTable, 1, 0, \"Total\", text_color = color.white, text_halign = text.align_center, bgcolor = color.new(color.blue, 35))\r\n    \r\n    // 1. ìŠ¹/íŒ¨\r\n    table.cell(statsTable, 0, 1, \"Win/Loss\", text_color = c_label, text_halign = text.align_left, bgcolor = bg1)\r\n    table.cell(statsTable, 1, 1, str.tostring(total_wins) + \"/\" + str.tostring(total_losses), text_color = c_value, text_halign = text.align_center, bgcolor = bg1)\r\n    \r\n    // 2. ìŠ¹ë¥ \r\n    table.cell(statsTable, 0, 2, \"Win Rate\", text_color = c_label, text_halign = text.align_left, bgcolor = bg2)\r\n    table.cell(statsTable, 1, 2, str.tostring(winRate, \"#.#\") + \"% \" + (winRate_ok ? \"âœ“\" : \"âœ—\"), text_color = winRate_ok ? color.lime : color.yellow, text_halign = text.align_center, bgcolor = bg2)\r\n    \r\n    // 3. CAGR\r\n    table.cell(statsTable, 0, 3, \"CAGR\", text_color = c_label, text_halign = text.align_left, bgcolor = bg1)\r\n    table.cell(statsTable, 1, 3, str.tostring(cagr, \"#.#\") + \"% \" + (cagr_ok ? \"âœ“\" : \"âœ—\"), text_color = cagr_ok ? color.lime : color.yellow, text_halign = text.align_center, bgcolor = bg1)\r\n    \r\n    // 4. Profit Factor\r\n    table.cell(statsTable, 0, 4, \"Profit Factor\", text_color = c_label, text_halign = text.align_left, bgcolor = bg2)\r\n    table.cell(statsTable, 1, 4, str.tostring(pf, \"#.##\") + \" \" + (pf_ok ? \"âœ“\" : \"âœ—\"), text_color = pf_ok ? color.lime : color.yellow, text_halign = text.align_center, bgcolor = bg2)\r\n    \r\n    // 5. Calmar\r\n    table.cell(statsTable, 0, 5, \"Calmar Ratio\", text_color = c_label, text_halign = text.align_left, bgcolor = bg1)\r\n    table.cell(statsTable, 1, 5, str.tostring(calmar, \"#.##\") + \" \" + (calmar_ok ? \"âœ“\" : \"âœ—\"), text_color = calmar_ok ? color.lime : color.yellow, text_halign = text.align_center, bgcolor = bg1)\r\n    \r\n    // 6. MDD\r\n    table.cell(statsTable, 0, 6, \"MDD\", text_color = c_label, text_halign = text.align_left, bgcolor = bg2)\r\n    table.cell(statsTable, 1, 6, str.tostring(mdd, \"#.##\") + \"% \" + (mdd_ok ? \"âœ“\" : \"âœ—\"), text_color = mdd_ok ? color.lime : color.yellow, text_halign = text.align_center, bgcolor = bg2)\r\n    \r\n    // 7. Sharpe\r\n    table.cell(statsTable, 0, 7, \"Sharpe Ratio\", text_color = c_label, text_halign = text.align_left, bgcolor = bg1)\r\n    table.cell(statsTable, 1, 7, str.tostring(sharpe, \"#.##\") + \" \" + (sharpe_ok ? \"âœ“\" : \"âœ—\"), text_color = sharpe_ok ? color.lime : color.yellow, text_halign = text.align_center, bgcolor = bg1)\r\n    \r\n    // 8. Sortino\r\n    table.cell(statsTable, 0, 8, \"Sortino Ratio\", text_color = c_label, text_halign = text.align_left, bgcolor = bg2)\r\n    table.cell(statsTable, 1, 8, str.tostring(sortino, \"#.##\") + \" \" + (sortino_ok ? \"âœ“\" : \"âœ—\"), text_color = sortino_ok ? color.lime : color.yellow, text_halign = text.align_center, bgcolor = bg2)\r\n    \r\n    // 9. Skewness\r\n    table.cell(statsTable, 0, 9, \"Skewness\", text_color = c_label, text_halign = text.align_left, bgcolor = bg1)\r\n    table.cell(statsTable, 1, 9, str.tostring(skew, \"#.##\") + \" \" + (skew_ok ? \"âœ“\" : \"âœ—\"), text_color = skew_ok ? color.lime : color.yellow, text_halign = text.align_center, bgcolor = bg1)\r\n    \r\n    // 10. Avg Trade\r\n    table.cell(statsTable, 0, 10, \"Avg Trade %\", text_color = c_label, text_halign = text.align_left, bgcolor = bg2)\r\n    table.cell(statsTable, 1, 10, str.tostring(avg_trade, \"#.##\") + \"% \" + (avg_ok ? \"âœ“\" : \"âœ—\"), text_color = avg_ok ? color.lime : color.yellow, text_halign = text.align_center, bgcolor = bg2)\r\n    \r\n    // 11. Total Equity\r\n    table.cell(statsTable, 0, 11, \"Total Equity\", text_color = c_label, text_halign = text.align_left, bgcolor = bg1)\r\n    table.cell(statsTable, 1, 11, \"$\" + str.tostring(strategy.equity, \"#,###\"), text_color = c_value, text_halign = text.align_center, bgcolor = bg1)"
  },
  {
    "url": "sNhVdBTy-Fractal-Break-Strategy-with-Time-Filter",
    "name": "Fractal Break Strategy with Time Filter",
    "description": "This strategy isn't complete yet but just curious how fast they will take it down. It is based off breaks of fractals and then taking the High/Low of the break candle",
    "image_url": "sNhVdBTy",
    "author": "ChadAnt",
    "likes": 138,
    "type": "strategy",
    "created": "2025-11-14",
    "updated": "2025-11-14",
    "source": "//@version=5\r\nstrategy(\"Fractal Break Strategy with Time Filter\", overlay=true, max_lines_count=500, max_labels_count=500, \r\n         default_qty_type=strategy.percent_of_equity, default_qty_value=100)\r\n\r\n// ============ Time Filter Inputs ============\r\nuseTimeFilter = input.bool(true, \"Enable Time Filter\", group=\"Time Filter\")\r\nstartHour = input.int(9, \"Start Hour (24h format)\", minval=0, maxval=23, group=\"Time Filter\")\r\nstartMinute = input.int(30, \"Start Minute\", minval=0, maxval=59, group=\"Time Filter\")\r\nendHour = input.int(16, \"End Hour (24h format)\", minval=0, maxval=23, group=\"Time Filter\")\r\nendMinute = input.int(0, \"End Minute\", minval=0, maxval=59, group=\"Time Filter\")\r\n\r\n// Time filter function\r\ninTimeWindow() =>\r\n    if not useTimeFilter\r\n        true\r\n    else\r\n        currentTime = time\r\n        startTime = timestamp(year, month, dayofmonth, startHour, startMinute, 0)\r\n        endTime = timestamp(year, month, dayofmonth, endHour, endMinute, 0)\r\n        \r\n        if startTime <= endTime\r\n            currentTime >= startTime and currentTime <= endTime\r\n        else\r\n            // Handle case where session crosses midnight\r\n            currentTime >= startTime or currentTime <= endTime\r\n\r\n// ============ Fractal Settings ============\r\nfractalPeriod = input.int(2, \"Fractal Period\", minval=1, maxval=10, group=\"Fractal Settings\", \r\n                          tooltip=\"Number of bars on each side. 2 = Williams Fractal (default). Higher values = stronger fractals.\")\r\n\r\n// ============ Color Inputs ============\r\nbullishBreakBodyColor = input.color(color.new(#ffffff, 0), \"Bullish Break - Body Color\", group=\"Bullish Break Colors\")\r\nbullishBreakBorderColor = input.color(color.new(#ffffff, 0), \"Bullish Break - Border Color\", group=\"Bullish Break Colors\")\r\nbullishBreakWickColor = input.color(color.new(#ffffff, 0), \"Bullish Break - Wick Color\", group=\"Bullish Break Colors\")\r\n\r\nbearishBreakBodyColor = input.color(color.new(#535353, 0), \"Bearish Break - Body Color\", group=\"Bearish Break Colors\")\r\nbearishBreakBorderColor = input.color(color.new(#535353, 0), \"Bearish Break - Border Color\", group=\"Bearish Break Colors\")\r\nbearishBreakWickColor = input.color(color.new(#535353, 0), \"Bearish Break - Wick Color\", group=\"Bearish Break Colors\")\r\n\r\nfractalHighColor = input.color(color.red, \"Fractal High Color\", group=\"Fractal Colors\")\r\nfractalLowColor = input.color(color.green, \"Fractal Low Color\", group=\"Fractal Colors\")\r\nlevelLineColor = input.color(color.blue, \"Level Line Color\", group=\"Line Style\")\r\nlevelLineWidth = input.int(1, \"Level Line Width\", minval=1, maxval=5, group=\"Line Style\")\r\nlevelLineStyle = input.string(\"Solid\", \"Level Line Style\", options=[\"Solid\", \"Dashed\", \"Dotted\"], group=\"Line Style\")\r\n\r\n// ============ Strategy Inputs ============\r\natrLength = input.int(14, \"ATR Length\", minval=1, group=\"Strategy Settings\")\r\natrMultiplier = input.float(0.0, \"ATR Multiplier for Stop\", minval=0.0, step=0.1, group=\"Strategy Settings\", tooltip=\"Set to 0 for stop at break candle high/low. Increase to add ATR buffer.\")\r\nriskReward = input.float(1.0, \"Risk:Reward Ratio\", minval=0.5, step=0.5, group=\"Strategy Settings\")\r\nwhichTP = input.int(1, \"Which Take Profit to Exit At\", minval=1, maxval=5, group=\"Strategy Settings\", tooltip=\"Choose which TP level to use for exit (1=closest, higher=further)\")\r\nnumTakeProfits = input.int(3, \"Number of Take Profit Levels to Display\", minval=1, maxval=5, group=\"Strategy Settings\")\r\n\r\n// Visual settings\r\nshowLevels = input.bool(true, \"Show Entry/Stop/TP Lines\", group=\"Visual Settings\")\r\nentryLineColor = input.color(color.blue, \"Entry Line Color\", group=\"Visual Settings\")\r\nstopLineColor = input.color(color.red, \"Stop Loss Line Color\", group=\"Visual Settings\")\r\ntpLineColor = input.color(color.green, \"Take Profit Line Color\", group=\"Visual Settings\")\r\n\r\n// Convert line style\r\ngetLineStyle() =>\r\n    switch levelLineStyle\r\n        \"Solid\" => line.style_solid\r\n        \"Dashed\" => line.style_dashed\r\n        \"Dotted\" => line.style_dotted\r\n        => line.style_solid\r\n\r\n// ============ Fractal Detection ============\r\nisFractalHigh() =>\r\n    bool isHigh = true\r\n    pivotHigh = high[fractalPeriod]\r\n    \r\n    // Check bars to the left\r\n    for i = 1 to fractalPeriod\r\n        if high[fractalPeriod + i] >= pivotHigh\r\n            isHigh := false\r\n            break\r\n    \r\n    // Check bars to the right\r\n    if isHigh\r\n        for i = 0 to fractalPeriod - 1\r\n            if high[i] >= pivotHigh\r\n                isHigh := false\r\n                break\r\n    \r\n    isHigh\r\n\r\nisFractalLow() =>\r\n    bool isLow = true\r\n    pivotLow = low[fractalPeriod]\r\n    \r\n    // Check bars to the left\r\n    for i = 1 to fractalPeriod\r\n        if low[fractalPeriod + i] <= pivotLow\r\n            isLow := false\r\n            break\r\n    \r\n    // Check bars to the right\r\n    if isLow\r\n        for i = 0 to fractalPeriod - 1\r\n            if low[i] <= pivotLow\r\n                isLow := false\r\n                break\r\n    \r\n    isLow\r\n\r\nisFractalHighDetected = isFractalHigh()\r\nisFractalLowDetected = isFractalLow()\r\n\r\n// Track most recent fractal levels\r\nvar float lastFractalHigh = na\r\nvar float lastFractalLow = na\r\nvar int lastFractalHighBar = na\r\nvar int lastFractalLowBar = na\r\nvar bool highBrokenPreviously = false\r\nvar bool lowBrokenPreviously = false\r\n\r\n// Update fractal levels when new ones form\r\nif isFractalHighDetected\r\n    if not na(lastFractalHigh) and not na(lastFractalHighBar)\r\n        line.new(lastFractalHighBar, lastFractalHigh, bar_index - fractalPeriod, lastFractalHigh, \r\n                 color=levelLineColor, width=levelLineWidth, style=getLineStyle())\r\n    \r\n    lastFractalHigh := high[fractalPeriod]\r\n    lastFractalHighBar := bar_index - fractalPeriod\r\n    highBrokenPreviously := false\r\n\r\nif isFractalLowDetected\r\n    if not na(lastFractalLow) and not na(lastFractalLowBar)\r\n        line.new(lastFractalLowBar, lastFractalLow, bar_index - fractalPeriod, lastFractalLow, \r\n                 color=levelLineColor, width=levelLineWidth, style=getLineStyle())\r\n    \r\n    lastFractalLow := low[fractalPeriod]\r\n    lastFractalLowBar := bar_index - fractalPeriod\r\n    lowBrokenPreviously := false\r\n\r\n// Plot fractals\r\nplotshape(isFractalHighDetected, title=\"Fractal High\", location=location.abovebar, color=fractalHighColor, \r\n          style=shape.triangledown, size=size.tiny, offset=-fractalPeriod)\r\nplotshape(isFractalLowDetected, title=\"Fractal Low\", location=location.belowbar, color=fractalLowColor, \r\n          style=shape.triangleup, size=size.tiny, offset=-fractalPeriod)\r\n\r\n// Draw current active level lines\r\nvar line currentHighLine = na\r\nvar line currentLowLine = na\r\n\r\nif not na(lastFractalHigh) and not na(lastFractalHighBar)\r\n    line.delete(currentHighLine)\r\n    currentHighLine := line.new(lastFractalHighBar, lastFractalHigh, bar_index, lastFractalHigh, color=levelLineColor, width=levelLineWidth, style=getLineStyle(), extend=extend.right)\r\n\r\nif not na(lastFractalLow) and not na(lastFractalLowBar)\r\n    line.delete(currentLowLine)\r\n    currentLowLine := line.new(lastFractalLowBar, lastFractalLow, bar_index, lastFractalLow, \r\n                               color=levelLineColor, width=levelLineWidth, style=getLineStyle(), extend=extend.right)\r\n\r\n// ============ Fractal Break Detection ============\r\nfractalHighBroken = not na(lastFractalHigh) and high > lastFractalHigh and not highBrokenPreviously\r\nfractalLowBroken = not na(lastFractalLow) and low < lastFractalLow and not lowBrokenPreviously\r\n\r\n// Track break candle for entry triggers\r\nvar float breakHigh = na\r\nvar float breakLow = na\r\nvar bool awaitingLongTrigger = false\r\nvar bool awaitingShortTrigger = false\r\n\r\n// When fractal breaks, store the break candle info\r\nif fractalHighBroken\r\n    highBrokenPreviously := true\r\n    breakHigh := high\r\n    breakLow := low\r\n    awaitingLongTrigger := true\r\n    awaitingShortTrigger := false\r\n\r\nif fractalLowBroken\r\n    lowBrokenPreviously := true\r\n    breakHigh := high\r\n    breakLow := low\r\n    awaitingShortTrigger := true\r\n    awaitingLongTrigger := false\r\n\r\n// Color only the break candle\r\nbarBodyColor = fractalHighBroken ? bullishBreakBodyColor : fractalLowBroken ? bearishBreakBodyColor : na\r\nbarBorderColor = fractalHighBroken ? bullishBreakBorderColor : fractalLowBroken ? bearishBreakBorderColor : na\r\nbarWickColor = fractalHighBroken ? bullishBreakWickColor : fractalLowBroken ? bearishBreakWickColor : na\r\n\r\nbarcolor(barBodyColor, title=\"Break Body Color\")\r\nplotcandle(open, high, low, close, title=\"Break Candle\", \r\n          color=barBodyColor, wickcolor=barWickColor, bordercolor=barBorderColor, editable=false)\r\n\r\n// ============ Strategy Logic ============\r\natr = ta.atr(atrLength)\r\n\r\n// Store entry details for visualization\r\nvar float activeEntryPrice = na\r\nvar float activeStopPrice = na\r\nvar float activeTargetPrice = na\r\nvar array<float> activeTpPrices = array.new<float>()\r\nvar line entryLine = na\r\nvar line stopLine = na\r\nvar array<line> tpLines = array.new<line>()\r\nvar label entryLabel = na\r\nvar label stopLabel = na\r\nvar array<label> tpLabels = array.new<label>()\r\n\r\n// Clear lines function\r\nclearLines() =>\r\n    line.delete(entryLine)\r\n    line.delete(stopLine)\r\n    label.delete(entryLabel)\r\n    label.delete(stopLabel)\r\n    if array.size(tpLines) > 0\r\n        for i = 0 to array.size(tpLines) - 1\r\n            line.delete(array.get(tpLines, i))\r\n        array.clear(tpLines)\r\n    if array.size(tpLabels) > 0\r\n        for i = 0 to array.size(tpLabels) - 1\r\n            label.delete(array.get(tpLabels, i))\r\n        array.clear(tpLabels)\r\n\r\n// Long entry conditions\r\nlongTriggered = awaitingLongTrigger and high > breakHigh and not (low < breakLow) and strategy.position_size == 0 and inTimeWindow()\r\n\r\n// Short entry after bullish break (reversal)\r\nshortAfterBullish = awaitingLongTrigger and low < breakLow and strategy.position_size == 0 and inTimeWindow()\r\n\r\n// Short entry conditions\r\nshortTriggered = awaitingShortTrigger and low < breakLow and not (high > breakHigh) and \r\n                 strategy.position_size == 0 and inTimeWindow()\r\n\r\n// Long entry after bearish break (reversal)\r\nlongAfterBearish = awaitingShortTrigger and high > breakHigh and \r\n                   strategy.position_size == 0 and inTimeWindow()\r\n\r\n// Execute LONG trades\r\nif longTriggered or longAfterBearish\r\n    awaitingLongTrigger := false\r\n    awaitingShortTrigger := false\r\n    \r\n    entryPrice = breakHigh\r\n    stopPrice = breakLow - (atr * atrMultiplier)\r\n    riskAmount = entryPrice - stopPrice\r\n    rewardAmount = riskAmount * riskReward\r\n    targetPrice = entryPrice + (rewardAmount * whichTP)\r\n    \r\n    // Enter position with stop and limit\r\n    strategy.entry(\"Long\", strategy.long)\r\n    strategy.exit(\"Exit Long\", \"Long\", stop=stopPrice, limit=targetPrice)\r\n    \r\n    // Store exit levels\r\n    activeEntryPrice := entryPrice\r\n    activeStopPrice := stopPrice\r\n    activeTargetPrice := targetPrice\r\n    array.clear(activeTpPrices)\r\n    \r\n    // Clear old lines\r\n    clearLines()\r\n    \r\n    // Draw new lines\r\n    if showLevels\r\n        entryLine := line.new(bar_index, entryPrice, bar_index, entryPrice, \r\n                             color=entryLineColor, width=2, style=line.style_solid, extend=extend.right)\r\n        entryLabel := label.new(bar_index, entryPrice, \"LONG: \" + str.tostring(entryPrice, format.mintick), \r\n                               style=label.style_label_left, color=entryLineColor, textcolor=color.white, size=size.small)\r\n        \r\n        stopLine := line.new(bar_index, stopPrice, bar_index, stopPrice, color=stopLineColor, width=2, style=line.style_solid, extend=extend.right)\r\n        stopLabel := label.new(bar_index, stopPrice, \"Stop: \" + str.tostring(stopPrice, format.mintick), \r\n                              style=label.style_label_left, color=stopLineColor, textcolor=color.white, size=size.small)\r\n        \r\n        for i = 1 to numTakeProfits\r\n            tpPrice = entryPrice + (rewardAmount * i)\r\n            array.push(activeTpPrices, tpPrice)\r\n            isActiveTP = i == whichTP\r\n            tpLine = line.new(bar_index, tpPrice, bar_index, tpPrice, color=isActiveTP ? color.new(tpLineColor, 0) : color.new(tpLineColor, 60), width=isActiveTP ? 2 : 1, style=isActiveTP ? line.style_solid : line.style_dashed, extend=extend.right)\r\n            tpLabel = label.new(bar_index, tpPrice, \r\n                              \"TP\" + str.tostring(i) + (isActiveTP ? \" âœ“\" : \"\") + \": \" + str.tostring(tpPrice, format.mintick), \r\n                              style=label.style_label_left, \r\n                              color=isActiveTP ? tpLineColor : color.new(tpLineColor, 60), \r\n                              textcolor=color.white, size=size.small)\r\n            array.push(tpLines, tpLine)\r\n            array.push(tpLabels, tpLabel)\r\n\r\n// Execute SHORT trades\r\nif shortTriggered or shortAfterBullish\r\n    awaitingLongTrigger := false\r\n    awaitingShortTrigger := false\r\n    \r\n    entryPrice = breakLow\r\n    stopPrice = breakHigh + (atr * atrMultiplier)\r\n    riskAmount = stopPrice - entryPrice\r\n    rewardAmount = riskAmount * riskReward\r\n    targetPrice = entryPrice - (rewardAmount * whichTP)\r\n    \r\n    // Enter position with stop and limit\r\n    strategy.entry(\"Short\", strategy.short)\r\n    strategy.exit(\"Exit Short\", \"Short\", stop=stopPrice, limit=targetPrice)\r\n    \r\n    // Store exit levels\r\n    activeEntryPrice := entryPrice\r\n    activeStopPrice := stopPrice\r\n    activeTargetPrice := targetPrice\r\n    array.clear(activeTpPrices)\r\n    \r\n    // Clear old lines\r\n    clearLines()\r\n    \r\n    // Draw new lines\r\n    if showLevels\r\n        entryLine := line.new(bar_index, entryPrice, bar_index, entryPrice, \r\n                             color=entryLineColor, width=2, style=line.style_solid, extend=extend.right)\r\n        entryLabel := label.new(bar_index, entryPrice, \"SHORT: \" + str.tostring(entryPrice, format.mintick), \r\n                               style=label.style_label_right, color=entryLineColor, textcolor=color.white, size=size.small)\r\n        \r\n        stopLine := line.new(bar_index, stopPrice, bar_index, stopPrice, color=stopLineColor, width=2, style=line.style_solid, extend=extend.right)\r\n        stopLabel := label.new(bar_index, stopPrice, \"Stop: \" + str.tostring(stopPrice, format.mintick), \r\n                              style=label.style_label_right, color=stopLineColor, textcolor=color.white, size=size.small)\r\n        \r\n        for i = 1 to numTakeProfits\r\n            tpPrice = entryPrice - (rewardAmount * i)\r\n            array.push(activeTpPrices, tpPrice)\r\n            isActiveTP = i == whichTP\r\n            tpLine = line.new(bar_index, tpPrice, bar_index, tpPrice, color=isActiveTP ? color.new(tpLineColor, 0) : color.new(tpLineColor, 60), width=isActiveTP ? 2 : 1, style=isActiveTP ? line.style_solid : line.style_dashed, extend=extend.right)\r\n            tpLabel = label.new(bar_index, tpPrice, \r\n                              \"TP\" + str.tostring(i) + (isActiveTP ? \" âœ“\" : \"\") + \": \" + str.tostring(tpPrice, format.mintick), \r\n                              style=label.style_label_right, \r\n                              color=isActiveTP ? tpLineColor : color.new(tpLineColor, 60), \r\n                              textcolor=color.white, size=size.small)\r\n            array.push(tpLines, tpLine)\r\n            array.push(tpLabels, tpLabel)\r\n\r\n// Update line extensions on every bar while position is open\r\nif strategy.position_size != 0 and showLevels\r\n    if not na(entryLine)\r\n        line.set_x2(entryLine, bar_index)\r\n    if not na(stopLine)\r\n        line.set_x2(stopLine, bar_index)\r\n    if array.size(tpLines) > 0\r\n        for i = 0 to array.size(tpLines) - 1\r\n            tpLine = array.get(tpLines, i)\r\n            if not na(tpLine)\r\n                line.set_x2(tpLine, bar_index)\r\n\r\n// When position closes, stop extending lines but keep them visible\r\nif strategy.position_size == 0 and strategy.position_size[1] != 0\r\n    // Remove extend.right from lines so they stop at exit bar\r\n    if not na(entryLine)\r\n        line.set_extend(entryLine, extend.none)\r\n        line.set_x2(entryLine, bar_index)\r\n    if not na(stopLine)\r\n        line.set_extend(stopLine, extend.none)\r\n        line.set_x2(stopLine, bar_index)\r\n    if array.size(tpLines) > 0\r\n        for i = 0 to array.size(tpLines) - 1\r\n            tpLine = array.get(tpLines, i)\r\n            if not na(tpLine)\r\n                line.set_extend(tpLine, extend.none)\r\n                line.set_x2(tpLine, bar_index)\r\n    \r\n    activeEntryPrice := na\r\n    activeStopPrice := na\r\n    activeTargetPrice := na"
  },
  {
    "url": "pGI38qFr",
    "name": "Fractional Candlestick Long Only Experimental V4 ",
    "description": "Another example of use an idea of Fractional Candlestick , based on mathematical rules of Fractional Calculus , typical kernel Caputo-Fabrizio ( CF )  and Atangana-Baleanu is used, alfa factor ( esential for calculation ) is in range 0,1-0.9. \nLet's fun with this script .",
    "image_url": "pGI38qFr",
    "author": "wojlucz",
    "likes": 23,
    "type": "strategy",
    "created": "2025-11-14",
    "updated": "2025-11-14",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// Â© wojlucz\r\n\r\n//@version=5\r\nstrategy(\"Fractional Candlestick Long Only Experimental V4 \",\r\n     overlay=true,\r\n     default_qty_type=strategy.percent_of_equity, default_qty_value=100,\r\n     pyramiding=0, process_orders_on_close=true, calc_on_every_tick=false)\r\n\r\n// â”€â”€â”€ USTAWIENIA WYÅšWIETLANIA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nshowStandardCandles = input.bool(true,  \"PokaÅ¼ standardowe Å›wiece\")\r\nshowHA              = input.bool(true,  \"PokaÅ¼ klasyczne Heikin-Ashi\")\r\nshowFracCFHA        = input.bool(true,  \"PokaÅ¼ Fractional HA CF\")\r\nshowFracABHA        = input.bool(true,  \"PokaÅ¼ Fractional HA AB\")\r\nshowCFCandles       = input.bool(true,  \"PokaÅ¼ Fractional Candlestick CF\")\r\nshowABCandles       = input.bool(true,  \"PokaÅ¼ Fractional Candlestick AB\")\r\nshowDebugLines      = input.bool(true,  \"PokaÅ¼ linie pomocnicze\")\r\nshowDebugScore      = input.bool(true,  \"PokaÅ¼ wynik stosu (label)\")\r\nshowRiskBg          = input.bool(true,  \"PokaÅ¼ tÅ‚o ryzyka (Low/Med/High)\")\r\n\r\n// â”€â”€â”€ PARAMETRY FRACTIONAL HA (CF/AB) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nalpha_cf_HA = input.float(0.10, \"RzÄ…d Î± CF (Fractional HA)\", minval=0.01, maxval=0.99)\r\nalpha_ab_HA = input.float(0.30, \"RzÄ…d Î± AB (Fractional HA)\", minval=0.01, maxval=0.99)\r\n\r\n// â”€â”€â”€ PARAMETRY FRACTIONAL CANDLESTICK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nalpha_cf_candle   = input.float(0.50, \"RzÄ…d Î± Fractional Candlestick CF\", minval=0.01, maxval=0.99)\r\nlength_cf_candle  = input.int(  20,   \"DÅ‚ugoÅ›Ä‡ Fractional Candlestick CF\", minval=1, maxval=300)\r\nalpha_ab_candle   = input.float(0.50, \"RzÄ…d Î± Fractional Candlestick AB\", minval=0.01, maxval=0.99)\r\nlength_ab_candle  = input.int(  20,   \"DÅ‚ugoÅ›Ä‡ Fractional Candlestick AB\", minval=1, maxval=300)\r\n\r\n// â”€â”€â”€ LOGIKA WEJÅšÄ† (stos relacji) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nstackMode         = input.string(\"Stack-4 (najsilniejszy)\", \"Tryb siÅ‚y stosu\", options=[\"Stack-4 (najsilniejszy)\",\"Stack-3 (mocny)\",\"Any-2 (luÅºny)\"])\r\nconfirmNextBar    = input.bool(true, \"WejÅ›cie potwierdzone (na kolejnej Å›wiecy)\")\r\n\r\n// â”€â”€â”€ FILTR KONSOLIDACJI (rdzeÅ„) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nuseConsolidation  = input.bool(true, \"Unikaj konsolidacji (kernel-range)\")\r\nrangePctMin       = input.float(0.20, \"PrÃ³g zakresu [% z mediany]\", minval=0.0, maxval=5.0)\r\n\r\n// â”€â”€â”€ WYJÅšCIA I RYZYKO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nexitMode          = input.string(\"Order flip (stos CF/AB/HA)\", \"Tryb wyjÅ›cia\", options=[\"Order flip (stos CF/AB/HA)\",\"CF<AB\",\"HA flip\",\"Kernel Trailing\"])\r\ntrailBufPct       = input.float(0.20, \"Bufor trailing [% ceny] (dla Kernel Trailing)\", minval=0.0, maxval=5.0)\r\nuseSLTP           = input.bool(false, \"Aktywuj SL/TP %\")\r\nslPct             = input.float(3.0, \"Stop Loss [%]\", minval=0.1, maxval=50.0)\r\ntpPct             = input.float(6.0, \"Take Profit [%]\", minval=0.1, maxval=200.0)\r\n\r\n// â”€â”€â”€ MODUÅ RYZYKA KONSOLIDACJI (bliskoÅ›Ä‡) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nnearPct   = input.float(10.0, \"PrÃ³g bliskoÅ›ci [% kernelRange]\", minval=0.1, maxval=50.0)\r\nriskGate  = input.string(\"Low\", \"Dopuszczaj ryzyko\", options=[\"Low\",\"Low+Med\",\"All\"])\r\n\r\n// â”€â”€â”€ OPCJE WIZUALIZACJI TRAILINGU/KANAÅU â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nshowTrailLine   = input.bool(true,  \"PokaÅ¼ liniÄ™ trailing stop\")\r\nshowTrailHit    = input.bool(true,  \"PokaÅ¼ znacznik trafienia trailing\")\r\nshowTrailBg     = input.bool(false, \"PokaÅ¼ tÅ‚o wzglÄ™dem trailing (zielone/czerwone)\")\r\nshowTrailChannel= input.bool(true,  \"PokaÅ¼ frakcyjny kanaÅ‚ trendu/trailing\")\r\n\r\n// â”€â”€â”€ JÄ„DRA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\ncf_kernel(i, alpha) => math.exp(-alpha / (1 - alpha) * i)\r\nab_kernel(i, alpha) => 1.0 / (1.0 + (alpha / (1 - alpha)) * math.pow(i, alpha))\r\n\r\n// â”€â”€â”€ FILTRY FRAKCYJNE DLA ÅšWIEC CF/AB â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nfrac_filter_cf(src, length, alpha) =>\r\n    _sum = 0.0, _norm = 0.0\r\n    for i = 0 to length\r\n        w = cf_kernel(i, alpha)\r\n        _sum += nz(src[i]) * w\r\n        _norm += w\r\n    _sum / _norm\r\n\r\nfrac_filter_ab(src, length, alpha) =>\r\n    _sum = 0.0, _norm = 0.0\r\n    for i = 0 to length\r\n        w = ab_kernel(i, alpha)\r\n        _sum += nz(src[i]) * w\r\n        _norm += w\r\n    _sum / _norm\r\n\r\n// â”€â”€â”€ FRACTIONAL EMA DO HA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nalpha_to_length(alpha) =>\r\n    l = math.round(2.0 / alpha)\r\n    l < 1 ? 1 : int(l)\r\n\r\nfractional_ema(src, alpha) =>\r\n    length = alpha_to_length(alpha)\r\n    ta.ema(src, length)\r\n\r\n// â”€â”€â”€ ÅšWIECE STANDARD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nstdBullColor = color.new(color.new(color.lime, 0), showStandardCandles ? 0 : 100)\r\nstdBearColor = color.new(color.new(color.red,  0), showStandardCandles ? 0 : 100)\r\nplotcandle(open, high, low, close, title=\"Standard\", color=open <= close ? stdBullColor : stdBearColor, wickcolor=color.new(color.gray, showStandardCandles ? 0 : 100), display = showStandardCandles ? display.all : display.none)\r\n\r\n// â”€â”€â”€ HEIKIN-ASHI KLASYCZNE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nhaClose = (open + high + low + close) / 4.0\r\nvar float haOpen = na\r\nhaOpen := na(haOpen[1]) ? (open + close) / 2.0 : (haOpen[1] + haClose[1]) / 2.0\r\nhaHigh = math.max(high, math.max(haOpen, haClose))\r\nhaLow  = math.min(low,  math.min(haOpen, haClose))\r\nhaColor = haClose >= haOpen ? color.new(color.green, 40) : color.new(color.red, 40)\r\nplotcandle(haOpen, haHigh, haLow, haClose, title=\"Heikin-Ashi\", color= showHA ? haColor : na, wickcolor=showHA ? color.new(haColor,0) : na, display = showHA ? display.all : display.none)\r\n\r\n// â”€â”€â”€ FRACTIONAL HEIKIN-ASHI (CF) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nfOpenCF_HA  = fractional_ema(open,  alpha_cf_HA)\r\nfHighCF_HA  = fractional_ema(high,  alpha_cf_HA)\r\nfLowCF_HA   = fractional_ema(low,   alpha_cf_HA)\r\nfCloseCF_HA = fractional_ema(close, alpha_cf_HA)\r\nvar float haOpenCF = na\r\nhaCloseCF = (fOpenCF_HA + fHighCF_HA + fLowCF_HA + fCloseCF_HA) / 4.0\r\nhaOpenCF := na(haOpenCF[1]) ? (fOpenCF_HA + fCloseCF_HA) / 2.0 : (haOpenCF[1] + haCloseCF[1]) / 2.0\r\nhaHighCF = math.max(fHighCF_HA, math.max(haOpenCF, haCloseCF))\r\nhaLowCF  = math.min(fLowCF_HA,  math.min(haOpenCF, haCloseCF))\r\nhaColorCF = haCloseCF >= haOpenCF ? color.new(color.green, 60) : color.new(color.red, 60)\r\nplotcandle(haOpenCF, haHighCF, haLowCF, haCloseCF, title=\"Fractional HA CF\", color = showFracCFHA ? haColorCF : na, wickcolor = showFracCFHA ? color.new(haColorCF,0) : na, display = showFracCFHA ? display.all : display.none)\r\n\r\n// â”€â”€â”€ FRACTIONAL HEIKIN-ASHI (AB) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nfOpenAB_HA  = fractional_ema(open,  alpha_ab_HA)\r\nfHighAB_HA  = fractional_ema(high,  alpha_ab_HA)\r\nfLowAB_HA   = fractional_ema(low,   alpha_ab_HA)\r\nfCloseAB_HA = fractional_ema(close, alpha_ab_HA)\r\nvar float haOpenAB = na\r\nhaCloseAB = (fOpenAB_HA + fHighAB_HA + fLowAB_HA + fCloseAB_HA) / 4.0\r\nhaOpenAB := na(haOpenAB[1]) ? (fOpenAB_HA + fCloseAB_HA) / 2.0 : (haOpenAB[1] + haCloseAB[1]) / 2.0\r\nhaHighAB = math.max(fHighAB_HA, math.max(haOpenAB, haCloseAB))\r\nhaLowAB  = math.min(fLowAB_HA,  math.min(haOpenAB, haCloseAB))\r\nhaColorAB = haCloseAB >= haOpenAB ? color.new(color.blue, 60) : color.new(color.orange, 60)\r\nplotcandle(haOpenAB, haHighAB, haLowAB, haCloseAB, title=\"Fractional HA AB\", color = showFracABHA ? haColorAB : na, wickcolor = showFracABHA ? color.new(haColorAB,0) : na, display = showFracABHA ? display.all : display.none)\r\n\r\n// â”€â”€â”€ FRACTIONAL CANDLESTICKS CF/AB â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\ncf_open  = frac_filter_cf(open,  length_cf_candle, alpha_cf_candle)\r\ncf_high  = frac_filter_cf(high,  length_cf_candle, alpha_cf_candle)\r\ncf_low   = frac_filter_cf(low,   length_cf_candle, alpha_cf_candle)\r\ncf_close = frac_filter_cf(close, length_cf_candle, alpha_cf_candle)\r\ncf_col   = cf_close >= cf_open ? color.new(color.teal, 0) : color.new(color.blue, 0)\r\nplotcandle(cf_open, cf_high, cf_low, cf_close, title=\"Fractional Candlestick CF\", color = showCFCandles ? cf_col : na, wickcolor = showCFCandles ? cf_col : na, bordercolor = showCFCandles ? cf_col : na, display = showCFCandles ? display.all : display.none)\r\n\r\nab_open  = frac_filter_ab(open,  length_ab_candle, alpha_ab_candle)\r\nab_high  = frac_filter_ab(high,  length_ab_candle, alpha_ab_candle)\r\nab_low   = frac_filter_ab(low,   length_ab_candle, alpha_ab_candle)\r\nab_close = frac_filter_ab(close, length_ab_candle, alpha_ab_candle)\r\nab_col   = ab_close >= ab_open ? color.new(color.orange, 0) : color.new(color.red, 0)\r\nplotcandle(ab_open, ab_high, ab_low, ab_close, title=\"Fractional Candlestick AB\", color = showABCandles ? ab_col : na, wickcolor = showABCandles ? ab_col : na, bordercolor = showABCandles ? ab_col : na, display = showABCandles ? display.all : display.none)\r\n\r\n// â”€â”€â”€ LINIE POMOCNICZE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nplot(showDebugLines and showFracCFHA ? haCloseCF : na, title='haCloseCF', color=color.fuchsia, linewidth=2)\r\nplot(showDebugLines and showFracABHA ? haCloseAB : na, title='haCloseAB', color=color.aqua, linewidth=2)\r\nplot(showDebugLines and showCFCandles ? cf_high : na,  title='cf_high',  color=color.orange, linewidth=1)\r\nplot(showDebugLines and showABCandles ? ab_low : na,   title='ab_low',   color=color.purple, linewidth=1)\r\n\r\n// â”€â”€â”€ FILTR KONSOLIDACJI (opcjonalny) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nkernelRange = math.max(cf_high - cf_low, ab_high - ab_low)\r\nmedianRange = ta.median(kernelRange, 50)\r\ninConsolid  = useConsolidation ? (kernelRange < medianRange * (1.0 + rangePctMin/100.0)) : false\r\n\r\n// â”€â”€â”€ RELACJE STOSU (4 sygnaÅ‚y porzÄ…dkowe) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nr1_cfAboveAb     = cf_close > ab_close               // CF nad AB (rdzenie Å›wiec)\r\nr2_haCfAboveHaAb = haCloseCF > haCloseAB             // HA_CF nad HA_AB (rdzenie HA)\r\nr3_haCfBull      = haCloseCF >= haOpenCF             // HA_CF bycze\r\nr4_haAbBull      = haCloseAB >= haOpenAB             // HA_AB bycze\r\n\r\nscore = (r1_cfAboveAb ? 1 : 0) + (r2_haCfAboveHaAb ? 1 : 0) + (r3_haCfBull ? 1 : 0) + (r4_haAbBull ? 1 : 0)\r\nneedScore = stackMode == \"Stack-4 (najsilniejszy)\" ? 4 : stackMode == \"Stack-3 (mocny)\" ? 3 : 2\r\n\r\n// â”€â”€â”€ BLISKOÅšÄ† I KLASYFIKACJA RYZYKA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\neps       = math.max(kernelRange * nearPct/100.0, syminfo.mintick)\r\nnearCFAB  = math.abs(cf_close  - ab_close ) <= eps\r\nnearHAs   = math.abs(haCloseCF - haCloseAB) <= eps\r\nhaMixed   = (haCloseCF >= haOpenCF) != (haCloseAB >= haOpenAB)\r\nscoreFlip = score != nz(score[1])\r\n\r\nriskHigh  = inConsolid or ((not r1_cfAboveAb) and (not r2_haCfAboveHaAb)) or (nearCFAB and nearHAs) or (score <= 1) or (scoreFlip and score <= 2)\r\nriskMed   = (not riskHigh) and ( ((not r1_cfAboveAb) != (not r2_haCfAboveHaAb)) or (score == 2 and haMixed) or (nearCFAB != nearHAs) )\r\nriskLow   = (not riskHigh) and (not riskMed)\r\n\r\n// â”€â”€â”€ TÅO RYZYKA (opcjonalne) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nriskBgHigh = showRiskBg and riskHigh ? color.new(color.red,    90) : na\r\nriskBgMed  = showRiskBg and riskMed  ? color.new(color.orange, 90) : na\r\nbgcolor(riskBgHigh)\r\nbgcolor(riskBgMed)\r\n\r\n// â”€â”€â”€ BRAMKOWANIE RYZYKIEM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nallowMed = riskGate == \"Low+Med\" or riskGate == \"All\"\r\nallowHigh = riskGate == \"All\"\r\nriskAllowed = riskLow or (riskMed and allowMed) or (riskHigh and allowHigh)\r\n\r\n// â”€â”€â”€ WEJÅšCIE (stos + ryzyko) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nbaseLongRaw = (score >= needScore) and riskAllowed\r\nbaseLong    = baseLongRaw and (not inConsolid)\r\nlongCondition = confirmNextBar ? (nz(baseLong[1]) and not nz(baseLong[2])) : (nz(baseLong) and not nz(baseLong[1]))\r\n\r\n// â”€â”€â”€ TÅO ENTER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nbgcolor(longCondition ? color.new(color.lime, 85) : na)\r\n\r\n// â”€â”€â”€ ZARZÄ„DZANIE POZYCJÄ„ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nvar inPos = false\r\ninPos := strategy.position_size > 0\r\n\r\n// WejÅ›cie\r\nif longCondition and not inPos\r\n    strategy.entry(\"LongBull\", strategy.long)\r\n\r\n// Trailing (Kernel Trailing po AB_Low z buforem %)\r\ntrailLevel = ab_low * (1.0 - trailBufPct/100.0)\r\n\r\n// â”€â”€â”€ KANAÅ FRAKCYJNY TRENDU / TRAILING â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nchanLower = math.min(cf_low, ab_low)                 // dolna banda â€“ pamiÄ™Ä‡ dna rynku\r\nchanUpper = math.max(haHighCF, haHighAB)             // gÃ³rna banda â€“ frakcyjny impuls HA\r\n\r\n// Ploty kanaÅ‚u (uchwyty wymagane do fill)\r\npChanUpper = plot(showTrailChannel and inPos ? chanUpper : na, title=\"Fractional Channel Upper\", color=color.new(color.green, 20), linewidth=1)\r\npChanLower = plot(showTrailChannel and inPos ? chanLower : na, title=\"Fractional Channel Lower\", color=color.new(color.orange,20), linewidth=1)\r\n\r\n// WypeÅ‚nienie kanaÅ‚u\r\nfill(pChanUpper, pChanLower, color=color.new(color.teal, 85), title=\"Frac Trend Channel\")\r\n\r\n// â”€â”€â”€ WIZUALIZACJA TRAILINGU â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\ntrailLine = showTrailLine and inPos ? trailLevel : na\r\nplot(trailLine, title=\"Trail Level\", linewidth=2, style=plot.style_line, color=color.new(color.green, 0))\r\n\r\ntrailHit = inPos and close < trailLevel\r\nplotshape(showTrailHit and trailHit, title=\"Trailing Hit\", style=shape.cross, size=size.small, color=color.red, text=\"TS\")\r\n\r\nbgcolor(showTrailBg and inPos and close >= trailLevel ? color.new(color.green, 92) : na)\r\nbgcolor(showTrailBg and inPos and close <  trailLevel ? color.new(color.red,   92) : na)\r\n\r\n// â”€â”€â”€ WYJÅšCIA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\ncfCrossDown   = cf_close < ab_close and cf_close[1] >= ab_close[1]\r\nhaFlipDown    = haCloseCF < haOpenCF and haCloseCF[1] >= haOpenCF[1]\r\norderFlipDown = score < needScore\r\n\r\nexitSignal =\r\n     exitMode == \"Order flip (stos CF/AB/HA)\" ? orderFlipDown :\r\n     exitMode == \"CF<AB\"                      ? cfCrossDown :\r\n     exitMode == \"HA flip\"                    ? haFlipDown :\r\n     exitMode == \"Kernel trailLevel\"            ? (close < trailLevel) : false\r\n\r\nif inPos and exitSignal\r\n    strategy.close(\"LongBull\", comment=exitMode)\r\n\r\n// SL/TP procentowe (opcjonalne)\r\nif useSLTP\r\n    slPrice = strategy.position_avg_price * (1.0 - slPct/100.0)\r\n    tpPrice = strategy.position_avg_price * (1.0 + tpPct/100.0)\r\n    strategy.exit(\"LongBull-X\", from_entry=\"LongBull\", stop=slPrice, limit=tpPrice)\r\n\r\n// â”€â”€â”€ DEBUG: wynik stosu â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\r\nvar label scoreLbl = na\r\nif showDebugScore\r\n    label.delete(scoreLbl)\r\n    scoreText = \"Stack: \" + str.tostring(score) + \"/4  [\" + (r1_cfAboveAb ? \"R1 \" : \"\") + (r2_haCfAboveHaAb ? \"R2 \" : \"\") + (r3_haCfBull ? \"R3 \" : \"\") + (r4_haAbBull ? \"R4\" : \"\") + \"]  | Risk: \" + (riskHigh ? \"High\" : riskMed ? \"Med\" : \"Low\")\r\n    scoreLbl := label.new(bar_index, na, scoreText, style=label.style_label_up, textcolor=color.black, size=size.small, color=color.new(color.yellow, 0))"
  },
  {
    "url": "biSRGk4f-GMH-Tech-Bubble",
    "name": "GMH : Tech Bubble ",
    "description": " Good Morning Holding\nSimulating How to Ride the Bubble â€” and Jump Out Before the Crash\n\nBe careful! Most simulation results show that this strategy sometimes underperforms a simple buy-and-hold, because it gives away positions during deep retracements and buys back at higher thresholds.\n\nHumans often struggle with cutting losses. When the pain becomes too much, they lose the confidence needed to execute even a reasonable strategy.\n\nBut in terms of mentality, this approach reduces long-term portfolio volatility. It helps investors feel more at peace, especially during real market crashes like the tech bubble in 2021.\n\n\nHow to use : Select TimeFrame 4HR on trading view",
    "image_url": "biSRGk4f",
    "author": "gmhfund",
    "likes": 29,
    "type": "strategy",
    "created": "2025-11-14",
    "updated": "2025-11-14",
    "source": "//@version=5\r\nstrategy(\"Tech Bubble\", overlay=true, initial_capital=3000, default_qty_type=strategy.percent_of_equity,pyramiding = 1,  default_qty_value=100)\r\n\r\n//Latch these variable\r\nvar float lastPeakPrice15 = na\r\nvar float lastBottomPrice15 = na\r\nvar string LastEvent15 = na\r\n\r\nvar float longTakeProfit = na\r\nvar float longStopLoss = na\r\nvar float longStopLossOVS = na \r\nvar float longTakeProfitOVS = na\r\nvar float earlytrend = na\r\nvar float long_cost = na\r\n\r\nvar int L_mode = na // 1 : BRK , 2 : OVS\r\nvar int SW_counter = na\r\n\r\nvar int latch_trend = 0\r\n\r\n// == Parameter Tune ==\r\n//BRK_TP = input.float(30.0,title = \"TP on Brake up\")\r\n\r\nBRK_TP = 30.0\r\n\r\n// Input settings\r\ninhiSideway = input(true,title=\"Inhibit Sideways\")\r\ninhiTrend = input(false,title = \"Inhibit Trend\")\r\n\r\n//Trailing = input.bool(false,title = \"Trailing\")\r\nTrailing = false\r\n//SLlimit = input.bool(true,\"Long SL limit\")\r\nSLlimit = true\r\n\r\n\r\ntrend_gap = input.float(0.0,\"Trend Filter Gap\")\r\ntrend_gap_p = input.float(10,\"Trend Filter %\")\r\n//TP = input.float(80,title = \"Long TP interval\")\r\n//maxSL = input.int(14,title = \"SL\",minval =0)\r\n\r\n\r\n\r\nkPeriod = 9\r\ndPeriod = 3\r\nsmoothK = 3\r\noverboughtLevel = 76\r\noversoldLevel = 24\r\n\r\nema200 = ta.ema(close, 200)\r\nema_offset = math.max(trend_gap,0.01*trend_gap_p*close)\r\nema_upper = ema200 + ema_offset\r\nema_lower = ema200 - ema_offset\r\n\r\n\r\n// === PERIOD TEST ===\r\nusePeriod  = input.bool(false, \"Use Testing Period\")\r\nstartYear  = input.int(2020, \"Start Year\")\r\nstartMonth = input.int(1, \"Start Month\")\r\nendYear    = input.int(2025, \"End Year\")\r\nendMonth   = input.int(10, \"End Month\")\r\n\r\n// === TIME RANGE  ===\r\nstartTime = timestamp(startYear, startMonth, 1, 00, 00)\r\nendTime   = timestamp(endYear, endMonth + 1, 1, 00, 00) - 1\r\ninRange   = not usePeriod or (time >= startTime and time <= endTime)\r\n\r\n\r\n[high15, low15, close15, open15] = request.security(syminfo.tickerid, timeframe.period, [high, low, close, open])\r\nk15 = ta.sma(ta.stoch(close15, high15, low15, kPeriod), smoothK)\r\nd15 = ta.sma(k15, dPeriod)\r\n\r\nisPeak15 = k15 > overboughtLevel and ta.crossunder(k15, d15)\r\nisFalseBrk = SW_counter > 80 ? (k15 < 70 and ta.crossunder(k15, d15)) : (k15 > 65 and ta.crossunder(k15, d15)) // Short at early phase of SW\r\n\r\nisRebound = k15 >  30 and ta.crossover(k15, d15)\r\nisBottom15 = k15 < oversoldLevel and ta.crossover(k15, d15)\r\nisPullback = k15 < 35 and ta.crossover(k15, d15)\r\n\r\n\r\n\r\nif barstate.isconfirmed and latch_trend != 1 and close15 > ema_upper\r\n    latch_trend := 1\r\n    lastPeakPrice15 := na // reset OVB bar\r\n    lastBottomPrice15 := na\r\n    earlytrend := ema_lower\r\nelse if barstate.isconfirmed and latch_trend!= -1 and close15 < ema_lower\r\n    latch_trend := -1\r\n    earlytrend := ema_upper\r\n    lastPeakPrice15 := na // reset OVB bar\r\n    lastBottomPrice15 := na    \r\n\r\n\r\ntrendMarket = latch_trend ==1 and barstate.isconfirmed\r\nsidewaysMarket = latch_trend ==-1 and barstate.isconfirmed\r\n\r\n// Code Start Here\r\nif usePeriod and time > endTime\r\n    strategy.close_all(comment=\"End of Range\")\r\nif not usePeriod or (usePeriod and time >= startTime and time <= endTime)\r\n    if isPeak15\r\n        if LastEvent15 == \"Overbought\" // found double OB , use higher\r\n            lastPeakPrice15 := na(lastPeakPrice15) ? high15 : math.max(lastPeakPrice15, high15)\r\n        else\r\n            lastPeakPrice15 := high15\r\n        LastEvent15 := \"Overbought\"\r\n\r\n    if isBottom15\r\n        if LastEvent15 == \"Oversold\" // found double SD , usd lower\r\n            lastBottomPrice15 := na(lastBottomPrice15) ? low15 : math.min(lastBottomPrice15, low15)\r\n        else\r\n            lastBottomPrice15 := low15\r\n        LastEvent15 := \"Oversold\"\r\n\r\n\r\n    if trendMarket\r\n        // Clear S position\r\n        SW_counter := 0\r\n        if strategy.position_size < 0  // In case holding S position from sideways market\r\n            strategy.close(\"Short BRK\", comment=\"Trend Change @ \" + str.tostring(close15, \"#,###\"))\r\n            strategy.close(\"Short OVB\", comment=\"Trend Change @ \" + str.tostring(close15, \"#,###\"))\r\n        \r\n        isSafeLong = close15 < ema_upper-10.0 and close15 >= ema200-20.0\r\n        // Follow Buy conditoin when breakout last Overbought\r\n        isLongCondition = true // close15 > lastPeakPrice15 and (close15 - earlytrend < 70.0 ) //and isSafeLong\r\n        // Buy on Squat condition when form Oversold\r\n        //isLongOversold = (isBottom15) and (close15 - earlytrend >= 0.0 ) and isSafeLong\r\n        isLongOversold =(close15 - earlytrend >= 40.0) and ((close15 > ema200 and close[1] <= ema200 and isSafeLong) or ((isBottom15) and isSafeLong))\r\n\r\n\r\n\r\n\r\n        //Open L\r\n        if strategy.position_size == 0 // Blank position\r\n            if isLongCondition  and inhiTrend == false and strategy.position_size == 0\r\n                strategy.entry(\"Long BRK\", strategy.long, comment=\"Long BRK \" + str.tostring(close15, \"#,###\"))\r\n                longTakeProfit := close15 + BRK_TP\r\n                longStopLoss := ema_lower //(SLlimit? close15 - maxSL : lastPeakPrice15 -5.0)\r\n                longStopLossOVS := ema_lower \r\n                long_cost := close15\r\n                L_mode := 1 // BRK\r\n                //strategy.exit(\"TP Long BRK \" + str.tostring(longTakeProfit,\"#,###\"), from_entry=\"Long BRK\", limit=longTakeProfit)\r\n                \r\n\r\n            if isLongOversold  and inhiTrend == false\r\n                strategy.entry(\"Long OVS\" , strategy.long, comment = \"OVS 1 \"  + str.tostring(close15, \"#,###\"))\r\n                longStopLossOVS := ema_lower //math.min(lastBottomPrice15 - 5.0,ema200-5.0)\r\n                //longTakeProfitOVS := close15 + 15.0\r\n                long_cost := close15\r\n                L_mode := 2 // OVS\r\n\r\n        // Has L or S position\r\n        else if strategy.position_size > 0 // Hold L position\r\n            if isLongOversold and inhiTrend == false and close15 < long_cost-5.0\r\n                strategy.entry(\"Long OVS 2\" , strategy.long , comment = \"OVS 2 \"  + str.tostring(close15, \"#,###\"))\r\n                longStopLossOVS := ema_lower // lastBottomPrice15 - 20.0\r\n                //longTakeProfitOVS := close15 + 15.0\r\n                long_cost := (long_cost+close15)/2\r\n\r\n            isLongWin = close15 > long_cost + 10.0 and ((close15 < ema_upper and isPeak15) or (close[1]>=ema_upper and close15<ema_upper))\r\n            isLongLoss = close15 <= longStopLossOVS\r\n\r\n            isTrailingBRK = close15 > longTakeProfit and close15 > lastPeakPrice15\r\n            //if isTrailingBRK and L_mode == 1 // BRK\r\n                //longTakeProfit := longTakeProfit + 10.0  \r\n                //label.new(bar_index, high15,text = \"trailing =\"+ str.tostring(close15, \"#,###\"), style=label.style_label_down, size=size.small)\r\n            isLongWinBRK = close15 >= longTakeProfit and close15 < ema_upper\r\n            isLongLossBRK = close15 <= longStopLoss\r\n            // Stop loss L\r\n            if isLongLossBRK\r\n                strategy.close(\"Long BRK\", comment=\"SL Long BRK @\"+ str.tostring(close15, \"#,###\"))\r\n                L_mode := 0 // clear\r\n\r\n\r\n            //if close15 <= longStopLossOVS\r\n            if isLongLoss\r\n                if strategy.position_size == 2\r\n                    strategy.close_all(comment=\"SL OVS @\"+ str.tostring(close15, \"#,###\"))\r\n                    L_mode := 0 // clear\r\n                else\r\n                    strategy.close(\"Long OVS\", comment=\"SL Long OVS @\"+ str.tostring(close15, \"#,###\"))\r\n                    strategy.close(\"Long OVS 2\", comment=\"SL Long OVS @\"+ str.tostring(close15, \"#,###\"))\r\n                    L_mode := 0 // clear\r\n\r\n            //if close15 > longTakeProfitOVS //(close15 > longTakeProfitOVS -8.0 and isFalseBrk)\r\n            if isLongWin\r\n                if strategy.position_size == 2\r\n                    strategy.close_all(comment=\"TP OVS @\"+ str.tostring(close15, \"#,###\"))\r\n                    L_mode := 0 // clear\r\n                else\r\n                    strategy.close(\"Long OVS\", comment=\"TP OVS 1@\"+ str.tostring(close15, \"#,###\"))\r\n                    strategy.close(\"Long OVS 2\", comment=\"TP OVS 2 @\"+ str.tostring(close15, \"#,###\"))\r\n                    L_mode := 0 // clear\r\n\r\n            if false // isLongWinBRK\r\n                strategy.close(\"Long BRK\", comment=\"TP Long BRK @\"+ str.tostring(close15, \"#,###\"))\r\n                L_mode := 0 // clear\r\n\r\n\r\n            var label trail_label = na\r\n            if Trailing == true and (high15 >= longTakeProfit or (close15<ema200 and close15 >= long_cost+10.0)) // any part of price hit tarket\r\n                if isLongCondition   // meet creteria to open L again \r\n                    longTakeProfit := close15 + 80.0 \r\n                    longStopLoss := (SLlimit? close15 - 15.0: lastBottomPrice15)\r\n                    trail_label := label.new(bar_index, high15,text = \"trailing =\"+ str.tostring(close15, \"#,###\"), style=label.style_label_down, size=size.small)\r\n                else // Take Profit\r\n                    strategy.close(\"Long BRK\", comment=\"Reach\" + str.tostring(longTakeProfit,\"#,###\")) \r\n\r\n\r\n    else if sidewaysMarket\r\n        SW_counter := SW_counter + 1\r\n        L_Rebound = SW_counter > 80 and close[2] < ema_lower and close[1] >= ema_lower and close15 > ema_lower //and k15 < 60\r\n\r\n        if strategy.position_size > 0 \r\n            if SW_counter < 10 // close15 < longStopLoss // In case holding L position from Trend market\r\n                strategy.close(\"Long BRK\", comment=\"Reverse SW \" + str.tostring(close15, \"#,###\") )\r\n                L_mode := 0 // clear\r\n\r\n            if SW_counter < 10 // close15 < longStopLossOVS\r\n                strategy.close_all(comment=\"Stop all \" + str.tostring(close15, \"#,###\"))\r\n                //strategy.close(\"Long OVS\", comment=\"Stop Oversold \" + str.tostring(close15, \"#,###\") )\r\n                //strategy.close(\"Long OVS 2\", comment=\"SL Long OVS @\"+ str.tostring(close15, \"#,###\"))\r\n                L_mode := 0 // clear\r\n\r\n            if SW_counter < 10 //close15 >= ema200-5.0\r\n                strategy.close(\"Long Rebound\", comment=\"TP Rebound \" + str.tostring(close15, \"#,###\") )\r\n        \r\n        if strategy.position_size == 0 and L_Rebound and inhiSideway == false\r\n            strategy.entry(\"Long Rebound\", strategy.long, comment=\"Rebound \" + str.tostring(close15, \"#,###\"))\r\n            strategy.exit(\"Exit Long Rebound\",from_entry=\"Long Rebound\", stop = ema_lower - (ema_lower*2*trend_gap_p/100) , comment = \"SL Rebound\")\r\n\r\n\r\n\r\n\r\n\r\nvar label DebugLabel = na\r\nlabel.delete(DebugLabel)\r\nif not na(latch_trend)\r\n    DebugLabel := label.new(bar_index, high15, text=\"trend \" + str.tostring(latch_trend,\"#\") , style=label.style_label_down, color=color.blue, textcolor=color.white, size=size.small)\r\n\r\n\r\n// Plot Bollinger Bands\r\n//plot(sidewaysMarket ? lastBottomPrice15 : na , color=color.yellow, style=plot.style_circles)\r\n//plot(sidewaysMarket ? lastPeakPrice15 : na , color=color.blue, style=plot.style_circles)\r\nplot(trendMarket ? lastBottomPrice15 : na, color=color.red, style=plot.style_circles)\r\nplot(trendMarket ? lastPeakPrice15 : na, color=color.green, style=plot.style_circles)\r\nbgcolor(sidewaysMarket ? color.new(color.black, 90) : na)\r\nbgcolor(trendMarket ? color.new(color.lime, 90) : na)\r\n\r\n// Plot the three lines\r\nplot(ema200, title=\"EMA 200\",       color=color.white)\r\nplot(ema_upper,  title=\"EMA 200 + 20\",  color=color.white)\r\nplot(ema_lower,  title=\"EMA 200 - 20\",  color=color.white)\r\n\r\n"
  },
  {
    "url": "XKdzjUYc",
    "name": "QQQ Momentum Regime Rider (EMA + VWAP + ADX + Vol Pullback)",
    "description": "My strategy catches intraday momentum, has a phenomenal return of 18% annually",
    "image_url": "XKdzjUYc",
    "author": "sjwyqvhtex",
    "likes": 6,
    "type": "strategy",
    "created": "2025-11-14",
    "updated": "2025-11-14",
    "source": "//@version=5\nstrategy(\"QQQ Momentum Regime Rider (EMA + VWAP + ADX + Vol Pullback)\",\n     overlay                = true,\n     initial_capital        = 100000,\n     commission_type        = strategy.commission.percent,\n     commission_value       = 0.0,\n     pyramiding             = 0,          // one position at a time\n     calc_on_every_tick     = true,\n     process_orders_on_close= true,\n     max_labels_count       = 500)\n\n//========= INPUTS =========//\nriskPerTrade   = input.float(1000, \"Risk per trade ($)\", minval = 100, step = 100)\natrLen         = input.int(14, \"ATR length\", minval = 5)\npullbackATR    = input.float(0.8, \"Max distance from EMA20 (ATR)\", minval = 0.1, step = 0.1)\n\ndmiLen         = input.int(14, \"DMI / ADX length\", minval = 5)\nadxTrendThresh = input.float(20.0, \"Min ADX for trend regime\", minval = 5, step = 1)\n\nvolLen         = input.int(20, \"Volume MA length\", minval = 5)\nvolDryFactor   = input.float(0.7, \"Max vol as % of avg on pullback\", minval = 0.1, maxval = 1.0, step = 0.05)\n\nsessionTime    = input.session(\"0930-1600\", \"Regular hours (NY)\")\nuseSession     = input.bool(true, \"Use RTH only\")\n\ntpRR           = input.float(3.0, \"Take-profit RR\", minval = 1.0, step = 0.1)\nslATRmult      = input.float(1.5, \"Stop distance (ATR multiples)\", minval = 0.5, step = 0.1)\n\n//========= INDICATORS =========//\n// 1m EMAs & VWAP\nema20 = ta.ema(close, 20)\nema50 = ta.ema(close, 50)\nvwap  = ta.vwap(close)\natr   = ta.atr(atrLen)\n\n// DMI / ADX  â€”â€” æ³¨æ„ï¼šTradingView è¿™é‡Œç”¨çš„æ˜¯ ta.dmi(length, adxSmoothing)\n[posDI, negDI, adx] = ta.dmi(dmiLen, dmiLen)\n\n// Volume regime\nvolMA  = ta.sma(volume, volLen)\nvolDry = volume < volMA * volDryFactor  // ç¼©é‡æ¡ä»¶\n\n// Session filter\ninSession = useSession ? not na(time(timeframe.period, sessionTime)) : true\n\n//========= TREND REGIME =========//\nbullTrend = ema20 > ema50 and adx > adxTrendThresh and posDI > negDI\nbearTrend = ema20 < ema50 and adx > adxTrendThresh and negDI > posDI\n\n//========= PULLBACK å®šä¹‰ï¼ˆè´´ EMA20 + ç¼©é‡ï¼‰ =========//\natrSafe   = math.max(atr, syminfo.mintick * 4)\n\nnearEma20 = math.abs(close - ema20) <= pullbackATR * atrSafe\n\n// Long æ–¹å‘çš„â€œå¥åº·å›žè°ƒâ€ = å¼ºå¤šå¤´è¶‹åŠ¿ + ä»·åœ¨ ema50 ä¹‹ä¸Š + å›žåˆ° ema20 é™„è¿‘ + åœ¨ VWAP ä¸Šæ–¹ + ç¼©é‡\nhealthyPullbackLong =\n     bullTrend and\n     close > ema50 and\n     close > vwap and\n     nearEma20 and\n     volDry\n\n// Short æ–¹å‘çš„â€œå¥åº·å›žè°ƒâ€ = å¼ºç©ºå¤´è¶‹åŠ¿ + ä»·åœ¨ ema50 ä¹‹ä¸‹ + å›žåˆ° ema20 é™„è¿‘ + åœ¨ VWAP ä¸‹æ–¹ + ç¼©é‡\nhealthyPullbackShort =\n     bearTrend and\n     close < ema50 and\n     close < vwap and\n     nearEma20 and\n     volDry\n\n//========= POSITION SIZE =========//\nstopDist = atrSafe * slATRmult\nqty      = riskPerTrade / stopDist\n\n//========= ENTRY CONDITIONSï¼ˆå•è¡Œï¼Œé˜²æ­¢æ¢è¡ŒæŠ¥é”™ï¼‰ =========//\nlongCond  = inSession and healthyPullbackLong  and strategy.position_size == 0\nshortCond = inSession and healthyPullbackShort and strategy.position_size == 0\n\n//========= EXECUTION =========//\n//================= EXECUTION =================//\n\n// è¿›åœºé€»è¾‘ä¿æŒä¸å˜ï¼šåªåœ¨æ»¡è¶³æ¡ä»¶ & æ— æŒä»“æ—¶è¿›åœº\nif longCond and strategy.position_size == 0\n    strategy.entry(\"Long\", strategy.long, qty = qty)\n\nif shortCond and strategy.position_size == 0\n    strategy.entry(\"Short\", strategy.short, qty = qty)\n\n\n//================= EXECUTION (BE + EMA20 only) =================//\n\n// -------- Long å‡ºåœºé€»è¾‘ï¼ˆåŠ¨æ€æ­¢æŸ + å›ºå®šRRæ­¢ç›ˆï¼‰ --------\nif strategy.position_size > 0 and strategy.position_avg_price > 0\n    entryLong   = strategy.position_avg_price\n    baseStopL   = entryLong - stopDist                      \n    beTriggerL  = entryLong + stopDist                      \n    beStopL     = close >= beTriggerL ? entryLong : baseStopL\n\n    trendStopL  = ema20 - atr * 0.2\n    finalStopL  = math.max(beStopL, trendStopL)\n\n    tpLong      = entryLong + stopDist * tpRR\n\n    strategy.exit(\"Long Exit\", \"Long\", stop = finalStopL, limit = tpLong)\n\n\n// -------- Short å‡ºåœºé€»è¾‘ --------\nif strategy.position_size < 0 and strategy.position_avg_price > 0\n    entryShort  = strategy.position_avg_price\n    baseStopS   = entryShort + stopDist\n    beTriggerS  = entryShort - stopDist\n    beStopS     = close <= beTriggerS ? entryShort : baseStopS\n\n    trendStopS  = ema20 + atr * 0.2\n    finalStopS  = math.min(beStopS, trendStopS)\n\n    tpShort     = entryShort - stopDist * tpRR\n    strategy.exit(\"Short Exit\", \"Short\", stop = finalStopS, limit = tpShort)\n\n//========= PLOTS =========//\nplot(ema20, \"EMA20\", color=color.orange)\nplot(ema50, \"EMA50\", color=color.blue)\nplot(vwap, \"VWAP\", color=color.new(color.purple, 0))\n\n// ADX / Volume å‡çº¿é»˜è®¤éšè—ï¼Œåªç”¨æ¥è°ƒå‚\nplot(adx,   \"ADX\",   color=color.new(color.teal,   0), display = display.none)\nplot(volMA, \"VolMA\", color=color.new(color.yellow, 0), display = display.none) "
  },
  {
    "url": "oRvV8YUZ",
    "name": "only test",
    "description": "only test\n\nthis chart is only test...\nthis chart is only test...\nthis chart is only test...\n",
    "image_url": "oRvV8YUZ",
    "author": "jangwooseng97",
    "likes": 5,
    "type": "strategy",
    "created": "2025-11-14",
    "updated": "2025-11-14",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// Â© jangwooseng97\n\n//@version=6\nstrategy(\"ë‚´ ì „ëžµ\", overlay=true, fill_orders_on_standard_ohlc = true)\n\nlongCondition = ta.crossover(ta.sma(close, 14), ta.sma(close, 28))\nif (longCondition)\n    strategy.entry(\"My Long Entry Id\", strategy.long)\n\nshortCondition = ta.crossunder(ta.sma(close, 14), ta.sma(close, 28))\nif (shortCondition)\n    strategy.entry(\"My Short Entry Id\", strategy.short)\n"
  },
  {
    "url": "cjrCh5y3-Range-Oscillator-Strategy-Stoch-Confirm",
    "name": "Range Oscillator Strategy + Stoch Confirm",
    "description": "ðŸ”¹ Short summary\nThis is a free, educational long-only strategy built on top of the public â€œRange Oscillatorâ€ by Zeiierman (used under CC BY-NC-SA 4.0), combined with a Stochastic timing filter, an EMA-based exit filter and an optional risk-management layer (SL/TP and R-multiple exits). It is NOT financial advice and it is NOT a magic money machine. Itâ€™s a structured framework to study how range-expansion + momentum + trend slope can be combined into one rule-based system, often with intentionally RARE trades.\n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n0. Legal / risk disclaimer\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nâ€¢ This script is FREE and public. I do not charge any fee for it.\nâ€¢ It is for EDUCATIONAL PURPOSES ONLY.\nâ€¢ It is NOT financial advice and does NOT guarantee profits.\nâ€¢ Backtest results can be very different from live results.\nâ€¢ Markets change over time; past performance is NOT indicative of future performance.\nâ€¢ You are fully responsible for your own trades and risk.\n\nPlease DO NOT use this script with money you cannot afford to lose. Always start in a demo / paper trading environment and make sure you understand what the logic does before you risk any capital.\n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n1. About default settings and risk (very important)\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nThe script is configured with the following defaults in the `strategy()` declaration:\n\nâ€¢ `initial_capital = 10000`  \n  â†’ This is only an EXAMPLE account size.\n\nâ€¢ `default_qty_type = strategy.percent_of_equity`  \nâ€¢ `default_qty_value = 100`  \n  â†’ This means 100% of equity per trade in the default properties.\n  â†’ This is AGGRESSIVE and should be treated as a STRESS TEST of the logic, not as a realistic way to trade.\n\nTradingViewâ€™s House Rules recommend risking only a small part of equity per trade (often 1â€“2%, max 5â€“10% in most cases). To align with these recommendations and to get more realistic backtest results, I STRONGLY RECOMMEND you to:\n\n1. Open **Strategy Settings â†’ Properties**.\n2. Set:\n   â€¢ Order size: **Percent of equity**  \n   â€¢ Order size (percent): e.g. **1â€“2%** per trade\n3. Make sure **commission** and **slippage** match your own broker conditions.\n   â€¢ By default this script uses `commission_value = 0.1` (0.1%) and `slippage = 3`, which are reasonable example values for many crypto markets.\n\nIf you choose to run the strategy with 100% of equity per trade, please treat it ONLY as a stress-test of the logic. It is NOT a sustainable risk model for live trading.\n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n2. What this strategy tries to do (conceptual overview)\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nThis is a LONG-ONLY strategy designed to explore the combination of:\n\n1. **Range Oscillator (Zeiierman-based)**  \n   - Measures how far price has moved away from an adaptive mean.\n   - Uses an ATR-based range to normalize deviation.\n   - High positive oscillator values indicate strong price expansion away from the mean in a bullish direction.\n\n2. **Stochastic as a timing filter**  \n   - A classic Stochastic (%K and %D) is used.\n   - The logic requires %K to be below a user-defined level and then crossing above %D.\n   - This is intended to catch moments when momentum turns up again, rather than chasing every extreme.\n\n3. **EMA Exit Filter (trend slope)**  \n   - An EMA with configurable length (default 70) is calculated.\n   - The slope of the EMA is monitored: when the slope turns negative while in a long position, and the filter is enabled, it triggers an exit condition.\n   - This acts as a trend-protection exit: if the medium-term trend starts to weaken, the strategy exits even if the oscillator has not yet fully reverted.\n\n4. **Optional risk-management layer**  \n   - Percentage-based Stop Loss and Take Profit (SL/TP).\n   - Risk/Reward (R-multiple) exit based on the distance from entry to SL.\n   - Implemented as OCO orders that work *on top* of the logical exits.\n\nThe goal is not to create a â€œholy grailâ€ system but to serve as a transparent, configurable framework for studying how these concepts behave together on different markets and timeframes.\n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n3. Components and how they work together\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n(1) Range Oscillator (based on â€œRange Oscillator (Zeiierman)â€)  \nâ€¢ The script computes a weighted mean price and then measures how far price deviates from that mean.  \nâ€¢ Deviation is normalized by an ATR-based range and expressed as an oscillator.  \nâ€¢ When the oscillator is above the **entry threshold** (default 100), it signals a strong move away from the mean in the bullish direction.  \nâ€¢ When it later drops below the **exit threshold** (default 30), it can trigger an exit (if enabled).\n\n(2) Stochastic confirmation  \nâ€¢ Classic Stochastic (%K and %D) is calculated.  \nâ€¢ An entry requires:\n  - %K to be below a user-defined â€œCross Levelâ€, and  \n  - then %K to cross above %D.  \nâ€¢ This is a momentum confirmation: the strategy tries to enter when momentum turns up from a pullback rather than at any random point.\n\n(3) EMA Exit Filter  \nâ€¢ The EMA length is configurable via `emaLength` (default 70).  \nâ€¢ The script monitors the EMA slope: it computes the relative change between the current EMA and the previous EMA.  \nâ€¢ If the slope turns negative while the strategy holds a long position and the filter is enabled, it triggers an exit condition.  \nâ€¢ This is meant to help protect profits or cut losses when the medium-term trend starts to roll over, even if the oscillator conditions are not (yet) signalling exit.\n\n(4) Risk management (optional)  \nâ€¢ Stop Loss (SL) and Take Profit (TP):\n  - Defined as percentages relative to average entry price.\n  - Both are disabled by default, but you can enable them in the Inputs.  \nâ€¢ Risk/Reward Exit:\n  - Uses the distance from entry to SL to project a profit target at a configurable R-multiple.\n  - Also optional and disabled by default.\n\nThese exits are implemented as `strategy.exit()` OCO orders and can close trades independently of oscillator/EMA conditions if hit first.\n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n4. Entry & Exit logic (high level)\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nA) Time filter  \nâ€¢ You can choose a **Start Year** in the Inputs.  \nâ€¢ Only candles between the selected start date and 31 Dec 2069 are used for backtesting (`timeCondition`).  \nâ€¢ This prevents accidental use of tiny cherry-picked windows and makes tests more honest.\n\nB) Entry condition (long-only)  \nA long entry is allowed when ALL the following are true:\n\n1. `timeCondition` is true (inside the backtest window).  \n2. If `useOscEntry` is true:\n   - Range Oscillator value must be above `entryLevel`.  \n3. If `useStochEntry` is true:\n   - Stochastic condition (`stochCondition`) must be true:\n     - %K < `crossLevel`, then %K crosses above %D.\n\nIf these filters agree, the strategy calls `strategy.entry(\"Long\", strategy.long)`.\n\nC) Exit condition (logical exits)  \nA position can be closed when:\n\n1. `timeCondition` is true AND a long position is open, AND  \n2. At least one of the following is true:\n   - If `useOscExit` is true: Oscillator is below `exitLevel`.  \n   - If `useMagicExit` (EMA Exit Filter) is true: EMA slope is negative (`isDown = true`).\n\nIn that case, `strategy.close(\"Long\")` is called.\n\nD) Risk-management exits  \nWhile a position is open:\n\nâ€¢ If SL or TP is enabled:\n  - `strategy.exit(\"Long Risk\", ...)` places an OCO stop/limit order based on the SL/TP percentages.  \n\nâ€¢ If Risk/Reward exit is enabled:\n  - `strategy.exit(\"RR Exit\", ...)` places an OCO order using a projected R-multiple (`rrMult`) of the SL distance.\n\nThese risk-based exits can trigger before the logical oscillator/EMA exits if price hits those levels.\n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n5. Recommended backtest configuration (to avoid misleading results)\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nTo align with TradingView House Rules and avoid misleading backtests:\n\n1. **Initial capital**  \n   - 10 000 (or any value you personally want to work with).\n\n2. **Order size**  \n   - Type: **Percent of equity**  \n   - Size: **1â€“2%** per trade is a reasonable starting point.  \n   - Avoid risking more than 5â€“10% per trade if you want results that could be sustainable in practice.\n\n3. **Commission & slippage**  \n   - Commission: around 0.1% if that matches your broker.  \n   - Slippage: a few ticks (e.g. 3) to account for real fills.\n\n4. **Timeframe & markets**  \n   - Volatile symbols (e.g. crypto like BTCUSDT, or major indices).  \n   - Timeframes: 1H / 4H / **1D (Daily)** are typical starting points.  \n   - I strongly recommend trying the strategy on **different timeframes**, for example 1D, to see how the behaviour changes between intraday and higher timeframes.\n\n5. **No â€œcaution warningâ€**  \n   - Make sure your chosen symbol + timeframe + settings do not trigger TradingViewâ€™s caution messages.  \n   - If you see warnings (e.g. â€œtoo few tradesâ€), adjust timeframe/symbol or the backtest period.\n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n5a. About low trade count and rare signals\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nThis strategy is intentionally designed to trade RARELY:\n\nâ€¢ It is **long-only**.  \nâ€¢ It uses strict filters (Range Oscillator threshold + Stochastic confirmation + optional EMA Exit Filter).  \nâ€¢ On higher timeframes (especially **1D / Daily**) this can result in a **low total number of trades**, sometimes WELL BELOW 100 trades over the whole backtest.\n\nTradingViewâ€™s House Rules mention 100+ trades as a guideline for more robust statistics. In this specific case:\n\nâ€¢ The **low trade count is a conscious design choice**, not an attempt to cherry-pick a tiny, ultra-profitable window.  \nâ€¢ The goal is to study a **small number of high-conviction long entries** on higher timeframes, not to generate frequent intraday signals.  \nâ€¢ Because of the low trade count, results should NOT be interpreted as statistically strong or â€œprovenâ€ â€“ they are only one sample of how this logic would have behaved on past data.\n\nPlease keep this in mind when you look at the equity curve and performance metrics. A beautiful curve with only a handful of trades is still just a small sample.\n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n6. How to use this strategy (step-by-step)\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n1. Add the script to your chart.  \n2. Open the **Inputs** tab:\n   - Set the backtest start year.  \n   - Decide whether to use Oscillator-based entry/exit, Stochastic confirmation, and EMA Exit Filter.  \n   - Optionally enable SL, TP, and Risk/Reward exits.  \n\n3. Open the **Properties** tab:\n   - Set a realistic account size if you want.  \n   - Set order size to a realistic % of equity (e.g. 1â€“2%).  \n   - Confirm that commission and slippage are realistic for your broker.  \n\n4. Run the backtest:\n   - Look at Net Profit, Max Drawdown, number of trades, and equity curve.  \n   - Remember that a low trade count means the statistics are not very strong.  \n\n5. Experiment:\n   - Tweak thresholds (`entryLevel`, `exitLevel`), Stochastic settings, EMA length, and risk params.  \n   - See how the metrics and trade frequency change.  \n\n6. Forward-test:\n   - Before using any idea in live trading, forward-test on a demo account and observe behaviour in real time.\n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n7. Originality and usefulness (why this is more than a mashup)\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nThis script is not intended to be a random visual mashup of indicators. It is designed as a coherent, testable strategy with clear roles for each component:\n\nâ€¢ Range Oscillator:\n  - Handles mean vs. range-expansion states via an adaptive, ATR-normalized metric.  \n\nâ€¢ Stochastic:\n  - Acts as a timing filter to avoid entering purely on extremes and instead waits for momentum to turn.  \n\nâ€¢ EMA Exit Filter:\n  - Trend-slope-based safety net to exit when the medium-term direction changes against the position.  \n\nâ€¢ Risk module:\n  - Provides practical, rule-based exits: SL, TP, and R-multiple exit, which are useful for structuring risk even if you modify the core logic.\n\nIt aims to give traders a ready-made **framework to study and modify**, not a black box or â€œsignalsâ€ product.\n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n8. Limitations and good practices\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nâ€¢ No single strategy works on all markets or in all regimes.  \nâ€¢ This script is long-only; it does not short the market.  \nâ€¢ Performance can degrade when market structure changes.  \nâ€¢ Overfitting (curve fitting) is a real risk if you endlessly tweak parameters to maximise historical profit.  \n\nGood practices:\n- Test on multiple symbols and timeframes.  \n- Focus on stability and drawdown, not only on how high the profit line goes.  \n- View this as a learning tool and a basis for your own research.\n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n9. Licensing and credits\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nâ€¢ Core oscillator idea & base code:\n  - â€œRange Oscillator (Zeiierman)â€  \n  - Â© Zeiierman, licensed under CC BY-NC-SA 4.0.\n\nâ€¢ Strategy logic, Stochastic confirmation, EMA Exit Filter, and risk-management layer:\n  - Modifications by jokiniemi.\n\nPlease respect both the original license and TradingView House Rules if you fork or republish any part of this script.\n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n10. No payments / no vendor pitch\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\nâ€¢ This script is completely FREE to use on TradingView.  \nâ€¢ There is no paid subscription, no external payment link, and no private signals group attached to it.  \nâ€¢ If you have questions, please use TradingViewâ€™s comment system or private messages instead of expecting financial advice.\n\nUse this script as a tool to learn, experiment, and build your own understanding of markets.\n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n11. Example backtest settings used in screenshots\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\nTo avoid any confusion about how the results shown in screenshots were produced, here is one concrete example configuration:\n\nâ€¢ Symbol: BTCUSDT (or similar major BTC pair)  \nâ€¢ Timeframe: 1D (Daily)  \nâ€¢ Backtest period: from 2018 to the most recent data  \nâ€¢ Initial capital: 10 000  \nâ€¢ Order size type: Percent of equity  \nâ€¢ Order size: 2% per trade  \nâ€¢ Commission: 0.1%  \nâ€¢ Slippage: 3 ticks  \nâ€¢ Risk settings: Stop Loss and Take Profit disabled by default, Risk/Reward exit disabled by default  \nâ€¢ Filters: Range Oscillator entry/exit enabled, Stochastic confirmation enabled, EMA Exit Filter enabled  \n\nIf you change any of these settings (symbol, timeframe, risk per trade, commission, slippage, filters, etc.), your results will look different. Please always adapt the configuration to your own risk tolerance, market, and trading style.\n",
    "image_url": "cjrCh5y3",
    "author": "jokiniemi",
    "likes": 27,
    "type": "strategy",
    "created": "2025-11-13",
    "updated": "2025-11-13",
    "source": "// Based on \"Range Oscillator (Zeiierman)\"\n// Â© Zeiierman, licensed under CC BY-NC-SA 4.0\n// Modifications and strategy logic by jokiniemi.\n//\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// IMPORTANT DISCLAIMER / TV HOUSE RULES\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// â€¢ This script is FREE and public. I do not charge any fee for it.\n// â€¢ It is for EDUCATIONAL PURPOSES ONLY and is NOT financial advice.\n// â€¢ Backtest results can be very different from live trading.\n// â€¢ Markets change over time; past performance is NOT indicative of future results.\n// â€¢ You are fully responsible for your own decisions and risk.\n//\n// About default settings and risk:\n// â€¢ initial_capital = 10000 is an example only.\n// â€¢ default_qty_value = 100 means 100% of equity per trade in the default\n//   properties. This is AGGRESSIVE and is used only as a stress-test example.\n// â€¢ TradingView House Rules recommend risking only a small part of equity\n//   (often 1â€“2%, max 5â€“10%) per trade.\n// â€¢ BEFORE trusting any results, please open Strategy Properties and set:\n//     - Order size type: Percent of equity\n//     - Order size: e.g. 1â€“2 % per trade (more realistic)\n//     - Commission & slippage: match your broker\n// â€¢ For meaningful statistics, test on long data samples with 100+ trades.\n//\n// If you stray from these recommendations (for example by using 100% of equity),\n// treat it ONLY as a stress-test of the strategy logic, NOT as a realistic\n// live-trading configuration.\n//\n// About inputs in status line:\n// â€¢ Pine Script cannot hide individual inputs from the status line by code.\n// â€¢ If you want to hide them, right-click the status line â†’ Settings and\n//   disable showing Inputs there.\n//\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// HIGH-LEVEL STRATEGY DESCRIPTION\n// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n// â€¢ Uses a Range Oscillator (based on Zeiierman) to detect how far price\n//   has moved away from an adaptive mean (range expansion).\n// â€¢ Uses Stochastic as a timing filter so we don't enter on every extreme\n//   but only when momentum turns up again.\n// â€¢ Uses an EMA slope-based \"EMA Exit Filter\" to force exits when the\n//   medium-term trend turns down.\n// â€¢ Optional Stop Loss / Take Profit and Risk/Reward exits can be enabled\n//   in the inputs to manage risk.\n// â€¢ Long-only by design.\n//\n// Please also read the script DESCRIPTION on TradingView for a detailed,\n// non-code explanation of what the strategy does, how it works conceptually,\n// how to configure it, and how to use it responsibly.\n\n// Generated: 2025-11-08 12:00 Europe/Helsinki\n//@version=6\nstrategy(\"Range Oscillator Strategy + Stoch Confirm\", overlay=false, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=100, commission_type=strategy.commission.percent, commission_value=0.1, slippage=3, margin_long=0, margin_short=0, fill_orders_on_standard_ohlc=true)\n\n// === [Backtest Period] ===\n// User-controlled backtest window. Helps avoid cherry-picking a tiny period.\nstartYear  = input.int(2018, \"Start Year\", minval=2000, maxval=2069, step=1, group=\"Backtest\")\nstartDate  = timestamp(startYear, 1, 1, 0, 0)\nendDate    = timestamp(\"31 Dec 2069 23:59 +0000\")\ntimeCondition = time >= startDate and time <= endDate\n\n// === [Strategy Logic Settings] ===\n// Toggles allow you to test each building block separately.\nuseOscEntry   = input.bool(true, title=\"Use Range Oscillator for Entry (value over Threshold)\", group=\"Strategy Logic\")\nuseStochEntry = input.bool(true, title=\"Use Stochastic Confirm for Entry\", group=\"Strategy Logic\")\nuseOscExit    = input.bool(true, title=\"Use Range Oscillator for Exit\", group=\"Strategy Logic\")\nuseMagicExit  = input.bool(true, title=\"Use EMA Exit Filter\", group=\"Strategy Logic\") // EMA-slope based exit\n\nentryLevel = input.float(100.0, title=\"Range Osc Entry Threshold\", group=\"Strategy Logic\")  // Higher = fewer, stronger signals\nexitLevel  = input.float(30.0,  title=\"Range Osc Exit Threshold\", group=\"Strategy Logic\")   // Controls when to exit on mean reversion\n\n// EMA length for exit filter (default 70), used in the \"EMA Exit Filter\".\nemaLength = input.int(70, title=\"EMA Exit Filter Length\", minval=1, group=\"Strategy Logic\")\n\n// === [Stochastic Settings] ===\n// Stochastic is used as a momentum confirmation filter (timing entries).\nperiodK     = input.int(7, title=\"%K Length\", minval=1, group=\"Stochastic\")\nsmoothK     = input.int(3, title=\"%K Smoothing\", minval=1, group=\"Stochastic\")\nperiodD     = input.int(3, title=\"%D Smoothing\", minval=1, group=\"Stochastic\")\ncrossLevel  = input.float(100.0, title=\"Stoch %K (blue line) Must Be Below This Before Crossing %D orange line\", minval=0, maxval=100, group=\"Stochastic\")\n\n// === [Range Oscillator Settings] ===\n// Range Oscillator measures deviation from a weighted mean, normalized by ATR.\nlength    = input.int(50, title=\"Minimum Range Length\", minval=1, group=\"Range Oscillator\")\nmult      = input.float(2.0, title=\"Range Width Multiplier\", minval=0.1, group=\"Range Oscillator\")\n\n// === [Risk Management] ===\n// Optional risk exits. By default SL/TP are OFF in code â€“ you can enable them in Inputs.\n// TradingView recommends using realistic SL/TP and small risk per trade.\nuseSL = input.bool(false, title=\"Use Stop Loss\", group=\"Risk Management\")\nslPct = input.float(1.5, title=\"Stop Loss (%)\", minval=0.0, step=0.1, group=\"Risk Management\") // Example: 1.5% of entry price\nuseTP = input.bool(false, title=\"Use Take Profit\", group=\"Risk Management\")\ntpPct = input.float(3.0, title=\"Take Profit (%)\", minval=0.0, step=0.1, group=\"Risk Management\")\n\n// === [Risk/Reward Exit] ===\n// Optional R-multiple exit based on distance from entry to SL.\nuseRR = input.bool(false, title=\"Use Risk/Reward Exit\", group=\"Risk/Reward Exit\")\nrrMult = input.float(1.5, title=\"Reward/Risk Multiplier\", minval=0.1, step=0.1, group=\"Risk/Reward Exit\")\n\n// === [Range Oscillator Calculation] ===\n// Core oscillator logic (based on Zeiiermanâ€™s Range Oscillator).\natrRaw   = nz(ta.atr(2000), ta.atr(200))\nrangeATR = atrRaw * mult\n\nsumWeightedClose = 0.0\nsumWeights = 0.0\nfor i = 0 to length - 1\n    delta = math.abs(close[i] - close[i + 1])\n    w = delta / close[i + 1]\n    sumWeightedClose += close[i] * w\n    sumWeights += w\nma = sumWeights != 0 ? sumWeightedClose / sumWeights : na\n\ndistances = array.new_float(length)\nfor i = 0 to length - 1\n    array.set(distances, i, math.abs(close[i] - ma))\nmaxDist = array.max(distances)\nosc = rangeATR != 0 ? 100 * (close - ma) / rangeATR : na\n\n// === [Stochastic Logic] ===\n// Stochastic cross used as confirmation: momentum turns up after being below a level.\nk = ta.sma(ta.stoch(close, high, low, periodK), smoothK)\nd = ta.sma(k, periodD)\nstochCondition = k < crossLevel and ta.crossover(k, d)\n\n// === [EMA Filter ] ===\n// EMA-slope-based exit filter: when EMA slope turns negative in a long, exit condition can trigger.\nema     = ta.ema(close, emaLength)\nchg     = ema - ema[1]\npct     = ema[1] != 0 ? (chg / ema[1]) * 100.0 : 0.0\nisDown  = pct < 0\nmagicExitCond = useMagicExit and isDown and strategy.position_size > 0\n\n// === [Entry & Exit Conditions] ===\n// Long-only strategy:\n// â€¢ Entry: timeCondition + (Range Oscillator & Stoch, if enabled)\n// â€¢ Exit: Range Oscillator exit and/or EMA Exit Filter.\noscEntryCond   = not useOscEntry or (osc > entryLevel)\nstochEntryCond = not useStochEntry or stochCondition\nentryCond      = timeCondition and oscEntryCond and stochEntryCond\n\noscExitCond = not useOscExit or (osc < exitLevel)\nexitCond = timeCondition and strategy.position_size > 0 and (oscExitCond or magicExitCond)\n\nif entryCond\n    strategy.entry(\"Long\", strategy.long)\n\nif exitCond\n    strategy.close(\"Long\")\n\n// === [Risk Management Exits] ===\n// Optional SL/TP and RR exits (OCO). They sit on top of the main exit logic.\n// Note: with default settings they are OFF, so you must enable them yourself.\nap      = strategy.position_avg_price\nslPrice = useSL ? ap * (1 - slPct / 100) : na\ntpPrice = useTP ? ap * (1 + tpPct / 100) : na\nrrStop  = ap * (1 - slPct / 100)\nrrLimit = ap + (ap - rrStop) * rrMult\n\nif strategy.position_size > 0\n    if useSL or useTP\n        strategy.exit(\"Long Risk\", from_entry=\"Long\", stop=slPrice, limit=tpPrice, comment=\"Risk OCO\")\n    if useRR\n        strategy.exit(\"RR Exit\", from_entry=\"Long\", limit=rrLimit, stop=rrStop, comment=\"RR OCO\")\n\n// === [Plot Only the Oscillator - Stoch hidden] ===\n// Visual focus on the Range Oscillator; Stochastic stays hidden but is used in logic.\ninTrade  = strategy.position_size > 0\noscColor = inTrade ? color.green : color.red\n\nplot(osc, title=\"Range Oscillator\", color=oscColor, linewidth=2)\nhline(entryLevel, \"Entry Level\", color=color.green, linestyle=hline.style_dotted)\nhline(exitLevel,  \"Exit Level\",  color=color.red,   linestyle=hline.style_dotted)\nplot(k, title=\"%K\", color=color.blue, display=display.none)\nplot(d, title=\"%D\", color=color.orange, display=display.none)\n\n// Plot EMA (hidden) so it is available but not visible on the chart.\nplot(ema, title=\"EMA Exit Filter\", display=display.none)\n"
  },
  {
    "url": "2c1JR1s9-Braid-Filter-Strategy",
    "name": "Braid Filter Strategy",
    "description": "This strategy is like a sophisticated set of traffic lights and speed limit signs for trading. It only allows a trade when multiple indicators line up to confirm a strong move, giving it its \"Braid Filter\" nameâ€”it weaves together several conditions.\n\nThe strategy is set up to use 100% of your account equity (your trading funds) on a trade and does not \"pyramid\" (it won't add to an existing trade).\n\n1. The Main Trend Check (The Traffic Lights)\nThe strategy uses three main filters that must agree before it considers a trade.\n\nA. The \"Chad Filter\" (Direction & Strength)\nThis is the heart of the strategy, a custom combination of three different Moving AveragesThese averages have fast, medium, and slow settings (3, 7, and 14 periods).\n\nGo Green (Buy Signal): The fastest average is higher than the medium average, AND the three averages are sufficiently separated (not tangled up, which indicates a strong move).\n\nGo Red (Sell Signal): The medium average is higher than the fastest average, AND the three averages are sufficiently separated.\n\nNeutral (Wait): If the averages are tangled or the separation isn't strong enough.\n\nKey Trigger: A primary condition for a signal is when the Chad Filter changes color (e.g., from Red/Grey to Green).\n\nB. The EMA Trend Bars (Secondary Confirmation)\nThis is a simpler, longer-term filter using a 34-period Exponential Moving Average (EMA). It checks if the current candle's average price is above or below this EMA.\n\nGreen Bars: The price is above the 34 EMA (Bullish Trend).\n\nRed Bars: The price is below the 34 EMA (Bearish Trend).\n\nTrades only happen if the signal direction matches the bar color. For a Buy, the bar must be Green. For a Sell, the bar must be Red.\n\nC. ADX/DI Filter (The Speed Limit Sign)\nThis uses the Average Directional Index (ADX) and Directional Movement Indicators (DI) to check if a trend is actually in motion and getting stronger.\n\nMust-Have Conditions:\n\nThe ADX value must be above 20 (meaning there is a trend, not just random movement).\n\nThe ADX line must be rising (meaning the trend is accelerating/getting stronger).\n\nThe strategy will only trade when the trend is strong and building momentum.\n\n2. The Trading Action (Entry and Exit)\nWhen all three filters (Chad Filter color change, EMA Trend Bar color, and ADX strength/slope) align, the strategy issues a signal, but it doesn't enter immediately.\n\nEntry Strategy (The \"Wait-for-Confirmation\" Approach):\n\nWhen a Buy Signal appears, the strategy sets a \"Buy Stop\" order at the signal candle's closing price.\n\nIt then waits for up to 3 candles (Candles Valid for Entry). The price must move up and hit that Buy Stop price within those 3 candles to confirm the move and enter the trade.\n\nA Sell Signal works the same way but uses a \"Sell Stop\" at the closing price, waiting for the price to drop and hit it.\n\nRisk Management (Stop Loss and Take Profit):\n\nStop Loss: To manage risk, the strategy finds a recent significant low (for a Buy) or high (for a Sell) over the last 20 candles and places the Stop Loss there. This is a logical place where the current move would be considered \"broken\" if the price reaches it.\n\nTake Profit: It uses a fixed Risk:Reward Ratio (set to 1.5 by default). This means the potential profit (Take Profit distance) is $1.50 for every $1.00 of risk (Stop Loss distance).\n\n3. Additional Controls\nTime Filter: You can choose to only allow trades during specific hours of the day.\n\nVisuals: It shows a small triangle on the chart where the signal happens and colors the background to reflect the Chad Filter's trend (Green/Red/Grey) and the candle bars to show the EMA trend (Lime/Red).\n\nðŸŽ¯ Summary of the Strategy's Goal\nThis strategy is designed to capture strong, confirmed momentum moves. It uses a fast, custom indicator (\"Chad Filter\") to detect the start of a new move, confirms that move with a slower trend filter (34 EMA), and then validates the move's strength with the ADX. By waiting a few candles for the price to hit the entry level, it aims to avoid false signals.",
    "image_url": "2c1JR1s9",
    "author": "ChadAnt",
    "likes": 35,
    "type": "strategy",
    "created": "2025-11-13",
    "updated": "2025-11-13",
    "source": "//@version=6\r\nstrategy(\"Braid Filter Strategy\", shorttitle=\"ChadAnt\", overlay=true, pyramiding=0, default_qty_type=strategy.percent_of_equity, default_qty_value=100)\r\n\r\n// --- Inputs ---\r\n// Chad Filter Inputs\r\ng_chad = \"Chad Filter\"\r\nmaType            = input.string(\"EMA\", \"MA Type\", options = [\"EMA\", \"DEMA\", \"TEMA\", \"WMA\", \"VWMA\", \"SMA\", \"SMMA\", \"HMA\", \"LSMA\", \"Kijun\", \"McGinley\", \"RMA\"], group=g_chad)\r\nPeriod1           = input.int(3,  \"Period 1\", group=g_chad)\r\nPeriod2           = input.int(7,  \"Period 2\", group=g_chad)\r\nPeriod3           = input.int(14, \"Period 3\", group=g_chad)\r\nPipsMinSepPercent = input.int(40, \"Pips Min Sep Percent\", group=g_chad)\r\n\r\n// EMA Trend Bars Inputs\r\ng_ema = \"EMA Trend Bars\"\r\nema1 = input.int(34, minval=1, maxval=300, title=\"EMA Length\", group=g_ema)\r\n\r\n// ADX and DI Inputs\r\ng_adx = \"ADX / DI\"\r\nlen = input.int(14, title=\"ADX Length\", group=g_adx)\r\nth = input.int(20, title=\"ADX Threshold\", group=g_adx)\r\n\r\n// Signal Control Inputs\r\ng_signals = \"Signal Controls\"\r\nshowBuySignals = input.bool(true, title=\"Show Buy Signals\", group=g_signals)\r\nshowSellSignals = input.bool(true, title=\"Show Sell Signals\", group=g_signals)\r\nuseTimeFilter = input.bool(false, title=\"Enable Time Filter\", group=g_signals)\r\nstartHour = input.int(0, title=\"Start Hour (0-23)\", minval=0, maxval=23, group=g_signals)\r\nstartMinute = input.int(0, title=\"Start Minute (0-59)\", minval=0, maxval=59, group=g_signals)\r\nendHour = input.int(23, title=\"End Hour (0-23)\", minval=0, maxval=23, group=g_signals)\r\nendMinute = input.int(59, title=\"End Minute (0-59)\", minval=0, maxval=59, group=g_signals)\r\n\r\n// Strategy Inputs\r\ng_strategy = \"Strategy Settings\"\r\ncandlesValid = input.int(3, title=\"Candles Valid for Entry\", minval=1, group=g_strategy)\r\nriskReward = input.float(1.5, title=\"Risk:Reward Ratio\", minval=0.1, step=0.1, group=g_strategy)\r\nmaxVisibleOrders = input.int(5, title=\"Max Visible Orders on Chart\", minval=1, maxval=20, group=g_strategy)\r\n\r\n\r\n// --- Functions ---\r\nma(string type, float src, int len) =>\r\n    float result = 0.0\r\n    if type==\"SMA\"\r\n        result := ta.sma(src, len)\r\n    else if type==\"EMA\"\r\n        result := ta.ema(src, len)\r\n    else if type==\"DEMA\"\r\n        e = ta.ema(src, len)\r\n        result := 2 * e - ta.ema(e, len)\r\n    else if type==\"TEMA\"\r\n        e = ta.ema(src, len)\r\n        result := 3 * (e - ta.ema(e, len)) + ta.ema(ta.ema(e, len), len)\r\n    else if type==\"WMA\"\r\n        result := ta.wma(src, len)\r\n    else if type==\"VWMA\"\r\n        result := ta.vwma(src, len)\r\n    else if type==\"SMMA\"\r\n        w = ta.wma(src, len)\r\n        result := na(w[1]) ? ta.sma(src, len) : (w[1] * (len - 1) + src) / len\r\n    else if type==\"RMA\"\r\n        result := ta.rma(src, len)\r\n    else if type==\"HMA\"\r\n        result := ta.wma(2 * ta.wma(src, len / 2) - ta.wma(src, len), int(math.round(math.sqrt(len))))\r\n    else if type==\"LSMA\"\r\n        result := ta.linreg(src, len, 0)\r\n    else if type==\"Kijun\"\r\n        kijun = math.avg(ta.lowest(len), ta.highest(len))\r\n        result := kijun\r\n    else if type==\"McGinley\"\r\n        mg = 0.0\r\n        mg := na(mg[1]) ? ta.ema(src, len) : mg[1] + (src - mg[1]) / (len * math.pow(src/mg[1], 4))\r\n        result := mg\r\n    result\r\n\r\n// Find local low (candle with higher lows on both sides)\r\nfindLocalLow(int lookback) =>\r\n    float localLow = high\r\n    int foundBar = -1\r\n    for i = 1 to lookback\r\n        if i > 0 and bar_index - i >= 0\r\n            if low[i] < low[i-1] and low[i] < low[i+1]\r\n                localLow := low[i]\r\n                foundBar := i\r\n                break\r\n    [localLow, foundBar]\r\n\r\n// Find local high (candle with lower highs on both sides)\r\nfindLocalHigh(int lookback) =>\r\n    float localHigh = low\r\n    int foundBar = -1\r\n    for i = 1 to lookback\r\n        if i > 0 and bar_index - i >= 0\r\n            if high[i] > high[i-1] and high[i] > high[i+1]\r\n                localHigh := high[i]\r\n                foundBar := i\r\n                break\r\n    [localHigh, foundBar]\r\n\r\n\r\n// --- Calculations ---\r\n\r\n// 1. Chad Filter\r\nma01 = ma(maType, close, Period1)\r\nma02 = ma(maType, open, Period2)\r\nma03 = ma(maType, close, Period3)\r\n\r\nmaxVal = math.max(math.max(ma01, ma02), ma03)\r\nminVal = math.min(math.min(ma01, ma02), ma03)\r\ndif = maxVal - minVal\r\n\r\nfilter = ta.atr(14) * PipsMinSepPercent / 100\r\nBraidColor = ma01 > ma02 and dif > filter ? color.green : ma02 > ma01 and dif > filter ? color.red : color.gray\r\n\r\n// 2. EMA Trend Bars\r\nusedEma = ta.ema(close, ema1)\r\nbarCol = hlc3 >= usedEma ? color.lime : color.red\r\n\r\n// 3. ADX and DI\r\nTrueRange = math.max(math.max(high-low, math.abs(high-nz(close[1]))), math.abs(low-nz(close[1])))\r\nDirectionalMovementPlus = high-nz(high[1]) > nz(low[1])-low ? math.max(high-nz(high[1]), 0): 0\r\nDirectionalMovementMinus = nz(low[1])-low > high-nz(high[1]) ? math.max(nz(low[1])-low, 0): 0\r\n\r\nvar float SmoothedTrueRange = 0.0\r\nSmoothedTrueRange := nz(SmoothedTrueRange[1]) - (nz(SmoothedTrueRange[1])/len) + TrueRange\r\n\r\nvar float SmoothedDirectionalMovementPlus = 0.0\r\nSmoothedDirectionalMovementPlus := nz(SmoothedDirectionalMovementPlus[1]) - (nz(SmoothedDirectionalMovementPlus[1])/len) + DirectionalMovementPlus\r\n\r\nvar float SmoothedDirectionalMovementMinus = 0.0\r\nSmoothedDirectionalMovementMinus := nz(SmoothedDirectionalMovementMinus[1]) - (nz(SmoothedDirectionalMovementMinus[1])/len) + DirectionalMovementMinus\r\n\r\nDIPlus = SmoothedDirectionalMovementPlus / SmoothedTrueRange * 100\r\nDIMinus = SmoothedDirectionalMovementMinus / SmoothedTrueRange * 100\r\nDX = math.abs(DIPlus-DIMinus) / (DIPlus+DIMinus)*100\r\nADX = ta.sma(DX, len)\r\nadxSlopePositive = ADX - ADX[1] > 0\r\n\r\n\r\n// --- Signal Logic ---\r\n// Time filter check\r\ncurrentHour = hour(time)\r\ncurrentMinute = minute(time)\r\nstartTimeMinutes = startHour * 60 + startMinute\r\nendTimeMinutes = endHour * 60 + endMinute\r\ncurrentTimeMinutes = currentHour * 60 + currentMinute\r\n\r\ninTimeWindow = not useTimeFilter or (startTimeMinutes <= endTimeMinutes ? \r\n     (currentTimeMinutes >= startTimeMinutes and currentTimeMinutes <= endTimeMinutes) : \r\n     (currentTimeMinutes >= startTimeMinutes or currentTimeMinutes <= endTimeMinutes))\r\n\r\n// Detect histogram color change\r\nhistChangeToGreen = (BraidColor == color.green and (BraidColor[1] == color.red or BraidColor[1] == color.gray))\r\nhistChangeToRed   = (BraidColor == color.red and (BraidColor[1] == color.green or BraidColor[1] == color.gray))\r\n\r\n// Conditions for Buy and Sell signals\r\nbuySig = histChangeToGreen and dif > filter and barCol == color.lime and ADX > th and adxSlopePositive and showBuySignals and inTimeWindow\r\nsellSig = histChangeToRed and dif > filter and barCol == color.red and ADX > th and adxSlopePositive and showSellSignals and inTimeWindow\r\n\r\n\r\n// --- Strategy Logic ---\r\nvar int buySignalBar = na\r\nvar float buyStopPrice = na\r\nvar int sellSignalBar = na\r\nvar float sellStopPrice = na\r\n\r\n// Track order lines\r\nvar array<line> longEntryLines = array.new<line>(0)\r\nvar array<line> longStopLines = array.new<line>(0)\r\nvar array<line> longTpLines = array.new<line>(0)\r\nvar array<line> shortEntryLines = array.new<line>(0)\r\nvar array<line> shortStopLines = array.new<line>(0)\r\nvar array<line> shortTpLines = array.new<line>(0)\r\n\r\n// Buy signal detected\r\nif buySig and strategy.position_size == 0\r\n    buySignalBar := bar_index\r\n    buyStopPrice := close\r\n\r\n// Sell signal detected  \r\nif sellSig and strategy.position_size == 0\r\n    sellSignalBar := bar_index\r\n    sellStopPrice := close\r\n\r\n// Check if buy stop is hit within valid candles\r\nif not na(buySignalBar) and strategy.position_size == 0\r\n    if bar_index - buySignalBar <= candlesValid\r\n        if high >= buyStopPrice\r\n            // Find local low for stop loss\r\n            [localLow, foundBar] = findLocalLow(20)\r\n            stopLoss = localLow\r\n            risk = buyStopPrice - stopLoss\r\n            takeProfit = buyStopPrice + (risk * riskReward)\r\n            \r\n            strategy.entry(\"Long\", strategy.long, stop=buyStopPrice)\r\n            strategy.exit(\"Long Exit\", \"Long\", stop=stopLoss, limit=takeProfit)\r\n            \r\n            // Draw lines\r\n            if array.size(longEntryLines) >= maxVisibleOrders\r\n                line.delete(array.shift(longEntryLines))\r\n                line.delete(array.shift(longStopLines))\r\n                line.delete(array.shift(longTpLines))\r\n            \r\n            entryLine = line.new(bar_index, buyStopPrice, bar_index + 50, buyStopPrice, color=color.blue, width=2, style=line.style_solid)\r\n            stopLine = line.new(bar_index, stopLoss, bar_index + 50, stopLoss, color=color.red, width=2, style=line.style_solid)\r\n            tpLine = line.new(bar_index, takeProfit, bar_index + 50, takeProfit, color=color.green, width=2, style=line.style_solid)\r\n            \r\n            array.push(longEntryLines, entryLine)\r\n            array.push(longStopLines, stopLine)\r\n            array.push(longTpLines, tpLine)\r\n            \r\n            buySignalBar := na\r\n    else\r\n        buySignalBar := na\r\n\r\n// Check if sell stop is hit within valid candles\r\nif not na(sellSignalBar) and strategy.position_size == 0\r\n    if bar_index - sellSignalBar <= candlesValid\r\n        if low <= sellStopPrice\r\n            // Find local high for stop loss\r\n            [localHigh, foundBar] = findLocalHigh(20)\r\n            stopLoss = localHigh\r\n            risk = stopLoss - sellStopPrice\r\n            takeProfit = sellStopPrice - (risk * riskReward)\r\n            \r\n            strategy.entry(\"Short\", strategy.short, stop=sellStopPrice)\r\n            strategy.exit(\"Short Exit\", \"Short\", stop=stopLoss, limit=takeProfit)\r\n            \r\n            // Draw lines\r\n            if array.size(shortEntryLines) >= maxVisibleOrders\r\n                line.delete(array.shift(shortEntryLines))\r\n                line.delete(array.shift(shortStopLines))\r\n                line.delete(array.shift(shortTpLines))\r\n            \r\n            entryLine = line.new(bar_index, sellStopPrice, bar_index + 50, sellStopPrice, color=color.blue, width=2, style=line.style_solid)\r\n            stopLine = line.new(bar_index, stopLoss, bar_index + 50, stopLoss, color=color.red, width=2, style=line.style_solid)\r\n            tpLine = line.new(bar_index, takeProfit, bar_index + 50, takeProfit, color=color.green, width=2, style=line.style_solid)\r\n            \r\n            array.push(shortEntryLines, entryLine)\r\n            array.push(shortStopLines, stopLine)\r\n            array.push(shortTpLines, tpLine)\r\n            \r\n            sellSignalBar := na\r\n    else\r\n        sellSignalBar := na\r\n\r\n\r\n// --- Plot Signals on Main Chart ---\r\nplotshape(buySig, title=\"Buy Signal\", style=shape.triangleup, color=color.lime, size=size.tiny, location=location.belowbar, text=\"BUY\")\r\nplotshape(sellSig, title=\"Sell Signal\", style=shape.triangledown, color=color.red, size=size.tiny, location=location.abovebar, text=\"SELL\")\r\n\r\n\r\n// --- Plots & Colors ---\r\nbgcolor(color.new(BraidColor, 85))\r\nbarcolor(barCol)"
  },
  {
    "url": "VaNuTU8p-Braid-Filter-Strategy",
    "name": "Braid Filter Strategy",
    "description": "Another of TradeIQ's youtube strategies. It looks a little messy but it combines all the indicators into one so there are no extra panes. This strategy is like a sophisticated set of traffic lights and speed limit signs for trading. It only allows a trade when multiple indicators line up to confirm a strong move, giving it its \"Braid Filter\" nameâ€”it weaves together several conditions.\n\nThe strategy is set up to use 100% of your account equity (your trading funds) on a trade and does not \"pyramid\" (it won't add to an existing trade).\n\n1. The Main Trend Check (The Traffic Lights)\nThe strategy uses three main filters that must agree before it considers a trade.\n\nA. The \"Braid Filter\" (Direction & Strength)\nThis is the heart of the strategy, a custom combination of three different Moving Averages\nThese averages have fast, medium, and slow settings (3, 7, and 14 periods).\n\nGo Green (Buy Signal): The fastest average is higher than the medium average, AND the three averages are sufficiently separated (not tangled up, which indicates a strong move).\n\nGo Red (Sell Signal): The medium average is higher than the fastest average, AND the three averages are sufficiently separated.\n\nNeutral (Wait): If the averages are tangled or the separation isn't strong enough.\n\nKey Trigger: A primary condition for a signal is when the Chad Filter changes color (e.g., from Red/Grey to Green).\n\nB. The EMA Trend Bars (Secondary Confirmation)\nThis is a simpler, longer-term filter using a 34-period Exponential Moving Average (EMA). It checks if the current candle's average price is above or below this EMA.\n\nGreen Bars: The price is above the 34 EMA (Bullish Trend).\n\nRed Bars: The price is below the 34 EMA (Bearish Trend).\n\nTrades only happen if the signal direction matches the bar color. For a Buy, the bar must be Green. For a Sell, the bar must be Red.\n\nC. ADX/DI Filter (The Speed Limit Sign)\nThis uses the Average Directional Index (ADX) and Directional Movement Indicators (DI) to check if a trend is actually in motion and getting stronger.\n\nMust-Have Conditions:\n\nThe ADX value must be above 20 (meaning there is a trend, not just random movement).\n\nThe ADX line must be rising (meaning the trend is accelerating/getting stronger).\n\nThe strategy will only trade when the trend is strong and building momentum.\n\n2. The Trading Action (Entry and Exit)\nWhen all three filters (Chad Filter color change, EMA Trend Bar color, and ADX strength/slope) align, the strategy issues a signal, but it doesn't enter immediately.\n\nEntry Strategy (The \"Wait-for-Confirmation\" Approach):\n\nWhen a Buy Signal appears, the strategy sets a \"Buy Stop\" order at the signal candle's closing price.\n\nIt then waits for up to 3 candles (Candles Valid for Entry). The price must move up and hit that Buy Stop price within those 3 candles to confirm the move and enter the trade.\n\nA Sell Signal works the same way but uses a \"Sell Stop\" at the closing price, waiting for the price to drop and hit it.\n\nRisk Management (Stop Loss and Take Profit):\n\nStop Loss: To manage risk, the strategy finds a recent significant low (for a Buy) or high (for a Sell) over the last 20 candles and places the Stop Loss there. This is a logical place where the current move would be considered \"broken\" if the price reaches it.\n\nTake Profit: It uses a fixed Risk:Reward Ratio (set to 1.5 by default). This means the potential profit (Take Profit distance) is $1.50 for every $1.00 of risk (Stop Loss distance).\n\n3. Additional Controls\nTime Filter: You can choose to only allow trades during specific hours of the day.\n\nVisuals: It shows a small triangle on the chart where the signal happens and colors the background to reflect the Chad Filter's trend (Green/Red/Grey) and the candle bars to show the EMA trend (Lime/Red).\n\nðŸŽ¯ Summary of the Strategy's Goal\nThis strategy is designed to capture strong, confirmed momentum moves. It uses a fast, custom indicator (\"Chad Filter\") to detect the start of a new move, confirms that move with a slower trend filter (34 EMA), and then validates the move's strength with the ADX. By waiting a few candles for the price to hit the entry level, it aims to avoid false signals.",
    "image_url": "VaNuTU8p",
    "author": "ChadAnt",
    "likes": 15,
    "type": "strategy",
    "created": "2025-11-13",
    "updated": "2025-11-13",
    "source": "//@version=6\r\nstrategy(\"Braid Filter Strategy\", shorttitle=\"ChadAnt\", overlay=true, pyramiding=0, default_qty_type=strategy.percent_of_equity, default_qty_value=100)\r\n\r\n// --- Inputs ---\r\n// Chad Filter Inputs\r\ng_chad = \"Chad Filter\"\r\nmaType            = input.string(\"EMA\", \"MA Type\", options = [\"EMA\", \"DEMA\", \"TEMA\", \"WMA\", \"VWMA\", \"SMA\", \"SMMA\", \"HMA\", \"LSMA\", \"Kijun\", \"McGinley\", \"RMA\"], group=g_chad)\r\nPeriod1           = input.int(3,  \"Period 1\", group=g_chad)\r\nPeriod2           = input.int(7,  \"Period 2\", group=g_chad)\r\nPeriod3           = input.int(14, \"Period 3\", group=g_chad)\r\nPipsMinSepPercent = input.int(40, \"Pips Min Sep Percent\", group=g_chad)\r\n\r\n// EMA Trend Bars Inputs\r\ng_ema = \"EMA Trend Bars\"\r\nema1 = input.int(34, minval=1, maxval=300, title=\"EMA Length\", group=g_ema)\r\n\r\n// ADX and DI Inputs\r\ng_adx = \"ADX / DI\"\r\nlen = input.int(14, title=\"ADX Length\", group=g_adx)\r\nth = input.int(20, title=\"ADX Threshold\", group=g_adx)\r\n\r\n// Signal Control Inputs\r\ng_signals = \"Signal Controls\"\r\nshowBuySignals = input.bool(true, title=\"Show Buy Signals\", group=g_signals)\r\nshowSellSignals = input.bool(true, title=\"Show Sell Signals\", group=g_signals)\r\nuseTimeFilter = input.bool(false, title=\"Enable Time Filter\", group=g_signals)\r\nstartHour = input.int(0, title=\"Start Hour (0-23)\", minval=0, maxval=23, group=g_signals)\r\nstartMinute = input.int(0, title=\"Start Minute (0-59)\", minval=0, maxval=59, group=g_signals)\r\nendHour = input.int(23, title=\"End Hour (0-23)\", minval=0, maxval=23, group=g_signals)\r\nendMinute = input.int(59, title=\"End Minute (0-59)\", minval=0, maxval=59, group=g_signals)\r\n\r\n// Strategy Inputs\r\ng_strategy = \"Strategy Settings\"\r\ncandlesValid = input.int(3, title=\"Candles Valid for Entry\", minval=1, group=g_strategy)\r\nriskReward = input.float(1.5, title=\"Risk:Reward Ratio\", minval=0.1, step=0.1, group=g_strategy)\r\nmaxVisibleOrders = input.int(5, title=\"Max Visible Orders on Chart\", minval=1, maxval=20, group=g_strategy)\r\n\r\n\r\n// --- Functions ---\r\nma(string type, float src, int len) =>\r\n    float result = 0.0\r\n    if type==\"SMA\"\r\n        result := ta.sma(src, len)\r\n    else if type==\"EMA\"\r\n        result := ta.ema(src, len)\r\n    else if type==\"DEMA\"\r\n        e = ta.ema(src, len)\r\n        result := 2 * e - ta.ema(e, len)\r\n    else if type==\"TEMA\"\r\n        e = ta.ema(src, len)\r\n        result := 3 * (e - ta.ema(e, len)) + ta.ema(ta.ema(e, len), len)\r\n    else if type==\"WMA\"\r\n        result := ta.wma(src, len)\r\n    else if type==\"VWMA\"\r\n        result := ta.vwma(src, len)\r\n    else if type==\"SMMA\"\r\n        w = ta.wma(src, len)\r\n        result := na(w[1]) ? ta.sma(src, len) : (w[1] * (len - 1) + src) / len\r\n    else if type==\"RMA\"\r\n        result := ta.rma(src, len)\r\n    else if type==\"HMA\"\r\n        result := ta.wma(2 * ta.wma(src, len / 2) - ta.wma(src, len), int(math.round(math.sqrt(len))))\r\n    else if type==\"LSMA\"\r\n        result := ta.linreg(src, len, 0)\r\n    else if type==\"Kijun\"\r\n        kijun = math.avg(ta.lowest(len), ta.highest(len))\r\n        result := kijun\r\n    else if type==\"McGinley\"\r\n        mg = 0.0\r\n        mg := na(mg[1]) ? ta.ema(src, len) : mg[1] + (src - mg[1]) / (len * math.pow(src/mg[1], 4))\r\n        result := mg\r\n    result\r\n\r\n// Find local low (candle with higher lows on both sides)\r\nfindLocalLow(int lookback) =>\r\n    float localLow = high\r\n    int foundBar = -1\r\n    for i = 1 to lookback\r\n        if i > 0 and bar_index - i >= 0\r\n            if low[i] < low[i-1] and low[i] < low[i+1]\r\n                localLow := low[i]\r\n                foundBar := i\r\n                break\r\n    [localLow, foundBar]\r\n\r\n// Find local high (candle with lower highs on both sides)\r\nfindLocalHigh(int lookback) =>\r\n    float localHigh = low\r\n    int foundBar = -1\r\n    for i = 1 to lookback\r\n        if i > 0 and bar_index - i >= 0\r\n            if high[i] > high[i-1] and high[i] > high[i+1]\r\n                localHigh := high[i]\r\n                foundBar := i\r\n                break\r\n    [localHigh, foundBar]\r\n\r\n\r\n// --- Calculations ---\r\n\r\n// 1. Chad Filter\r\nma01 = ma(maType, close, Period1)\r\nma02 = ma(maType, open, Period2)\r\nma03 = ma(maType, close, Period3)\r\n\r\nmaxVal = math.max(math.max(ma01, ma02), ma03)\r\nminVal = math.min(math.min(ma01, ma02), ma03)\r\ndif = maxVal - minVal\r\n\r\nfilter = ta.atr(14) * PipsMinSepPercent / 100\r\nBraidColor = ma01 > ma02 and dif > filter ? color.green : ma02 > ma01 and dif > filter ? color.red : color.gray\r\n\r\n// 2. EMA Trend Bars\r\nusedEma = ta.ema(close, ema1)\r\nbarCol = hlc3 >= usedEma ? color.lime : color.red\r\n\r\n// 3. ADX and DI\r\nTrueRange = math.max(math.max(high-low, math.abs(high-nz(close[1]))), math.abs(low-nz(close[1])))\r\nDirectionalMovementPlus = high-nz(high[1]) > nz(low[1])-low ? math.max(high-nz(high[1]), 0): 0\r\nDirectionalMovementMinus = nz(low[1])-low > high-nz(high[1]) ? math.max(nz(low[1])-low, 0): 0\r\n\r\nvar float SmoothedTrueRange = 0.0\r\nSmoothedTrueRange := nz(SmoothedTrueRange[1]) - (nz(SmoothedTrueRange[1])/len) + TrueRange\r\n\r\nvar float SmoothedDirectionalMovementPlus = 0.0\r\nSmoothedDirectionalMovementPlus := nz(SmoothedDirectionalMovementPlus[1]) - (nz(SmoothedDirectionalMovementPlus[1])/len) + DirectionalMovementPlus\r\n\r\nvar float SmoothedDirectionalMovementMinus = 0.0\r\nSmoothedDirectionalMovementMinus := nz(SmoothedDirectionalMovementMinus[1]) - (nz(SmoothedDirectionalMovementMinus[1])/len) + DirectionalMovementMinus\r\n\r\nDIPlus = SmoothedDirectionalMovementPlus / SmoothedTrueRange * 100\r\nDIMinus = SmoothedDirectionalMovementMinus / SmoothedTrueRange * 100\r\nDX = math.abs(DIPlus-DIMinus) / (DIPlus+DIMinus)*100\r\nADX = ta.sma(DX, len)\r\nadxSlopePositive = ADX - ADX[1] > 0\r\n\r\n\r\n// --- Signal Logic ---\r\n// Time filter check\r\ncurrentHour = hour(time)\r\ncurrentMinute = minute(time)\r\nstartTimeMinutes = startHour * 60 + startMinute\r\nendTimeMinutes = endHour * 60 + endMinute\r\ncurrentTimeMinutes = currentHour * 60 + currentMinute\r\n\r\ninTimeWindow = not useTimeFilter or (startTimeMinutes <= endTimeMinutes ? \r\n     (currentTimeMinutes >= startTimeMinutes and currentTimeMinutes <= endTimeMinutes) : \r\n     (currentTimeMinutes >= startTimeMinutes or currentTimeMinutes <= endTimeMinutes))\r\n\r\n// Detect histogram color change\r\nhistChangeToGreen = (BraidColor == color.green and (BraidColor[1] == color.red or BraidColor[1] == color.gray))\r\nhistChangeToRed   = (BraidColor == color.red and (BraidColor[1] == color.green or BraidColor[1] == color.gray))\r\n\r\n// Conditions for Buy and Sell signals\r\nbuySig = histChangeToGreen and dif > filter and barCol == color.lime and ADX > th and adxSlopePositive and showBuySignals and inTimeWindow\r\nsellSig = histChangeToRed and dif > filter and barCol == color.red and ADX > th and adxSlopePositive and showSellSignals and inTimeWindow\r\n\r\n\r\n// --- Strategy Logic ---\r\nvar int buySignalBar = na\r\nvar float buyStopPrice = na\r\nvar int sellSignalBar = na\r\nvar float sellStopPrice = na\r\n\r\n// Track order lines\r\nvar array<line> longEntryLines = array.new<line>(0)\r\nvar array<line> longStopLines = array.new<line>(0)\r\nvar array<line> longTpLines = array.new<line>(0)\r\nvar array<line> shortEntryLines = array.new<line>(0)\r\nvar array<line> shortStopLines = array.new<line>(0)\r\nvar array<line> shortTpLines = array.new<line>(0)\r\n\r\n// Buy signal detected\r\nif buySig and strategy.position_size == 0\r\n    buySignalBar := bar_index\r\n    buyStopPrice := close\r\n\r\n// Sell signal detected  \r\nif sellSig and strategy.position_size == 0\r\n    sellSignalBar := bar_index\r\n    sellStopPrice := close\r\n\r\n// Check if buy stop is hit within valid candles\r\nif not na(buySignalBar) and strategy.position_size == 0\r\n    if bar_index - buySignalBar <= candlesValid\r\n        if high >= buyStopPrice\r\n            // Find local low for stop loss\r\n            [localLow, foundBar] = findLocalLow(20)\r\n            stopLoss = localLow\r\n            risk = buyStopPrice - stopLoss\r\n            takeProfit = buyStopPrice + (risk * riskReward)\r\n            \r\n            strategy.entry(\"Long\", strategy.long, stop=buyStopPrice)\r\n            strategy.exit(\"Long Exit\", \"Long\", stop=stopLoss, limit=takeProfit)\r\n            \r\n            // Draw lines\r\n            if array.size(longEntryLines) >= maxVisibleOrders\r\n                line.delete(array.shift(longEntryLines))\r\n                line.delete(array.shift(longStopLines))\r\n                line.delete(array.shift(longTpLines))\r\n            \r\n            entryLine = line.new(bar_index, buyStopPrice, bar_index + 50, buyStopPrice, color=color.blue, width=2, style=line.style_solid)\r\n            stopLine = line.new(bar_index, stopLoss, bar_index + 50, stopLoss, color=color.red, width=2, style=line.style_solid)\r\n            tpLine = line.new(bar_index, takeProfit, bar_index + 50, takeProfit, color=color.green, width=2, style=line.style_solid)\r\n            \r\n            array.push(longEntryLines, entryLine)\r\n            array.push(longStopLines, stopLine)\r\n            array.push(longTpLines, tpLine)\r\n            \r\n            buySignalBar := na\r\n    else\r\n        buySignalBar := na\r\n\r\n// Check if sell stop is hit within valid candles\r\nif not na(sellSignalBar) and strategy.position_size == 0\r\n    if bar_index - sellSignalBar <= candlesValid\r\n        if low <= sellStopPrice\r\n            // Find local high for stop loss\r\n            [localHigh, foundBar] = findLocalHigh(20)\r\n            stopLoss = localHigh\r\n            risk = stopLoss - sellStopPrice\r\n            takeProfit = sellStopPrice - (risk * riskReward)\r\n            \r\n            strategy.entry(\"Short\", strategy.short, stop=sellStopPrice)\r\n            strategy.exit(\"Short Exit\", \"Short\", stop=stopLoss, limit=takeProfit)\r\n            \r\n            // Draw lines\r\n            if array.size(shortEntryLines) >= maxVisibleOrders\r\n                line.delete(array.shift(shortEntryLines))\r\n                line.delete(array.shift(shortStopLines))\r\n                line.delete(array.shift(shortTpLines))\r\n            \r\n            entryLine = line.new(bar_index, sellStopPrice, bar_index + 50, sellStopPrice, color=color.blue, width=2, style=line.style_solid)\r\n            stopLine = line.new(bar_index, stopLoss, bar_index + 50, stopLoss, color=color.red, width=2, style=line.style_solid)\r\n            tpLine = line.new(bar_index, takeProfit, bar_index + 50, takeProfit, color=color.green, width=2, style=line.style_solid)\r\n            \r\n            array.push(shortEntryLines, entryLine)\r\n            array.push(shortStopLines, stopLine)\r\n            array.push(shortTpLines, tpLine)\r\n            \r\n            sellSignalBar := na\r\n    else\r\n        sellSignalBar := na\r\n\r\n\r\n// --- Plot Signals on Main Chart ---\r\nplotshape(buySig, title=\"Buy Signal\", style=shape.triangleup, color=color.lime, size=size.tiny, location=location.belowbar, text=\"BUY\")\r\nplotshape(sellSig, title=\"Sell Signal\", style=shape.triangledown, color=color.red, size=size.tiny, location=location.abovebar, text=\"SELL\")\r\n\r\n\r\n// --- Plots & Colors ---\r\nbgcolor(color.new(BraidColor, 85))\r\nbarcolor(barCol)"
  },
  {
    "url": "80lETemF-Stochastic-Bollinger-Bands-Multi-Timeframe-Strategy",
    "name": "Stochastic + Bollinger Bands Multi-Timeframe Strategy",
    "description": "This strategy fuses the Stochastic Oscillator from the 4-hour timeframe with Bollinger Bands from the 1-hour timeframe, operating on a 10-hour chart to capture a unique volatility rhythm and temporal alignment discovered through observational alpha.\n\nBy blending momentum confirmation from the higher timeframe with short-term volatility extremes, the strategy leverages what some traders refer to as â€œrotating volatilityâ€ â€” a phenomenon where multi-timeframe oscillations sync to reveal hidden trade opportunities.\n\n ðŸ§  Strategy Logic \nâœ… Long Entry Condition:\n\nStochastic on the 4H timeframe:\n\n%K crosses above %D\n\nBoth %K and %D are below 20 (oversold zone)\n\nBollinger Bands on the 1H timeframe:\n\nPrice crosses above the lower Bollinger Band, indicating a potential reversal\n\nâ†’ A long trade is opened when both momentum recovery and volatility reversion align.\n\nâœ… Long Exit Condition:\n\nStochastic on the 4H:\n\n%K crosses below %D\n\nBoth %K and %D are above 80 (overbought zone)\n\nBollinger Bands on the 1H:\n\nPrice reaches or exceeds the upper Bollinger Band, suggesting exhaustion\n\nâ†’ The long trade is closed when either signal suggests a potential reversal or overextension.\n\n ðŸ§¬ Temporal Structure & Alpha \n\nThis strategy is deployed on a 10-hour chart â€” a non-standard timeframe that may align more effectively with multi-timeframe mean reversion dynamics.\nThis subtle adjustment exploits what some traders identify as â€œtemporal driftâ€ â€” the desynchronization of volatility across timeframes that creates hidden rhythm in price action.\n\nâ†’ For example, Stochastic on 4H (lookback 17) and Bollinger Bands on 1H (lookback 20) may periodically sync around 10H intervals, offering unique alpha windows.\n\n ðŸ“Š Indicator Components \nðŸ”¹ Stochastic Oscillator (4H, Length 17)\n\nDetects momentum reversals using %K and %D crossovers\n\nHelps define overbought/oversold zones from a mid-term view\n\nðŸ”¹ Bollinger Bands (1H, Length 20, Â±2 StdDev)\n\nMeasures price volatility using standard deviation around a moving average\n\nEntry occurs near lower band (support), exits near upper band (resistance)\n\nðŸ”¹ Multi-Timeframe Logic\n\nUses request.security() to safely reference 4H and 1H indicators from a 10H chart\n\nAvoids repainting by using closed higher-timeframe candles only\n\nðŸ“ˆ Visualization\n\nA plot selector input allows toggling between:\n\nStochastic Plot (%K & %D, with overbought/oversold levels)\n\nBollinger Bands Plot (Upper, Basis, Lower from 1H data)\n\nThis helps users visually confirm entry/exit triggers in real time.\n\nðŸ›  Customization\n\nFully configurable Stochastic and BB settings\n\nTimeframes are independently adjustable\n\nStrategy settings like position sizing, slippage, and commission are editable\n\n âš ï¸ Disclaimer \n\n This strategy is intended for educational and informational purposes only.\nIt does not constitute financial advice or a recommendation to buy or sell any asset.\nMarket conditions vary, and past performance does not guarantee future results.\nAlways test any trading strategy in a simulated environment and consult a licensed financial advisor before making real-world investment decisions.",
    "image_url": "80lETemF",
    "author": "RWCS_LTD",
    "likes": 27,
    "type": "strategy",
    "created": "2025-11-11",
    "updated": "2025-11-11",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// Â© RWCS_LTD\n\n//@version=6\nstrategy(\"Stochastic + Bollinger Bands Multi-Timeframe Strategy\", \n     overlay = false, \n     pyramiding = 0, \n     initial_capital = 1000, \n     default_qty_type = strategy.percent_of_equity, \n     default_qty_value = 100, \n     slippage = 3, \n     commission_value = 0.045\n     )\n\n// === INPUTS ===\ngroup1 = \"Plotting Options\"\ngroup2 = \"Stochastic Settings\"\ngroup3 = \"Bollinger Bands Settings\"\n\nplotChoice = input.string(\"Stochastic\", title=\"Plot Selector\", options=[\"Stochastic\", \"Bollinger Bands\"], group = group1)\n\nSTOCH_TIME = input.timeframe(\"240\", \"Stochastic Timeframe\", group = group2)\nstochKLen = input.int(17, title=\"%K Length\", group = group2)\nstochSmoothK = input.int(1, title=\"%K Smoothing\", group = group2)\nstochDLen = input.int(3, title=\"%D Smoothing\", group = group2)\n\nBB_TIME = input.timeframe(\"60\", \"Bollinger Bands Timeframe\", group = group3)\nbbLen = input.int(20, title=\"BB Length\", group = group3)\nbbMult = input.float(2.0, title=\"BB Multiplier\", group = group3)\n\n\n// === STOCHASTIC on 1D ===\n[k, d] = request.security(syminfo.tickerid, STOCH_TIME, \n     [ta.sma(ta.stoch(close, high, low, stochKLen), stochSmoothK),\n     ta.sma(ta.sma(ta.stoch(close, high, low, stochKLen), stochSmoothK), stochDLen)]\n     )\n\nstochLong = ta.crossover(k, d) and k < 20 and d < 20\nstochExit = ta.crossunder(k, d) and k > 80 and d > 80\n\n// === BOLLINGER BANDS on 4H ===\n[bbBasis, bbUpper, bbLower] = request.security(syminfo.tickerid, BB_TIME,\n     ta.bb(close, bbLen, bbMult)\n     )\n\nbbLong = ta.crossover(close, bbLower)\nbbExit = close >= bbUpper\n\n// === ENTRY & EXIT CONDITIONS ===\nlongCondition = stochLong and bbLong\nif longCondition\n    strategy.entry(\"Long\", strategy.long)\n\nexitCondition = stochExit or bbExit\nif exitCondition\n    strategy.close(\"Long\")\n\n// === PLOTTING ===\nshowStoch = plotChoice == \"Stochastic\"\nshowBB = plotChoice == \"Bollinger Bands\"\n\n// Stochastic %K and %D\nplot(showStoch ? k : na, title=\"%K (1D)\", color=color.blue)\nplot(showStoch ? d : na, title=\"%D (1D)\", color=color.orange)\nhline(showStoch ? 80 : na, \"Stoch OB\", color=color.red)\nhline(showStoch ? 20 : na, \"Stoch OS\", color=color.green)\n\n// Bollinger Bands\nplot(showBB ? bbUpper : na, title=\"BB Upper (4H)\", color=color.red)\nplot(showBB ? bbBasis : na, title=\"BB Basis (4H)\", color=color.gray)\nplot(showBB ? bbLower : na, title=\"BB Lower (4H)\", color=color.green)\n"
  },
  {
    "url": "jNJBgHD3-BTC-1h-Strat",
    "name": "BTC 1h Strat",
    "description": "Uses LuxAlgo-style Support/Resistance levels (pivot-based, with volume break labels).\nAdds momentum confirmation (RSI + MACD) to filter fakeouts.Keeps your swing breakout logic (close above swing high / below swing low).\nIncludes liquidity and TP/SL risk management.",
    "image_url": "jNJBgHD3",
    "author": "dominikpopp123",
    "likes": 21,
    "type": "strategy",
    "created": "2025-11-11",
    "updated": "2025-11-11",
    "source": "//@version=5\nstrategy(\"Swing Breakout + LuxAlgo S/R + RSI & MACD Confirmation\",\n     overlay=true,\n     initial_capital=10000,\n     pyramiding=0,\n     process_orders_on_close=true)\n\n// ======================================================================\n// 1ï¸âƒ£ LuxAlgo-style Support & Resistance Levels (modernized v5)\n// ======================================================================\n\ntoggleBreaks  = input.bool(true, \"Show Break Labels\")\nsrLeftBars    = input.int(15, \"S/R Left Bars\", minval=1)\nsrRightBars   = input.int(15, \"S/R Right Bars\", minval=1)\nvolumeThresh  = input.int(20, \"Volume Threshold (%)\", minval=1)\n\n// Pivot-based dynamic S/R levels\nhighUsePivot = ta.pivothigh(high, srLeftBars, srRightBars)\nlowUsePivot  = ta.pivotlow(low, srLeftBars, srRightBars)\n\nresistance = ta.valuewhen(not na(highUsePivot), highUsePivot, 0)\nsupport    = ta.valuewhen(not na(lowUsePivot),  lowUsePivot, 0)\n\nplot(resistance, \"Resistance\", color=color.new(color.red, 0), linewidth=2)\nplot(support,    \"Support\",    color=color.new(color.blue, 0), linewidth=2)\n\n// Volume oscillator for breakout validation\nshortEMA = ta.ema(volume, 5)\nlongEMA  = ta.ema(volume, 10)\nosc = 100 * (shortEMA - longEMA) / longEMA\n\nbullBreak = toggleBreaks and ta.crossover(close, resistance) and osc > volumeThresh\nbearBreak = toggleBreaks and ta.crossunder(close, support)   and osc > volumeThresh\n\nplotshape(bullBreak, title=\"Bull Break\", text=\"B\", style=shape.labelup, location=location.belowbar,\n           color=color.new(color.green, 0), textcolor=color.white, size=size.tiny)\nplotshape(bearBreak, title=\"Bear Break\", text=\"B\", style=shape.labeldown, location=location.abovebar,\n           color=color.new(color.red, 0), textcolor=color.white, size=size.tiny)\n\n// ======================================================================\n// 2ï¸âƒ£ Swing Breakout + Liquidity + Momentum Confirmation\n// ======================================================================\n\n// ==== Inputs ====\ngrpSwing = \"Swing Definition\"\nleftBars  = input.int(2, \"Left Bars\",  minval=1, group=grpSwing)\nrightBars = input.int(2, \"Right Bars\", minval=1, group=grpSwing)\n\ngrpBreak = \"Breakout Filter\"\nbufferPct = input.float(0.0, \"Breakout buffer (%)\", minval=0.0, step=0.1, group=grpBreak)\n\ngrpLiquidity = \"Liquidity Filter\"\nvolLen   = input.int(20, \"Avg volume length\", minval=1, group=grpLiquidity)\nvolMult  = input.float(1.2, \"Min vol multiple vs avg\", minval=0.5, step=0.1, group=grpLiquidity)\n\ngrpMomentum = \"Momentum Confirmation\"\nrsiLen = input.int(14, \"RSI Length\", group=grpMomentum)\nmacdFast = input.int(12, \"MACD Fast EMA\", group=grpMomentum)\nmacdSlow = input.int(26, \"MACD Slow EMA\", group=grpMomentum)\nmacdSignal = input.int(9, \"MACD Signal EMA\", group=grpMomentum)\n\ngrpRisk = \"Risk Management\"\nuseStops  = input.bool(true, \"Use TP/SL exits\", group=grpRisk)\ntpPct     = input.float(3.0,  \"Take profit (%)\", minval=0.1, step=0.1, group=grpRisk)\nslPct     = input.float(2.0,  \"Stop loss (%)\",   minval=0.1, step=0.1, group=grpRisk)\n\n// ==== Confirmed Swing Levels ====\nph = ta.pivothigh(high, leftBars, rightBars)\npl = ta.pivotlow(low,  leftBars, rightBars)\n\nvar float lastSwingHigh = na\nvar float lastSwingLow  = na\n\nif not na(ph)\n    lastSwingHigh := ph\nif not na(pl)\n    lastSwingLow := pl\n\n// ==== Liquidity Filter ====\navgVol = ta.sma(volume, volLen)\nliquidityOk = volume > avgVol * volMult\n\n// ==== Breakout Triggers ====\nlongTrigger  = na(lastSwingHigh) ? na : lastSwingHigh * (1 + bufferPct / 100.0)\nshortTrigger = na(lastSwingLow)  ? na : lastSwingLow  * (1 - bufferPct / 100.0)\n\n// ==== S/R Confluence ====\nsrNearLevel = (not na(resistance) and math.abs(close - resistance) / close < 0.005) or\n               (not na(support)    and math.abs(close - support)    / close < 0.005)\n\n// ==== Momentum Confirmation (RSI + MACD) ====\nrsi = ta.rsi(close, rsiLen)\nrsiBull = rsi > 55\nrsiBear = rsi < 45\n\nmacdLine = ta.ema(close, macdFast) - ta.ema(close, macdSlow)\nmacdSignalLine = ta.ema(macdLine, macdSignal)\nmacdHist = macdLine - macdSignalLine\nmacdBull = macdHist > 0\nmacdBear = macdHist < 0\n\nmomentumBull = rsiBull and macdBull\nmomentumBear = rsiBear and macdBear\n\n// ==== Entry Conditions ====\nlongCond  = barstate.isconfirmed and liquidityOk and srNearLevel and momentumBull and close > longTrigger\nshortCond = barstate.isconfirmed and liquidityOk and srNearLevel and momentumBear and close < shortTrigger\n\n// ==== Orders ====\nif longCond and strategy.position_size <= 0\n    strategy.entry(\"Long\", strategy.long)\nif shortCond and strategy.position_size >= 0\n    strategy.entry(\"Short\", strategy.short)\n\nif useStops\n    if strategy.position_size > 0\n        le = strategy.position_avg_price\n        strategy.exit(\"L-Exit\", \"Long\", limit=le * (1 + tpPct / 100), stop=le * (1 - slPct / 100))\n    if strategy.position_size < 0\n        se = strategy.position_avg_price\n        strategy.exit(\"S-Exit\", \"Short\", limit=se * (1 - tpPct / 100), stop=se * (1 + slPct / 100))\n\n// ==== Visuals ====\nplot(lastSwingHigh, \"Last Swing High\", color=color.new(color.green, 0))\nplot(lastSwingLow,  \"Last Swing Low\",  color=color.new(color.red, 0))\n\nplotshape(longCond,  title=\"Long Entry\",  style=shape.triangleup,   color=color.new(color.green, 0), size=size.tiny, text=\"LONG\")\nplotshape(shortCond, title=\"Short Entry\", style=shape.triangledown, color=color.new(color.red, 0),   size=size.tiny, text=\"SHORT\")\n\n// ==== Alerts ====\nalertcondition(longCond,  title=\"Long Breakout\",  message=\"Long breakout confirmed by RSI & MACD near LuxAlgo S/R\")\nalertcondition(shortCond, title=\"Short Breakout\", message=\"Short breakout confirmed by RSI & MACD near LuxAlgo S/R\")"
  },
  {
    "url": "KzTaJELp-Kronos-Scalper-RAVINDRA-KHADSE-11-11-2025",
    "name": "Kronos Scalper (RAVINDRA KHADSE) 11.11.2025",
    "description": "Nice â€” below is a ready-to-copy TradingView Pine Script (v5) strategy named â€œKronos Scalperâ€.\nItâ€™s a self-contained scalping strategy (non-repainting) with configurable EMAs trend filter, RSI entry filter, ATR-based stop loss / take profit, optional trailing stop, plots and entry/exit labels. Drop it into TradingViewâ€™s Pine editor and Add to Chart â†’ Strategy Tester.",
    "image_url": "KzTaJELp",
    "author": "Ravindrakhadse",
    "likes": 48,
    "type": "strategy",
    "created": "2025-11-11",
    "updated": "2025-11-11",
    "source": "//@version=5\nstrategy(\"Kronos Scalper (Clean Final)\", overlay=true, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=1, pyramiding=1, commission_type=strategy.commission.percent, commission_value=0.075)\n\n// === INPUTS ===\nfastLen    = input.int(8,  \"Fast EMA length\", minval=1)\nslowLen    = input.int(21, \"Slow EMA length\", minval=1)\nrsiLen     = input.int(9,  \"RSI length\", minval=1)\nrsiEntry   = input.int(50, \"RSI entry crossover level\", minval=1, maxval=99)\nrsiOverb   = input.int(70, \"RSI overbought (avoid long)\", minval=50, maxval=99)\nrsiOvers   = input.int(30, \"RSI oversold (avoid short)\", minval=1, maxval=50)\n\natrLen     = input.int(14, \"ATR length\", minval=1)\nstopATR    = input.float(1.0, \"Stop Loss (ATR multiplier)\", step=0.1)\ntpATR      = input.float(1.5, \"Take Profit (ATR multiplier)\", step=0.1)\nuseTrail   = input.bool(true, \"Use trailing stop after profit?\")\ntrailStart = input.float(1.0, \"Start trailing after X ATR profit\", step=0.1)\ntrailATR   = input.float(0.8, \"Trail distance (ATR multiplier)\", step=0.1)\n\nminBars    = input.int(50, \"Minimum bars before trading\", minval=1)\nshowEMAs   = input.bool(true, \"Show EMAs\")\nshowLabels = input.bool(true, \"Show entry/exit labels\")\n\n// === CALCULATIONS ===\nfastEMA = ta.ema(close, fastLen)\nslowEMA = ta.ema(close, slowLen)\nrsiVal  = ta.rsi(close, rsiLen)\natrVal  = ta.atr(atrLen)\n\n// Trend filter\nisBull = fastEMA > slowEMA\nisBear = fastEMA < slowEMA\n\n// Entry conditions\nlongCond  = isBull and ta.crossover(rsiVal, rsiEntry)\nshortCond = isBear and ta.crossunder(rsiVal, rsiEntry)\nlongAllow = rsiVal < rsiOverb\nshortAllow= rsiVal > rsiOvers\n\ncanTrade = bar_index > minBars\n\n// === ENTRIES & FIXED EXITS ===\nif (canTrade)\n    if (longCond and longAllow)\n        stopPx = close - atrVal * stopATR\n        tpPx   = close + atrVal * tpATR\n        strategy.entry(\"Kronos Long\", strategy.long)\n        strategy.exit(\"Exit Long\", from_entry=\"Kronos Long\", stop=stopPx, limit=tpPx)\n\n    if (shortCond and shortAllow)\n        stopPxS = close + atrVal * stopATR\n        tpPxS   = close - atrVal * tpATR\n        strategy.entry(\"Kronos Short\", strategy.short)\n        strategy.exit(\"Exit Short\", from_entry=\"Kronos Short\", stop=stopPxS, limit=tpPxS)\n\n// === TRAILING STOP (parameterized correctly) ===\ntrail_offset_val = atrVal * trailATR\n\nif (useTrail)\n    if (strategy.position_size > 0)\n        entryPrice = strategy.position_avg_price\n        profitATR  = (close - entryPrice) / atrVal\n        if (profitATR >= trailStart)\n            // Must provide both trail_price and trail_offset (or trail_points)\n            strategy.exit(\"Trail Long\", from_entry=\"Kronos Long\", trail_price=close, trail_offset=trail_offset_val)\n\n    if (strategy.position_size < 0)\n        entryPriceS = strategy.position_avg_price\n        profitATRS  = (entryPriceS - close) / atrVal\n        if (profitATRS >= trailStart)\n            strategy.exit(\"Trail Short\", from_entry=\"Kronos Short\", trail_price=close, trail_offset=trail_offset_val)\n\n// === VISUALS ===\nplot(showEMAs ? fastEMA : na, title=\"Fast EMA\", linewidth=2)\nplot(showEMAs ? slowEMA : na, title=\"Slow EMA\", linewidth=2)\n\nplotshape(showLabels and longCond and canTrade ? low : na, title=\"Buy\", style=shape.triangleup, location=location.belowbar, size=size.tiny, text=\"Buy\")\nplotshape(showLabels and shortCond and canTrade ? high : na, title=\"Sell\", style=shape.triangledown, location=location.abovebar, size=size.tiny, text=\"Sell\")\n\nbgcolor(isBull ? color.new(color.green, 92) : isBear ? color.new(color.red, 92) : na)\n\n// === ALERTS ===\nif (longCond and canTrade)\n    alert(\"Kronos Scalper â€” LONG Signal\", alert.freq_once_per_bar_close)\nif (shortCond and canTrade)\n    alert(\"Kronos Scalper â€” SHORT Signal\", alert.freq_once_per_bar_close)\n"
  },
  {
    "url": "hPj1mp40-Dhanesh-CustomTrendlineLogic",
    "name": "Dhanesh_CustomTrendlineLogic",
    "description": "Used framma in getting the trades. \nYou can also define the custom horizontal and an inclined trendline breaking of which can trigger the trade. Enjoy the script.\n",
    "image_url": "hPj1mp40",
    "author": "rdhaneshm",
    "likes": 8,
    "type": "strategy",
    "created": "2025-11-11",
    "updated": "2025-11-11",
    "source": "//@version=5\r\nstrategy(title='CustomTrendlineLogic', shorttitle='CustomTrendlineLogic', format=format.price, precision=4, overlay=true,max_bars_back=2000)\r\n \r\nstring timezoneInput = input.string(\"Asia/Kolkata\", \"Time zone\")\r\n// y1 = input.int(title='Enter Top year 1', defval=2025, confirm=false)\r\n// y2 = input.int(title='Enter Top year 2', defval=2025, confirm=false)\r\n// y3 = input.int(title='Enter Bottom year 1', defval=2025, confirm=false)\r\n// y4 = input.int(title='Enter Bottom year 2', defval=2025, confirm=false)\r\n\r\n// m1 = input.int(title='Enter Top month 1', defval=2, confirm=false)\r\n// m2 = input.int(title='Enter Top month 2', defval=2, confirm=false)\r\n// m3 = input.int(title='Enter Bottom month 1', defval=2, confirm=false)\r\n// m4 = input.int(title='Enter Bottom month 2', defval=3, confirm=false)\r\n\r\n// d1 = input.int(title='Enter Top day 1', defval=26, confirm=false)\r\n// d2 = input.int(title='Enter Top day 2', defval=27, confirm=false)\r\n// d3 = input.int(title='Enter Bottom day 1', defval=28, confirm=false)\r\n// d4 = input.int(title='Enter Bottom day 2', defval=1, confirm=false)\r\n\r\n// h1 = input.int(title='Enter Top hour 1', defval=16, confirm=false)\r\n// min1 = input.int(title='Enter Top minute 1', defval=30, confirm=false)\r\n// price1 = input.float(title='Enter Top Price 1', defval=0.0, confirm=false)\r\n\r\n// h2 = input.int(title='Enter Top hour 2', defval=17, confirm=false)\r\n// min2 = input.int(title='Enter Top minute 2', defval=00, confirm=false)\r\n// price2 = input.float(title='Enter Top Price 2', defval=0.0, confirm=false)\r\n\r\n// h3 = input.int(title='Enter Bottom hour 1', defval=2, confirm=false)\r\n// min3 = input.int(title='Enter Bottom minute 1', defval=0, confirm=false)\r\n// price3 = input.float(title='Enter Bottom Price 1', defval=0.0, confirm=false)\r\n\r\n// h4 = input.int(title='Enter Bottom hour 2', defval=6, confirm=false)\r\n// min4 = input.int(title='Enter Bottom minute 2', defval=30, confirm=false)\r\n// price4 = input.float(title='Enter Bottom Price 2', defval=0.0, confirm=false)\r\n\r\ny1 = input.int(title='************* Enter Top year 1', defval=2025, confirm=false)\r\nm1 = input.int(title='Enter Top month 1', defval=9, confirm=false)\r\nd1 = input.int(title='Enter Top day 1', defval=26, confirm=false)\r\nh1 = input.int(title='Enter Top hour 1', defval=16, confirm=false)\r\nmin1 = input.int(title='Enter Top minute 1', defval=30, confirm=false)\r\nprice1 = input.float(title='Enter Top Price 1', defval=100000.0, confirm=false)\r\n\r\n\r\ny2 = input.int(title='************* Enter Top year 2', defval=2025, confirm=false)\r\nm2 = input.int(title='Enter Top month 2', defval=9, confirm=false)\r\nd2 = input.int(title='Enter Top day 2', defval=27, confirm=false)\r\nh2 = input.int(title='Enter Top hour 2', defval=17, confirm=false)\r\nmin2 = input.int(title='Enter Top minute 2', defval=00, confirm=false)\r\nprice2 = input.float(title='Enter Top Price 2', defval=100000.0, confirm=false)\r\n\r\n\r\ny3 = input.int(title='************* Enter Bottom year 1', defval=2025, confirm=false)\r\nm3 = input.int(title='Enter Bottom month 1', defval=9, confirm=false)\r\nd3 = input.int(title='Enter Bottom day 1', defval=28, confirm=false)\r\nh3 = input.int(title='Enter Bottom hour 1', defval=2, confirm=false)\r\nmin3 = input.int(title='Enter Bottom minute 1', defval=0, confirm=false)\r\nprice3 = input.float(title='Enter Bottom Price 1', defval=100000.0, confirm=false)\r\n\r\ny4 = input.int(title='************* Enter Bottom year 2', defval=2025, confirm=false)\r\nm4 = input.int(title='Enter Bottom month 2', defval=9, confirm=false)\r\nd4 = input.int(title='Enter Bottom day 2', defval=1, confirm=false)\r\nh4 = input.int(title='Enter Bottom hour 2', defval=6, confirm=false)\r\nmin4 = input.int(title='Enter Bottom minute 2', defval=30, confirm=false)\r\nprice4 = input.float(title='Enter Bottom Price 2', defval=100000.0, confirm=false)\r\n\r\nprice5 = input.float(title='Custom Price: Enter Bottom Price 5', defval=0.0, confirm=false)\r\nprice6 = input.float(title='Custom Price: Enter Bottom Price 6', defval=0.0, confirm=false)\r\n\r\n\r\nint unixTimestampIn1 = timestamp(timezone=timezoneInput, year = y1, month = m1, day = d1, hour = h1, minute = min1, second = 0) //top1\r\nint unixTimestampIn2 = timestamp(timezone=timezoneInput,  year = y2, month = m2, day = d2, hour = h2, minute = min2, second = 0) //top2\r\nint unixTimestampIn3 = timestamp(timezone=timezoneInput,  year = y3, month = m3, day = d3, hour = h3, minute = min3, second = 0) //bottom1\r\nint unixTimestampIn4 = timestamp(timezone=timezoneInput,  year = y4, month = m4, day = d4, hour = h4, minute = min4, second = 0) //bottom2\r\n\r\n\r\n//SLOPE of line \r\nMAPeriod=input.int(title='************* Slope MA Period', defval=50, confirm=false)\r\nSlopePeriod=input.int(title='************* Slope Period', defval=50, confirm=false)\r\nsma50=ta.sma(close,MAPeriod)\r\nslope50=( sma50 - sma50[SlopePeriod]) / SlopePeriod\r\nplot(sma50, \"Sma 50\", color=color.yellow, linewidth=2)\r\nslope50Deried=sma50+3 * slope50\r\nplot(slope50Deried, \"Slope Sma 50\", color=color.rgb(42, 216, 19), linewidth=2)\r\n\r\n//BELOW CODE IS NEEDD for not to delete below section\r\nalertSymbol = input.string(confirm=false, defval = \"BTCUSD\", title=\"Enter Symbol Name\")\r\nmhh = input.int(title='Mkt Start Hours', defval=9, confirm=false)\r\nmhm = input.int(title='Mkt Start Min', defval=15, confirm=false)\r\nmhhA = input.int(title='Mkt Start Hours Actual', defval=9, confirm=false)\r\nmhmA = input.int(title='Mkt Start Min Actual', defval=18, confirm=false)\r\n\r\nmhhc = input.int(title='Mkt Close Hours', defval=14, confirm=false)\r\nmhmc = input.int(title='Mkt Close Min', defval=45, confirm=false)\r\nperiod=timeframe.period\r\nisSquaredOffInt=0\r\ndebugMsg=''\r\n// isAlreadyBuyBefore1=strategy.position_size > 0\r\n// isAlreadySellBefore1=strategy.position_size < 0\r\n\r\nisAlreadyBuyBefore1=false\r\nif na(isAlreadyBuyBefore1[1])\r\n    isAlreadyBuyBefore1:=false\r\nelse\r\n    isAlreadyBuyBefore1:=isAlreadyBuyBefore1[1]\r\n\r\nisAlreadySellBefore1=false\r\nif na(isAlreadySellBefore1[1])\r\n    isAlreadySellBefore1:=false\r\nelse\r\n    isAlreadySellBefore1:=isAlreadySellBefore1[1]\r\n\r\nisStartDay= (hour(time) == mhh and minute(time) == mhm) // or (hour(time) == mhh and minute(time) == mhm+( int(str.tonumber(period)))) \r\nisEndDay=(hour(time) == mhhc and minute(time) >= mhmc) or (hour(time) > mhhc)\r\nonlyIntradayTrades = input.bool(title='Take only Intraday Trades?', defval=false, confirm=false)\r\nif onlyIntradayTrades == false\r\n    isEndDay:=false\r\n    isStartDay:=false\r\n\r\n\r\nglob_pl=0.0\r\nif na(glob_pl[1])\r\n    glob_pl:=0.0\r\nelse\r\n    glob_pl:=glob_pl[1]\r\n\r\nmypl=0.0\r\nif na(mypl[1])\r\n    mypl:=0.0\r\nelse\r\n    mypl:=mypl[1]\r\n\r\ntotalPL=0.0\r\nif na(totalPL[1])\r\n    totalPL:=0.0\r\nelse\r\n    totalPL:=totalPL[1]\r\nclosepl= request.security((syminfo.tickerid), timeframe.period, close)\r\ntradeInB=0.00\r\nif na(tradeInB[1])\r\n    tradeInB:=0.0\r\nelse\r\n    tradeInB:=tradeInB[1]\r\ntradeInS=0.0\r\nif na(tradeInS[1])\r\n    tradeInS:=0.0\r\nelse\r\n    tradeInS:=tradeInS[1]\r\nppl=0.0\r\nbrokerage_pl=20.0\r\ntarget = input.int(title='Target', defval=300000, confirm=false)\r\nisToConsider=false\r\n\r\n\r\nisB=false\r\nif na(isB[1])\r\n    isB:=false\r\nelse\r\n    isB:=isB[1]\r\n\r\nisS=false\r\nif na(isS[1])\r\n    isS:=false\r\nelse\r\n    isS:=isS[1]\r\n\r\nsl=0.0\r\nif na(sl[1])\r\n    sl:=0.0\r\nelse\r\n    sl:=sl[1]\r\n\r\nsl1=0.0\r\nif na(sl1[1])\r\n    sl1:=0.0\r\nelse\r\n    sl1:=sl1[1]\r\n\r\ntradeNumIntraday=0\r\nif na(tradeNumIntraday[1])\r\n    tradeNumIntraday:=0\r\nelse\r\n    tradeNumIntraday:=tradeNumIntraday[1]\r\n\r\ncanHi=0.0\r\nif na(canHi[1])\r\n    canHi:=0.0\r\nelse\r\n    canHi:=canHi[1]\r\n\r\ncanLow=0.0\r\nif na(canLow[1])\r\n    canLow:=0.0\r\nelse\r\n    canLow:=canLow[1]\r\n\r\nprevSquareoffInt=0\r\nif na(prevSquareoffInt[1])\r\n    prevSquareoffInt:=0\r\nelse\r\n    prevSquareoffInt:=prevSquareoffInt[1]\r\n\r\nhh=0.0\r\nif na(hh[1])\r\n    hh:=0.0\r\nelse\r\n    hh:=hh[1]\r\nll=0.0\r\nif na(ll[1])\r\n    ll:=0.0\r\nelse\r\n    ll:=ll[1]  \r\ntempHH=0.0\r\nif na(tempHH[1])\r\n    tempHH:=0.0\r\nelse\r\n    tempHH:=tempHH[1]\r\ntempLL=0.0\r\nif na(tempLL[1])\r\n    tempLL:=0.0\r\nelse\r\n    tempLL:=tempLL[1]\r\n\r\ntempHH1=0.0\r\nif na(tempHH1[1])\r\n    tempHH1:=0.0\r\nelse\r\n    tempHH1:=tempHH1[1]\r\ntempLL1=0.0\r\nif na(tempLL1[1])\r\n    tempLL1:=0.0\r\nelse\r\n    tempLL1:=tempLL1[1]\r\n\r\nisUpStarted=false\r\nif na(isUpStarted[1])\r\n    isUpStarted:=false\r\nelse\r\n    isUpStarted:=isUpStarted[1]\r\n\r\nisDownStarted=false\r\nif na(isDownStarted[1])\r\n    isDownStarted:=false\r\nelse\r\n    isDownStarted:=isDownStarted[1]\r\n\r\nisDayStarted=false\r\nif na(isDayStarted[1])\r\n    isDayStarted:=false\r\nelse\r\n    isDayStarted:=isDayStarted[1]\r\n\r\nisToStart=false\r\nif na(isToStart[1])\r\n    isToStart:=false\r\nelse\r\n    isToStart:=isToStart[1]\r\n\r\nis1=false\r\nif na(is1[1])\r\n    is1:=false\r\nelse\r\n    is1:=is1[1]\r\nis2=false\r\nif na(is2[1])\r\n    is2:=false\r\nelse\r\n    is2:=is2[1]\r\n\r\nis3=false\r\nif na(is3[1])\r\n    is3:=false \r\nelse\r\n    is3:=is3[1]\r\nis4=false\r\nif na(is4[1])\r\n    is4:=false\r\nelse\r\n    is4:=is4[1]\r\nis5=false\r\nif na(is5[1])\r\n    is5:=false\r\nelse\r\n    is5:=is5[1]\r\n\r\ncnt1=0\r\nif na(cnt1[1])\r\n    cnt1:=0\r\nelse\r\n    cnt1:=cnt1[1]\r\ncnt2=0\r\nif na(cnt2[1])\r\n    cnt2:=0\r\nelse\r\n    cnt2:=cnt2[1]\r\ncnt3=0\r\nif na(cnt3[1])\r\n    cnt3:=0\r\nelse\r\n    cnt3:=cnt3[1]\r\n\r\ncurrLookingForBuy=''\r\nif na(currLookingForBuy[1])\r\n    currLookingForBuy:=''\r\nelse\r\n    currLookingForBuy:=currLookingForBuy[1]\r\nnextSLOfPrevSell=''\r\nif na(nextSLOfPrevSell[1])\r\n    nextSLOfPrevSell:=''\r\nelse\r\n    nextSLOfPrevSell:=nextSLOfPrevSell[1]\r\ncurrLookingForSell=''\r\nif na(currLookingForSell[1])\r\n    currLookingForSell:=''\r\nelse\r\n    currLookingForSell:=currLookingForSell[1]\r\nnextSLOfPrevBuy=''\r\nif na(nextSLOfPrevBuy[1])\r\n    nextSLOfPrevBuy:=''\r\nelse\r\n    nextSLOfPrevBuy:=nextSLOfPrevBuy[1]\r\n\r\ntmp1=0\r\nif na(tmp1[1])\r\n    tmp1:=0\r\nelse\r\n    tmp1:=tmp1[1]\r\ntmp2=0\r\nif na(tmp2[1])\r\n    tmp2:=0\r\nelse\r\n    tmp2:=tmp2[1]\r\ntmp3=0\r\nif na(tmp3[1])\r\n    tmp3:=0\r\nelse\r\n    tmp3:=tmp3[1]\r\n\r\ngapup=0.0\r\nif na(gapup[1])\r\n    gapup:=0.0\r\nelse\r\n    gapup:=gapup[1]\r\nprevDayClose=0.0\r\nif na(prevDayClose[1])\r\n    prevDayClose:=0.0\r\nelse\r\n    prevDayClose:=prevDayClose[1]\r\nfinalPL=0.0\r\nif na(finalPL[1])\r\n    finalPL:=0.0\r\nelse\r\n    finalPL:=finalPL[1]\r\n\r\nnewDay = ta.change(dayofweek)\r\nndDone=false\r\nif na(ndDone[1])\r\n    ndDone:=false\r\nelse\r\n    ndDone:=ndDone[1]\r\n// Get the high and low of the first candle of the day\r\nif newDay\r\n    isStartDay:= true\r\n    is2:=false\r\n    ndDone:=true\r\n    if onlyIntradayTrades\r\n        sl1:=0\r\n        isAlreadySellBefore1:=false\r\n        isAlreadyBuyBefore1:=false\r\n        //label.new(bar_index, na, \"START dhgf fgh fg hfgh\", yloc = yloc.abovebar, style = label.style_none, textcolor = color.rgb(172, 240, 13), size = size.large)\r\n        glob_pl:=0.0\r\n    //strategy.exit(id=\"End: Daily Profit: \"+str.tostring( int (glob_pl) )+\" Total Profit: \"+str.tostring( int (totalPL) ) , stop=close)\r\n    \r\nisFirstCandleDone = (hour(time) == mhh and minute(time) == (mhm + timeframe.multiplier))\r\nisActStart=(hour(time) == mhhA and minute(time) == mhmA)\r\nopenpl= request.security((syminfo.tickerid), timeframe.period, open)\r\n\r\nif isStartDay\r\n    prevDayClose:=closepl[1]\r\n    gapup:=high - prevDayClose\r\n    tmp1:=0\r\n    tmp2:=0\r\n\r\nif onlyIntradayTrades == true\r\n    if isActStart\r\n        canHi:=high[1]\r\n        canLow:=low[1]\r\n    if isStartDay\r\n        currLookingForBuy:=''\r\n        nextSLOfPrevSell:=''\r\n        currLookingForSell:=''\r\n        nextSLOfPrevBuy:=''\r\n        glob_pl:=0\r\n        tradeInB:=0\r\n        tradeInS:=0\r\n        tradeNumIntraday:=0\r\n        isDayStarted:=true\r\n        isToStart:=false\r\n        //isHighLowBroken:=false\r\n        //is1:=false\r\n        // is2:=false\r\n        // is3:=false\r\n        is4:=false\r\n        is5:=false\r\n        cnt1:=0\r\n        cnt2:=0\r\n        // cnt3:=0\r\n        isUpStarted:=false\r\n        isDownStarted:=false\r\n    if isEndDay\r\n        isDayStarted:=false\r\n        canHi:=0.0\r\n        canLow:=0.0\r\n        //isHighLowBroken:=false\r\n    if  ( ( isStartDay ) or isEndDay )\r\n        isToConsider := false\r\n        //isHighLowBroken:=false\r\n        if (hour(time) == mhhA and minute(time) == mhmA)\r\n            isToConsider := true\r\n        hh:=0.0\r\n        ll:=0.0\r\n        //tempHH:=0.0\r\n        //tempLL:=0.0\r\n        sl:=0.0\r\n        isUpStarted:=false\r\n        isDownStarted:=false\r\n        isS:=false\r\n        isB:=false\r\n        //is1:=false\r\n        // is2:=false\r\n        // is3:=false \r\n        is4:=false\r\n        is5:=false\r\n        cnt1:=0\r\n        cnt2:=0\r\n        // cnt3:=0\r\n        // if(isAlreadyBuyBefore1 or isAlreadySellBefore1)\r\n        //     if isEndDay == false\r\n        //         strategy.exit(id=\"Start\", stop=close) \r\n    else if (hour(time) == mhhA and minute(time) == mhmA)\r\n        isToConsider := true\r\n    else \r\n        isToConsider := isToConsider[1]\r\nelse\r\n    isToConsider:=true\r\nfinalBuySellVal=0\r\nnoTrade=isAlreadyBuyBefore1==false and isAlreadySellBefore1==false\r\n\r\n\r\n// *******************************************************************************\r\n//     START  FRAMA \r\n// *********************************************************************************\r\n\r\n// ï¼©ï¼®ï¼°ï¼µï¼´ï¼³ --------------------------------------------------------------------------------------------------------{\r\n// User Inputs for FRAMA Channel\r\nint    N          = input.int   (26, title=\"Length\", minval=2, step = 2, group = \"Channel\") // Length for FRAMA calculation\r\nfloat  distance   = input.float (1.5, \"Bands Distance\", step = 0.01, minval = 0.3, group = \"Channel\") // Distance for channel bands\r\nstring price_vol  = input.string(\"Price\", \"Signals Data\", [\"Price\", \"Average Volume\"]) // Source data for signals\r\nstring labl_size  = input.string(\"Small\", \"Lables Size\", [\"Small\", \"Normal\", \"Large\"])\r\n\r\n// Colors\r\ngroup = \"Colors\"\r\ncolor color1     = input.color(#27e27b, \"Momentum Up\", group = group, inline = \"1\") // Color for upward momentum\r\ncolor color2     = input.color(color.rgb(39, 114, 226), \"Down\", group = group, inline = \"1\") // Color for downward momentum\r\ncolor color3     = input.color(#a2b5ca, \"Neutral\", group = group) // Color for neutral state\r\nvar color color  = color(na) // Variable to hold the current color\r\n\r\nbool  candles    = input.bool  (true, \"Color Candles\") // Toggle for coloring candles based on momentum\r\n\r\n// Source for FRAMA calculation\r\nseries float price = hl2 // Use hl2 as the default source\r\n\r\n// Variables for FRAMA calculation\r\nvar float Filt   = na\r\nvar float Filt1  = na\r\nvar float Filt2  = na\r\nvar int   count1 = na\r\nvar int   count2 = na\r\n// }\r\n\r\n// UDTs----------------------------------------------------------------------------------------------------------------{\r\n// Define a user-defined type (UDT) to store variables used in FRAMA calculation\r\ntype vars \r\n    float N1\r\n    float N2\r\n    float N3\r\n    float HH\r\n    float LL\r\n    float Dimen \r\n    float alpha\r\n\r\n// Initialize UDT instance\r\nv = vars.new(0., 0., 0., 0., 0., 0., 0.)\r\n// }\r\n\r\n\r\n// ï¼£ï¼¡ï¼¬ï¼£ï¼µï¼¬ï¼¡ï¼´ï¼©ï¼¯ï¼®ï¼³----------------------------------------------------------------------------------------------{\r\n// Perform calculations for the FRAMA Channel\r\nseries float volatility = ta.sma(high - low, 200) // Calculate volatility using the average true range\r\nseries float p_vol      = switch price_vol // Select the data source for signals (Price or Average Volume)\r\n    \"Price\"             => close\r\n    \"Average Volume\"    => math.round(math.sum(volume, 10) / 10, 2)\r\n\r\n// Calculate N3 for the fractal dimension\r\nv.N3 := (ta.highest(high, N) - ta.lowest(low, N)) / N\r\n\r\n// Loop to calculate N1\r\nv.HH := high\r\nv.LL := low\r\n\r\nfor count = 0 to N / 2 - 1\r\n    if high[count] > v.HH\r\n        v.HH := high[count]\r\n    if low[count] < v.LL\r\n        v.LL := low[count]\r\n\r\nv.N1 := (v.HH - v.LL) / (N / 2)\r\n\r\n// Loop to calculate N2\r\nv.HH := high[N / 2]\r\nv.LL := low[N / 2]\r\n\r\nfor count = N / 2 to N - 1\r\n    if high[count] > v.HH\r\n        v.HH := high[count]\r\n    if low[count] < v.LL\r\n        v.LL := low[count]\r\n\r\nv.N2 := (v.HH - v.LL) / (N / 2)\r\n\r\n// Calculate the fractal dimension\r\nif (v.N1 > 0 and v.N2 > 0 and v.N3 > 0)\r\n    v.Dimen := (math.log(v.N1 + v.N2) - math.log(v.N3)) / math.log(2)\r\n\r\n// Calculate alpha for FRAMA\r\nv.alpha := math.exp(-4.6 * (v.Dimen - 1))\r\nv.alpha := math.max(math.min(v.alpha, 1), 0.01) // Clamp alpha between 0.01 and 1\r\n\r\n// Calculate the FRAMA filtered value\r\nFilt  := na(Filt) \r\n          ? price \r\n          : v.alpha * price + (1 - v.alpha) * Filt[1]\r\n\r\nFilt  := ta.sma((bar_index < N + 1) ? price : Filt, 5) // Apply SMA for smoothing\r\n\r\n// Calculate the channel bands\r\nFilt1 := Filt + volatility * distance\r\nFilt2 := Filt - volatility * distance\r\n// }\r\n\r\n\r\n// ï¼°ï¼¬ï¼¯ï¼´-------------------------------------------------------------------------------------------------------------{\r\n// Define conditions for plotting and coloring\r\nbreak_up = ta.crossover(hlc3, Filt1) and barstate.isconfirmed\r\nbreak_dn = ta.crossunder(hlc3, Filt2) and barstate.isconfirmed\r\n\r\nif ta.cross(close, Filt)\r\n    color := color3 // Neutral color \r\n\r\n// Determine the color based on breakout conditions\r\nswitch \r\n    break_up => color := color1 // Upward breakout\r\n    break_dn => color := color2 // Downward breakout\r\n\r\n// Set candle color if enabled\r\ncolor color_c = candles ? color : na\r\n\r\n// Plot the FRAMA and bands\r\np0 = plot(Filt,  color = color.new(color,color == color3 ? 100 : 50),  editable = false)\r\np1 = plot(Filt1, color = color.new(color,20), linewidth = 1, editable = false)\r\np2 = plot(Filt2, color = color.new(color,20), linewidth = 1, editable = false)\r\n\r\n// Fill the area between the bands and FRAMA\r\nfill(p1, p0, Filt1, Filt, color.new(color, candles ? 95 : 85), na, editable = false)\r\nfill(p0, p2, Filt, Filt2, na, color.new(color, candles ? 95 : 85), editable = false)\r\n\r\nsize = switch labl_size\r\n    \"Small\"  => size.small\r\n    \"Normal\" => size.normal\r\n    \"Large\"  => size.large\r\n\r\n// Add labels on breakout events\r\nif break_up\r\n    count2 := 0\r\n    count1 += 1 \r\n    if count1 == 1\r\n        label.new(\r\n                  x         = bar_index,\r\n                  y         = Filt2, \r\n                  text      = \"ðŸ¢\\n\" + str.tostring(p_vol),\r\n                  style     = label.style_label_up,\r\n                  textcolor = color1, \r\n                  color     = color(na), \r\n                  size = size\r\n                  )\r\n\r\nif break_dn\r\n    count1 := 0 \r\n    count2 += 1\r\n    if count2 == 1\r\n        label.new(\r\n                  x         = bar_index,\r\n                  y         = Filt1, \r\n                  text      = str.tostring(p_vol) + \"\\nðŸ¢ƒ\",\r\n                  style     = label.style_label_down,\r\n                  textcolor = color2, \r\n                  color     = color(na), \r\n                  size      = size\r\n                  )\r\n\r\n// Plot candles with the calculated colors\r\nplotcandle(\r\n             open, high, low, close, \r\n             \"Candles\", \r\n             color_c,\r\n             color_c, \r\n             bordercolor = color_c, \r\n             editable    = false\r\n             )\r\n// }\r\n\r\n// *******************************************************************************\r\n//      END FRAMA\r\n// *********************************************************************************\r\n\r\n\r\n// *******************************************************************************\r\n//      MultiTimeframe EMAs START \r\n// *********************************************************************************\r\n\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n// Inputs\r\n\r\n// global input\r\ni_hideFromLowerTf = input.bool(true, 'Hide MA from lower timeframe')\r\ni_mtf_mode = input.bool(true, \"MTF Smoothed Mode\", tooltip = \"Smoothes the average between the bars of higher timeframes or shows the actual value (step lines).\")\r\n\r\n// label input\r\nconst string g_label = 'MA Labels'\r\ni_showType = input.bool(true, 'Display MA Type', group = g_label)\r\ni_showLen = input.bool(true, 'Display MA Length', group = g_label)\r\ni_showTf = input.bool(true, 'Display MA Timeframe', group = g_label)\r\ni_showN = input.bool(false, 'Display MA Number', group = g_label, tooltip = 'Helps you find and configure the moving average more easily')\r\ni_labelOffset = input.int(0, 'Label offset', minval=0, group = g_label)\r\ni_labelSize = input.string('normal', 'Label size', options = ['tiny', 'small', 'normal', 'large', 'huge'])\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n// Funcs\r\n\r\n\r\nf_mvwap(src, length, vol) =>\r\n\tuvol = vol\r\n\tuwgt = vol * src\r\n\r\n    if length < 1\r\n        na\r\n    else\r\n    \tfor i = 1 to length - 1\r\n    \t    uvol := uvol + vol[i]\r\n    \t\tuwgt := uwgt + vol[i] * src[i]\r\n    \tuwgt / uvol\r\n\r\n\r\nf_dema(_src, _length) =>\r\n    e1 = ta.ema(_src, _length)\r\n    e2 = ta.ema(e1, _length)\r\n    2 * e1 - e2\r\n\r\n\r\nf_tema(_src, _length) =>\r\n    e1 = ta.ema(_src, _length)\r\n    e2 = ta.ema(e1, _length)\r\n    e3 = ta.ema(e2, _length)\r\n    (3 * e1) - (3 * e2) + e3\r\n\r\n\r\nf_smma(_src, _length) =>\r\n    sma = ta.sma(_src, _length)\r\n    float smma = 0.0\r\n    smma := na(smma[1]) ? sma : (smma[1] * (_length - 1) + _src) / _length\r\n\r\n\r\nf_ma(_type, _src, _len) =>\r\n    switch _type\r\n        \"EMA: Exponential Moving Average\" => ta.ema(_src, _len)\r\n        \"DEMA: Double Exponential Moving Average\" => f_dema(_src, _len)\r\n        \"TEMA: Triple Exponential Moving Average\" => f_tema(_src, _len)\r\n        \"VWMA: Volume Weighted Moving Average\" => ta.vwma(_src, _len)\r\n        \"RMA: Rolling Moving Average\" => ta.rma(_src, _len)\r\n        \"WMA: Weighted Moving Average\" => ta.wma(_src, _len)\r\n        \"HMA: Hull Moving Average\" => ta.hma(_src, _len)\r\n        \"SMA: Simple Moving Average\" => ta.sma(_src, _len)\r\n        \"SWMA: Symmetrically Weighted Moving Average\" => ta.swma(_src)\r\n        \"SMMA: Smoothed Moving Average\" => f_smma(_src, _len)\r\n        \"VWAP: Volume Weighted Average Price (Daily)\" => ta.vwap(_src)\r\n        \"MVWAP: Moving VWAP\" => f_mvwap(_src, _len, volume)\r\n        \"LSMA: Least Squares Moving Average\" => ta.linreg(_src, _len, 0)\r\n\r\n\r\nf_timeframeToHuman(_tf) =>\r\n    seconds = timeframe.in_seconds(_tf)\r\n\r\n    if seconds < 60\r\n        _tf\r\n    else if seconds < 3600\r\n        str.tostring(seconds / 60) + 'm'\r\n    else if seconds < 86400\r\n        str.tostring(seconds / 60 / 60) + 'h'\r\n    else\r\n        switch _tf\r\n            \"1D\" => \"D\"\r\n            \"1W\" => \"W\"\r\n            \"1M\" => \"M\"\r\n            => str.tostring(_tf)\r\n\r\n\r\nf_getSizeFromString(_size) =>\r\n    switch _size\r\n        \"auto\" => size.auto\r\n        \"tiny\" => size.tiny\r\n        \"small\" => size.small\r\n        \"normal\" => size.normal\r\n        \"large\" => size.large\r\n        \"huge\" => size.huge\r\n\r\n\r\nf_getLabelText(_tf, _type, _len, _n) =>\r\n    t = ''\r\n    maType = str.substring(_type, 0, str.pos(_type, ':'))\r\n\r\n    if i_showType\r\n        t := maType\r\n\r\n    if i_showLen and maType != \"VWAP\" and maType != \"SWMA\"\r\n        t += (t != '' ? ' ' : '') + str.tostring(_len)\r\n\r\n    if i_showTf and _tf != ''\r\n        t += (t != '' ? ' / ' : '') + f_timeframeToHuman(_tf)\r\n\r\n    if i_showN\r\n        t += (t != '' ? ' ' : '') + '#' + str.tostring(_n)\r\n    t\r\n\r\n\r\nlabelSize = f_getSizeFromString(i_labelSize)\r\n\r\nf_addMaLabel(_enabled, _n, _src, _price, _tf, _type, _len, _color, _offset) =>\r\n    label l = na\r\n    if _enabled and not na(_price)\r\n        labelText = f_getLabelText(_tf, _type, _len, _n)\r\n        if labelText != ''\r\n            pos = chart.point.from_index(bar_index + i_labelOffset + _offset, _price)\r\n            maTooltip = str.format(\"MA #{0}\\nType: {1}\\nLength: {2}\\nTimeframe: {3}\\nPrice: {4}\", _n, str.replace(_type, ':', ' -'), _len, f_timeframeToHuman(_tf), _price)\r\n            l := label.new(pos, text=labelText, color=color.new(color.black, 100), textcolor=_color, style=label.style_label_left, textalign=text.align_left, yloc=yloc.price, size = labelSize, tooltip = maTooltip)\r\n    label.delete(l[1])\r\n\r\n\r\n\r\n// real value / step lines\r\nf_getMaConverted_mode2(_tf, _type, _src, _len) =>\r\n    ma = f_ma(_type, _src, _len)\r\n    tfma = request.security(syminfo.tickerid, _tf, ma)\r\n\r\n// smoothed lines\r\nf_getMaConverted_mode1(_tf, _type, _src, _len) =>\r\n    ma = f_ma(_type, _src, _len)\r\n    [m, bindex] = request.security(syminfo.tickerid, _tf, [ma, bar_index])\r\n    int lbindex = na\r\n    lbindex := na(lbindex[1]) or bindex > lbindex[1] ? bindex : lbindex[1]\r\n    lbindex != lbindex[1] or barstate.islast ? m : na\r\n\r\nf_getMaConverted(_tf, _type, _src, _len) =>\r\n    if i_mtf_mode\r\n        f_getMaConverted_mode1(_tf, _type, _src, _len)\r\n    else\r\n        f_getMaConverted_mode2(_tf, _type, _src, _len)\r\n\r\n\r\n\r\nf_showInCurrentTimeframe(_hideInLowerTf, _tf) =>\r\n    if _hideInLowerTf == false\r\n        true\r\n    else\r\n        timeframe.in_seconds(_tf) >= timeframe.in_seconds()\r\n\r\n\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n// Plots\r\n\r\n\r\n// line width\r\nconst int C_LINEWIDTH = 2\r\n\r\n\r\n//------------------------------------\r\n// MA #1\r\nconst string g_ma1 = 'Moving Average #1'\r\ni_ma1_enabled = input.bool(true, 'Enabled', group = g_ma1)\r\ni_ma1_tf = input.timeframe('', 'Timeframe', group = g_ma1)\r\ni_ma1_src = input.source(close, 'Source', group = g_ma1)\r\ni_ma1_len = input.int(20, 'Length', group = g_ma1)\r\ni_ma1_offset = input.int(0, 'Offset', group = g_ma1)\r\ni_ma1_type = input.string('EMA: Exponential Moving Average', 'Type', options=[\"DEMA: Double Exponential Moving Average\",\"EMA: Exponential Moving Average\",\"HMA: Hull Moving Average\",\"LSMA: Least Squares Moving Average\",\"MVWAP: Moving VWAP\",\"RMA: Rolling Moving Average\",\"SMA: Simple Moving Average\",\"SMMA: Smoothed Moving Average\",\"SWMA: Symmetrically Weighted Moving Average\",\"TEMA: Triple Exponential Moving Average\",\"VWAP: Volume Weighted Average Price (Daily)\",\"VWMA: Volume Weighted Moving Average\",\"WMA: Weighted Moving Average\"], group = g_ma1)\r\ni_ma1_color = input.color(#f7525f, 'Color', group = g_ma1)\r\n\r\nv_ma1 = f_getMaConverted(i_ma1_tf, i_ma1_type, i_ma1_src, i_ma1_len)\r\nv_ma1_visible = i_ma1_enabled and f_showInCurrentTimeframe(i_hideFromLowerTf, i_ma1_tf)\r\nplot(v_ma1_visible ? v_ma1 : na, color=i_ma1_color, linewidth=C_LINEWIDTH, title='MA #1', join=true, offset = i_ma1_offset)\r\nf_addMaLabel(v_ma1_visible, 1, i_ma1_src, v_ma1, i_ma1_tf, i_ma1_type, i_ma1_len, i_ma1_color, i_ma1_offset)\r\nthreshold_ma1 = input(0.6, \"Threshold\")\r\n// Calculate the Simple Moving Average slope\r\nsma_slope_ma1 = ta.sma(close,i_ma1_len) - ta.sma(close[1], i_ma1_len)\r\n// Normalize the Simple Moving Average slope by dividing it by the long-term strandard deviation of the slope\r\nnormalized_sma_slope_ma1 = sma_slope_ma1 / ta.stdev(sma_slope_ma1, i_ma1_len*10)\r\n\r\n\r\n//------------------------------------\r\n// MA #2\r\nconst string g_ma2 = 'Moving Average #2'\r\ni_ma2_enabled = input.bool(true, 'Enabled', group = g_ma2)\r\ni_ma2_tf = input.timeframe('', 'Timeframe', group = g_ma2)\r\ni_ma2_src = input.source(close, 'Source', group = g_ma2)\r\ni_ma2_len = input.int(50, 'Length', group = g_ma2)\r\ni_ma2_offset = input.int(0, 'Offset', group = g_ma2)\r\ni_ma2_type = input.string('EMA: Exponential Moving Average', 'Type', options=[\"DEMA: Double Exponential Moving Average\",\"EMA: Exponential Moving Average\",\"HMA: Hull Moving Average\",\"LSMA: Least Squares Moving Average\",\"MVWAP: Moving VWAP\",\"RMA: Rolling Moving Average\",\"SMA: Simple Moving Average\",\"SMMA: Smoothed Moving Average\",\"SWMA: Symmetrically Weighted Moving Average\",\"TEMA: Triple Exponential Moving Average\",\"VWAP: Volume Weighted Average Price (Daily)\",\"VWMA: Volume Weighted Moving Average\",\"WMA: Weighted Moving Average\"], group = g_ma2)\r\ni_ma2_color = input.color(#ffa726, 'Color', group = g_ma2)\r\n\r\nv_ma2 = f_getMaConverted(i_ma2_tf, i_ma2_type, i_ma2_src, i_ma2_len)\r\nv_ma2_visible = i_ma2_enabled and f_showInCurrentTimeframe(i_hideFromLowerTf, i_ma2_tf)\r\nplot(v_ma2_visible ? v_ma2 : na, color=i_ma2_color, linewidth=C_LINEWIDTH, title='MA #2', join=true, offset = i_ma2_offset)\r\nf_addMaLabel(v_ma2_visible, 2, i_ma2_src, v_ma2, i_ma2_tf, i_ma2_type, i_ma2_len, i_ma2_color, i_ma2_offset)\r\nthreshold_ma2 = input(0.6, \"Threshold\")\r\n// Calculate the Simple Moving Average slope\r\nsma_slope_ma2 = ta.sma(close,i_ma2_len) - ta.sma(close[1], i_ma2_len)\r\n// Normalize the Simple Moving Average slope by dividing it by the long-term strandard deviation of the slope\r\nnormalized_sma_slope_ma2 = sma_slope_ma2 / ta.stdev(sma_slope_ma2, i_ma2_len*10)\r\n\r\n\r\n\r\n// *******************************************************************************\r\n//     ENDSs MultiTimeframe EMAs ENDs \r\n// *********************************************************************************\r\n\r\n// *******************************************************************************\r\n//     START Durbtrade BollingerBand BB\r\n// *********************************************************************************\r\n\r\n// *******************************************************************************\r\n//     ENDSs Durbtrade BollingerBand BB\r\n// *********************************************************************************\r\nfunc_multitimeframe()=>\r\n    //your logic goes here\r\n    length = input.int(20, minval=1)\r\n    src = input(close, title=\"Source\")\r\n    mult = input.float(2.0, minval=0.001, maxval=50, title=\"StdDev\")\r\n    basis = ta.sma(src, length)\r\n    dev = mult * ta.stdev(src, length)\r\n    upper = basis + dev\r\n    lower = basis - dev\r\n    bbw = (upper-lower)/basis\r\n    col = bbw - bbw[1] >0 ?  color.green : color.red\r\n    len2 = input.int(2, minval=1, title=\"EMA Length\")\r\n    offset = input.int(title=\"EMA Offset\", defval=0, minval=-500, maxval=500)\r\n    out = ta.ema(bbw, len2)\r\n    zero= basis - basis\r\n    FilCol = bbw>out ? #17ff03 : #ff0000\r\n\r\n    // plot(zero, title=\"Zero\", color=#d1d4dc, offset=1)\r\n    // F1 = plot(out, title=\"EMA\", color=#0300ff, linewidth=2, offset=offset)\r\n    // F2 = plot(bbw, \"Durbtrade BBW\", color=col, linewidth=2)\r\n    // fill(F1, F2, title=\"Fill\", color=FilCol, transp=85)\r\n\r\n    // Cross1 = ta.crossover(bbw, out) ? #17ff03 : na\r\n    // Cross2 = ta.crossunder(bbw, out) ? #ff0000 : na\r\n    // bgcolor(Cross1, title=\"Cross Over\")\r\n    // bgcolor(Cross2, title=\"Cross Under\")\r\n    [bbw,col,out] \r\n\r\n//plot(smoothingMA, \"RSI-based MA\", color=color.yellow, display =  display.all)\r\n\r\n// // Global Request Function\r\ngetRequest_multitimeframe(_symbol, _timeframe) =>\r\n    [magic,col,out]= request.security(_symbol, _timeframe, func_multitimeframe(),gaps=barmerge.gaps_off,lookahead=barmerge.lookahead_on)    \r\n\r\n// Timeframe_A_3 = input.timeframe(\"5\", title=\"Timeframe A\")\r\nTimeframe_B_15 = input.timeframe(\"60\", title=\"Timeframe B\")\r\n\r\n// [magic3] = getRequestMagicTrend(syminfo.tickerid, Timeframe_A_3)\r\n[bbw60,col,out60] = getRequest_multitimeframe(syminfo.tickerid, Timeframe_B_15)\r\nplot(88000+bbw60, \"Durbtrade BBW\", color=col, linewidth=2)\r\n\r\n\r\n// *******************************************************************************\r\n//     START Fractals\r\n// *********************************************************************************\r\n\r\n//\r\n// === INPUTS ===\r\n//\r\n// jawLength     = input(13, \"Jaw Length\")\r\n// teethLength   = input(8, \"Teeth Length\")\r\n// lipsLength    = input(5, \"Lips Length\")\r\n// //\r\n// jawOffset     = input(8, \"Jaw Offset\")\r\n// teethOffset   = input(5, \"Teeth Offset\")\r\n// lipsOffset    = input(3, \"Lips Offset\")\r\n// asrc          = input(hl2, \"Alligator Source\")\r\n// //\r\n// hideAlligator = input(false)\r\n// showAlligatorState = input(false)\r\n// //\r\n// hidefractals  = input(false)\r\n// hidelevels    = input(false)\r\n// maxLvlLen     = input(0)\r\n// uFractalRev   = input(false, \"Use Fractal Reversal Strategy\")\r\n// uFractalBO    = input(false, \"Use Fractal Break Out Strategy\")\r\n// //\r\n// uAwesomeBO    = input(false, \"Use Awesome Break Out Strategy\")\r\n// nLengthSlow   = input(34, minval=1, title=\"Awesome Slow Length\")\r\n// nLengthFast   = input(5,  minval=1, title=\"Awesome Fast Length\")\r\n//\r\n// === /INPUTS ===\r\n\r\n\r\n// === FUNCTIONS ===\r\n\r\n//  ||---   Completed Fractals Recognition Functions:  -----------------------------------------------------||\r\n// isIdealFractal(mode) =>\r\n//     ret = mode == 1 ? high[4] < high[3] and high[3] < high[2] and high[2] > high[1] and high[1] > high[0] : \r\n//           mode == -1 ? low[4] > low[3] and low[3] > low[2] and low[2] < low[1] and low[1] < low[0] : false\r\n    \r\n\r\nisRegularFractal(mode) =>\r\n    ret = mode == 1 ? high[4] < high[2] and high[3] <= high[2] and high[2] > high[1] and high[2] > high[0] : \r\n          mode == -1 ? low[4] > low[2] and low[3] >= low[2] and low[2] < low[1] and low[2] < low[0] : false\r\n          \r\n// //  ||-----------------------------------------------------------------------------------------------------||\r\n\r\n// //\r\n// // SMMA function to Calculate Alligaor Trend Lines\r\n// //\r\n// smma(src, length) =>\r\n//     s = 0.0\r\n//     s := na(s[1]) ? sma(src, length) : ( (s[1] * (length - 1)) + src) / length\r\n//     s\r\n    \r\n// // === /FUNCIONS ===\r\n\r\n// // === SERIES ===\r\n\r\n// // Calculate Offsetted Alligator curves\r\n// jaw_   = smma(asrc, jawLength)\r\n// teeth_ = smma(asrc, teethLength)\r\n// lips_  = smma(asrc, lipsLength)\r\n\r\n// // Re-allign Alligator to current price action.\r\n// jaw   = jaw_[jawOffset]\r\n// teeth = teeth_[teethOffset]\r\n// lips  = lips_[lipsOffset]\r\n\r\n// Fractals.\r\ntopfractal = isRegularFractal(1)\r\nbotfractal = isRegularFractal(-1)\r\n\r\n//Count How many candles for current Pivot Level, If new reset.\r\ntopcnt = 0\r\nbotcnt = 0\r\ntopcnt := topfractal ? 0 : nz(topcnt[1])+1\r\nbotcnt := botfractal ? 0 : nz(botcnt[1])+1\r\n\r\ntopfractals = 0.0\r\nbotfractals = 0.0\r\ntopfractals := topfractal ? high[2] : topfractals[1]\r\nbotfractals := botfractal ? low[2] : botfractals[1]\r\n\r\ntopfc = (topfractals != topfractals[1]) ? na : color.green\r\nbotfc = (botfractals != botfractals[1]) ? na : color.red\r\n\r\n// // Alligator trend States down(<0), up(>0), considation(0) conditions.\r\n// // 1 = lips above teeth above jaw in order, 2 = lips above teeth and jaw, 3 = lips above teeth.\r\n// //\r\n// AlligatorState = lips < teeth and teeth < jaw? -1 : lips > teeth and teeth > jaw ? 1 : \r\n//                  lips<teeth and lips<jaw? -2 : lips>teeth and lips>jaw? 2 :\r\n//                  lips<teeth? -3 : lips>teeth? 3 : 0\r\n\r\n// // Awesome Oscillator \r\n// xSMA1_hl2 = sma(hl2, nLengthFast)\r\n// xSMA2_hl2 = sma(hl2, nLengthSlow)\r\n// xSMA1_SMA2 = xSMA1_hl2 - xSMA2_hl2\r\n// // AO State\r\n// // 1 = start above zero and ascending, 2 = above zero but descending.\r\n// AOstate = xSMA1_SMA2>=0? xSMA1_SMA2 > xSMA1_SMA2[1] ? 1 : 2 : xSMA1_SMA2 > xSMA1_SMA2[1] ? -2 : -1\r\n\r\n// // === /SERIES ===\r\n\r\n// // === PLOTTING ===\r\n// //\r\n// // Plot Alligator\r\n// plot(hideAlligator ? na : jaw_, \"Jaw\", blue, offset=jawOffset,transp=10,linewidth=2)\r\n// plot(hideAlligator ? na : teeth_, \"Teeth\", red, offset=teethOffset,transp=10,linewidth=2)\r\n// plot(hideAlligator ? na : lips_, \"Lips\", green, offset=lipsOffset,transp=10,linewidth=2)\r\n\r\n// Plot Fractals\r\n// plotshape(topfractal, color=color.green, transp=0, style=shape.triangleup, location=location.abovebar, offset=-2, size=size.auto)\r\n// plotshape(botfractal, color=color.red, transp=0, style=shape.triangledown, location=location.belowbar, offset=-2, size=size.auto)\r\n\r\n// Build The Fractal Level lines, fill in the gaps.\r\n// plot( (topcnt<=2)? topfractals : na, color=topfc, transp=20, linewidth=2, offset=-2, title=\"Top Levels -2\")\r\n// plot( (botcnt<=2)? botfractals : na, color=botfc, transp=20, linewidth=2, offset=-2, title=\"Bottom Levels -2\")\r\n// plot( (topcnt<=3)? topfractals : na, color=topfc, transp=20, linewidth=2, offset=-1, title=\"Top Levels -1\")\r\n// plot( (botcnt<=3)? botfractals : na, color=botfc, transp=20, linewidth=2, offset=-1, title=\"Bottom Levels -1\")\r\n// plot( ( topcnt<maxLvlLen)? topfractals : na, color=topfc, transp=20, linewidth=1, offset=0, title=\"Top Levels 0\")\r\n// plot( ( botcnt<maxLvlLen)? botfractals : na, color=botfc, transp=20, linewidth=1, offset=0, title=\"Bottom Levels 0\")\r\n\r\n// // === /PLOTTING ===\r\n\r\n// //\r\n// // === ALERTS ===\r\n// //\r\n\r\n// //\r\n// // Type 1 - Fractal Reversal Signal\r\n// //\r\n// highRev = 0\r\n// lowRev  = 0\r\n// highRev := AlligatorState<=0 ? 0 : AlligatorState==1? AlligatorState[2]>0 and botfractal and low[2]>teeth[2] ? nz(highRev[1])+1 :   highRev[1]>0? highRev[1]+1 : 0 : 0\r\n// lowRev  := AlligatorState>=0 ? 0 : AlligatorState==-1? AlligatorState[2]<0 and topfractal and high[2]<teeth[2] ? nz(lowRev[1])+1 : lowRev[1]>0? lowRev[1]+1 : 0 : 0\r\n\r\n// // Show Fractal Reversal alert Arrows\r\n// plotarrow(uFractalRev ? highRev==1?1:lowRev==1?-1:na : na, title='Fractal Reversal Arrow', colorup=lime, colordown=red, transp=20, offset=0, minheight=40, maxheight=60 )\r\n\r\n// //\r\n// // Type 2 - Fractal Break Out Signal\r\n// //\r\n// highBO = 0\r\n// lowBO = 0\r\n// highBO := AlligatorState<=0 or low<teeth? 0 : AlligatorState>0? (valuewhen(topfractal,high[2],0) > valuewhen(topfractal,teeth[2],0)) ? nz(highBO[1])+1 : highBO[1]>0? highBO[1]+1 : 0 : 0\r\n// lowBO  := AlligatorState>=0 or high>teeth? 0 : AlligatorState<0? (valuewhen(botfractal,low[2],0) < valuewhen(botfractal,teeth[2],0)) ? nz(lowBO[1])+1 : lowBO[1]>0? lowBO[1]+1 : 0 : 0\r\n \r\n// // Show Break out alert arrows\r\n// plotarrow(uFractalBO ? highBO==1?1:lowBO==1?-1:na : na, title='Fractal BreakOut Arrow', colorup=aqua, colordown=fuchsia, transp=20, offset=0, minheight=40, maxheight=60 )\r\n\r\n// //\r\n// // Type 3 - Awesome Break Out Signal\r\n// //\r\n// highABO = 0\r\n// lowABO = 0\r\n// highABO := AlligatorState<=0 or low<teeth? 0 : AlligatorState<=2? AOstate==1 and close>lips ? nz(highABO[1])+1 : 0 : 0\r\n// lowABO  := AlligatorState>=0 or high>teeth? 0 : AlligatorState>=-2? AOstate==-1 and close<lips ? nz(lowABO[1])+1 : 0 : 0\r\n\r\n// // Show Break out alert arrows\r\n// plotarrow(uAwesomeBO ? highABO==1?1:lowABO==1?-1:na : na, title='Fractal BreakOut Arrow', colorup=teal, colordown=orange, transp=20, offset=0, minheight=40, maxheight=60 )\r\n\r\n\r\n// // show Alligator Trend Direction State.\r\n// plotshape(showAlligatorState?true:na, title=\"Alligator Trend Direction\", location=location.bottom,style=shape.square, color=AlligatorState==1?green:AlligatorState==-1?red:yellow,transp=10)\r\n\r\n// // send alerts to alarm subsystem\r\n// alertcondition(highRev==1,title=\"Fractal Reversal Long\",message=\"REV LONG\")\r\n// alertcondition(lowRev==1,title=\"Fractal Reversal Short\",message=\"REV SHORT\")\r\n// alertcondition(highBO==1,title=\"Fractal BreakOut Long\",message=\"BO LONG\")\r\n// alertcondition(lowBO==1,title=\"Fractal BreakOut Short\",message=\"BO SHORT\")\r\n\r\n// // === /ALERTS ===\r\n// //EOF\r\n// *******************************************************************************\r\n//     ENDs Fractals\r\n// *********************************************************************************\r\n\r\n\r\n\r\n//LOGIC HERE starts\r\n//**************************************************************************************************************************************************\r\n//**************************************************************************************************************************************************\r\n//**************************************************************************************************************************************************\r\n\r\ntradeLogic = input.int(title = \"Select \\n TradeLogic: 15: For Manual Trendline with ema crossover \\n 16: only slope  \\n 17: Trade using FRAMAA  \",  defval = 17)\r\nminStochasticPriceDiff = input.float(title = \" min span between hh and lll in one side stochstics candle price values \",  defval = 350.0)\r\n\r\ndop = request.security(ticker.standard( syminfo.tickerid), 'D', open, lookahead=barmerge.lookahead_on)\r\n\r\n// plot(dop , color=color.rgb(185, 178, 77), style=plot.style_cross, linewidth=2, title=\"open\", transp = 5)\r\n\r\n// ttt=label.new(bar_index+1, dop, \"Open\" + \": \" + str.tostring(dop, format.mintick), color=color.new(color.white, 100), textcolor=color.yellow, style=label.style_label_left)\r\n// label.delete(ttt[1])\r\n\r\npdh = request.security(ticker.standard( syminfo.tickerid), 'D', high[1], lookahead=barmerge.lookahead_on)\r\npdl = request.security(ticker.standard( syminfo.tickerid), 'D', low[1], lookahead=barmerge.lookahead_on)\r\n\r\npmh = request.security(ticker.standard( syminfo.tickerid), 'M', high[1], lookahead=barmerge.lookahead_on)\r\npml = request.security(ticker.standard( syminfo.tickerid), 'M', low[1], lookahead=barmerge.lookahead_on)\r\npmc = request.security(ticker.standard( syminfo.tickerid), 'M', close[1], lookahead=barmerge.lookahead_on)\r\n\r\n\r\nmonthR1 = (0.0916*(pmh-pml)) + pmc\r\nmonthS1 = pmc - (0.0916*(pmh-pml))\r\n\r\n\r\nplot(pdh , color=color.rgb(230, 39, 13), style=plot.style_cross, linewidth=2, title=\"open\", transp = 5)\r\nplot(pdl , color=color.rgb(185, 178, 77), style=plot.style_cross, linewidth=2, title=\"open\", transp = 5)\r\n\r\nttt=label.new(bar_index+1, pdh, \"HighV\" + \": \" + str.tostring(pdh, format.mintick), color=color.new(color.white, 100), textcolor=color.rgb(238, 27, 27), style=label.style_label_left)\r\nlabel.delete(ttt[1])\r\nttt1=label.new(bar_index+1, pdl, \"LowV\" + \": \" + str.tostring(pdl, format.mintick), color=color.new(color.white, 100), textcolor=color.yellow, style=label.style_label_left)\r\nlabel.delete(ttt1[1])\r\n\r\nplot(monthR1 , color=#380fce, style=plot.style_circles, linewidth=2, title=\"monthR1\", transp = 5)\r\nplot(monthS1 , color=color.rgb(43, 231, 231), style=plot.style_circles, linewidth=2, title=\"monthS1\", transp = 5)\r\nttt_mRq1=label.new(bar_index+1, monthR1, \"Month-R1\" + \": \" + str.tostring(monthR1, format.mintick), color=color.new(color.white, 100), textcolor=color.rgb(238, 27, 27), style=label.style_label_left)\r\nlabel.delete(ttt_mRq1[1])\r\nttt1_mS1=label.new(bar_index+1, monthS1, \"Month-S1\" + \": \" + str.tostring(monthS1, format.mintick), color=color.new(color.white, 100), textcolor=color.yellow, style=label.style_label_left)\r\nlabel.delete(ttt1_mS1[1])\r\n\r\nfinalBuySellVal:=0\r\nbool longCondition=false\r\nbool shortCondition=false\r\n\r\nisgreen= col==color.green //(bbw60 - bbw60[1] >0)\r\nif not isgreen and (isAlreadyBuyBefore1 or isAlreadySellBefore1)\r\n    if isAlreadyBuyBefore1\r\n        isSquaredOffInt:=1\r\n        finalBuySellVal:=-50\r\n        debugMsg+= str.tostring( int (1))\r\n    else if isAlreadySellBefore1\r\n        isSquaredOffInt:=2\r\n        finalBuySellVal:=50\r\n        debugMsg+= str.tostring( int (2))\r\nif(isgreen and ta.crossover(bbw60, out60))\r\n    if v_ma1 > v_ma1[1]\r\n        finalBuySellVal:=50\r\n        debugMsg+= str.tostring( int (3))\r\n    else if v_ma1 < v_ma1[1]\r\n        finalBuySellVal:=-50\r\n        debugMsg+= str.tostring( int (4))\r\nelse if isgreen\r\n    if isAlreadyBuyBefore1 and  ( ta.crossunder(v_ma1, v_ma2) or (v_ma1 < v_ma1[1] and v_ma2 < v_ma2[1] and v_ma1 < v_ma2))\r\n        finalBuySellVal:=-50\r\n        debugMsg+= str.tostring( int (5))\r\n    else if isAlreadySellBefore1 and ( ta.crossover(v_ma1, v_ma2)  or (v_ma1 > v_ma1[1] and v_ma2 > v_ma2[1] and v_ma1 > v_ma2))\r\n        finalBuySellVal:=50\r\n        debugMsg+= str.tostring( int (6))\r\n\r\n\r\n// if  topfractals!=0.0 and close > topfractals and close[1] <= topfractals and (bbw60 - bbw60[1] >0)\r\n//     finalBuySellVal:=50\r\n// else if  botfractals!=0.0 and close < botfractals and close[1] >= botfractals and (bbw60 - bbw60[1] >0)\r\n//     finalBuySellVal:=-50\r\n// else if (isAlreadyBuyBefore1 ) and (col==color.red)\r\n//     finalBuySellVal:=-50\r\n//     //isSquaredOffInt:=1\r\n// else if (isAlreadySellBefore1 ) and (col==color.red)\r\n//     finalBuySellVal:=50\r\n//     //isSquaredOffInt:=2\r\n// else if  topfractals[1]!=0.0 and close > topfractals[1] and close[1] <= topfractals[1] and (bbw60 - bbw60[1] >0)\r\n//     finalBuySellVal:=50\r\n// else if  botfractals[1]!=0.0 and close < botfractals[1] and close[1] >= botfractals[1] and (bbw60 - bbw60[1] >0)\r\n//     finalBuySellVal:=-50\r\n        \r\n\r\n//debugMsg+= str.tostring( bool (bbw60 - bbw60[1] >0))\r\n//debugMsg+= str.tostring( float (bbw60))\r\nT_from = 0 //int(input.time(title=\"Plz enter the Top line point 1 timestamp\", defval=0)) // unixTimestampIn1\r\nT_to   = 0 // int(input.time(title=\"Plz enter the Top line point 2 timestamp\", defval=0)) //unixTimestampIn2\r\n\r\nT_from1 = 0 // int(input.time(title=\"Plz enter the Bottom line point 1 timestamp\", defval=0)) // unixTimestampIn1\r\nT_to1   =  0 //int(input.time(title=\"Plz enter the Bottom line point 2 timestamp\", defval=0)) //unixTimestampIn2\r\n\r\nif T_from==0\r\n    T_from:=unixTimestampIn1\r\nif T_to==0\r\n    T_to:=unixTimestampIn2\r\nif T_from1==0\r\n    T_from1:=unixTimestampIn3\r\nif T_to1==0\r\n    T_to1:=unixTimestampIn4\r\n\r\nbartime = int(ta.change(time))\r\n\r\nint count_bars1 = ta.barssince(year(T_from)==year(time) and month(T_from)==month(time) and dayofmonth(T_from)==dayofmonth(time) and hour(T_from)==hour(time) and minute(T_from)==minute(time))//math.floor((timenow - T_from) / bartime)\r\nint count_bars2 = ta.barssince(year(T_to)==year(time) and month(T_to)==month(time) and dayofmonth(T_to)==dayofmonth(time) and hour(T_to)==hour(time) and minute(T_to)==minute(time)) //math.floor((timenow - T_to) / bartime)\r\n\r\nint count_bars3 = ta.barssince(year(T_from1)==year(time) and month(T_from1)==month(time) and dayofmonth(T_from1)==dayofmonth(time) and hour(T_from1)==hour(time) and minute(T_from1)==minute(time))//math.floor((timenow - T_from) / bartime)\r\nint count_bars4 = ta.barssince(year(T_to1)==year(time) and month(T_to1)==month(time) and dayofmonth(T_to1)==dayofmonth(time) and hour(T_to1)==hour(time) and minute(T_to1)==minute(time)) //math.floor((timenow - T_to) / bartime)\r\n\r\ncount_bars3 := math.min(count_bars3, 4999)\r\ncount_bars4 := math.min(count_bars4, 4999)\r\n\r\ncount_bars1 := math.min(count_bars1, 4999)\r\ncount_bars2 := math.min(count_bars2, 4999)\r\n// 1 Jan 25 9:48\r\n// 6 jan 25 13:54\r\n\r\ntrendBottom=line(na)\r\ntrendBottom:=tradeLogic!=15?line(na):line.new(x1=bar_index-count_bars1, y1=price1==0.0?high[count_bars1]:price1, x2=bar_index-count_bars2, y2=price2==0.0?high[count_bars2]:price2, xloc=xloc.bar_index ,extend =extend.right, color=#7d69ee, style=line.style_solid, width=1)\r\nline.delete(trendBottom[2])\r\n\r\ntrendTop=line(na)\r\ntrendTop:=tradeLogic!=15?line(na):line.new(x1=bar_index-count_bars3, y1=price3==0.0?low[count_bars3]:price3, x2=bar_index-count_bars4, y2=price4==0.0?low[count_bars4]:price4, xloc=xloc.bar_index ,extend =extend.right, color=#7d69ee, style=line.style_solid, width=1)\r\nline.delete(trendTop[2]) \r\n\r\nhline(price=price5,title='Resistence',color=color.rgb(42, 231, 222), linestyle=hline.style_dashed, linewidth=3)\r\nhline(price=price6,title='Resistence',color=color.rgb(42, 231, 222), linestyle=hline.style_dashed, linewidth=3)\r\n// if(time == unixTimestampIn2 or time == unixTimestampIn4)\r\n//     strategy.exit(id=\"BS\", stop=close) \r\nif tradeLogic==15\r\n    finalBuySellVal:=0\r\n    isSquaredOffInt:=0\r\n    e201= v_ma1_visible? v_ma1: close\r\n    topLinePrice=line.get_price(trendBottom,bar_index)\r\n    bottomLinePrice=line.get_price(trendTop,bar_index)\r\n    if ta.crossover(e201, topLinePrice[1]) or ta.crossover(e201, bottomLinePrice[1]) or (e201[1] <= topLinePrice[1] and e201>topLinePrice[0] ) or (e201[1] <= bottomLinePrice[1] and e201>bottomLinePrice[0] )\r\n        finalBuySellVal:=50\r\n    else if ta.crossunder(e201, topLinePrice[1]) or ta.crossunder(e201, bottomLinePrice[1]) or (e201[1] >= topLinePrice[1] and e201<topLinePrice[0] ) or (e201[1] >= bottomLinePrice[1] and e201<bottomLinePrice[0] )\r\n        finalBuySellVal:=-50\r\n\r\n    if (price5 >0 or price6 > 0) and (ta.crossunder(e201, price5) or ta.crossunder(e201, price6))\r\n        finalBuySellVal:=-50\r\n    else if (price5 >0 or price6 > 0) and (ta.crossover(e201, price5) or ta.crossover(e201, price6))\r\n        finalBuySellVal:=50\r\n                \r\n    if time < math.max(unixTimestampIn2,unixTimestampIn4)\r\n        finalBuySellVal:=0\r\nif tradeLogic==16 // only slope\r\n    finalBuySellVal:=0\r\n    isSquaredOffInt:=0\r\n    if slope50Deried > slope50Deried[1] and slope50Deried[1] > slope50Deried[2] and slope50Deried[2] <= slope50Deried[3] \r\n        finalBuySellVal:=50\r\n    if slope50Deried < slope50Deried[1] and slope50Deried[1] < slope50Deried[2] and slope50Deried[2] >= slope50Deried[3]\r\n        finalBuySellVal:=-50\r\n\r\nif tradeLogic==17 // FRAMA\r\n    finalBuySellVal:=0\r\n    isSquaredOffInt:=0\r\n    topLinePrice=line.get_price(trendBottom,bar_index)\r\n    bottomLinePrice=line.get_price(trendTop,bar_index)\r\n    // Detect if current bar is the first of a new day\r\n    isNewDay = (dayofmonth != dayofmonth[1]) or (month != month[1]) or (year != year[1])\r\n\r\n    isFilt1Buy=ta.crossover(Filt1,topLinePrice[0]) or ta.crossover(Filt1,topLinePrice[1]) or ta.crossover(Filt1,bottomLinePrice[0]) or ta.crossover(Filt1,bottomLinePrice[1]) or ta.crossover(Filt1,monthR1[0]) or ta.crossover(Filt1,monthS1[0])  or ta.crossover(Filt1,pdh[0])  or ta.crossover(Filt1,pdl[0]) or ta.crossover(Filt1,price5[0]) or ta.crossover(Filt1,price6[0]) \r\n    isFilt2Buy=ta.crossover(Filt2,topLinePrice[0]) or ta.crossover(Filt2,topLinePrice[1]) or ta.crossover(Filt2,bottomLinePrice[0]) or ta.crossover(Filt2,bottomLinePrice[1]) or ta.crossover(Filt2,monthR1[0]) or ta.crossover(Filt2,monthS1[0])  or ta.crossover(Filt2,pdh[0])  or ta.crossover(Filt2,pdl[0]) or ta.crossover(Filt2,price5[0]) or ta.crossover(Filt2,price6[0])\r\n    isFilt1Sell=ta.crossunder(Filt1,topLinePrice[0]) or ta.crossunder(Filt1,topLinePrice[1]) or ta.crossunder(Filt1,bottomLinePrice[0]) or ta.crossunder(Filt1,bottomLinePrice[1]) or ta.crossunder(Filt1,monthR1[0]) or ta.crossunder(Filt1,monthS1[0])  or ta.crossunder(Filt1,pdh[0])  or ta.crossunder(Filt1,pdl[0]) or ta.crossunder(Filt1,price5[0]) or ta.crossunder(Filt1,price6[0]) \r\n    isFilt2Sell=ta.crossunder(Filt2,topLinePrice[0]) or ta.crossunder(Filt2,topLinePrice[1]) or ta.crossunder(Filt2,bottomLinePrice[0]) or ta.crossunder(Filt2,bottomLinePrice[1]) or ta.crossunder(Filt2,monthR1[0]) or ta.crossunder(Filt2,monthS1[0])  or ta.crossunder(Filt2,pdh[0])  or ta.crossunder(Filt2,pdl[0]) or ta.crossunder(Filt2,price5[0]) or ta.crossunder(Filt2,price6[0])\r\n\r\n    if isNewDay==false and (isFilt1Buy or isFilt2Buy)\r\n        finalBuySellVal:=50\r\n    else if  isNewDay==false and (isFilt1Sell or isFilt2Sell)\r\n        finalBuySellVal:=-50\r\n//LOGIC here END \r\n//**************************************************************************************************************************************************\r\n//**************************************************************************************************************************************************\r\n//**************************************************************************************************************************************************\r\n\r\n\r\n\r\n\r\n\r\n\r\n//***********************************************************************************************************************************\r\n//**********************************************************************************************************************************\r\n//**************************************************DO not deleted below this*********************************************************************************\r\n//***********************************************************************************************************************************\r\n//***********************************************************************************************************************************\r\n// *********************************************************************************************************\r\nif isEndDay and onlyIntradayTrades\r\n    if isAlreadyBuyBefore1\r\n        isSquaredOffInt:=1\r\n        finalBuySellVal:=-50\r\n    else if isAlreadySellBefore1\r\n        isSquaredOffInt:=2\r\n        finalBuySellVal:=50\r\nif isEndDay==false and finalBuySellVal==50 and (isAlreadySellBefore1 or (isAlreadyBuyBefore1==false and isAlreadySellBefore1==false) or (isSquaredOffInt==2))\r\n    tradeInB:=closepl\r\n    if tradeInS > 0\r\n        ppl:=tradeInS - tradeInB - brokerage_pl\r\n        glob_pl:=glob_pl+ppl\r\n        totalPL:=totalPL+ppl\r\n        if ndDone\r\n            mypl:=mypl+ppl\r\nelse if isEndDay==false and finalBuySellVal==-50 and (isAlreadyBuyBefore1 or (isAlreadyBuyBefore1==false and isAlreadySellBefore1==false) or (isSquaredOffInt==1) )\r\n    tradeInS:=closepl\r\n    if tradeInB > 0\r\n        ppl:=tradeInS - tradeInB - brokerage_pl\r\n        glob_pl:=glob_pl+ppl\r\n        totalPL:=totalPL+ppl\r\n        if ndDone\r\n            mypl:=mypl+ppl\r\n\r\nqty = input.int(confirm=false, defval = 40, title=\"Qty to trade for bitcoin\")\r\nproductType = input.string(confirm=false, defval = \"M\", options=[\"M\",\"I\"], title=\"Product Type - Day(M) or Intraday(I)\")\r\ninstrumentType = input.string(confirm=false, defval = \"OPT\", options=[\"OPT\",\"FUT\"], title=\"Is this future or options?\")\r\necn = input.string(confirm=false, defval = \"NSE\", options=[\"NSE\",\"MCX\"], title=\"Exchange Select\")\r\nstrike_price = input.string(confirm=false, defval = \"50000.0\", title=\"Enter Strike Price\")\r\nsecret = input.string(confirm=false, defval = \"N.A.\", title=\"Enter Dhan Secret against the URL Webhook\")\r\nreal_qty = input.string(confirm=false, defval = \"4\", title=\"Enter Dhan Qty Lot to trade\")\r\nexp_date = input.string(confirm=false, defval = \"2024-05-15\", title=\"Enter Expiry date of the option\")\r\n\r\ngetAlertJsonMessage_DHAN(c,o,h,l,bsVal,isSqrd,t,sym,secret,real_qty,exp_date) =>\r\n    isFuture = instrumentType == \"FUT\"\r\n    cepe = \"CE\"\r\n    tranType = \"B\"\r\n    price = 0.0\r\n    if isFuture\r\n        tranType := bsVal == 50 ? 'B' : 'S'\r\n    else\r\n        if isSqrd==0\r\n            if bsVal == 50\r\n                cepe := \"CE\"\r\n                tranType:=\"B\"\r\n                price := high + 10\r\n            else if bsVal == -50\r\n                cepe := \"PE\"\r\n                tranType:=\"B\"\r\n                price := high + 10\r\n        else if isSqrd == 1\r\n            cepe := \"CE\"\r\n            tranType:=\"S\"\r\n            price := low - 10\r\n        else if isSqrd == 2\r\n            cepe := \"PE\"\r\n            tranType:=\"S\"\r\n            price := low - 10\r\n    //productType\r\n    json = \"{\\\"secret\\\":\\\"\"++str.tostring(secret)+\"\\\",\"\r\n    json += \"\\\"alertType\\\":\\\"multi_leg_order\\\",\\\"order_legs\\\":[\"\r\n    \r\n    json += \" {\\\"orderType\\\":\\\"MKT\\\",\\\"exchange\\\":\\\"\"+str.tostring(ecn)+\"\\\",\\\"instrument\\\":\\\"\"+str.tostring(instrumentType)+\"\\\",\\\"sort_order\\\":\\\"1\\\",\"\r\n    json += \"\\\"symbol\\\":\\\"\"+str.tostring(sym)+\"\\\",\"\r\n    //json += \"\\\"price\\\":\\\"\"+str.tostring(price)+\"\\\",\"\r\n    json += \"\\\"price\\\":\\\"0\\\",\"\r\n    \r\n    json += \"\\\"transactionType\\\":\\\"\"+str.tostring(tranType)+\"\\\",\"\r\n    json += \"\\\"productType\\\":\\\"\"+str.tostring(productType)+\"\\\",\"\r\n    json += \"\\\"quantity\\\":\\\"\"+str.tostring(real_qty)+\"\\\"\"\r\n    if isFuture == false\r\n        json += \"\\\",\"\r\n        json += \"\\\"option_type\\\":\\\"\"+str.tostring(cepe)+\"\\\",\"\r\n        json += \"\\\"strike_price\\\":\\\"\"+str.tostring(strike_price)+\"\\\",\"\r\n        json += \"\\\"expiry_date\\\":\\\"\"+str.tostring(exp_date)+\"\\\"\"\r\n        json += \"},\"\r\n    else\r\n        json += \"}\"\r\n    //Counter order\r\n    if isFuture\r\n        tranType := bsVal == -50 ? 'B' : 'S'\r\n    else\r\n        if isSqrd==0\r\n            if bsVal == 50\r\n                cepe := \"PE\"\r\n                tranType:=\"S\"\r\n                price := high + 10\r\n            else if bsVal == -50\r\n                cepe := \"CE\"\r\n                tranType:=\"S\"\r\n                price := high + 10\r\n        else if isSqrd == 1\r\n            cepe := \"PE\"\r\n            tranType:=\"B\"\r\n            price := low - 10\r\n        else if isSqrd == 2\r\n            cepe := \"CE\"\r\n            tranType:=\"B\"\r\n            price := low - 10\r\n        \r\n    if isFuture == false\r\n        json += \" {\\\"orderType\\\":\\\"MKT\\\",\\\"exchange\\\":\\\"\"+str.tostring(ecn)+\"\\\",\\\"instrument\\\":\\\"\"+str.tostring(instrumentType)+\"\\\",\\\"sort_order\\\":\\\"1\\\",\"\r\n        json += \"\\\"symbol\\\":\\\"\"+str.tostring(sym)+\"\\\",\"\r\n        //json += \"\\\"price\\\":\\\"\"+str.tostring(price)+\"\\\",\"\r\n        json += \"\\\"price\\\":\\\"0\\\",\"\r\n        if isFuture\r\n            if tranType ==\"S\"\r\n                tranType:=\"B\"\r\n            else\r\n                tranType:=\"S\"\r\n        json += \"\\\"transactionType\\\":\\\"\"+str.tostring(tranType)+\"\\\",\"\r\n        json += \"\\\"productType\\\":\\\"\"+str.tostring(productType)+\"\\\",\"\r\n        json += \"\\\"quantity\\\":\\\"\"+str.tostring(real_qty)+\"\\\"\"\r\n        if isFuture == false    \r\n            json += \"\\\",\"\r\n            json += \"\\\"option_type\\\":\\\"\"+str.tostring(cepe)+\"\\\",\"\r\n            json += \"\\\"strike_price\\\":\\\"\"+str.tostring(strike_price)+\"\\\",\"\r\n            json += \"\\\"expiry_date\\\":\\\"\"+str.tostring(exp_date)+\"\\\"\"\r\n        json += \"}\"\r\n\r\n    json += \"]}\"\r\n    json\r\n\r\ngetAlertJsonMessage(c,o,h,l,bsVal,isSqrd,t,sym) =>\r\n    json = \"{\\\"stocks\\\": \\\"\"+str.tostring(sym)+\"\\\",\"\r\n    json +=\"    \\\"trigger_prices\\\":\"+str.tostring( int (c) ) +\",\"\r\n    json +=\"    \\\"scan_name\\\":\\\"positionalmyrnd\\\",\"\r\n    json +=\"    \\\"triggeredAtInLong\\\":\"+str.tostring(t) +\",\"\r\n    json +=\"    \\\"open\\\":\"+str.tostring( int (o) ) +\",\"\r\n    json +=\"    \\\"high\\\":\"+str.tostring( int (h) ) +\",\"\r\n    json +=\"    \\\"low\\\":\"+str.tostring( int (l) ) +\",\" \r\n    json +=\"    \\\"close\\\":\"+str.tostring( int (c) ) +\",\"\r\n    json +=\"    \\\"minDeviation\\\": 1.7,\"\r\n    json +=\"    \\\"conversionLine\\\":0.0,\"\r\n    json +=\"    \\\"baseLine\\\":0.0,\"\r\n    json +=\"    \\\"isOnBuySellValue\\\": true,\"\r\n    json +=\"    \\\"buySellValue\\\":\"+str.tostring( int (bsVal) ) +\",\"\r\n    json +=\"    \\\"isSquaredOff\\\":\"+str.tostring( int (isSqrd) ) +\",\"\r\n    json +=\"    \\\"version\\\": 222,\"\r\n    json +=\"    \\\"sendAlertAsIs\\\":false}\"\r\n    json\r\n\r\nxDown=  finalBuySellVal[0] == -50 and  isSquaredOffInt==0 and (noTrade or isAlreadyBuyBefore1) \r\nxUp=  finalBuySellVal[0] == 50 and  isSquaredOffInt==0 and (noTrade or isAlreadySellBefore1)\r\nxSquareOff=isSquaredOffInt > 0 and ((isAlreadySellBefore1 or isAlreadyBuyBefore1) )\r\n\r\n\r\nside= xUp ? \"buy\": xDown ? \"sell\" : \"NA\"\r\nif isSquaredOffInt==1\r\n    side:=\"sell\"\r\nelse if isSquaredOffInt==2\r\n    side:=\"buy\"\r\n\r\ngetAlertJsonMessageBitcoin(qty, mm, sym) =>\r\n    json = \"{\"\r\n    json += \"\\\"symbol\\\": \\\"\"+str.tostring(sym)+\"\\\",\"\r\n    json += \"\\\"side\\\":\\\"\"+str.tostring(mm)+\"\\\",\"\r\n    json += \"\\\"qty\\\": \\\"\"+str.tostring(qty)+\"\\\",\"\r\n    json += \"\\\"trigger_time\\\": \\\"{{timenow}}\\\",\"\r\n    json += \"\\\"strategy_id\\\": \\\"6691cbdf4ed9de5491f9b0a8c9c3858d\\\"\"\r\n    json += \"}\"\r\n    json\r\n\r\nalert_msg = alertSymbol=='BTCUSD' ?getAlertJsonMessageBitcoin(qty,side,alertSymbol) : getAlertJsonMessage(close,open,high,low,finalBuySellVal,isSquaredOffInt,time,alertSymbol) \r\n//alert_msg_target_exit = alertSymbol=='BTCUSD' ?getAlertJsonMessageBitcoin(qty,side_target_exit,alertSymbol) : secret!='N.A.' ? getAlertJsonMessage_DHAN(close,open,high,low,finalBuySellVal==50?-50:finalBuySellVal==-50?50:0,isSquaredOffInt,time_close,alertSymbol,secret,real_qty,exp_date) :getAlertJsonMessage(close,open,high,low,finalBuySellVal==50?-50:finalBuySellVal==-50?50:0,isSquaredOffInt,time,alertSymbol) \r\n\r\n\r\n\r\n\r\n\r\n\r\nbuySellCol =  finalBuySellVal==50 ? color.black :  color.black\r\nplot(finalBuySellVal , color=buySellCol, style=plot.style_line, linewidth=1, title=\"BuySellValue\", transp = 5)\r\nplot(isSquaredOffInt , color=buySellCol, style=plot.style_line, linewidth=1, title=\"isSquaredOff\", transp = 5)\r\n\r\nif isEndDay and ndDone and onlyIntradayTrades\r\n    xSquareOff:=true\r\n    if (isAlreadySellBefore1) // earlier sell\r\n        ppl:=tradeInS - closepl - brokerage_pl\r\n        glob_pl:=glob_pl+ppl\r\n        totalPL:=totalPL+ppl\r\n    else if (isAlreadyBuyBefore1) \r\n        ppl:=closepl - tradeInB - brokerage_pl\r\n        glob_pl:=glob_pl+ppl\r\n        totalPL:=totalPL+ppl\r\n    ndDone:=false\r\n    mypl:=mypl+ppl\r\n    finalPL:=finalPL+(totalPL - mypl)\r\n    isAlreadySellBefore1:=false\r\n    isAlreadyBuyBefore1:=false\r\nelse\r\n    if (isAlreadySellBefore1 and tradeInS == 0) \r\n        tradeInS:=closepl\r\n    if (isAlreadyBuyBefore1 and tradeInB == 0) \r\n        tradeInB:=closepl\r\n    candleWiseProfit=0.0\r\n    if isAlreadyBuyBefore1 and tradeInB > 0\r\n        candleWiseProfit:=closepl - tradeInB + glob_pl\r\n    else if isAlreadySellBefore1 and tradeInS > 0\r\n        candleWiseProfit:=tradeInS - closepl + glob_pl\r\n    if (isAlreadySellBefore1 and tradeInS > 0) // earlier sell\r\n        ppl:=tradeInS - closepl - brokerage_pl\r\n        totalPL:=totalPL+ppl\r\n    else if (isAlreadyBuyBefore1  and tradeInB > 0) \r\n        ppl:=closepl - tradeInB - brokerage_pl\r\n        totalPL:=totalPL+ppl\r\n    if candleWiseProfit >= target and target > 0\r\n        isToConsider:=false\r\n        xSquareOff:=true\r\n\r\nif ((xDown ) or (xUp ) or (xSquareOff))    \r\n    if (xDown and not xSquareOff)\r\n        tradeInS:=closepl\r\n        \r\n        isAlreadySellBefore1:=true\r\n        isAlreadyBuyBefore1:=false\r\n        strategy.entry(\"S \"+debugMsg, strategy.short, when= (xDown and not xSquareOff)  , alert_message=alert_msg)\r\n        log.warning(\"sell xSquareOff:\"+str.tostring(bool(xSquareOff))+ \" xDown:\"+str.tostring(bool(xDown)) + \" xUp:\"+str.tostring(bool(xUp)) )\r\n    else if (xUp and not xSquareOff)\r\n        tradeInB:=closepl\r\n        isAlreadySellBefore1:=false\r\n        isAlreadyBuyBefore1:=true\r\n        strategy.entry(\"B \"+debugMsg, strategy.long, when= (xUp and not xSquareOff), alert_message=alert_msg )\r\n        log.warning(\"buy xSquareOff:\"+str.tostring(bool(xSquareOff))+ \" xDown:\"+str.tostring(bool(xDown)) + \" xUp:\"+str.tostring(bool(xUp)) )\r\n    else if  ( xSquareOff)\r\n        isAlreadySellBefore1:=false\r\n        isAlreadyBuyBefore1:=false\r\n        strategy.exit(id=\"e \"+debugMsg, stop=close, alert_message=alert_msg)\r\n        log.warning(\"exit xSquareOff:\"+str.tostring(bool(xSquareOff))+ \" xDown:\"+str.tostring(bool(xDown)) + \" xUp:\"+str.tostring(bool(xUp)) )\r\n    //alert(getAlertJsonMessage(close,open,high,low,finalBuySellVal,isSquaredOffInt,time,alertSymbol),alert.freq_once_per_bar)\r\n\r\n \r\nplot(totalPL , color=color.rgb(241, 222, 78), style=plot.style_line, linewidth=1, title=\"PROFIT\", transp = 5)\r\n\r\n\r\n \r\nplotchar(xUp and not xSquareOff, 'Go Long', 'â–²', location.belowbar, color.new(color.lime, 0), size=size.tiny)\r\nplotchar(xDown and not xSquareOff, 'Go Short', 'â–¼', location.abovebar, color.new(color.red, 0), size=size.tiny)\r\nplotchar(xSquareOff, 'Squareoff', 'â–¼', location.abovebar, color.new(#6d45fc, 0), size=size.tiny,text=\"\")\r\n\r\n// //START:: Logic for SL and Target diagramtically on chart\r\n\r\n\r\n// moneyToSLPoints(money) =>\r\n//     strategy.position_size !=0 ? (money / syminfo.pointvalue / math.abs(strategy.position_size)) / syminfo.mintick : na\r\n\r\n// // p = moneyToSLPoints(input(200, title = \"Take Profit $$\"))\r\n// // l = moneyToSLPoints(input(100, title = \"Stop Loss $$\"))\r\n\r\n// p=0\r\n// if na(p[1])\r\n//     p:=0\r\n// else\r\n//     p:=p[1]\r\n// l =0\r\n// if na(l[1])\r\n//     l:=0\r\n// else\r\n//     l:=l[1]\r\n\r\n// if ((longCondition and strategy.position_size <= 0) or (shortCondition and strategy.position_size >= 0))\r\n//     p := int(profit)  //moneyToSLPoints(int(profit))\r\n//     l := int(loss)    //moneyToSLPoints(int(loss))\r\n\r\n\r\n// if (longCondition and strategy.position_size <= 0)\r\n//     //strategy.exit(id=\"x \", stop=close,alert_message=alert_msg_target_exit)\r\n//     strategy.entry(\"My Long Entry Id\"+ str.tostring(int (p))+\" \"+str.tostring(int (l)), strategy.long,alert_message=alert_msg)\r\n//     eventTriggered:=4\r\n\r\n\r\n// if (shortCondition and strategy.position_size >= 0)\r\n//     //strategy.exit(id=\"x \", stop=close,alert_message=alert_msg_target_exit)\r\n//     strategy.entry(\"My Short Entry Id\"+ str.tostring(int (p))+\" \"+str.tostring(int (l)), strategy.short,alert_message=alert_msg)\r\n//     eventTriggered:=2\r\n\r\n// if p > 0 and strategy.position_size != 0 \r\n//     strategy.exit(\"x \", profit = p, loss = l,alert_message=alert_msg_target_exit)\r\n// //strategy.exit(\"x \"+ str.tostring(int (p))+\" \"+str.tostring(int (l)), profit = p, loss = l,alert_message=alert_msg)\r\n\r\n// // debug plots for visualize SL & TP levels\r\n// pointsToPrice(pp) =>\r\n//     na(pp) ? na : strategy.position_avg_price + pp * math.sign(strategy.position_size) * syminfo.mintick\r\n    \r\n// pp = plot(pointsToPrice(p), style = plot.style_linebr )\r\n// lp = plot(pointsToPrice(-l), style = plot.style_linebr )\r\n// avg = plot( strategy.position_avg_price, style = plot.style_linebr )\r\n// fill(pp, avg, color = color.green)\r\n// fill(avg, lp, color = color.red)\r\n// //END:: Logic for SL and Target diagramtically on chart \r\n\r\n\r\n//*******************************************************************\r\n// STARTS MultiTimeframe CODE\r\n//*******************************************************************\r\n\r\n// func_multitimeframe()=>\r\n//     //your logic goes here\r\n//     [23432]\r\n// //plot(smoothingMA, \"RSI-based MA\", color=color.yellow, display =  display.all)\r\n\r\n// // // Global Request Function\r\n// getRequest_multitimeframe(_symbol, _timeframe) =>\r\n//     [magic]= request.security(_symbol, _timeframe, func_multitimeframe(),gaps=barmerge.gaps_off,lookahead=barmerge.lookahead_off)    \r\n\r\n// // Timeframe_A_3 = input.timeframe(\"5\", title=\"Timeframe A\")\r\n// Timeframe_B_15 = input.timeframe(\"15\", title=\"Timeframe B\")\r\n\r\n// // [magic3] = getRequestMagicTrend(syminfo.tickerid, Timeframe_A_3)\r\n// [magic15] = getRequest_multitimeframe(syminfo.tickerid, Timeframe_B_15)\r\n//*******************************************************************\r\n// ENDS MultiTimeframe CODE\r\n//*******************************************************************\r\n"
  },
  {
    "url": "7WpyJVvp-Quasimodo-Pattern-Strategy-Back-Test-TradingFinder-QM-Trading",
    "name": "Quasimodo Pattern Strategy Back Test [TradingFinder] QM Trading",
    "description": "ðŸ”µ Introduction \n\nThe QM pattern, also known as the Quasimodo pattern, is one of the popular patterns in price action, and it is often used by technical analysts. The QM pattern is used to identify trend reversals and provides a very good risk-to-reward ratio. One of the advantages of the QM pattern is its high frequency and visibility in charts.\n\nAdditionally, due to its strength, it is highly profitable, and as mentioned, its risk-to-reward ratio is very good. The QM pattern is highly popular among traders in supply and demand, and traders also use this pattern.\n\nThe Price Action QM pattern, like other Price Action patterns, has two types: Bullish QM and Bearish QM patterns. To identify this pattern, you need to be familiar with its types to recognize it.\n\n\nðŸ”µ Identifying the QM Pattern \n\nðŸŸ£ Bullish QM \n\nIn the bullish QM pattern, as you can see in the image below, an LL and HH are formed. As you can see, the neckline is marked as a dashed line. When the price reaches this range, it will start its upward movement.\n\n  \n\nðŸŸ£ Bearish QM \n\nThe Price Action QM pattern also has a bearish pattern. As you can see in the image below, initially, an HH and LL are formed. The neckline in this image is the dashed line, and when the LL is formed, the price reaches this neckline. However, it cannot pass it, and the downward trend resumes.\n\n  \n\n\nðŸ”µ How to Use \n\nThe Quasimodo pattern is one of the clearest structures used to identify market reversals. It is built around the concept of a structural break followed by a pullback into an area of trapped liquidity. Instead of relying on lagging indicators, this pattern focuses purely on price action and how the market reacts after exhausting one side of liquidity. When understood correctly, it provides traders with precise entry points at the transition between trend phases.\n\nðŸŸ£ Bullish Quasimodo \n\nA bullish Quasimodo forms after a clear downtrend when sellers start losing control. The market continues to make lower lows until a sudden higher high appears, signaling that buyers are entering with strength. Price then pulls back to retest the previous low, creating what is known as the Quasimodo low. \n\n  \n\nThis area often becomes the final trap for sellers before the market shifts upward. A visible rejection or displacement from this zone confirms bullish momentum. Traders usually place entries near this level, stops below the low, and targets at previous highs or the next resistance zone. Combining the setup with demand zones or Fair Value Gaps increases its accuracy.\n\nðŸŸ£ Bearish Quasimodo \n\nA bearish Quasimodo forms near the top of an uptrend when buyers begin to lose strength. The market continues to make higher highs until a sudden lower low breaks the bullish structure, showing that selling pressure is entering the market. Price then retraces upward to retest the previous high, forming the Quasimodo high, where breakout buyers are often trapped. \n\n  \n\nOnce rejection appears at this level, it indicates a likely reversal. Traders can enter short near this area, with stop-losses placed above the high and targets near the next support or previous lows. The setup gains more reliability when aligned with supply zones, SMT divergence, or bearish Fair Value Gaps.\n\n\nðŸ”µ Setting \n\n Pivot Period : You can use this parameter to use your desired period to identify the QM pattern. By default, this parameter is set to the number 5.\n\n Take Profit Mode : You can choose your desired Take Profit in three ways. Based on the logic of the QM strategy, you can select two Take Profit levels, TP1 and TP2. You can also choose your take profit based on the Reward to Risk ratio. You must enter your desired R/R in the Reward to Risk Ratio parameter.\n\n  \n\n  \n\n  \n\n\n Stop Loss Refine : The loss limit of the QM strategy is based on its logic on the Head pattern. You can refine it using the ATR Refine option to prevent Stop Hunt. You can enter your desired coefficient in the Stop Loss ATR Adjustment Coefficient parameter.\n\n  \n\n  \n\n Reward to Risk Ratio : If you set Take Profit Mode to R/R, you must enter your desired R/R here. For example, if your loss limit is 10 pips and you set R/R to 2, your take profit will be reached when the price is 20 pips away from your entry point.\n\n Stop Loss ATR Adjustment Coefficient : If you set Stop Loss Refine to ATR Refine, you must adjust your loss limit coefficient here. For example, if your buy position's loss limit is at the price of 1000, and your ATR is 10, if you set Stop Loss ATR Adjustment Coefficient to 2, your loss limit will be at the price of 980.\n\n Entry Level Validity : Determines how long the Entry level remains valid. The higher the level, the longer the entry level will remain valid. By default it is 2 and it can be set between 2 and 15.\n\n\nðŸ”µ Results \n\nThe following examples show the backtest results of the Quasimodo (QM) strategy in action. Each image is based on specific settings for the symbol, timeframe, and input parameters, illustrating how the QM logic can generate signals under different market conditions. The detailed configuration for each backtest is also displayed on the image.\n\nâš  Important Note : Even with identical settings and the same symbol, results may vary slightly across different brokers due to data feed variations and pricing differences.\n\n\n Default Properties of Backtests :\n\n  \n\n\n\n  OANDA:XAUUSD  | TimeFrame: 5min | Duration: 1 Year :\n\n  \n\n  BINANCE:BTCUSD  | TimeFrame: 5min | Duration: 1 Year :\n\n  \n\n  CAPITALCOM:US30  | TimeFrame: 5min | Duration: 1 Year :\n\n  \n\n  NASDAQ:QQQ  | TimeFrame: 5min | Duration: 5 Year :\n\n  \n\n   OANDA:EURUSD  | TimeFrame: 5min | Duration: 5 Year :\n\n  \n\n  PEPPERSTONE:US500  | TimeFrame: 5min | Duration: 5 Year :\n\n  \n",
    "image_url": "7WpyJVvp",
    "author": "TFlab",
    "likes": 1303,
    "type": "strategy",
    "created": "2025-11-10",
    "updated": "2025-11-10",
    "source": "// This Pine Scriptâ„¢ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MTL/2.0/\r\n// Â© chartbox90\r\n//@version=5\r\nstrategy(\"Quasimodo Pattern Strategy Back Test [TradingFinder] QM Trading\", \"QM Strategy TFlab\" ,overlay = true ,\r\n initial_capital = 1000 ,default_qty_type = strategy.cash , default_qty_value = 10000 ,max_bars_back = 5000 ,max_lines_count = 500 , max_labels_count = 500)\r\n\r\n\r\nPP = input.int(5 , 'Pivot Period')\r\nATR = ta.atr(21)\r\nTPMode =  input.string('TP1' , 'Take Profit Mode', options = ['TP1', 'TP2', 'R/R'])\r\nSLMode =  input.string('Original' , 'Stop Loss Refine', options = ['Original' , 'ATR Refine'])\r\nRR = input.float(2.0 , 'Reward to Risk Ratio', minval = 0.25  )\r\nCSL = input.float(0.5 , 'Stop Loss ATR Adjustment Coefficient', minval = 0.25  )\r\n\r\nELV = input.int(2 , 'Entry Level Validity', minval= 2 , maxval = 15 , tooltip = 'Determines how long the Entry level remains valid. The higher the level, the longer the entry level will remain valid. By default it is 2 and it can be set between 2 and 15.')\r\n\r\nvar ArrayType = array.new_string()\r\nvar ArrayValue = array.new_float()\r\nvar ArrayIndex =  array.new_int()\r\nvar Line = array.new_line()\r\n\r\nHighPivot = ta.pivothigh(PP,PP)\r\nLowPivot = ta.pivotlow(PP,PP)\r\n\r\nHighValue = ta.valuewhen(HighPivot ,high[PP], 0)\r\nLowValue = ta.valuewhen(LowPivot ,low[PP], 0)\r\n\r\nHighIndex = ta.valuewhen(HighPivot ,bar_index[PP], 0)\r\nLowIndex = ta.valuewhen(LowPivot ,bar_index[PP], 0)\r\n\r\nCorrect_HighPivot = 0.0\r\nCorrect_LowPivot =  0.0\r\n\r\nPASS = 0\r\n\r\nif HighPivot  and  LowPivot\r\n    if ArrayType.size() == 0\r\n        PASS := 1\r\n    else if ArrayType.size() >= 1\r\n        if ((ArrayType.get(ArrayType.size() - 1)) == \"L\" or\r\n             (ArrayType.get(ArrayType.size() - 1)) == \"LL\")\r\n            if LowPivot < ArrayValue.get(ArrayType.size() - 1)\r\n                array.remove(ArrayType,ArrayType.size() - 1)\r\n                array.remove(ArrayValue,ArrayValue.size() - 1)\r\n                array.remove(ArrayIndex,ArrayIndex.size() - 1) \r\n                array.push(ArrayType,ArrayType.size()>2? ArrayValue.get(ArrayType.size() - 2) < LowValue ? \"HL\" : \"LL\" : \"L\")///////////////////////////////Here\r\n                array.push(ArrayValue, LowValue)\r\n                array.push(ArrayIndex, LowIndex)\r\n                Correct_LowPivot :=  LowValue\r\n            else \r\n                array.push(ArrayType,ArrayType.size()>2? ArrayValue.get(ArrayType.size() - 2) < HighValue ? \"HH\" : \"LH\" : \"H\" ) ///////////////////////////////Here\r\n                array.push(ArrayValue, HighValue)\r\n                array.push(ArrayIndex, HighIndex)\r\n            Correct_HighPivot := HighValue  \r\n        else if (ArrayType.get(ArrayType.size() - 1)) == \"H\" or \r\n             (ArrayType.get(ArrayType.size() - 1)) == \"HH\"\r\n            if HighPivot > ArrayValue.get(ArrayType.size() - 1)\r\n                array.remove(ArrayType,ArrayType.size() - 1)\r\n                array.remove(ArrayValue,ArrayValue.size() - 1)\r\n                array.remove(ArrayIndex,ArrayIndex.size() - 1)\r\n                array.push(ArrayType,ArrayType.size()>2? ArrayValue.get(ArrayType.size() - 2) < HighValue ? \"HH\" : \"LH\" : \"H\")///////////////////////////////Here\r\n                array.push(ArrayValue, HighValue)\r\n                array.push(ArrayIndex, HighIndex)\r\n                Correct_HighPivot := HighValue  \r\n            else \r\n                array.push(ArrayType,ArrayType.size()>2?  ArrayValue.get(ArrayType.size() - 2) < LowValue ? \"HL\" : \"LL\" : \"L\")///////////////////////////////Here\r\n                array.push(ArrayValue, LowValue)\r\n                array.push(ArrayIndex, LowIndex)\r\n            Correct_LowPivot :=  LowValue    \r\n        else if (ArrayType.get(ArrayType.size() - 1)) == \"LH\"\r\n            if HighPivot < ArrayValue.get(ArrayType.size() - 1)\r\n                array.push(ArrayType,ArrayType.size()>2?  ArrayValue.get(ArrayType.size() - 2) < LowValue ? \"HL\" : \"LL\" : \"L\")///////////////////////////////Here\r\n                array.push(ArrayValue, LowValue)\r\n                array.push(ArrayIndex, LowIndex)\r\n                Correct_LowPivot :=  LowValue \r\n            else if HighPivot > ArrayValue.get(ArrayType.size() - 1)\r\n                if close < ArrayValue.get(ArrayType.size() - 1)\r\n                    array.remove(ArrayType,ArrayType.size() - 1)\r\n                    array.remove(ArrayValue,ArrayValue.size() - 1)\r\n                    array.remove(ArrayIndex,ArrayIndex.size() - 1)\r\n                    array.push(ArrayType,ArrayType.size()>2? ArrayValue.get(ArrayType.size() - 2) < HighValue ? \"HH\" : \"LH\" : \"H\")///////////////////////////////Here\r\n                    array.push(ArrayValue, HighValue)\r\n                    array.push(ArrayIndex, HighIndex)\r\n                    Correct_HighPivot := HighValue  \r\n                else if close > ArrayValue.get(ArrayType.size() - 1)\r\n                    array.push(ArrayType,ArrayType.size()>2? ArrayValue.get(ArrayType.size() - 2) < LowValue ? \"HL\" : \"LL\" : \"L\")///////////////////////////////Here\r\n                    array.push(ArrayValue, LowValue)\r\n                    array.push(ArrayIndex, LowIndex)\r\n                    Correct_LowPivot :=  LowValue\r\n        else if (ArrayType.get(ArrayType.size() - 1)) == \"HL\"\r\n            if LowPivot > ArrayValue.get(ArrayType.size() - 1)\r\n                array.push(ArrayType,ArrayType.size()>2? ArrayValue.get(ArrayType.size() - 2) < HighValue ? \"HH\" : \"LH\" : \"H\" ) ///////////////////////////////Here\r\n                array.push(ArrayValue, HighValue)\r\n                array.push(ArrayIndex, HighIndex)\r\n                Correct_HighPivot := HighValue                       \r\n            else if LowPivot < ArrayValue.get(ArrayType.size() - 1)\r\n                if close > ArrayValue.get(ArrayType.size() - 1)\r\n                    array.remove(ArrayType,ArrayType.size() - 1)\r\n                    array.remove(ArrayValue,ArrayValue.size() - 1)\r\n                    array.remove(ArrayIndex,ArrayIndex.size() - 1) \r\n                    array.push(ArrayType,ArrayType.size()>2? ArrayValue.get(ArrayType.size() - 2) < LowValue ? \"HL\" : \"LL\" : \"L\")///////////////////////////////Here\r\n                    array.push(ArrayValue, LowValue)\r\n                    array.push(ArrayIndex, LowIndex)\r\n                    Correct_LowPivot :=  LowValue\r\n                else if close < ArrayValue.get(ArrayType.size() - 1)\r\n                    array.push(ArrayType,ArrayType.size()>2? ArrayValue.get(ArrayType.size() - 2) < HighValue ? \"HH\" : \"LH\" : \"H\")///////////////////////////////Here\r\n                    array.push(ArrayValue, HighValue)\r\n                    array.push(ArrayIndex, HighIndex)\r\n                    Correct_HighPivot := HighValue                         \r\nelse if  HighPivot \r\n    if ArrayType.size() == 0\r\n        array.insert(ArrayType, 0, \"H\")\r\n        array.insert(ArrayValue, 0, HighValue)\r\n        array.insert(ArrayIndex, 0, HighIndex)\r\n        Correct_HighPivot := HighValue\r\n    else if ArrayType.size() >= 1\r\n        if ((ArrayType.get(ArrayType.size() - 1)) == \"L\" or\r\n             (ArrayType.get(ArrayType.size() - 1)) == \"HL\" or\r\n             (ArrayType.get(ArrayType.size() - 1)) == \"LL\")\r\n            if HighPivot > ArrayValue.get(ArrayType.size() - 1)\r\n                array.push(ArrayType,ArrayType.size()>2? ArrayValue.get(ArrayType.size() - 2) < HighValue ? \"HH\" : \"LH\" : \"H\" ) ///////////////////////////////Here\r\n                array.push(ArrayValue, HighValue)\r\n                array.push(ArrayIndex, HighIndex)\r\n                Correct_HighPivot := HighValue\r\n            else if  HighPivot < ArrayValue.get(ArrayType.size() - 1)\r\n                array.remove(ArrayType,ArrayType.size() - 1)\r\n                array.remove(ArrayValue,ArrayValue.size() - 1)\r\n                array.remove(ArrayIndex,ArrayIndex.size() - 1) \r\n                array.push(ArrayType,ArrayType.size()>2? ArrayValue.get(ArrayType.size() - 2) < LowValue ? \"HL\" : \"LL\" : \"L\")///////////////////////////////Here\r\n                array.push(ArrayValue, LowValue)\r\n                array.push(ArrayIndex, LowIndex)\r\n                Correct_LowPivot :=  LowValue                         \r\n        else if (ArrayType.get(ArrayType.size() - 1)) == \"H\" or \r\n             (ArrayType.get(ArrayType.size() - 1)) == \"HH\" or \r\n             (ArrayType.get(ArrayType.size() - 1)) == \"LH\"\r\n            if (ArrayValue.get(ArrayValue.size() - 1)) < HighValue\r\n                array.remove(ArrayType,ArrayType.size() - 1)\r\n                array.remove(ArrayValue,ArrayValue.size() - 1)\r\n                array.remove(ArrayIndex,ArrayIndex.size() - 1)\r\n                array.push(ArrayType,ArrayType.size()>2? ArrayValue.get(ArrayType.size() - 2) < HighValue ? \"HH\" : \"LH\" : \"H\")///////////////////////////////Here\r\n                array.push(ArrayValue, HighValue)\r\n                array.push(ArrayIndex, HighIndex)\r\n                Correct_HighPivot := HighValue               \r\nelse if LowPivot \r\n    if ArrayType.size() == 0\r\n        array.insert(ArrayType, 0, \"L\")\r\n        array.insert(ArrayValue, 0, LowValue)\r\n        array.insert(ArrayIndex, 0, LowIndex)\r\n        Correct_LowPivot :=  LowValue\r\n    else if ArrayType.size() >= 1\r\n        if (ArrayType.get(ArrayType.size() - 1)) == \"H\" or \r\n             (ArrayType.get(ArrayType.size() - 1)) == \"HH\" or \r\n             (ArrayType.get(ArrayType.size() - 1)) == \"LH\"\r\n            if LowPivot < ArrayValue.get(ArrayType.size() - 1)\r\n                array.push(ArrayType,ArrayType.size()>2?  ArrayValue.get(ArrayType.size() - 2) < LowValue ? \"HL\" : \"LL\" : \"L\")///////////////////////////////Here\r\n                array.push(ArrayValue, LowValue)\r\n                array.push(ArrayIndex, LowIndex)\r\n                Correct_LowPivot :=  LowValue\r\n            else if LowPivot > ArrayValue.get(ArrayType.size() - 1)\r\n                array.remove(ArrayType,ArrayType.size() - 1)\r\n                array.remove(ArrayValue,ArrayValue.size() - 1)\r\n                array.remove(ArrayIndex,ArrayIndex.size() - 1)\r\n                array.push(ArrayType,ArrayType.size()>2? ArrayValue.get(ArrayType.size() - 2) < HighValue ? \"HH\" : \"LH\" : \"H\")///////////////////////////////Here\r\n                array.push(ArrayValue, HighValue)\r\n                array.push(ArrayIndex, HighIndex)\r\n                Correct_HighPivot := HighValue                        \r\n        else if (ArrayType.get(ArrayType.size() - 1)) == \"L\" or \r\n             (ArrayType.get(ArrayType.size() - 1)) == \"HL\" or \r\n             (ArrayType.get(ArrayType.size() - 1)) == \"LL\"\r\n            if (ArrayValue.get(ArrayValue.size() - 1)) > LowValue\r\n                array.remove(ArrayType,ArrayType.size() - 1)\r\n                array.remove(ArrayValue,ArrayValue.size() - 1)\r\n                array.remove(ArrayIndex,ArrayIndex.size() - 1) \r\n                array.push(ArrayType,ArrayType.size()>2? ArrayValue.get(ArrayType.size() - 2) < LowValue ? \"HL\" : \"LL\" : \"L\")///////////////////////////////Here\r\n                array.push(ArrayValue, LowValue)\r\n                array.push(ArrayIndex, LowIndex)\r\n                Correct_LowPivot :=  LowValue\r\n\r\n\r\nQMDetector(TPMode, SLMode, RR, CSL)=>\r\n    //Bearish QM\r\n\r\n    var string TH1 = \"\"\r\n    var string TH2 = \"\"\r\n    var string TH3 = \"\"\r\n    var string TH4 = \"\"\r\n    var string TH5 = \"\"\r\n\r\n    var int IH = 0\r\n    var int IH1 = 0\r\n    var int IH2 = 0\r\n    var int IH3 = 0\r\n    var int IH4 = 0\r\n    var int IH5 = 0\r\n\r\n    var float VH1 = 0.0\r\n    var float VH2 = 0.0\r\n    var float VH3 = 0.0\r\n    var float VH4 = 0.0\r\n    var float VH5 = 0.0\r\n\r\n    var bool BearQM = false\r\n\r\n    //Bullish QM\r\n\r\n    var string TL1 = \"\"\r\n    var string TL2 = \"\"\r\n    var string TL3 = \"\"\r\n    var string TL4 = \"\"\r\n    var string TL5 = \"\"\r\n\r\n    var int IL = 0\r\n    var int IL1 = 0\r\n    var int IL2 = 0\r\n    var int IL3 = 0\r\n    var int IL4 = 0\r\n    var int IL5 = 0\r\n\r\n    var float VL1 = 0.0\r\n    var float VL2 = 0.0\r\n    var float VL3 = 0.0\r\n    var float VL4 = 0.0\r\n    var float VL5 = 0.0\r\n\r\n    var bool BullQM = false\r\n\r\n    //TP & SL Control\r\n    var string TPmode = TPMode\r\n    var string SLmode = SLMode\r\n    var float rr = RR\r\n    var float Csl = CSL \r\n\r\n\r\n    if ArrayType.size() > 5 \r\n        TH1 := ArrayType.get(ArrayType.size() - 1)\r\n        TH2 :=  ArrayType.get(ArrayType.size() - 2)\r\n        TH3 :=  ArrayType.get(ArrayType.size() - 3)\r\n        TH4 :=  ArrayType.get(ArrayType.size() - 4)\r\n        TH5 :=  ArrayType.get(ArrayType.size() - 5)\r\n        IH  := ArrayIndex.get(ArrayType.size() - 1)\r\n\r\n        IH1 := ArrayIndex.get(ArrayType.size() - 1)\r\n        IH2 := ArrayIndex.get(ArrayType.size() - 2)\r\n        IH3 := ArrayIndex.get(ArrayType.size() - 3)\r\n        IH4 := ArrayIndex.get(ArrayType.size() - 4)\r\n        IH5 := ArrayIndex.get(ArrayType.size() - 5)\r\n\r\n        VH1 := ArrayValue.get(ArrayType.size() - 1)\r\n        VH2 := ArrayValue.get(ArrayType.size() - 2)\r\n        VH3 := ArrayValue.get(ArrayType.size() - 3)\r\n        VH4 := ArrayValue.get(ArrayType.size() - 4)\r\n        VH5 := ArrayValue.get(ArrayType.size() - 5)\r\n\r\n    if ArrayType.size() > 5 \r\n        TL1 := ArrayType.get(ArrayType.size() - 1)\r\n        TL2 := ArrayType.get(ArrayType.size() - 2)\r\n        TL3 := ArrayType.get(ArrayType.size() - 3)\r\n        TL4 := ArrayType.get(ArrayType.size() - 4)\r\n        TL5 := ArrayType.get(ArrayType.size() - 5)\r\n\r\n        IL  := ArrayIndex.get(ArrayType.size() - 1)\r\n        IL1 := ArrayIndex.get(ArrayType.size() - 1)\r\n        IL2 := ArrayIndex.get(ArrayType.size() - 2)\r\n        IL3 := ArrayIndex.get(ArrayType.size() - 3)\r\n        IL4 := ArrayIndex.get(ArrayType.size() - 4)\r\n        IL5 := ArrayIndex.get(ArrayType.size() - 5)\r\n\r\n        VL1 := ArrayValue.get(ArrayType.size() - 1)\r\n        VL2 := ArrayValue.get(ArrayType.size() - 2)\r\n        VL3 := ArrayValue.get(ArrayType.size() - 3)\r\n        VL4 := ArrayValue.get(ArrayType.size() - 4)\r\n        VL5 := ArrayValue.get(ArrayType.size() - 5)\r\n\r\n    //Bearish QM\r\n    var BearQM_Start = 0.0\r\n    var BearQM_End = 0.0\r\n    var BearQM_Index = 0.0\r\n    var CheckBe = 0\r\n    if TH1 == \"LL\" and  TH2 == \"HH\" and TH3 == \"HL\" and TH4 == \"HH\"  and VH5 < VH1 and IH == (bar_index - PP) and CheckBe == 0\r\n        BearQM := true\r\n        BearQM_Start := VH2\r\n        BearQM_End := VH1\r\n        BearQM_Index := IH\r\n        CheckBe := 1 \r\n    else\r\n        BearQM := false\r\n    if BearQM_Start != VH2\r\n        CheckBe := 0\r\n\r\n\r\n    //Bullish QM\r\n    var BullQM_Start = 0.0\r\n    var BullQM_End = 0.0\r\n    var BullQM_Index = 0\r\n    var CheckBu = 0\r\n    if  TL1 == \"HH\" and TL2 == \"LL\" and TL3 == \"LH\" and TL4 == \"LL\" and VL5 > VL1 and  IL == bar_index - PP and CheckBu == 0 \r\n        BullQM := true\r\n        BullQM_Start := VL2\r\n        BullQM_End := VL1\r\n        BullQM_Index := IL\r\n        CheckBu := 1\r\n    else\r\n        BullQM := false\r\n\r\n    if BullQM_Start != VL2\r\n        CheckBu := 0\r\n\r\n    var line BuLeg1 = na\r\n    var line BuLeg2 = na\r\n    var line BuLeg3 = na\r\n    var line BuLeg4 = na\r\n    var line BuLeg5 = na\r\n    var line BuEntryLine= na    \r\n    var line BuSLLine   = na\r\n    var line BuTP1Line  = na\r\n    var line BuTP2Line  = na\r\n    var label BuEntryLabel= na    \r\n    var label BuSLLabel   = na\r\n    var label BuTP1Label  = na\r\n    var label BuTP2Label  = na \r\n    BuMove  = (IL2 - IL4) /2\r\n\r\n    var line BeLeg1 = na\r\n    var line BeLeg2 = na\r\n    var line BeLeg3 = na\r\n    var line BeLeg4 = na\r\n    var line BeLeg5 = na\r\n    var line BeEntryLine= na\r\n    var line BeSLLine   = na\r\n    var line BeTP1Line  = na\r\n    var line BeTP2Line  = na\r\n    var label BeEntryLabel= na\r\n    var label BeSLLabel   = na\r\n    var label BeTP1Label  = na\r\n    var label BeTP2Label  = na\r\n    BeMove  = (IH2 - IH4) /2\r\n \r\n    if BullQM\r\n        // BuMove := (IL2 - IL5) * 2 + 6\r\n        BuLeg1 := line.new(IL5 , VL5 , IL4 , VL4, color = #00a740f5 , width = 2)\r\n        BuLeg2 := line.new(IL4 , VL4 , IL3 , VL3, color = #00a740f5 , width = 2)\r\n        BuLeg3 := line.new(IL3 , VL3 , IL2 , VL2, color = #00a740f5 , width = 2)\r\n        BuLeg4 := line.new(IL2 , VL2 , IL1 , VL1, color = #00a740f5 , width = 2)\r\n        BuLeg5 := line.new(IL1 , VL1 , IL1 + BuMove-2 , VL4, color = #04d7fc , width = 2 , style = line.style_arrow_right)\r\n        BuEntryLine:= line.new(IL4 , VL4 , IL1 + BuMove , VL4, color = #534d4d , width = 1 , style = line.style_dotted)\r\n        BuSLLine   := line.new(IL2  , SLmode == 'Original' ? VL2 : VL2 - (ATR * Csl) , IL1 + BuMove , SLmode == 'Original' ? VL2 : VL2 - (ATR * Csl), color = #b40054, width = 1, style = line.style_dotted)\r\n        BuTP1Line  := line.new(IL3 , VL3 , IL1 + BuMove , VL3, color = #009e3d , width = 1, style = line.style_dotted)\r\n        BuTP2Line  := line.new(IL1 , VL1 , IL1 + BuMove , VL1, color = #009e3d , width = 1, style = line.style_dotted) \r\n        BuEntryLabel:= label.new(IL1 + BuMove+1 , VL4 , 'Entry' , color = #b3b1b100 , style = label.style_text_outline ,textcolor = #b3b1b1)\r\n        BuSLLabel   := label.new(IL1 + BuMove+1 ,SLmode == 'Original' ? VL2 : VL2 - (ATR * Csl) , 'SL' , color = #b3b1b100 , style = label.style_text_outline ,textcolor = #b3b1b1)\r\n        BuTP1Label  := label.new(IL1 + BuMove+1 , VL3 , 'TP1' , color = #b3b1b100 , style = label.style_text_outline ,textcolor = #b3b1b1)\r\n        BuTP2Label  := label.new(IL1 + BuMove+1 , VL1 , 'TP2' , color = #b3b1b100 , style = label.style_text_outline ,textcolor = #b3b1b1)\r\n\r\n\r\n    if BearQM\r\n        BeLeg1 := line.new(IH5 , VH5 , IH4 , VH4, color = #b40054 , width = 2)\r\n        BeLeg2 := line.new(IH4 , VH4 , IH3 , VH3, color = #b40054 , width = 2)\r\n        BeLeg3 := line.new(IH3 , VH3 , IH2 , VH2, color = #b40054 , width = 2)\r\n        BeLeg4 := line.new(IH2 , VH2 , IH1 , VH1, color = #b40054 , width = 2)\r\n        BeLeg5 := line.new(IH1 , VH1 , IH1 + BeMove-2 , VH4, color = #fcad04 , width = 2 , style = line.style_arrow_right)\r\n        BeEntryLine:= line.new(IH4 , VH4 , IH1 + BeMove , VH4, color = #534d4d , width = 1 , style = line.style_dotted)\r\n        BeSLLine   := line.new(IH2  , SLmode == 'Original' ? VH2 : VH2 + (ATR * Csl) , IH1 + BeMove , SLmode == 'Original' ? VH2 : VH2 + (ATR * Csl), color = #b40054, width = 1, style = line.style_dotted)\r\n        BeTP1Line  := line.new(IH3 , VH3 , IH1 + BeMove , VH3, color = #009e3d , width = 1, style = line.style_dotted)\r\n        BeTP2Line  := line.new(IH1 , VH1 , IH1 + BeMove , VH1, color = #009e3d , width = 1, style = line.style_dotted) \r\n        BeEntryLabel:= label.new(IH1 + BeMove+1 , VH4 , 'Entry' , color = #b3b1b100 , style = label.style_text_outline ,textcolor = #b3b1b1)\r\n        BeSLLabel   := label.new(IH1 + BeMove+1 , SLmode == 'Original' ? VH2 : VH2 + (ATR * Csl) , 'SL' , color = #b3b1b100 , style = label.style_text_outline,textcolor = #b3b1b1 )\r\n        BeTP1Label  := label.new(IH1 + BeMove+1 , VH3 , 'TP1' , color = #b3b1b100 , style = label.style_text_outline,textcolor = #b3b1b1 )\r\n        BeTP2Label  := label.new(IH1 + BeMove+1 , VH1 , 'TP2' , color = #b3b1b100 , style = label.style_text_outline,textcolor = #b3b1b1 )\r\n\r\n\r\n\r\n\r\n\r\n    //Strategy\r\n\r\n    //Short\r\n    var BeCheck = 0\r\n    if high >= BeEntryLine.get_y1() and high < BeSLLine.get_y1() and BeCheck == 0 and BearQM_Index + (BeMove * ELV) > bar_index\r\n        BeCheck := 1\r\n        strategy.entry('Sell' , strategy.short )\r\n    \r\n    if low <= (TPmode == 'TP1' ? BeTP1Line.get_y1() : TPmode == 'TP2' ?  BeTP2Line.get_y1() : strategy.position_avg_price - (BeSLLine.get_y1() - strategy.position_avg_price)*rr )\r\n        strategy.close('Sell' )\r\n    else if   high >= BeSLLine.get_y1()\r\n        strategy.close('Sell' )\r\n\r\n\r\n    if  line.get_y1(BeEntryLine)  !=  line.get_y1(BeEntryLine[1]) \r\n        BeCheck := 0\r\n    \r\n    //Long\r\n    var BuCheck = 0\r\n    if low <= BuEntryLine.get_y1() and low > BuSLLine.get_y1() and BuCheck == 0 and BullQM_Index + (BuMove * ELV) > bar_index\r\n        strategy.entry('Buy' , strategy.long )\r\n        BuCheck := 1       \r\n\r\n    if high >= (TPmode == 'TP1' ? BuTP1Line.get_y1() :  TPmode == 'TP2' ? BuTP2Line.get_y1() : strategy.position_avg_price + (strategy.position_avg_price- BuSLLine.get_y1())*rr)  \r\n        strategy.close('Buy' )\r\n    else if low <= BuSLLine.get_y1() \r\n        strategy.close('Buy'  )\r\n\r\n    if line.get_y1(BuEntryLine)  !=  line.get_y1(BuEntryLine[1]) \r\n        BuCheck := 0\r\n\r\n\r\nQMDetector(TPMode, SLMode, RR, CSL)"
  },
  {
    "url": "khONeeNp-Multi-EMA-Session-Breakout-Strategy",
    "name": "Multi-EMA Session Breakout Strategy",
    "description": "this is a strategy that use the session high and low and the EMA LOWS 2 3 6 9 110 355 AND 480",
    "image_url": "khONeeNp",
    "author": "CharisTreader",
    "likes": 16,
    "type": "strategy",
    "created": "2025-11-10",
    "updated": "2025-11-10",
    "source": "//@version=5\r\nstrategy(\"Multi-EMA Session Breakout Strategy\", shorttitle=\"EMA Session Breakout\", overlay=true)\r\n\r\n// --- 1. EMA INPUTS & CALCULATIONS ---\r\n// The user specified the EMAs should be applied to the 'low' of the bar.\r\nema_src = low\r\nema_2   = ta.ema(ema_src, 2)\r\nema_3   = ta.ema(ema_src, 3)\r\nema_6   = ta.ema(ema_src, 6)\r\nema_9   = ta.ema(ema_src, 9)\r\nema_25  = ta.ema(ema_src, 25)\r\nema_110 = ta.ema(ema_src, 110)\r\nema_355 = ta.ema(ema_src, 355)\r\nema_480 = ta.ema(ema_src, 480)\r\n\r\n// --- 2. EMA PLOTTING (RIBBON) ---\r\n// Plotting the EMAs to visualize the ribbon and trend direction.\r\nplot(ema_2,   color=color.rgb(0, 255, 0, 10), title=\"EMA 2 Low\")\r\nplot(ema_3,   color=color.rgb(0, 255, 0, 20), title=\"EMA 3 Low\")\r\nplot(ema_6,   color=color.rgb(0, 255, 0, 30), title=\"EMA 6 Low\")\r\nplot(ema_9,   color=color.rgb(0, 255, 0, 40), title=\"EMA 9 Low\")\r\nplot(ema_25,  color=color.rgb(0, 200, 255, 50), title=\"EMA 25 Low\")\r\nplot(ema_110, color=color.rgb(255, 165, 0, 60), title=\"EMA 110 Low\")\r\nplot(ema_355, color=color.rgb(255, 0, 0, 70), title=\"EMA 355 Low\")\r\nplot(ema_480, color=color.rgb(255, 0, 0, 80), title=\"EMA 480 Low\")\r\n\r\n// --- 3. SESSION HIGH/LOW CALCULATION ---\r\n// Gets the High and Low of the *previous* day's session.\r\n// Note: 'D' is the daily resolution. Change to 'W' for weekly session, etc.\r\nprev_session_high = request.security(syminfo.tickerid, \"D\", high[1], lookahead=barmerge.lookahead_on)\r\nprev_session_low  = request.security(syminfo.tickerid, \"D\", low[1], lookahead=barmerge.lookahead_on)\r\n\r\n// Plot the previous session High/Low\r\nplot(prev_session_high, title=\"Prev Session High\", color=color.new(color.blue, 0), style=plot.style_stepline)\r\nplot(prev_session_low,  title=\"Prev Session Low\", color=color.new(color.red, 0), style=plot.style_stepline)\r\n\r\n// --- 4. TREND CONFIRMATION LOGIC (EMA STACK) ---\r\n// Define a strong bullish/bearish trend based on the EMA ribbon stacking\r\nis_bullish_trend = ema_2 > ema_6 and ema_6 > ema_25 and ema_25 > ema_110 and ema_110 > ema_355\r\nis_bearish_trend = ema_2 < ema_6 and ema_6 < ema_25 and ema_25 < ema_110 and ema_110 < ema_355\r\n\r\n// --- 5. RISK MANAGEMENT INPUTS ---\r\nrisk_reward_ratio = input.float(2.0, title=\"Risk/Reward Ratio (TP:SL)\", minval=1.0)\r\ninitial_risk_percentage = input.float(1.0, title=\"Initial Risk % of Equity\", minval=0.1)\r\n\r\n// Calculate Risk Amount in Currency\r\n// Equity is used to determine position size for realistic backtesting\r\nequity = strategy.initial_capital + strategy.netprofit\r\nrisk_amount = (equity * initial_risk_percentage / 100)\r\n\r\n// --- 6. TRADING LOGIC ---\r\n\r\n// --- LONG ENTRY (BUY) ---\r\n// Condition 1: Strong bullish trend\r\n// Condition 2: Price breaks and CLOSE above the Previous Session High\r\nlong_condition = is_bullish_trend and close > prev_session_high[1] and close[1] <= prev_session_high[1]\r\n\r\nif long_condition\r\n    // Stop Loss: Below the Previous Session Low\r\n    stop_level = prev_session_low\r\n    \r\n    // Position Size Calculation (based on risk)\r\n    long_atr_risk = close - stop_level // Risk in currency units\r\n    long_qty = math.floor(risk_amount / long_atr_risk) // Calculate whole number of contracts/shares\r\n    \r\n    // Take Profit: Calculated based on the Risk/Reward Ratio\r\n    profit_level = close + (long_atr_risk * risk_reward_ratio)\r\n\r\n    if long_qty > 0\r\n        strategy.entry(\"Long\", strategy.long, qty=long_qty)\r\n        strategy.exit(\"TP/SL Long\", from_entry=\"Long\", stop=stop_level, limit=profit_level)\r\n\r\n\r\n// --- SHORT ENTRY (SELL) ---\r\n// Condition 1: Strong bearish trend\r\n// Condition 2: Price breaks and CLOSE below the Previous Session Low\r\nshort_condition = is_bearish_trend and close < prev_session_low[1] and close[1] >= prev_session_low[1]\r\n\r\nif short_condition\r\n    // Stop Loss: Above the Previous Session High\r\n    stop_level = prev_session_high\r\n    \r\n    // Position Size Calculation (based on risk)\r\n    short_atr_risk = stop_level - close // Risk in currency units\r\n    short_qty = math.floor(risk_amount / short_atr_risk) // Calculate whole number of contracts/shares\r\n    \r\n    // Take Profit: Calculated based on the Risk/Reward Ratio\r\n    profit_level = close - (short_atr_risk * risk_reward_ratio)\r\n\r\n    if short_qty > 0\r\n        strategy.entry(\"Short\", strategy.short, qty=short_qty)\r\n        strategy.exit(\"TP/SL Short\", from_entry=\"Short\", stop=stop_level, limit=profit_level)\r\n\r\n// --- END OF SCRIPT ---"
  },
  {
    "url": "e7XQPek8-EMA-Cross-RSI-ADX-Autotrade-Strategy-V2",
    "name": "EMA Cross + RSI + ADX - Autotrade Strategy V2",
    "description": "Overview\nA versatile trend-following strategy combining EMA 9/21 crossovers with RSI momentum filtering and optional ADX trend strength confirmation. Designed for both cryptocurrency and traditional futures/options markets with built-in stop loss management and automated position reversals.\nKey Features\n\nMulti-Market Compatibility: Works on both crypto futures (Bitcoin, Ethereum) and traditional markets (NIFTY, Bank NIFTY, S&P 500 futures, equity options)\nTriple Confirmation System: EMA crossover + RSI filter + ADX strength (optional)\nAutomated Risk Management: 2% stop loss with wick-touch detection\nPosition Auto-Reversal: Opposite signals automatically close and reverse positions\nWebhook Ready: Six distinct alert messages for automation (Entry Buy/Sell, Close Long/Short, SL Hit Long/Short)\n\nPerformance Metrics\n\nNIFTY Futures (15min): 50%+ win rate with ADX filter OFF\nCrypto Markets: Requires extensive backtesting before live deployment\nOptimal Timeframes: 15-minute to 1-hour charts (patience required for higher timeframes)\n\nStrategy Logic\nEntry Signals:\n\nLONG: EMA 9 crosses above EMA 21 + RSI > 55 + ADX > 20 (if enabled)\nSHORT: EMA 9 crosses below EMA 21 + RSI < 45 + ADX > 20 (if enabled)\n\nExit Signals:\n\nOpposite EMA crossover (auto-closes current position)\nStop loss hit at 2% from entry price (tracks candle wicks)\n\nTechnical Indicators:\n\nFast EMA: 9-period (short-term trend)\nSlow EMA: 21-period (primary trend)\nRSI: 14-period with 55/45 thresholds (momentum confirmation)\nADX: 14-period with 20 threshold (trend strength filter - optional)\n\nMarket-Specific Settings\nTraditional Markets (NIFTY, Bank NIFTY, S&P Futures, Options)\nRecommended Settings:\n\nADX Filter: Turn OFF (less choppy, cleaner trends)\nTimeframe: 15-minute chart\nWin Rate: 50%+ on NIFTY Futures\nWhy No ADX: Traditional markets have more institutional participation and smoother price action, making ADX unnecessary\n\nCryptocurrency Markets (BTC, ETH, Altcoins)\nRecommended Settings:\n\nADX Filter: Turn ON (ADX > 20)\nTimeframe: 15-minute to 1-hour\nExtensive backtesting required before live trading\nWhy ADX: Crypto markets are highly volatile and prone to false breakouts; ADX filters low-quality chop\n\nBest Practices\nâœ… Backtest thoroughly on your specific instrument and timeframe\nâœ… Use larger timeframes (1H, 4H) for higher quality signals and better risk/reward\nâœ… Adjust RSI thresholds based on market volatility (try 52/48 for more signals, 60/40 for fewer but stronger)\nâœ… Monitor ADX effectiveness - disable for traditional markets, enable for crypto\nâœ… Proper position sizing - adjust default_qty_value based on your capital and instrument price\nâœ… Paper trade first - test for 2-4 weeks before risking real capital\nRisk Management\n\nFixed 2% stop loss per trade (adjustable)\nStop loss tracks candle wicks for accurate execution\nPositions auto-reverse on opposite signals (no manual intervention needed)\n0.075% commission built into backtest (adjust for your broker)\n\nCustomization Options\nAll parameters are adjustable via inputs:\n\nEMA periods (default: 9/21)\nRSI length and thresholds (default: 14-period, 55/45 levels)\nADX length and threshold (default: 14-period, 20 threshold)\nStop loss percentage (default: 2%)\n\nWebhook Automation\nThis strategy includes six distinct alert messages for automated trading:\n\n\"Entry Buy\" - Long position opened\n\"Entry Sell\" - Short position opened\n\"Close Long\" - Long position closed on opposite crossover\n\"Close Short\" - Short position closed on opposite crossover\n\"SL Hit Long\" - Long stop loss triggered\n\"SL Hit Short\" - Short stop loss triggered\n\nCompatible with Delta Exchange, Binance Futures, 3Commas, Alertatron, and other webhook platforms.\nImportant Notes\nâš ï¸ Crypto markets require extensive backtesting - volatility patterns differ significantly from traditional markets\nâš ï¸ Higher timeframes = better results - 15min works but 1H/4H provide cleaner signals\nâš ï¸ ADX toggle is critical - OFF for traditional markets, ON for crypto\nâš ï¸ Not financial advice - always conduct your own research and use proper risk management\nâš ï¸ Past performance â‰  future results - backtest results may not reflect live trading conditions\nDisclaimer\nThis strategy is for educational and informational purposes only. Trading futures and options involves substantial risk of loss. Always backtest thoroughly, start with paper trading, and never risk more than you can afford to lose. The author assumes no responsibility for any trading losses incurred using this strategy.",
    "image_url": "e7XQPek8",
    "author": "varuns_back",
    "likes": 737,
    "type": "strategy",
    "created": "2025-11-10",
    "updated": "2025-11-10",
    "source": "//@version=6\r\nstrategy(\"EMA Cross + RSI + ADX - Strategy V2\", overlay=true, initial_capital=1000, default_qty_value=10, default_qty_type=strategy.fixed, commission_type=strategy.commission.percent, commission_value=0.075)\r\n\r\n// Inputs\r\nema_fast = input.int(9, \"Fast EMA\", minval=1)\r\nema_slow = input.int(21, \"Slow EMA\", minval=1)\r\nrsi_length = input.int(14, \"RSI Length\", minval=1)\r\nrsi_long = input.int(55, \"RSI Long Threshold\", minval=1, maxval=100)\r\nrsi_short = input.int(40, \"RSI Short Threshold\", minval=1, maxval=100)\r\nsl_percent = input.float(2.0, \"Stop Loss %\", minval=0.1, maxval=10)\r\n\r\n// Filter Inputs\r\nuse_adx = input.bool(true, \"Use ADX Filter\")\r\nadx_length = input.int(14, \"ADX Length\", minval=1)\r\nadx_threshold = input.float(0, \"ADX Threshold\", minval=0, maxval=100)\r\n\r\n// Calculations\r\nema9 = ta.ema(close, ema_fast)\r\nema21 = ta.ema(close, ema_slow)\r\nrsi = ta.rsi(close, rsi_length)\r\n\r\n// ADX Calculation\r\n[diPlus, diMinus, adx] = ta.dmi(adx_length, adx_length)\r\n\r\n// Crossover Detection\r\nbullCross = ta.crossover(ema9, ema21)\r\nbearCross = ta.crossunder(ema9, ema21)\r\n\r\n// Entry Conditions with optional ADX filter\r\nadx_ok = use_adx ? adx > adx_threshold : true\r\nlongCondition = bullCross and rsi > rsi_long and adx_ok\r\nshortCondition = bearCross and rsi < rsi_short and adx_ok\r\n\r\n// Stop Loss Tracking\r\nvar float longSL = na\r\nvar float shortSL = na\r\n\r\n// Update SL on entry\r\nif longCondition\r\n    longSL := close * (1 - sl_percent/100)\r\n\r\nif shortCondition\r\n    shortSL := close * (1 + sl_percent/100)\r\n\r\n// Exit Conditions\r\ncloseLongCondition = bearCross and strategy.position_size > 0\r\ncloseShortCondition = bullCross and strategy.position_size < 0\r\n\r\n// SL Hit Detection (wick touch)\r\nlongSLHit = strategy.position_size > 0 and not na(longSL) and low <= longSL\r\nshortSLHit = strategy.position_size < 0 and not na(shortSL) and high >= shortSL\r\n\r\n// === STRATEGY EXECUTION ===\r\n\r\n// Entries\r\nif longCondition\r\n    strategy.entry(\"LONG\", strategy.long, alert_message=\"Entry Buy\")\r\n\r\nif shortCondition\r\n    strategy.entry(\"SHORT\", strategy.short, alert_message=\"Entry Sell\")\r\n\r\n// Close on opposite crossover\r\nif closeLongCondition\r\n    strategy.close(\"LONG\", comment=\"Opposite Cross\", alert_message=\"Close Long\")\r\n    longSL := na\r\n\r\nif closeShortCondition\r\n    strategy.close(\"SHORT\", comment=\"Opposite Cross\", alert_message=\"Close Short\")\r\n    shortSL := na\r\n\r\n// Stop Loss hits\r\nif longSLHit\r\n    strategy.close(\"LONG\", comment=\"SL Hit\", alert_message=\"SL Hit Long\")\r\n    longSL := na\r\n\r\nif shortSLHit\r\n    strategy.close(\"SHORT\", comment=\"SL Hit\", alert_message=\"SL Hit Short\")\r\n    shortSL := na\r\n\r\n// === PLOTS ===\r\nplot(ema9, \"EMA 9\", color.blue, 2)\r\nplot(ema21, \"EMA 21\", color.red, 2)\r\nplot(strategy.position_size > 0 ? longSL : na, \"Long SL\", color.orange, 2, plot.style_linebr)\r\nplot(strategy.position_size < 0 ? shortSL : na, \"Short SL\", color.orange, 2, plot.style_linebr)\r\n\r\nplotshape(longCondition, \"Long Entry\", shape.triangleup, location.belowbar, color.new(color.green, 0), size=size.large)\r\nplotshape(shortCondition, \"Short Entry\", shape.triangledown, location.abovebar, color.new(color.red, 0), size=size.large)\r\n\r\nplotarrow(closeLongCondition ? -1 : na, \"Close Long\", color.red, minheight=15, maxheight=15)\r\nplotarrow(closeShortCondition ? 1 : na, \"Close Short\", color.green, minheight=15, maxheight=15)\r\n\r\nplotshape(longSLHit, \"Long SL Hit\", shape.xcross, location.belowbar, color.new(color.orange, 0), size=size.normal)\r\nplotshape(shortSLHit, \"Short SL Hit\", shape.xcross, location.abovebar, color.new(color.orange, 0), size=size.normal)"
  },
  {
    "url": "F2SLJNd1-3-Minute-RSI-and-EMA-Crossover-Strategy",
    "name": "3-Minute RSI and EMA Crossover Strategy ",
    "description": "3-Minute RSI and EMA Crossover Sell Strategy with Exit Conditions and Re-entry",
    "image_url": "F2SLJNd1",
    "author": "RSIBHAI",
    "likes": 23,
    "type": "strategy",
    "created": "2025-11-10",
    "updated": "2025-11-10",
    "source": "//@version=5\r\nstrategy(\"3-Minute RSI and EMA Crossover Sell Strategy with Exit Conditions and Re-entry\", overlay=true)\r\n\r\n// Define timeframes for RSI and EMA\r\nthreeMinRSI = request.security(syminfo.tickerid, \"3\", ta.rsi(close, 3))\r\n\r\n// Define EMA on 1-minute timeframe\r\nema10_1m = ta.ema(close, 10)\r\nema20_1m = ta.ema(close, 20)\r\n\r\n// Define EMA on 3-minute timeframe\r\nthreeMinEMA10 = request.security(syminfo.tickerid, \"3\", ta.ema(close, 10))\r\nthreeMinEMA20 = request.security(syminfo.tickerid, \"3\", ta.ema(close, 20))\r\nema13 = ta.ema(close, 13)\r\n\r\n// Track state of the 3-minute RSI condition\r\nvar bool rsi_condition_met = false\r\nvar float sell_price = na\r\nvar int last_trade_close_time = na\r\n\r\n// Check if 3-minute RSI goes above 85\r\nif (threeMinRSI >= 85)\r\n    rsi_condition_met := true\r\n\r\n// Check for EMA crossover and candle close conditions after RSI condition is met\r\nsell_condition = rsi_condition_met and ta.crossunder(ema10_1m, ema20_1m) and close < ema10_1m and close < ema20_1m\r\n\r\nif (sell_condition)\r\n    sell_price := close\r\n    strategy.entry(\"Sell\", strategy.short)\r\n    // Plot \"Sell\" text on the chart at the crossover point with 20% opacity\r\n    label.new(bar_index, low, \"Sell\", color=color.new(color.red, 80), style=label.style_label_down, textcolor=color.white, size=size.normal)\r\n    // Reset the RSI condition to ensure new sequences are checked\r\n    rsi_condition_met := false\r\n\r\n// Exit Conditions\r\nprice_movement = close <= (sell_price - 300)\r\nema_cross_up_3m = ta.crossover(threeMinEMA10, threeMinEMA20)\r\n\r\nif (strategy.position_size < 0) // Checking if the position is short\r\n    if (price_movement or ema_cross_up_3m)\r\n        strategy.close(\"Sell\")\r\n        // Plot \"Close\" text on the chart with 20% opacity\r\n        label.new(bar_index, high, \"Close\", color=color.new(color.green, 80), style=label.style_label_up, textcolor=color.white, size=size.normal)\r\n        // Store the time when the trade was closed\r\n        last_trade_close_time := timenow\r\n\r\n// Re-entry Condition\r\nmin_wait_time = 3 * 60 * 1000  // 3 minutes in milliseconds\r\ntime_since_last_close = timenow - last_trade_close_time\r\n\r\n// Re-entry if at least 3 minutes have passed and EMA 10 crosses below EMA 20 on the 3-minute timeframe\r\nreentry_condition_3m = ta.crossunder(threeMinEMA10, threeMinEMA20) and time_since_last_close >= min_wait_time\r\n\r\nif (reentry_condition_3m)\r\n    sell_price := close\r\n    strategy.entry(\"Re-sell\", strategy.short)\r\n    // Plot \"Re-sell\" text on the chart with 20% opacity\r\n    label.new(bar_index, high, \"Re-sell\", color=color.new(color.blue, 80), style=label.style_label_down, textcolor=color.white, size=size.normal)\r\n\r\n// Plot EMAs for visualization\r\nplot(ema10_1m, title=\"EMA 10 (1m)\", color=color.green, linewidth=2)\r\nplot(ema20_1m, title=\"EMA 20 (1m)\", color=color.orange, linewidth=2)\r\nplot(ema13, title=\"EMA 13\", color=color.white, linewidth=2)\r\n\r\n// Comment out the plots for 3-minute EMAs to hide them from the chart\r\n// plot(threeMinEMA10, title=\"EMA 10 (3m)\", color=color.blue, linewidth=2)\r\n// plot(threeMinEMA20, title=\"EMA 20 (3m)\", color=color.red, linewidth=2)\r\n"
  },
  {
    "url": "MitnY3DA-Multi-EMA-Strategy-Low-Source",
    "name": "Multi-EMA Strategy (Low Source)",
    "description": "this strategy use the ema low for its functionality 8 9 110 355 and 480",
    "image_url": "MitnY3DA",
    "author": "CharisTreader",
    "likes": 5,
    "type": "strategy",
    "created": "2025-11-10",
    "updated": "2025-11-10",
    "source": "//@version=5\nstrategy(title='Multi-EMA Strategy (Low Source)', shorttitle='MultiEMA Strategy', overlay=true, initial_capital=10000)\n\n// --- EMA Lengths ---\nlen8 = input.int(8, title='EMA 8 (Fastest)', minval=1)\nlen9 = input.int(9, title='EMA 9 (Fast)', minval=1)\nlen25 = input.int(25, title='EMA 25 (Short-Term)', minval=1)\nlen110 = input.int(110, title='EMA 110 (Mid-Term)', minval=1)\nlen355 = input.int(355, title='EMA 355 (Long-Term)', minval=1)\nlen480 = input.int(480, title='EMA 480 (Very Long-Term)', minval=1)\n\n// --- Source and EMA Calculation ---\nsource = low  // All EMAs calculated using the Low price\n\nema8 = ta.ema(source, len8)\nema9 = ta.ema(source, len9)\nema25 = ta.ema(source, len25)\nema110 = ta.ema(source, len110)\nema355 = ta.ema(source, len355)\nema480 = ta.ema(source, len480)\n\n// --- Plotting the EMAs ---\nplot(ema8, title='EMA 8 (Low)', color=color.new(color.yellow, 0), linewidth=1)\nplot(ema9, title='EMA 9 (Low)', color=color.new(color.blue, 0), linewidth=1)\nplot(ema25, title='EMA 25 (Low)', color=color.new(color.green, 0), linewidth=2)\nplot(ema110, title='EMA 110 (Low)', color=color.new(color.orange, 0), linewidth=2)\nplot(ema355, title='EMA 355 (Low)', color=color.new(color.red, 40), linewidth=3)\nplot(ema480, title='EMA 480 (Low)', color=color.new(color.purple, 20), linewidth=3)\n\n// --- Strategy Logic (V4) ---\nfast_bull_cross = ta.crossover(ema9, ema25)\nfast_bear_cross = ta.crossunder(ema9, ema25)\n\nif fast_bull_cross\n    strategy.entry('Long', strategy.long)\nif fast_bear_cross\n    strategy.close('Long')\n\n"
  },
  {
    "url": "uOhNhsV1",
    "name": "é€±ä¸€æ™®è·Œç­–ç•¥ Monday shit Strategy ",
    "description": "Strategy Description / ç­–ç•¥æ•˜è¿°\n\nEN\nThis strategy takes a short position at the start of each Monday, based on the hypothesis that cryptocurrency markets tend to experience post-weekend risk-off behavior.\nThe system enters a full-equity short position at the Tokyo open (Taipei 08:00), aiming to capture Monday downside pressure resulting from accumulated weekend information and macro sentiment adjustments when traditional financial markets reopen.\nRisk management uses fixed percentage take-profit and stop-loss levels, emphasizing asymmetric reward-to-risk (large occasional gains, small frequent losses).\nThe model reflects the increasing alignment between crypto price behavior and traditional financial market cycles.\n\nZH-TW\næœ¬ç­–ç•¥æ–¼æ¯é€±ä¸€é–‹ç›¤æ™‚åšç©ºï¼ŒåŸºæ–¼å‡è¨­åŠ å¯†è³‡ç”¢åœ¨é€±æœ«å¾Œå…·æœ‰é¢¨éšªé‡‹æ”¾èˆ‡è£œè·Œå‚¾å‘ã€‚\nç³»çµ±æœƒåœ¨å°åŒ—æ™‚é–“æ—©ä¸Š 08:00 ä»¥å…¨å€‰åšç©ºï¼Œç›®æ¨™æ•æ‰å› é€±æœ«ç´¯ç©æ¶ˆæ¯èˆ‡å‚³çµ±é‡‘èžå¸‚å ´é‡æ–°é–‹ç›¤æ‰€é€ æˆçš„ä¸‹è·Œå£“åŠ›ã€‚\né¢¨æŽ§æŽ¡å›ºå®šæ­¢ç›ˆã€æ­¢æç™¾åˆ†æ¯”ï¼Œå¼·èª¿é«˜å ±é…¬ï¼ä½Žé¢¨éšªçš„ä¸å°ç¨±çµæ§‹ï¼ˆå°è™§å¤šæ¬¡ã€å¶çˆ¾å¤§è³ºï¼‰ã€‚\næ­¤æ¨¡åž‹åæ˜ åŠ å¯†è²¨å¹£å¸‚å ´è¡Œç‚ºèˆ‡è¯çˆ¾è¡—é€±æœŸæ„ˆè¶¨ä¸€è‡´çš„å¸‚å ´ç¾è±¡ã€‚",
    "image_url": "uOhNhsV1",
    "author": "crypto_two_face",
    "likes": 8,
    "type": "strategy",
    "created": "2025-11-10",
    "updated": "2025-11-10",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// Â© crypto_two_face\r\n\r\n//@version=6\r\nstrategy(\"é€±ä¸€æ™®è·Œç­–ç•¥\",\r\n overlay=true,\r\n default_qty_type=strategy.cash,\r\n default_qty_value=100,\r\n initial_capital=1000,\r\n pyramiding=0,\r\n margin_long=0,\r\n margin_short=0\r\n )\r\n\r\n// åˆ¤æ–·æ™‚é–“\r\nt = time(timeframe.period, \"Asia/Taipei\")\r\nisMonday = dayofweek(t) == dayofweek.sunday\r\nis8am = hour(t) == 23 and minute(t) == 0\r\n// è¨˜éŒ„æ˜¯å¦å·²æŽ› TP/SL\r\nvar bool ordersPlaced = false\r\n\r\n// å›ºå®š% æ­¢ç›ˆæ­¢æ\r\ntpPercent = input.float(0.1,'æ­¢ç›ˆ', step=0.01)  // æ­¢ç›ˆ\r\nslPercent = input.float(0.01,'æ­¢æ', step=0.01)  // æ­¢æ\r\n\r\n// é€²å ´ï¼šæ¯é€±ä¸€ 08:00 ç¬¬ä¸€æ ¹ K\r\nenterShort = isMonday and is8am and barstate.isnew\r\n\r\n// è¨ˆç®—æœ¬æ¬¡ä¸‹å–®é‡‘é¡ = ç•¶å‰å…¨éƒ¨ equity\r\ncashToUse = strategy.equity\r\n\r\nif (enterShort and strategy.position_size == 0)\r\n    entryPrice = close[1]\r\n    qty = strategy.equity / entryPrice   // å…¨å€‰\r\n    strategy.entry(\"MonShort\", strategy.short, qty = qty) // å¸‚åƒ¹é€²å ´\r\n    ordersPlaced := false\r\n\r\n// æŒå€‰å¾ŒæŽ› TP/SL\r\nif (strategy.position_size < 0 and not ordersPlaced)\r\n    avg = strategy.position_avg_price\r\n    tpPrice = avg * (1 - tpPercent)\r\n    slPrice = avg * (1 + slPercent)\r\n\r\n    strategy.exit(\"Exit\", \"MonShort\", stop = slPrice, limit = tpPrice)\r\n    ordersPlaced := true\r\n\r\n// å¹³å€‰å¾Œ reset\r\nif (strategy.position_size == 0)\r\n    ordersPlaced := false"
  },
  {
    "url": "NSRNRvG0-FVG-Session-Break-Strategy-with-ATR-RR",
    "name": "FVG Session Break Strategy with ATR RR",
    "description": "ðŸ§  FVG Session Break Strategy with ATR RR â€” Timezone-Aware, Session-Savvy, and Risk-Calibrated\nThis strategy captures high-probability reversals and continuations by combining Fair Value Gap (FVG) imbalances with session-based breakout logic and ATR-calibrated risk management. Itâ€™s designed for traders who want to exploit structural inefficiencies during key market sessions â€” with precision and portability across global exchanges.\n\nðŸ” Core Logic:\nFair Value Gap Detection: Identifies bullish and bearish FVGs using a 3-bar displacement pattern.\n\nSession Breakout Engine: Tracks session highs and lows (Asian, London, NY) and triggers trades only when price breaks these levels â€” ensuring trades occur at meaningful inflection points.\n\nATR-Based RR Control: Dynamically sizes stop-loss and take-profit levels using ATR Ã— multiplier, maintaining consistent risk across volatility regimes.\n\nðŸŒ Timezone-Aware Session Logic:\nSession boundaries are defined in UTC-5 (e.g., NY: 0930â€“1600) but automatically converted to the exchangeâ€™s local timezone using timestamp(\"Etc/GMT+5\", ...). This ensures:\n\nAccurate session detection across all markets and assets\n\nNo manual timezone adjustments needed\n\nRobust performance on crypto, forex, and global equities\n\nðŸ“ˆ Visuals:\nSession highs and lows plotted in orange\n\nBullish and bearish FVGs marked with green and red triangles\n\nStrategy entries and exits shown on chart with full RR logic\n\nThis strategy is ideal for traders who want to combine structural edge with session context and disciplined risk.",
    "image_url": "NSRNRvG0",
    "author": "slopip",
    "likes": 12,
    "type": "strategy",
    "created": "2025-11-25",
    "updated": "2025-11-25",
    "source": "//@version=5\r\nstrategy(\"FVG Session Break Strategy with ATR RR\", overlay=true, default_qty_type=strategy.percent_of_equity, default_qty_value=10)\r\n\r\n// === Inputs ===\r\natrLength   = input.int(14, \"ATR Length\")\r\natrMult     = input.float(1.0, \"ATR Multiplier\")\r\nfirstTradeOnly = input.bool(false, \"Only Take First Trade Per Session\")\r\n\r\n// === ATR Settings ===\r\natr = ta.atr(atrLength)\r\nslBuffer = atr * atrMult\r\ntpBuffer = slBuffer * 2\r\n\r\n// === Session Time Logic (Timezone-Aware) ===\r\nasian_start_utc5  = 1800\r\nasian_end_utc5    = 0\r\nlondon_start_utc5 = 0\r\nlondon_end_utc5   = 600\r\nny_start_utc5     = 930\r\nny_end_utc5       = 1600\r\n\r\nget_session_time(hhmm) =>\r\n    hr = hhmm / 100\r\n    min = hhmm % 100\r\n    timestamp(\"Etc/GMT+5\", year, month, dayofmonth, hr, min)\r\n\r\nasian_start_ts  = get_session_time(asian_start_utc5)\r\nasian_end_ts    = get_session_time(asian_end_utc5)\r\nlondon_start_ts = get_session_time(london_start_utc5)\r\nlondon_end_ts   = get_session_time(london_end_utc5)\r\nny_start_ts     = get_session_time(ny_start_utc5)\r\nny_end_ts       = get_session_time(ny_end_utc5)\r\n\r\nbar_time = time\r\n\r\nis_asian  = bar_time >= asian_start_ts or bar_time < asian_end_ts\r\nis_london = bar_time >= london_start_ts and bar_time < london_end_ts\r\nis_ny     = bar_time >= ny_start_ts and bar_time < ny_end_ts\r\n\r\n// === Session High/Low Tracking ===\r\nvar float session_high = na\r\nvar float session_low = na\r\nvar bool sessionLimitUpdated = false\r\nvar bool tradedThisSession = false   // NEW FLAG\r\n\r\nnew_session = (is_asian and not is_asian[1]) or (is_london and not is_london[1]) or (is_ny and not is_ny[1])\r\n\r\nif new_session\r\n    session_high := high\r\n    session_low := low\r\n    sessionLimitUpdated := false\r\n    tradedThisSession := false       // RESET FLAG AT NEW SESSION\r\nelse\r\n    if high > session_high\r\n        session_high := high\r\n        sessionLimitUpdated := true\r\n    if low < session_low\r\n        session_low := low\r\n        sessionLimitUpdated := true\r\n\r\n// === FVG Definitions ===\r\nbullishFVG = high[2] < low[0] and high > session_high[1] \r\nbearishFVG = low[2] > high[0] and low < session_low[1]\r\n\r\n// === Trade Logic ===\r\nvar bool canTrade = false\r\n\r\nif sessionLimitUpdated\r\n    canTrade := true\r\n\r\nif canTrade and (not firstTradeOnly or not tradedThisSession)\r\n    if bullishFVG\r\n        longSL = close - slBuffer\r\n        longTP = close + tpBuffer\r\n        strategy.entry(\"Long FVG\", strategy.long)\r\n        strategy.exit(\"Long TP/SL\", from_entry=\"Long FVG\", stop=longSL, limit=longTP)\r\n        canTrade := false\r\n        sessionLimitUpdated := false\r\n        tradedThisSession := true   // MARK TRADE TAKEN\r\n    else if bearishFVG\r\n        shortSL = close + slBuffer\r\n        shortTP = close - tpBuffer\r\n        strategy.entry(\"Short FVG\", strategy.short)\r\n        strategy.exit(\"Short TP/SL\", from_entry=\"Short FVG\", stop=shortSL, limit=shortTP)\r\n        canTrade := false\r\n        sessionLimitUpdated := false\r\n        tradedThisSession := true   // MARK TRADE TAKEN\r\n\r\n// === Plotting ===\r\nplotshape(bullishFVG, title=\"Bullish FVG\", location=location.belowbar, color=color.green, style=shape.triangleup, size=size.small)\r\nplotshape(bearishFVG, title=\"Bearish FVG\", location=location.abovebar, color=color.red, style=shape.triangledown, size=size.small)\r\nplot(session_high, \"Session High\", color=color.orange, linewidth=1)\r\nplot(session_low, \"Session Low\", color=color.orange, linewidth=1)\r\n"
  },
  {
    "url": "9odfcpq0-QQQ-Timing",
    "name": "QQQ Timing",
    "description": "This is a trend-following position trading strategy designed for the QQQ and the leveraged ETF QLD (ProShares Ultra QQQ). The primary goal is to capture multi-month holds for maximal profit.\n\n Key Instruments & Performance \n\nThe strategy performs best with QLD, which yields far superior results compared to QQQ.\n\nTQQQ (triple-leveraged) results in higher drawdowns and is not the optimal choice.\n\nImportant: The system is not intended for use with other indexes, individual stocks, or investments (like crypto or gold), as performance can vary widely.\n\n Buy Signals \n\nThe strategy's signals are rooted in the S&P 500 Index (SPX), as testing showed it provides more reliable triggers than using QQQ itself.\n\nPrimary Buy Signal (Credit to IBD/Mike Webster): The SPX triggers a buy when its low closes above the 21-day Exponential Moving Average (EMA) for three consecutive days.\n\nRefinement with Downtrend Lines: During corrective or bear periods, results and drawdowns can be significantly improved by incorporating downtrend lines. These lines connect lower highs. The strategy waits for the price to close above a drawn downtrend line before executing a buy. This refinement can modify the primary signal, either by allowing for an earlier entry or, in some cases, completely nullifying a false signal until the trend change proves itself.\n\n Risk Management & Exit Strategy \n\nInitial Buy Risk: A 3.7% stop loss is applied immediately upon the initial entry.\n\nInitial Exit Rule: An exit is required if the QQQ's low drops below the 50-day Simple Moving Average (SMA).\n\nNote: The 3.7% stop often provides protection when the initial buy occurs below the 50-day SMA. However, if QQQ is already trading above its 50-day SMA at the time of the SPX signal (indicating relative strength), historically, it has been better to use the 50-day SMA rule to give the position more room to run.\n\nTrend Exit (Profit-Taking): To stay in a strong trend for the optimal amount of time, the long position is exited when a moving average crossover to the downside is triggered, based around the 107-day Simple Moving Average (SMA).",
    "image_url": "9odfcpq0",
    "author": "market_quester",
    "likes": 50,
    "type": "strategy",
    "created": "2025-11-10",
    "updated": "2025-11-10",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// Â© market_quester\r\n\r\n//@version=5\r\nstrategy(\"QQQ Timing\", overlay = true, default_qty_type = strategy.percent_of_equity, default_qty_value=100, currency = currency.USD, initial_capital=100000)\r\n\r\n// ðŸ’¡ Note: Only intended and backtested for trading QQQ, QLD.   Long term results are worse than QLD with TQQQ as of backtesting in 2025\r\n// Use QQQ chart for manually drawing downtrend lines (attaching lower highs, falling tops) and greatly enhancing false buys and slightly \r\n// better entries in some cases during corrections/bear markets. Don't use QLD or TQQQ for drawing downtrend lines as the daily reset distorts the trend.\r\n\r\n// --- ðŸ“Š Index Data (SPX) ---\r\n// Index ticker to use for signals (S&P 500).  Found better results with S&P as root\r\nindexTicker = \"SP:SPX\"\r\nspxClose = request.security(\"SPX\", 'D', close)\r\nspxLow = request.security(\"SPX\", 'D', low)\r\n\r\n// --- ðŸ“ˆ Index Moving Averages ---\r\nspxShortMA = ta.sma(spxClose, 7)\r\nspxMediumMA = ta.ema(spxClose, 14)\r\nspxLongMA = ta.sma(spxClose, 107)\r\nspx21ema = ta.ema(spxClose, 21)\r\n\r\nshortMA = ta.sma(close, 7)\r\nmediumMA = ta.ema(close, 14)\r\nlongMA = ta.sma(close, 107)\r\n\r\n// --- ðŸ“‰ Current Ticker Plotting MAs ---\r\n_14ema = ta.ema(close, 14)\r\n_21ema = ta.ema(close, 21)\r\n_50sma = ta.sma(close, 50)\r\n\r\n// --- ðŸ›‘ Stop Loss Calculation, 3.7% from initial buy point, no trail ---\r\nlongLossPerc = input.float(title=\"Long Stop Loss (%)\",\r\n     minval=0.0, step=0.1, defval=1) * 0.037\r\nlongStopPrice = strategy.position_avg_price * (1 - longLossPerc)\r\n\r\n// --- âœ… Entry Condition ---\r\n// SPX Low must be above the 21 EMA for 3 consecutive days.\r\nspxLowAbove21ema_3days = spxLow > spx21ema and spxLow[1] > spx21ema[1] and spxLow[2] > spx21ema[2]\r\nlongCondition = spxLowAbove21ema_3days\r\n\r\n// --- Exit Condition ---\r\nexitCondition = (\r\n   ((ta.crossunder(spxShortMA, spxLongMA) and spxClose < spxShortMA and spxClose < spxMediumMA) and (close < _14ema)) or \r\n   (low < longStopPrice and low < _50sma))\r\n\r\n// --- ðŸ“… Date Range Filter ---\r\nstartDate = input.int(title=\"Start Date\",\r\n     defval=8, minval=1, maxval=24)\r\nstartMonth = input.int(title=\"Start Month\",\r\n     defval=6, minval=1, maxval=12)\r\nstartYear = input.int(title=\"Start Year\",\r\n     defval=1970, minval=1970, maxval=2100)\r\ninDateRange = (time >= timestamp(syminfo.timezone, startYear, startMonth, startDate, 0, 0))\r\n\r\n// --- ðŸ” Strategy Execution ---\r\nif longCondition and inDateRange\r\n    strategy.entry(\"Buy\", strategy.long)\r\n\r\nif exitCondition and inDateRange\r\n    strategy.close(\"Buy\")\r\n\r\n// --- ðŸŽ¨ Plotting & Background ---\r\n// Get the background color's RGB values\r\nr = color.r(chart.bg_color)\r\ng = color.g(chart.bg_color)\r\nb = color.b(chart.bg_color)\r\nbool darkMode = r < 80 and g < 80 and b < 80\r\ncolor color21ema = color.green\r\ncolor colorShortMA = color.new(color.orange, 30)\r\ncolor colorMediumMA = color.new(color.purple, 0)\r\ncolor colorLongMA = color.new(color.blue, 35)\r\ncolor buyBackground = color.new(#90EE90, 50)\r\n\r\nplot(_21ema, color=color21ema, title=\"21 EMA\")\r\nplot(_50sma, color=color.new(color.red, 0), title=\"50 EMA\")\r\nplot(shortMA, color=colorShortMA, title=\"7 SMA\")\r\nplot(mediumMA, color=colorMediumMA, title=\"14 EMA\")\r\nplot(longMA, color=colorLongMA, title=\"107 SMA\")\r\n\r\n\r\nmycolor = strategy.position_size > 0 ? buyBackground : na\r\nbgcolor(mycolor)\r\n"
  },
  {
    "url": "8qSr57Sx-Rasta",
    "name": "Rasta",
    "description": "Rasta â€” Educational Strategy (Pine v5)\n\nMomentum Â· Smoothing Â· Trend Study\n\nOverview\n\nThe Rasta Strategy is a visual and educational framework designed to help traders study momentum transitions using the interaction between a fast-reacting EMA line and a slower smoothed reference line.\nIt is not a signal generator or profit system; itâ€™s a learning tool for understanding how smoothing, crossovers, and filters interact under different market conditions.\n\nThe script displays:\n\nA primary EMA line (the fast reactive wave).\n\nA Smoothed line (using your chosen smoothing method).\n\nOptional fog zones between them for quick visual context.\n\nOptional DNA rungs connecting both lines to illustrate volatility compression and expansion.\n\nOptional EMA 8 / EMA 21 trend filter to observe higher-time-frame alignment.\n\nCore Idea\n\nThe Rasta model focuses on wave interaction. When the fast EMA crosses above the smoothed line, it reflects a shift in short-term momentum relative to background trend pressure. Cross-unders suggest weakening or reversal.\nRather than treating this as a trading â€œsignal,â€ use it to observe structure, study trend alignment, and test how smoothing type affects reaction speed.\n\nSmoothing Types Explained\n\nThe script lets you experiment with multiple smoothing techniques:\n\nType\tDescription\tUse Case\nSMA (Simple Moving Average)\tArithmetic mean of the last n values. Smooth and steady, but slower.\tTrend-following studies; filters noise on higher time frames.\nEMA (Exponential Moving Average)\tWeights recent data more. Responds faster to new price action.\tMomentum or reactive strategies; quick shifts and reversals.\nRMA (Relative Moving Average)\tUsed internally by RSI; smooths exponentially but slower than EMA.\tMomentum confirmation; balanced response.\nWMA (Weighted Moving Average)\tLinear weights emphasizing the most recent data strongly.\tIntraday scalping; crisp but potentially noisy.\nNone\tDisables smoothing; uses the EMA line alone.\tRaw comparison baseline.\n\nEach smoothing method changes how early or late the strategy reacts:\n\nFaster smoothing (EMA/WMA) = more responsive, good for scalping.\n\nSlower smoothing (SMA/RMA) = more stable, good for trend following.\n\nModes of Study\nðŸ”¹ Scalper Mode\n\nUse short EMA lengths (e.g., 3â€“5) and fast smoothing (EMA or WMA).\n\nFocus on 1 min â€“ 15 min charts.\n\nWatch how quick crossovers appear near local tops/bottoms.\n\nFog and rung compression reveal volatility contraction before bursts.\nGoal: study short-term rhythm and liquidity pulses.\n\nðŸ”¹ Momentum Mode\n\nUse moderate EMA (5â€“9) and RMA smoothing.\n\nIdeal for 1 Hâ€“4 H charts.\n\nObserve how the fog color aligns with trend shifts.\n\nEMA 8 / 21 filter can act as macro bias; â€œEnterâ€ labels will appear only in its direction when enabled.\nGoal: study sustained motion between pullbacks and acceleration waves.\n\nðŸ”¹ Trend-Follower Mode\n\nUse longer EMA (13â€“21) with SMA smoothing.\n\nGreat for daily/weekly charts.\n\nFocus on periods where fog stays unbroken for long stretches â€” these illustrate clear trend dominance.\n\nWatch rung spacing: tight clusters often precede consolidations; wide rungs signal expanding volatility.\nGoal: visualize slow-motion trend transitions and filter whipsaw conditions.\n\nComponents\n\nEMA Line (Red): Fast-reacting short-term direction.\n\nSmoothed Line (Yellow): Reference trend baseline.\n\nFog Zone: Green when EMA > Smoothed (up-momentum), red when below.\n\nDNA Rungs: Thin connectors showing volatility structure.\n\nEMA 8 / 21 Filter (optional):\n\nWhen enabled, the strategy will only allow Enter events if EMA 8 > EMA 21.\n\nUse this to study higher-trend gating effects.\n\nEducational Applications\n\nMomentum Visualization: Observe how the fast EMA â€œbreathesâ€ around the smoothed baseline.\n\nTrend Transitions: Compare different smoothing types to see how early or late reversals are detected.\n\nNoise Filtering: Experiment with fog opacity and smoothing lengths to understand trade-off between responsiveness and stability.\n\nRisk Concept Simulation: Includes a simple fixed stop-loss parameter (default 13%) for educational demonstrations of position management in the Strategy Tester.\n\nHow to Use\n\nAdd to Chart â†’ â€œStrategy.â€\nWorks on any timeframe and instrument.\n\nAdjust Parameters:\n\nLength: base EMA speed.\n\nSmoothing Type: choose SMA, EMA, RMA, or WMA.\n\nSmoothing Length: controls delay and smoothness.\n\nEMA 8 / 21 Filter: toggles trend gating.\n\nFog & Rungs: visual study options only.\n\nStudy Behavior:\n\nUse Strategy Tester â†’ List of Trades for entry/exit context.\n\nObserve how different smoothing types affect early vs. late â€œEnterâ€ points.\n\nCompare trend periods vs. ranging periods to evaluate efficiency.\n\nCombine with External Tools:\n\nOverlay RSI, MACD, or Volume for deeper correlation analysis.\n\nUse replay mode to visualize crossovers in live sequence.\n\nInterpreting the Labels\n\nEnter: Marks where fast EMA crosses above the smoothed line (or when filter flips positive).\n\nExit: Marks where fast EMA crosses back below.\nThese are purely analytical markers â€” they do not represent trade advice.\n\nEducational Value\n\nThe Rasta framework helps learners explore:\n\nReaction time differences between moving-average algorithms.\n\nImpact of smoothing on signal clarity.\n\nInteraction of local and global trends.\n\nVisualization of volatility contraction (tight DNA rungs) and expansion (wide fog zones).\nItâ€™s a sandbox for studying price structure, not a promise of profit.\n\nDisclaimer\n\nThis script is provided for educational and research purposes only.\nIt does not constitute financial advice, trading signals, or performance guarantees. Past market behavior does not predict future outcomes.\nUsers are encouraged to experiment responsibly, record observations, and develop their own understanding of price behavior.\n\nAuthor: Michael Culpepper (mikeyc747)\nLicense: Educational / Open for study and modification with credit.\nPhilosophy:\n\nâ€œLearning the rhythm of the market is more valuable than chasing its profits.â€ â€” Rasta",
    "image_url": "8qSr57Sx",
    "author": "mikeyc747",
    "likes": 409,
    "type": "strategy",
    "created": "2025-11-09",
    "updated": "2025-11-09",
    "source": "//@version=5\nstrategy(\"Rasta\",\n     overlay=true, max_lines_count=500,\n\n     // --- Defaults to match your screenshots\n     initial_capital = 100,\n     currency        = currency.USD,\n     default_qty_type= strategy.cash,     // order size in USD\n     default_qty_value=100,\n     pyramiding      = 0,\n     commission_type = strategy.commission.percent,\n     commission_value= 0.25,\n     slippage        = 0,\n     calc_on_every_tick = true,\n     calc_on_order_fills = true)\n\n/// ========= Inputs (same as indicator)\ngroupInp   = \"Inputs\"\nemaLen     = input.int(5, \"Length\", minval=1, group=groupInp)\nsrc        = input.source(close, \"Source\", group=groupInp)\noffsetBars = input.int(0, \"Offset\", group=groupInp)\n\ngroupSm    = \"Smoothing\"\nsmType     = input.string(\"SMA\", \"Type\",\n              options=[\"SMA\",\"EMA\",\"RMA\",\"WMA\",\"None\"], group=groupSm)\nsmLen      = input.int(5, \"Length\", minval=1, group=groupSm)\n\ngroupViz   = \"Visualization\"\nshowLabels = input.bool(true,  \"Show Buy/Sell Labels\", group=groupViz)\nshowFog    = input.bool(true,  \"Show Colored Fog Between Lines\", group=groupViz)\nfogTransp  = input.int(55,     \"Fog Opacity (0=solid, 100=hidden)\", minval=0, maxval=100, group=groupViz)\n\ngroupRung  = \"DNA Rungs\"\nshowRungs  = input.bool(true,  \"Show DNA Rungs (EMA â†” Smoothed)\", group=groupRung)\nrungWidth  = input.int(3,      \"Rung Width\", minval=1, maxval=5, group=groupRung)\nmaxKeep    = input.int(420,    \"Max Rungs to Keep (<= 450)\", minval=100, maxval=450, step=10, group=groupRung)\nrungColorMode = input.string(\"Direction\", \"Rung Color\",\n     options=[\"Fixed Green\",\"Direction\"], group=groupRung)\nrungFixedCol  = input.color(color.lime, \"Fixed Rung Color\", group=groupRung)\n\n/// ========== EMA 8/21 Filter (same behavior; exits never blocked)\ngroupFilt        = \"EMA 8/21 Filter\"\nuseEmaFilter     = input.bool(true,  \"Enable EMA 8/21 Filter\", group=groupFilt)\nemaFastLenSw     = input.int(8,      \"Fast EMA\",  minval=1, group=groupFilt)\nemaSlowLenSw     = input.int(21,     \"Slow EMA\",  minval=1, group=groupFilt)\nplotFilterEMAs   = input.bool(false, \"Plot Filter EMAs\", group=groupFilt)\nadaptiveOnFlip   = input.bool(true,  \"Adaptive entry when filter flips ON\", group=groupFilt)\n\nema8  = ta.ema(close, emaFastLenSw)\nema21 = ta.ema(close, emaSlowLenSw)\nupTrend       = ema8 > ema21\nfilterFlipOn  = ta.crossover(ema8, ema21)\n\n/// ========== Fixed Stop-Loss (adjustable; default 13%)\ngroupRisk   = \"Risk\"\nslPctInp    = input.float(13.0, \"Fixed Stop Loss (%)\", minval=0.1, step=0.1, group=groupRisk) / 100.0\n\n/// ========== Core calc\nemaLine = ta.ema(src, emaLen)\nf_smooth(series float s, string t, int l) =>\n    float out = switch t\n        \"SMA\"  => ta.sma(s, l)\n        \"EMA\"  => ta.ema(s, l)\n        \"RMA\"  => ta.rma(s, l)\n        \"WMA\"  => ta.wma(s, l)\n        => s\n    out\nsmoothed = f_smooth(emaLine, smType, smLen)\ndirUp   = emaLine > smoothed\n\n/// ========== Tick-by-tick signals with per-bar lock (mirrors your indicator)\nvar bool barLock = false\nif barstate.isnew\n    barLock := false\n\nbuyRaw  = ta.crossover(emaLine, smoothed)\nsellRaw = ta.crossunder(emaLine, smoothed)\n\nbuyFireBase  = buyRaw  and not barLock and strategy.position_size == 0\nsellFireBase = sellRaw and not barLock and strategy.position_size > 0\n\n// EMA 8/21 gating\nbuyAllowed  = (not useEmaFilter) or upTrend\nsellAllowed = true\n\n// Adaptive entry\nadaptiveBuy = useEmaFilter and adaptiveOnFlip and filterFlipOn and strategy.position_size == 0 and not barLock and (emaLine > smoothed)\n\n// Final realtime fires\nbuyFire  = ((buyFireBase and buyAllowed) or adaptiveBuy)\nsellFire =  (sellFireBase and sellAllowed)\n\n// Close-only backup (ungated)\nbuyFireClose  = barstate.isconfirmed and ta.crossover(emaLine, smoothed) and strategy.position_size == 0 and buyAllowed\nsellFireClose = barstate.isconfirmed and ta.crossunder(emaLine, smoothed)  and strategy.position_size > 0\n\n// Lock for this bar when a realtime fire happens\nif buyFire or sellFire\n    barLock := true\n\n/// ========== Strategy orders\n// Entries (one position at a time)\nif (buyFire or buyFireClose) and strategy.position_size == 0\n    strategy.entry(\"LONG\", strategy.long)\n\n// Manage fixed stop-loss every tick while in position\nif strategy.position_size > 0\n    stopPrice = strategy.position_avg_price * (1.0 - slPctInp)\n    // Re-issue/refresh the exit each bar so SL tracks avg fill\n    strategy.exit(\"SL\", from_entry=\"LONG\", stop=stopPrice)\n\n// Exit on SELL signals (market close of position)\nif (sellFire or sellFireClose) and strategy.position_size > 0\n    strategy.close(\"LONG\")\n\n/// ========== Plots & labels (unchanged visuals)\npEMA = plot(emaLine,  \"EMA\",      color=color.new(color.red,   0), offset=offsetBars, linewidth=2)\npSM  = plot(smoothed, \"Smoothed\", color=color.new(color.yellow,0), offset=offsetBars, linewidth=2)\n\nplot(plotFilterEMAs ? ema8  : na, \"EMA 8 (Filter)\",  color=color.new(color.teal,  0), linewidth=1)\nplot(plotFilterEMAs ? ema21 : na, \"EMA 21 (Filter)\", color=color.new(color.orange,0), linewidth=1)\n\nif showLabels and buyFire\n    label.new(bar_index, low,  \"Enter\",  style=label.style_label_up,   textcolor=color.white, color=color.new(color.teal, 0))\nif showLabels and sellFire\n    label.new(bar_index, high, \"Exit\", style=label.style_label_down, textcolor=color.white, color=color.new(color.red,  0))\nif showLabels and buyFireClose\n    label.new(bar_index, low,  \"Enter\",  style=label.style_label_up,   textcolor=color.white, color=color.new(color.teal, 0))\nif showLabels and sellFireClose\n    label.new(bar_index, high, \"Exit\", style=label.style_label_down, textcolor=color.white, color=color.new(color.red,  0))\n\n// Directional fog\ncolFog = showFog ? (dirUp ? color.new(color.lime, fogTransp) : color.new(color.red, fogTransp)) : na\nfill(pEMA, pSM, color=colFog)\n\n// FAT DNA rungs\ntopR = math.max(emaLine, smoothed)\nbotR = math.min(emaLine, smoothed)\nrungCol = rungColorMode == \"Direction\" ? (dirUp ? color.lime : color.red) : rungFixedCol\nvar line   curRung = na\nvar line[] rungBuf = array.new_line()\nif showRungs\n    if barstate.isnew\n        curRung := line.new(bar_index, botR, bar_index, topR,\n                             xloc=xloc.bar_index, extend=extend.none,\n                             color=rungCol, width=rungWidth)\n        array.push(rungBuf, curRung)\n        if array.size(rungBuf) > maxKeep\n            line.delete(array.shift(rungBuf))\n    if not na(curRung)\n        line.set_y1(curRung, botR)\n        line.set_y2(curRung, topR)\n        line.set_width(curRung, rungWidth)\n        line.set_color(curRung, rungCol)\n"
  },
  {
    "url": "zeS9gFsg-EMA-Wick-A-Retest-Strategy",
    "name": "EMA Wick A+ Retest Strategy",
    "description": "The EMA Wick A+ Retest Strategy is a precision pullback system built for high-probability trend entries. It uses a combination of:\nEMA 21 dynamic trend filtering\nATR-based stop-loss and reward targeting (1:1.5 RR)\nWick retest logic, where the lower wick must touch the EMA and represent at least 50% of the candle's range\nOptional filter: RSI > 50 for bullish momentum confirmation\nThis strategy is designed to capture institutional-style entries after a clean pullback in an uptrend.\nâœ… Clean signals\nâœ… High risk-to-reward setups\nâœ… Built for swing trading or intraday with strong trend bias\nIdeal for Forex, Crypto, and Indices.\nUse responsibly. Backtest before live trading.",
    "image_url": "zeS9gFsg",
    "author": "khalifehkr",
    "likes": 10,
    "type": "strategy",
    "created": "2025-11-09",
    "updated": "2025-11-09",
    "source": "//@version=6\nstrategy(\"EMA Wick A+ Retest Strategy\", overlay=true, default_qty_type=strategy.percent_of_equity, default_qty_value=100)\n\n// === INPUTS ===\nemaLen      = input.int(21, \"EMA Length\")\natrLen      = input.int(21, \"ATR Length\")\nrrTarget    = input.float(1.5, \"Risk:Reward Target\", step=0.1)\nuseRSI      = input.bool(true, \"Use RSI > 50?\")\nuseAPlus    = input.bool(true, \"Use A+ Wick Retest?\")\nminWickPerc = input.int(50, \"Min Wick % of Candle\", minval=1, maxval=100)\n\n// === CORE INDICATORS ===\nema21   = ta.ema(close, emaLen)\natr     = ta.atr(atrLen)\nrsi     = ta.rsi(close, 14)\n\n// === CANDLE STRUCTURE ===\nbodySize = math.abs(close - open)\nlowerWick = math.min(open, close) - low\nwickPerc = (lowerWick / (high - low + 1e-5)) * 100\n\n// === CONDITIONS ===\nisBull = close > open\nwickTouch = low <= ema21 and close > ema21\nrsiValid = not useRSI or rsi > 50\naPlusValid = not useAPlus or (wickPerc >= minWickPerc)\n\nbuySignal = isBull and wickTouch and rsiValid and aPlusValid\n\n// === RISK CALC ===\nentry = close\nsl = entry - atr\ntp = entry + atr * rrTarget\n\n// === EXECUTION ===\nif buySignal\n    strategy.entry(\"Buy A+\", strategy.long)\n    strategy.exit(\"TP/SL\", from_entry=\"Buy A+\", stop=sl, limit=tp)\n\n// === PLOT ===\nplot(ema21, title=\"EMA 21\", color=color.orange)\nplotshape(buySignal, title=\"Buy A+\", location=location.belowbar, style=shape.labelup, color=color.green, text=\"Buy\")\n"
  },
  {
    "url": "hlAZd4Ot-ETH-Short-Term-VWAP-EMA-RSI-ATR-Risk-1h-James-Logan",
    "name": "ETH Short-Term VWAP+EMA/RSI (ATR Risk, <1h) (James Logan)",
    "description": "ETH Short-Term VWAP + EMA / RSI Strategy (ATR-based Risk Control)\n\nA short-term (< 1 hour) ETH trading system designed for intraday scalps and momentum swings on 5- to 15-minute charts.\nIt blends trend confirmation (EMA 50 / 200) with intrabar structure (EMA 21 pullback & VWAP filter) and RSI momentum triggers, managing exits dynamically through ATR-based stop, take-profit, and trailing stop targets.\n\nCore logic\n\tâ€¢\tLong when RSI crosses above the threshold within an up-trend (EMA 50 > EMA 200) and price is above VWAP.\n\tâ€¢\tShort when RSI crosses below threshold within a down-trend (EMA 50 < EMA 200) and price is below VWAP.\n\tâ€¢\tOptional pullback confirmation to the 21-EMA for cleaner entries.\n\tâ€¢\tRisk defined by ATR-multiples for stop-loss, take-profit, and an adaptive trailing stop.\n\tâ€¢\tAutomatic flat-out exit after a set number of bars (time-based close).\n\nBest use\n\tâ€¢\t5 min â€“ 15 min ETH/USDT charts (Binance, Bybit, Coinbase, etc.)\n\tâ€¢\tWorks with both spot and perpetual data.\n\tâ€¢\tTune ATR and RSI thresholds per venue; defaults are balanced for 0.05 % per-side fees.\n\nKey parameters\n\tâ€¢\tATR SL Ã— 1.6â€ƒATR TP Ã— 2.2â€ƒATR Trail Ã— 2.0\n\tâ€¢\tRSI 50 cross  |  EMA 50/200 trend filter  |  VWAP confirmation\n\tâ€¢\tDefault position sizing = USD-based (e.g. $1 000 per trade).\n\nNotes\n\tâ€¢\tAll orders and exits are simulated at bar close; use 1-minute bar magnifier for finer fill modeling.\n\tâ€¢\tNo repaintingâ€”uses only confirmed bar data.\n\tâ€¢\tBest validated with â‰¥ 200 trades and profit factor > 1.25 over multi-month backtests.",
    "image_url": "hlAZd4Ot",
    "author": "jamesbmlogan1",
    "likes": 5,
    "type": "strategy",
    "created": "2025-11-09",
    "updated": "2025-11-09",
    "source": "//@version=6\nstrategy(\"ETH Short-Term VWAP+EMA/RSI (ATR Risk, <1h)\",\n     overlay=true,\n     initial_capital=10000,\n     commission_type=strategy.commission.percent,\n     commission_value=0.05,\n     slippage=2,\n     pyramiding=0,\n     calc_on_every_tick=true,\n     calc_on_order_fills=true)\n\n//â€“â€“â€“â€“â€“ Inputs\ntfInfo           = input.string(\"15m\", \"Chart Timeframe (info)\", inline=\"tf\")\nsessionFilterOn  = input.bool(false, \"Use Trading Session Filter?\", inline=\"sess\")\ntradeSession     = input.session(\"0000-2359\", \"\", inline=\"sess\")\n\nuseFixedUSD      = input.bool(true, \"Size Using Fixed USD per Trade?\")\nusdPerTrade      = input.float(1000, \"USD per Trade\", step=50.0)\ncontractsFixed   = input.float(0.1, \"Fixed Contracts (if not using USD)\", step=0.01)\nmaxOpenBars      = input.int(36, \"Max Bars in Trade (time exit)\", minval=1)\n\natrLen           = input.int(14, \"ATR Length\")\natrSLmult        = input.float(1.6, \"Stop ATR Multiplier\", step=0.1)\natrTPmult        = input.float(2.2, \"Take-Profit ATR Multiplier\", step=0.1)\ntrailOn          = input.bool(true, \"Use ATR Trailing Stop?\")\ntrailMult        = input.float(2.0, \"ATR Trail Multiplier\", step=0.1)\n\nemaFastLen       = input.int(50, \"Trend EMA Fast\")\nemaSlowLen       = input.int(200, \"Trend EMA Slow\")\nemaPullLen       = input.int(21, \"Pullback EMA\")\nrsiLen           = input.int(14, \"RSI Length\")\nrsiLongThresh    = input.int(50, \"RSI Long Cross Above\")\nrsiShortThresh   = input.int(50, \"RSI Short Cross Below\")\n\nuseVwap          = input.bool(true, \"Require Price on Correct Side of VWAP?\")\nusePullback      = input.bool(true, \"Require Pullback to EMA21?\")\n\n//â€“â€“â€“â€“â€“ Calculations\nemaFast = ta.ema(close, emaFastLen)\nemaSlow = ta.ema(close, emaSlowLen)\nemaPull = ta.ema(close, emaPullLen)\nrsi     = ta.rsi(close, rsiLen)\natr     = ta.atr(atrLen)\nvwap    = ta.vwap(hlc3)\n\ntrendUp   = emaFast > emaSlow\ntrendDown = emaFast < emaSlow\n\nonSession = not sessionFilterOn or not na(time(timeframe.period, tradeSession))\n\nvwapOKLong  = not useVwap or close > vwap\nvwapOKShort = not useVwap or close < vwap\npullOKLong  = not usePullback or (close >= emaPull and low <= emaPull)\npullOKShort = not usePullback or (close <= emaPull and high >= emaPull)\n\nlongSignal  = onSession and trendUp   and vwapOKLong  and pullOKLong  and ta.crossover(rsi, rsiLongThresh)\nshortSignal = onSession and trendDown and vwapOKShort and pullOKShort and ta.crossunder(rsi, rsiShortThresh)\n\nqtyUSD  = math.max(usdPerTrade, 10)\nqty     = useFixedUSD ? qtyUSD / close : contractsFixed\n\nlongStop  = close - atrSLmult * atr\nlongTP    = close + atrTPmult * atr\nshortStop = close + atrSLmult * atr\nshortTP   = close - atrTPmult * atr\n\n//â€“â€“â€“â€“â€“ Time-in-trade tracking\nvar int entryBarIndex = na\n\nif strategy.position_size == 0 and (longSignal or shortSignal)\n    entryBarIndex := na\n\nif (longSignal and strategy.position_size <= 0)\n    if strategy.position_size < 0\n        strategy.close(\"Short\")\n    strategy.entry(\"Long\", strategy.long, qty=qty)\n    entryBarIndex := bar_index\n\nif (shortSignal and strategy.position_size >= 0)\n    if strategy.position_size > 0\n        strategy.close(\"Long\")\n    strategy.entry(\"Short\", strategy.short, qty=qty)\n    entryBarIndex := bar_index\n\n//â€“â€“â€“â€“â€“ Stop & TP exits\nstrategy.exit(\"L-Exit\", \"Long\",  stop=longStop,  limit=longTP)\nstrategy.exit(\"S-Exit\", \"Short\", stop=shortStop, limit=shortTP)\n\n//â€“â€“â€“â€“â€“ ATR Trailing Stop (working version)\nif trailOn\n    if strategy.position_size > 0\n        newTrailStop = close - trailMult * atr\n        if not na(strategy.position_avg_price)\n            newTrailStop := math.max(newTrailStop, longStop)  // donâ€™t trail below base stop\n        strategy.exit(\"L-Trail\", \"Long\", stop=newTrailStop)\n    if strategy.position_size < 0\n        newTrailStop = close + trailMult * atr\n        if not na(strategy.position_avg_price)\n            newTrailStop := math.min(newTrailStop, shortStop)\n        strategy.exit(\"S-Trail\", \"Short\", stop=newTrailStop)\n\n//â€“â€“â€“â€“â€“ Time-based exit\nbarsInTrade = na(entryBarIndex) ? 0 : (bar_index - entryBarIndex)\nif strategy.position_size != 0 and barsInTrade >= maxOpenBars\n    if strategy.position_size > 0\n        strategy.close(\"Long\",  comment=\"Time Exit\")\n    if strategy.position_size < 0\n        strategy.close(\"Short\", comment=\"Time Exit\")\n\n//â€“â€“â€“â€“â€“ Visuals\nplot(emaFast, \"EMA Fast\", color=color.new(color.teal, 0))\nplot(emaSlow, \"EMA Slow\", color=color.new(color.purple, 0))\nplot(emaPull, \"EMA Pullback\", color=color.new(color.orange, 0))\nplot(vwap,    \"VWAP\", color=color.new(color.blue, 0), linewidth=2)\n\nbgcolor(trendUp ? color.new(color.green, 90) : trendDown ? color.new(color.red, 90) : na)\n\nplotshape(longSignal,  title=\"Long Signal\",  style=shape.triangleup,   color=color.new(color.green, 0), location=location.belowbar, size=size.tiny, text=\"â–²L\")\nplotshape(shortSignal, title=\"Short Signal\", style=shape.triangledown, color=color.new(color.red, 0),   location=location.abovebar, size=size.tiny, text=\"â–¼S\")\n\n//â€“â€“â€“â€“â€“ Alerts\nalertcondition(longSignal,  \"ETH Long Signal\",  \"ETH LONG: TrendUp+VWAP+RSI cross @ {{close}}\")\nalertcondition(shortSignal, \"ETH Short Signal\", \"ETH SHORT: TrendDown+VWAP+RSI cross @ {{close}}\")"
  },
  {
    "url": "8FmrW7vq-Final-Scalping-Strategy-RELAXED-ENTRY-jangan-gopoh-brader",
    "name": "Final Scalping Strategy  - RELAXED ENTRY, jangan gopoh brader",
    "description": "EMA Scalping System (MTF) Guide (1HR direction, 15 min entry)\n\nObjective\n\nTo capture small, consistent profits by entering trades when 15-minute momentum aligns with the 1-hour trend.\n\nTrades are executed only during high-liquidity London and New York sessions to increase the probability of execution and success. \n\nStrategy Setup\n\n \n Chart Timeframe (Execution):  15-Minute (M15).\n Trend Filter (HTF): 1-Hour (H1) chart data is used for the long-term EMA.\n Long-Term Trend Filter: 50-Period EMA (based on H1 data).\n Short-Term Momentum Signal: 20-Period EMA (based on M15 data).\n Risk\n  Metric: 14-period ATR for dynamic Stop Loss calculation.\n\nâœ… Trading RulesðŸŸ¢\n\n Long (Buy) Entry Conditions\n\n \n Session: Must be within the London (0800-1700 GMT) or New York (1300-2200 GMT) sessions.\n HTF Trend: Current price must be above the 1-Hour EMA 50.\n Momentum Signal: Price crosses above the 15-Minute EMA 20.\n Confirmation: The bar immediately following the crossover must close above the 15-Minute EMA 20.\n Ent\n ry: A market order is executed on the close of the confirmation candle.\n\nðŸ”´ Short (Sell) Entry Conditions\n\n \n Session: Must be within the London (0800-1700 GMT) or New York (1300-2200 GMT) sessions.\n HTF Trend: Current price must be below the 1-Hour EMA 50.\n Momentum Signal: Price crosses below the 15-Minute EMA 20.\n Confirmation: The bar immediately following the crossover must close below the 15-Minute EMA 20.\n Entry: A market order is executed on the close of the confirmation candle.\n \n\nðŸ›‘ Trade Management & Exits\n\n \n Stop Loss (SL): Placed dynamically at 2.0 times the 14-period ATR distance from the entry candle's low (for Buys) or high (for Sells).\n Take Profit (TP): Placed dynamically to achieve a 1.5 Risk-Reward Ratio (RR) (TP distance = 1.5  x SL d\n istance).\n\nðŸ“Š On-Chart Visuals\n\n \n Detailed Labels: A box appears on the entry bar showing the action, SL/TP prices, Risk/Reward in Pips, and the exact R:R ratio.\n Horizontal Lines: Dashed lines display the calculated SL (Red) and TP (Green) levels while the trade is active.\n Background: The chart background is shaded to highlight the active London and New York tradi\n ng sessions.",
    "image_url": "8FmrW7vq",
    "author": "hushedDiamond97573",
    "likes": 24,
    "type": "strategy",
    "created": "2025-11-09",
    "updated": "2025-11-09",
    "source": "//@version=5\nstrategy(\"Final Scalping Strategy (v5) - RELAXED ENTRY\", overlay=true, \n     default_qty_type=strategy.percent_of_equity, default_qty_value=2, \n     initial_capital=10000, \n     commission_type=strategy.commission.percent, commission_value=0.01)\n\n// --- 1. Inputs ---\nhtf_tf = input.string(\"60\", \"Higher Timeframe (Trend/HTF)\", group=\"Timeframes\") \nltf_tf = input.string(\"15\", \"Lower Timeframe (Signal/LTF)\", group=\"Timeframes\") \nlondon_session = input.session(\"0800-1700:12345\", \"London Session (GMT)\", group=\"Session Filter\")\nny_session = input.session(\"1300-2200:12345\", \"New York Session (GMT)\", group=\"Session Filter\")\n\natr_multiplier = input.float(2.0, \"ATR Stop Multiplier (SL distance)\", step=0.1, group=\"Risk Management\")\nrr_ratio = input.float(1.5, \"Risk-Reward Ratio (TP distance)\", step=0.1, group=\"Risk Management\")\n\nema_length_htf = input.int(50, \"HTF EMA Length\", group=\"Indicators\") \nema_length_ltf = input.int(20, \"LTF EMA Length\", group=\"Indicators\") \n\nf_pips(price_diff) =>\n    math.round(price_diff / syminfo.mintick / 10 * 100) / 100 \n\n// --- 2. Indicators & Calculations ---\nhtf_ema = request.security(syminfo.tickerid, htf_tf, ta.ema(close, ema_length_htf))\ntrend_bullish = close > htf_ema[1]\ntrend_bearish = close < htf_ema[1]\n\nltf_ema = ta.ema(close, ema_length_ltf)\n\natr_value = ta.atr(14) \natr_stop_dist = atr_value * atr_multiplier \n\nin_london = time(timeframe.period, london_session) != 0\nin_ny = time(timeframe.period, ny_session) != 0\nin_session = in_london or in_ny\n\n// --- 3. Entry Conditions (RELAXED - NO CANDLE CONFIRMATION) ---\nlong_signal = ta.crossover(close, ltf_ema)\n// Entry only requires EMA cross + HTF trend alignment + session\nlongCondition = long_signal and trend_bullish and in_session \n\nshort_signal = ta.crossunder(close, ltf_ema)\n// Entry only requires EMA cross + HTF trend alignment + session\nshortCondition = short_signal and trend_bearish and in_session \n\n// --- 4. Trade Execution and Label Data Storage ---\nvar float last_sl_price = na\nvar float last_tp_price = na\nvar float last_risk_pips = na\nvar float last_reward_pips = na\nvar float last_rr_ratio = na\nvar string last_action = \"\"\n\nif longCondition and strategy.position_size == 0 \n    long_sl_price = low - atr_stop_dist \n    long_risk_dist = close - long_sl_price\n    long_tp_price = close + (long_risk_dist * rr_ratio) \n    \n    last_sl_price := long_sl_price\n    last_tp_price := long_tp_price\n    last_risk_pips := f_pips(long_risk_dist)\n    last_reward_pips := f_pips(long_tp_price - close)\n    last_rr_ratio := last_reward_pips / last_risk_pips\n    last_action := \"BUY\"\n\n    strategy.entry(\"Long\", strategy.long)\n    strategy.exit(\"Long Exit\", \"Long\", stop=long_sl_price, limit=long_tp_price)\n\nif shortCondition and strategy.position_size == 0 \n    short_sl_price = high + atr_stop_dist \n    short_risk_dist = short_sl_price - close\n    short_tp_price = close - (short_risk_dist * rr_ratio) \n    \n    last_sl_price := short_sl_price\n    last_tp_price := short_tp_price\n    last_risk_pips := f_pips(short_risk_dist)\n    last_reward_pips := f_pips(close - short_tp_price)\n    last_rr_ratio := last_reward_pips / last_risk_pips\n    last_action := \"SHORT\"\n    \n    strategy.entry(\"Short\", strategy.short)\n    strategy.exit(\"Short Exit\", \"Short\", stop=short_sl_price, limit=short_tp_price)\n\n\n// --- 5. On-Chart Visuals ---\n\n// Plot 1: SL and TP Price Lines \nplot(strategy.position_size > 0 ? last_sl_price : na, title=\"Long SL\", color=color.red, linewidth=2, style=plot.style_linebr)\nplot(strategy.position_size > 0 ? last_tp_price : na, title=\"Long TP\", color=color.lime, linewidth=2, style=plot.style_linebr)\nplot(strategy.position_size < 0 ? last_sl_price : na, title=\"Short SL\", color=color.red, linewidth=2, style=plot.style_linebr)\nplot(strategy.position_size < 0 ? last_tp_price : na, title=\"Short TP\", color=color.lime, linewidth=2, style=plot.style_linebr)\n\n// Plot 2: Entry/Exit Shapes (Triangles)\nplotshape(longCondition, title=\"Long Entry\", location=location.belowbar, style=shape.triangleup, color=color.green, size=size.small)\nplotshape(shortCondition, title=\"Short Entry\", location=location.abovebar, style=shape.triangledown, color=color.red, size=size.small)\n\n// Plot 3: Detailed Trade Label \nif (longCondition or shortCondition) and strategy.position_size != strategy.position_size[1]\n    \n    y_position = last_action == \"BUY\" ? low - atr_stop_dist : high + atr_stop_dist\n    y_location = last_action == \"BUY\" ? yloc.belowbar : yloc.abovebar\n    label_style = last_action == \"BUY\" ? label.style_label_up : label.style_label_down\n\n    label_text = last_action + \n                 \"\\nSL: \" + str.tostring(last_sl_price, format.mintick) + \n                 \"\\nTP: \" + str.tostring(last_tp_price, format.mintick) + \n                 \"\\nRisk: \" + str.tostring(last_risk_pips, \"#.##\") + \" pips\" + \n                 \"\\nReward: \" + str.tostring(last_reward_pips, \"#.##\") + \" pips\" +\n                 \"\\nR:R = 1:\" + str.tostring(last_rr_ratio, \"#.##\")\n\n    label.new(x=bar_index, y=y_position, \n              text=label_text, \n              xloc=xloc.bar_index, \n              yloc=y_location, \n              color=last_action == \"BUY\" ? color.green : color.red, \n              textcolor=color.white,\n              style=label_style,\n              size=size.small)\n\n// Plot 4: EMAs and Backgrounds\nplot(htf_ema, color=color.blue, title=\"HTF EMA 50\", linewidth=2)\nplot(ltf_ema, color=color.orange, title=\"LTF EMA 20\")\n\nbgcolor(in_london ? color.new(#FFC300, 85) : na, title=\"London Session Background\")\nbgcolor(in_ny ? color.new(#4A235A, 85) : na, title=\"NY Session Background\")"
  },
  {
    "url": "uWpjvpRA-XAutoTrade-Alert-Builder-v1-1",
    "name": "XAutoTrade Alert Builder v1.1",
    "description": "Automate Your NinjaTrader Trading with TradingView Alerts\n\nThe XAutoTrade Alert Builder is a flexible Pine Script strategy that bridges TradingView alerts with\nNinjaTrader automated trading. Design custom entry signals, configure exit strategies, and execute trades\nautomatically on your NinjaTrader account - all from TradingView charts.\n\nKey Features\n\nðŸ“Š Flexible Signal Logic\n- Configure buy/sell signals independently\n- Compare any two indicators or price sources using crossover, crossunder, greater than, or less than\nlogic\n- Visual buy/sell markers on chart for easy signal verification\n\nðŸŽ¯ Multiple Exit Methods\n1. ATM Strategy - Leverage your existing NinjaTrader ATM templates for advanced order management\n2. Source Signals - Exit positions based on opposite entry signals\n3. Fixed Levels - Set stop loss and profit targets using ticks or percentage\n\nâš™ï¸ NinjaTrader Integration\n- Direct webhook integration with XAutoTrade backend service\n- Multi-account support (trade multiple accounts simultaneously)\n- Position sizing and max position limits\n- Market or limit order types with configurable offset\n- Time-in-force options (DAY/GTC)\n- Active hours filter (US ET timezone) to control when alerts execute\n\nðŸ” Secure & Reliable\n- Webhook secret authentication\n- Symbol override capability\n- Real-time status indicator showing configuration readiness\n\nHow It Works\n\n1. Configure Entry Signals - Choose your buy/sell logic by comparing any two data sources (price,\nindicators, etc.)\n2. Set Exit Strategy - Select ATM templates, signal-based exits, or fixed stop/profit levels\n3. Connect to NinjaTrader - Enter your XAutoTrade webhook secret and account details\n4. Create Alert - Use the strategy's alert system to send formatted JSON payloads to your XAutoTrade\nwebhook\n5. Trade Futures & Stocks Automatically - TradingView alerts trigger real trades in your NinjaTrader account\n\nPerfect For\n\n- Traders wanting to automate TradingView strategies in NinjaTrader\n- Users with existing ATM templates who want TradingView signal automation\n- Multi-account traders managing several NinjaTrader accounts\n- Anyone seeking a no-code bridge between TradingView and NinjaTrader\n\nRequirements\n\n- Active XAutoTrade account and subscription\n- NinjaTrader 8 with XAutoTrade AddOn installed\n- TradingView Premium/Pro account (for webhook alerts)",
    "image_url": "uWpjvpRA",
    "author": "ivytony",
    "likes": 14,
    "type": "strategy",
    "created": "2025-11-09",
    "updated": "2025-11-09",
    "source": "// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// Â© XAutoTrade\r\n// Version: 1.1 - Fixed placeholder values for symbol, price, and timestamp\r\n// Documentation: https://www.xautotrade.com/docs/api-reference/order-actions\r\n\r\n//@version=6\r\nstrategy(\"XAutoTrade Alert Builder\", shorttitle=\"XAutoTrade Alert\", overlay=true, initial_capital=10000, default_qty_type=strategy.fixed, default_qty_value=1)\r\n\r\n// Signal Configuration\r\nenableBuySignals = input.bool(true, \"Enable Buy Signals\", group=\"Signal Logic\", tooltip=\"Enable to generate buy/long entry signals\")\r\nenableSellSignals = input.bool(false, \"Enable Sell Signals\", group=\"Signal Logic\", tooltip=\"Enable to generate sell/short entry signals\")\r\nsignalLogic = input.string(\"Single\", \"Signal Logic\", options=[\"Single\"], group=\"Signal Logic\", tooltip=\"Compare two signal sources using one logic condition\")\r\nbuySignalSource1 = input.source(close, \"Buy Signal Source 1\", group=\"Signal Logic\", tooltip=\"Primary signal source for buy logic (only used when 'Enable Buy Signals' is checked)\")\r\nbuySignalSource2 = input.source(close, \"Buy Signal Source 2\", group=\"Signal Logic\", tooltip=\"Secondary signal source for buy logic (only used when 'Enable Buy Signals' is checked)\")\r\nsellSignalSource1 = input.source(close, \"Sell Signal Source 1\", group=\"Signal Logic\", tooltip=\"Primary signal source for sell logic (only used when 'Enable Sell Signals' is checked)\")\r\nsellSignalSource2 = input.source(close, \"Sell Signal Source 2\", group=\"Signal Logic\", tooltip=\"Secondary signal source for sell logic (only used when 'Enable Sell Signals' is checked)\")\r\nbuyLogicType = input.string(\"Crossover\", \"Buy Logic\", options=[\"Crossover\", \"Crossunder\", \"Greater Than\", \"Less Than\"], group=\"Signal Logic\", tooltip=\"Comparison logic: Crossover (Source1 crosses above Source2), Crossunder, Greater Than, or Less Than\")\r\nsellLogicType = input.string(\"Crossunder\", \"Sell Logic\", options=[\"Crossover\", \"Crossunder\", \"Greater Than\", \"Less Than\"], group=\"Signal Logic\", tooltip=\"Comparison logic: Crossover, Crossunder (Source1 crosses below Source2), Greater Than, or Less Than\")\r\n\r\n// Exit Configuration\r\nexitMethod = input.string(\"ATM Strategy\", \"Exit Method\", options=[\"ATM Strategy\", \"Source Signals\", \"Fixed Levels\"], group=\"Exit Configuration\", tooltip=\"Choose how positions will exit: ATM Strategy (use NinjaTrader ATM templates), Source Signals (exit based on opposite signals), or Fixed Levels (set stop loss and profit targets)\")\r\n\r\n// ATM Strategy fields\r\natmStrategyName = input.string(\"\", \"ATM Strategy Name\", group=\"Exit Configuration - ATM Strategy\", tooltip=\"Must match your NinjaTrader ATM template name exactly. Used when Exit Method = 'ATM Strategy'\")\r\n\r\n// Source Signals fields\r\nbuyExitSource = input.source(close, \"Buy Exit Source\", group=\"Exit Configuration - Source Signals\", tooltip=\"Signal source for exiting long positions. Used when Exit Method = 'Source Signals'\")\r\nsellExitSource = input.source(close, \"Sell Exit Source\", group=\"Exit Configuration - Source Signals\", tooltip=\"Signal source for exiting short positions. Used when Exit Method = 'Source Signals'\")\r\n\r\n// Fixed Levels fields\r\nexitLevelType = input.string(\"Ticks\", \"Exit Level Type\", options=[\"Ticks\", \"Percentage\"], group=\"Exit Configuration - Fixed Levels\", tooltip=\"Choose whether to specify stop loss and take profit using ticks or percentage. Only the selected type will be used. Used when Exit Method = 'Fixed Levels'\")\r\nstopLossTicks = input.int(10, \"Stop Loss (Ticks)\", group=\"Exit Configuration - Fixed Levels\", tooltip=\"Distance in ticks from entry price for stop loss. Used when Exit Level Type = 'Ticks'\")\r\ntakeProfitTicks = input.int(20, \"Take Profit (Ticks)\", group=\"Exit Configuration - Fixed Levels\", tooltip=\"Distance in ticks from entry price for profit target. Used when Exit Level Type = 'Ticks'\")\r\nstopLossPercent = input.float(1.0, \"Stop Loss (%)\", step=0.1, group=\"Exit Configuration - Fixed Levels\", tooltip=\"Percentage from entry price for stop loss. Used when Exit Level Type = 'Percentage'\")\r\ntakeProfitPercent = input.float(2.0, \"Take Profit (%)\", step=0.1, group=\"Exit Configuration - Fixed Levels\", tooltip=\"Percentage from entry price for profit target. Used when Exit Level Type = 'Percentage'\")\r\n\r\n// XAutoTrade Settings\r\nsymbolOverride = input.string(\"\", \"Symbol\", group=\"XAutoTrade Settings\")\r\nquantity = input.int(1, \"Quantity\", minval=1, group=\"XAutoTrade Settings\")\r\nmaxPositions = input.int(2, \"Max Positions\", minval=1, group=\"XAutoTrade Settings\", tooltip=\"Maximum positions allowed to open at the same time\")\r\naccountNames = input.string(\"Sim101\", \"Account Names\", group=\"XAutoTrade Settings\", tooltip=\"Separate accounts with comma(,). Example: Sim101,Sim102\")\r\nwebhookSecret = input.string(\"\", \"Webhook Secret\", group=\"XAutoTrade Settings\", tooltip=\"Secret for your personal XAutoTrade webhook\")\r\norderType = input.string(\"Market\", \"Order Type\", options=[\"Market\", \"Limit\"], group=\"XAutoTrade Settings\")\r\nlimitOffsetTicks = input.int(0, \"Limit Offset Ticks\", group=\"XAutoTrade Settings\", tooltip=\"Number of ticks required for placing limit fill price\")\r\ntimeInForce = input.string(\"DAY\", \"Time In Force\", options=[\"DAY\", \"GTC\"], group=\"XAutoTrade Settings\")\r\nactiveHours = input.string(\"\", \"Active Hours (US ET)\", group=\"XAutoTrade Settings\", tooltip=\"Time range when alerts are accepted (HH:MM:SS-HH:MM:SS). Leave empty for 24/7. Example: 09:30:00-16:00:00\")\r\n\r\n// Calculate Signals\r\nvar bool buySignal = false\r\nvar bool sellSignal = false\r\n\r\nif signalLogic == \"Single\"\r\n    if buyLogicType == \"Crossover\"\r\n        buySignal := ta.crossover(buySignalSource1, buySignalSource2)\r\n    else if buyLogicType == \"Crossunder\"\r\n        buySignal := ta.crossunder(buySignalSource1, buySignalSource2)\r\n    else if buyLogicType == \"Greater Than\"\r\n        buySignal := buySignalSource1 > buySignalSource2\r\n    else\r\n        buySignal := buySignalSource1 < buySignalSource2\r\n\r\n    if sellLogicType == \"Crossover\"\r\n        sellSignal := ta.crossover(sellSignalSource1, sellSignalSource2)\r\n    else if sellLogicType == \"Crossunder\"\r\n        sellSignal := ta.crossunder(sellSignalSource1, sellSignalSource2)\r\n    else if sellLogicType == \"Greater Than\"\r\n        sellSignal := sellSignalSource1 > sellSignalSource2\r\n    else\r\n        sellSignal := sellSignalSource1 < sellSignalSource2\r\n\r\nbuyEntry = buySignal and enableBuySignals\r\nsellEntry = sellSignal and enableSellSignals\r\n\r\n// Strategy Execution\r\nif buyEntry\r\n    if exitMethod == \"Fixed Levels\"\r\n        // Calculate exit prices at entry\r\n        usePercentage = exitLevelType == \"Percentage\"\r\n        stopDistance = usePercentage ? close * (stopLossPercent/100) : stopLossTicks * syminfo.mintick\r\n        targetDistance = usePercentage ? close * (takeProfitPercent/100) : takeProfitTicks * syminfo.mintick\r\n\r\n        longStopPrice = close - stopDistance\r\n        longTargetPrice = close + targetDistance\r\n\r\n        strategy.entry(\"Long\", strategy.long, qty=quantity)\r\n        strategy.exit(\"Exit Long\", \"Long\", limit=longTargetPrice, stop=longStopPrice)\r\n    else\r\n        strategy.entry(\"Long\", strategy.long, qty=quantity)\r\n\r\nif sellEntry\r\n    if exitMethod == \"Fixed Levels\"\r\n        // Calculate exit prices at entry\r\n        usePercentage = exitLevelType == \"Percentage\"\r\n        stopDistance = usePercentage ? close * (stopLossPercent/100) : stopLossTicks * syminfo.mintick\r\n        targetDistance = usePercentage ? close * (takeProfitPercent/100) : takeProfitTicks * syminfo.mintick\r\n\r\n        shortStopPrice = close + stopDistance\r\n        shortTargetPrice = close - targetDistance\r\n\r\n        strategy.entry(\"Short\", strategy.short, qty=quantity)\r\n        strategy.exit(\"Exit Short\", \"Short\", limit=shortTargetPrice, stop=shortStopPrice)\r\n    else\r\n        strategy.entry(\"Short\", strategy.short, qty=quantity)\r\n\r\n// Source Signals exits\r\nif exitMethod == \"Source Signals\"\r\n    if sellEntry\r\n        strategy.close(\"Long\")\r\n    if buyEntry\r\n        strategy.close(\"Short\")\r\n\r\n// Generate Payload Function\r\ngeneratePayload(action, isLong) =>\r\n    sym = symbolOverride != \"\" ? symbolOverride : str.tostring(syminfo.ticker)\r\n    currentPrice = str.tostring(close)\r\n    alertTime = str.format(\"{0,date,yyyy-MM-dd} {0,time,HH:mm:ss}\", timenow)\r\n\r\n    var string payload = \"\"\r\n    payload := '{\\n  \"symbol\": \"' + sym + '\",\\n  \"action\": \"' + action + '\",\\n  \"price\": ' + currentPrice + ',\\n  \"quantity\": ' + str.tostring(quantity) + ',\\n  \"max_positions\": ' + str.tostring(maxPositions) + ',\\n  \"account_names\": \"' + accountNames + '\",\\n  \"alert_time\": \"' + alertTime + '\"'\r\n\r\n    if webhookSecret != \"\"\r\n        payload := payload + ',\\n  \"hook_secret\": \"' + webhookSecret + '\"'\r\n\r\n    if exitMethod == \"ATM Strategy\"\r\n        if atmStrategyName != \"\"\r\n            payload := payload + ',\\n  \"use_atm\": true,\\n  \"atm_strategy\": \"' + atmStrategyName + '\"'\r\n        else\r\n            // If ATM Strategy is selected but no name provided, set use_atm to false\r\n            payload := payload + ',\\n  \"use_atm\": false'\r\n    else if exitMethod == \"Source Signals\"\r\n        // Explicitly set use_atm to false for Source Signals, even if ATM Strategy Name is configured\r\n        payload := payload + ',\\n  \"use_atm\": false'\r\n    else if exitMethod == \"Fixed Levels\"\r\n        // Explicitly set use_atm to false for Fixed Levels, even if ATM Strategy Name is configured\r\n        payload := payload + ',\\n  \"use_atm\": false,\\n  \"enable_oco\": true'\r\n\r\n        var float stopDistance = 0.0\r\n        var float targetDistance = 0.0\r\n\r\n        if exitLevelType == \"Percentage\"\r\n            // For percentage, calculate the point distance from entry price\r\n            // stop_loss/profit_target = entry_price * (percent / 100)\r\n            stopDistance := close * (stopLossPercent / 100)\r\n            targetDistance := close * (takeProfitPercent / 100)\r\n        else\r\n            // For ticks, convert to points (point distance from entry)\r\n            stopDistance := stopLossTicks * syminfo.mintick\r\n            targetDistance := takeProfitTicks * syminfo.mintick\r\n\r\n        payload := payload + ',\\n  \"stop_loss\": ' + str.tostring(stopDistance) + ',\\n  \"profit_target\": ' + str.tostring(targetDistance)\r\n\r\n    if orderType == \"Limit\" and limitOffsetTicks > 0\r\n        offset = limitOffsetTicks * syminfo.mintick\r\n        limitPrice = isLong ? close - offset : close + offset\r\n        payload := payload + ',\\n  \"limit_price\": ' + str.tostring(limitPrice)\r\n\r\n    // Always include time_in_force\r\n    payload := payload + ',\\n  \"time_in_force\": \"' + timeInForce + '\"'\r\n\r\n    // Always include active_hours_us_et, default to 24/7 if empty\r\n    activeHoursValue = activeHours != \"\" ? activeHours : \"00:00:00-23:59:59\"\r\n    payload := payload + ',\\n  \"active_hours_us_et\": \"' + activeHoursValue + '\"'\r\n\r\n    payload + '\\n}'\r\n\r\n// Generate Payloads\r\nbuyAction = orderType == \"Market\" ? \"BUYMARKET\" : \"BUYLIMIT\"\r\nsellAction = orderType == \"Market\" ? \"SELLSHORTMARKET\" : \"SELLSHORTLIMIT\"\r\nbuyPayload = generatePayload(buyAction, true)\r\nsellPayload = generatePayload(sellAction, false)\r\n\r\n// Alerts\r\nif buyEntry\r\n    alert(buyPayload, alert.freq_once_per_bar_close)\r\nif sellEntry\r\n    alert(sellPayload, alert.freq_once_per_bar_close)\r\n\r\n// Visual Display\r\nplotshape(buyEntry, \"Long\", shape.triangleup, location.belowbar, color.new(color.green, 0), size=size.small, text=\"BUY\")\r\nplotshape(sellEntry, \"Short\", shape.triangledown, location.abovebar, color.new(color.red, 0), size=size.small, text=\"SELL\")\r\n\r\n// Info Table\r\nvar table info = table.new(position.bottom_right, 2, 5, bgcolor=color.new(color.black, 85), frame_width=1, frame_color=color.new(color.gray, 50), border_width=1)\r\n\r\nif barstate.islast\r\n    table.cell(info, 0, 0, \"XAutoTrade\", bgcolor=color.new(color.teal, 70), text_color=color.white, text_size=size.small)\r\n    table.cell(info, 1, 0, \"Alert Builder\", bgcolor=color.new(color.teal, 70), text_color=color.white, text_size=size.small)\r\n    table.cell(info, 0, 1, \"Signals:\", text_color=color.white, text_size=size.tiny)\r\n    signalText = (enableBuySignals ? \"BUY \" : \"\") + (enableSellSignals ? \"SELL\" : \"\")\r\n    table.cell(info, 1, 1, signalText, text_color=color.yellow, text_size=size.tiny)\r\n    table.cell(info, 0, 2, \"Exit:\", text_color=color.white, text_size=size.tiny)\r\n    exitText = exitMethod == \"ATM Strategy\" ? atmStrategyName : exitMethod\r\n    table.cell(info, 1, 2, exitText, text_color=color.white, text_size=size.tiny)\r\n    table.cell(info, 0, 3, \"Account:\", text_color=color.white, text_size=size.tiny)\r\n    table.cell(info, 1, 3, accountNames, text_color=color.white, text_size=size.tiny)\r\n    table.cell(info, 0, 4, \"Status:\", text_color=color.white, text_size=size.tiny)\r\n    statusText = webhookSecret != \"\" ? \"âœ“ Ready\" : \"âš  Setup\"\r\n    statusColor = webhookSecret != \"\" ? color.green : color.orange\r\n    table.cell(info, 1, 4, statusText, text_color=statusColor, text_size=size.tiny)\r\n"
  },
  {
    "url": "D2UwK8lK-NEXT-GEN-INSPIRED-BY-OLIVER-VELEZ",
    "name": "NEXT GEN INSPIRED BY OLIVER VELEZ",
    "description": "DYOR NFA\n\n\n1. Initial Setup & Application\nLoad the Strategy to your desired chart (e.g., EURUSD M5, as suggested by the script's backtest).\n\nOverlay: Ensure the script is set to overlay=true (which it is) so the signals and Moving Averages plot directly on the price chart.\n\nEquity Management: Review the initial strategy settings for capital and position sizing:\n\nInitial Capital: Defaults to 10,000.\n\nDefault Qty Type: Set to strategy.percent_of_equity (22%), meaning 22% of your available equity is used per trade. Adjust this percentage based on your personal risk tolerance.\n\n2. Reviewing Key Indicator Inputs\nThe script uses default values that are optimized, but you can adjust them in the settings panel:\n\nFast EMA: Defaults to 9 (e.g., a 9-period Exponential Moving Average).\n\nSlow EMA: Defaults to 21 (e.g., a 21-period Exponential Moving Average). These EMAs define the short-term trend.\n\nATR: Defaults to 14 (Average True Range). Used to dynamically calculate volatility for SL/TP distances.\n\nFinal R:R: Defaults to 4.5 (minimum R:R required for a signal). This is the core of the strategy's high reward goal.\n\n3. Interpreting Entry Signals\nA trade signal is generated only when all conditionsâ€”EMA trend, \"Elephant Logic\" momentum, and non-ranging marketâ€”are met.\n\nLong Signal: Appears as a green triangle (â–²) below the bar, labeled \"COMBO\".\n\nShort Signal: Appears as a red triangle (â–¼) above the bar, labeled \"COMBO\".\n\nLive Plan: Upon signal, a detailed label is immediately plotted on the chart showing the FULL BATTLE PLAN:\n\nSL: Calculated Stop Loss price.\n\nTP: Calculated Take Profit price (based on the Final R:R).\n\nRisk/Reward Pips: The calculated pips for the trade's risk and reward.\n\nR:R = 1:4.5: The exact Risk-to-Reward ratio.\n\n4. Understanding Market Conditions & Visuals\nThe script provides visuals to help you understand the current market state:\n\nTrend EMAs: The 9 EMA (green) and 21 EMA (purple/magenta) are plotted to show the underlying trend.\n\nLong trades only fire when Price > 9 EMA > 21 EMA.\n\nShort trades only fire when Price < 9 EMA < 21 EMA.\n\nRanging Market (Rejection): Bars turn a light gray/silver when the proprietary \"Reject Ranging\" logic is active, indicating a low-volatility period. No new trades will be taken during these bars.\n\nMomentum Bar: Bars turn a gold/yellow color when the \"Elephant Logic\" (high-momentum, large-body candles over 2-3 periods) is detected, highlighting powerful price movement.\n\n5. Execution and Exit Logic\nThe strategy handles entry, scaling, and exit automatically:\n\nEntry: A market order is placed (strategy.entry) immediately upon the bar where the longSetup or shortSetup condition is met.\n\nScaling Out (+1R): If the trade moves favorably by an amount equal to the initial risk (1R), the script closes a portion of the position (strategy.close with comment \"+1R\"). This partial exit locks in profit equivalent to the initial risk.\n\nRe-entry (Pyramiding): After the +1R exit, the strategy attempts a re-entry (LONG RE/SHORT RE diamond plot) if the price meets certain criteria near the 9 EMA, trying to capitalize on further trend continuation.\n\nFinal Exits:\n\nTake Profit: A limit order is set at the calculated TP level (stopDist * minRR).\n\nStop Loss: A stop order is set at the calculated SL level (stopDist * 1.3), slightly wider than the initial SL distance, likely to account for spread/slippage, ensuring the maximum loss is defined.\n\nTrailing Stop: A trailing stop is applied to the re-entry positions (LONG RE/SHORT RE) to protect profits as the market moves further in the direction of the trade.\n",
    "image_url": "D2UwK8lK",
    "author": "hushedDiamond97573",
    "likes": 21,
    "type": "strategy",
    "created": "2025-11-09",
    "updated": "2025-11-09",
    "source": "//@version=6\r\nstrategy(\"VELEZ 2025 - SL + TP + R:R LIVE PREDICTION vGOD\", overlay=true,\r\n     initial_capital=10000,\r\n     default_qty_type=strategy.percent_of_equity,\r\n     default_qty_value=22,\r\n     commission_type=strategy.commission.percent,\r\n     commission_value=0.006,\r\n     pyramiding=15)\r\n\r\n// INPUTS\r\nfastEMA = input.int(9,  \"Fast EMA\")\r\nslowEMA = input.int(21, \"Slow EMA\")\r\natrLen  = input.int(14, \"ATR\")\r\nminRR   = input.float(4.5, \"Final R:R\", minval=3.0)\r\n\r\n// INDICATORS\r\ne9  = ta.ema(close, fastEMA)\r\ne21 = ta.ema(close, slowEMA)\r\natr = ta.atr(atrLen)\r\n\r\n// REJECT RANGING\r\navgRange = ta.sma(high - low, 25)\r\nisRanging = (high - low) < avgRange * 0.4\r\n\r\n// COMBINED ELEPHANT LOGIC\r\nbody = math.abs(close - open)\r\ncandleRange = high - low\r\n\r\nbullMomentum3 = close > open and close[1] > open[1] and close[2] > open[2]\r\nbearMomentum3 = close < open and close[1] < open[1] and close[2] < open[2]\r\nbullMomentum2 = close > open and close[1] > open[1]\r\nbearMomentum2 = close < open and close[1] < open[1]\r\n\r\ncombinedRange2 = candleRange + candleRange[1]\r\ncombinedRange3 = combinedRange2 + candleRange[2]\r\ncombinedBody2 = body + body[1]\r\ncombinedBody3 = combinedBody2 + body[2]\r\n\r\nmonsterSize = atr * 2.1\r\n\r\nbullCombined = (bullMomentum3 and combinedRange3 >= monsterSize and combinedBody3 > combinedRange3 * 0.6) or \r\n               (bullMomentum2 and combinedRange2 >= monsterSize * 1.1 and combinedBody2 > combinedRange2 * 0.65)\r\n\r\nbearCombined = (bearMomentum3 and combinedRange3 >= monsterSize and combinedBody3 > combinedRange3 * 0.6) or \r\n               (bearMomentum2 and combinedRange2 >= monsterSize * 1.1 and combinedBody2 > combinedRange2 * 0.65)\r\n\r\nbullFinal = bullCombined and close > e9 and e9 > e21 and close > close[2]\r\nbearFinal = bearCombined and close < e9 and e9 < e21 and close < close[2]\r\n\r\ntrendOK = e9 > e21 ? close > e9 : close < e9\r\nnoRange = not isRanging\r\n\r\nlongSetup  = bullFinal and trendOK and noRange\r\nshortSetup = bearFinal and trendOK and noRange\r\n\r\n// DYNAMIC STOP & TARGET\r\nstopDist = atr * 1.2\r\nlongSL  = low - stopDist\r\nshortSL = high + stopDist\r\nlongTP  = close + stopDist * minRR\r\nshortTP = close - stopDist * minRR\r\n\r\n// PIP CALCULATIONS (5-digit broker)\r\npipRiskLong  = (close - longSL)  / syminfo.mintick / 10\r\npipRiskShort = (shortSL - close) / syminfo.mintick / 10\r\npipRewardLong  = (longTP - close)  / syminfo.mintick / 10\r\npipRewardShort = (close - shortTP) / syminfo.mintick / 10\r\n\r\n// LIVE LABEL WITH SL + TP + R:R + PIPS\r\nif longSetup\r\n    strategy.entry(\"COMBO LONG\", strategy.long)\r\n    label.new(bar_index, low - stopDist*0.8,\r\n              text=\"LONG\\n\" +\r\n                   \"SL: \" + str.tostring(longSL, \"#.#####\") + \"\\n\" +\r\n                   \"TP: \" + str.tostring(longTP, \"#.#####\") + \"\\n\" +\r\n                   \"Risk: \" + str.tostring(pipRiskLong, \"#.#\") + \" pips\\n\" +\r\n                   \"Reward: \" + str.tostring(pipRewardLong, \"#.#\") + \" pips\\n\" +\r\n                   \"R:R = 1:\" + str.tostring(minRR, \"#.#\"),\r\n              style=label.style_label_up, color=#00FF00, textcolor=#000000, size=size.normal, yloc=yloc.belowbar)\r\n\r\nif shortSetup\r\n    strategy.entry(\"COMBO SHORT\", strategy.short)\r\n    label.new(bar_index, high + stopDist*0.8,\r\n              text=\"SHORT\\n\" +\r\n                   \"SL: \" + str.tostring(shortSL, \"#.#####\") + \"\\n\" +\r\n                   \"TP: \" + str.tostring(shortTP, \"#.#####\") + \"\\n\" +\r\n                   \"Risk: \" + str.tostring(pipRiskShort, \"#.#\") + \" pips\\n\" +\r\n                   \"Reward: \" + str.tostring(pipRewardShort, \"#.#\") + \" pips\\n\" +\r\n                   \"R:R = 1:\" + str.tostring(minRR, \"#.#\"),\r\n              style=label.style_label_down, color=#FF0000, textcolor=#FFFFFF, size=size.normal, yloc=yloc.abovebar)\r\n\r\n// PYRAMID + MINI EXIT\r\nif strategy.position_size > 0 and close >= strategy.position_avg_price + stopDist\r\n    strategy.close(\"COMBO LONG\", comment=\"+1R\")\r\n    if close <= e9 * 1.002\r\n        strategy.entry(\"LONG RE\", strategy.long)\r\n\r\nif strategy.position_size < 0 and close <= strategy.position_avg_price - stopDist\r\n    strategy.close(\"COMBO SHORT\", comment=\"+1R\")\r\n    if close >= e9 * 0.998\r\n        strategy.entry(\"SHORT RE\", strategy.short)\r\n\r\n// FINAL EXITS\r\nstrategy.exit(\"FINAL L\", from_entry=\"COMBO LONG\", limit=strategy.position_avg_price + stopDist*minRR, stop=strategy.position_avg_price - stopDist*1.3)\r\nstrategy.exit(\"FINAL S\", from_entry=\"COMBO SHORT\", limit=strategy.position_avg_price - stopDist*minRR, stop=strategy.position_avg_price + stopDist*1.3)\r\n\r\n// TRAILING\r\ntrailOffset = stopDist * 0.55\r\ntrailPrice = strategy.position_size > 0 ? close - trailOffset : close + trailOffset\r\nstrategy.exit(\"TRAIL\", from_entry=\"LONG RE\",  stop=trailPrice)\r\nstrategy.exit(\"TRAIL\", from_entry=\"SHORT RE\", stop=trailPrice)\r\n\r\n// VISUALS\r\nplot(e9,  color=#00FF00, linewidth=3)\r\nplot(e21, color=#FF00FF, linewidth=3)\r\nbarcolor(isRanging ? color.new(#808080, 85) : na)\r\nbarcolor(bullCombined or bearCombined ? #FFD700 : na)\r\n\r\nplotshape(longSetup,  location=location.belowbar, color=#00FF00, style=shape.triangleup,   size=size.large,   text=\"COMBO\")\r\nplotshape(shortSetup, location=location.abovebar, color=#FF0000, style=shape.triangledown, size=size.large,   text=\"COMBO\")\r\n\r\n// RE-ENTRY\r\nplotshape(strategy.position_size > strategy.position_size[1] and strategy.position_size > 0, location=location.belowbar, color=#00FFFF, style=shape.diamond, size=size.small, text=\"+\")\r\nplotshape(strategy.position_size < strategy.position_size[1] and strategy.position_size < 0, location=location.abovebar, color=#FF00FF, style=shape.diamond, size=size.small, text=\"+\")\r\n\r\n// ALERTS\r\nalertcondition(longSetup,  \"COMBO LONG\",  \"VELEZ COMBO LONG â€“ FULL PLAN SHOWN!\")\r\nalertcondition(shortSetup, \"COMBO SHORT\", \"VELEZ COMBO SHORT â€“ FULL PLAN SHOWN!\")"
  },
  {
    "url": "0oFRzxDy-Range-Trading-Strategy",
    "name": "Range Trading Strategy",
    "description": "OVERVIEW \nThe Range Trading Strategy is a systematic trading approach that identifies price ranges \nfrom higher timeframe candles or trading sessions, tracks pivot points, and generates \ntrading signals when range extremes are mitigated and confirmed by pivot levels.\n\n CORE CONCEPT \nThe strategy is based on the principle that when a candle (or session) closes within the \nrange of the previous candle (or session), that previous candle becomes a \"range\" with \nidentifiable high and low extremes. When price breaks through these extremes, it creates \ntrading opportunities that are confirmed by pivot levels.\n\n RANGE DETECTION MODES \n 1. HTF (Higher Timeframe) Mode: \n \n Automatically selects a higher timeframe based on the current chart timeframe\n Uses request.security() to fetch HTF candle data\n Range is created when an HTF candle closes within the previous HTF candle's range\n The previous HTF candle's high and low become the range extremes\n \n\n 2. Sessions Mode: \n \n    - Divides the trading day into 4 sessions (UTC):\n      * Session 1: 00:00 - 06:00 (6 hours)\n      * Session 2: 06:00 - 12:00 (6 hours)\n      * Session 3: 12:00 - 20:00 (8 hours)\n      * Session 4: 20:00 - 00:00 (4 hours, spans midnight)\n    - Tracks high, low, and close for each session\n    - Range is created when a session closes within the previous session's range\n    - The previous session's high and low become the range extremes\n \n\n PIVOT DETECTION \nPivots are detected based on candle color changes (bullish/bearish transitions):\n\n 1. Pivot Low: \n \n Created when a bullish candle appears after a bearish candle\n Pivot low = minimum of the current candle's low and previous candle's low\n The pivot bar is the actual bar where the low was formed (current or previous bar)\n \n\n 2. Pivot High: \n \n Created when a bearish candle appears after a bullish candle\n Pivot high = maximum of the current candle's high and previous candle's high\n The pivot bar is the actual bar where the high was formed (current or previous bar)\n \n\n IMPORTANT: There is always only ONE active pivot high and ONE active pivot low at any \ngiven time. When a new pivot is created, it replaces the previous one. \n\n RANGE CREATION \n A range is created when: \n \n (HTF Mode) An HTF candle closes within the previous HTF candle's range AND a new HTF \n   candle has just started\n (Sessions Mode) A session closes within the previous session's range AND a new session \n   has just started\n Or Range Can Be Created when the Extreme of Another Range Gets Mitigated and We Have a Pivot low Just Above the Range Low or Pivot High just Below the Range High\n \n\n Range Properties: \n \n rangeHigh: The high extreme of the range\n rangeLow: The low extreme of the range\n highStartTime: The timestamp when the range high was actually formed (found by looping \n   backwards through bars)\n lowStartTime: The timestamp when the range low was actually formed (found by looping \n   backwards through bars)\n highMitigated / lowMitigated: Flags tracking whether each extreme has been broken\n isSpecial: Flag indicating if this is a \"special range\" (see Special Ranges section)\n \n\n RANGE MITIGATION \nA range extreme is considered \"mitigated\" when price interacts with it:\n \n High is mitigated when: high >= rangeHigh (any interaction at or above the level)\n Low is mitigated when: low <= rangeLow (any interaction at or below the level)\n \n\n Mitigation can happen: \n \n At the moment of range creation (if price is already beyond the extreme)\n At any point after range creation when price touches the extreme\n \n\nSIGNAL GENERATION\n\n1. Pending Signals:\n   When a range extreme is mitigated, a pending signal is created:\n\n    a) BEARISH Pending Signal: \n \n       - Triggered when: rangeHigh is mitigated\n       - Confirmation Level: Current pivotLow\n       - Signal is confirmed when: close < pivotLow\n       - Stop Loss: Current pivotHigh (at time of confirmation)\n       - Entry: Short position\n \n\n Signal Confirmation \n  \n\n    b) BULLISH Pending Signal: \n \n       - Triggered when: rangeLow is mitigated\n       - Confirmation Level: Current pivotHigh\n       - Signal is confirmed when: close > pivotHigh\n       - Stop Loss: Current pivotLow (at time of confirmation)\n       - Entry: Long position\n \n\n IMPORTANT: There is only ever ONE pending bearish signal and ONE pending bullish signal \nat any given time. When a new pending signal is created, it replaces the previous one \nof the same type. \n\n2. Signal Confirmation:\n   - Bearish: Confirmed when price closes below the pivot low (confirmation level)\n   - Bullish: Confirmed when price closes above the pivot high (confirmation level)\n   - Upon confirmation, a trade is entered immediately\n   - The confirmation line is drawn from the pivot bar to the confirmation bar\n\n TRADE EXECUTION \n When a signal is confirmed: \n\n 1. Position Management: \n \n    - Any existing position in the opposite direction is closed first\n    - Then the new position is entered\n \n\n 2. Stop Loss: \n \n    - Bearish (Short): Stop at pivotHigh\n    - Bullish (Long): Stop at pivotLow\n \n\n \n 3. Take Profit: \n    - Calculated using Risk:Reward Ratio (default 2:1)\n    - Risk = Distance from entry to stop loss\n    - Target = Entry Â± (Risk Ã— R:R Ratio)\n    - Can be disabled with \"Stop Loss Only\" toggle\n \n\n 4. Trade Comments: \n \n    - \"Range Bear\" for short trades\n    - \"Range Bull\" for long trades\n \n\n SPECIAL RANGES \nSpecial ranges are created when:\n \n - A range high is mitigated AND the current pivotHigh is below the range high\n - A range low is mitigated AND the current pivotLow is above the range low\n \n\n\nIn these cases:\n- The pivot value is stored in an array (storedPivotHighs or storedPivotLows)\n- A \"special range\" is created with only ONE extreme:\n  * If pivotHigh < rangeHigh: Creates a range with rangeHigh = pivotLow, rangeLow = na\n  * If pivotLow > rangeLow: Creates a range with rangeLow = pivotHigh, rangeHigh = na\n- Special ranges can generate signals just like normal ranges\n- If a special range is mitigated on the creation bar or the next bar, it is removed \n  entirely without generating signals (prevents false signals)\n Special Ranges \n  \n\n REVERSE ON STOP LOSS \nWhen enabled, if a stop loss is hit, the strategy automatically opens a trade in the \nopposite direction:\n\n 1. Long Stop Loss Hit:\n    \n \n - Detects when: position_size  > 0 AND position_size <= 0 AND low <= longStopLoss\n    - Action: Opens a SHORT position\n    - Stop Loss: Current pivotHigh\n    - Trade Comment: \"Reverse on Stop\"\n \n\n 2. Short Stop Loss Hit: \n \n    - Detects when: position_size  < 0 AND position_size >= 0 AND high >= shortStopLoss\n    - Action: Opens a LONG position\n    - Stop Loss: Current pivotLow\n    - Trade Comment: \"Reverse on Stop\"\n \n\n The reverse trade uses the same R:R ratio and respects the \"Stop Loss Only\" setting. \n\n VISUAL ELEMENTS \n\n 1. Range Lines: \n \n    - Drawn from the time when the extreme was formed to the mitigation point (or current \n      time if not mitigated)\n    - High lines: Blue (or mitigated color if mitigated)\n    - Low lines: Red (or mitigated color if mitigated)\n    - Style: SOLID\n    - Width: 1\n \n\n2. Confirmation Lines:\n \n    - Drawn when a signal is confirmed\n    - Extends from the pivot bar to the confirmation bar\n    - Bearish: Red, solid line\n    - Bullish: Green, solid line\n    - Width: 1\n    - Can be toggled on/off\n \n\n STRATEGY SETTINGS \n\n1. Range Detection Mode:\n \n    - HTF: Uses higher timeframe candles\n    - Sessions: Uses trading session boundaries\n \n \n2. Auto HTF:\n \n    - Automatically selects HTF based on current chart timeframe\n    - Can be disabled to use manual HTF selection\n \n \n3. Risk:Reward Ratio:\n \n    - Default: 2.0 (2:1)\n    - Minimum: 0.5\n    - Step: 0.5\n \n\n4. Stop Loss Only:\n \n    - When enabled: Trades only have stop loss (no take profit)\n    - Trades close on stop loss or when opposite signal confirms\n \n\n5. Reverse on Stop Loss:\n \n    - When enabled: Hitting a stop loss opens opposite trade with stop at opposing pivot\n \n\n6. Max Ranges to Display:\n \n    - Limits the number of ranges kept in memory\n    - Oldest ranges are purged when limit is exceeded\n \n\nKEY FEATURES\n1. Dynamic Pivot Tracking:\n \n    - Pivots update on every candle color change\n    - Always maintains one high and one low pivot\n \n\n2. Range Lifecycle:\n \n    - Ranges are created when price closes within previous range\n    - Ranges are tracked until mitigated\n    - Mitigation creates pending signals\n    - Signals are confirmed by pivot levels\n \n\n3. Signal Priority:\n \n    - Only one pending signal of each type at a time\n    - New signals replace old ones\n    - Confirmation happens on close of bar\n \n\n4. Position Management:\n \n    - Closes opposite positions before entering new trades\n    - Tracks stop loss levels for reverse functionality\n    - Respects pyramiding = 1 (only one position per direction)\n \n\n5. Time-Based Drawing:\n \n    - Uses time coordinates instead of bar indices for line drawing\n    - Prevents \"too far from current bar\" errors\n    - Lines can extend to any historical point\n \n \n\n \n USAGE NOTES \n \n - Best suited for trending and ranging markets\n - Works on any timeframe, but HTF mode adapts automatically\n - Sessions mode is ideal for intraday trading\n - Pivot detection requires clear candle color changes\n - Range detection requires price to close within previous range\n - Signals are generated on bar close, not intra-bar\n \n\nThe strategy combines range identification, pivot tracking, and signal confirmation to \ncreate a systematic approach to trading breakouts and reversals based on price structure, past performance does not in any way predict future performance \n\n",
    "image_url": "0oFRzxDy",
    "author": "mindyourbuisness",
    "likes": 473,
    "type": "strategy",
    "created": "2025-11-08",
    "updated": "2025-11-08",
    "source": "//@version=6\r\nstrategy('Range Trading Strategy', overlay = true, max_lines_count = 400, pyramiding = 1, initial_capital = 100000, default_qty_type = strategy.percent_of_equity, default_qty_value = 10)\r\n\r\n// Range Detection Mode\r\nrangeMode = input.string('HTF', 'Range Detection Mode', options = ['HTF', 'Sessions'], group = 'Range Detection')\r\n\r\n// HTF Settings\r\nautoMode = input.bool(true, 'Auto HTF', tooltip = 'Automatically select HTF based on current chart timeframe', group = 'Range Detection')\r\nmanualHTF = input.timeframe('D', 'Manual HTF', tooltip = 'Manual HTF selection (only used when Auto HTF is disabled)', group = 'Range Detection')\r\n\r\n// Strategy Settings\r\nriskRewardRatio = input.float(2.0, 'Risk:Reward Ratio', minval = 0.5, step = 0.5, group = 'Strategy')\r\nshowConfirmationLines = input.bool(true, 'Show Confirmation Lines', group = 'Strategy')\r\nstopLossOnly = input.bool(false, 'Stop Loss Only', tooltip = 'When enabled, trades only have stop loss (no take profit). Trades close on stop loss or when opposite signal confirms.', group = 'Strategy')\r\nreverseOnStopLoss = input.bool(false, 'Reverse on Stop Loss', tooltip = 'When enabled, hitting a stop loss opens an opposite trade with stop at the opposing pivot.', group = 'Strategy')\r\n\r\n// Get HTF Period function (from Composite Profile)\r\ngetHTFPeriod() =>\r\n    switch timeframe.period\r\n        '1'   => '45'      // 1m â†’ 45m\r\n        '3'   => '120'     // 3m â†’ 2h\r\n        '5'   => '240'     // 5m â†’ 4h\r\n        '10'  => '480'     // 10m â†’ 8h\r\n        '15'  => '720'     // 15m â†’ 12h\r\n        '30'  => '1D'      // 30m â†’ 1D\r\n        '45'  => '2D'      // 45m â†’ 2D\r\n        '60'  => '2D'      // 1h â†’ 2D\r\n        '120' => '4D'      // 2h â†’ 4D\r\n        '240' => '1W'      // 4h â†’ 1W\r\n        '360' => '2W'      // 6h â†’ 2W\r\n        '720' => '1M'      // 12h â†’ 1M\r\n        '1D'  => '1M'      // 1D â†’ 1M\r\n        '3D'  => '3M'      // 3D â†’ 3M\r\n        '1W'  => '1Y'      // 1W â†’ 1Y\r\n        '1M'  => '4Y'      // 1M â†’ 4Y\r\n        '3M'  => '12Y'     // 3M â†’ 12Y\r\n        => '1D'            // Default\r\n\r\n// Use auto or manual timeframe\r\nselectedHTF = autoMode ? getHTFPeriod() : manualHTF\r\n\r\n// ========================================\r\n// SESSION DETECTION (from CompositeProfile.pine)\r\n// ========================================\r\ntf = timeframe.period\r\ntz = \"UTC\"\r\n\r\n// Session definitions (HHMM-HHMM format in UTC)\r\nsession1_str = '0000-0600'  // Session 1: 00:00 - 06:00 (6 hours)\r\nsession2_str = '0600-1200'  // Session 2: 06:00 - 12:00 (6 hours)\r\nsession3_str = '1200-2000'  // Session 3: 12:00 - 20:00 (8 hours)\r\nsession4_str = '2000-0000'  // Session 4: 20:00 - 00:00 (4 hours, spans midnight)\r\n\r\n// Session detection using time() function\r\nis_session1 = math.sign(nz(time(tf, session1_str, tz)))\r\nis_session2 = math.sign(nz(time(tf, session2_str, tz)))\r\nis_session3 = math.sign(nz(time(tf, session3_str, tz)))\r\nis_session4 = math.sign(nz(time(tf, session4_str, tz)))\r\n\r\n// Get current session name\r\ngetCurrentSession() =>\r\n    if is_session1 > 0\r\n        'Session 1'\r\n    else if is_session2 > 0\r\n        'Session 2'\r\n    else if is_session3 > 0\r\n        'Session 3'\r\n    else if is_session4 > 0\r\n        'Session 4'\r\n    else\r\n        'Off Hours'\r\n\r\n// Session tracking variables\r\nvar string currentSession = na\r\nvar float sessionHigh = na\r\nvar float sessionLow = na\r\nvar float sessionClose = na\r\nvar float sessionHighPrev = na\r\nvar float sessionLowPrev = na\r\nvar float sessionClosePrev = na\r\nvar bool newSession = false\r\n\r\n// Input parameters\r\nmaxRangesToDisplay = input.int(10, 'Max Ranges to Display', minval = 1, maxval = 400)\r\n\r\n// Color settings\r\nrangeHighColor = input.color(color.blue, 'Range High Color')\r\nrangeLowColor = input.color(color.red, 'Range Low Color')\r\nmitigatedColor = input.color(color.gray, 'Mitigated Color')\r\n\r\n// Structure for ranges - track high and low mitigation separately\r\ntype Range\r\n    float rangeHigh\r\n    float rangeLow\r\n    int highStartTime     // Time when the high was formed\r\n    int lowStartTime      // Time when the low was formed\r\n    bool highMitigated\r\n    bool lowMitigated\r\n    int highMitigationTime\r\n    int lowMitigationTime\r\n    bool isSpecial        // Flag to mark special ranges (only one extreme)\r\n    int creationBar       // Bar index where the range was created (for special ranges)\r\n\r\n// Pending Signal Structure\r\ntype PendingSignal\r\n    string signalType       // \"BEARISH\" or \"BULLISH\"\r\n    float confirmationLevel // Pivot level that needs to be crossed\r\n    int creationBar         // Bar where signal was created\r\n    int pivotBarIndex       // Bar index where the pivot was formed\r\n\r\n// Initialize arrays\r\nvar ranges = array.new<Range>()\r\nvar array<line> rangeLines = array.new_line()\r\n\r\n// Pivot tracking (always one high and one low)\r\nvar float pivotHigh = na\r\nvar float pivotLow = na\r\nvar int pivotHighBar = na\r\nvar int pivotLowBar = na\r\nvar bool wasBullish = true  // Initialize to true to track changes\r\n\r\n// Pending signals (max one of each type)\r\nvar PendingSignal pendingBearish = na\r\nvar PendingSignal pendingBullish = na\r\n\r\n// Arrays to store pivot values for special range creation\r\nvar storedPivotHighs = array.new<float>()\r\nvar storedPivotLows = array.new<float>()\r\n\r\n// Stop loss tracking for reverse on stop loss\r\nvar float longStopLoss = na\r\nvar float shortStopLoss = na\r\n\r\n// Clear previous drawings\r\nwhile array.size(rangeLines) > 0\r\n    line.delete(array.pop(rangeLines))\r\n\r\n// ========================================\r\n// PIVOT CALCULATION\r\n// ========================================\r\n// Update pivots based on candle color changes\r\nbool isBullish = close > open\r\nbool isBearish = close < open\r\n\r\n// Bullish candle after bearish â†’ new pivot low\r\nif isBullish and not wasBullish\r\n    pivotLow := math.min(low, low[1])\r\n    // Pivot bar is the actual bar where the low was formed\r\n    pivotLowBar := low < low[1] ? bar_index : bar_index - 1\r\n\r\n// Bearish candle after bullish â†’ new pivot high\r\nif isBearish and wasBullish\r\n    pivotHigh := math.max(high, high[1])\r\n    // Pivot bar is the actual bar where the high was formed\r\n    pivotHighBar := high > high[1] ? bar_index : bar_index - 1\r\n\r\n// Update candle direction tracking\r\nif isBullish or isBearish\r\n    wasBullish := isBullish\r\n\r\n// ========================================\r\n// RANGE DETECTION DATA (HTF or Sessions)\r\n// ========================================\r\nfloat parentHigh = na\r\nfloat parentLow = na\r\nbool isValidRange = false\r\nbool newPeriod = false\r\n\r\nif rangeMode == 'HTF'\r\n    // Get HTF data\r\n    [htfHigh, htfLow, htfClose] = request.security(syminfo.tickerid, selectedHTF, [high, low, close], lookahead = barmerge.lookahead_off)\r\n    [htfHighPrev, htfLowPrev] = request.security(syminfo.tickerid, selectedHTF, [high[1], low[1]], lookahead = barmerge.lookahead_off)\r\n    \r\n    // Detect new HTF candle\r\n    newPeriod := timeframe.change(selectedHTF)\r\n    \r\n    // Check if HTF candle closes within previous HTF candle's range\r\n    if not na(htfHighPrev) and not na(htfLowPrev) and not na(htfClose)\r\n        parentHigh := htfHighPrev\r\n        parentLow := htfLowPrev\r\n        \r\n        // HTF candle closes within previous HTF candle's range\r\n        isValidRange := htfClose <= parentHigh and htfClose >= parentLow and newPeriod\r\n\r\nelse if rangeMode == 'Sessions'\r\n    // Session-based range detection\r\n    string thisSession = getCurrentSession()\r\n    \r\n    // Detect new session\r\n    if na(currentSession)\r\n        // First session\r\n        currentSession := thisSession\r\n        newSession := false\r\n        sessionHigh := high\r\n        sessionLow := low\r\n        sessionClose := close\r\n    else if thisSession != currentSession and thisSession != 'Off Hours'\r\n        // New session started\r\n        // Store previous session data\r\n        sessionHighPrev := sessionHigh\r\n        sessionLowPrev := sessionLow\r\n        sessionClosePrev := sessionClose\r\n        \r\n        // Start new session\r\n        currentSession := thisSession\r\n        newSession := true\r\n        sessionHigh := high\r\n        sessionLow := low\r\n        sessionClose := close\r\n        \r\n        // Check if previous session close is within previous session's range\r\n        if not na(sessionHighPrev) and not na(sessionLowPrev) and not na(sessionClosePrev)\r\n            parentHigh := sessionHighPrev\r\n            parentLow := sessionLowPrev\r\n            \r\n            // Previous session closes within its range\r\n            isValidRange := sessionClosePrev <= parentHigh and sessionClosePrev >= parentLow\r\n    else\r\n        // Same session - update high/low\r\n        newSession := false\r\n        if high > sessionHigh\r\n            sessionHigh := high\r\n        if low < sessionLow\r\n            sessionLow := low\r\n        sessionClose := close\r\n\r\n// Create new range if valid\r\nif isValidRange\r\n    // Find the time when the range high was formed by looping backwards\r\n    int highStartTime = time\r\n    for i = 0 to 500  // Look back up to 500 bars\r\n        if bar_index - i < 0\r\n            break\r\n        if high[i] >= parentHigh\r\n            highStartTime := time[i]\r\n            break\r\n    \r\n    // Find the time when the range low was formed by looping backwards\r\n    int lowStartTime = time\r\n    for i = 0 to 500  // Look back up to 500 bars\r\n        if bar_index - i < 0\r\n            break\r\n        if low[i] <= parentLow\r\n            lowStartTime := time[i]\r\n            break\r\n    \r\n    newRange = Range.new()\r\n    newRange.rangeHigh := parentHigh\r\n    newRange.rangeLow := parentLow\r\n    newRange.highStartTime := highStartTime\r\n    newRange.lowStartTime := lowStartTime\r\n    newRange.isSpecial := false\r\n    newRange.creationBar := bar_index\r\n    \r\n    // Check if extremes are already mitigated at creation\r\n    newRange.highMitigated := high >= parentHigh\r\n    newRange.lowMitigated := low <= parentLow\r\n    newRange.highMitigationTime := newRange.highMitigated ? time : na\r\n    newRange.lowMitigationTime := newRange.lowMitigated ? time : na\r\n    \r\n    array.push(ranges, newRange)\r\n\r\n// Create special ranges from stored pivot values (runs on every bar)\r\n// Create ranges with stored pivot lows as rangeHigh\r\nif array.size(storedPivotLows) > 0\r\n    for i = 0 to array.size(storedPivotLows) - 1\r\n        storedPivotLow = array.get(storedPivotLows, i)\r\n        \r\n        // Find the time when the pivot low was formed by looping backwards\r\n        int pivotLowStartTime = time\r\n        for j = 0 to 500  // Look back up to 500 bars\r\n            if bar_index - j < 0\r\n                break\r\n            if low[j] <= storedPivotLow\r\n                pivotLowStartTime := time[j]\r\n                break\r\n        \r\n        // Create special range with pivot low as rangeHigh\r\n        specialRange = Range.new()\r\n        specialRange.rangeHigh := storedPivotLow\r\n        specialRange.rangeLow := na  // No low extreme\r\n        specialRange.highStartTime := pivotLowStartTime\r\n        specialRange.lowStartTime := time\r\n        specialRange.highMitigated := false\r\n        specialRange.lowMitigated := true  // Always mitigated since it doesn't exist\r\n        specialRange.highMitigationTime := na\r\n        specialRange.lowMitigationTime := time\r\n        specialRange.isSpecial := true\r\n        specialRange.creationBar := bar_index\r\n        array.push(ranges, specialRange)\r\n    array.clear(storedPivotLows)\r\n\r\n// Create ranges with stored pivot highs as rangeLow\r\nif array.size(storedPivotHighs) > 0\r\n    for i = 0 to array.size(storedPivotHighs) - 1\r\n        storedPivotHigh = array.get(storedPivotHighs, i)\r\n        \r\n        // Find the time when the pivot high was formed by looping backwards\r\n        int pivotHighStartTime = time\r\n        for j = 0 to 500  // Look back up to 500 bars\r\n            if bar_index - j < 0\r\n                break\r\n            if high[j] >= storedPivotHigh\r\n                pivotHighStartTime := time[j]\r\n                break\r\n        \r\n        // Create special range with pivot high as rangeLow\r\n        specialRange = Range.new()\r\n        specialRange.rangeHigh := na  // No high extreme\r\n        specialRange.rangeLow := storedPivotHigh\r\n        specialRange.highStartTime := time\r\n        specialRange.lowStartTime := pivotHighStartTime\r\n        specialRange.highMitigated := true  // Always mitigated since it doesn't exist\r\n        specialRange.lowMitigated := false\r\n        specialRange.highMitigationTime := time\r\n        specialRange.lowMitigationTime := na\r\n        specialRange.isSpecial := true\r\n        specialRange.creationBar := bar_index\r\n        array.push(ranges, specialRange)\r\n    array.clear(storedPivotHighs)\r\n\r\n// Check for range mitigation (any interaction with extreme)\r\nif array.size(ranges) > 0\r\n    for i = array.size(ranges) - 1 to 0\r\n        r = array.get(ranges, i)\r\n        \r\n        // Check high mitigation - any interaction at or above range high\r\n        if not r.highMitigated and high >= r.rangeHigh\r\n            r.highMitigated := true\r\n            r.highMitigationTime := time\r\n            \r\n            // For special ranges, if mitigated on creation bar or next bar, remove entirely\r\n            if r.isSpecial and (r.creationBar == bar_index or r.creationBar == bar_index - 1)\r\n                array.remove(ranges, i)\r\n                continue\r\n            \r\n            // Store pivot high if it's below the range high (for special range creation)\r\n            // Only store for non-special ranges to prevent endless cycling\r\n            if not r.isSpecial and not na(pivotHigh) and pivotHigh < r.rangeHigh\r\n                array.push(storedPivotHighs, pivotHigh)\r\n            \r\n            // Create pending BEARISH signal (range high mitigated)\r\n            if not na(pivotLow) and not na(pivotLowBar)\r\n                // Create new pending bearish signal\r\n                pendingBearish := PendingSignal.new()\r\n                pendingBearish.signalType := \"BEARISH\"\r\n                pendingBearish.confirmationLevel := pivotLow\r\n                pendingBearish.creationBar := bar_index\r\n                pendingBearish.pivotBarIndex := pivotLowBar\r\n        \r\n        // Check low mitigation - any interaction at or below range low\r\n        if not r.lowMitigated and low <= r.rangeLow\r\n            r.lowMitigated := true\r\n            r.lowMitigationTime := time\r\n            \r\n            // For special ranges, if mitigated on creation bar or next bar, remove entirely\r\n            if r.isSpecial and (r.creationBar == bar_index or r.creationBar == bar_index - 1)\r\n                array.remove(ranges, i)\r\n                continue\r\n            \r\n            // Store pivot low if it's above the range low (for special range creation)\r\n            // Only store for non-special ranges to prevent endless cycling\r\n            if not r.isSpecial and not na(pivotLow) and pivotLow > r.rangeLow\r\n                array.push(storedPivotLows, pivotLow)\r\n            \r\n            // Create pending BULLISH signal (range low mitigated)\r\n            if not na(pivotHigh) and not na(pivotHighBar)\r\n                // Create new pending bullish signal\r\n                pendingBullish := PendingSignal.new()\r\n                pendingBullish.signalType := \"BULLISH\"\r\n                pendingBullish.confirmationLevel := pivotHigh\r\n                pendingBullish.creationBar := bar_index\r\n                pendingBullish.pivotBarIndex := pivotHighBar\r\n    \r\n    // Purge oldest ranges if we exceed the maximum limit\r\n    while array.size(ranges) > maxRangesToDisplay\r\n        array.shift(ranges)\r\n\r\n// Draw active ranges\r\nif array.size(ranges) > 0\r\n    for i = 0 to array.size(ranges) - 1\r\n        r = array.get(ranges, i)\r\n        \r\n        // Determine right edge time for high line\r\n        int highRightTime = r.highMitigated ? r.highMitigationTime : time\r\n        color highLineColor = r.highMitigated ? color.new(mitigatedColor, 50) : rangeHighColor\r\n        \r\n        // Determine right edge time for low line\r\n        int lowRightTime = r.lowMitigated ? r.lowMitigationTime : time\r\n        color lowLineColor = r.lowMitigated ? color.new(mitigatedColor, 50) : rangeLowColor\r\n        \r\n        // Draw range high line using time (starts from where high was formed)\r\n        array.push(rangeLines, line.new(r.highStartTime, r.rangeHigh, highRightTime, r.rangeHigh, color = highLineColor, width = 1, xloc = xloc.bar_time))\r\n        \r\n        // Draw range low line using time (starts from where low was formed)\r\n        array.push(rangeLines, line.new(r.lowStartTime, r.rangeLow, lowRightTime, r.rangeLow, color = lowLineColor, width = 1, xloc = xloc.bar_time))\r\n\r\n// ========================================\r\n// SIGNAL CONFIRMATION & STRATEGY\r\n// ========================================\r\n\r\n// Check pending bearish signal confirmation\r\nif not na(pendingBearish)\r\n    // Bearish confirmed when price closes below confirmation level (pivot low)\r\n    if close < pendingBearish.confirmationLevel\r\n        // Draw confirmation line from pivot low bar to current bar\r\n        if showConfirmationLines\r\n            line.new(pendingBearish.pivotBarIndex, pendingBearish.confirmationLevel, bar_index, pendingBearish.confirmationLevel, color = color.new(color.red, 0), width = 1, style = line.style_solid)\r\n        \r\n        // Calculate entry, stop, and target\r\n        float entryPrice = close\r\n        float stopPrice = pivotHigh  // Current pivot high at confirmation\r\n        float riskAmount = stopPrice - entryPrice\r\n        float targetPrice = entryPrice - (riskAmount * riskRewardRatio)\r\n        \r\n        // Close any long positions\r\n        if strategy.position_size > 0\r\n            strategy.close_all(comment = \"Close Longs\")\r\n            longStopLoss := na  // Clear stop loss tracking\r\n        \r\n        // Enter short\r\n        strategy.entry(\"Short\", strategy.short, comment = \"Range Bear\")\r\n        shortStopLoss := stopPrice  // Track stop loss level\r\n        if stopLossOnly\r\n            strategy.exit(\"Short Exit\", \"Short\", stop = stopPrice)\r\n        else\r\n            strategy.exit(\"Short Exit\", \"Short\", stop = stopPrice, limit = targetPrice)\r\n        \r\n        // Clear pending signal\r\n        pendingBearish := na\r\n\r\n// Check pending bullish signal confirmation\r\nif not na(pendingBullish)\r\n    // Bullish confirmed when price closes above confirmation level (pivot high)\r\n    if close > pendingBullish.confirmationLevel\r\n        // Draw confirmation line from pivot high bar to current bar\r\n        if showConfirmationLines\r\n            line.new(pendingBullish.pivotBarIndex, pendingBullish.confirmationLevel, bar_index, pendingBullish.confirmationLevel, color = color.new(color.green, 0), width = 1, style = line.style_solid)\r\n        \r\n        // Calculate entry, stop, and target\r\n        float entryPrice = close\r\n        float stopPrice = pivotLow  // Current pivot low at confirmation\r\n        float riskAmount = entryPrice - stopPrice\r\n        float targetPrice = entryPrice + (riskAmount * riskRewardRatio)\r\n        \r\n        // Close any short positions\r\n        if strategy.position_size < 0\r\n            strategy.close_all(comment = \"Close Shorts\")\r\n            shortStopLoss := na  // Clear stop loss tracking\r\n        \r\n        // Enter long\r\n        strategy.entry(\"Long\", strategy.long, comment = \"Range Bull\")\r\n        longStopLoss := stopPrice  // Track stop loss level\r\n        if stopLossOnly\r\n            strategy.exit(\"Long Exit\", \"Long\", stop = stopPrice)\r\n        else\r\n            strategy.exit(\"Long Exit\", \"Long\", stop = stopPrice, limit = targetPrice)\r\n        \r\n        // Clear pending signal\r\n        pendingBullish := na\r\n\r\n// ========================================\r\n// REVERSE ON STOP LOSS\r\n// ========================================\r\nif reverseOnStopLoss\r\n    // Detect if long stop loss was hit\r\n    if strategy.position_size[1] > 0 and strategy.position_size <= 0 and not na(longStopLoss)\r\n        // Check if price touched the stop loss\r\n        if low <= longStopLoss\r\n            // Hit bullish stop loss - open short with stop at pivot high\r\n            if not na(pivotHigh)\r\n                float reverseEntryPrice = close\r\n                float reverseStopPrice = pivotHigh\r\n                float reverseRiskAmount = reverseStopPrice - reverseEntryPrice\r\n                float reverseTargetPrice = reverseEntryPrice - (reverseRiskAmount * riskRewardRatio)\r\n                \r\n                // Enter short\r\n                strategy.entry(\"Reverse Short\", strategy.short, comment = \"Reverse on Stop\")\r\n                shortStopLoss := reverseStopPrice\r\n                if stopLossOnly\r\n                    strategy.exit(\"Reverse Short Exit\", \"Reverse Short\", stop = reverseStopPrice)\r\n                else\r\n                    strategy.exit(\"Reverse Short Exit\", \"Reverse Short\", stop = reverseStopPrice, limit = reverseTargetPrice)\r\n            \r\n            // Clear long stop loss tracking\r\n            longStopLoss := na\r\n    \r\n    // Detect if short stop loss was hit\r\n    if strategy.position_size[1] < 0 and strategy.position_size >= 0 and not na(shortStopLoss)\r\n        // Check if price touched the stop loss\r\n        if high >= shortStopLoss\r\n            // Hit bearish stop loss - open long with stop at pivot low\r\n            if not na(pivotLow)\r\n                float reverseEntryPrice = close\r\n                float reverseStopPrice = pivotLow\r\n                float reverseRiskAmount = reverseEntryPrice - reverseStopPrice\r\n                float reverseTargetPrice = reverseEntryPrice + (reverseRiskAmount * riskRewardRatio)\r\n                \r\n                // Enter long\r\n                strategy.entry(\"Reverse Long\", strategy.long, comment = \"Reverse on Stop\")\r\n                longStopLoss := reverseStopPrice\r\n                if stopLossOnly\r\n                    strategy.exit(\"Reverse Long Exit\", \"Reverse Long\", stop = reverseStopPrice)\r\n                else\r\n                    strategy.exit(\"Reverse Long Exit\", \"Reverse Long\", stop = reverseStopPrice, limit = reverseTargetPrice)\r\n            \r\n            // Clear short stop loss tracking\r\n            shortStopLoss := na\r\n"
  },
  {
    "url": "Epqb0L8C-RSI-MACD-Multi-Timeframe-Strategy",
    "name": "RSI + MACD Multi-Timeframe Strategy",
    "description": "This strategy combines the Relative Strength Index (RSI) from the daily timeframe with the Moving Average Convergence Divergence (MACD) from the 4-hour timeframe to generate precise long entry and exit signals.\n\nThe system uses a multi-timeframe approach to align longer-term trend conditions with shorter-term momentum shifts â€” allowing traders to catch dips with confirmation and exit before reversals.\n\n ðŸ§  Strategy Logic \nâœ… Long Entry Condition:\n\n- RSI on the daily (1D) timeframe is oversold (below your defined threshold)\n- MACD on the 4H timeframe crosses above the signal line\n\nâ†’ A long trade is opened when these two align\n\nâœ… Long Exit Condition:\n\n- RSI on the daily timeframe is overbought\n- MACD on the 4H timeframe crosses below the signal line\n\nâ†’ The long trade is closed when these two conditions are met\n\nðŸ’¡ This strategy currently supports long entries only. Short logic can be added if needed.\n\n ðŸ“Š Indicator Components \nðŸ”¹ RSI (Relative Strength Index):\n\n- A momentum oscillator that measures the speed and magnitude of price changes.\n- Helps identify overbought (potential sell) and oversold (potential buy) conditions.\n- Applied on the 1D timeframe (by default) to reflect broader market trend or exhaustion levels.\n\nðŸ”¹ MACD (Moving Average Convergence Divergence):\n\n- A trend-following momentum indicator based on moving averages.\n- The MACD Line (fast EMA - slow EMA) crossing above the Signal Line indicates bullish momentum.\n- Used here on the 4-hour timeframe (by default) for shorter-term momentum confirmation.\n\nðŸ”¹ Multi-Timeframe (MTF) Logic:\n\n- Uses request.security() to pull higher timeframe data (1D for RSI, 4H for MACD).\n- Ensures no repainting, as it only uses closed candles from the higher timeframe.\n- Aligns longer-term signals with shorter-term entries, reducing false signals.\n\n ðŸ“ˆ Plotting Options \n\nThe script includes a plot selector input allowing you to toggle between:\n\n- RSI Plot (with overbought/oversold lines)\n- MACD Plot (MACD line and signal line)\n- This helps visualize signal conditions clearly on your chart.\n\nðŸ›  Customization\n\n- RSI & MACD settings are fully configurable\n- RSI and MACD timeframes can be adjusted independently\n\nâš ï¸ Disclaimer\n\n This strategy is provided for educational and informational purposes only.\nIt is not financial advice or a recommendation to buy or sell any asset.\nPast performance does not guarantee future results. Always test strategies in a simulated environment before live use, and consult with a licensed financial advisor for investment decisions.",
    "image_url": "Epqb0L8C",
    "author": "RWCS_LTD",
    "likes": 586,
    "type": "strategy",
    "created": "2025-11-08",
    "updated": "2025-11-08",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// Â© RWCS_LTD\r\n\r\n//@version=6\r\nstrategy(\"RSI + MACD Multi-Timeframe Strategy\", overlay=false, default_qty_type=strategy.percent_of_equity, default_qty_value=100)\r\n\r\n// === INPUTS ===\r\ngroup1 = \"Plotting Options\"\r\ngroup2 = \"Relative Strength Index\"\r\ngroup3 = \"Moving Average Convergence/Divergence\"\r\n\r\nplotChoice = input.string(\"RSI\", title=\"Plot Selector\", options=[\"RSI\", \"MACD\"], group = group1)\r\n\r\nRSI_TIME = input.timeframe(\"1D\", \"RSI Timeframe\", group = group2)\r\nrsiLength = input.int(14, \"RSI Length\", group = group2)\r\nrsiOB = input.int(70, \"RSI Overbought Level\", group = group2)\r\nrsiOS = input.int(30, \"RSI Oversold Level\", group = group2)\r\n\r\nMACD_TIME = input.timeframe(\"240\", \"MACD Timeframe\", group = group3)\r\nmacdFast = input.int(12, \"MACD Fast Length\", group = group3)\r\nmacdSlow = input.int(26, \"MACD Slow Length\", group = group3)\r\nmacdSignal = input.int(9, \"MACD Signal Smoothing\", group = group3)\r\n\r\n\r\n// === RSI on 1D ===\r\nrsi1D = request.security(syminfo.tickerid, RSI_TIME, ta.rsi(close, rsiLength))\r\nisOB = rsi1D > rsiOB\r\nisOS = rsi1D < rsiOS\r\n\r\n// === MACD on 4H ===\r\n[macdLine, signalLine, _] = request.security(syminfo.tickerid, MACD_TIME, ta.macd(close, macdFast, macdSlow, macdSignal))\r\nmacdCrossOver = ta.crossover(macdLine, signalLine)\r\nmacdCrossUnder = ta.crossunder(macdLine, signalLine)\r\n\r\n// === Long Entry ===\r\nlongCondition = isOS and macdCrossOver\r\nif (longCondition)\r\n    strategy.entry(\"Long\", strategy.long)\r\n\r\n// === Long Exit ===\r\nlongExit = isOB and macdCrossUnder\r\nif (longExit)\r\n    strategy.close(\"Long\")\r\n\r\n// === Plotting ===\r\nshowRSI = plotChoice == \"RSI\"\r\nshowMACD = plotChoice == \"MACD\"\r\n\r\n// === Conditional Plotting ===\r\nplot(showRSI ? rsi1D : na, title=\"RSI (1D)\", color=color.blue)\r\nhline(showRSI ? rsiOB : na, \"Overbought\", color=color.red)\r\nhline(showRSI ? rsiOS : na, \"Oversold\", color=color.green)\r\n\r\nplot(showMACD ? macdLine : na, title=\"MACD Line (4H)\", color=color.orange)\r\nplot(showMACD ? signalLine : na, title=\"Signal Line (4H)\", color=color.purple)\r\n"
  },
  {
    "url": "BFbjDzVD-Confirmed-Momentum-QQQ-RSI-MACD-Filter",
    "name": "Confirmed Momentum QQQ (RSI/MACD Filter)",
    "description": "Gemini and Myself,\n\n\n\nHow This Targets a Higher Win Rate\nThe key to the win rate increase is the RSI 20/80 filter.\n\nLong Signal: A long entry is now only taken if the trend is up (SMA cross), the MACD is bullish, and the RSI is not overbought (below 80). By only entering when momentum is not yet exhausted, you increase the chance that the price can travel far enough to hit your 4.0 point Take Profit.\n\nWider SL: The wider Stop Loss of 2.5 points reduces the chance of being stopped out prematurely by routine market movements (whipsaws), which is the number one killer of win rates in high-frequency trading.\n\nAfter applying these changes, you will need to run the Strategy Tester again to see the new win rate and the new total number of trades.\n\nWould you like me to help you interpret the new Strategy Tester results once you apply these settings?",
    "image_url": "BFbjDzVD",
    "author": "Allerius",
    "likes": 10,
    "type": "strategy",
    "created": "2025-11-08",
    "updated": "2025-11-08",
    "source": "//@version=6\r\nstrategy(\"Confirmed Momentum QQQ (RSI/MACD Filter)\",\r\n overlay = true,\r\n initial_capital = 10000,\r\n default_qty_type = strategy.percent_of_equity,\r\n default_qty_value = 10, // 10% of equity\r\n pyramiding = 0)\r\n\r\n// === CONSTANTES ===\r\nconst string TF = \"15\" // Fixed Timeframe for calculation\r\nconst string SYM_ALLOWED = \"QQQ\" // Allowed symbol\r\nconst string NY_TZ = \"America/New_York\"\r\n\r\n// === Inputs ===\r\n// Strategy Settings (Based on previous optimization)\r\nconfirmOnClose = input.bool(true, \"Confirmar seÃ±al al cierre\")\r\nmaxGapPtsShort = input.float(0.25, \"MÃ¡x gap permitido en CORTOS (puntos)\", 0.0, 1e6)\r\ntpPts = input.float(3.0, \"Take Profit (puntos)\", 0.01)\r\nslPts = input.float(1.5, \"Stop Loss (puntos)\", 0.01)\r\n\r\n// Optimized Session Times (09:30-10:00 & 13:30-16:00 ET)\r\nuseSessions = input.bool(true, \"Usar ventanas NY\")\r\nsess1 = input.session(\"0930-1000\", \"Ventana 1 (NY)\") // Morning Open\r\nsess2 = input.session(\"1330-1600\", \"Ventana 2 (NY)\") // Afternoon Close\r\nflatOutside = input.bool(true, \"Cerrar posiciÃ³n al salir de la ventana\")\r\n\r\n// Indicator Lengths\r\nlenRSI = input.int(14, \"RSI Length\")\r\nlenFastMA = input.int(5, \"Fast MA (Base Signal)\")\r\nlenSlowMA = input.int(15, \"Slow MA (Base Signal)\")\r\nlenMACDFast = input.int(12, \"MACD Fast Length\")\r\nlenMACDSlow = input.int(26, \"MACD Slow Length\")\r\nlenMACDSignal = input.int(9, \"MACD Signal Length\")\r\nrsiOversold = input.int(30, \"RSI Oversold Level\")\r\nrsiOverbought = input.int(70, \"RSI Overbought Level\")\r\n\r\n\r\n// === Utilidades ===\r\nisAllowedSymbol() =>\r\n (syminfo.ticker == SYM_ALLOWED) or str.contains(str.upper(syminfo.ticker), str.upper(SYM_ALLOWED))\r\n\r\n// === MTF Indicators (Calculation on TF=\"15\") ===\r\ncloseTF = request.security(syminfo.tickerid, TF, close, barmerge.gaps_off, barmerge.lookahead_off)\r\n\r\n// 1. BASE SIGNAL: SMA Crossover (MTF)\r\nsmaFast = ta.sma(closeTF, lenFastMA)\r\nsmaSlow = ta.sma(closeTF, lenSlowMA)\r\nlongSignalBase = ta.crossover(smaFast, smaSlow)\r\nshortSignalBase = ta.crossunder(smaFast, smaSlow)\r\n\r\n// 2. CONFIRMATION FILTER 1: RSI (MTF)\r\nrsi = ta.rsi(closeTF, lenRSI)\r\n// Long confirmation: RSI must NOT be overbought (i.e., less room to fall)\r\nlongConfirmRSI = rsi < rsiOverbought\r\n// Short confirmation: RSI must NOT be oversold (i.e., less room to rise)\r\nshortConfirmRSI = rsi > rsiOversold\r\n\r\n// 3. CONFIRMATION FILTER 2: MACD Trend Confirmation (MTF)\r\n[macdLine, signalLine, _] = ta.macd(closeTF, lenMACDFast, lenMACDSlow, lenMACDSignal)\r\n// Long confirmation: MACD line is above Signal line\r\nlongConfirmMACD = macdLine > signalLine\r\n// Short confirmation: MACD line is below Signal line\r\nshortConfirmMACD = macdLine < signalLine\r\n\r\n// === Final Confirmed Signals (MTF) ===\r\nlongSignalConfirmed = longSignalBase and longConfirmRSI and longConfirmMACD\r\nshortSignalConfirmed = shortSignalBase and shortConfirmRSI and shortConfirmMACD\r\n\r\n\r\n// === Sessions (evaluated in the chart's TF, NY zone) ===\r\ninSess1 = useSessions ? not na(time(timeframe.period, sess1, NY_TZ)) : true\r\ninSess2 = useSessions ? not na(time(timeframe.period, sess2, NY_TZ)) : true\r\ninSession = inSess1 or inSess2\r\n\r\n// Removed \"1 trade/ventana\" limit to increase frequency\r\n\r\n// === Filter NO-GAP ONLY for SHORTS (in POINTS) ===\r\ngapPts = math.abs(open - close[1])\r\nshortGapOK = maxGapPtsShort <= 0 ? true : (gapPts <= maxGapPtsShort)\r\n\r\n// === Gating (Entry Conditions) ===\r\nisFlat = strategy.position_size == 0\r\ncanSignal = (not confirmOnClose or barstate.isconfirmed)\r\ncanTrade = isAllowedSymbol() and inSession and canSignal // Removed canTakeMore, trades often\r\n\r\n\r\n// === ENTRADAS (Filled on the next bar's open) ===\r\n// Longs: SMA Cross + RSI NOT Overbought + MACD Bullish\r\nif canTrade and isFlat and longSignalConfirmed\r\n    strategy.entry(\"C-Long\", strategy.long)\r\n\r\n// Shorts: SMA Cross + RSI NOT Oversold + MACD Bearish + Gap Filter\r\nif canTrade and isFlat and shortSignalConfirmed and shortGapOK\r\n    strategy.entry(\"C-Short\", strategy.short)\r\n\r\n// === TP/SL in points (Tight risk management) ===\r\nif strategy.position_size > 0\r\n    e = strategy.position_avg_price\r\n    strategy.exit(\"TP/SL Long\", from_entry=\"C-Long\", limit=e + tpPts, stop=e - slPts)\r\nif strategy.position_size < 0\r\n    e = strategy.position_avg_price\r\n    strategy.exit(\"TP/SL Short\", from_entry=\"C-Short\", limit=e - tpPts, stop=e + slPts)\r\n\r\n// === Close outside session ===\r\nif flatOutside and not inSession and strategy.position_size != 0\r\n    strategy.close_all(\"Fuera de sesiÃ³n\")\r\n\r\n// === Visual (Plots) ===\r\nplot(smaFast, color=color.new(color.teal, 0), title=\"SMA 5 (\"+TF+\")\")\r\nplot(smaSlow, color=color.new(color.orange, 0), title=\"SMA 15 (\"+TF+\")\")\r\nplotshape(longSignalConfirmed and canTrade and isFlat, title=\"Confirmed Buy\", style=shape.triangleup,\r\n location=location.belowbar, color=color.new(color.lime,0), size=size.small, text=\"Confirmed Long\")\r\nplotshape(shortSignalConfirmed and canTrade and isFlat and shortGapOK, title=\"Confirmed Sell\", style=shape.triangledown,\r\n location=location.abovebar, color=color.new(color.red,0), size=size.small, text=\"Confirmed Short\")"
  },
  {
    "url": "D9dkKBUh-W-R-Pullback-EMA-Trend-TS-Indie",
    "name": "W%R Pullback+EMA Trend [TS_Indie]",
    "description": "ðŸ”°  Core Concept of the Strategy \nThe main idea is  â€œTrend-Following with Momentum Pullback.â€ \nThis means trading  in the direction of the main trend (defined by EMA)  while using  Williams %R  to identify  pullback entries  (buying the dip or selling the rally) where momentum returns to the trend direction.\n\nðŸ“Š  Indicators Used \n\t1.\t EMA Fast  â€“ Defines the short-term trend.\n\t2.\t EMA Slow  â€“ Defines the long-term trend (used as a trend filter).\n\t3.\t Williams %R \n\t     â€¢\tOverbought zone: above -20\n\t     â€¢\tOversold zone: below -80 \n\nâš™ï¸  Entry Rules \nðŸ”¹  Buy Setup \n  \n\t1.\t EMA Fast > EMA Slow  â†’ Uptrend condition.\n\t2.\t Williams %R  on the previous candle dropped below -80, and on the current candle, it  crosses back above -80  â†’ indicates momentum returning to the upside.\n\t3.\tCurrent close is above EMA Fast.\n\t4.\t Entry Buy  at the close of the candle where %R crosses above -80.\n\nðŸŽ¯  Entry, Stop Loss, and Take Profit \n\t1.\t Entry : At the candle close where the signal occurs.\n\t2.\t Stop Loss : At the lowest low between the current and previous candles.\n\t3.\t Take Profit : Calculated based on entry price and stop loss distance multiplied by the  Risk/Reward Ratio. \n\nðŸ”¹  Sell Setup \n  \n\t1.\t EMA Fast < EMA Slow  â†’ Downtrend condition.\n\t2.\t Williams %R  on the previous candle went above -20, and on the current candle, it  crosses back below -20  â†’ indicates renewed selling momentum.\n\t3.\t Current price is below EMA Fast. \n\t4.\t Entry Sell  at the close of the candle where %R crosses below -20.\n\nðŸŽ¯  Entry, Stop Loss, and Take Profit \n\t1.\t Entry : At the candle close where the signal occurs.\n\t2.\t Stop Loss : At the highest high between the current and previous candles.\n\t3.\t Take Profit : Calculated based on entry price and stop loss distance multiplied by the  Risk/Reward Ratio. \n\nâš™ï¸  Optional Parameters \n  \n\tâ€¢\tCustom  Risk/Reward Ratio  for Take Profit.\n\tâ€¢\tOption to  add ATR buffer  to Stop Loss.\n\tâ€¢\tAdjustable  EMA Fast period. \n\tâ€¢\tAdjustable  EMA Slow period. \n\tâ€¢\tAdjustable  Williams %R period. \n\tâ€¢\tOption to enable  Long only / Short only  positions.\n\tâ€¢\tCustomizable  Backtest start and end date. \n\tâ€¢\tCustomizable  trading session time. \n\nâ°  Alert Function \nAlerts display:\n\tâ€¢\tEntry price\n\tâ€¢\tStop Loss price\n\tâ€¢\tTake Profit price\n\nGuys, try adjusting the parameters yourselves!\nIâ€™ve been tweaking the settings for several days and managed to get great results on XAU/USD in the 5-minute timeframe.\nI think this strategy is quite interesting and could potentially deliver good results on other instruments as well.\n\nâš ï¸ Disclaimer \nThis indicator is designed for educational and research purposes only.\nIt does not guarantee profits and should not be considered financial advice.\nTrading in financial markets involves significant risk, including the potential loss of capital.\n",
    "image_url": "D9dkKBUh",
    "author": "Truth_Strategy_Indie",
    "likes": 161,
    "type": "strategy",
    "created": "2025-11-22",
    "updated": "2025-11-22",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// Â© Truth_Strategy_Indie\r\n\r\n//@version=6\r\nstrategy(\"W%R Pullback+EMA Trend [TS_Indie]\", overlay=true, max_labels_count=500 , max_lines_count = 500 ,max_boxes_count = 500, max_bars_back = 5000 , margin_long=0, margin_short=0 ,  initial_capital=10000 , process_orders_on_close = true )\r\n\r\nGROUP_1 = \"====== Conditions Entry ======\"\r\nGROUP_2 = \"====== Setup Risk/Reward Ratio ======\"\r\nGROUP_3 = \"====== Setup Stop loss ATR ======\"\r\n\r\n// === Input Parameters ===\r\nrr_ratio = input.float(1.5, \"Risk Reward Ratio\", step=0.1 , inline=\"1\" , group = GROUP_2 )\r\nlength_atr = input.int(title=\"Length ATR\", defval=14, minval=1 , inline=\"2\" , group = GROUP_3 )\r\nx_ATR = input.float( 0 , \"x ATR\", step=0.1 , inline=\"2\" , group = GROUP_3 )\r\n\r\nmaTypeInput_fast = input.string(\"EMA\", \"Type MA Fast\", options = [\"EMA\", \"SMA\", \"SMMA (RMA)\", \"WMA\", \"VWMA\"], group = GROUP_1 , inline=\"3\" , display = display.data_window)\r\nema_fast_len = input.int(20, \"Length Fast\" , inline=\"3.5\" , group = GROUP_1 )\r\nsrc_1 = input(close, \"Source\" , inline=\"3.5\" , group = GROUP_1 )\r\n\r\nmaTypeInput_slow = input.string(\"EMA\", \"Type MA Slow\", options = [\"EMA\", \"SMA\", \"SMMA (RMA)\", \"WMA\", \"VWMA\"], group = GROUP_1 , inline=\"4\", display = display.data_window)\r\nema_slow_len = input.int(250, \"Length Slow\", inline=\"4.5\" , group = GROUP_1 )\r\nsrc_2 = input(close, \"Source\" , inline=\"4.5\" , group = GROUP_1 )\r\n\r\nwr_len = input.int(37, \"Williams %R Length\", inline=\"5\"  , group = GROUP_1 )\r\nOverbought = input.int(-20, \"Ov_Bought\", inline=\"6\" , group = GROUP_1 )\r\nOversold = input.int(-80, \"Ov_Sold\", inline=\"6\" , group = GROUP_1 )\r\nlong_t = input(true,\"Entry Longã…¤ã…¤\", inline=\"10\" , group = GROUP_1 )\r\nshort_t = input(true, \"Entry Short\" , inline=\"10\" , group = GROUP_1 )\r\n\r\n//====== Time Filter ======\r\nTime_Filter = \"====== Time Filter ======\"\r\ns_date = input.time(timestamp(\"01 Jan 1970\"),\"Start\" , inline=\"1\" , group = Time_Filter )\r\nen_date = input.time(timestamp(\"01 Jan 2500\"), \"End \" , inline=\"2\" , group = Time_Filter )\r\n\r\ncon_date = time >= s_date and time <= en_date\r\n//======== session ======== \r\n_session(sess) =>\r\n    not na(time(timeframe.period, sess, \"UTC+0\" ))\r\n\r\ns_New_York = input.bool( false ,\"New York\" , inline = \"3\" , group = Time_Filter )\r\nt_New = input.session( '1300-2200', \"\" , inline = \"3\" , group = Time_Filter )\r\nSession_1 = _session(t_New) , cf_ses1 = s_New_York ? Session_1 : false\r\n\r\ns_London = input.bool( false ,\"London\" , inline = \"4\" , group = Time_Filter )\r\nt_Lon = input.session( '0700-1600' , \"\" , inline = \"4\" , group = Time_Filter )\r\nSession_2 = _session(t_Lon) , cf_ses2 = s_London ? Session_2 : false\r\n\r\ns_Tokyo = input.bool( false ,\"Tokyo\" , inline = \"5\" , group = Time_Filter )\r\nt_Tokyo = input.session( '0000-0900' , \"\" , inline = \"5\" , group = Time_Filter )\r\nSession_3 = _session(t_Tokyo) , cf_ses3 = s_Tokyo ? Session_3 : false\r\n\r\ns_Sydney = input.bool( false ,\"Sydney\" , inline = \"6\" , group = Time_Filter )\r\nt_Syd = input.session( '2100-0600' , \"\" , inline = \"6\" , group = Time_Filter )\r\nSession_4 = _session(t_Syd) , cf_ses4 = s_Sydney ? Session_4 : false\r\n\r\nses_check = s_New_York or s_London or s_Tokyo or s_Sydney\r\ntime_con = cf_ses1 or cf_ses2 or cf_ses3 or cf_ses4\r\ncon_time = ses_check ? time_con : true\r\n\r\n//======== Table ======== \r\nposition(select) =>\r\n    switch select\r\n        \"bottom_right\"  => position.bottom_right\r\n        \"bottom_center\" => position.bottom_center\r\n        \"bottom_left\"   => position.bottom_left\r\n        \"top_center\"    => position.top_center\r\n        \"top_left\"      => position.top_left\r\n        \"top_right\"     => position.top_right\r\n        \"mid_center\"    => position.middle_center\r\n        \"mid_left\"      => position.middle_left\r\n        \"mid_right\"     => position.middle_right\r\n\r\nresult_group = \"====== Trading Result Table ======\"\r\nShow_result = input.bool( true ,\"Show Result\" , inline = \"1\" , group = result_group ,tooltip = \"The Profit Factor here is calculated using the formula:\\n\\(Number of Wins x Risk-Reward Ratio) / Number of Losses\\n\\This formula is based on the assumption that the risk per losing trade is fixed â€” for example, every losing trade costs exactly 1% of the account.\\n\\Because of this assumption, the calculated Profit Factor will not match TradingViewâ€™s result, since TradingView uses:\\n\\Gross Profit / Gross Loss\\n\\And in actual TradingView trades, the loss amount of each trade is not always equal, because the system doesnâ€™t enforce a fixed-risk rule for every losing trade. \" )\r\nselect_position = input.string(\"bottom_right\", \"\", options = [\"bottom_right\", \"bottom_center\", \"bottom_left\", \"top_center\", \"top_left\" , \"top_right\" , \"mid_center\" , \"mid_left\" , \"mid_right\" ], group = result_group  , inline=\"1\" , display = display.data_window)\r\nFactor_up = input.float( 1.3 ,\"Profit Factor > \" , step=0.1 , inline = \"2\" , group = result_group )\r\nFactor_up_color = input(title = \"   \" , defval = #a5d6a7  , inline = \"2\" , group = result_group)\r\nFactor_donw = input.float( 1 ,\"Profit Factor < \" , step=0.1 , inline = \"3\" , group = result_group )\r\nFactor_donw_color = input(title = \"   \" , defval = #faa1a4  , inline = \"3\" , group = result_group)\r\n\r\n// MA Calculation\r\nma(source, length, MAtype) =>\r\n\tswitch MAtype\r\n\t\t\"SMA\"                   => ta.sma(source, length)\r\n\t\t\"EMA\"                   => ta.ema(source, length)\r\n\t\t\"SMMA (RMA)\"            => ta.rma(source, length)\r\n\t\t\"WMA\"                   => ta.wma(source, length)\r\n\t\t\"VWMA\"                  => ta.vwma(source, length)\r\n\r\n\r\natr_sl = ta.ema(ta.tr(true), length_atr)\r\n\r\nvar int c_order_buy = 0 , var int c_order_sell = 0\r\nbool pending_buy = false , bool pending_sell = false\r\nvar float stop_loss_long = 0 , var float stop_loss_short = 0\r\nvar float take_profit_long = 0 , var float take_profit_short = 0\r\nvar float open_long = 0 , var float open_short = 0\r\nvar int time_buy = 0 , var int time_sell = 0\r\n\r\n// === Indicator Calculation ===\r\nema_fast = ma(src_1, ema_fast_len, maTypeInput_fast)\r\nema_slow = ma(src_2, ema_slow_len, maTypeInput_slow)\r\n\r\n_pr(length) =>\r\n    max = ta.highest(length)\r\n    min = ta.lowest(length)\r\n    100 * (close - max) / (max - min)\r\nwr = _pr(wr_len)\r\n\r\n// === Trend Filter ===\r\nuptrend = ema_fast > ema_slow\r\ndowntrend = ema_fast < ema_slow\r\n\r\nWr_Overbought = math.abs(Overbought)*-1\r\nWr_Oversold = math.abs(Oversold)*-1\r\n\r\nwr_crossover_up = ( wr[1]<Wr_Oversold and wr > Wr_Oversold ) and uptrend\r\nwr_crossover_down = ( wr[1] > Wr_Overbought and wr < Wr_Overbought ) and downtrend\r\n\r\n// === Entry Conditions ===\r\nbuy_signal = barstate.isconfirmed and long_t and close > ema_fast and wr_crossover_up  and strategy.position_size == 0 and con_time and con_date\r\nsell_signal = barstate.isconfirmed and short_t and close < ema_fast and wr_crossover_down and strategy.position_size == 0 and con_time and con_date\r\n\r\n// === Position Size ===\r\nrisk_pips = atr_sl * x_ATR\r\nvalue_remove2(va1 , va2 , size) =>\r\n    array.remove(va1,size) , array.remove(va2,size)\r\nvar tp_buy = array.new_float(0,na) , var sl_buy = array.new_float(0,na)  \r\nvar tp_sell = array.new_float(0,na) , var sl_sell = array.new_float(0,na)  \r\n\r\n// === Long Entry ===\r\nif (buy_signal) and barstate.isconfirmed \r\n    sl_cal_long = low < low[1] ? low : low[1]\r\n    stop_loss_long := sl_cal_long - risk_pips\r\n    take_profit_long := close + (close - stop_loss_long)*rr_ratio\r\n    c_order_buy += 1 \r\n    cs_buy = str.tostring(c_order_buy)\r\n    strategy.entry(\"Long \"+cs_buy, strategy.long , na , limit = close , stop = close )\r\n    strategy.exit(\"Long Exit \"+cs_buy , \"Long \"+cs_buy , stop = stop_loss_long , limit = take_profit_long , comment_profit = \"Long(Tp) \"+cs_buy ,comment_loss = \"Long(SL) \"+cs_buy )\r\n    p_entry = \"\\n\\nEntry price = \"+str.tostring( close , format.mintick)\r\n    p_sl = \"\\n\\nStop loss = \"+str.tostring(stop_loss_long, format.mintick)\r\n    p_tp = \"\\n\\nTarget profit = \"+str.tostring(take_profit_long, format.mintick)\r\n    alert(\"Long_\"+p_entry+p_sl+p_tp, alert.freq_all)\r\n    pending_buy := true , open_long := close , time_buy := time\r\n    array.unshift(tp_buy, take_profit_long) , array.unshift(sl_buy,stop_loss_long)\r\n\r\n// === Short Entry ===\r\nif (sell_signal) and barstate.isconfirmed \r\n    sl_cal_short = high > high[1] ? high : high[1]\r\n    stop_loss_short := sl_cal_short + risk_pips\r\n    take_profit_short := close - (stop_loss_short - close)*rr_ratio\r\n    c_order_sell += 1\r\n    cs_sell = str.tostring(c_order_sell)\r\n    strategy.entry(\"Short \"+cs_sell, strategy.short , na , limit = close , stop = close )\r\n    strategy.exit(\"Short Exit \"+cs_sell ,\"Short \"+cs_sell , stop = stop_loss_short , limit = take_profit_short , comment_profit = \"Short(Tp) \"+cs_sell ,comment_loss = \"Short(SL) \"+cs_sell )\r\n    p_entry = \"\\n\\nEntry price = \"+str.tostring( close , format.mintick)\r\n    p_sl = \"\\n\\nStop loss = \"+str.tostring(stop_loss_short, format.mintick)\r\n    p_tp = \"\\n\\nTarget profit = \"+str.tostring(take_profit_short, format.mintick)\r\n    alert(\"Short_\"+p_entry+p_sl+p_tp, alert.freq_all)\r\n    pending_sell := true , open_short := close  , time_sell := time\r\n    array.unshift(tp_sell, take_profit_short) , array.unshift(sl_sell,stop_loss_short)\r\n\r\n//show pending\r\nn_time = timeframe.in_seconds(timeframe.period) * 1000 * 5\r\ncol_1 = color.rgb(8, 153, 129, 80)  , col_2 = color.rgb(242, 54, 70, 80)  \r\ntext_line2_col = #ffffff , TRANSP = #ffffff00\r\n\r\nbox box_entrybuy_1_his = na , box box_entrybuy_2_his = na\r\nbox box_entrysell_1_his = na , box box_entrysell_2_his = na\r\nlabel lbl_entry_his = na , label lbl_tp_his = na , label lbl_sl_his = na\r\n//show Buy\r\nif pending_buy or strategy.position_size > 0\r\n    box.delete(box_entrybuy_1_his[1]) , box.delete(box_entrybuy_2_his[1]) , label.delete(lbl_entry_his[1]) , label.delete(lbl_tp_his[1]) , label.delete(lbl_sl_his[1])\r\n    box_entrybuy_1_his := box.new(xloc = xloc.bar_time ,left = time_buy , top = take_profit_long, right = time+n_time , bottom = open_long , border_color = col_1 ,bgcolor = col_1)\r\n    box_entrybuy_2_his := box.new(xloc = xloc.bar_time ,left = time_buy , top = open_long, right = time+n_time , bottom = stop_loss_long , border_color = col_2 ,bgcolor = col_2)\r\n    lbl_entry_his := label.new(time+n_time, open_long , str.tostring(open_long,format.mintick) ,xloc = xloc.bar_time, color = TRANSP, textcolor = text_line2_col, style = label.style_label_center, size = size.small)\r\n    lbl_tp_his := label.new(time+n_time, take_profit_long , str.tostring(take_profit_long,format.mintick),xloc = xloc.bar_time, color = TRANSP, textcolor = text_line2_col, style = label.style_label_center, size = size.small)\r\n    lbl_sl_his := label.new(time+n_time, stop_loss_long , str.tostring(stop_loss_long,format.mintick) ,xloc = xloc.bar_time, color = TRANSP, textcolor = text_line2_col, style = label.style_label_center, size = size.small)\r\n\r\n//show sell\r\nif  pending_sell or strategy.position_size < 0\r\n    box.delete(box_entrysell_1_his[1]) , box.delete(box_entrysell_2_his[1]) , label.delete(lbl_entry_his[1]) , label.delete(lbl_tp_his[1]) , label.delete(lbl_sl_his[1])\r\n    box_entrysell_1_his := box.new(xloc = xloc.bar_time , left = time_sell , top = take_profit_short, right = time+n_time  , bottom = open_short , border_color = col_1 ,bgcolor = col_1)\r\n    box_entrysell_2_his := box.new(xloc = xloc.bar_time , left = time_sell , top = open_short, right = time+n_time  , bottom = stop_loss_short , border_color = col_2 ,bgcolor = col_2)\r\n    lbl_entry_his := label.new(time+n_time , open_short , str.tostring(open_short,format.mintick) ,xloc = xloc.bar_time, color = TRANSP, textcolor = text_line2_col, style = label.style_label_center, size = size.small)\r\n    lbl_tp_his := label.new(time+n_time , take_profit_short , str.tostring(take_profit_short,format.mintick),xloc = xloc.bar_time, color = TRANSP, textcolor = text_line2_col, style = label.style_label_center, size = size.small)\r\n    lbl_sl_his := label.new(time+n_time , stop_loss_short , str.tostring(stop_loss_short,format.mintick) ,xloc = xloc.bar_time, color = TRANSP, textcolor = text_line2_col, style = label.style_label_center, size = size.small)\r\n\r\nvar int Loss_Buy = 0 , var int Win_Buy = 0 , var float sl_trade_buy = na , var float tp_trade_buy = na\r\nvar int Loss_Sell = 0 , var int Win_Sell = 0 , var float sl_trade_sell = na , var float tp_trade_sell = na\r\nif Show_result\r\n    //Check SL buy\r\n    if array.size(sl_buy) > 0 and not na(array.get(sl_buy,0))\r\n        sl_trade_buy := array.get(sl_buy,0)\r\n    if low <= sl_trade_buy and ( strategy.position_size[1] > 0 or buy_signal[1] ) and array.size(sl_buy) > 0\r\n        sl_trade_buy := na\r\n        for i = array.size(sl_buy)-1 to 0\r\n            if low <= array.get(sl_buy,i) and not na(array.get(sl_buy,i))\r\n                Loss_Buy += 1\r\n                value_remove2( tp_buy , sl_buy , i)\r\n    //check TP buy\r\n    if array.size(tp_buy) > 0 and not na(array.get(tp_buy,0))\r\n        tp_trade_buy := array.get(tp_buy,0)\r\n    if high >= tp_trade_buy and ( strategy.position_size[1] > 0 or buy_signal[1] ) and array.size(tp_buy) > 0\r\n        tp_trade_buy := na\r\n        for i = array.size(tp_buy)-1 to 0\r\n            if high >= array.get(tp_buy,i) and not na(array.get(tp_buy,i))\r\n                Win_Buy += 1 \r\n                value_remove2( tp_buy , sl_buy , i)\r\n    //Check SL Sell\r\n    if array.size(sl_sell) > 0 and not na(array.get(sl_sell,0))\r\n        sl_trade_sell := array.get(sl_sell,0)\r\n    if high >= sl_trade_sell and ( strategy.position_size[1] < 0 or sell_signal[1] ) and array.size(sl_sell) > 0\r\n        sl_trade_sell := na\r\n        for i = array.size(sl_sell)-1 to 0\r\n            if high >= array.get(sl_sell,i) and not na(array.get(sl_sell,i))\r\n                Loss_Sell += 1\r\n                value_remove2( tp_sell , sl_sell , i)\r\n    //check TP Sell\r\n    if array.size(tp_sell) > 0 and not na(array.get(tp_sell,0))\r\n        tp_trade_sell := array.get(tp_sell,0)\r\n    if low <= tp_trade_sell and ( strategy.position_size[1] < 0 or sell_signal[1] ) and array.size(tp_sell) > 0\r\n        tp_trade_sell := na\r\n        for i = array.size(tp_sell)-1 to 0\r\n            if low <= array.get(tp_sell,i) and not na(array.get(tp_sell,i))\r\n                Win_Sell += 1 \r\n                value_remove2( tp_sell , sl_sell , i)\r\n\r\n// === Plotting ===\r\np1 = plot(ema_fast, color= #f23645, title=\"EMA fast\")\r\np2 = plot(ema_slow, color=#ffee58, title=\"EMA slow\")\r\n\r\nfill(p1, p2, color = ema_fast > ema_slow ? color.rgb(67, 160, 72, 85) : color.rgb(244, 67, 54, 85))\r\nplot(wr,\"Williams %R\" ,color = color.new(color.blue, 0), display = display.status_line , precision = 2  )\r\n\r\ncon_Overbought = wr > math.abs(Overbought)*-1 and downtrend\r\ncon_Oversold = wr < math.abs(Oversold)*-1 and uptrend\r\n\r\nbarcolor( con_Oversold ? color.blue : na ,title = \"Bar Oversold\")\r\nbarcolor( wr_crossover_up ? color.orange  : na ,title = \"Bar Crossover Up\")\r\n\r\nbarcolor( con_Overbought ? color.aqua : na ,title = \"Bar Overbought\")\r\nbarcolor( wr_crossover_down ? color.fuchsia : na ,title = \"Bar Crossover Down\")\r\n\r\nbgcolor(s_New_York and cf_ses1 ? color.rgb(255, 251, 0, 92) : na ,title = \"New York\")\r\nbgcolor(s_London and cf_ses2 ? color.rgb(255, 0, 255, 92) : na ,title = \"London\")\r\nbgcolor(s_Tokyo and cf_ses3? color.rgb(111, 255, 82, 92) : na ,title = \"Tokyo\")\r\nbgcolor(s_Sydney and cf_ses4? color.rgb(82, 122, 255, 92) : na ,title = \"Sydney\")\r\n\r\nLocation_session = ((9*60*60) / timeframe.in_seconds(timeframe.period)) / 2 \r\nLbl_New_York = not cf_ses1 and cf_ses1 != cf_ses1[1] and s_New_York and t_New == '1300-2200' and timeframe.in_seconds(timeframe.period) <= 32400\r\nplotshape( Lbl_New_York , \"Session New York\", shape.labeldown, location.bottom, na , offset = -Location_session  , text = \"New York\", textcolor = #fffb00, size = size.tiny, display = display.all - display.status_line, editable = false)\r\nLbl_London = not cf_ses2 and cf_ses2 != cf_ses2[1] and s_London and t_Lon == '0700-1600' and timeframe.in_seconds(timeframe.period) <= 32400\r\nplotshape( Lbl_London , \"Session London\", shape.labeldown, location.bottom, na , offset = -Location_session  , text = \"London\", textcolor = #ff00ff , size = size.tiny, display = display.all - display.status_line, editable = false)\r\nLbl_Tokyo = not cf_ses3 and cf_ses3 != cf_ses3[1] and s_Tokyo and t_Tokyo == '0000-0900' and timeframe.in_seconds(timeframe.period) <= 32400\r\nplotshape( Lbl_Tokyo , \"Session Tokyo\", shape.labeldown, location.bottom, na , offset = -Location_session  , text = \"Tokyo\", textcolor = #6fff52 , size = size.tiny, display = display.all - display.status_line, editable = false)\r\nLbl_Sydney = not cf_ses4 and cf_ses4 != cf_ses4[1] and s_Sydney and t_Syd == '2100-0600' and timeframe.in_seconds(timeframe.period) <= 32400\r\nplotshape( Lbl_Sydney , \"Session Sydney\", shape.labeldown, location.bottom, na , offset = -Location_session  , text = \"Sydney\", textcolor = #527aff , size = size.tiny, display = display.all - display.status_line, editable = false)\r\n\r\n\r\nvar table Balane_status = table.new( position(select_position) , 6 , 6 , border_width = 1)\r\n\r\nTotal_all = Win_Buy + Loss_Buy + Win_Sell + Loss_Sell\r\nif Show_result and (Total_all > Total_all[1])\r\n    Long_all = Win_Buy + Loss_Buy , Short_all = Win_Sell + Loss_Sell\r\n    Total_win = Win_Buy + Win_Sell , Total_loss = Loss_Buy + Loss_Sell\r\n    Factor_all = (Total_win*rr_ratio)/Total_loss\r\n    Factor_buy = (Win_Buy*rr_ratio)/Loss_Buy\r\n    Factor_sell = (Win_Sell*rr_ratio)/Loss_Sell\r\n    txt1_1 = str.tostring(Total_all,format.volume)\r\n    txt1_2 = str.tostring(Long_all,format.volume)\r\n    txt1_3 = str.tostring(Short_all,format.volume)\r\n    txt2_1 = str.tostring(Total_win,format.volume)\r\n    txt3_1 = str.tostring(Total_loss,format.volume)\r\n    txt4_1 = str.tostring((Total_win/Total_all)*100,format.percent)\r\n    txt5_1 = str.format(\"{0,number,#.##}\", Factor_all )\r\n\r\n    txt2_2 = str.tostring(Win_Buy,format.volume)\r\n    txt3_2 = str.tostring(Loss_Buy,format.volume)\r\n    txt4_2 = str.tostring((Win_Buy/Long_all)*100,format.percent)\r\n    txt5_2 = str.format(\"{0,number,#.##}\", Factor_buy )\r\n\r\n    txt2_3 = str.tostring(Win_Sell,format.volume)\r\n    txt3_3 = str.tostring(Loss_Sell,format.volume)\r\n    txt4_3 = str.tostring((Win_Sell/Short_all)*100,format.percent)\r\n    txt5_3 = str.format(\"{0,number,#.##}\", Factor_sell)\r\n\r\n    Factor_all_color = Factor_all > Factor_up ? Factor_up_color : Factor_all < Factor_donw ? Factor_donw_color : color.white \r\n    Factor_buy_color = Factor_buy > Factor_up ? Factor_up_color : Factor_buy < Factor_donw ? Factor_donw_color : color.white \r\n    Factor_sell_color = Factor_sell > Factor_up ? Factor_up_color : Factor_sell < Factor_donw ? Factor_donw_color : color.white \r\n\r\n    table.cell(Balane_status , 1 , 1 , txt1_1 , bgcolor = color.black , text_color = Factor_all_color )\r\n    table.cell(Balane_status , 2 , 1 , txt2_1 , bgcolor = color.black , text_color = Factor_all_color )\r\n    table.cell(Balane_status , 3 , 1 , txt3_1 , bgcolor = color.black , text_color = Factor_all_color )\r\n    table.cell(Balane_status , 4 , 1 , txt4_1 , bgcolor = color.black , text_color = Factor_all_color )\r\n    table.cell(Balane_status , 5 , 1 , txt5_1 , bgcolor = color.black , text_color = Factor_all_color )\r\n\r\n    table.cell(Balane_status , 1 , 2 , txt1_2 , bgcolor = color.black , text_color = Factor_buy_color )\r\n    table.cell(Balane_status , 2 , 2 , txt2_2 , bgcolor = color.black , text_color = Factor_buy_color )\r\n    table.cell(Balane_status , 3 , 2 , txt3_2 , bgcolor = color.black , text_color = Factor_buy_color )\r\n    table.cell(Balane_status , 4 , 2 , txt4_2 , bgcolor = color.black , text_color = Factor_buy_color )\r\n    table.cell(Balane_status , 5 , 2 , txt5_2 , bgcolor = color.black , text_color = Factor_buy_color )\r\n    \r\n    table.cell(Balane_status , 1 , 3 , txt1_3 , bgcolor = color.black , text_color = Factor_sell_color )\r\n    table.cell(Balane_status , 2 , 3 , txt2_3 , bgcolor = color.black , text_color = Factor_sell_color )\r\n    table.cell(Balane_status , 3 , 3 , txt3_3 , bgcolor = color.black , text_color = Factor_sell_color )\r\n    table.cell(Balane_status , 4 , 3 , txt4_3 , bgcolor = color.black , text_color = Factor_sell_color )\r\n    table.cell(Balane_status , 5 , 3 , txt5_3 , bgcolor = color.black , text_color = Factor_sell_color )\r\n\r\n    table.cell(Balane_status , 0 , 1 , \"Total\" , bgcolor = color.black , text_color = color.white )\r\n    table.cell(Balane_status , 0 , 2 , \"Long\" , bgcolor = color.black , text_color = color.white )\r\n    table.cell(Balane_status , 0 , 3 , \"Short\" , bgcolor = color.black , text_color = color.white )\r\n    table.cell(Balane_status , 1 , 0 , \"All\" , bgcolor = color.black , text_color = color.white )\r\n    table.cell(Balane_status , 2 , 0 , \"Win\" , bgcolor = color.black , text_color = color.white )\r\n    table.cell(Balane_status , 3 , 0 , \"Loss\" , bgcolor = color.black , text_color = color.white )\r\n    table.cell(Balane_status , 4 , 0 , \"Winrate\" , bgcolor = color.black , text_color = color.white )\r\n    table.cell(Balane_status , 5 , 0 , \"Profit\\n\\Factor\" , bgcolor = color.black , text_color = color.white )\r\n"
  }
]
