[
  {
    "url": "8I2576zL-Mutanabby-AI-ONEUSDT-MR1",
    "name": "Mutanabby_AI | ONEUSDT_MR1 ",
    "description": "\nONEUSDT Mean-Reversion Strategy | 74.68% Win Rate | 417% Net Profit\n\n\nThis is a long-only mean-reversion strategy designed specifically for ONEUSDT on the 1-hour timeframe. The core logic identifies oversold conditions following sharp declines and enters positions when selling pressure exhausts, capturing the subsequent recovery bounce.\n\nBacktested Period: June 2019 â€“ December 2025 (~6 years)\n\n Performance Summary\n\n| Metric | Value |\n|--------|-------|\n| Net Profit | +417.68% |\n| Win Rate | 74.68% |\n| Profit Factor | 4.019 |\n| Total Trades | 237 |\n| Sharpe Ratio | 0.364 |\n| Sortino Ratio | 1.917 |\n| Max Drawdown | 51.08% |\n| Avg Win | +3.14% |\n| Avg Loss | -2.30% |\n| Buy & Hold Return | -80.44% |\n\n\nStrategy Logic :\n\n Entry Conditions (Long Only): \n\nThe strategy seeks confluence of three conditions that identify exhausted selling:\n\n1. Prior Move Filter:*The price change from 5 bars ago to 3 bars ago must be â‰¥ -7% (ensures we're not entering during freefall)\n\n2. Current Move Filter: The price change over the last 2 bars must be â‰¤ 0% (confirms momentum is stalling or reversing)\n\n3.  Three-Bar Decline: The price change from 5 bars ago to 3 bars ago must be â‰¤ -5% (confirms a significant recent drop occurred)\n\nWhen all three conditions align, the strategy identifies a potential reversal point where sellers are exhausted.\n\n Exit Conditions: \n\n- Primary Exit: Close above the previous bar's high while the open of the previous bar is at or below the close from 9 bars ago (profit-taking on strength)\n- Trailing Stop: 11x ATR trailing stop that locks in profits as price rises\n\n\n Risk Management\n \n- Position Sizing:Fixed position based on account equity divided by entry price\n- Trailing Stop:11Ã— ATR (14-period) provides wide enough room for crypto volatility while protecting gains\n- Pyramiding:Up to 4 orders allowed (can scale into winning positions)\n- **Commission:** 0.1% per trade (realistic exchange fees included)\n\n\n\n Important Disclaimers\n \n\nâš ï¸ This is NOT financial advice.\n\n- Past performance does not guarantee future results\n- Backtest results may contain look-ahead bias or curve-fitting\n- Real trading involves slippage, liquidity issues, and execution delays\n- This strategy is optimized for ONEUSDT specifically â€” results may differ on other pairs\n- Always test  before risking real capital\n\n\n Recommended Usage\n \n- Timeframe:*1H (as designed)\n- Pair: ONEUSDT (Binance)\n- Account Size: Ensure sufficient capital to survive max drawdown\n\n\n Source Code\n \n\n\n Feedback Welcome\n \n\nI'm sharing this strategy freely for educational purposes. Please:\n- Drop a comment with your backtesting results any you analysis \n- Share any modifications that improve performance\n- Let me know if you spot any issues in the logic\n\n Happy trading\n \n\n\n\nAs a quant trader, do you think this strategy will survive in live trading?\nYes or No? And why?\nI want to hear from you guys",
    "image_url": "8I2576zL",
    "author": "Mutanabby_AI",
    "likes_count": 36,
    "comments_count": 1,
    "script_type": "strategy",
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=5\r\nstrategy(\"ONEUSDT(1)_MR1\", overlay=true, initial_capital=100, default_qty_type=strategy.fixed, default_qty_value=100)\r\n\r\n// Input Parameters\r\nvar float TRAIL_ATR_MULT = 11.0\r\nvar int ATR_LENGTH = 14\r\nvar float ACCOUNT_SIZE = 100.0\r\n\r\n\r\n// Tracking Variables\r\nvar int profx = 0\r\nvar float trailLevel = na\r\nvar int barsInTrade = 0\r\n\r\n// Calculate Technical Indicators\r\natr = ta.atr(ATR_LENGTH)\r\n\r\n// Position Size Calculation\r\npositionSize = math.floor(ACCOUNT_SIZE / close)\r\n\r\n// Calculate Price Changes\r\npercentChange2Bars(offset) =>\r\n    ((close[offset] - close[offset+2]) / close[offset+2]) * 100\r\n\r\n// Entry Conditions\r\n\r\npriorMove = percentChange2Bars(3) >= -7\r\ncurrentMove = percentChange2Bars(0) <= 0\r\nthreeBarBack = percentChange2Bars(3) <= -5\r\n\r\nlongCondition =  priorMove and currentMove and threeBarBack\r\n\r\n// Exit Conditions\r\nexitCondition = close > high[1] and open[1] <= close[9]\r\n\r\n// Track Trade Duration and Profitable Closes\r\nif (strategy.position_size > 0)\r\n    barsInTrade := barsInTrade + 1\r\n    if (close >= strategy.position_avg_price)\r\n        profx := profx + 1\r\nelse\r\n    barsInTrade := 0\r\n\r\n// Trailing Stop Logic\r\nif (strategy.position_size > 0)\r\n    float newTrail = close - (atr * TRAIL_ATR_MULT)\r\n    trailLevel := na(trailLevel) ? newTrail : math.max(trailLevel, newTrail)\r\nelse\r\n    trailLevel := na\r\n\r\n// Execute Strategy\r\nif (longCondition)\r\n    strategy.entry(\"Long\", strategy.long, qty=positionSize)\r\n    profx := 0\r\n\r\n// Exit Conditions\r\nif (strategy.position_size > 0)\r\n    // Trailing Stop\r\n    strategy.exit(\"Trail\", \"Long\", stop=trailLevel)\r\n    \r\n    // Signal Exit\r\n    if (exitCondition)\r\n        strategy.close(\"Long\", comment=\"Signal Exit\")\r\n    \r\n\r\n\r\n// Visualization\r\nplot(strategy.position_size > 0 ? trailLevel : na, \"Trailing Stop\", color=color.red, style=plot.style_stepline)\r\nplotshape(longCondition, \"Entry\", location=location.belowbar, color=color.green, style=shape.triangleup, size=size.small)\r\nplotshape(exitCondition and strategy.position_size > 0, \"Exit\", location=location.abovebar, color=color.red, style=shape.triangledown, size=size.small)"
  },
  {
    "url": "ZWOqYiQq-ORB-Strategy-Extensions-Custom-SL-EOD-Live-Lines",
    "name": "ORB Strategy: Extensions & Custom SL (EOD & Live Lines)",
    "description": "That's a great request. Since you've now built a complex Pine Script Strategy with several user-configurable risk management, targeting, and exit options, the description should focus on the systematic rules used for entering, managing, and exiting trades.\n\nHere is a clear, written description of the trading strategy you have built:\n\nTrading Strategy Description: ORB Extension Breakout with Custom Stop, Live Tracking, and EOD Exit\nThis strategy is a systematic, momentum-based system designed for intraday trading. It operates on the principle of an Opening Range Breakout (ORB), utilizing the initial market consolidation to project high-probability targets, while offering multiple methods for managing risk and enforcing a mandatory end-of-day closure.\n\n1. Market Identification (The Opening Range)\nThe strategy first defines the market's initial boundaries and volatility:\n\nSession Window: The strategy calculates the Opening Range (OR) over a user-defined time period (default: 9:30 AM to 10:30 AM New York Time).\n\nORB Levels: Two key price levels are established and locked once the time window closes:\n\nWick High/Low: The absolute highest and lowest prices of the session. These serve as the entry trigger lines.\n\nBody High/Low (Shaded Range): The highest and lowest open/close prices of the session. The height of this range is used as the basis for calculating all targets and stops.\n\n2. Entry Rule (The Breakout)\nThe strategy waits passively for a breakout that confirms direction and ensures the move has not yet reached its immediate target.\n\nTrigger Condition: A trade is signaled when a candle closes either:\n\nAbove the Wick High (for a Long entry).\n\nBelow the Wick Low (for a Short entry).\n\nConstraint (Fresh Breakout): The entry is invalidated if the breakout candle's price action (High for Long, Low for Short) has already touched or surpassed the projected Take Profit (0.5 Extension) level before the candle closes.\n\nExecution: The entry is a Market Order executed on the candle that meets the trigger conditions, subject to a user-defined Entry Delay (default 0 bars).\n\nDirection Control: The user can select to trade Long Only, Short Only, or Both.\n\n3. Exit and Risk Management\nAll trades are placed with simultaneous Take Profit and Stop Loss orders (a bracket order) upon entry.\n\nA. Take Profit (TP)\nThe Take Profit is set at the 0.5 Extension of the Shaded Range (Body Range).\n\nCalculation: The distance from the Body High/Low to the TP level is exactly 50% of the total height of the Shaded Range.\n\nB. Stop Loss (SL)\nThe Stop Loss is dynamically calculated based on a user-selected method for risk control:\n\nRange 0.5 (Body Range): The SL is placed an equal distance (0.5 times the Body Range height) outside the opposite side of the Body Range.\n\nATR Multiple: The Stop Loss distance is calculated as a user-defined Multiplier times the Average True Range (ATR).\n\nRecent Swing Low/High: The Stop Loss is placed based on a structural low (for Long) or high (for Short) within a user-defined lookback period.\n\nC. End-of-Day (EOD) Exit\nAny open position is forced closed at the market price if it is still open when the user-defined closing time (default: 16:00 HHMM) is reached. This prevents carrying intraday risk overnight.\n\n4. Visualization\nThe strategy includes comprehensive visual cues for analysis:\n\nORB Drawing: Displays the Wick High/Low and the shaded Body Range.\n\nBreakout Signals: Highlights the specific bar where the validated entry signal occurs.\n\nClosed Trades: Draws persistent lines for the Entry and Exit prices of the last few closed trades.\n\nLive Open Trades: Draws persistent lines for the current Entry Price, active Take Profit Level, and active Stop Loss Level for any open position.",
    "image_url": "ZWOqYiQq",
    "author": "ChadAnt",
    "likes_count": 21,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=5\nstrategy(\"ORB Strategy: Extensions & Custom SL (EOD & Live Lines)\", overlay=true, shorttitle=\"ORB Str\")\n\n// ==========================================\n// 1. USER INPUTS\n// ==========================================\n\n// --- STRATEGY SETTINGS ---\ngrp_strategy = \"Strategy Execution\"\nentryDelay = input.int(0, \"Entry Delay (Bars after Break)\", minval=0, maxval=5, group=grp_strategy)\ntradeDirection = input.string(\"Both\", \"Trade Direction\", options=[\"Long Only\", \"Short Only\", \"Both\"], group=grp_strategy)\n\n// --- END-OF-DAY SETTINGS ---\ngrp_eod = \"End-of-Day Exit\"\ncloseTimeInput = input.int(1600, \"Forced Close Time (HHMM)\", minval=0000, maxval=2359, group=grp_eod, tooltip=\"Closes all open trades at this time in the defined timezone.\")\n\n\n// --- VISUALIZATION SETTINGS ---\ngrp_vis = \"Trade Visualization\"\nnumTradesToDisplay = input.int(3, \"Closed Trades to Display (0 to disable)\", minval=0, maxval=50, group=grp_vis)\nnumOpenTradesToDisplay = input.int(1, \"Open Trades (Live Levels) to Display\", minval=0, maxval=10, group=grp_vis)\nlineLength = input.int(15, \"Trade Line Length (Bars)\", minval=5, group=grp_vis)\n\n\n// Stop Loss Management\ngrp_sl = \"Stop Loss Settings\"\nslType = input.string(\"Range 0.5 (Body Range)\", \"Stop Loss Type\", \n     options=[\"Range 0.5 (Body Range)\", \"ATR Multiple\", \"Recent Swing Low/High\"], \n     group=grp_sl) \natrLength = input.int(14, \"ATR Lookback\", minval=1, group=grp_sl)\natrMultiplier = input.float(2.0, \"ATR Multiplier\", minval=0.1, group=grp_sl)\nswingLookback = input.int(10, \"Swing Lookback Bars\", minval=5, group=grp_sl)\n\n\n// --- ORB Time Settings ---\ngrp_time = \"ORB Time Settings\"\nsessionInput = input.session(\"0930-1030\", \"Opening Range Session (NY Time)\", group=grp_time)\nendTimeInput = input.int(1600, \"ORB Lines Stop Time (HHMM)\", group=grp_time)\ntimezone     = \"America/New_York\" \n\n// --- ORB Extension Settings ---\ngrp_ext = \"ORB Extensions (Body Range Based)\"\ntpStep = 0.5 // Fixed Take Profit at 0.5 extension as per request\nstdDevSteps  = input.float(0.5, \"Step Size (e.g. 0.5 = 50% of range)\", step=0.1, group=grp_ext, tooltip=\"This input controls the SL/TP step size.\")\nstdDevQty    = input.int(3, \"Number of Extension Lines\", minval=1, maxval=10, group=grp_ext) \nextLineStyle = input.string(\"Dotted\", \"Extension Line Style\", options=[\"Solid\", \"Dotted\", \"Dashed\"], group=grp_ext)\n\n// --- ORB Visuals (kept for compatibility and analysis) ---\ngrp_style = \"ORB Visuals (Non-Trading)\"\nwickColor = input.color(color.new(color.gray, 0), \"Wick Line Color\", group=grp_style)\nbodyColor = input.color(color.new(color.blue, 0), \"Body Line Color\", group=grp_style)\nfillColor = input.color(color.new(color.blue, 90), \"Body Range Fill Color\", group=grp_style)\nlineWidth = input.int(2, \"Line Width\", minval=1, group=grp_style)\n\n// ==========================================\n// 2. ORB LOGIC\n// ==========================================\n\n// Detect New Day & Time Checks\nisNewDay = ta.change(time(\"D\"))\nnyHour = hour(time, timezone)\nnyMinute = minute(time, timezone)\ncurrNyTime = nyHour * 100 + nyMinute\npastCutoff = currNyTime >= endTimeInput\ninFormingSession = not na(time(timeframe.period, sessionInput + \":1234567\", timezone))\n\n// State Variables\nvar float rHigh = na\nvar float rLow = na\nvar float rBodyHigh = na\nvar float rBodyLow = na\nvar bool bullBreakHappened = false\nvar bool bearBreakHappened = false\nvar float breakOutPrice = na \n// Variables to store TP/SL for live visualization (if strategy.position_size is not zero)\nvar float longStopLossLevel = na\nvar float longTakeProfitLevel = na\nvar float shortStopLossLevel = na\nvar float shortTakeProfitLevel = na\n\n\n// Reset on New Day\nif isNewDay\n    rHigh := na\n    rLow := na\n    rBodyHigh := na\n    rBodyLow := na\n    bullBreakHappened := false\n    bearBreakHappened := false\n    breakOutPrice := na\n\n// Update Logic during session\nif inFormingSession and not inFormingSession[1]\n    rHigh := high\n    rLow := low\n    rBodyHigh := math.max(open, close)\n    rBodyLow := math.min(open, close)\n    bullBreakHappened := false \n    bearBreakHappened := false\nelse if inFormingSession\n    rHigh := math.max(rHigh, high)\n    rLow := math.min(rLow, low)\n    rBodyHigh := math.max(rBodyHigh, math.max(open, close))\n    rBodyLow := math.min(rBodyLow, math.min(open, close))\n\n// ORB Boundary Check\nsessionEnded = not inFormingSession and not na(rHigh)\n\n// Global calculation for range height and TP/SL levels\nbodyRangeHeight = rBodyHigh - rBodyLow \ntpLongLevel = rBodyHigh + (bodyRangeHeight * tpStep)\ntpShortLevel = rBodyLow - (bodyRangeHeight * tpStep)\n\n// New Constraint: Check if the candle high/low hits the TP level before close.\npreTargetHitBullish = high >= tpLongLevel \npreTargetHitBearish = low <= tpShortLevel\n\n// Check for close outside the wick (trigger condition) AND apply the constraint\nbullBreakCondition = sessionEnded and not bullBreakHappened and close > rHigh and not preTargetHitBullish\nbearBreakCondition = sessionEnded and not bearBreakHappened and close < rLow and not preTargetHitBearish\n\n// Update Breakout Status and save price for delayed entry\nif bullBreakCondition\n    bullBreakHappened := true\n    breakOutPrice := close\nif bearBreakCondition\n    bearBreakHappened := true\n    breakOutPrice := close\n\n// ==========================================\n// 3. TARGET & STOP LOSS CALCULATION\n// ==========================================\n\nvar float entryPrice = na\nvar float takeProfit = na\nvar float stopLoss = na\n\n// --- ATR Calculation for SL Option ---\natrValue = ta.atr(atrLength)\n\n// --- Swing High/Low Calculation for SL Option ---\nswingLowPrice = ta.lowest(low, swingLookback)\nswingHighPrice = ta.highest(high, swingLookback)\n\n\n// Function to calculate SL based on user choice\ncalcStopLoss(isLong, currentEntryPrice, rangeHeight, currentATR) =>\n    sl = float(na)\n    if slType == \"Range 0.5 (Body Range)\"\n        sl := isLong ? rBodyLow - (rangeHeight * stdDevSteps) : rBodyHigh + (rangeHeight * stdDevSteps)\n    else if slType == \"ATR Multiple\"\n        sl := isLong ? currentEntryPrice - (currentATR * atrMultiplier) : currentEntryPrice + (currentATR * atrMultiplier)\n    else if slType == \"Recent Swing Low/High\"\n        sl := isLong ? swingLowPrice : swingHighPrice\n    sl\n\n// Function to calculate TP (always 0.5 extension of shaded range)\ncalcTakeProfit(isLong, rangeHeight) =>\n    tp = float(na)\n    tp := isLong ? tpLongLevel : tpShortLevel\n    tp\n\n// ==========================================\n// 4. STRATEGY ENTRY & EXIT LOGIC\n// ==========================================\n\n// Entry Logic: Use `ta.barssince()` to count bars since the breakout condition was met\nbarsSinceBullBreak = ta.barssince(bullBreakCondition)\nbarsSinceBearBreak = ta.barssince(bearBreakCondition)\n\n// --- LONG TRADE ENTRY ---\nif barsSinceBullBreak == entryDelay and (tradeDirection == \"Long Only\" or tradeDirection == \"Both\") and strategy.position_size == 0\n    entryPrice := breakOutPrice[entryDelay]\n    takeProfit := calcTakeProfit(true, bodyRangeHeight)\n    stopLoss := calcStopLoss(true, entryPrice, bodyRangeHeight, atrValue)\n    \n    strategy.entry(\"Long ORB\", strategy.long, comment=\"L-ORB\") \n    \n    strategy.exit(\"TP/SL Long\", \"Long ORB\", limit=takeProfit, stop=stopLoss)\n    breakOutPrice := na // Clear breakout price so it doesn't trigger again\n    \n    // Store levels for live visualization\n    longTakeProfitLevel := takeProfit\n    longStopLossLevel := stopLoss\n\n\n// --- SHORT TRADE ENTRY ---\nif barsSinceBearBreak == entryDelay and (tradeDirection == \"Short Only\" or tradeDirection == \"Both\") and strategy.position_size == 0\n    entryPrice := breakOutPrice[entryDelay]\n    takeProfit := calcTakeProfit(false, bodyRangeHeight)\n    stopLoss := calcStopLoss(false, entryPrice, bodyRangeHeight, atrValue)\n    \n    strategy.entry(\"Short ORB\", strategy.short, comment=\"S-ORB\") \n    \n    strategy.exit(\"TP/SL Short\", \"Short ORB\", limit=takeProfit, stop=stopLoss)\n    breakOutPrice := na // Clear breakout price so it doesn't trigger again\n    \n    // Store levels for live visualization\n    shortTakeProfitLevel := takeProfit\n    shortStopLossLevel := stopLoss\n\n// --- END-OF-DAY CLOSURE LOGIC ---\n// Check if current time has passed the forced close time\ncloseTimeReached = currNyTime >= closeTimeInput\n\nif closeTimeReached and strategy.position_size != 0\n    // Close the entire position at market price\n    strategy.close_all(comment=\"EOD Close\")\n\n\n// ==========================================\n// 5. ORB VISUALS (Existing)\n// ==========================================\n\n// Plotting the ORB Levels\ncanDraw = not na(rHigh) and not pastCutoff\nplot(canDraw ? rHigh : na, color=wickColor, linewidth=1, title=\"Wick High\", style=plot.style_linebr)\nplot(canDraw ? rLow : na, color=wickColor, linewidth=1, title=\"Wick Low\", style=plot.style_linebr)\np_bh = plot(canDraw ? rBodyHigh : na, color=bodyColor, linewidth=lineWidth, title=\"Body High\", style=plot.style_linebr)\np_bl = plot(canDraw ? rBodyLow : na, color=bodyColor, linewidth=lineWidth, title=\"Body Low\", style=plot.style_linebr)\nfill(p_bh, p_bl, color = inFormingSession ? fillColor : color.new(color.white, 100))\n\n// Draw Breakout and Extension Visuals\ngetLineStyle(s) => s == \"Dotted\" ? line.style_dotted : s == \"Dashed\" ? line.style_dashed : line.style_solid\n\n// Visuals for Breakout Candle (Only draw if the conditions were met, including the TP constraint)\nplotshape(bullBreakCondition, style=shape.labelup, location=location.belowbar, color=color.green, text=\"BREAK\", textcolor=color.white, size=size.small)\nplotshape(bearBreakCondition, style=shape.labeldown, location=location.abovebar, color=color.red, text=\"BREAK\", textcolor=color.white, size=size.small)\n\n// Visuals for Extension Lines (Redrawn only on the break candle for neatness)\nif bullBreakCondition or bearBreakCondition\n    // Draw only for the successful break direction\n    if bullBreakCondition\n        line.new(bar_index, tpLongLevel, bar_index + 10, tpLongLevel, color=color.green, style=getLineStyle(extLineStyle), width=2)\n    if bearBreakCondition\n        line.new(bar_index, tpShortLevel, bar_index + 10, tpShortLevel, color=color.red, style=getLineStyle(extLineStyle), width=2)\n\n\n// ==========================================\n// 6. TRADE VISUALIZATION\n// ==========================================\n\n// --- CLOSED TRADES (Existing Logic) ---\ndrawTradeClosed(idx, entry, exit, isLong, tradeNum) => \n    exitColor = exit > entry and isLong or exit < entry and not isLong ? color.green : color.red\n    \n    // Draw lines for Entry, Exit, and Exit Line\n    line.new(idx, entry, idx + lineLength, entry, color=color.new(color.yellow, 0), width=2, style=line.style_solid)\n    line.new(idx, exit, idx + lineLength, exit, color=color.new(exitColor, 0), width=2, style=line.style_dotted)\n    line.new(idx, exit, idx + lineLength, exit, color=color.new(exitColor, 40), width=1, style=line.style_dashed)\n\n    label.new(idx + lineLength, entry, text=\"C-Entry #\" + str.tostring(tradeNum), style=label.style_label_right, color=color.yellow, textcolor=color.black, size=size.small)\n\nif strategy.closedtrades > 0 and numTradesToDisplay > 0\n    maxTrades = math.min(strategy.closedtrades, numTradesToDisplay)\n    for i = 1 to maxTrades\n        tradeIndex = strategy.closedtrades - i \n        entryPriceTrade = strategy.closedtrades.entry_price(tradeIndex)\n        exitPriceTrade = strategy.closedtrades.exit_price(tradeIndex)\n        entryBarIndex = strategy.closedtrades.entry_bar_index(tradeIndex)\n        entryComment = strategy.closedtrades.entry_comment(tradeIndex)\n        isLongTrade = entryComment == \"L-ORB\"\n        \n        drawTradeClosed(entryBarIndex, entryPriceTrade, exitPriceTrade, isLongTrade, i)\n\n\n// --- OPEN TRADES (NEW LIVE LOGIC) ---\n// This draws the lines persistently for the CURRENT open trade(s)\n\nif strategy.position_size != 0 and numOpenTradesToDisplay > 0\n    // Get details of the current trade\n    currentEntryPrice = strategy.position_avg_price\n    isLong = strategy.position_size > 0\n    \n    // Since only one position is active at a time in this strategy, we use \n    // the stored TP/SL variables from the entry logic.\n    tpLevel = isLong ? longTakeProfitLevel : shortTakeProfitLevel\n    slLevel = isLong ? longStopLossLevel : shortStopLossLevel\n    \n    entryBarIndex = strategy.opentrades.entry_bar_index(0) // Get bar index of the current entry\n\n    // Draw lines for Entry, TP, and SL\n    // Entry Price (Solid Yellow)\n    line.new(entryBarIndex, currentEntryPrice, bar_index + lineLength, currentEntryPrice, color=color.new(color.yellow, 0), width=2, style=line.style_solid)\n    // TP Level (Dotted Green)\n    line.new(entryBarIndex, tpLevel, bar_index + lineLength, tpLevel, color=color.new(color.green, 0), width=2, style=line.style_dotted)\n    // SL Level (Dashed Red)\n    line.new(entryBarIndex, slLevel, bar_index + lineLength, slLevel, color=color.new(color.red, 0), width=1, style=line.style_dashed)\n    \n    // Label the entry line\n    label.new(bar_index + lineLength, currentEntryPrice, text=\"Live Entry\", style=label.style_label_right, color=color.yellow, textcolor=color.black, size=size.small)"
  },
  {
    "url": "ZkZBYPrK",
    "name": "Trend Following $ZEC - Multi-Timeframe Structure Filter + Revers",
    "description": "# Trend Following  CRYPTOCAP:ZEC  - Strategy Guide\n\n## ðŸ“Š Strategy Overview\n\nTrend Following  CRYPTOCAP:ZEC  is an enhanced Turtle Trading system designed for cryptocurrency spot trading, combining Donchian Channel breakouts, multi-timeframe structure filtering, and ATR-based dynamic risk management for both long and short positions.\n\n---\n\n## ðŸŽ¯ Core Features\n\n1. Multi-Timeframe Structure Filtering\n   - Uses Swing High/Low to identify market structure\n   - Customizable structure timeframe (default: 1 minute)\n   - Only enters trades in the direction of the trend, avoiding counter-trend positions\n\n2. Reverse Signal Exit\n   - No fixed stop-loss or fixed-period exits\n   - Exits only when a reverse entry signal triggers\n   - Maximizes trend profits, reduces premature exits\n\n3. ATR Dynamic Pyramiding\n   - Adds positions when price moves 0.5 ATR in favorable direction\n   - Supports up to 2 units maximum (adjustable)\n   - Pyramid scaling to enhance profitability\n\n4. Complete Risk Management\n   - Fixed position size (5000 USD per unit)\n   - Commission fee 0.06% (Binance spot rate)\n   - Initial capital 10,000 USD\n\n---\n\n## ðŸ“ˆ Trading Logic\n\nEntry Conditions\n\nâœ… Long Entry: \n- Close price breaks above 20-period high\n- Structure trend is bullish (price breaks above Swing High)\n\nâœ… Short Entry: \n- Close price breaks below 20-period low\n- Structure trend is bearish (price breaks below Swing Low)\n\nAdd Position Conditions\n- Long: Price rises â‰¥ 0.5 ATR\n- Short: Price falls â‰¥ 0.5 ATR\n- Maximum 2 units including initial entry\n\nExit Conditions\n- Long Exit: When short entry signal triggers (price breaks 20-period low + structure turns bearish)\n- Short Exit: When long entry signal triggers (price breaks 20-period high + structure turns bullish)\n\n---\n\n## âš™ï¸ Parameter Settings\n\nChannel Settings\n- Entry Channel Period: 20 (Donchian Channel breakout period)\n- Exit Channel Period: 10 (reserved parameter, actually uses reverse signal exit)\n\nATR Settings\n- ATR Period: 20\n- Stop Loss ATR Multiplier: 2.0 (reserved parameter)\n- Add Position ATR Multiplier: 0.5\n\nStructure Filter\n- Swing Length: 160 (Swing High/Low calculation period)\n- Structure Timeframe: 1 minute (can change to 5/15/60, etc.)\n\nPosition Management\n- Maximum Units: 2 (including initial entry)\n- Capital Per Unit: 5000 USD\n\n---\n\n## ðŸŽ¨ Visualization Features\n\nBackground Colors\n- Light Green: Bullish structure\n- Light Red: Bearish structure\n- Dark Green: Long entry\n- Dark Red: Short entry\n\nOptional Display (Default: OFF)\n- Entry/exit channel lines\n- Structure high/low lines\n- ATR stop-loss line\n- Next add position indicator\n- Entry/exit labels\n\n---\n\n## ðŸ“± Alert Message Format\n\nStrategy sends notifications on entry/exit with the following format:\n\n- Entry: `1m Long EP:428.26`\n- Add Position: `15m Add Long 2/2 EP:429.50`\n- Exit: `1m Close Long Reverse Signal`\n\nWhere:\n- `1m`/`15m` = Current chart timeframe\n- `EP` = Entry Price\n\n---\n\n## ðŸ’° Backtest Settings\n\nCapital Allocation\n- Initial Capital: 10,000 USD\n- Per Entry: 5,000 USD (split into 2 entries)\n- Leverage: 0x (spot trading)\n\nTrading Costs\n- Commission: 0.06% (Binance spot VIP0)\n- Slippage: 0\n\n---\n\n## ðŸŽ¯ Use Cases\n\nâœ… Best Scenarios\n- Trending markets\n- Moderate volatility assets\n- 1-minute to 4-hour timeframes\n\nâš ï¸ Not Suitable For\n- Highly volatile choppy markets\n- Low liquidity small-cap coins\n- Extreme market conditions (black swan events)\n\n---\n\n## ðŸ“Š Usage Recommendations\n\nTimeframe Suggestions\n\n| Timeframe | Trading Style | Suggested Parameter Adjustment |\n|-----------|--------------|-------------------------------|\n| 1-5 min | Scalping | Swing Length 100-160 |\n| 15-30 min | Short-term | Swing Length 50-100 |\n| 1-4 hour | Swing Trading | Swing Length 20-50 |\n\nOptimization Tips\n1. Adjust swing length based on backtest results\n2. Different coins may require different parameters\n3. Recommend backtesting on 1-minute chart first before live trading\n4. Enable labels to observe entry/exit points\n\n---\n\n## âš ï¸ Risk Disclaimer\n\n1. Past Performance Does Not Guarantee Future Results\n   - Backtest data is for reference only\n   - Live trading may be affected by slippage, delays, etc.\n\n2. Market Condition Changes\n   - Strategy performs better in trending markets\n   - May experience frequent stops in ranging markets\n\n3. Capital Management\n   - Do not invest more than you can afford to lose\n   - Recommend setting total capital stop-loss threshold\n\n4. Commission Impact\n   - Frequent trading accumulates commission fees\n   - Recommend using exchange discounts (BNB fee reduction, etc.)\n\n---\n\n## ðŸ”§ Troubleshooting\n\nQ: No entry signals?\nA: Check if structure filter is too strict, adjust swing length or timeframe\n\nQ: Too many labels displayed?\nA: Turn off \"Show Labels\" option in settings\n\nQ: Poor backtest performance?\nA: \n1. Check if the coin is suitable for trend-following strategies\n2. Adjust parameters (swing length, channel period)\n3. Try different timeframes\n\nQ: How to set alerts?\nA: \n1. Click \"Alert\" in top-right corner of chart\n2. Condition: Select \"Strategy - Trend Following  CRYPTOCAP:ZEC \"\n3. Choose \"Order filled\"\n4. Set notification method (Webhook/Email/App)\n\n---\n\n## ðŸ“ž Contact Information\n\nStrategy Name: Trend Following  CRYPTOCAP:ZEC \nVersion: v1.0\nPine Script Version: v6\nLast Updated: December 2025\n\n---\n\n## ðŸ“„ Copyright Notice\n\nThis strategy is for educational and research purposes only.\nAll risks of using this strategy for live trading are borne by the user.\nCommercial use without authorization is prohibited.\n\n---\n\n## ðŸŽ“ Learning Resources\n\nTo understand the strategy principles in depth, recommended reading:\n- \"The Complete TurtleTrader\" - Curtis Faith\n- \"Trend Following\" - Michael Covel\n- TradingView Pine Script Official Documentation\n\n---\n\nHappy Trading! Remember to manage your risk ðŸ“ˆ",
    "image_url": "ZkZBYPrK",
    "author": "ssun_6",
    "likes_count": 16,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-12",
    "updated": "2025-12-12",
    "source": "//@version=6\r\nstrategy(\"Trend $ZEC/AXL\", shorttitle=\"$ZEC/AXL 1/15m\", overlay=true, \r\n         initial_capital=10000, \r\n         default_qty_type=strategy.cash, \r\n         default_qty_value=5000, \r\n         commission_type=strategy.commission.percent, \r\n         commission_value=0.06,\r\n         slippage=0,\r\n         max_lines_count=500,\r\n         max_labels_count=500)\r\n\r\n// ========== åƒæ•¸è¨­å®š ==========\r\n// å”å¥‡å®‰é€šé“åƒæ•¸\r\nentry_period = input.int(20, \"é€²å ´é€šé“é€±æœŸ\", minval=1, group=\"é€šé“è¨­å®š\")\r\nexit_period = input.int(10, \"å‡ºå ´é€šé“é€±æœŸ\", minval=1, group=\"é€šé“è¨­å®š\")\r\n\r\n// ATR åƒæ•¸\r\natr_period = input.int(20, \"ATR é€±æœŸ\", minval=1, group=\"ATR è¨­å®š\")\r\natr_stop_mult = input.float(2.0, \"æ­¢æ ATR å€æ•¸\", minval=0.1, step=0.1, group=\"ATR è¨­å®š\")\r\natr_add_mult = input.float(0.5, \"åŠ å€‰ ATR å€æ•¸\", minval=0.1, step=0.1, group=\"ATR è¨­å®š\")\r\n\r\n// å¤šç©ºçµæ§‹åƒæ•¸ - åŠ å…¥å¤šæ™‚é–“æ¡†æž¶\r\nswing_length = input.int(160, \"çµæ§‹æ“ºå‹•é•·åº¦\", minval=1, group=\"ðŸ“Š å¤šç©ºçµæ§‹éŽæ¿¾\")\r\nstructure_timeframe = input.timeframe(\"1\", \"çµæ§‹æ™‚é–“æ¡†æž¶\", group=\"ðŸ“Š å¤šç©ºçµæ§‹éŽæ¿¾\", tooltip=\"é¸æ“‡çµæ§‹åˆ¤æ–·çš„æ™‚é–“é€±æœŸ,ç©ºç™½=ç•¶å‰åœ–è¡¨,D=æ—¥ç·š,W=é€±ç·š\")\r\nshow_structure_lines = input.bool(false, \"é¡¯ç¤ºçµæ§‹ç·š\", group=\"ðŸ“Š å¤šç©ºçµæ§‹éŽæ¿¾\")\r\nshow_structure_labels = input.bool(false, \"é¡¯ç¤ºçµæ§‹æ¨™ç±¤\", group=\"ðŸ“Š å¤šç©ºçµæ§‹éŽæ¿¾\")\r\n\r\n// åŠ å€‰è¨­å®š\r\nmax_units = input.int(2, \"æœ€å¤§å–®ä½æ•¸(å«é¦–æ¬¡)\", minval=1, maxval=10, group=\"å€‰ä½ç®¡ç†\")\r\nposition_size = input.int(5000, \"æ¯å–®ä½è³‡é‡‘(USD)\", minval=100, group=\"å€‰ä½ç®¡ç†\", tooltip=\"10000Uæœ¬é‡‘åˆ†2æ¬¡é€²å ´ï¼Œæ¯æ¬¡5000U\")\r\n\r\n// é¡¯ç¤ºè¨­å®š\r\nshow_channels = input.bool(false, \"é¡¯ç¤ºé€šé“\", group=\"é¡¯ç¤ºè¨­å®š\")\r\nshow_atr_lines = input.bool(false, \"é¡¯ç¤º ATR ç·š\", group=\"é¡¯ç¤ºè¨­å®š\")\r\nshow_labels = input.bool(true, \"é¡¯ç¤ºæ¨™ç±¤\", group=\"é¡¯ç¤ºè¨­å®š\")\r\nshow_table = input.bool(false, \"é¡¯ç¤ºè³‡è¨Šé¢æ¿\", group=\"é¡¯ç¤ºè¨­å®š\")\r\nlabel_distance = input.float(2.5, \"æ¨™ç±¤è·é›¢ K æ£’å€æ•¸\", minval=0.1, step=0.1, group=\"é¡¯ç¤ºè¨­å®š\", tooltip=\"æ¨™ç±¤è·é›¢Kæ£’çš„ATRå€æ•¸\")\r\nshow_label_lines = input.bool(false, \"é¡¯ç¤ºæ¨™ç±¤é€£ç·š\", group=\"é¡¯ç¤ºè¨­å®š\")\r\n\r\n// ========== è¨ˆç®—å”å¥‡å®‰é€šé“ ==========\r\nentry_upper = ta.highest(high, entry_period)\r\nentry_lower = ta.lowest(low, entry_period)\r\nexit_upper = ta.highest(high, exit_period)\r\nexit_lower = ta.lowest(low, exit_period)\r\n\r\n// ========== è¨ˆç®— ATR (Nå€¼) ==========\r\nN = ta.atr(atr_period)\r\n\r\n// ========== å¤šæ™‚é–“æ¡†æž¶å¤šç©ºçµæ§‹åˆ¤æ–· ==========\r\n// è¨ˆç®—çµæ§‹çš„å‡½æ•¸\r\nf_calculate_structure() =>\r\n    var int trend = 0\r\n    var float lastHigh = na\r\n    var float lastLow = na\r\n    \r\n    swingHigh = ta.pivothigh(high, swing_length, swing_length)\r\n    swingLow = ta.pivotlow(low, swing_length, swing_length)\r\n    \r\n    if not na(swingHigh)\r\n        lastHigh := swingHigh\r\n    \r\n    if not na(swingLow)\r\n        lastLow := swingLow\r\n    \r\n    if not na(lastHigh) and close > lastHigh and trend != 1\r\n        trend := 1\r\n    \r\n    if not na(lastLow) and close < lastLow and trend != -1\r\n        trend := -1\r\n    \r\n    [trend, lastHigh, lastLow]\r\n\r\n// ç²å–æŒ‡å®šæ™‚é–“æ¡†æž¶çš„çµæ§‹\r\n[structure_trend_mtf, last_structure_high_mtf, last_structure_low_mtf] = request.security(syminfo.tickerid, structure_timeframe, f_calculate_structure(), lookahead=barmerge.lookahead_off)\r\n\r\n// ä½¿ç”¨å¤šæ™‚é–“æ¡†æž¶çš„çµæ§‹è¶¨å‹¢\r\nstructure_trend = structure_trend_mtf\r\nlast_structure_high = last_structure_high_mtf\r\nlast_structure_low = last_structure_low_mtf\r\n\r\n// æª¢æ¸¬çµæ§‹è®ŠåŒ–ï¼ˆç”¨æ–¼ç¹ªè£½æ¨™ç±¤ï¼‰\r\nvar int prev_structure_trend = 0\r\nbool bull_break = structure_trend == 1 and prev_structure_trend != 1\r\nbool bear_break = structure_trend == -1 and prev_structure_trend != -1\r\nprev_structure_trend := structure_trend\r\n\r\n// ç¹ªè£½çµæ§‹çªç ´æ¨™ç±¤\r\nif show_structure_labels\r\n    if bull_break\r\n        label.new(bar_index, low, \"å¤šæ–¹çµæ§‹\", style=label.style_label_up, color=color.new(color.green, 0), textcolor=color.white, size=size.small)\r\n    \r\n    if bear_break\r\n        label.new(bar_index, high, \"ç©ºæ–¹çµæ§‹\", style=label.style_label_down, color=color.new(color.red, 0), textcolor=color.white, size=size.small)\r\n\r\n// ========== æŒå€‰ç‹€æ…‹è¿½è¹¤ ==========\r\nvar float entry_price = na\r\nvar float[] add_prices = array.new_float(0)\r\nvar int position = 0\r\nvar int units = 0\r\nvar float stop_loss = na\r\n\r\n// ========== é€²å ´è¨Šè™Ÿ (åŠ å…¥çµæ§‹éŽæ¿¾) ==========\r\nlong_entry_signal = close > entry_upper[1] and structure_trend == 1\r\nshort_entry_signal = close < entry_lower[1] and structure_trend == -1\r\n\r\nlong_entry = long_entry_signal and position != 1\r\nshort_entry = short_entry_signal and position != -1\r\n\r\n// ========== åŠ å€‰è¨Šè™Ÿ ==========\r\nlong_add = false\r\nshort_add = false\r\n\r\nif position == 1 and units < max_units\r\n    if array.size(add_prices) > 0\r\n        last_add_price = array.get(add_prices, array.size(add_prices) - 1)\r\n        long_add := close >= last_add_price + (atr_add_mult * N)\r\n    else\r\n        long_add := close >= entry_price + (atr_add_mult * N)\r\n\r\nif position == -1 and units < max_units\r\n    if array.size(add_prices) > 0\r\n        last_add_price = array.get(add_prices, array.size(add_prices) - 1)\r\n        short_add := close <= last_add_price - (atr_add_mult * N)\r\n    else\r\n        short_add := close <= entry_price - (atr_add_mult * N)\r\n\r\n// ========== å‡ºå ´è¨Šè™Ÿ (æ”¹ç‚ºåå‘è¨Šè™Ÿå‡ºå ´) ==========\r\n// å¤šå–®å‡ºå ´ï¼šç•¶ç©ºå–®é€²å ´è¨Šè™Ÿè§¸ç™¼æ™‚\r\nlong_exit = (position == 1) and short_entry_signal\r\n\r\n// ç©ºå–®å‡ºå ´ï¼šç•¶å¤šå–®é€²å ´è¨Šè™Ÿè§¸ç™¼æ™‚\r\nshort_exit = (position == -1) and long_entry_signal\r\n\r\n// ========== æ›´æ–°æŒå€‰ç‹€æ…‹ ==========\r\nif long_entry\r\n    position := 1\r\n    units := 1\r\n    entry_price := close\r\n    array.clear(add_prices)\r\n    array.push(add_prices, close)\r\n    stop_loss := close - (atr_stop_mult * N)\r\n    alert_msg = timeframe.period + \" åšå¤š EP:\" + str.tostring(close, \"#.##\")\r\n    strategy.entry(\"å¤šå–®1\", strategy.long, qty=position_size/close, comment=alert_msg, alert_message=alert_msg)\r\n    \r\nelse if short_entry\r\n    position := -1\r\n    units := 1\r\n    entry_price := close\r\n    array.clear(add_prices)\r\n    array.push(add_prices, close)\r\n    stop_loss := close + (atr_stop_mult * N)\r\n    alert_msg = timeframe.period + \" åšç©º EP:\" + str.tostring(close, \"#.##\")\r\n    strategy.entry(\"ç©ºå–®1\", strategy.short, qty=position_size/close, comment=alert_msg, alert_message=alert_msg)\r\n    \r\nelse if long_add\r\n    units := units + 1\r\n    array.push(add_prices, close)\r\n    stop_loss := close - (atr_stop_mult * N)\r\n    alert_msg = timeframe.period + \" åŠ å€‰å¤š \" + str.tostring(units) + \"/\" + str.tostring(max_units) + \" EP:\" + str.tostring(close, \"#.##\")\r\n    strategy.entry(\"å¤šå–®\" + str.tostring(units), strategy.long, qty=position_size/close, comment=alert_msg, alert_message=alert_msg)\r\n    \r\nelse if short_add\r\n    units := units + 1\r\n    array.push(add_prices, close)\r\n    stop_loss := close + (atr_stop_mult * N)\r\n    alert_msg = timeframe.period + \" åŠ å€‰ç©º \" + str.tostring(units) + \"/\" + str.tostring(max_units) + \" EP:\" + str.tostring(close, \"#.##\")\r\n    strategy.entry(\"ç©ºå–®\" + str.tostring(units), strategy.short, qty=position_size/close, comment=alert_msg, alert_message=alert_msg)\r\n    \r\nelse if long_exit or short_exit\r\n    if long_exit\r\n        alert_msg = timeframe.period + \" å¹³å¤š åå‘è¨Šè™Ÿ\"\r\n        strategy.close_all(comment=alert_msg, alert_message=alert_msg)\r\n    if short_exit\r\n        alert_msg = timeframe.period + \" å¹³ç©º åå‘è¨Šè™Ÿ\"\r\n        strategy.close_all(comment=alert_msg, alert_message=alert_msg)\r\n    \r\n    position := 0\r\n    units := 0\r\n    entry_price := na\r\n    array.clear(add_prices)\r\n    stop_loss := na\r\n\r\n// ========== ç¹ªè£½é€šé“ ==========\r\nplot(show_channels ? entry_upper : na, \"é€²å ´ä¸Šè»Œ\", color=color.new(color.red, 0), linewidth=2)\r\nplot(show_channels ? entry_lower : na, \"é€²å ´ä¸‹è»Œ\", color=color.new(color.green, 0), linewidth=2)\r\nplot(show_channels ? exit_upper : na, \"å‡ºå ´ä¸Šè»Œ\", color=color.new(color.orange, 50), linewidth=1, style=plot.style_circles)\r\nplot(show_channels ? exit_lower : na, \"å‡ºå ´ä¸‹è»Œ\", color=color.new(color.blue, 50), linewidth=1, style=plot.style_circles)\r\n\r\n// ç¹ªè£½çµæ§‹é«˜ä½Žé»ž\r\nplot(show_structure_lines ? last_structure_high : na, \"çµæ§‹é«˜é»ž\", color=color.new(color.red, 85), linewidth=2, style=plot.style_stepline)\r\nplot(show_structure_lines ? last_structure_low : na, \"çµæ§‹ä½Žé»ž\", color=color.new(color.green, 85), linewidth=2, style=plot.style_stepline)\r\n\r\n// ========== ç¹ªè£½ ATR ç·š ==========\r\nplot(show_atr_lines and position != 0 ? stop_loss : na, \"æ­¢æç·š\", color=color.new(color.red, 0), linewidth=2, style=plot.style_cross)\r\n\r\nvar float next_add_long = na\r\nif position == 1 and units < max_units\r\n    next_add_long := array.size(add_prices) > 0 ? array.get(add_prices, array.size(add_prices) - 1) + (atr_add_mult * N) : entry_price + (atr_add_mult * N)\r\nelse\r\n    next_add_long := na\r\n\r\nplot(show_atr_lines and position == 1 and units < max_units ? next_add_long : na, \"ä¸‹æ¬¡åŠ å€‰(å¤š)\", color=color.new(color.yellow, 30), linewidth=1, style=plot.style_stepline)\r\n\r\nvar float next_add_short = na\r\nif position == -1 and units < max_units\r\n    next_add_short := array.size(add_prices) > 0 ? array.get(add_prices, array.size(add_prices) - 1) - (atr_add_mult * N) : entry_price - (atr_add_mult * N)\r\nelse\r\n    next_add_short := na\r\n\r\nplot(show_atr_lines and position == -1 and units < max_units ? next_add_short : na, \"ä¸‹æ¬¡åŠ å€‰(ç©º)\", color=color.new(color.yellow, 30), linewidth=1, style=plot.style_stepline)\r\n\r\n// ========== ç¹ªè£½è¨Šè™Ÿæ¨™ç±¤ ==========\r\nif show_labels\r\n    label_offset = N * label_distance\r\n    long_label_style = show_label_lines ? label.style_label_up : label.style_none\r\n    short_label_style = show_label_lines ? label.style_label_down : label.style_none\r\n    \r\n    if long_entry\r\n        label.new(bar_index, low - label_offset, \"åšå¤šZEC\\nå–®ä½1/\" + str.tostring(max_units), color=color.new(color.green, 0), style=long_label_style, textcolor=color.white, size=size.normal, textalign=text.align_center)\r\n    \r\n    if short_entry\r\n        label.new(bar_index, high + label_offset, \"åšç©ºZEC\\nå–®ä½1/\" + str.tostring(max_units), color=color.new(color.red, 0), style=short_label_style, textcolor=color.white, size=size.normal, textalign=text.align_center)\r\n    \r\n    if long_add\r\n        label.new(bar_index, low - label_offset, \"åŠ å€‰å¤šå–®ZEC\\nå–®ä½\" + str.tostring(units) + \"/\" + str.tostring(max_units), color=color.new(color.lime, 0), style=long_label_style, textcolor=color.black, size=size.small, textalign=text.align_center)\r\n    \r\n    if short_add\r\n        label.new(bar_index, high + label_offset, \"åŠ å€‰ç©ºå–®ZEC\\nå–®ä½\" + str.tostring(units) + \"/\" + str.tostring(max_units), color=color.new(color.maroon, 0), style=short_label_style, textcolor=color.white, size=size.small, textalign=text.align_center)\r\n    \r\n    if long_exit\r\n        label.new(bar_index, low - label_offset, \"å¹³å¤šZEC\\nåå‘è¨Šè™Ÿ\", color=color.new(color.orange, 0), style=long_label_style, textcolor=color.white, size=size.normal, textalign=text.align_center)\r\n    \r\n    if short_exit\r\n        label.new(bar_index, high + label_offset, \"å¹³ç©ºZEC\\nåå‘è¨Šè™Ÿ\", color=color.new(color.blue, 0), style=short_label_style, textcolor=color.white, size=size.normal, textalign=text.align_center)\r\n\r\n// ========== èƒŒæ™¯é¡è‰² ==========\r\nbgcolor(structure_trend == 1 ? color.new(color.green, 70) : structure_trend == -1 ? color.new(color.red, 70) : na, title=\"çµæ§‹è¶¨å‹¢\")\r\nbgcolor(long_entry ? color.new(color.green, 85) : na, title=\"å¤šå–®é€²å ´\")\r\nbgcolor(short_entry ? color.new(color.red, 85) : na, title=\"ç©ºå–®é€²å ´\")\r\nbgcolor(long_add ? color.new(color.lime, 90) : na, title=\"å¤šå–®åŠ å€‰\")\r\nbgcolor(short_add ? color.new(color.maroon, 90) : na, title=\"ç©ºå–®åŠ å€‰\")"
  },
  {
    "url": "n1xKPRA2-DR-IDR-Break-5-TP",
    "name": "DR/IDR Break .5 TP",
    "description": "DR/IDR Extension Breakout with Custom Stop\nThis strategy is a systematic, counter-trend, and momentum-based system designed for intraday trading. It operates on the principle of an Opening Range Breakout (ORB), utilizing the initial market consolidation to project high-probability targets, while offering multiple methods for managing risk.\n\n1. Market Identification (The Opening Range)\nThe strategy begins by defining the market's initial boundaries and volatility:\n\nSession Window: The strategy calculates the Opening Range (OR) over a user-defined time period (default: 9:30 AM to 10:30 AM New York Time).\n\nORB Levels: Two key price levels are established and locked once the time window closes:\n\nWick High/Low: The absolute highest and lowest prices of the session. These serve as the entry trigger lines.\n\nBody High/Low (Shaded Range): The highest and lowest open/close prices of the session. The height of this range is used to calculate the Take Profit and Stop Loss levels.\n\n2. Entry Rule (The Breakout)\nThe strategy is passive until the range is violated, looking for a strong move out of the consolidation area.\n\nTrigger Condition: A trade is signaled when a candle closes either:\n\nAbove the Wick High (for a Long entry).\n\nBelow the Wick Low (for a Short entry).\n\nExecution: The entry is a Market Order executed on the candle that meets the trigger condition, subject to a user-defined Entry Delay (default 0 bars, meaning the entry is taken immediately upon the breakout candle's close).\n\nDirection Control: The user can select to trade Long Only, Short Only, or Both.\n\n3. Exit and Risk Management\nAll trades are placed with simultaneous Take Profit and Stop Loss orders (a bracket order) once the entry is filled.\n\nA. Take Profit (TP)\nThe Take Profit is set at the 0.5 Extension of the Shaded Range (Body Range).\n\nCalculation: The distance from the Body High/Low to the TP level is exactly 50% of the total height of the Shaded Range.\n\nB. Stop Loss (SL)\nThe Stop Loss is dynamically calculated based on a user-selected method for risk control:\n\nRange 0.5 (Body Range): The Stop Loss is placed an equal distance (0.5 times the Body Range height) outside the opposite side of the Body Range.\n\nExample (Long): If entry is above the Wick High, the SL is set 0.5 times the Body Range height below the Body Low.\n\nATR Multiple: The Stop Loss distance is determined by the asset's recent volatility.\n\nCalculation: The distance is calculated as a user-defined Multiplier (default 2.0) times the Average True Range (ATR).\n\nRecent Swing Low/High: The Stop Loss is placed based on a structural level defined by recent price action.\n\nLong Entry: SL is placed at the Lowest Swing Low within a user-defined lookback period.\n\nShort Entry: SL is placed at the Highest Swing High within a user-defined lookback period.\n\nSummary of Workflow\nThe market sets the Wick and Body boundaries (e.g., 9:30â€“10:30 AM).\n\nPrice breaks and closes beyond a Wick boundary, triggering a signal.\n\nThe trade enters after the specified delay.\n\nA bracket order is placed: TP is fixed at the 0.5 Extension, and SL is set based on the user's chosen risk method.\n\nThe trade is closed upon reaching either the TP or the SL level.",
    "image_url": "n1xKPRA2",
    "author": "ChadAnt",
    "likes_count": 12,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=5\r\nstrategy(\"DR/IDR Break .5 TP\", overlay=true, shorttitle=\"DR/IDR break .5 TP\")\r\n\r\n// ==========================================\r\n// 1. USER INPUTS\r\n// ==========================================\r\n\r\n// --- STRATEGY SETTINGS ---\r\ngrp_strategy = \"Strategy Execution\"\r\n// CHANGED: entryDelay logic modified internally for better execution.\r\nentryDelay = input.int(0, \"Entry Delay (Bars after Break)\", minval=0, maxval=5, group=grp_strategy)\r\ntradeDirection = input.string(\"Both\", \"Trade Direction\", options=[\"Long Only\", \"Short Only\", \"Both\"], group=grp_strategy)\r\n\r\n// Stop Loss Management\r\ngrp_sl = \"Stop Loss Settings\"\r\nslType = input.string(\"Range 0.5 (Body Range)\", \"Stop Loss Type\", \r\n     options=[\"Range 0.5 (Body Range)\", \"ATR Multiple\", \"Recent Swing Low/High\"], \r\n     group=grp_sl) \r\natrLength = input.int(14, \"ATR Lookback\", minval=1, group=grp_sl)\r\natrMultiplier = input.float(2.0, \"ATR Multiplier\", minval=0.1, group=grp_sl)\r\nswingLookback = input.int(10, \"Swing Lookback Bars\", minval=5, group=grp_sl)\r\n\r\n\r\n// --- ORB Time Settings ---\r\ngrp_time = \"ORB Time Settings\"\r\nsessionInput = input.session(\"0930-1030\", \"Opening Range Session (NY Time)\", group=grp_time)\r\nendTimeInput = input.int(1600, \"ORB Lines Stop Time (HHMM)\", group=grp_time)\r\ntimezone     = \"America/New_York\" \r\n\r\n// --- ORB Extension Settings ---\r\ngrp_ext = \"ORB Extensions (Body Range Based)\"\r\ntpStep = 0.5 // Fixed Take Profit at 0.5 extension as per request\r\nstdDevSteps  = input.float(0.5, \"Step Size (e.g. 0.5 = 50% of range)\", step=0.1, group=grp_ext, tooltip=\"This input controls the SL/TP step size.\")\r\nstdDevQty    = input.int(3, \"Number of Extension Lines\", minval=1, maxval=10, group=grp_ext) \r\nextLineStyle = input.string(\"Dotted\", \"Extension Line Style\", options=[\"Solid\", \"Dotted\", \"Dashed\"], group=grp_ext)\r\n\r\n// --- ORB Visuals (kept for compatibility and analysis) ---\r\ngrp_style = \"ORB Visuals (Non-Trading)\"\r\nwickColor = input.color(color.new(color.gray, 0), \"Wick Line Color\", group=grp_style)\r\nbodyColor = input.color(color.new(color.blue, 0), \"Body Line Color\", group=grp_style)\r\nfillColor = input.color(color.new(color.blue, 90), \"Body Range Fill Color\", group=grp_style)\r\nlineWidth = input.int(2, \"Line Width\", minval=1, group=grp_style)\r\n\r\n// ==========================================\r\n// 2. ORB LOGIC\r\n// ==========================================\r\n\r\n// Detect New Day & Time Checks\r\nisNewDay = ta.change(time(\"D\"))\r\ninFormingSession = not na(time(timeframe.period, sessionInput + \":1234567\", timezone))\r\nnyHour = hour(time, timezone)\r\nnyMinute = minute(time, timezone)\r\ncurrNyTime = nyHour * 100 + nyMinute\r\npastCutoff = currNyTime >= endTimeInput\r\n\r\n// State Variables\r\nvar float rHigh = na\r\nvar float rLow = na\r\nvar float rBodyHigh = na\r\nvar float rBodyLow = na\r\nvar bool bullBreakHappened = false\r\nvar bool bearBreakHappened = false\r\n// New variable to store the price when the break was first detected\r\nvar float breakOutPrice = na \r\n\r\n// Reset on New Day\r\nif isNewDay\r\n    rHigh := na\r\n    rLow := na\r\n    rBodyHigh := na\r\n    rBodyLow := na\r\n    bullBreakHappened := false\r\n    bearBreakHappened := false\r\n    breakOutPrice := na\r\n\r\n// Update Logic during session\r\nif inFormingSession and not inFormingSession[1]\r\n    rHigh := high\r\n    rLow := low\r\n    rBodyHigh := math.max(open, close)\r\n    rBodyLow := math.min(open, close)\r\n    bullBreakHappened := false \r\n    bearBreakHappened := false\r\nelse if inFormingSession\r\n    rHigh := math.max(rHigh, high)\r\n    rLow := math.min(rLow, low)\r\n    rBodyHigh := math.max(rBodyHigh, math.max(open, close))\r\n    rBodyLow := math.min(rBodyLow, math.min(open, close))\r\n\r\n// ORB Boundary Check\r\nsessionEnded = not inFormingSession and not na(rHigh)\r\n// Check for close outside the wick (trigger condition)\r\nbullBreakCondition = sessionEnded and not bullBreakHappened and close > rHigh\r\nbearBreakCondition = sessionEnded and not bearBreakHappened and close < rLow\r\n\r\n// Update Breakout Status and save price for delayed entry\r\nif bullBreakCondition\r\n    bullBreakHappened := true\r\n    breakOutPrice := close\r\nif bearBreakCondition\r\n    bearBreakHappened := true\r\n    breakOutPrice := close\r\n\r\n// ==========================================\r\n// 3. TARGET & STOP LOSS CALCULATION\r\n// ==========================================\r\n\r\nvar float entryPrice = na\r\nvar float takeProfit = na\r\nvar float stopLoss = na\r\nbodyRangeHeight = rBodyHigh - rBodyLow \r\n\r\n// --- ATR Calculation for SL Option ---\r\natrValue = ta.atr(atrLength)\r\n\r\n// --- Swing High/Low Calculation for SL Option ---\r\nswingLowPrice = ta.lowest(low, swingLookback)\r\nswingHighPrice = ta.highest(high, swingLookback)\r\n\r\n\r\n// Function to calculate SL based on user choice\r\ncalcStopLoss(isLong, currentEntryPrice, rangeHeight, currentATR) =>\r\n    sl = float(na)\r\n    if slType == \"Range 0.5 (Body Range)\"\r\n        sl := isLong ? rBodyLow - (rangeHeight * stdDevSteps) : rBodyHigh + (rangeHeight * stdDevSteps)\r\n    else if slType == \"ATR Multiple\"\r\n        sl := isLong ? currentEntryPrice - (currentATR * atrMultiplier) : currentEntryPrice + (currentATR * atrMultiplier)\r\n    else if slType == \"Recent Swing Low/High\"\r\n        sl := isLong ? swingLowPrice : swingHighPrice\r\n    sl\r\n\r\n// Function to calculate TP (always 0.5 extension of shaded range)\r\ncalcTakeProfit(isLong, rangeHeight) =>\r\n    tp = float(na)\r\n    tp := isLong ? rBodyHigh + (rangeHeight * tpStep) : rBodyLow - (rangeHeight * tpStep)\r\n    tp\r\n\r\n// ==========================================\r\n// 4. STRATEGY ENTRY & EXIT LOGIC (MODIFIED)\r\n// ==========================================\r\n\r\n// Entry Logic: Use `ta.barssince()` to count bars since the breakout condition was met\r\nbarsSinceBullBreak = ta.barssince(bullBreakCondition)\r\nbarsSinceBearBreak = ta.barssince(bearBreakCondition)\r\n\r\n// --- LONG TRADE ENTRY ---\r\nif barsSinceBullBreak == entryDelay and (tradeDirection == \"Long Only\" or tradeDirection == \"Both\") and strategy.position_size == 0\r\n    entryPrice := breakOutPrice[entryDelay] // Use the close of the breakout candle for entry price\r\n    takeProfit := calcTakeProfit(true, bodyRangeHeight)\r\n    stopLoss := calcStopLoss(true, entryPrice, bodyRangeHeight, atrValue)\r\n    \r\n    strategy.entry(\"Long ORB\", strategy.long, comment=\"L-ORB\", stop=close) // Set entry with a market order\r\n    \r\n    // Define Exit Orders based on calculated prices\r\n    strategy.exit(\"TP/SL Long\", \"Long ORB\", limit=takeProfit, stop=stopLoss)\r\n    // Clear breakout price so it doesn't trigger again\r\n    breakOutPrice := na\r\n\r\n\r\n// --- SHORT TRADE ENTRY ---\r\nif barsSinceBearBreak == entryDelay and (tradeDirection == \"Short Only\" or tradeDirection == \"Both\") and strategy.position_size == 0\r\n    entryPrice := breakOutPrice[entryDelay] // Use the close of the breakout candle for entry price\r\n    takeProfit := calcTakeProfit(false, bodyRangeHeight)\r\n    stopLoss := calcStopLoss(false, entryPrice, bodyRangeHeight, atrValue)\r\n    \r\n    strategy.entry(\"Short ORB\", strategy.short, comment=\"S-ORB\", stop=close) // Set entry with a market order\r\n    \r\n    // Define Exit Orders based on calculated prices\r\n    strategy.exit(\"TP/SL Short\", \"Short ORB\", limit=takeProfit, stop=stopLoss)\r\n    // Clear breakout price so it doesn't trigger again\r\n    breakOutPrice := na\r\n\r\n\r\n// ==========================================\r\n// 5. VISUALS\r\n// ==========================================\r\n\r\n// Plotting the ORB Levels\r\ncanDraw = not na(rHigh) and not pastCutoff\r\nplot(canDraw ? rHigh : na, color=wickColor, linewidth=1, title=\"Wick High\", style=plot.style_linebr)\r\nplot(canDraw ? rLow : na, color=wickColor, linewidth=1, title=\"Wick Low\", style=plot.style_linebr)\r\np_bh = plot(canDraw ? rBodyHigh : na, color=bodyColor, linewidth=lineWidth, title=\"Body High\", style=plot.style_linebr)\r\np_bl = plot(canDraw ? rBodyLow : na, color=bodyColor, linewidth=lineWidth, title=\"Body Low\", style=plot.style_linebr)\r\nfill(p_bh, p_bl, color = inFormingSession ? fillColor : color.new(color.white, 100))\r\n\r\n// Draw Breakout and Extension Visuals\r\ngetLineStyle(s) => s == \"Dotted\" ? line.style_dotted : s == \"Dashed\" ? line.style_dashed : line.style_solid\r\n\r\n// Visuals for Breakout Candle\r\nplotshape(bullBreakCondition, style=shape.labelup, location=location.belowbar, color=color.green, text=\"BREAK\", textcolor=color.white, size=size.small)\r\nplotshape(bearBreakCondition, style=shape.labeldown, location=location.abovebar, color=color.red, text=\"BREAK\", textcolor=color.white, size=size.small)\r\n\r\n// Visuals for Extension Lines (Redrawn only on the break candle for neatness)\r\nif bullBreakCondition or bearBreakCondition\r\n    // Long TP (fixed at 0.5)\r\n    tpLongLevel = rBodyHigh + (bodyRangeHeight * tpStep)\r\n    // Short TP (fixed at 0.5)\r\n    tpShortLevel = rBodyLow - (bodyRangeHeight * tpStep)\r\n    \r\n    // Draw only for the successful break direction\r\n    if bullBreakCondition\r\n        line.new(bar_index, tpLongLevel, bar_index + 10, tpLongLevel, color=color.green, style=getLineStyle(extLineStyle), width=2)\r\n    if bearBreakCondition\r\n        line.new(bar_index, tpShortLevel, bar_index + 10, tpShortLevel, color=color.red, style=getLineStyle(extLineStyle), width=2)"
  },
  {
    "url": "YVaGAcV3",
    "name": "Trend Following $BTC - Multi-Timeframe Structure + Revers",
    "description": "TREND FOLLOWING STRATEGY - MULTI-TIMEFRAME STRUCTURE BREAKOUT SYSTEM\n\nStrategy Overview\n\nThis is an enhanced Turtle Trading system designed for cryptocurrency spot trading. It combines Donchian Channel breakouts with multi-timeframe structure filtering and ATR-based dynamic risk management. The strategy trades both long and short positions using reverse signal exits to maximize trend capture.\n\nCore Features\n\nMulti-Timeframe Structure Filtering\nThe strategy uses Swing High/Low analysis to identify market structure trends. You can customize the structure timeframe (default: 3 minutes) to match your trading style. Only enters trades aligned with the identified trend direction, avoiding counter-trend positions that often lead to losses.\n\nReverse Signal Exit System\nInstead of using fixed stop-losses or time-based exits, this strategy exits positions only when a reverse entry signal triggers. This approach maximizes trend profits and reduces premature exits during normal market retracements.\n\nATR Dynamic Pyramiding\nAutomatically adds positions when price moves 0.5 ATR in your favor. Supports up to 2 units maximum (adjustable). This pyramid scaling enhances profitability during strong trends while maintaining disciplined risk management.\n\nComplete Risk Management\nFixed position sizing at 5000 USD per unit. Includes realistic commission fees of 0.06% (Binance spot rate). Initial capital set at 10,000 USD. All backtest parameters reflect real-world trading conditions.\n\nTrading Logic\n\nEntry Conditions\nLong Entry: Close price breaks above the 20-period high AND structure trend is bullish (price breaks above Swing High)\nShort Entry: Close price breaks below the 20-period low AND structure trend is bearish (price breaks below Swing Low)\n\nPosition Scaling\nLong positions: Add when price rises 0.5 ATR or more\nShort positions: Add when price falls 0.5 ATR or more\nMaximum 2 units including initial entry\n\nExit Conditions\nLong Exit: Triggers when short entry signal appears (price breaks 20-period low + structure turns bearish)\nShort Exit: Triggers when long entry signal appears (price breaks 20-period high + structure turns bullish)\n\nDefault Parameters\n\nChannel Settings\nEntry Channel Period: 20 (Donchian Channel breakout period)\nExit Channel Period: 10 (reserved parameter)\n\nATR Settings\nATR Period: 20\nStop Loss ATR Multiplier: 2.0\nAdd Position ATR Multiplier: 0.5\n\nStructure Filter\nSwing Length: 300 (Swing High/Low calculation period)\nStructure Timeframe: 3 minutes\nAdjust these based on your trading timeframe and asset volatility\n\nPosition Management\nMaximum Units: 2 (including initial entry)\nCapital Per Unit: 5000 USD\n\nVisualization Features\n\nBackground Colors\nLight Green: Bullish market structure\nLight Red: Bearish market structure\nDark Green: Long position entry\nDark Red: Short position entry\n\nOptional Display Elements (Default: OFF)\nEntry and exit channel lines\nStructure high/low reference lines\nATR stop-loss indicator\nNext position add level\nEntry/exit labels\n\nAlert Message Format\n\nThe strategy sends notifications with the following format:\nEntry: \"5m Long EP:90450.50\"\nAdd Position: \"15m Add Long 2/2 EP:91000.25\"\nExit: \"5m Close Long Reverse Signal\"\n\nWhere the first part shows your current chart timeframe and EP indicates Entry Price\n\nBacktest Settings\n\nCapital Allocation\nInitial Capital: 10,000 USD\nPer Entry: 5,000 USD (split into 2 potential entries)\nLeverage: 0x (spot trading only)\n\nTrading Costs\nCommission: 0.06% (Binance spot VIP0 rate)\nSlippage: 0 (adjust based on your experience)\n\nBest Use Cases\n\nIdeal Scenarios\nTrending markets with clear directional movement\nModerate to high volatility assets\nTimeframes from 1-minute to 4-hour charts\nBest suited for major cryptocurrencies with good liquidity\n\nNot Recommended For\nHighly volatile choppy/ranging markets\nLow liquidity small-cap coins\nExtreme market conditions or black swan events\n\nUsage Recommendations\n\nTimeframe Guidelines\n1-5 minute charts: Use for scalping, consider Swing Length 100-160\n15-30 minute charts: Good for short-term trading, Swing Length 50-100\n1-4 hour charts: Suitable for swing trading, Swing Length 20-50\n\nOptimization Tips\nAlways backtest on historical data before live trading\nAdjust swing length based on asset volatility and your timeframe\nDifferent cryptocurrencies may require different parameter settings\nEnable visualization options initially to understand entry/exit points\nMonitor win rate and drawdown during backtesting\n\nTechnical Details\n\nBuilt on Pine Script v6\nNo repainting - uses proper bar referencing with   offset\nPrevents lookahead bias with lookahead=off parameter\nStrategy mode with accurate commission and slippage modeling\nMulti-timeframe security function for structure analysis\nProper position state tracking to avoid duplicate signals\n\nRisk Disclaimer\n\nThis strategy is provided for educational and research purposes only. Past performance does not guarantee future results. Backtesting results may differ from live trading due to slippage, execution delays, and changing market conditions. The strategy performs best in trending markets and may experience drawdowns during ranging conditions. Always practice proper risk management and never risk more than you can afford to lose. It is recommended to paper trade first and start with small position sizes when going live.\n\nHow to Use\n\nAdd the strategy to your TradingView chart\nSelect your desired timeframe (1m to 4h recommended)\nAdjust parameters based on your risk tolerance and trading style\nReview backtest results in the Strategy Tester tab\nSet up alerts for automated notifications\nConsider paper trading before risking real capital\n\nTags\nTrend Following, Turtle Trading, Donchian Channel, Structure Breakout, ATR, Cryptocurrency, Spot Trading, Risk Management, Pyramiding, Multi-Timeframe Analysis\n\n---\n\nStrategy Name: Trend Following BTC\nVersion: v1.0\nPine Script Version: v6\nLast Updated: December 2025",
    "image_url": "YVaGAcV3",
    "author": "ssun_6",
    "likes_count": 15,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-12",
    "updated": "2025-12-12",
    "source": "//@version=6\r\nstrategy(\"Trend $BTC/LUNC/SOMI\", shorttitle=\"$BTC/LUNC/SOMI 5/15m\", overlay=true, \r\n         initial_capital=10000, \r\n         default_qty_type=strategy.cash, \r\n         default_qty_value=5000, \r\n         commission_type=strategy.commission.percent, \r\n         commission_value=0.06,\r\n         slippage=0,\r\n         max_lines_count=500,\r\n         max_labels_count=500)\r\n\r\n// ========== åƒæ•¸è¨­å®š ==========\r\n// å”å¥‡å®‰é€šé“åƒæ•¸\r\nentry_period = input.int(20, \"é€²å ´é€šé“é€±æœŸ\", minval=1, group=\"é€šé“è¨­å®š\")\r\nexit_period = input.int(10, \"å‡ºå ´é€šé“é€±æœŸ\", minval=1, group=\"é€šé“è¨­å®š\")\r\n\r\n// ATR åƒæ•¸\r\natr_period = input.int(20, \"ATR é€±æœŸ\", minval=1, group=\"ATR è¨­å®š\")\r\natr_stop_mult = input.float(2.0, \"æ­¢æ ATR å€æ•¸\", minval=0.1, step=0.1, group=\"ATR è¨­å®š\")\r\natr_add_mult = input.float(0.5, \"åŠ å€‰ ATR å€æ•¸\", minval=0.1, step=0.1, group=\"ATR è¨­å®š\")\r\n\r\n// å¤šç©ºçµæ§‹åƒæ•¸ - åŠ å…¥å¤šæ™‚é–“æ¡†æž¶\r\nswing_length = input.int(300, \"çµæ§‹æ“ºå‹•é•·åº¦\", minval=1, group=\"ðŸ“Š å¤šç©ºçµæ§‹éŽæ¿¾\")\r\nstructure_timeframe = input.timeframe(\"3\", \"çµæ§‹æ™‚é–“æ¡†æž¶\", group=\"ðŸ“Š å¤šç©ºçµæ§‹éŽæ¿¾\", tooltip=\"é¸æ“‡çµæ§‹åˆ¤æ–·çš„æ™‚é–“é€±æœŸ,ç©ºç™½=ç•¶å‰åœ–è¡¨,D=æ—¥ç·š,W=é€±ç·š\")\r\nshow_structure_lines = input.bool(false, \"é¡¯ç¤ºçµæ§‹ç·š\", group=\"ðŸ“Š å¤šç©ºçµæ§‹éŽæ¿¾\")\r\nshow_structure_labels = input.bool(false, \"é¡¯ç¤ºçµæ§‹æ¨™ç±¤\", group=\"ðŸ“Š å¤šç©ºçµæ§‹éŽæ¿¾\")\r\n\r\n// åŠ å€‰è¨­å®š\r\nmax_units = input.int(2, \"æœ€å¤§å–®ä½æ•¸(å«é¦–æ¬¡)\", minval=1, maxval=10, group=\"å€‰ä½ç®¡ç†\")\r\nposition_size = input.int(5000, \"æ¯å–®ä½è³‡é‡‘(USD)\", minval=100, group=\"å€‰ä½ç®¡ç†\", tooltip=\"10000Uæœ¬é‡‘åˆ†2æ¬¡é€²å ´ï¼Œæ¯æ¬¡5000U\")\r\n\r\n// é¡¯ç¤ºè¨­å®š\r\nshow_channels = input.bool(false, \"é¡¯ç¤ºé€šé“\", group=\"é¡¯ç¤ºè¨­å®š\")\r\nshow_atr_lines = input.bool(false, \"é¡¯ç¤º ATR ç·š\", group=\"é¡¯ç¤ºè¨­å®š\")\r\nshow_labels = input.bool(true, \"é¡¯ç¤ºæ¨™ç±¤\", group=\"é¡¯ç¤ºè¨­å®š\")\r\nshow_table = input.bool(false, \"é¡¯ç¤ºè³‡è¨Šé¢æ¿\", group=\"é¡¯ç¤ºè¨­å®š\")\r\nlabel_distance = input.float(2.5, \"æ¨™ç±¤è·é›¢ K æ£’å€æ•¸\", minval=0.1, step=0.1, group=\"é¡¯ç¤ºè¨­å®š\", tooltip=\"æ¨™ç±¤è·é›¢Kæ£’çš„ATRå€æ•¸\")\r\nshow_label_lines = input.bool(false, \"é¡¯ç¤ºæ¨™ç±¤é€£ç·š\", group=\"é¡¯ç¤ºè¨­å®š\")\r\n\r\n// ========== è¨ˆç®—å”å¥‡å®‰é€šé“ ==========\r\nentry_upper = ta.highest(high, entry_period)\r\nentry_lower = ta.lowest(low, entry_period)\r\nexit_upper = ta.highest(high, exit_period)\r\nexit_lower = ta.lowest(low, exit_period)\r\n\r\n// ========== è¨ˆç®— ATR (Nå€¼) ==========\r\nN = ta.atr(atr_period)\r\n\r\n// ========== å¤šæ™‚é–“æ¡†æž¶å¤šç©ºçµæ§‹åˆ¤æ–· ==========\r\n// è¨ˆç®—çµæ§‹çš„å‡½æ•¸\r\nf_calculate_structure() =>\r\n    var int trend = 0\r\n    var float lastHigh = na\r\n    var float lastLow = na\r\n    \r\n    swingHigh = ta.pivothigh(high, swing_length, swing_length)\r\n    swingLow = ta.pivotlow(low, swing_length, swing_length)\r\n    \r\n    if not na(swingHigh)\r\n        lastHigh := swingHigh\r\n    \r\n    if not na(swingLow)\r\n        lastLow := swingLow\r\n    \r\n    if not na(lastHigh) and close > lastHigh and trend != 1\r\n        trend := 1\r\n    \r\n    if not na(lastLow) and close < lastLow and trend != -1\r\n        trend := -1\r\n    \r\n    [trend, lastHigh, lastLow]\r\n\r\n// ç²å–æŒ‡å®šæ™‚é–“æ¡†æž¶çš„çµæ§‹\r\n[structure_trend_mtf, last_structure_high_mtf, last_structure_low_mtf] = request.security(syminfo.tickerid, structure_timeframe, f_calculate_structure(), lookahead=barmerge.lookahead_off)\r\n\r\n// ä½¿ç”¨å¤šæ™‚é–“æ¡†æž¶çš„çµæ§‹è¶¨å‹¢\r\nstructure_trend = structure_trend_mtf\r\nlast_structure_high = last_structure_high_mtf\r\nlast_structure_low = last_structure_low_mtf\r\n\r\n// æª¢æ¸¬çµæ§‹è®ŠåŒ–ï¼ˆç”¨æ–¼ç¹ªè£½æ¨™ç±¤ï¼‰\r\nvar int prev_structure_trend = 0\r\nbool bull_break = structure_trend == 1 and prev_structure_trend != 1\r\nbool bear_break = structure_trend == -1 and prev_structure_trend != -1\r\nprev_structure_trend := structure_trend\r\n\r\n// ç¹ªè£½çµæ§‹çªç ´æ¨™ç±¤\r\nif show_structure_labels\r\n    if bull_break\r\n        label.new(bar_index, low, \"å¤šæ–¹çµæ§‹\", style=label.style_label_up, color=color.new(color.green, 0), textcolor=color.white, size=size.small)\r\n    \r\n    if bear_break\r\n        label.new(bar_index, high, \"ç©ºæ–¹çµæ§‹\", style=label.style_label_down, color=color.new(color.red, 0), textcolor=color.white, size=size.small)\r\n\r\n// ========== æŒå€‰ç‹€æ…‹è¿½è¹¤ ==========\r\nvar float entry_price = na\r\nvar float[] add_prices = array.new_float(0)\r\nvar int position = 0\r\nvar int units = 0\r\nvar float stop_loss = na\r\n\r\n// ========== é€²å ´è¨Šè™Ÿ (åŠ å…¥çµæ§‹éŽæ¿¾) ==========\r\nlong_entry_signal = close > entry_upper[1] and structure_trend == 1\r\nshort_entry_signal = close < entry_lower[1] and structure_trend == -1\r\n\r\nlong_entry = long_entry_signal and position != 1\r\nshort_entry = short_entry_signal and position != -1\r\n\r\n// ========== åŠ å€‰è¨Šè™Ÿ ==========\r\nlong_add = false\r\nshort_add = false\r\n\r\nif position == 1 and units < max_units\r\n    if array.size(add_prices) > 0\r\n        last_add_price = array.get(add_prices, array.size(add_prices) - 1)\r\n        long_add := close >= last_add_price + (atr_add_mult * N)\r\n    else\r\n        long_add := close >= entry_price + (atr_add_mult * N)\r\n\r\nif position == -1 and units < max_units\r\n    if array.size(add_prices) > 0\r\n        last_add_price = array.get(add_prices, array.size(add_prices) - 1)\r\n        short_add := close <= last_add_price - (atr_add_mult * N)\r\n    else\r\n        short_add := close <= entry_price - (atr_add_mult * N)\r\n\r\n// ========== å‡ºå ´è¨Šè™Ÿ (æ”¹ç‚ºåå‘è¨Šè™Ÿå‡ºå ´) ==========\r\n// å¤šå–®å‡ºå ´ï¼šç•¶ç©ºå–®é€²å ´è¨Šè™Ÿè§¸ç™¼æ™‚\r\nlong_exit = (position == 1) and short_entry_signal\r\n\r\n// ç©ºå–®å‡ºå ´ï¼šç•¶å¤šå–®é€²å ´è¨Šè™Ÿè§¸ç™¼æ™‚\r\nshort_exit = (position == -1) and long_entry_signal\r\n\r\n// ========== æ›´æ–°æŒå€‰ç‹€æ…‹ ==========\r\nif long_entry\r\n    position := 1\r\n    units := 1\r\n    entry_price := close\r\n    array.clear(add_prices)\r\n    array.push(add_prices, close)\r\n    stop_loss := close - (atr_stop_mult * N)\r\n    alert_msg = timeframe.period + \" åšå¤š EP:\" + str.tostring(close, \"#.##\")\r\n    strategy.entry(\"å¤šå–®1\", strategy.long, qty=position_size/close, comment=alert_msg, alert_message=alert_msg)\r\n    \r\nelse if short_entry\r\n    position := -1\r\n    units := 1\r\n    entry_price := close\r\n    array.clear(add_prices)\r\n    array.push(add_prices, close)\r\n    stop_loss := close + (atr_stop_mult * N)\r\n    alert_msg = timeframe.period + \" åšç©º EP:\" + str.tostring(close, \"#.##\")\r\n    strategy.entry(\"ç©ºå–®1\", strategy.short, qty=position_size/close, comment=alert_msg, alert_message=alert_msg)\r\n    \r\nelse if long_add\r\n    units := units + 1\r\n    array.push(add_prices, close)\r\n    stop_loss := close - (atr_stop_mult * N)\r\n    alert_msg = timeframe.period + \" åŠ å€‰å¤š \" + str.tostring(units) + \"/\" + str.tostring(max_units) + \" EP:\" + str.tostring(close, \"#.##\")\r\n    strategy.entry(\"å¤šå–®\" + str.tostring(units), strategy.long, qty=position_size/close, comment=alert_msg, alert_message=alert_msg)\r\n    \r\nelse if short_add\r\n    units := units + 1\r\n    array.push(add_prices, close)\r\n    stop_loss := close + (atr_stop_mult * N)\r\n    alert_msg = timeframe.period + \" åŠ å€‰ç©º \" + str.tostring(units) + \"/\" + str.tostring(max_units) + \" EP:\" + str.tostring(close, \"#.##\")\r\n    strategy.entry(\"ç©ºå–®\" + str.tostring(units), strategy.short, qty=position_size/close, comment=alert_msg, alert_message=alert_msg)\r\n    \r\nelse if long_exit or short_exit\r\n    if long_exit\r\n        alert_msg = timeframe.period + \" å¹³å¤š åå‘è¨Šè™Ÿ\"\r\n        strategy.close_all(comment=alert_msg, alert_message=alert_msg)\r\n    if short_exit\r\n        alert_msg = timeframe.period + \" å¹³ç©º åå‘è¨Šè™Ÿ\"\r\n        strategy.close_all(comment=alert_msg, alert_message=alert_msg)\r\n    \r\n    position := 0\r\n    units := 0\r\n    entry_price := na\r\n    array.clear(add_prices)\r\n    stop_loss := na\r\n\r\n// ========== ç¹ªè£½é€šé“ ==========\r\nplot(show_channels ? entry_upper : na, \"é€²å ´ä¸Šè»Œ\", color=color.new(color.red, 0), linewidth=2)\r\nplot(show_channels ? entry_lower : na, \"é€²å ´ä¸‹è»Œ\", color=color.new(color.green, 0), linewidth=2)\r\nplot(show_channels ? exit_upper : na, \"å‡ºå ´ä¸Šè»Œ\", color=color.new(color.orange, 50), linewidth=1, style=plot.style_circles)\r\nplot(show_channels ? exit_lower : na, \"å‡ºå ´ä¸‹è»Œ\", color=color.new(color.blue, 50), linewidth=1, style=plot.style_circles)\r\n\r\n// ç¹ªè£½çµæ§‹é«˜ä½Žé»ž\r\nplot(show_structure_lines ? last_structure_high : na, \"çµæ§‹é«˜é»ž\", color=color.new(color.red, 85), linewidth=2, style=plot.style_stepline)\r\nplot(show_structure_lines ? last_structure_low : na, \"çµæ§‹ä½Žé»ž\", color=color.new(color.green, 85), linewidth=2, style=plot.style_stepline)\r\n\r\n// ========== ç¹ªè£½ ATR ç·š ==========\r\nplot(show_atr_lines and position != 0 ? stop_loss : na, \"æ­¢æç·š\", color=color.new(color.red, 0), linewidth=2, style=plot.style_cross)\r\n\r\nvar float next_add_long = na\r\nif position == 1 and units < max_units\r\n    next_add_long := array.size(add_prices) > 0 ? array.get(add_prices, array.size(add_prices) - 1) + (atr_add_mult * N) : entry_price + (atr_add_mult * N)\r\nelse\r\n    next_add_long := na\r\n\r\nplot(show_atr_lines and position == 1 and units < max_units ? next_add_long : na, \"ä¸‹æ¬¡åŠ å€‰(å¤š)\", color=color.new(color.yellow, 30), linewidth=1, style=plot.style_stepline)\r\n\r\nvar float next_add_short = na\r\nif position == -1 and units < max_units\r\n    next_add_short := array.size(add_prices) > 0 ? array.get(add_prices, array.size(add_prices) - 1) - (atr_add_mult * N) : entry_price - (atr_add_mult * N)\r\nelse\r\n    next_add_short := na\r\n\r\nplot(show_atr_lines and position == -1 and units < max_units ? next_add_short : na, \"ä¸‹æ¬¡åŠ å€‰(ç©º)\", color=color.new(color.yellow, 30), linewidth=1, style=plot.style_stepline)\r\n\r\n// ========== ç¹ªè£½è¨Šè™Ÿæ¨™ç±¤ ==========\r\nif show_labels\r\n    label_offset = N * label_distance\r\n    long_label_style = show_label_lines ? label.style_label_up : label.style_none\r\n    short_label_style = show_label_lines ? label.style_label_down : label.style_none\r\n    \r\n    if long_entry\r\n        label.new(bar_index, low - label_offset, \"åšå¤šBTC\\nå–®ä½1/\" + str.tostring(max_units), color=color.new(color.green, 0), style=long_label_style, textcolor=color.white, size=size.normal, textalign=text.align_center)\r\n    \r\n    if short_entry\r\n        label.new(bar_index, high + label_offset, \"åšç©ºBTC\\nå–®ä½1/\" + str.tostring(max_units), color=color.new(color.red, 0), style=short_label_style, textcolor=color.white, size=size.normal, textalign=text.align_center)\r\n    \r\n    if long_add\r\n        label.new(bar_index, low - label_offset, \"åŠ å€‰å¤šå–®BTC\\nå–®ä½\" + str.tostring(units) + \"/\" + str.tostring(max_units), color=color.new(color.lime, 0), style=long_label_style, textcolor=color.black, size=size.small, textalign=text.align_center)\r\n    \r\n    if short_add\r\n        label.new(bar_index, high + label_offset, \"åŠ å€‰ç©ºå–®BTC\\nå–®ä½\" + str.tostring(units) + \"/\" + str.tostring(max_units), color=color.new(color.maroon, 0), style=short_label_style, textcolor=color.white, size=size.small, textalign=text.align_center)\r\n    \r\n    if long_exit\r\n        label.new(bar_index, low - label_offset, \"å¹³å¤šBTC\\nåå‘è¨Šè™Ÿ\", color=color.new(color.orange, 0), style=long_label_style, textcolor=color.white, size=size.normal, textalign=text.align_center)\r\n    \r\n    if short_exit\r\n        label.new(bar_index, high + label_offset, \"å¹³ç©ºBTC\\nåå‘è¨Šè™Ÿ\", color=color.new(color.blue, 0), style=short_label_style, textcolor=color.white, size=size.normal, textalign=text.align_center)\r\n\r\n// ========== èƒŒæ™¯é¡è‰² ==========\r\nbgcolor(structure_trend == 1 ? color.new(color.green, 70) : structure_trend == -1 ? color.new(color.red, 70) : na, title=\"çµæ§‹è¶¨å‹¢\")\r\nbgcolor(long_entry ? color.new(color.green, 85) : na, title=\"å¤šå–®é€²å ´\")\r\nbgcolor(short_entry ? color.new(color.red, 85) : na, title=\"ç©ºå–®é€²å ´\")\r\nbgcolor(long_add ? color.new(color.lime, 90) : na, title=\"å¤šå–®åŠ å€‰\")\r\nbgcolor(short_add ? color.new(color.maroon, 90) : na, title=\"ç©ºå–®åŠ å€‰\")\r\n"
  },
  {
    "url": "YCs14F4c-Volatility-Trend-Follower",
    "name": "Volatility Trend Follower",
    "description": "The script combines several classic technical analysis techniques:\n\nSuperTrend / Adaptive Band - The main idea comes from the SuperTrend indicator, which uses ATR (Average True Range) to create a trailing band that adapts to volatility\n\nATR (Average True Range) - A volatility measure developed by J. Welles Wilder Jr.\n\nEMA (Exponential Moving Average) - Used as a global trend filter\n\nHeikin Ashi - An option to smooth prices and reduce noise",
    "image_url": "YCs14F4c",
    "author": "Benji1302",
    "likes_count": 7,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=5\nstrategy(\"Volatility Trend Follower\", overlay=true, default_qty_type=strategy.percent_of_equity, default_qty_value=100)\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// PARAMÃˆTRES UTILISATEUR\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nmultiplier      = input.float(2.0,   \"Multiplicateur VolatilitÃ©\", minval=0.5, maxval=5, step=0.1)\nvolatilityLen   = input.int(14,      \"PÃ©riode VolatilitÃ©\", minval=1)\ntrendFilterLen  = input.int(100,     \"PÃ©riode Filtre Tendance\", minval=10)\nuseHeikinAshi   = input.bool(false,  \"Utiliser Heikin Ashi\")\nuseTrendFilter  = input.bool(true,   \"Activer Filtre Tendance\")\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// CALCUL DE LA SOURCE DE PRIX\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nhaClose = request.security(ticker.heikinashi(syminfo.tickerid), timeframe.period, close)\npriceSource = useHeikinAshi ? haClose : close\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// INDICATEUR DE VOLATILITÃ‰ (bande dynamique)\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nvolatility = ta.atr(volatilityLen)\nbandDistance = multiplier * volatility\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// BANDE ADAPTATIVE (trailing)\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nvar float adaptiveBand = na\nvar int currentDirection = 0\n\nupperBand = priceSource + bandDistance\nlowerBand = priceSource - bandDistance\n\nif na(adaptiveBand)\n    adaptiveBand := lowerBand\n    currentDirection := 1\nelse\n    if currentDirection == 1\n        adaptiveBand := math.max(adaptiveBand, lowerBand)\n        if priceSource < adaptiveBand\n            adaptiveBand := upperBand\n            currentDirection := -1\n    else\n        adaptiveBand := math.min(adaptiveBand, upperBand)\n        if priceSource > adaptiveBand\n            adaptiveBand := lowerBand\n            currentDirection := 1\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// FILTRE DE TENDANCE GLOBAL\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\ntrendLine = ta.ema(priceSource, trendFilterLen)\nbullishTrend = priceSource > trendLine\nbearishTrend = priceSource < trendLine\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// DÃ‰TECTION DES SIGNAUX\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\ndirectionChanged = currentDirection != currentDirection[1]\nlongSignal  = directionChanged and currentDirection == 1\nshortSignal = directionChanged and currentDirection == -1\n\n// Application du filtre de tendance\nvalidLong  = longSignal and (useTrendFilter ? bullishTrend : true)\nvalidShort = shortSignal and (useTrendFilter ? bearishTrend : true)\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// AFFICHAGE\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nbandColor = currentDirection == 1 ? color.new(color.teal, 0) : color.new(color.maroon, 0)\nplot(adaptiveBand, \"Bande Adaptative\", color=bandColor, linewidth=2)\nplot(useTrendFilter ? trendLine : na, \"Tendance\", color=color.gray, linewidth=1)\n\nplotshape(validLong,  \"Achat\",  shape.triangleup,   location.belowbar, color.teal,   size=size.small)\nplotshape(validShort, \"Vente\",  shape.triangledown, location.abovebar, color.maroon, size=size.small)\n\nbarcolor(currentDirection == 1 ? color.new(color.teal, 70) : color.new(color.maroon, 70))\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// EXÃ‰CUTION STRATÃ‰GIE\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nif validLong\n    strategy.close(\"Short\")\n    strategy.entry(\"Long\", strategy.long)\n\nif validShort\n    strategy.close(\"Long\")\n    strategy.entry(\"Short\", strategy.short)\n\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n// ALERTES\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nalertcondition(validLong,  \"Signal Achat\",  \"ACHAT_SIGNAL\")\nalertcondition(validShort, \"Signal Vente\",  \"VENTE_SIGNAL\")"
  },
  {
    "url": "KlaTN7AD-Elliott-Wave-Full-Fractal-System-v2-0",
    "name": "Elliott Wave Full Fractal System v2.0",
    "description": "Elliott Wave Full Fractal System v2.0 â€“ Q.C. FINAL (Guaranteed R/R) \n\nElliott Wave Full Fractal System is a multi-timeframe wave engine that automatically labels Elliott impulses and ABC corrections, then builds a rule-based, ATR-driven risk/reward framework around the â€œW3â€“W4â€“W5â€ leg.\nâ€œGuaranteed R/Râ€ here means every order is placed with a predefined stop-loss and take-profit that respect a minimum Reward:Risk ratio â€“ it does  not  mean guaranteed profits.\n\n Core Idea \nThis strategy turns a full fractal Elliott Wave labelling engine into a systematic trading model.\nIt scans fractal pivots on three wave degrees (Primary, Intermediate, Minor) to detect 5-wave impulses and ABC corrections.\nA separate â€œTrading Degreeâ€ pivot stream, filtered by a 200-EMA trend filter and ATR-based dynamic pivots, is then used to find W4 pullback entries with a minimum, user-defined Reward:Risk ratio.\n\n Default Properties & Risk Assumptions \nThe backtest uses realistic but conservative defaults:\n\n \n// Default properties used for backtesting\nstrategy(\n\"Elliott Wave Full Fractal System - Q.C. FINAL (Guaranteed R/R)\",\noverlay           = true,\ninitial_capital   = 10000,      // realistic account size\ndefault_qty_type  = strategy.percent_of_equity,\ndefault_qty_value = 1,          // 1% risk per trade\ncommission_type   = strategy.commission.cash_per_contract,\ncommission_value  = 0.005,      // example stock commission\nslippage          = 0           // see notes below\n)\n \n \n Account size:  10,000 (can be changed to match your own account).\n Position sizing:  1% of equity per trade to keep risk per idea sustainable and aligned with TradingViewâ€™s recommendations.\n Commission:  0.005 cash per contract/share as a realistic example for stock trading.\n Slippage:  set to 0 in code for clarity of â€œpure logicâ€ backtesting. Real-life trading will experience slippage, so users should adjust this according to their market and broker.\n \n Always re-run the backtest after changing any of these values, and avoid using high risk fractions (5â€“10%+) as that is rarely sustainable. \n\n 1. Full Fractal Wave Engine \nThe script builds and maintains four pivot streams using ATR-adaptive fractals:\n \n Primary Degree (Macro Trend): \nCaptures the large swings that define the major trend. Labels â‘ â€“â‘¤ and â’¶â’·â’¸ using blue â€œCircleâ€ labels and thicker lines.\n Intermediate Degree (Trading Degree): \nCaptures the medium swings (swing-trading horizon). Uses teal labels ( (1)â€¦(5), (A)(B)(C) ).\n Minor Degree (Micro Structure): \nTracks short-term swings inside the larger waves. Uses red roman numerals (iâ€¦v, a b c).\n ABC Corrections (Optional): \nWhen enabled, the engine tries to detect standard Aâ€“Bâ€“C corrective structures that follow a completed 5-wave impulse and plots them with dashed lines.\n \nEach degree uses a dynamic pivot lookback that expands when ATR is above its EMA, so the system naturally requires â€œstrongerâ€ pivots in volatile environments and reacts faster in quiet conditions.\n\n 2. Theory Rules & Strict Mode \n \n Normal Mode:  More permissive detection. Designed to show more wave structures for educational / exploratory use.\n Strict Mode:  Enforces key Elliott constraints:\n \n Wave 3 not shorter than waves 1 and 5.\n No invalid W4 overlap with W1 (for standard impulses).\n \n ABC Logic:  After a confirmed bullish impulse, the script expects a down-up-down corrective pattern (A,B,C). After a bearish impulse, it looks for up-down-up.\n \n 3. Trend Filter & Pivots \n \n EMA Trend Filter:  A configurable EMA (default 200) is used as a non-wave trend filter.\n \n Price above EMA â†’ Only long setups are considered.\n Price below EMA â†’ Only short setups are considered.\n \n ATR-Adaptive Pivots:  The pivot engine scales its left/right bars based on current ATR vs ATR EMA, making waves and trading pivots more robust in volatile regimes.\n \n 4. Dynamic Risk Management (Guaranteed R/R Engine) \n\nThe trading engine is designed around risk, not just pattern recognition:\n \n ATR-Based Stop: \nStop-loss is placed at:\n Entry Â± ATR Ã— Multiplier  (user-configurable, default 2.0).\nThis anchors risk to current volatility.\n Minimum Reward:Risk Ratio: \nFor each setup, the script:\n \n Computes the distance from entry to stop (risk).\n Projects a take-profit target at  risk Ã— min_rr_ratio  away from entry.\n Only accepts the setup if risk is positive and the required R:R ratio is achievable.\n \n Result:  Every order is created with both TP and SL at a predefined distance, so each trade starts with a known, minimum Reward:Risk profile by design.\n \n â€œGuaranteed R/Râ€ refers exclusively to this order placement logic (TP/SL geometry), not to win-rate or profitability. \n\n 5. Trading Logic â€“ W3â€“W4â€“W5 Pattern \n\nThe Trading pivot stream (separate from visual wave degrees) looks for a simple but powerful pattern:\n \n Bullish structure: \n \n Sequence of pivots forms a higher-high / higher-low pattern.\n Price is above the EMA trend filter.\n A strong â€œW3â€ leg is confirmed with structure rules (optionally stricter in Strict mode).\n \n Entry (Long â€“ W4 Pullback): \n \n The â€œheightâ€ of W3 is measured.\n Entry is placed at a configurable Fibonacci pullback (default 50%) inside that leg.\n ATR-based stop is placed below entry.\n Take-profit is projected to satisfy min Reward:Risk.\n \n Bearish structure: \nMirrored logic (lower highs/lows, price below EMA, W3 down, W4 retrace up, W5 continuation down).\n \nOnce a valid setup is found, the script draws a colored box around the entry zone and a label describing the type of signal (â€œLONG SETUPâ€ or â€œSHORT SETUPâ€) with the suggested limit price.\n\n 6. Orders & Execution \n \n Entry Orders:  The strategy uses  limit  orders at the computed W4 level (â€œSniper Longâ€ or â€œSniper Shortâ€).\n Exits:  A single strategy.exit() is attached to each entry with:\n \n Take-profit at the projected minimum R:R target.\n Stop-loss at ATR-based level.\n \n One Trade at a Time:  New setups are only used when there is no open position (strategy.opentrades == 0) to keep the logic clear and risk contained.\n \n 7. Visual Guide on the Chart \n \n Wave Labels: \n \n Primary: â‘ ,â‘¡,â‘¢,â‘£,â‘¤, â’¶â’·â’¸\n Intermediate: (1)â€¦(5), (A)(B)(C)\n Minor: iâ€¦v, a b c\n \n Trend EMA:  Single blue EMA showing the dominant trend.\n Setup Boxes: \n \n Green transparent box â†’ long entry zone.\n Red transparent box â†’ short entry zone.\n \n Labels:  â€œLONG SETUP / SHORT SETUPâ€ labels mark the proposed limit entry with price.\n \n 8. How to Use This Strategy \n \n Attach the strategy to your chart \nChoose your market (stocks, indices, FX, crypto, futures, etc.) and timeframe (for example 1h, 4h, or Daily). Then add the strategy to the chart from your Scripts list.\n\n Start with the default settings \nLeave all inputs on their defaults first. This lets you see the â€œintendedâ€ behaviour and the exact properties used for the published backtest (account size, 1% risk, commission, etc.).\n\n Study the wave map \nZoom in and out and look at the three wave degrees:\n \n Blue circles â†’ Primary degree (big picture trend).\n Teal (1)â€¦(5) â†’ Intermediate degree (swing structure).\n Red iâ€¦v â†’ Minor degree (micro waves).\n \nUse this to understand how the engine is interpreting the Elliott structure on your symbol.\n\n Watch for valid setups \nLook for the coloured boxes and labels:\n \n Green box + â€œLONG SETUPâ€ label â†’ potential W4 pullback long in an uptrend.\n Red box + â€œSHORT SETUPâ€ label â†’ potential W4 pullback short in a downtrend.\n \nOnly trades in the direction of the EMA trend filter are allowed by the strategy.\n\n Check the Reward:Risk of each idea \nFor each setup, inspect:\n \n Limit entry price.\n ATR-based stop level.\n Projected take-profit level.\n \nMake sure the minimum Reward:Risk ratio matches your own rules before you consider trading it.\n\n Backtest and evaluate \nOpen the Strategy Tester:\n \n Verify you have a decent sample size (ideally 100+ trades).\n Check drawdowns, average trade, win-rate and R:R distribution.\n Change markets and timeframes to see where the logic behaves best.\n \n Adapt to your own risk profile \nIf you plan to use it live:\n \n Set  Initial Capital  to your real account size.\n Adjust  default_qty_value  to a risk level you are comfortable with (often 0.5â€“2% per trade).\n Set  commission  and  slippage  to realistic broker values.\n Re-run the backtest after every major change.\n \n Use as a framework, not a signal machine \nTreat this as a structured Elliott/R:R framework:\n \n Filter signals by higher-timeframe trend, major S/R, volume, or fundamentals.\n Optionally hide some wave degrees or ABC labels if you want a cleaner chart.\n Combine the systemâ€™s structure with your own trade management and discretion.\n \n \n Best Practices & Limitations \n \n This is an  approximate  Elliott Wave engine based on fractal pivots. It does not replace a full discretionary Elliott analysis.\n All wave counts are algorithmic and can differ from a manual analystâ€™s interpretation.\n Like any backtest, results depend heavily on:\n \n Symbol and timeframe.\n Sample size (more trades are better).\n Realistic commission/slippage settings.\n \n The 0-slippage default is chosen only to show the â€œraw logicâ€. In real markets, slippage can significantly impact performance.\n No strategy wins all the time. Losing streaks and drawdowns will still occur even with a strict R:R framework.\n \n Disclaimer \n\n This script is for educational and research purposes only and does not constitute financial advice or a recommendation to buy or sell any security. Past performance, whether real or simulated, is not indicative of future results. Always test on multiple symbols/timeframes, use conservative risk, and consult your financial advisor before trading live capital. \n",
    "image_url": "KlaTN7AD",
    "author": "mbedaiwi2",
    "likes_count": 15,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// Â© mbedaiwi2\n\n//@version=6 \nstrategy(\n     \"Elliott Wave Full Fractal System v2.0\", \n     overlay             = true,\n     max_labels_count    = 500,\n     max_lines_count     = 500,\n     max_boxes_count     = 500,\n     initial_capital     = 10000,\n     default_qty_type    = strategy.percent_of_equity,\n     default_qty_value   = 1,\n     commission_type     = strategy.commission.cash_per_contract,\n     commission_value    = 0.005,\n     slippage            = 0\n)\n\n// 1. SETTINGS -------------------------------------------------------------\n\n// 1.1 Wave degrees\ngrpCycle   = \"1. Primary Degree (Macro Trend)\"\nshowPrimary = input.bool(true, \"Show Primary Waves (1, 2...)\", group = grpCycle)\nlenPriL     = input.int(21, \"Primary Lookback Left\",  group = grpCycle)\nlenPriR     = input.int(21, \"Primary Lookback Right\", group = grpCycle)\n\ngrpInter   = \"2. Intermediate Degree (Trading Degree)\"\nshowInter   = input.bool(true, \"Show Intermediate Waves ((1), (2)...)\", group = grpInter)\nlenIntL = input.int(5,   \"Intermediate Lookback Left\",  minval = 2, group = grpInter)\nlenIntR = input.int(5,   \"Intermediate Lookback Right\", minval = 2, group = grpInter)\n\ngrpMinor   = \"3. Minor Degree (Micro Structure)\"\nshowMinor   = input.bool(true, \"Show Minor Waves (i, ii...)\", group = grpMinor)\nlenMinL = input.int(3,   \"Minor Lookback Left\",  group = grpMinor)\nlenMinR = input.int(3,   \"Minor Lookback Right\", group = grpMinor)\n\n// 1.2 Rules\ngrpRules    = \"Theory Rules\"\nrule_Strict = input.bool(false, \"Strict Rules (No Overlap, W3 Not Shortest)\", group = grpRules)\nshowABC     = input.bool(true, \"Show ABC Corrections\", group = grpRules)\n\n// 1.3 Pivot / ATR\ngrpVol = \"Pivot Dynamics\"\natr_len = input.int(14, \"ATR Lookback for Dynamic Pivots\", group = grpVol)\n\n// 1.4 EMA Trend Filter\ngrpFilter = \"4. Trend Filter (Non-Wave)\"\nema_len = input.int(200, \"EMA Trend Filter Length\", group = grpFilter)\nema_filter = ta.ema(close, ema_len)\nplot(ema_filter, color = color.blue, title = \"Trend EMA\")\n\n// 1.5 Dynamic Risk Management\ngrpRisk = \"5. Dynamic Risk Management\"\natr_stop_mult = input.float(2.0, \"ATR Stop Multiplier (Stop = Entry +/- ATR*X)\", minval = 1.0, step = 0.1, group = grpRisk)\nmin_rr_ratio = input.float(2.0, \"Minimum Reward/Risk Ratio (TP Target)\", minval = 1.5, step = 0.5, group = grpRisk)\n\n// 1.6 Trading Settings\ngrpTrade   = \"STRATEGY SETTINGS\"\ntrade_on = input.bool(true, \"Active Trading Signals\", group = grpTrade)\nfib_entry = input.float(0.50, \"W4 Entry Fib\", minval = 0.2, maxval = 0.7, step = 0.02, group = grpTrade)\nfib_target = input.float(1.618, \"W5 Target Extension (Deprecated)\", group = grpTrade) \n\n// 2. GLOBAL ARRAYS & STATE (Unchanged)\nvar int[]  pri_idx = array.new_int()\nvar float[] pri_prc = array.new_float()\nvar int[]  pri_typ = array.new_int()\n\nvar int[]  int_idx = array.new_int()\nvar float[] int_prc = array.new_float()\nvar int[]  int_typ = array.new_int()\n\nvar int[]  min_idx = array.new_int()\nvar float[] min_prc = array.new_float()\nvar int[]  min_typ = array.new_int()\n\nvar int[]  trd_idx = array.new_int()\nvar float[] trd_prc = array.new_float()\nvar int[]  trd_typ = array.new_int()\n\nvar int[]  lastIdxArr     = array.new_int(3, 0)\nvar int[]  lastW5IdxArr   = array.new_int(3, 0)\nvar bool[] lastWasBullArr = array.new_bool(3, false)\n\n\n// 3. HELPER FUNCTIONS ---------------------------------------------------------\n\n// Visual Styles\nf_get_style(_degree) =>\n    color waveColor = color.new(color.blue, 0)\n    string fmt = \"Circle\"\n    int w = 2\n    if _degree == \"Primary\"\n        waveColor := color.new(color.blue, 0)\n        fmt := \"Circle\"\n        w := 3\n    else if _degree == \"Intermediate\"\n        waveColor := color.new(color.teal, 0)\n        fmt := \"Paren\"\n        w := 2\n    else\n        waveColor := color.new(color.red, 0)\n        fmt := \"Roman\"\n        w := 1\n    [waveColor, fmt, w]\n\n// Label Drawer\nf_draw_wave(int _idx, float _price, int _count, bool _isBull, string _degree) =>\n    [cWave, fmt, wid] = f_get_style(_degree)\n    string txt = \"\"\n    if fmt == \"Circle\"\n        txt := _count == 1 ? \"â‘ \" : _count == 2 ? \"â‘¡\" : _count == 3 ? \"â‘¢\" : _count == 4 ? \"â‘£\" : _count == 5 ? \"â‘¤\" : _count == 11 ? \"â’¶\" : _count == 12 ? \"â’·\" : _count == 13 ? \"â’¸\" : \"?\"\n    else if fmt == \"Paren\"\n        txt := _count == 1 ? \"(1)\" : _count == 2 ? \"(2)\" : _count == 3 ? \"(3)\" : _count == 4 ? \"(4)\" : _count == 5 ? \"(5)\" : _count == 11 ? \"(A)\" : _count == 12 ? \"(B)\" : _count == 13 ? \"(C)\" : \"?\"\n    else\n        txt := _count == 1 ? \"i\" : _count == 2 ? \"ii\" : _count == 3 ? \"iii\" : _count == 4 ? \"iv\" : _count == 5 ? \"v\" : _count == 11 ? \"a\" : _count == 12 ? \"b\" : _count == 13 ? \"c\" : \"?\"\n\n    label.new(\n          _idx, _price, txt, xloc = xloc.bar_index, yloc = _isBull ? yloc.abovebar : yloc.belowbar,\n          style = _isBull ? label.style_label_down : label.style_label_up, color = cWave, textcolor = color.white,\n          size = _degree == \"Primary\" ? size.normal : size.small)\n\n// Utility: limit array size\nf_trim_arrays(int[] idx, float[] prc, int[] typ, int maxSize) =>\n    while array.size(idx) > maxSize\n        array.shift(idx)\n        array.shift(prc)\n        array.shift(typ)\n\n// Dynamic Pivot Updater\nf_update_pivots(int _L, int _R, int[] idx, float[] prc, int[] typ) =>\n    float atrValue = ta.atr(atr_len)\n    float avgAtr   = ta.ema(atrValue, 50)\n\n    int dynamic_L = math.round(_L * (atrValue > avgAtr ? 1.5 : 1.0))\n    int dynamic_R = math.round(_R * (atrValue > avgAtr ? 1.5 : 1.0))\n\n    dynamic_L := math.max(2, dynamic_L)\n    dynamic_R := math.max(2, dynamic_R)\n\n    float ph = ta.pivothigh(high, dynamic_L, dynamic_R)\n    float pl = ta.pivotlow(low,  dynamic_L, dynamic_R)\n\n    if not na(ph)\n        array.push(idx, bar_index[dynamic_R])\n        array.push(prc, ph)\n        array.push(typ, 1)\n    if not na(pl)\n        array.push(idx, bar_index[dynamic_R])\n        array.push(prc, pl)\n        array.push(typ, -1)\n\n    f_trim_arrays(idx, prc, typ, 300)\n\n// Visualization Engine for one degree\nf_process_degree(string _degName, int _degIndex, bool _show, int[] idx, float[] prc, int[] typ) =>\n    if not _show\n        [0, 0, false]\n    else\n        int  lastIdx     = array.get(lastIdxArr, _degIndex)\n        int  lastW5Idx   = array.get(lastW5IdxArr, _degIndex)\n        bool lastWasBull = array.get(lastWasBullArr, _degIndex)\n\n        if array.size(idx) >= 6\n            int sz = array.size(idx)\n\n            int  i0 = array.get(idx, sz - 6)\n            int  i1 = array.get(idx, sz - 5)\n            int  i2 = array.get(idx, sz - 4)\n            int  i3 = array.get(idx, sz - 3)\n            int  i4 = array.get(idx, sz - 2)\n            int  i5 = array.get(idx, sz - 1)\n            float p0 = array.get(prc, sz - 6)\n            float p1 = array.get(prc, sz - 5)\n            float p2 = array.get(prc, sz - 4)\n            float p3 = array.get(prc, sz - 3)\n            float p4 = array.get(prc, sz - 2)\n            float p5 = array.get(prc, sz - 1)\n            int  t0 = array.get(typ, sz - 6)\n\n            // â”€â”€ IMPULSE WAVE DETECTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n            if i0 > lastIdx\n                // Bullish 5-wave\n                if t0 == -1 and p1 > p0 and p3 > p1 and p5 > p3 and p2 > p0 and p4 > p2\n                    \n                    bool r3_gt_r1      = rule_Strict ? (math.abs(p3 - p2) > math.abs(p1 - p0)) : true\n                    bool r4_no_overlap = rule_Strict ? (p4 > p1) : true\n\n                    float len1          = math.abs(p1 - p0)\n                    float len3          = math.abs(p3 - p2)\n                    float len5          = math.abs(p5 - p4)\n                    float min_len       = math.min(len1, math.min(len3, len5))\n                    bool  r3_not_short  = rule_Strict ? (len3 > min_len) : true\n\n                    if r3_gt_r1 and r4_no_overlap and r3_not_short\n                        lastIdx     := i5\n                        lastW5Idx   := i5\n                        lastWasBull := true\n\n                        f_draw_wave(i1, p1, 1, true, _degName)\n                        f_draw_wave(i2, p2, 2, true, _degName)\n                        f_draw_wave(i3, p3, 3, true, _degName)\n                        f_draw_wave(i4, p4, 4, true, _degName)\n                        f_draw_wave(i5, p5, 5, true, _degName)\n                        [c, _, w] = f_get_style(_degName)\n                        line.new(i0, p0, i1, p1, color = c, width = w)\n                        line.new(i1, p1, i2, p2, color = c, width = w)\n                        line.new(i2, p2, i3, p3, color = c, width = w)\n                        line.new(i3, p3, i4, p4, color = c, width = w)\n                        line.new(i4, p4, i5, p5, color = c, width = w)\n\n                // Bearish 5-wave\n                else if t0 == 1 and p1 < p0 and p3 < p1 and p5 < p3 and p2 < p0 and p4 < p2\n                    bool r3b_gt_r1b      = rule_Strict ? (math.abs(p2 - p3) > math.abs(p0 - p1)) : true\n                    bool r4b_no_overlap  = rule_Strict ? (p4 < p1) : true\n\n                    float len1b         = math.abs(p0 - p1)\n                    float len3b         = math.abs(p2 - p3)\n                    float len5b         = math.abs(p4 - p5)\n                    float min_lenb      = math.min(len1b, math.min(len3b, len5b))\n                    bool  r3_not_short_b = rule_Strict ? (len3b > min_lenb) : true\n\n                    if r3b_gt_r1b and r4b_no_overlap and r3_not_short_b\n                        lastIdx     := i5\n                        lastW5Idx   := i5\n                        lastWasBull := false\n\n                        f_draw_wave(i1, p1, 1, false, _degName)\n                        f_draw_wave(i2, p2, 2, false, _degName)\n                        f_draw_wave(i3, p3, 3, false, _degName)\n                        f_draw_wave(i4, p4, 4, false, _degName)\n                        f_draw_wave(i5, p5, 5, false, _degName)\n                        [c, _, w] = f_get_style(_degName)\n                        line.new(i0, p0, i1, p1, color = c, width = w)\n                        line.new(i1, p1, i2, p2, color = c, width = w)\n                        line.new(i2, p2, i3, p3, color = c, width = w)\n                        line.new(i3, p3, i4, p4, color = c, width = w)\n                        line.new(i4, p4, i5, p5, color = c, width = w)\n\n            // â”€â”€ ABC CORRECTION DETECTION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n            if showABC and lastW5Idx > 0 and i3 >= lastW5Idx\n                int  ia = i3, ib = i4, ic = i5\n                float pa = p3, pb = p4, pc = p5\n\n                // After bullish impulse: look for down-up-down\n                if lastWasBull and p3 < p2\n                    if pc < pa and pb < array.get(prc, sz - 4)\n                        lastIdx := ic\n                        f_draw_wave(ia, pa, 11, false, _degName)   // A\n                        f_draw_wave(ib, pb, 12, true,  _degName)   // B\n                        f_draw_wave(ic, pc, 13, false, _degName)   // C\n                        [cA, _, _wA] = f_get_style(_degName)\n                        line.new(i2, p2, ia, pa, color = color.new(cA, 50), width = 1, style = line.style_dashed)\n                        line.new(ia, pa, ib, pb, color = color.new(cA, 50), width = 1, style = line.style_dashed)\n                        line.new(ib, pb, ic, pc, color = color.new(cA, 50), width = 1, style = line.style_dashed)\n\n                // After bearish impulse: look for up-down-up\n                if not lastWasBull and p3 > p2\n                    if pc > pa and pb > array.get(prc, sz - 4)\n                        lastIdx := ic\n                        f_draw_wave(ia, pa, 11, true,  _degName)   // A\n                        f_draw_wave(ib, pb, 12, false, _degName)   // B\n                        f_draw_wave(ic, pc, 13, true,  _degName)   // C\n                        [cB, _, _wB] = f_get_style(_degName)\n                        line.new(i2, p2, ia, pa, color = color.new(cB, 50), width = 1, style = line.style_dashed)\n                        line.new(ia, pa, ib, pb, color = color.new(cB, 50), width = 1, style = line.style_dashed)\n                        line.new(ib, pb, ic, pc, color = color.new(cB, 50), width = 1, style = line.style_dashed)\n\n            // Save updated state back into arrays\n            array.set(lastIdxArr,     _degIndex, lastIdx)\n            array.set(lastW5IdxArr,   _degIndex, lastW5Idx)\n            array.set(lastWasBullArr, _degIndex, lastWasBull)\n\n        [lastIdx, lastW5Idx, lastWasBull]\n\n// 4. UPDATE PIVOTS (once per bar) ---------------------------------------------\n\nf_update_pivots(lenPriL, lenPriR, pri_idx, pri_prc, pri_typ)\nf_update_pivots(lenIntL, lenIntR, int_idx, int_prc, int_typ)\nf_update_pivots(lenMinL, lenMinR, min_idx, min_prc, min_typ)\nf_update_pivots(lenIntL, lenIntR, trd_idx, trd_prc, trd_typ)\n\n// 5. DRAW WAVES FOR EACH DEGREE -----------------------------------------------\n\nf_process_degree(\"Primary\", 0, showPrimary, pri_idx, pri_prc, pri_typ)\nf_process_degree(\"Intermediate\", 1, showInter, int_idx, int_prc, int_typ)\nf_process_degree(\"Minor\", 2, showMinor, min_idx, min_prc, min_typ)\n\n// 6. TRADING ENGINE -----------------------------------------------------------\n\n// Trade state\nvar int trade_lastW3 = 0\nvar int trade_dir = 0\nvar float trade_entry = na\nvar float trade_stop = na\nvar float trade_tp = na\n\n// 6.1 Setup detection based on trading pivots\nif trade_on and array.size(trd_idx) >= 4\n    int sz = array.size(trd_idx)\n\n    int i3 = array.get(trd_idx, sz - 1)\n    float p0 = array.get(trd_prc, sz - 4)\n    float p1 = array.get(trd_prc, sz - 3)\n    float p2 = array.get(trd_prc, sz - 2)\n    float p3 = array.get(trd_prc, sz - 1)\n    int t0 = array.get(trd_typ, sz - 4)\n    int t3 = array.get(trd_typ, sz - 1)\n    \n    // **FIXED: ATR calculation moved here**\n    float current_atr = ta.atr(atr_len)\n\n    // Only react to a fresh pivot sequence\n    if i3 > trade_lastW3\n        bool is_bull_trend = close > ema_filter\n        bool is_bear_trend = close < ema_filter\n\n        // â”€â”€ LONG SETUP\n        if t0 == -1 and t3 == 1 and is_bull_trend\n            bool isBullStruct = (p1 > p0) and (p2 > p0) and (p2 < p1) and (p3 > p1)\n\n            float len1 = math.abs(p1 - p0)\n            float len3 = math.abs(p3 - p2)\n            bool r3_gt1 = rule_Strict ? (len3 > len1) : true\n\n            if isBullStruct and r3_gt1\n                trade_lastW3 := i3\n                float w3_height = p3 - p2\n\n                float entryPrice = p3 - (w3_height * fib_entry)\n                float stopPrice  = entryPrice - (current_atr * atr_stop_mult)\n                \n                // Calculate TP to GUARANTEE min_rr_ratio\n                float risk_long  = entryPrice - stopPrice\n                float tpPrice    = entryPrice + (risk_long * min_rr_ratio) \n\n                // Check stop viability and ensure risk > 0\n                bool  rr_ok      = risk_long > 0 \n                \n                if entryPrice > stopPrice and rr_ok\n                    trade_dir  := 1\n                    trade_entry := entryPrice\n                    trade_stop := stopPrice\n                    trade_tp := tpPrice\n\n                    box.new(bar_index, p3, bar_index + 20, entryPrice, xloc = xloc.bar_index, bgcolor = color.new(color.green, 85), border_color = na)\n                    label.new(bar_index, entryPrice, \"LONG SETUP\\nLimit Buy: \" + str.tostring(entryPrice, \"#.##\"), xloc = xloc.bar_index, yloc = yloc.belowbar, style = label.style_label_up, color = color.green, textcolor = color.white, size = size.small)\n\n\n        // â”€â”€ SHORT SETUP\n        else if t0 == 1 and t3 == -1 and is_bear_trend\n            bool isBearStruct = (p1 < p0) and (p2 < p0) and (p2 > p1) and (p3 < p1)\n\n            float len1b  = math.abs(p0 - p1)\n            float len3b  = math.abs(p2 - p3)\n            bool r3_gt1b = rule_Strict ? (len3b > len1b) : true\n\n            if isBearStruct and r3_gt1b\n                trade_lastW3 := i3\n                float w3_height = p2 - p3\n\n                float entryPrice = p3 + (w3_height * fib_entry)\n                float stopPrice  = entryPrice + (current_atr * atr_stop_mult)\n                \n                // Calculate TP to GUARANTEE min_rr_ratio\n                float risk_short   = stopPrice - entryPrice\n                float tpPrice   = entryPrice - (risk_short * min_rr_ratio)\n\n                // Check stop viability and ensure risk > 0\n                bool  rr_ok      = risk_short > 0\n\n                if entryPrice < stopPrice and rr_ok\n                    trade_dir  := -1\n                    trade_entry := entryPrice\n                    trade_stop := stopPrice\n                    trade_tp := tpPrice\n\n                    box.new(bar_index, p3, bar_index + 20, entryPrice, xloc = xloc.bar_index, bgcolor = color.new(color.red, 85), border_color = na)\n                    label.new(bar_index, entryPrice, \"SHORT SETUP\\nLimit Sell: \" + str.tostring(entryPrice, \"#.##\"), xloc = xloc.bar_index, yloc = yloc.abovebar, style = label.style_label_down, color = color.red, textcolor = color.white, size = size.small)\n\n// 7. ORDER EXECUTION ----------------------------------------------------------\n\n// Long execution\nif trade_dir == 1 and strategy.opentrades == 0\n    strategy.order(\"Sniper Long\", strategy.long, limit = trade_entry, comment = \"W4 Buy Limit\")\n    strategy.exit(\"TP/SL Long\", \"Sniper Long\", limit = trade_tp, stop = trade_stop, comment = \"W5 TP / ATR SL\")\n    trade_dir  := 0\n    trade_entry := na\n    trade_stop := na\n    trade_tp := na\n\n// Short execution\nif trade_dir == -1 and strategy.opentrades == 0\n    strategy.order(\"Sniper Short\", strategy.short, limit = trade_entry, comment = \"W4 Sell Limit\")\n    strategy.exit(\"TP/SL Short\", \"Sniper Short\", limit = trade_tp, stop = trade_stop, comment = \"W5 TP / ATR SL\")\n    trade_dir  := 0\n    trade_entry := na\n    trade_stop := na\n    trade_tp := na"
  },
  {
    "url": "cVhMmD9X-Combined-Signal-Auto-Day-Plan-Volume",
    "name": "Combined Signal + Auto Day Plan + Volume",
    "description": "ðŸ“˜ TradingView Description â€” Combined Signal + Auto Day Plan + Volume\nStrategy Overview\n\nThis strategy combines trend-following signals, daily context levels, and volume confirmation to generate high-probability intraday trading setups.\nIt is designed to filter noise, identify trend direction early, and avoid trades during low-quality market conditions.\n\nðŸ”· 1. Combined Signal Logic\n\nThe strategy merges multiple indicators to produce a single, cleaner signal:\n\nLong Signal\n\nTrend bias is bullish\n\nMomentum histogram (MACD/Custom) shows upward pressure\n\nPrice crosses above the midline (WMA/EMA/etc.)\n\nVolume supports the move\n\nShort Signal\n\nTrend bias is bearish\n\nMomentum histogram shows downward pressure\n\nPrice crosses below the midline\n\nVolume supports the move\n\nThis reduces false breakouts and ensures signals appear only during strong directional moves.\n\nðŸ”¶ 2. Auto Day Plan Levels (D-1 â†’ D)\n\nThe script automatically reads previous day levels and displays them on todayâ€™s session:\n\nPrevious Day High (PDH)\n\nPrevious Day Low (PDL)\n\nPrevious Day Close (PDC)\n\nPrevious Day Mid / Range Zones\n\nOptional FIB levels or custom zones\n\nThese levels act as intraday support/resistance, helping identify breakout, reversal, and retest opportunities.\n\nBehavior:\n\nD-1 levels are plotted from todayâ€™s open until todayâ€™s close.\n\nLevels do not overlap into the wrong day.\n\nOptional: extend lines to next day (D+1) for planning.\n\nðŸ”· 3. Volume Confirmation\n\nTo improve entry accuracy, the script checks for strength in volume:\n\nVolume > X-period average\n\nVolume spike detection\n\nRelative Volume (RVOL) filter\n\nOptional low-volume avoidance\n\nA trade is taken only when the market shows real participation, reducing traps and sideways chop trades.\n\nðŸ”¶ 4. Entry & Exit Logic\nEntry\n\nLong Entry: Combined bull signal + volume confirmation\n\nShort Entry: Combined bear signal + volume confirmation\n\nExit\n\nLong Exit â†’ Histogram turns down (hist < hist )\n\nShort Exit â†’ Histogram turns up (hist > hist )\n\nOptional:\n\nAuto SL at PDL/PDH\n\nTrailing based on midline\n\nTake profit using FIB or volatility levels\n\nðŸ’  5. Visuals\n\nThe chart plots:\n\nBuy/Sell markers\n\nD-1 support/resistance lines\n\nTrend direction midline\n\nVolume confirmation label\n\nCombined signal status\n\nColors and styles can be customized from the input panel.\n\nðŸŽ¯ 6. Purpose of the Strategy\n\nThis is a complete intraday automation tool combining:\n\nâœ” Trend\nâœ” Momentum\nâœ” Volume strength\nâœ” Key day levels\n\nThe goal is to provide structured, mechanical, rule-based trading â€” reducing emotional decisions and improving consistency.",
    "image_url": "cVhMmD9X",
    "author": "PK-TELUGUTRADER",
    "likes_count": 5,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-12",
    "updated": "2025-12-12",
    "source": "//@version=5\r\nstrategy(\"Combined Signal + Auto Day Plan + Volume (English Version)\", overlay=true, max_lines_count=500, max_labels_count=100)\r\n\r\n// === Signal Settings\r\nlenImpulse = input.int(20, \"Impulse Length\")\r\nsmaLen     = input.int(50, \"SMA Length\")\r\nlevelRatio = input.float(0.2, \"SL/TP Multiplier\", step=0.01)\r\nvolLen     = input.int(20, \"Volume SMA Length\")\r\nmaxSignals = 100\r\n\r\n// === Trend\r\nsma = ta.sma(close, smaLen)\r\nbias = close > sma ? 1 : -1  // 1 = LONG, -1 = SHORT\r\n\r\n// === Impulse Range\r\nimpulseHigh = ta.highest(high, lenImpulse)\r\nimpulseLow  = ta.lowest(low, lenImpulse)\r\nimpulseRange = impulseHigh - impulseLow\r\n\r\n// === Signal\r\nvar float entryPrice = na\r\nvar int lastBias = na\r\nvar bool activeSignal = false\r\nvar int sig_bar = na\r\n\r\nvar float TP1 = na\r\nvar float TP2 = na\r\nvar float TP3 = na\r\nvar float SL  = na\r\n\r\nvar line lineTP1 = na\r\nvar line lineTP2 = na\r\nvar line lineTP3 = na\r\nvar line lineEntry = na\r\nvar line lineSL = na\r\n\r\n// === Signal Expiration\r\nsignalExpired = false\r\nif activeSignal and not na(entryPrice)\r\n    signalExpired := lastBias == 1 ? (close >= TP3 or close <= SL) : (close <= TP3 or close >= SL)\r\n\r\n// === Signal Reset Conditions\r\nsignalChanged = na(lastBias) or bias != lastBias or signalExpired\r\n\r\nif signalChanged\r\n    entryPrice := close\r\n    lastBias := bias\r\n    activeSignal := true\r\n    sig_bar := bar_index\r\n\r\n    TP1 := lastBias == 1 ? entryPrice + impulseRange * 0.382 : entryPrice - impulseRange * 0.382\r\n    TP2 := lastBias == 1 ? entryPrice + impulseRange * 0.618 : entryPrice - impulseRange * 0.618\r\n    TP3 := lastBias == 1 ? entryPrice + impulseRange * 0.786 : entryPrice - impulseRange * 0.786\r\n    SL  := lastBias == 1 ? entryPrice - impulseRange * levelRatio : entryPrice + impulseRange * levelRatio\r\n\r\n    if not na(lineTP1)\r\n        line.delete(lineTP1)\r\n        line.delete(lineTP2)\r\n        line.delete(lineTP3)\r\n        line.delete(lineEntry)\r\n        line.delete(lineSL)\r\n\r\n    lineTP1 := line.new(bar_index, TP1, bar_index+1, TP1, extend=extend.right, color=color.green)\r\n    lineTP2 := line.new(bar_index, TP2, bar_index+1, TP2, extend=extend.right, color=color.green)\r\n    lineTP3 := line.new(bar_index, TP3, bar_index+1, TP3, extend=extend.right, color=color.green)\r\n    lineEntry := line.new(bar_index, entryPrice, bar_index+1, entryPrice, extend=extend.right, color=color.yellow)\r\n    lineSL := line.new(bar_index, SL, bar_index+1, SL, extend=extend.right, color=color.red)\r\n\r\n// === Volume Strength\r\nvolSMA = ta.sma(volume, volLen)\r\nvolCategory = volume > volSMA * 1.5 ? \"Strong\" : volume < volSMA * 0.8 ? \"Weak\" : \"Normal\"\r\nvolColor     = volume > volSMA * 1.5 ? color.green : volume < volSMA * 0.8 ? color.red : color.yellow\r\n\r\n// === Signal Table\r\nvar table sigTbl = table.new(position.top_right, 2, 8, border_width=3)\r\n\r\nif not na(entryPrice)\r\n    table.cell(sigTbl, 0,0,\"ðŸ“ˆ Signal:\", text_color=color.black, bgcolor= lastBias==1 ? color.new(color.green,60) : color.new(color.red,60))\r\n    table.cell(sigTbl, 1,0, lastBias==1 ? \"LONG\" : \"SHORT\", text_color=color.black)\r\n\r\n    table.cell(sigTbl, 0,1,\"ðŸŽ¯ TP1:\", text_color=color.black)\r\n    table.cell(sigTbl, 1,1,str.tostring(TP1, format.mintick), text_color=color.green)\r\n\r\n    table.cell(sigTbl, 0,2,\"ðŸŽ¯ TP2:\", text_color=color.black)\r\n    table.cell(sigTbl, 1,2,str.tostring(TP2, format.mintick), text_color=color.green)\r\n\r\n    table.cell(sigTbl, 0,3,\"ðŸŽ¯ TP3:\", text_color=color.black)\r\n    table.cell(sigTbl, 1,3,str.tostring(TP3, format.mintick), text_color=color.green)\r\n\r\n    table.cell(sigTbl, 0,4,\"ðŸŸ¡ Entry:\", text_color=color.black)\r\n    table.cell(sigTbl, 1,4,str.tostring(entryPrice, format.mintick), text_color=color.black)\r\n\r\n    table.cell(sigTbl, 0,5,\"ðŸ›‘ Stop Loss:\", text_color=color.black)\r\n    table.cell(sigTbl, 1,5,str.tostring(SL, format.mintick), text_color=color.red)\r\n\r\n    table.cell(sigTbl, 0,6,\"ðŸ“Š Volume:\", text_color=color.black)\r\n    table.cell(sigTbl, 1,6,volCategory, text_color=volColor)\r\n\r\n// === Auto Day Plan Settings\r\nbaseTF = input.timeframe(\"60\", \"Base Timeframe for Zones/VWAP/Pivot\", [\"60\",\"240\",\"D\"])\r\nfwdBars = input.int(6, \"Forward Bars\", minval=1)\r\natrMult1 = input.float(1.0, \"ATR Multiplier Target 1\", step=0.1)\r\natrMult2 = input.float(2.0, \"ATR Multiplier Target 2\", step=0.1)\r\n\r\natrBase = request.security(syminfo.tickerid, baseTF, ta.atr(14))\r\natr1d   = request.security(syminfo.tickerid, \"D\", ta.atr(14))\r\natrAvg  = baseTF == \"D\" ? atr1d : (atrBase + atr1d)/2\r\n\r\nprevCloseTF = request.security(syminfo.tickerid, baseTF, close[1])\r\n\r\ncalc_from(base, m) => base + m * atrAvg\r\n\r\nsup1  = calc_from(prevCloseTF, -1.6)\r\nbalLo = calc_from(prevCloseTF, -1.0)\r\nbalHi = calc_from(prevCloseTF, -0.6)\r\nresLo = calc_from(prevCloseTF, 1.4)\r\nresHi = calc_from(prevCloseTF, 2.1)\r\npivot = prevCloseTF\r\n\r\n// === VWAP\r\nisNewPeriod = ta.change(time(baseTF))\r\nvar float vNum = 0\r\nvar float vDen = 0\r\n\r\nif isNewPeriod\r\n    vNum := 0\r\n    vDen := 0\r\n\r\nvNum += hlc3 * volume\r\nvDen += volume\r\nvwap = vDen > 0 ? vNum / vDen : na\r\n\r\n// === EMA Trend\r\nemaFast = ta.ema(close, 50)\r\nemaSlow = ta.ema(close, 200)\r\n\r\ntrendUp = emaFast > emaSlow\r\ntrendDown = emaFast < emaSlow\r\n\r\nexpectUp = trendUp and close > vwap and close > pivot\r\nexpectDown = trendDown and close < vwap and close < pivot\r\ndir = expectUp ? 1 : expectDown ? -1 : 0\r\n\r\n// === Zones\r\nvar box resBox = box.new(bar_index, resHi, bar_index, resLo, extend=extend.right, bgcolor=color.new(color.red,70))\r\nvar box balBox = box.new(bar_index, balHi, bar_index, balLo, extend=extend.right, bgcolor=color.new(color.orange,80))\r\nvar line supLine = line.new(bar_index, sup1, bar_index, sup1, extend=extend.right, color=color.green)\r\nvar line pivotLine = line.new(bar_index, pivot, bar_index, pivot, extend=extend.right, color=color.blue, style=line.style_dashed)\r\nvar line vwapLine = line.new(bar_index, vwap, bar_index, vwap, extend=extend.right, color=color.teal)\r\n\r\nbox.set_right(resBox, bar_index)\r\nbox.set_top(resBox, resHi)\r\nbox.set_bottom(resBox, resLo)\r\n\r\nbox.set_right(balBox, bar_index)\r\nbox.set_top(balBox, balHi)\r\nbox.set_bottom(balBox, balLo)\r\n\r\nline.set_xy1(supLine, bar_index, sup1)\r\nline.set_xy2(supLine, bar_index+1, sup1)\r\n\r\nline.set_xy1(pivotLine, bar_index, pivot)\r\nline.set_xy2(pivotLine, bar_index+1, pivot)\r\n\r\nline.set_xy1(vwapLine, bar_index, vwap)\r\nline.set_xy2(vwapLine, bar_index+1, vwap)\r\n\r\n// === Targets\r\ntgtUp1 = pivot + atrAvg * atrMult1\r\ntgtUp2 = pivot + atrAvg * atrMult2\r\ntgtDn1 = pivot - atrAvg * atrMult1\r\ntgtDn2 = pivot - atrAvg * atrMult2\r\n\r\nvar line t1Line = na\r\nvar line t2Line = na\r\n\r\nif dir != 0\r\n    col = dir == 1 ? color.lime : color.red\r\n    if na(t1Line)\r\n        t1Line := line.new(bar_index, dir==1?tgtUp1:tgtDn1, bar_index+fwdBars, dir==1?tgtUp1:tgtDn1, extend=extend.right, color=col, style=line.style_dotted)\r\n    if na(t2Line)\r\n        t2Line := line.new(bar_index, dir==1?tgtUp2:tgtDn2, bar_index+fwdBars, dir==1?tgtUp2:tgtDn2, extend=extend.right, color=col, style=line.style_dotted)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// ---------------------------\r\n// STRATEGY ENTRY CONDITIONS\r\n// ---------------------------\r\nlongEntry  = signalChanged and lastBias == 1\r\nshortEntry = signalChanged and lastBias == -1\r\n\r\nif (longEntry)\r\n    strategy.entry(\"LONG\", strategy.long, comment = \"LONG Entry\")\r\n\r\nif (shortEntry)\r\n    strategy.entry(\"SHORT\", strategy.short, comment = \"SHORT Entry\")\r\n\r\n// ---------------------------\r\n// STRATEGY EXIT CONDITIONS\r\n// ---------------------------\r\n\r\n\r\n// ---- TP1 exits ----\r\ntp1HitLong  = activeSignal and lastBias == 1  and high >= TP3\r\ntp1HitShort = activeSignal and lastBias == -1 and low <= TP3\r\n\r\nif (tp1HitLong)\r\n    strategy.exit(\"TP1 LONG EXIT\", from_entry = \"LONG\", limit = TP1, comment = \"TP1 Long Hit\")\r\n\r\nif (tp1HitShort)\r\n    strategy.exit(\"TP1 SHORT EXIT\", from_entry = \"SHORT\", limit = TP1, comment = \"TP1 Short Hit\")\r\n\r\n// ---- STOP LOSS exits ----\r\nslHitLong  = activeSignal and lastBias == 1  and close <= SL\r\nslHitShort = activeSignal and lastBias == -1 and close >= SL\r\n\r\nif (slHitLong)\r\n    strategy.exit(\"SL LONG EXIT\", from_entry = \"LONG\", stop = SL, comment = \"SL Long Hit\")\r\n\r\nif (slHitShort)\r\n    strategy.exit(\"SL SHORT EXIT\", from_entry = \"SHORT\", stop = SL, comment = \"SL Short Hit\")\r\n\r\n// =======================================\r\n// ALERT CONDITIONS (for real-time trading)\r\n// =======================================\r\nalertcondition(longEntry,  title=\"LONG Entry\",  message=\"LONG Entry Triggered\")\r\nalertcondition(shortEntry, title=\"SHORT Entry\", message=\"SHORT Entry Triggered\")\r\n\r\nalertcondition(tp1HitLong,  title=\"TP1 Hit LONG\",  message=\"TP1 Hit for LONG\")\r\nalertcondition(tp1HitShort, title=\"TP1 Hit SHORT\", message=\"TP1 Hit for SHORT\")\r\n\r\nalertcondition(slHitLong,  title=\"SL Hit LONG\",  message=\"Stoploss Hit LONG\")\r\nalertcondition(slHitShort, title=\"SL Hit SHORT\", message=\"Stoploss Hit SHORT\")\r\n"
  },
  {
    "url": "xvYoa3vU-Strategia-S-P-500-vs-US10Y-Yield",
    "name": "Strategia S&P 500 vs US10Y Yield",
    "description": "This strategy explores the macroeconomic relationship between the equity market (S&P 500) and the debt market (10-Year Treasury Yield). Historically, rapid spikes in bond yields often exert downward pressure on equity valuations, leading to corrections or bear markets.\n\nThe goal of this strategy is capital preservation. It attempts to switch to cash when yields are rising too aggressively and re-enter the stock market when the bond market stabilizes.",
    "image_url": "xvYoa3vU",
    "author": "adamniestoj",
    "likes_count": 6,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=5\nstrategy(\"Strategia S&P 500 vs US10Y Yield\", overlay=true, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=100)\n\n// --- USTAWIENIA ---\n// Symbol rentownoÅ›ci obligacji (Treasury Yield 10Y)\nyieldSymbol = input.symbol(\"US10Y\", \"Symbol RentownoÅ›ci (Yield)\")\n// Okres dla zakresu (range) - z obrazka wynika, Å¼e to 63 dni (ok. 3 miesiÄ…ce handlowe)\nlookbackPeriod = input.int(63, \"Okres zakresu (dni)\", minval=1)\n// PrÃ³g procentowy (80% zakresu)\nthresholdPercent = input.float(0.80, \"PrÃ³g zakresu (0.80 = 80%)\", step=0.01)\n\n// --- POBIERANIE DANYCH ---\n// Pobieramy zamkniÄ™cia rentownoÅ›ci 10-letniej. UÅ¼ywamy request.security, aby mieÄ‡ dane niezaleÅ¼nie od wykresu, na ktÃ³rym jesteÅ›my.\nyieldClose = request.security(yieldSymbol, \"D\", close)\n\n// --- OBLICZENIA WSKAÅ¹NIKA (Yield % of Range) ---\n// Obliczamy najwyÅ¼szy i najniÅ¼szy poziom rentownoÅ›ci w oknie 63 dni\nyieldHigh = ta.highest(yieldClose, lookbackPeriod)\nyieldLow  = ta.lowest(yieldClose, lookbackPeriod)\n\n// Obliczamy pozycjÄ™ obecnej rentownoÅ›ci w tym zakresie (Stochastic formula)\n// WzÃ³r: (Obecna cena - Minimum) / (Maksimum - Minimum)\nyieldPosition = (yieldClose - yieldLow) / (yieldHigh - yieldLow)\n\n// --- LOGIKA STRATEGII ---\n// Warunek \"Risk Off\" (Ucieczka do gotÃ³wki): JeÅ›li Yield jest powyÅ¼ej 80% zakresu\nisRiskOff = yieldPosition > thresholdPercent\n\n// Warunek \"Risk On\" (Kupno akcji): JeÅ›li Yield jest poniÅ¼ej lub rÃ³wny 80% zakresu\nisRiskOn = not isRiskOff\n\n// --- WYKONYWANIE ZLECEÅƒ ---\nif (isRiskOn)\n    // JeÅ›li jest bezpiecznie, wchodzimy w pozycjÄ™ dÅ‚ugÄ… (lub jÄ… utrzymujemy)\n    strategy.entry(\"Long SP500\", strategy.long, comment=\"Kupno\")\nelse\n    // JeÅ›li rentownoÅ›Ä‡ roÅ›nie gwaÅ‚townie (Risk Off), zamykamy pozycjÄ™ (przechodzimy w gotÃ³wkÄ™)\n    strategy.close(\"Long SP500\", comment=\"GotÃ³wka\")\n\n// --- WIZUALIZACJA (Opcjonalna) ---\n// Kolor tÅ‚a, Å¼eby widzieÄ‡ kiedy strategia jest poza rynkiem\nbgcolor(isRiskOff ? color.new(color.red, 90) : na, title=\"Okresy w gotÃ³wce\")\n\n// MoÅ¼esz dodaÄ‡ plotowanie wskaÅºnika w osobnym oknie, jeÅ›li zmienisz overlay=false\n// plot(yieldPosition, title=\"Yield Position\", color=color.red)\n// hline(thresholdPercent, title=\"PrÃ³g 80%\", color=color.gray, linestyle=hline.style_dashed)"
  },
  {
    "url": "yP9aTS37-Layered-Bi-Directional-Grid-Maker-SUPERBEST",
    "name": "Layered Bi-Directional Grid Maker SUPERBEST",
    "description": "super best for btc 1m scalp trade please be careful",
    "image_url": "yP9aTS37",
    "author": "Besttraderalltheworld",
    "likes_count": 9,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=5\r\nstrategy(\"Layered Bi-Directional Grid Maker (FIXED)\", overlay=true, pyramiding=20, initial_capital=50000, default_qty_type=strategy.fixed, default_qty_value=12, currency=currency.USDT)\r\n\r\n// --- 1. INPUT PENGATURAN ---\r\ngrp_main = \"Pengaturan Grid\"\r\n// Jarak antar layer order dalam persen.\r\ngridDistPct = input.float(0.15, \"Jarak Grid (%)\", step=0.01, group=grp_main) \r\n// Target profit untuk menutup posisi rata-rata.\r\ntakeProfitPct = input.float(0.25, \"Target Profit (%)\", step=0.01, group=grp_main) \r\n// Input ini dipertahankan, namun visualisasinya disederhanakan (lihat bagian 4)\r\nmaxLayers = input.int(10, \"Maksimal Layer (Visualisasi Disederhanakan)\", minval=1, maxval=20, group=grp_main) \r\n\r\n// --- 2. LOGIKA ENTRY (2 ARAH) ---\r\n\r\n// Tentukan apakah ini adalah trade awal\r\nisInitialEntry = strategy.position_size == 0\r\n\r\n// Tentukan harga rata-rata acuan: 'close' saat posisi 0, atau 'strategy.position_avg_price' saat posisi ada.\r\nfloat avgPrice = strategy.position_avg_price == 0 ? close : strategy.position_avg_price\r\n\r\n// KONDISI ENTRY LONG (BUY)\r\n// Perhitungan Threshold/Ambang Batas untuk layer baru\r\nlongEntryThreshold = avgPrice * (1 - gridDistPct/100)\r\nbool longEntryCond = isInitialEntry or close < longEntryThreshold\r\n\r\nif longEntryCond\r\n    // Limit order Buy ditempatkan sedikit di bawah harga close untuk mensimulasikan \"Maker\"\r\n    strategy.entry(\"Grid Buy\", strategy.long, qty=12, limit=close * 0.9995, comment=\"ðŸ”µ Buy Layer\")\r\n\r\n\r\n// KONDISI ENTRY SHORT (SELL)\r\n// Perhitungan Threshold/Ambang Batas untuk layer baru\r\nshortEntryThreshold = avgPrice * (1 + gridDistPct/100)\r\nbool shortEntryCond = isInitialEntry or close > shortEntryThreshold\r\n\r\nif shortEntryCond\r\n    // Limit order Sell ditempatkan sedikit di atas harga close\r\n    strategy.entry(\"Grid Sell\", strategy.short, qty=12, limit=close * 1.0005, comment=\"ðŸ”´ Sell Layer\")\r\n\r\n\r\n// --- 3. LOGIKA EXIT (TAKE PROFIT) ---\r\n// Exit untuk Long (Profit Target di atas rata-rata harga beli)\r\nif (strategy.position_size > 0)\r\n    tpLongPrice = strategy.position_avg_price * (1 + takeProfitPct/100)\r\n    strategy.exit(\"TP Long\", \"Grid Buy\", profit=na, limit=tpLongPrice, comment=\"ðŸ’° TP Long\")\r\n\r\n// Exit untuk Short (Profit Target di bawah rata-rata harga jual)\r\nif (strategy.position_size < 0)\r\n    tpShortPrice = strategy.position_avg_price * (1 - takeProfitPct/100)\r\n    strategy.exit(\"TP Short\", \"Grid Sell\", profit=na, limit=tpShortPrice, comment=\"ðŸ’° TP Short\")\r\n\r\n\r\n// --- 4. VISUALISASI GRID (PINESCRIPT V5 COMPLIANT) ---\r\nplotGrid = input.bool(true, \"Tampilkan Level Grid\", group=\"Visualisasi\")\r\n\r\n// 4a. Plot Garis Rata-rata Posisi (Pusat Grid)\r\nfloat avgPricePlot = strategy.position_avg_price != 0 and plotGrid ? strategy.position_avg_price : na\r\nplot(avgPricePlot, color=color.new(color.black, 0), style=plot.style_line, linewidth=2, title=\"Average Entry Price\")\r\n\r\n// 4b. Plot Level Grid Pertama (yang akan dieksekusi berikutnya)\r\nfloat nextLongLevel = avgPrice * (1 - (gridDistPct / 100))\r\nfloat nextShortLevel = avgPrice * (1 + (gridDistPct / 100))\r\n\r\n// Kondisikan nilai yang di-plot (menggunakan 'na' saat kondisi plot tidak terpenuhi)\r\nfloat plotNextLong = plotGrid ? nextLongLevel : na\r\nfloat plotNextShort = plotGrid ? nextShortLevel : na\r\n\r\n// Plotting Next Layers\r\n// NOTE: Fungsi plot() dipanggil dari global scope.\r\nplot(plotNextLong, color=color.new(color.green, 40), style=plot.style_linebr, title=\"Next Buy Layer\") \r\nplot(plotNextShort, color=color.new(color.red, 40), style=plot.style_linebr, title=\"Next Sell Layer\")\r\n\r\n// Visualisasi Background\r\nbgcolor(strategy.position_size > 0 ? color.new(color.green, 95) : strategy.position_size < 0 ? color.new(color.red, 95) : na)"
  },
  {
    "url": "yn4Tqapn-N1E-UTBOAT",
    "name": "N1E_UTBOAT",
    "description": "N1E_UTBOAT\n\nATR trailing stop\n\nOptional Heikin Ashi source\n\nBuy/Sell signals based on a crossover of price vs ATR trailing stop\n\nStrategy long/short entries",
    "image_url": "yn4Tqapn",
    "author": "swma4444",
    "likes_count": 9,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "\r\n//@version=5\r\nstrategy(\"UT Bot Strategy (v5) â€” HeikinAshi fix\", overlay=true)\r\n\r\n// Inputs\r\na = input.float(1.0, title = \"Key Value (Sensitivity)\")\r\nc = input.int(10, title = \"ATR Period\")\r\nuseHA = input.bool(false, title = \"Use Heikin Ashi Source\")\r\n\r\n// --- Heikin Ashi (computed locally) ---\r\nha_close = (open + high + low + close) / 4.0\r\nha_open  = float(na)\r\nha_open  := nz(ha_open[1], (open + close) / 2.0)   // initialize from first bar\r\nha_open  := (ha_open + ha_close[1]) / 2.0\r\nha_high  = math.max(high, math.max(ha_open, ha_close))\r\nha_low   = math.min(low,  math.min(ha_open, ha_close))\r\n\r\nsrc = useHA ? ha_close : close\r\n\r\n// ATR & trailing stop\r\nxATR  = ta.atr(c)\r\nnLoss = a * xATR\r\n\r\nvar float xStop = na\r\nxStop := if src > nz(xStop[1], 0) and src[1] > nz(xStop[1], 0)\r\n    math.max(nz(xStop[1]), src - nLoss)\r\nelse if src < nz(xStop[1], 0) and src[1] < nz(xStop[1], 0)\r\n    math.min(nz(xStop[1]), src + nLoss)\r\nelse\r\n    src > nz(xStop[1], 0) ? src - nLoss : src + nLoss\r\n\r\n// Position detection (not strictly required but kept from original)\r\nvar int pos = 0\r\npos := src[1] < nz(xStop[1]) and src > nz(xStop[1]) ? 1 :\r\n       src[1] > nz(xStop[1]) and src < nz(xStop[1]) ? -1 : nz(pos[1], 0)\r\n\r\n// Signal logic\r\nema1 = ta.ema(src, 1)\r\nabove = ta.crossover(ema1, xStop)\r\nbelow = ta.crossover(xStop, ema1)\r\n\r\nbuy  = src > xStop and above\r\nsell = src < xStop and below\r\n\r\n// Plotting / visuals\r\nplot(xStop, title=\"ATR Trailing Stop\", linewidth=2, style=plot.style_line)\r\nplotshape(buy,  title=\"Buy\",  text=\"Buy\",  style=shape.labelup,   location=location.belowbar, color=color.green, textcolor=color.white, size=size.tiny)\r\nplotshape(sell, title=\"Sell\", text=\"Sell\", style=shape.labeldown, location=location.abovebar, color=color.red,   textcolor=color.white, size=size.tiny)\r\nbarcolor(src > xStop ? color.new(color.green, 0) : src < xStop ? color.new(color.red, 0) : na)\r\n\r\n// Entries\r\nstrategy.entry(\"Long\",  strategy.long,  when = buy)\r\nstrategy.entry(\"Short\", strategy.short, when = sell)"
  },
  {
    "url": "u5Iy0SMM-Multi-MA-RSI-Pullback-Strategy-Jordan",
    "name": "Multi-MA + RSI Pullback Strategy (Jordan)",
    "description": "1ï¸âƒ£ Strategy logic Iâ€™ll code\n\nFrom your screenshots:\n\nIndicators\n\tâ€¢\tEMAs: 600 / 200 / 100 / 50\n\tâ€¢\tRSI: length 6, levels 80 / 20\n\nRules (simplified so a script can handle them):\n\tâ€¢\tUse a higher-timeframe trend filter (15m or 1h) using the EMAs.\n\tâ€¢\tTake entries on the chart timeframe (you can use 1m or 5m).\n\tâ€¢\tLong:\n\tâ€¢\tHigher-TF trend is up.\n\tâ€¢\tPrice is pulling back into a zone (between 50 EMA and 100 EMA on the entry timeframe â€“ this approximates your 50â€“61% retrace).\n\tâ€¢\tRSI crosses below 20 (oversold).\n\tâ€¢\tShort:\n\tâ€¢\tHigher-TF trend is down.\n\tâ€¢\tPrice pulls back between 50 & 100 EMAs.\n\tâ€¢\tRSI crosses above 80 (overbought).\n\tâ€¢\tExits: ATR-based stop + take-profit with adjustable R:R (2:1 or 3:1).\n\tâ€¢\tMax 4 trades per day.\n\nNews filter & â€œonly trade goldâ€ you handle manually (run it on XAUUSD and avoid news times yourself â€“ TradingView canâ€™t read the economic calendar from code).\n",
    "image_url": "u5Iy0SMM",
    "author": "jordana4r79",
    "likes_count": 1,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=5\nstrategy(\"Multi-MA + RSI Pullback Strategy\", overlay=true, margin_long=100, margin_short=100)\n\n// === INPUTS ===\nema50 = ta.ema(close, 50)\nema100 = ta.ema(close, 100)\nema200 = ta.ema(close, 200)\nema600 = ta.ema(close, 600)\nrsiPeriod = input.int(6, \"RSI Period\")\nrsiOB = input.int(80, \"RSI Overbought\")\nrsiOS = input.int(20, \"RSI Oversold\")\nrsi = ta.rsi(close, rsiPeriod)\n\n// === TREND DIRECTION ===\nisBull = ema50 > ema100 and ema100 > ema200 and ema200 > ema600\nisBear = ema50 < ema100 and ema100 < ema200 and ema200 < ema600\n\n// === ENTRY CONDITIONS ===\nlongCond = isBull and ta.crossunder(rsi, rsiOS)\nshortCond = isBear and ta.crossover(rsi, rsiOB)\n\n// === STRATEGY EXECUTION ===\nif (longCond)\n    strategy.entry(\"Long\", strategy.long)\n\nif (shortCond)\n    strategy.entry(\"Short\", strategy.short)\n\n// === EXIT CONDITIONS ===\nrr = input.float(2.0, \"Risk/Reward Ratio\", step=0.1)\nstopATR = ta.atr(14)\nif strategy.position_size > 0\n    strategy.exit(\"Long Exit\", \"Long\", stop=close - stopATR, limit=close + stopATR * rr)\nif strategy.position_size < 0\n    strategy.exit(\"Short Exit\", \"Short\", stop=close + stopATR, limit=close - stopATR * rr)\n\n// === PLOTTING ===\nplot(ema50, color=color.red)\nplot(ema100, color=color.yellow)\nplot(ema200, color=color.green)\nplot(ema600, color=color.blue)\nplot(rsi, title=\"RSI\", color=color.new(color.white, 0), display=display.none)"
  },
  {
    "url": "L9Uyla3a-Strategia-S-P-500-vs-US10Y-Yield-od-2000",
    "name": "Strategia S&P 500 vs US10Y Yield (od 2000)",
    "description": "This strategy explores the macroeconomic relationship between the equity market (S&P 500) and the debt market (10-Year Treasury Yield). Historically, rapid spikes in bond yields often exert downward pressure on equity valuations, leading to corrections or bear markets.\n\nThe goal of this strategy is capital preservation. It attempts to switch to cash when yields are rising too aggressively and re-enter the stock market when the bond market stabilizes.",
    "image_url": "L9Uyla3a",
    "author": "adamniestoj",
    "likes_count": 2,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=5\nstrategy(\"Strategia S&P 500 vs US10Y Yield (od 2000)\", overlay=true, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=100)\n\n// --- USTAWIENIA ---\nyieldSymbol = input.symbol(\"TVC:US10Y\", \"Symbol RentownoÅ›ci (Yield)\") \nlookbackPeriod = input.int(63, \"Okres zakresu (dni)\", minval=1)\nthresholdPercent = input.float(0.80, \"PrÃ³g zakresu (0.80 = 80%)\", step=0.01)\n\n// NOWE: Ustawienie daty startowej\nstartYear = input.int(2000, \"Rok poczÄ…tkowy backtestu\", minval=1900)\n\n// --- POBIERANIE DANYCH ---\n// Zabezpieczenie: gaps=barmerge.gaps_off uzupeÅ‚nia luki w danych\nyieldClose = request.security(yieldSymbol, \"D\", close, gaps=barmerge.gaps_off)\n\n// --- DIAGNOSTYKA (DEBUG) ---\nplotchar(na(yieldClose), \"Brak Danych\", \"âŒ\", location.top, color.red, size=size.tiny, text=\"Brak danych US10Y!\")\n\n// --- OBLICZENIA WSKAÅ¹NIKA ---\nvalidData = not na(yieldClose)\n\nyieldHigh = ta.highest(yieldClose, lookbackPeriod)\nyieldLow  = ta.lowest(yieldClose, lookbackPeriod)\n\nrangeDiff = yieldHigh - yieldLow\nyieldPosition = (rangeDiff > 0) ? (yieldClose - yieldLow) / rangeDiff : 0.5\n\n// --- LOGIKA STRATEGII ---\nisRiskOff = validData and (yieldPosition > thresholdPercent)\nisRiskOn = validData and (yieldPosition <= thresholdPercent)\n\n// --- FILTR CZASOWY ---\n// Tworzymy znacznik czasu dla 1 stycznia wybranego roku\nstartTime = timestamp(startYear, 1, 1, 0, 0)\n// Sprawdzamy, czy obecna Å›wieczka jest po tej dacie\ninDateRange = time >= startTime\n\n// --- WYKONYWANIE ZLECEÅƒ ---\n// Dodano warunek \"and inDateRange\"\nif (bar_index > lookbackPeriod and inDateRange)\n    if (isRiskOn)\n        strategy.entry(\"Long SP500\", strategy.long, comment=\"Kupno\")\n    \n    if (isRiskOff)\n        strategy.close(\"Long SP500\", comment=\"GotÃ³wka\")\n\n// --- WIZUALIZACJA ---\n// TÅ‚o rysuje siÄ™ tylko w wybranym zakresie dat\nbgcolor(isRiskOff and inDateRange ? color.new(color.red, 85) : na, title=\"Cash Mode\")"
  },
  {
    "url": "eZGgOsDY",
    "name": "2 Dip/Tepe + Destek/DirenÃ§ + Tek Sinyal Stratejisi",
    "description": "â­ A Brief Summary of What the Strategy Does\nðŸŽ¯ 1) Market analysis is being released (bottom-top analysis)\n\nIt automatically finds pivot bottoms and pivot tops on the strategic chart. Then:\n\nIf the bottoms are rising (HL â€“ High Low): the trend is upward\n\nIf the tops are falling (LH â€“ Lower High): the trend is downward\n\nit interprets this.\n\nðŸŽ¯ 2) Support and resistance lines are formed\n\nLast pivot top = resistance line\n\nLast pivot bottom = support line\n\nThese lines are automatically drawn on the chart.\n\nðŸŽ¯ 3) Breakout is expected according to the trend structure\nFor LONG:\n\nThe last two bottoms will be rising bottoms\n\nThe price will rise above the last resistance line\n\nThis gives a single LONG signal.\n\nFor SHORT:\n\nThe last two peaks will be falling peaks\n\nThe price will fall below the support line\n\nThis gives a single SHORT signal.",
    "image_url": "eZGgOsDY",
    "author": "hayrialbayir",
    "likes_count": 8,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=5\nstrategy(\"2 Dip/Tepe + Destek/DirenÃ§ + Tek Sinyal Stratejisi\", overlay=true, margin_long=100, margin_short=100, initial_capital=100000)\n\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n// Pivot AyarlarÄ±\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\nleft  = input.int(5, \"Sol Pivot\")\nright = input.int(5, \"SaÄŸ Pivot\")\n\npivotLow  = ta.pivotlow(low, left, right)\npivotHigh = ta.pivothigh(high, left, right)\n\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n// Son iki dip (HL iÃ§in) ve son iki tepe (LH iÃ§in)\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\nvar float lastLow1  = na\nvar float lastLow2  = na\nvar float lastHigh1 = na\nvar float lastHigh2 = na\n\nif not na(pivotLow)\n    lastLow2 := lastLow1\n    lastLow1 := pivotLow\n\nif not na(pivotHigh)\n    lastHigh2 := lastHigh1\n    lastHigh1 := pivotHigh\n\n// KoÅŸullarÄ±n var olmasÄ±\nvalidLows  = not na(lastLow1)  and not na(lastLow2)\nvalidHighs = not na(lastHigh1) and not na(lastHigh2)\n\n// YÃ¼kselen Dip (HL) â†’ LONG setup\nisHL = validLows and lastLow1 > lastLow2\n\n// AlÃ§alan Tepe (LH) â†’ SHORT setup\nisLH = validHighs and lastHigh1 < lastHigh2\n\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n// Destek & DirenÃ§ Ã§izgileri\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\nvar float resistance = na\nvar float support    = na\n\nif not na(pivotHigh)\n    resistance := pivotHigh\n\nif not na(pivotLow)\n    support := pivotLow\n\nplot(resistance, \"DirenÃ§\", color=color.red, linewidth=2)\nplot(support, \"Destek\", color=color.green, linewidth=2)\n\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n// SINYAL TEKRARLAMASINI ENGELLEME\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\nvar bool longTriggered  = false\nvar bool shortTriggered = false\n\n// LONG sinyali mantÄ±ÄŸÄ±\nlongSignal = isHL and not na(resistance) and close > resistance and not longTriggered\n\n// SHORT sinyali mantÄ±ÄŸÄ±\nshortSignal = isLH and not na(support) and close < support and not shortTriggered\n\n// Sinyal geldiÄŸinde sadece 1 kez tetikle\nif longSignal\n    strategy.entry(\"LONG\", strategy.long)\n    longTriggered := true\n    shortTriggered := false   // yÃ¶n deÄŸiÅŸince reset\n\nif shortSignal\n    strategy.entry(\"SHORT\", strategy.short)\n    shortTriggered := true\n    longTriggered := false    // yÃ¶n deÄŸiÅŸince reset\n\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n// Opsiyonel Stop-Loss / Take-Profit\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\nslPct = input.float(3.0, \"Stop-Loss %\", step=0.1)\ntpPct = input.float(6.0, \"Take-Profit %\", step=0.1)\n\nif strategy.position_size > 0\n    strategy.exit(\"Exit Long\", from_entry=\"LONG\", stop = strategy.position_avg_price * (1 - slPct/100), limit = strategy.position_avg_price * (1 + tpPct/100))\n\nif strategy.position_size < 0\n    strategy.exit(\"Exit Short\", from_entry=\"SHORT\", stop = strategy.position_avg_price * (1 + slPct/100), limit = strategy.position_avg_price * (1 - tpPct/100))\n\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n// GÃ¶rsel iÅŸaretler\n// â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\nplotshape(longSignal,  title=\"Long Sinyal\",  color=color.green, style=shape.labelup,   text=\"LONG\")\nplotshape(shortSignal, title=\"Short Sinyal\", color=color.red,   style=shape.labeldown, text=\"SHORT\")\n\n"
  },
  {
    "url": "SYuloc1g-Keltner-Channels-Strategy-New",
    "name": "Keltner Channels Strategy New",
    "description": "The strategy is chenging the same as an original copy, but this one is for tests, so I will publish it and check results",
    "image_url": "SYuloc1g",
    "author": "agodovanik",
    "likes_count": 3,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-11",
    "updated": "2025-12-11",
    "source": "//@version=6\nstrategy(title=\"Keltner Channels Strategy\", overlay=true)\nlength = input.int(20, minval=1)\nmult = input.float(2.0, \"Multiplier\")\nsrc = input(close, title=\"Source\")\nexp = input(true, \"Use Exponential MA\", display = display.data_window)\nBandsStyle = input.string(\"Average True Range\", options = [\"Average True Range\", \"True Range\", \"Range\"], title=\"Bands Style\", display = display.data_window)\natrlength = input(10, \"ATR Length\", display = display.data_window)\nesma(source, length)=>\n\ts = ta.sma(source, length)\n\te = ta.ema(source, length)\n\texp ? e : s\nma = esma(src, length)\nrangema = BandsStyle == \"True Range\" ? ta.tr(true) : BandsStyle == \"Average True Range\" ? ta.atr(atrlength) : ta.rma(high - low, length)\nupper = ma + rangema * mult\nlower = ma - rangema * mult\ncrossUpper = ta.crossover(src, upper)\ncrossLower = ta.crossunder(src, lower)\nbprice = 0.0\nbprice := crossUpper ? high+syminfo.mintick : nz(bprice[1])\nsprice = 0.0\nsprice := crossLower ? low -syminfo.mintick : nz(sprice[1])\ncrossBcond = false\ncrossBcond := crossUpper ? true : crossBcond[1]\ncrossScond = false\ncrossScond := crossLower ? true : crossScond[1]\ncancelBcond = crossBcond and (src < ma or high >= bprice )\ncancelScond = crossScond and (src > ma or low <= sprice )\nif (cancelBcond)\n\tstrategy.cancel(\"KltChLE\")\nif (crossUpper)\n\tstrategy.entry(\"KltChLE\", strategy.long, stop=bprice, comment=\"KltChLE\")\nif (cancelScond)\n\tstrategy.cancel(\"KltChSE\")\nif (crossLower)\n\tstrategy.entry(\"KltChSE\", strategy.short, stop=sprice, comment=\"KltChSE\")"
  },
  {
    "url": "z9MwNqWe-Trend-Vector-Pro-v2-0",
    "name": "Trend Vector Pro v2.0",
    "description": "Title: Trend Vector Pro v2.0 \n ðŸ‘¨â€ðŸ’» Developed by: Mohammed Bedaiwi \n\n ðŸ’¡ Strategy Overview & Coherence \n\n Trend Vector Pro (TVPro)  is a momentum-based trend & reversal strategy that uses a custom smoothed oscillator, an optional ADX filter, and classic Pivot Points to create a single, coherent trading framework.\n\n Instead of stacking random indicators, TVPro is built around these integrated components: \n \n  A custom momentum engine (signal generation)\n  An optional ADX filter (trend quality control)\n  Daily Pivot Points (context, targets & S/R)\n  Swing-based â€œGolden Barâ€ trailing stops (trade management)\n  Optional extended bar detection (overextension alerts)\n \nAll parts are designed to work together and are documented below to address originality & usefulness requirements.\n\n ðŸ” Core Components & Justification \n\n 1. Custom Momentum Engine (Main Signal Source) \nTVProâ€™s engine is a custom oscillator derived from the bar midpoint ( hl2 ), similar in spirit to the Awesome Oscillator but adapted and fully integrated into the strategy. It measures velocity and acceleration of price, letting the script distinguish between strong impulses, weakening trends, and pure noise.\n\n 2. ADX Filter (Trend Strength Validation â€“ Optional) \nUses Average Directional Index (ADX) as a gatekeeper.\n Why this matters:  This prevents the strategy from firing signals in choppy, non-trending environments (when ADX is below the threshold) and keeps trades focused on periods of clear directional strength.\n\n 3. Classic Pivot Points (Context & Targets) \nCalculates Daily Pivot Points ( PP, R1-R3, S1-S3 ) via  request.security()  using prior session data.\n Why this matters:  Momentum gives the signal, ADX validates the environment, and Pivots add external structure for risk and target planning. This is a designed interaction, not a random mashup.\n\n ðŸ§­ Trend State Logic (5-State Bar Coloring) \n\nThe strategy uses the momentum's value + slope to define five states, turning the chart into a visual momentum map:\n \n   ðŸŸ¢ STRONG BULL (Bright Green):  Momentum accelerating UP. â†’ Strong upside impulse.\n   ðŸŒ² WEAK BULL (Dark Green):  Momentum decelerating DOWN (while positive). â†’ Pullback/pause zone.\n   ðŸ”´ STRONG BEAR (Bright Red):  Momentum accelerating DOWN. â†’ Strong downside impulse.\n   ðŸ· WEAK BEAR (Dark Red):  Momentum decelerating UP (while negative). â†’ Rally/short-covering zone.\n   ðŸ”µ NEUTRAL / CHOP (Cyan):  Momentum is near zero (based on noise threshold). â†’ Consolidation / low volatility.\n \n ðŸŽ¯ Signal Logic Modes \n\nTVPro provides two selectable entry styles, controlled by input:\n \n   Reversals Only (Cleaner Mode â€“ Default):  Targets trend flips. Entry triggers when the current state is Bullish (or Bearish) and the previous state was not. This reduces noise and over-trading.\n   All Strong Pulses (Aggressive Mode):  Targets acceleration phases. Entry triggers when the bar turns to  STRONG BULL  or  STRONG BEAR  after any other state. This mode produces more trades.\n \n ðŸ“Œ Risk Management Tools \n \n    Golden Bars â€“ Trailing Stops:  Yellow â€œTrailâ€ Arrows mark confirmed Swing Highs/Lows. These are used as logical trailing stop levels based on market structure.\n   Extended Bars:  Detects when price closes outside a 2-standard-deviation channel, flagging overextension where a pullback is more likely.\n   Pivot Points:  Used as external targets for Take Profit and structural stop placement.\n \n âš™ï¸ Strategy Defaults (Crucial for Publication Compliance) \n\n To keep backtest results realistic and in line with House Rules, TVPro is published with the following fixed default settings: \n \n   Order Size:   5% of equity per trade  ( default_qty_value = 5 )\n   Commission:   0.04% per order  ( commission_value = 0.04 )\n   Slippage:   2 ticks  ( slippage = 2 )\n   Initial Capital:  10,000\n \n ðŸ“˜ How to Trade with Trend Vector Pro \n \n   Entry:  Take Long when a Long signal appears and confirm the bar is Green (Bull state). Short for Red (Bear state).\n   Stop Loss:  Place the initial SL near the latest swing High/Low, or near a relevant Pivot level.\n   Trade Management:  Follow  Golden (Trail) Arrows  to trail your stop behind structure.\n   Exits:  Exit when: the trailing stop is hit, Price reaches a major Pivot level, or an opposite signal prints.\n \n ðŸ›‘ Disclaimer \n \n This script is for educational purposes only and does not constitute financial advice.  Past performance does not guarantee future results. Always forward-test and use proper risk management before applying any strategy to live trading.\n",
    "image_url": "z9MwNqWe",
    "author": "mbedaiwi2",
    "likes_count": 31,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-10",
    "updated": "2025-12-10",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// Â© mbedaiwi2\n\n//@version=6\nstrategy(\"Trend Vector Pro v2.0\", shorttitle=\"TVPro\", overlay=true, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=5, \ncommission_type=strategy.commission.percent, commission_value=0.04, slippage=2) \n\n// -----------------------------------------------------------------------------\n// 1. CONFIGURATION & INPUTS  \n// -----------------------------------------------------------------------------\ngrp_main = \"Trend Configuration\"\nint fastLen = input.int(5, \"Fast Momentum Length\", minval=1, group=grp_main)\nint slowLen = input.int(34, \"Slow Momentum Length\", minval=1, group=grp_main)\nint smooth = input.int(5, \"Smoothing Factor\", minval=1, group=grp_main)\n\ngrp_filters = \"Signal Filters & Strategy\"\n// Signal Mode Selection\nstring sigMode = input.string(\"Reversals Only (Cleaner)\", \"Signal Logic Mode\", options=[\"Reversals Only (Cleaner)\", \"All Strong Pulses (Aggressive)\"], group=grp_filters)\n\n// ADX Filter\nbool useAdx = input.bool(false, \"Use ADX Filter?\", group=grp_filters)\nint adxThresh = input.int(20, \"ADX Threshold\", minval=1, group=grp_filters)\n\ngrp_visuals = \"Visual Settings\"\nstring textSize = input.string(size.small, \"Labels Text Size\", options=[size.auto, size.tiny, size.small, size.normal, size.large], group=grp_visuals)\n\ncolor col_strong_bull = input.color(color.new(#00FF00, 0), \"Strong Bullish\", group=grp_visuals)\ncolor col_weak_bull   = input.color(color.new(#006400, 0), \"Neutral/Bullish\", group=grp_visuals)\ncolor col_neutral     = input.color(color.new(#00FFFF, 0), \"Neutral (Cyan)\", group=grp_visuals)\ncolor col_weak_bear   = input.color(color.new(#8B0000, 0), \"Neutral/Bearish\", group=grp_visuals)\ncolor col_strong_bear = input.color(color.new(#FF0000, 0), \"Strong Bearish\", group=grp_visuals)\ncolor col_golden      = input.color(color.new(#FFD700, 0), \"Golden Bar\", group=grp_visuals)\ncolor col_extended    = input.color(color.new(#D3D3D3, 0), \"Extended Bar\", group=grp_visuals)\n\ngrp_pivots = \"Pivots Lines\"\nbool showPivotLines = input.bool(true, \"Show Pivot Lines on Chart\", group=grp_pivots)\nstring pivotPeriod = input.timeframe(\"D\", \"Pivot Timeframe\", group=grp_pivots)\n\n// -----------------------------------------------------------------------------\n// 2. MOMENTUM ENGINE & ADX\n// -----------------------------------------------------------------------------\nfloat mid = hl2\nfloat ao = ta.sma(mid, fastLen) - ta.sma(mid, slowLen)\nfloat aoSmooth = ta.ema(ao, smooth) \n\n// ADX Calculation\n[diplus, diminus, adxValue] = ta.dmi(14, 14)\nbool marketIsTrending = useAdx ? (adxValue > adxThresh) : true\n\n// -----------------------------------------------------------------------------\n// 3. TREND STATE LOGIC\n// -----------------------------------------------------------------------------\nvar color barColor = na\nstring stateBias = \"NEUTRAL\"\n\nif aoSmooth > 0\n    if aoSmooth > aoSmooth[1]\n        barColor := col_strong_bull\n        stateBias := \"STRONG BULL\"\n    else\n        barColor := col_weak_bull\n        stateBias := \"WEAK BULL\"\nelse\n    if aoSmooth < aoSmooth[1]\n        barColor := col_strong_bear\n        stateBias := \"STRONG BEAR\"\n    else\n        barColor := col_weak_bear\n        stateBias := \"WEAK BEAR\"\n\nfloat noiseThreshold = ta.stdev(aoSmooth, 100) * 0.2\nif math.abs(aoSmooth) < noiseThreshold\n    barColor := col_neutral\n    stateBias := \"NEUTRAL\"\n\n// -----------------------------------------------------------------------------\n// 4. SPECIAL BAR LOGIC (Visuals Only)\n// -----------------------------------------------------------------------------\n// Extended Bars Logic (Visual)\nbool showExtended = true // Internal Force\nint extPeriod = 20\nfloat extDev = 2.0\nfloat basis = ta.sma(close, extPeriod)\nfloat dev = ta.stdev(close, extPeriod)\nfloat upper = basis + (dev * extDev)\nfloat lower = basis - (dev * extDev)\nbool isExtended = (close > upper) or (close < lower)\n\nif isExtended\n    barColor := col_extended\n    stateBias := \"EXTENDED\"\n\n// Golden Bars (Swing Points) - Used for Trailing Visuals\nbool showGolden = true\nbool isSwingHigh = high[1] > high[0] and high[1] > high[2]\nbool isSwingLow = low[1] < low[0] and low[1] < low[2]\nbool goldenBull = (stateBias == \"STRONG BULL\" or stateBias == \"WEAK BULL\") and isSwingHigh\nbool goldenBear = (stateBias == \"STRONG BEAR\" or stateBias == \"WEAK BEAR\") and isSwingLow\n\nif goldenBull or goldenBear\n    barColor := col_golden\n\nbarcolor(barColor)\n\n// -----------------------------------------------------------------------------\n// 5. SIGNALS GENERATION (FIXED LOGIC)\n// -----------------------------------------------------------------------------\n// Initialize as false to prevent 'na' errors\nbool entryLong = false\nbool entryShort = false\n\n// Logic A: Aggressive\nbool aggLong = (barColor == col_strong_bull) and (barColor[1] != col_strong_bull)\nbool aggShort = (barColor == col_strong_bear) and (barColor[1] != col_strong_bear)\n\n// Logic B: Reversals Only\nbool isBullBias = (stateBias == \"STRONG BULL\" or stateBias == \"WEAK BULL\")\nbool isBearBias = (stateBias == \"STRONG BEAR\" or stateBias == \"WEAK BEAR\")\nbool revLong = isBullBias and not isBullBias[1]\nbool revShort = isBearBias and not isBearBias[1]\n\n// Select Mode\nif sigMode == \"Reversals Only (Cleaner)\"\n    entryLong := revLong\n    entryShort := revShort\nelse\n    entryLong := aggLong\n    entryShort := aggShort\n\n// Apply ADX Filter\nif useAdx\n    entryLong := entryLong and marketIsTrending\n    entryShort := entryShort and marketIsTrending\n\n// -----------------------------------------------------------------------------\n// 6. STRATEGY EXECUTION (BACKTESTING)\n// -----------------------------------------------------------------------------\nif entryLong\n    strategy.entry(\"Long\", strategy.long, comment=\"Long\")\n\nif entryShort\n    strategy.entry(\"Short\", strategy.short, comment=\"Short\")\n\n// -----------------------------------------------------------------------------\n// 7. VISUALS: ARROWS & LABELS\n// -----------------------------------------------------------------------------\ncolor dynamicText = chart.fg_color \n\n// Entry Visuals\nplotshape(entryLong, title=\"Long Entry\", style=shape.arrowup, location=location.belowbar, color=col_strong_bull, size=size.tiny)\nplotshape(entryShort, title=\"Short Entry\", style=shape.arrowdown, location=location.abovebar, color=col_strong_bear, size=size.tiny)\n\nif entryLong\n    label.new(bar_index, low, \"Long\", yloc=yloc.belowbar, color=color(na), textcolor=dynamicText, style=label.style_none, size=textSize)\nif entryShort\n    label.new(bar_index, high, \"Short\", yloc=yloc.abovebar, color=color(na), textcolor=dynamicText, style=label.style_none, size=textSize)\n\n// Trailing Visuals\nplotshape(goldenBear, title=\"Trail Stop (Short)\", style=shape.arrowdown, location=location.abovebar, color=color.yellow, size=size.tiny)\nplotshape(goldenBull, title=\"Trail Stop (Long)\", style=shape.arrowup, location=location.belowbar, color=color.yellow, size=size.tiny)\n\nif goldenBear\n    label.new(bar_index, high, \"Trail\\nShort\", yloc=yloc.abovebar, color=color(na), textcolor=dynamicText, style=label.style_none, size=textSize)\nif goldenBull\n    label.new(bar_index, low, \"Trail\\nLong\", yloc=yloc.belowbar, color=color(na), textcolor=dynamicText, style=label.style_none, size=textSize)\n\n// -----------------------------------------------------------------------------\n// 8. DASHBOARD\n// -----------------------------------------------------------------------------\nvar label infoLabel = label.new(na, na, \"\")\nlabel.delete(infoLabel)\n\nif barstate.islast\n    string biasText = \"BIAS: \" + stateBias\n    color txtColor = barColor == col_extended ? color.gray : barColor == col_golden ? color.yellow : barColor\n    infoLabel := label.new(bar_index + 3, close, text=biasText, color=color.new(chart.bg_color, 0), textcolor=txtColor, style=label.style_label_left, text_formatting=text.format_bold, size=size.small)\n\n// -----------------------------------------------------------------------------\n// 9. PIVOT POINTS\n// -----------------------------------------------------------------------------\np_h = request.security(syminfo.tickerid, pivotPeriod, high[1], lookahead=barmerge.lookahead_on)\np_l = request.security(syminfo.tickerid, pivotPeriod, low[1], lookahead=barmerge.lookahead_on)\np_c = request.security(syminfo.tickerid, pivotPeriod, close[1], lookahead=barmerge.lookahead_on)\n\nfloat pp = (p_h + p_l + p_c) / 3\nfloat r1 = (2 * pp) - p_l\nfloat s1 = (2 * pp) - p_h\nfloat r2 = pp + (p_h - p_l)\nfloat s2 = pp - (p_h - p_l)\nfloat r3 = p_h + 2 * (pp - p_l)\nfloat s3 = p_l - 2 * (p_h - pp)\n\ncolor c_res = color.new(color.red, 30)\ncolor c_sup = color.new(color.green, 30)\ncolor c_pp  = color.new(color.yellow, 0)\n\ndraw_pivot_line(price, col, width) =>\n    line.new(bar_index, price, bar_index, price, color=col, width=width)\n\nvar line l_r3 = na\nvar line l_r2 = na\nvar line l_r1 = na\nvar line l_pp = na\nvar line l_s1 = na\nvar line l_s2 = na\nvar line l_s3 = na\n\nbool isNewPivotPeriod = ta.change(time(pivotPeriod)) != 0\n\nif showPivotLines\n    if isNewPivotPeriod\n        l_r3 := draw_pivot_line(r3, c_res, 1)\n        l_r2 := draw_pivot_line(r2, c_res, 1)\n        l_r1 := draw_pivot_line(r1, c_res, 1)\n        l_pp := draw_pivot_line(pp, c_pp, 2)\n        l_s1 := draw_pivot_line(s1, c_sup, 1)\n        l_s2 := draw_pivot_line(s2, c_sup, 1)\n        l_s3 := draw_pivot_line(s3, c_sup, 1)\n    else\n        line.set_x2(l_r3, bar_index)\n        line.set_x2(l_r2, bar_index)\n        line.set_x2(l_r1, bar_index)\n        line.set_x2(l_pp, bar_index)\n        line.set_x2(l_s1, bar_index)\n        line.set_x2(l_s2, bar_index)\n        line.set_x2(l_s3, bar_index)"
  },
  {
    "url": "csOouivq-Trend-Vector-Pro-v2-0",
    "name": "Trend Vector Pro v2.0",
    "description": "Trend Vector Pro v2.0 \n ðŸ‘¨â€ðŸ’» Developed by: Mohammed Bedaiwi \n\n ðŸ’¡ Strategy Overview & Coherence \n\n Trend Vector Pro (TVPro)  is a momentum-based trend & reversal strategy that uses a custom smoothed oscillator, an optional ADX filter, and classic Pivot Points to create a single, coherent trading framework.\n\n Instead of stacking random indicators, TVPro is built around these integrated components: \n \n  A custom momentum engine (signal generation)\n  An optional ADX filter (trend quality control)\n  Daily Pivot Points (context, targets & S/R)\n  Swing-based â€œGolden Barâ€ trailing stops (trade management)\n  Optional extended bar detection (overextension alerts)\n \nAll parts are designed to work together and are documented below to address originality & usefulness requirements.\n\n ðŸ” Core Components & Justification \n\n 1. Custom Momentum Engine (Main Signal Source) \nTVProâ€™s engine is a custom oscillator derived from the bar midpoint ( hl2 ), similar in spirit to the Awesome Oscillator but adapted and fully integrated into the strategy. It measures velocity and acceleration of price, letting the script distinguish between strong impulses, weakening trends, and pure noise.\n\n 2. ADX Filter (Trend Strength Validation â€“ Optional) \nUses Average Directional Index (ADX) as a gatekeeper.\n Why this matters:  This prevents the strategy from firing signals in choppy, non-trending environments (when ADX is below the threshold) and keeps trades focused on periods of clear directional strength.\n\n 3. Classic Pivot Points (Context & Targets) \nCalculates Daily Pivot Points ( PP, R1-R3, S1-S3 ) via  request.security()  using prior session data.\n Why this matters:  Momentum gives the signal, ADX validates the environment, and Pivots add external structure for risk and target planning. This is a designed interaction, not a random mashup.\n\n ðŸ§­ Trend State Logic (5-State Bar Coloring) \n\nThe strategy uses the momentum's value + slope to define five states, turning the chart into a visual momentum map:\n\n \n   ðŸŸ¢ STRONG BULL (Bright Green):  Momentum accelerating UP. â†’ Strong upside impulse.\n   ðŸŒ² WEAK BULL (Dark Green):  Momentum decelerating DOWN (while positive). â†’ Pullback/pause zone.\n   ðŸ”´ STRONG BEAR (Bright Red):  Momentum accelerating DOWN. â†’ Strong downside impulse.\n   ðŸ· WEAK BEAR (Dark Red):  Momentum decelerating UP (while negative). â†’ Rally/short-covering zone.\n   ðŸ”µ NEUTRAL / CHOP (Cyan):  Momentum is near zero (based on noise threshold). â†’ Consolidation / low volatility.\n \n\n ðŸŽ¯ Signal Logic Modes \n\nTVPro provides two selectable entry styles, controlled by input:\n\n \n   Reversals Only (Cleaner Mode â€“ Default):  Targets trend flips. Entry triggers when the current state is Bullish (or Bearish) and the previous state was not. This reduces noise and over-trading.\n   All Strong Pulses (Aggressive Mode):  Targets acceleration phases. Entry triggers when the bar turns to  STRONG BULL  or  STRONG BEAR  after any other state. This mode produces more trades.\n \n\n ðŸ“Œ Risk Management Tools \n\n \n   ðŸŸ¡ Golden Bars â€“ Trailing Stops:  Yellow â€œTrailâ€ Arrows mark confirmed Swing Highs/Lows. These are used as logical trailing stop levels based on market structure.\n   Extended Bars:  Detects when price closes outside a 2-standard-deviation channel, flagging overextension where a pullback is more likely.\n   Pivot Points:  Used as external targets for Take Profit and structural stop placement.\n \n\n âš™ï¸ Strategy Defaults (Crucial for Publication Compliance) \n\n To keep backtest results realistic and in line with House Rules, TVPro is published with the following fixed default settings: \n\n \n   Order Size:   5% of equity per trade  ( default_qty_value = 5 )\n   Commission:   0.04% per order  ( commission_value = 0.04 )\n   Slippage:   2 ticks  ( slippage = 2 )\n   Initial Capital:  10,000\n \n\n ðŸ“˜ How to Trade with Trend Vector Pro \n\n \n   Entry:  Take Long when a Long signal appears and confirm the bar is Green (Bull state). Short for Red (Bear state).\n   Stop Loss:  Place the initial SL near the latest swing High/Low, or near a relevant Pivot level.\n   Trade Management:  Follow  Golden (Trail) Arrows  to trail your stop behind structure.\n   Exits:  Exit when: the trailing stop is hit, Price reaches a major Pivot level, or an opposite signal prints.\n \n\n ðŸ›‘ Disclaimer \n\n \n This script is for educational purposes only and does not constitute financial advice.  Past performance does not guarantee future results. Always forward-test and use proper risk management before applying any strategy to live trading.\n",
    "image_url": "csOouivq",
    "author": "mbedaiwi2",
    "likes_count": 4,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-10",
    "updated": "2025-12-10",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// Â© mbedaiwi2\n\n//@version=6\nstrategy(\"Trend Vector Pro v2.0\", shorttitle=\"TVPro\", overlay=true, initial_capital=10000, default_qty_type=strategy.percent_of_equity, default_qty_value=5, \ncommission_type=strategy.commission.percent, commission_value=0.04, slippage=2) \n\n// -----------------------------------------------------------------------------\n// 1. CONFIGURATION & INPUTS  \n// -----------------------------------------------------------------------------\ngrp_main = \"Trend Configuration\"\nint fastLen = input.int(5, \"Fast Momentum Length\", minval=1, group=grp_main)\nint slowLen = input.int(34, \"Slow Momentum Length\", minval=1, group=grp_main)\nint smooth = input.int(5, \"Smoothing Factor\", minval=1, group=grp_main)\n\ngrp_filters = \"Signal Filters & Strategy\"\n// Signal Mode Selection\nstring sigMode = input.string(\"Reversals Only (Cleaner)\", \"Signal Logic Mode\", options=[\"Reversals Only (Cleaner)\", \"All Strong Pulses (Aggressive)\"], group=grp_filters)\n\n// ADX Filter\nbool useAdx = input.bool(false, \"Use ADX Filter?\", group=grp_filters)\nint adxThresh = input.int(20, \"ADX Threshold\", minval=1, group=grp_filters)\n\ngrp_visuals = \"Visual Settings\"\nstring textSize = input.string(size.small, \"Labels Text Size\", options=[size.auto, size.tiny, size.small, size.normal, size.large], group=grp_visuals)\n\ncolor col_strong_bull = input.color(color.new(#00FF00, 0), \"Strong Bullish\", group=grp_visuals)\ncolor col_weak_bull   = input.color(color.new(#006400, 0), \"Neutral/Bullish\", group=grp_visuals)\ncolor col_neutral     = input.color(color.new(#00FFFF, 0), \"Neutral (Cyan)\", group=grp_visuals)\ncolor col_weak_bear   = input.color(color.new(#8B0000, 0), \"Neutral/Bearish\", group=grp_visuals)\ncolor col_strong_bear = input.color(color.new(#FF0000, 0), \"Strong Bearish\", group=grp_visuals)\ncolor col_golden      = input.color(color.new(#FFD700, 0), \"Golden Bar\", group=grp_visuals)\ncolor col_extended    = input.color(color.new(#D3D3D3, 0), \"Extended Bar\", group=grp_visuals)\n\ngrp_pivots = \"Pivots Lines\"\nbool showPivotLines = input.bool(true, \"Show Pivot Lines on Chart\", group=grp_pivots)\nstring pivotPeriod = input.timeframe(\"D\", \"Pivot Timeframe\", group=grp_pivots)\n\n// -----------------------------------------------------------------------------\n// 2. MOMENTUM ENGINE & ADX\n// -----------------------------------------------------------------------------\nfloat mid = hl2\nfloat ao = ta.sma(mid, fastLen) - ta.sma(mid, slowLen)\nfloat aoSmooth = ta.ema(ao, smooth) \n\n// ADX Calculation\n[diplus, diminus, adxValue] = ta.dmi(14, 14)\nbool marketIsTrending = useAdx ? (adxValue > adxThresh) : true\n\n// -----------------------------------------------------------------------------\n// 3. TREND STATE LOGIC\n// -----------------------------------------------------------------------------\nvar color barColor = na\nstring stateBias = \"NEUTRAL\"\n\nif aoSmooth > 0\n    if aoSmooth > aoSmooth[1]\n        barColor := col_strong_bull\n        stateBias := \"STRONG BULL\"\n    else\n        barColor := col_weak_bull\n        stateBias := \"WEAK BULL\"\nelse\n    if aoSmooth < aoSmooth[1]\n        barColor := col_strong_bear\n        stateBias := \"STRONG BEAR\"\n    else\n        barColor := col_weak_bear\n        stateBias := \"WEAK BEAR\"\n\nfloat noiseThreshold = ta.stdev(aoSmooth, 100) * 0.2\nif math.abs(aoSmooth) < noiseThreshold\n    barColor := col_neutral\n    stateBias := \"NEUTRAL\"\n\n// -----------------------------------------------------------------------------\n// 4. SPECIAL BAR LOGIC (Visuals Only)\n// -----------------------------------------------------------------------------\n// Extended Bars Logic (Visual)\nbool showExtended = true // Internal Force\nint extPeriod = 20\nfloat extDev = 2.0\nfloat basis = ta.sma(close, extPeriod)\nfloat dev = ta.stdev(close, extPeriod)\nfloat upper = basis + (dev * extDev)\nfloat lower = basis - (dev * extDev)\nbool isExtended = (close > upper) or (close < lower)\n\nif isExtended\n    barColor := col_extended\n    stateBias := \"EXTENDED\"\n\n// Golden Bars (Swing Points) - Used for Trailing Visuals\nbool showGolden = true\nbool isSwingHigh = high[1] > high[0] and high[1] > high[2]\nbool isSwingLow = low[1] < low[0] and low[1] < low[2]\nbool goldenBull = (stateBias == \"STRONG BULL\" or stateBias == \"WEAK BULL\") and isSwingHigh\nbool goldenBear = (stateBias == \"STRONG BEAR\" or stateBias == \"WEAK BEAR\") and isSwingLow\n\nif goldenBull or goldenBear\n    barColor := col_golden\n\nbarcolor(barColor)\n\n// -----------------------------------------------------------------------------\n// 5. SIGNALS GENERATION (FIXED LOGIC)\n// -----------------------------------------------------------------------------\n// Initialize as false to prevent 'na' errors\nbool entryLong = false\nbool entryShort = false\n\n// Logic A: Aggressive\nbool aggLong = (barColor == col_strong_bull) and (barColor[1] != col_strong_bull)\nbool aggShort = (barColor == col_strong_bear) and (barColor[1] != col_strong_bear)\n\n// Logic B: Reversals Only\nbool isBullBias = (stateBias == \"STRONG BULL\" or stateBias == \"WEAK BULL\")\nbool isBearBias = (stateBias == \"STRONG BEAR\" or stateBias == \"WEAK BEAR\")\nbool revLong = isBullBias and not isBullBias[1]\nbool revShort = isBearBias and not isBearBias[1]\n\n// Select Mode\nif sigMode == \"Reversals Only (Cleaner)\"\n    entryLong := revLong\n    entryShort := revShort\nelse\n    entryLong := aggLong\n    entryShort := aggShort\n\n// Apply ADX Filter\nif useAdx\n    entryLong := entryLong and marketIsTrending\n    entryShort := entryShort and marketIsTrending\n\n// -----------------------------------------------------------------------------\n// 6. STRATEGY EXECUTION (BACKTESTING)\n// -----------------------------------------------------------------------------\nif entryLong\n    strategy.entry(\"Long\", strategy.long, comment=\"Long\")\n\nif entryShort\n    strategy.entry(\"Short\", strategy.short, comment=\"Short\")\n\n// -----------------------------------------------------------------------------\n// 7. VISUALS: ARROWS & LABELS\n// -----------------------------------------------------------------------------\ncolor dynamicText = chart.fg_color \n\n// Entry Visuals\nplotshape(entryLong, title=\"Long Entry\", style=shape.arrowup, location=location.belowbar, color=col_strong_bull, size=size.tiny)\nplotshape(entryShort, title=\"Short Entry\", style=shape.arrowdown, location=location.abovebar, color=col_strong_bear, size=size.tiny)\n\nif entryLong\n    label.new(bar_index, low, \"Long\", yloc=yloc.belowbar, color=color(na), textcolor=dynamicText, style=label.style_none, size=textSize)\nif entryShort\n    label.new(bar_index, high, \"Short\", yloc=yloc.abovebar, color=color(na), textcolor=dynamicText, style=label.style_none, size=textSize)\n\n// Trailing Visuals\nplotshape(goldenBear, title=\"Trail Stop (Short)\", style=shape.arrowdown, location=location.abovebar, color=color.yellow, size=size.tiny)\nplotshape(goldenBull, title=\"Trail Stop (Long)\", style=shape.arrowup, location=location.belowbar, color=color.yellow, size=size.tiny)\n\nif goldenBear\n    label.new(bar_index, high, \"Trail\\nShort\", yloc=yloc.abovebar, color=color(na), textcolor=dynamicText, style=label.style_none, size=textSize)\nif goldenBull\n    label.new(bar_index, low, \"Trail\\nLong\", yloc=yloc.belowbar, color=color(na), textcolor=dynamicText, style=label.style_none, size=textSize)\n\n// -----------------------------------------------------------------------------\n// 8. DASHBOARD\n// -----------------------------------------------------------------------------\nvar label infoLabel = label.new(na, na, \"\")\nlabel.delete(infoLabel)\n\nif barstate.islast\n    string biasText = \"BIAS: \" + stateBias\n    color txtColor = barColor == col_extended ? color.gray : barColor == col_golden ? color.yellow : barColor\n    infoLabel := label.new(bar_index + 3, close, text=biasText, color=color.new(chart.bg_color, 0), textcolor=txtColor, style=label.style_label_left, text_formatting=text.format_bold, size=size.small)\n\n// -----------------------------------------------------------------------------\n// 9. PIVOT POINTS\n// -----------------------------------------------------------------------------\np_h = request.security(syminfo.tickerid, pivotPeriod, high[1], lookahead=barmerge.lookahead_on)\np_l = request.security(syminfo.tickerid, pivotPeriod, low[1], lookahead=barmerge.lookahead_on)\np_c = request.security(syminfo.tickerid, pivotPeriod, close[1], lookahead=barmerge.lookahead_on)\n\nfloat pp = (p_h + p_l + p_c) / 3\nfloat r1 = (2 * pp) - p_l\nfloat s1 = (2 * pp) - p_h\nfloat r2 = pp + (p_h - p_l)\nfloat s2 = pp - (p_h - p_l)\nfloat r3 = p_h + 2 * (pp - p_l)\nfloat s3 = p_l - 2 * (p_h - pp)\n\ncolor c_res = color.new(color.red, 30)\ncolor c_sup = color.new(color.green, 30)\ncolor c_pp  = color.new(color.yellow, 0)\n\ndraw_pivot_line(price, col, width) =>\n    line.new(bar_index, price, bar_index, price, color=col, width=width)\n\nvar line l_r3 = na\nvar line l_r2 = na\nvar line l_r1 = na\nvar line l_pp = na\nvar line l_s1 = na\nvar line l_s2 = na\nvar line l_s3 = na\n\nbool isNewPivotPeriod = ta.change(time(pivotPeriod)) != 0\n\nif showPivotLines\n    if isNewPivotPeriod\n        l_r3 := draw_pivot_line(r3, c_res, 1)\n        l_r2 := draw_pivot_line(r2, c_res, 1)\n        l_r1 := draw_pivot_line(r1, c_res, 1)\n        l_pp := draw_pivot_line(pp, c_pp, 2)\n        l_s1 := draw_pivot_line(s1, c_sup, 1)\n        l_s2 := draw_pivot_line(s2, c_sup, 1)\n        l_s3 := draw_pivot_line(s3, c_sup, 1)\n    else\n        line.set_x2(l_r3, bar_index)\n        line.set_x2(l_r2, bar_index)\n        line.set_x2(l_r1, bar_index)\n        line.set_x2(l_pp, bar_index)\n        line.set_x2(l_s1, bar_index)\n        line.set_x2(l_s2, bar_index)\n        line.set_x2(l_s3, bar_index)"
  },
  {
    "url": "gG8XPeRl-Advanced-Breakout-System-v2-0",
    "name": "Advanced Breakout System v2.0",
    "description": "Advanced Breakout System v2.0 \n Developed by:  Mohammed Bedaiwi\n\nThis script hunts for high-probability breakouts by combining price consolidation zones, volume spikes vs. average volume, smart money flow (OBV), and a Momentum Override for explosive moves that skip consolidation. Additionally, it automatically identifies and plots Support and Resistance levels with price labels to help you visualize market structure.\n\nThe system follows a \"Watch & Confirm\" logic: it first prints a WATCH setup, then a BUY only if price confirms strength.\n\n ðŸ’¡ JUSTIFICATION OF CONCEPTS (MASHUP & ORIGINALITY) \n\nThis script is an original mashup combining several analytical concepts to address common breakout failures:\n \n Volatility Compression Engine: Uses built-in functions like ta.highest() and ta.lowest() to mathematically define the setup phase where price volatility is compressed below a user-defined threshold.\n\n Volume Spike Confirmation: The breakout must be confirmed by a volume increase greater than a moving average of volume, signaling strong market interest.\n\n Smart Volume Filter (OBV): This is the key component. By checking if ta.obv is above its own Moving Average, we confirm that accumulation has been occurring during the consolidation period, suggesting institutional positioning before the price break.\n\n Multi-Exit Risk System: Employs dynamic exits (EMA cross, volume dump, bearish pattern) instead of static stop-losses to manage risk adaptively based on real-time market action.\n\n Market Structure Visualization: The script also includes a Support & Resistance engine to plot key swing pivots and price labels for visual context.\n \n âœ… STRATEGY RESULTS & POLICY COMPLIANCE \n\nTo ensure non-misleading and transparent backtesting results, this strategy is published with the following fully compliant properties:\n \n Dataset Compliance: The backtest is performed on the CMTL Daily (1D) chart across a long history, generating 201 total trades. This significantly exceeds the minimum requirement of 100 trades, providing a robust test dataset.\n\n Risk Control: The strategy uses a conservative order size set to 2% of equity (default_qty_value=2), strictly adhering to the sustainable risk recommendation of 5-10% of equity per trade.\n\n Transaction Costs: Realistic trading conditions are modeled using 0.07% commission and 3 ticks slippage to prevent the overestimation of profitability.\n \n âš™ï¸ VISUAL GUIDE & SIGNAL LOGIC \n\nKey Color Legend (Visual Guide):\n \n WATCH â€“ Setup (Yellow Arrow Down): Potential breakout setup detected.\n\n BUY â€“ Confirmation (Green Arrow Up): Confirmed breakout, triggered when price trades above the high of the WATCH candle.\n\n SELL â€“ Break (Orange Arrow): Short-term trend weakness, triggered when price closes below the Fast EMA (9).\n\n SELL â€“ Dump (Dark Red Arrow): Distribution / volume dump, triggered by a bearish candle with abnormally high volume.\n\n SELL â€“ Pattern (Purple Arrow): Bearish price-action pattern (such as a bearish engulfing).\n\n Support & Resistance Lines (Red/Green): Small horizontal lines plotted at key swing points with exact price labels.\n \n âŒ¨ï¸ INPUTS (DEFAULT SETTINGS) \n \n Entry settings: Consolidation Lookback (default 20) = bars used to detect consolidation. Consolidation Range % (default 12%) = max allowed range size. Volume Spike Multiplier (default 1.2) = factor above average volume to count as a spike. Force Signal on Big Moves (default ON) = forces a WATCH signal on high-momentum moves.\n\n Exit settings: Enable Fast Exit (EMA 9) toggles the SELL â€“ Break signal. Dump Volume Multiplier defines what counts as â€œdumpâ€ volume.\n\n Support & Resistance: Adjustable Pivot Left/Right bars control the sensitivity of the support and resistance lines.\n \n âš ï¸ Disclaimer  Trading involves significant risk of loss. This script is for educational and informational purposes only and is not financial advice or a recommendation to buy or sell any asset. BUY and SELL signals are rule-based and derived from historical behavior and do not guarantee future performance. Always use your own analysis and risk management. This is an open-source strategy; users are encouraged to test it across different symbols and timeframes.",
    "image_url": "gG8XPeRl",
    "author": "mbedaiwi2",
    "likes_count": 30,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-10",
    "updated": "2025-12-10",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// Â© mbedaiwi2\n\n//@version=6\nstrategy(\"Advanced Breakout System v2.0\", overlay=true, initial_capital=10000, \n     default_qty_type=strategy.percent_of_equity, \n     default_qty_value=2, currency=currency.USD, \n     commission_type=strategy.commission.percent, \n     commission_value=0.07,      slippage=3 )\n     \n// -------------------------------------------------------------------------\n// 1. Settings (Inputs)\n// -------------------------------------------------------------------------\ngroup_entry = \"Entry Settings\"\n// --- CONDITIONAL INPUTS ---\n// Apply less restrictive settings on Daily chart to force more trades for policy compliance\nis_daily = timeframe.isdaily\n\n// Less restrictive Lookback (e.g., 5 bars instead of 20) on Daily\ndaily_lookback = 5\ndefault_lookback = input.int(20, \"Consolidation Lookback (Bars)\", minval=5, group=group_entry)\nlookback_period = is_daily ? daily_lookback : default_lookback\n\n// More restrictive Range (e.g., 50% instead of 12%) on Daily\ndaily_range_percent = 50.0 // Allow a much wider range for a 'consolidation'\ndefault_range_percent = input.float(12.0, \"Consolidation Range %\", minval=1.0, step=0.5, group=group_entry)\nrange_percent_val = is_daily ? daily_range_percent : default_range_percent\nrange_percent = range_percent_val / 100 \n// -------------------------------------------------------------------------\n// The rest of the script remains the same, but replaces these:\n// lookback_period = input.int(...)  // Delete this line\n// range_percent = input.float(...) / 100 // Delete this line\n// -------------------------------------------------------------------------\nvol_multiplier  = input.float(1.2, \"Volume Spike Multiplier\", minval=1.0, step=0.1, group=group_entry)\nuse_obv_filter  = input.bool(true, \"Enable Smart Volume Filter (OBV)\", group=group_entry)\nignore_cons_on_big_move = input.bool(true, \"Force Signal on Big Moves (>5%)\", tooltip=\"Triggers an immediate WATCH signal for strong moves, bypassing all filters\", group=group_entry)\n\ngroup_exit = \"Exit Settings (Warnings)\"\nuse_fast_exit    = input.bool(true, \"Enable Fast Exit (EMA 9)\", group=group_exit)\nuse_vol_exit     = input.bool(true, \"Enable Volume Dump Exit\", group=group_exit)\nvol_exit_mult    = input.float(2.0, \"Dump Volume Multiplier\", group=group_exit)\nuse_pattern_exit = input.bool(true, \"Enable Bearish Engulfing Exit\", group=group_exit)\n\n// --- GROUP: Support & Resistance ---\ngroup_sr = \"Support & Resistance Points\"\nsr_left_bars  = input.int(15, \"Pivot Left Bars\", minval=2, tooltip=\"Minimum bars to the left to confirm a point\", group=group_sr)\nsr_right_bars = input.int(5, \"Pivot Right Bars\", minval=1, tooltip=\"Minimum bars to the right to confirm a point (lag)\", group=group_sr)\n\n// -------------------------------------------------------------------------\n// 2. Indicators & Calculations\n// -------------------------------------------------------------------------\nhighest_high = ta.highest(high, lookback_period)[1]\nlowest_low   = ta.lowest(low, lookback_period)[1]\n\navg_volume = ta.sma(volume, 20)\nema_fast   = ta.ema(close, 9)\nsma_slow   = ta.sma(close, 20)\n\nobv_value = ta.obv\nobv_ma    = ta.sma(obv_value, lookback_period)\nis_obv_strong = (obv_value > obv_ma)\n\n// --- Pivot Calculation ---\npivot_high = ta.pivothigh(high, sr_left_bars, sr_right_bars)\npivot_low  = ta.pivotlow(low, sr_left_bars, sr_right_bars)\n\n// -------------------------------------------------------------------------\n// 3. Logic & Strategy\n// -------------------------------------------------------------------------\nis_consolidating = ((highest_high - lowest_low) / close[1]) < range_percent\nis_big_move = (close > open * 1.05)\nbreakout_core = close > highest_high and volume > (avg_volume * vol_multiplier)\n\nnormal_trigger = breakout_core and is_consolidating[1]\nfinal_normal_trigger = use_obv_filter ? (normal_trigger and is_obv_strong) : normal_trigger\nmomentum_trigger = breakout_core and is_big_move and ignore_cons_on_big_move\nbreakout_condition = final_normal_trigger or momentum_trigger\n\nvar bool pending_confirmation = false\nvar float breakout_high_price = 0.0\n\nif breakout_condition\n    pending_confirmation := true\n    breakout_high_price := high\n\nif pending_confirmation and close < lowest_low\n    pending_confirmation := false\n\nvalid_entry = pending_confirmation and high > breakout_high_price and bar_index > 0 and not breakout_condition\n\nif valid_entry\n    pending_confirmation := false\n\n// -------------------------------------------------------------------------\n// 4. Exits Logic\n// -------------------------------------------------------------------------\nexit_trend = use_fast_exit and ta.crossunder(close, ema_fast)\nexit_vol = use_vol_exit and close < open and volume > (avg_volume * vol_exit_mult)\nis_engulfing = close < open and close[1] > open[1] and close < low[1] and open > high[1]\nexit_pattern = use_pattern_exit and is_engulfing\nany_exit_signal = exit_trend or exit_vol or exit_pattern\n\n// -------------------------------------------------------------------------\n// 5. Strategy Execution\n// -------------------------------------------------------------------------\nif valid_entry\n    strategy.entry(\"Long Position\", strategy.long, stop=breakout_high_price)\n\nif strategy.position_size > 0 and any_exit_signal\n    strategy.close(\"Long Position\", comment=\"Exit Signal\")\n\n// -------------------------------------------------------------------------\n// 6. Alerts\n// -------------------------------------------------------------------------\nif breakout_condition\n    alert(\"ðŸŸ¡ WATCH SETUP: \" + syminfo.ticker + \" - Breakout Detected. Prepare for entry.\", alert.freq_once_per_bar_close)\n\nif valid_entry\n    alert(\"ðŸŸ¢ BUY SIGNAL: \" + syminfo.ticker + \" - Price Confirmed above Breakout Level.\", alert.freq_once_per_bar_close)\n\nif any_exit_signal\n    string exit_reason = \"\"\n    if exit_trend\n        exit_reason := \"Trend Broken (EMA 9)\"\n    else if exit_vol\n        exit_reason := \"Volume Dump (Distribution)\"\n    else if exit_pattern\n        exit_reason := \"Bearish Pattern (Engulfing)\"\n    alert(\"ðŸ”´ SELL SIGNAL: \" + syminfo.ticker + \" - Reason: \" + exit_reason, alert.freq_once_per_bar_close)\n\n// -------------------------------------------------------------------------\n// 7. Visualization\n// -------------------------------------------------------------------------\nfill(plot(highest_high, display=display.none), plot(lowest_low, display=display.none), color=is_consolidating ? color.new(color.blue, 90) : na, title=\"Consolidation Zone\")\nplot(use_fast_exit ? ema_fast : na, \"EMA 9 (Fast Exit)\", color.orange)\nplot(sma_slow, \"SMA 20 (Trend)\", color.gray)\n\n// Signals\nplotshape(breakout_condition, \"Breakout Setup\", shape.arrowdown, location.abovebar, color.yellow, 0, \"WATCH\", color.yellow, size=size.small)\nplotshape(valid_entry, \"Buy Confirmation\", shape.arrowup, location.belowbar, color.green, 0, \"BUY\", color.green, size=size.small)\nplotshape(exit_trend, \"Trend Break\", shape.arrowdown, location.abovebar, color.orange, 0, \"BREAK\", color.orange, size=size.small)\nplotshape(exit_vol, \"Volume Dump\", shape.arrowdown, location.abovebar, color.maroon, 0, \"DUMP\", color.maroon, size=size.small)\nplotshape(exit_pattern, \"Bearish Pattern\", shape.arrowdown, location.abovebar, color.purple, 0, \"PATTERN\", color.purple, size=size.small)\n\n// --- NEW: Support & Resistance (Lines & Price Labels) ---\n\n// 1. Draw Resistance (Red Line + Price)\nif not na(pivot_high)\n    // Pivot location is in the past\n    pivot_loc = bar_index - sr_right_bars\n    // Draw small red line\n    line.new(x1=pivot_loc - 1, y1=pivot_high, x2=pivot_loc + 1, y2=pivot_high, color=color.red, width=2)\n    // Draw price text above\n    label.new(x=pivot_loc, y=pivot_high, text=str.tostring(pivot_high, format.mintick), style=label.style_label_down, color=color.new(color.white, 100), textcolor=color.red, size=size.small)\n\n// 2. Draw Support (Green Line + Price)\nif not na(pivot_low)\n    // Pivot location is in the past\n    pivot_loc = bar_index - sr_right_bars\n    // Draw small green line\n    line.new(x1=pivot_loc - 1, y1=pivot_low, x2=pivot_loc + 1, y2=pivot_low, color=color.green, width=2)\n    // Draw price text below\n    label.new(x=pivot_loc, y=pivot_low, text=str.tostring(pivot_low, format.mintick), style=label.style_label_up, color=color.new(color.white, 100), textcolor=color.green, size=size.small)"
  },
  {
    "url": "BC1UkDQc-2026-CHRISTMAS-PRESENT",
    "name": "2026 CHRISTMAS PRESENT ",
    "description": "CHRISTMAS PRESENT \n\n Overview \n\nThe Cash Detector is a comprehensive trading strategy that combines momentum analysis with price action confirmation to identify high-probability entry points. This strategy is designed to capture trend reversals and continuation moves by requiring multiple confirming signals before entry, significantly reducing false signals common in single-indicator systems.\n\n\n Strategy Background \n\nThe strategy is built on the principle of confluence trading requiring multiple technical factors to align before taking a position. It focuses on two critical phases of market rotation:\n\nQ2 Momentum Phase: Uses MACD crossovers to identify shifts in market momentum, signaling when bulls or bears are gaining control.\n\nQ4 Trigger Phase: Employs engulfing candlestick patterns to confirm strong directional pressure and validate the momentum signal with actual price action.\n\nBy combining these elements, the strategy filters out weak signals and focuses only on setups where both momentum AND price action agree on direction.\n\n\n Key Features \n\n\n Dual Confirmation System: Requires both MACD momentum shift and engulfing candle pattern\n\n RSI Filter: Optional overbought/oversold filter to avoid extreme conditions\n\n Built-in Risk Management: Configurable stop loss and take profit levels\n\n Performance Dashboard: Real-time ROI metrics displayed on chart\n\n Full Backtesting: Strategy mode allows historical performance analysis\n\n\n\n Trading Rules \n\n\n LONG ENTRY BUY \n\nAll conditions must occur on the same candle:\n\n 1. Momentum Confirmation: \nMACD line crosses above signal line bullish crossover\n\n 2. Price Action Confirmation: \nBullish engulfing pattern forms:\nCurrent close greater than previous open\nCurrent open less than previous close\nCurrent close greater than current open\n\n 3. RSI Filter Optional: \nRSI less than 70 not overbought\n\nVisual Signal: Green LONG label appears below the candle\n\n\n SHORT ENTRY SELL \n\nAll conditions must occur on the same candle:\n\n 1. Momentum Confirmation: \nMACD line crosses below signal line bearish crossover\n\n 2. Price Action Confirmation: \nBearish engulfing pattern forms:\nCurrent close less than previous open\nCurrent open greater than previous close\nCurrent close less than current open\n\n 3. RSI Filter Optional: \nRSI greater than 30 not oversold\n\nVisual Signal: Red SHORT label appears above the candle\n\n \nExit Rules \n\n\n Stop Loss Default 2 percent \n\nLong: Exit if price drops 2 percent below entry\n\nShort: Exit if price rises 2 percent above entry\n\n\n Take Profit Default 4 percent \n\nLong: Exit if price rises 4 percent above entry\n\nShort: Exit if price drops 4 percent below entry\n\n\n Input Parameters\n\n\nIndicator Settings \n\nMACD Fast Length: 12 default\n\nMACD Slow Length: 26 default\n\nRSI Length: 14 default\n\n \nRisk Management \n\nUse Stop Loss: Enable or disable stop loss\n\nStop Loss percent: Percentage risk per trade default 2 percent\n\nUse Take Profit: Enable or disable take profit\n\nTake Profit percent: Target profit per trade default 4 percent\n\n\nFilters\n\nUse RSI Filter: Enable or disable RSI overbought oversold filter\n\nRSI Overbought: Upper threshold default 70\n\nRSI Oversold: Lower threshold default 30\n\n\nPerformance Metrics\n\nThe built-in dashboard displays:\n\nNet Profit: Total profit loss in currency and percentage\n\nTotal Trades: Number of completed trades\n\nWin Rate: Percentage of profitable trades\n\nProfit Factor: Ratio of gross profit to gross loss\n\nAverage Win Loss: Mean profit per winning losing trade\n\nMax Drawdown: Largest peak to trough decline\n\n\n Best Practices \n\n1. Timeframe Selection: Works on multiple timeframes test on 15min 1H 4H and daily\n\n2. Market Conditions: Most effective in trending markets with clear momentum\n\n3. Risk Reward Ratio: Default 1:2 ratio 2 percent risk 4 percent reward is conservative adjust based on backtesting\n\n4. Combine with Context: Consider overall market trend and support resistance levels\n\n5. Backtest First: Always backtest on your specific instrument and timeframe before live trading\n\n\n Risk Disclaimer \n\nThis strategy is for educational purposes. Past performance does not guarantee future results. Always:\n\nBacktest thoroughly on historical data\n\nPaper trade before using real capital\n\nUse proper position sizing and risk management\n\nNever risk more than you can afford to lose\n\n\nCustomization Tips\n\nAggressive traders: Reduce stop loss to 1.5 percent increase take profit to 5 percent\n\nConservative traders: Increase stop loss to 3 percent reduce take profit to 3 percent\n\nRanging markets: Enable RSI filter to avoid false breakouts\n\nStrong trends: Disable RSI filter to catch all momentum shifts\n\n\nTechnical Details\n\nIndicators Used:\n\nMoving Average Convergence Divergence MACD\n\nRelative Strength Index RSI\n\nCandlestick Pattern Recognition\n\nStrategy Type: Trend following with momentum confirmation\n\nBest Suited For: Stocks Forex Crypto Indices\n\n\nVersion 1.0\n\nCompatible with Pine Script v5\n\n",
    "image_url": "BC1UkDQc",
    "author": "hushedDiamond97573",
    "likes_count": 1216,
    "comments_count": 8,
    "script_type": "strategy",
    "created": "2025-12-10",
    "updated": "2025-12-10",
    "source": "//@version=5\nstrategy(\"Quad Rotation Detector with ROI\", overlay=true, \n     default_qty_type=strategy.percent_of_equity, default_qty_value=100)\n\n// ========== Input Parameters ==========\nlenMACD = input.int(12, \"MACD Fast Length\", minval=1)\nlenSignal = input.int(26, \"MACD Slow Length\", minval=1)\nlenRSI = input.int(14, \"RSI Length\", minval=1)\n\n// Trade Settings\nuseStopLoss = input.bool(true, \"Use Stop Loss\", group=\"Risk Management\")\nstopLossPct = input.float(2.0, \"Stop Loss %\", minval=0.1, maxval=20, step=0.1, group=\"Risk Management\")\nuseTakeProfit = input.bool(true, \"Use Take Profit\", group=\"Risk Management\")\ntakeProfitPct = input.float(4.0, \"Take Profit %\", minval=0.1, maxval=50, step=0.1, group=\"Risk Management\")\n\n// Signal Filters\nuseRSIFilter = input.bool(true, \"Use RSI Filter\", group=\"Filters\")\nrsiOverbought = input.int(70, \"RSI Overbought\", minval=50, maxval=100, group=\"Filters\")\nrsiOversold = input.int(30, \"RSI Oversold\", minval=0, maxval=50, group=\"Filters\")\n\n// ========== Q2 â€“ Momentum ==========\n[macdLine, signalLine, _] = ta.macd(close, lenMACD, lenSignal, 9)\nmacdCrossUp = ta.crossover(macdLine, signalLine)\nmacdCrossDown = ta.crossunder(macdLine, signalLine)\nrsi = ta.rsi(close, lenRSI)\n\n// ========== Q4 â€“ Trigger Candle ==========\nengulfingBull = close > open[1] and open < close[1] and close > open\nengulfingBear = close < open[1] and open > close[1] and close < open\n\n// ========== Signal Logic ==========\n// Long signal: Momentum up + Bullish engulfing\nlongSignal = macdCrossUp and engulfingBull\nif useRSIFilter\n    longSignal := longSignal and rsi < rsiOverbought\n\n// Short signal: Momentum down + Bearish engulfing\nshortSignal = macdCrossDown and engulfingBear\nif useRSIFilter\n    shortSignal := shortSignal and rsi > rsiOversold\n\n// ========== Strategy Execution ==========\nif longSignal\n    strategy.entry(\"Long\", strategy.long)\n    if useStopLoss\n        strategy.exit(\"Long Exit\", \"Long\", \n             stop=close * (1 - stopLossPct / 100),\n             limit=useTakeProfit ? close * (1 + takeProfitPct / 100) : na)\n\nif shortSignal\n    strategy.entry(\"Short\", strategy.short)\n    if useStopLoss\n        strategy.exit(\"Short Exit\", \"Short\",\n             stop=close * (1 + stopLossPct / 100),\n             limit=useTakeProfit ? close * (1 - takeProfitPct / 100) : na)\n\n// ========== Visual Markers ==========\nplotshape(macdCrossUp, title=\"Momentum Up\", location=location.belowbar,\n     color=color.new(color.green, 0), style=shape.triangleup, size=size.tiny)\nplotshape(macdCrossDown, title=\"Momentum Down\", location=location.abovebar,\n     color=color.new(color.red, 0), style=shape.triangledown, size=size.tiny)\n\nplotshape(longSignal, title=\"LONG Signal\", location=location.belowbar,\n     color=color.new(color.lime, 0), style=shape.labelup, text=\"LONG\", size=size.small)\nplotshape(shortSignal, title=\"SHORT Signal\", location=location.abovebar,\n     color=color.new(color.maroon, 0), style=shape.labeldown, text=\"SHORT\", size=size.small)\n\n// ========== Performance Dashboard ==========\nvar table perfTable = table.new(position.top_right, 2, 8, \n     bgcolor=color.new(color.white, 10), border_width=2, border_color=color.gray)\n\nif barstate.islast\n    // Calculate metrics\n    totalTrades = strategy.closedtrades\n    winningTrades = 0\n    losingTrades = 0\n    totalProfit = 0.0\n    \n    for i = 0 to totalTrades - 1\n        profit = strategy.closedtrades.profit(i)\n        totalProfit := totalProfit + profit\n        if profit > 0\n            winningTrades := winningTrades + 1\n        else\n            losingTrades := losingTrades + 1\n    \n    winRate = totalTrades > 0 ? (winningTrades / totalTrades) * 100 : 0\n    avgWin = winningTrades > 0 ? strategy.grossprofit / winningTrades : 0\n    avgLoss = losingTrades > 0 ? strategy.grossloss / losingTrades : 0\n    profitFactor = strategy.grossloss != 0 ? strategy.grossprofit / math.abs(strategy.grossloss) : 0\n    \n    // Display table\n    table.cell(perfTable, 0, 0, \"Performance Metrics\", \n         text_color=color.white, text_size=size.normal, bgcolor=color.new(color.blue, 20))\n    table.merge_cells(perfTable, 0, 0, 1, 0)\n    \n    table.cell(perfTable, 0, 1, \"Net Profit:\", text_color=color.black, text_size=size.small)\n    table.cell(perfTable, 1, 1, str.tostring(strategy.netprofit, \"#.##\") + \" (\" + \n         str.tostring((strategy.netprofit / strategy.initial_capital) * 100, \"#.##\") + \"%)\",\n         text_color=strategy.netprofit > 0 ? color.green : color.red, text_size=size.small)\n    \n    table.cell(perfTable, 0, 2, \"Total Trades:\", text_color=color.black, text_size=size.small)\n    table.cell(perfTable, 1, 2, str.tostring(totalTrades), text_color=color.black, text_size=size.small)\n    \n    table.cell(perfTable, 0, 3, \"Win Rate:\", text_color=color.black, text_size=size.small)\n    table.cell(perfTable, 1, 3, str.tostring(winRate, \"#.##\") + \"%\",\n         text_color=winRate > 50 ? color.green : color.orange, text_size=size.small)\n    \n    table.cell(perfTable, 0, 4, \"Profit Factor:\", text_color=color.black, text_size=size.small)\n    table.cell(perfTable, 1, 4, str.tostring(profitFactor, \"#.##\"),\n         text_color=profitFactor > 1 ? color.green : color.red, text_size=size.small)\n    \n    table.cell(perfTable, 0, 5, \"Avg Win:\", text_color=color.black, text_size=size.small)\n    table.cell(perfTable, 1, 5, str.tostring(avgWin, \"#.##\"), \n         text_color=color.green, text_size=size.small)\n    \n    table.cell(perfTable, 0, 6, \"Avg Loss:\", text_color=color.black, text_size=size.small)\n    table.cell(perfTable, 1, 6, str.tostring(avgLoss, \"#.##\"),\n         text_color=color.red, text_size=size.small)\n    \n    table.cell(perfTable, 0, 7, \"Max Drawdown:\", text_color=color.black, text_size=size.small)\n    table.cell(perfTable, 1, 7, str.tostring(strategy.max_drawdown, \"#.##\") + \" (\" +\n         str.tostring((strategy.max_drawdown / strategy.initial_capital) * 100, \"#.##\") + \"%)\",\n         text_color=color.orange, text_size=size.small)"
  },
  {
    "url": "bZzxTcfj-ALT-Risk-Metric-Strategy",
    "name": "ALT Risk Metric Strategy",
    "description": "Here's a professional write-up for your ALT Risk Strategy script:\n\nALT/BTC Risk Strategy - Multi-Crypto DCA with Bitcoin Correlation Analysis\nOverview\nThis strategy uses Bitcoin correlation as a risk indicator to time entries and exits for altcoins. By analyzing how your chosen altcoin performs relative to Bitcoin, the strategy identifies optimal accumulation periods (when alt/BTC is oversold) and profit-taking opportunities (when alt/BTC is overbought). Perfect for traders who want to outperform Bitcoin by strategically timing altcoin positions.\nKey Innovation: Why Alt/BTC Matters\nMost traders focus solely on USD price, but Alt/BTC ratios reveal true altcoin strength:\n\nWhen Alt/BTC is low â†’ Altcoin is undervalued relative to Bitcoin (buy opportunity)\nWhen Alt/BTC is high â†’ Altcoin has outperformed Bitcoin (take profits)\nThis approach captures the rotation between BTC and alts that drives crypto cycles\n\nKey Features\nðŸ“Š Advanced Technical Analysis\n\nRSI (60% weight): Primary momentum indicator on weekly timeframe\nLong-term MA Deviation (35% weight): Measures distance from 150-period baseline\nMACD (5% weight): Minor confirmation signal\nEMA Smoothing: Filters noise while maintaining responsiveness\nAll calculations performed on Alt/BTC pairs for superior market timing\n\nðŸ’° 3-Tier DCA System\n\nLevel 1 (Risk â‰¤ 70): Conservative entry, base allocation\nLevel 2 (Risk â‰¤ 50): Increased allocation, strong opportunity\nLevel 3 (Risk â‰¤ 30): Maximum allocation, extreme undervaluation\nContinuous buying: Executes every bar while below threshold for true DCA behavior\nCumulative sizing: L3 triggers = L1 + L2 + L3 amounts combined\n\nðŸ“ˆ Smart Profit Management\n\nSequential selling: Must complete L1 before L2, L2 before L3\nPercentage-based exits: Sell portions of position, not fixed amounts\nAuto-reset on re-entry: New buy signals reset sell progression\nPrevents premature full exits during volatile conditions\n\nðŸ¤– 3Commas Automation\n\nPre-configured JSON webhooks for Custom Signal Bots\nMulti-exchange support: Binance, Coinbase, Kraken, Bitfinex, Bybit\nFlexible quote currency: USD, USDT, or BUSD\nDynamic order sizing: Automatically adjusts to your tier thresholds\nFull webhook documentation compliance\n\nðŸŽ¨ Multi-Asset Support\nPre-configured for popular altcoins:\n\nETH (Ethereum)\nSOL (Solana)\nADA (Cardano)\nLINK (Chainlink)\nUNI (Uniswap)\nXRP (Ripple)\nDOGE\nRENDER\nCustom option for any other crypto\n\nHow It Works\nRisk Metric Calculation (0-100 scale):\n\nFetches weekly Alt/BTC price data for stability\nCalculates RSI, MACD, and deviation from 150-period MA\nNormalizes MACD to 0-100 range using 500-bar lookback\nCombines weighted components: (MACD Ã— 0.05) + (RSI Ã— 0.60) + (Deviation Ã— 0.35)\nApplies 5-period EMA smoothing for cleaner signals\n\nColor-Coded Risk Zones:\n\nGreen (0-30): Extreme buying opportunity - Alt heavily oversold vs BTC\nLime/Yellow (30-70): Accumulation range - favorable risk/reward\nOrange (70-85): Caution zone - consider taking initial profits\nRed/Maroon (85-100+): Euphoria zone - aggressive profit-taking\n\nEntry Logic:\n\nBuys execute every candle when risk is below threshold\nAs risk decreases, position sizing automatically scales up\nExample: If risk drops from 60â†’25, you'll be buying at L1 rate until it hits 50, then L2 rate, then L3 rate\n\nExit Logic:\n\nSells only trigger when in profit AND risk exceeds thresholds\nSequential execution ensures partial profit-taking\nIf new buy signal occurs before all sells complete, sell levels reset to L1\n\nConfiguration Guide\nChoosing Your Altcoin:\n\nSelect crypto from dropdown (or use CUSTOM for unlisted coins)\nPick your exchange\nChoose quote currency (USD, USDT, BUSD)\n\nRisk Metric Tuning:\n\nLong Term MA (default 150): Higher = more extreme signals, Lower = more frequent\nRSI Length (default 10): Lower = more volatile, Higher = smoother\nSmoothing (default 5): Increase for less noise, decrease for faster reaction\n\nBuy Settings (Aggressive DCA Example):\n\nL1 Threshold: 70 | Amount: $5\nL2 Threshold: 50 | Amount: $6\nL3 Threshold: 30 | Amount: $7\nTotal L3 buy = $18 per candle when deeply oversold\n\nSell Settings (Balanced Exit Example):\n\nL1: 70 threshold, 25% position\nL2: 85 threshold, 35% position\nL3: 100 threshold, 40% position (final exit)\n\n3Commas Setup\nBot Configuration:\n\nCreate Custom Signal Bot in 3Commas\nSet trading pair to your altcoin/USD (e.g., ETH/USD, SOL/USDT)\nOrder size: Select \"Send in webhook, quote\" to use strategy's dollar amounts\nCopy Bot UUID and Secret Token\n\nScript Configuration:\n\nPaste credentials into 3Commas section inputs\nCheck \"Enable 3Commas Alerts\"\nSave and apply to chart\n\nTradingView Alert:\n\nCreate Alert â†’ Condition: \"alert() function calls only\"\nWebhook URL: api.3commas.io\nEnable \"Webhook URL\" checkbox\nExpiration: Open-ended\n\nStrategy Advantages\nâœ… Outperform Bitcoin: Designed specifically to beat BTC by timing alt rotations\nâœ… Capture Alt Seasons: Automatically accumulates when alts lag, sells when they pump\nâœ… Risk-Adjusted Sizing: Buys more when cheaper (better risk/reward)\nâœ… Emotional Discipline: Systematic approach removes fear and FOMO\nâœ… Multi-Asset: Run same strategy across multiple altcoins simultaneously\nâœ… Proven Indicators: Combines RSI, MACD, and MA deviation - battle-tested tools\nBacktesting Insights\nOptimal Timeframes:\n\nDaily chart: Best for backtesting and signal generation\nWeekly data is fetched internally regardless of display timeframe\n\nHistorical Performance Characteristics:\n\nAccumulates heavily during bear markets and BTC dominance periods\nCaptures explosive altcoin rallies when BTC stagnates\nSequential selling preserves capital during extended downtrends\nWorks best on established altcoins with multi-year history\n\nRisk Considerations:\n\nRequires capital reserves for extended accumulation periods\nSome altcoins may never recover if fundamentals deteriorate\nPast correlation patterns may not predict future performance\nAlways size positions according to personal risk tolerance\n\nVisual Interface\nIndicator Panel Displays:\n\nDynamic color line: Greenâ†’Limeâ†’Yellowâ†’Orangeâ†’Red as risk increases\nHorizontal threshold lines: Dashed lines mark your buy/sell levels\nEntry/Exit labels: Green labels for buys, Orange/Red/Maroon for sells\nReal-time risk value: Numerical display on price scale\n\nCustomization:\n\nAll threshold lines are adjustable via inputs\nColor scheme clearly differentiates buy zones (green spectrum) from sell zones (red spectrum)\nLine weights emphasize most extreme thresholds (L3 buy and L3 sell)\n\nStrategy Philosophy\nThis strategy is built on the principle that altcoins move in cycles relative to Bitcoin. During Bitcoin rallies, alts often bleed against BTC (high sell, accumulate). When Bitcoin consolidates, alts pump (take profits). By measuring risk on the Alt/BTC chart instead of USD price, we time these rotations with precision.\nThe 3-tier system ensures you're always averaging in at better prices and scaling out at better prices, maximizing your Bitcoin-denominated returns.\nAdvanced Tips\nMulti-Bot Strategy:\nRun this on 5-10 different altcoins simultaneously to:\n\nDiversify correlation risk\nCapture whichever alt is pumping\nSmooth equity curve through rotation\n\nPairing with BTC Strategy:\nUse alongside the BTC DCA Risk Strategy for complete portfolio coverage:\n\nBTC strategy for core holdings\nALT strategies for alpha generation\nRebalance between them based on BTC dominance\n\nThreshold Calibration:\n\nCheck 2-3 years of historical data for your chosen alt\nNote where risk metric sat during major bottoms (set buy thresholds)\nNote where it peaked during euphoria (set sell thresholds)\nAdjust for your risk tolerance and holding period\n\nCredits\nStrategy Development & 3Commas Integration: Claude AI (Anthropic)\nTechnical Analysis Framework: RSI, MACD, Moving Average theory\nImplementation: pommesUNDwurst\nDisclaimer\nThis strategy is for educational purposes only. Cryptocurrency trading involves substantial risk of loss. Altcoins are especially volatile and many fail completely. The strategy assumes liquid markets and reliable Alt/BTC price data. Always do your own research, understand the fundamentals of any asset you trade, and never risk more than you can afford to lose. Past performance does not guarantee future results. The authors are not financial advisors and assume no liability for trading decisions.\nAdditional Warning: Using leverage or trading illiquid altcoins amplifies risk significantly. This strategy is designed for spot trading of established cryptocurrencies with deep liquidity.\n\nTags: Altcoin, Alt/BTC, DCA, Risk Metric, Dollar Cost Averaging, 3Commas, ETH, SOL, Crypto Rotation, Bitcoin Correlation, Automated Trading, Alt Season\n\nFeel free to modify any sections to better match your style or add specific backtesting results you've observed! ðŸš€Claude is AI and can make mistakes. Please double-check responses. Sonnet 4.5",
    "image_url": "bZzxTcfj",
    "author": "nakphanan",
    "likes_count": 15,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-10",
    "updated": "2025-12-10",
    "source": "//@version=5\r\nstrategy(\"ALT Risk Strategy\", overlay=false, initial_capital=10000, default_qty_type=strategy.cash, commission_type=strategy.commission.percent, commission_value=0.1)\r\n\r\n// === TICKER SELECTION ===\r\ncryptoSymbol = input.string(\"ETH\", \"Crypto Symbol\", options=[\"ETH\", \"SOL\", \"ADA\", \"LINK\", \"UNI\", \"XRP\", \"XDG\", \"RENDER\", \"CUSTOM\"])\r\ncustomSymbol = input.string(\"\", \"Custom Symbol (if CUSTOM selected)\")\r\nquoteSymbol = input.string(\"USD\", \"Quote Currency\", options=[\"USD\", \"USDT\", \"BUSD\"])\r\nexchange = input.string(\"BINANCE\", \"Exchange\", options=[\"BINANCE\", \"COINBASE\", \"KRAKEN\", \"BITFINEX\", \"BYBIT\"])\r\n\r\n// Build the tickers\r\nuseSymbol = cryptoSymbol == \"CUSTOM\" ? customSymbol : cryptoSymbol\r\nCRYPTO_BTC_TICKER = exchange + \":\" + useSymbol + \"BTC\"  // For risk metric calculation\r\nCRYPTO_USD_TICKER = useSymbol + quoteSymbol  // For 3Commas trading\r\n\r\n// === RISK METRIC INPUTS ===\r\nlongTermLength   = input.int(150, \"Long Term MA Length\", minval=10, group=\"Risk Metric\")\r\nrsiLength        = input.int(10, \"RSI Length\", minval=1, group=\"Risk Metric\")\r\nsignalFastLength = input.int(8, \"MACD Fast Length\", minval=1, group=\"Risk Metric\")\r\nsignalSlowLength = input.int(26, \"MACD Slow Length\", minval=1, group=\"Risk Metric\")\r\nsmoothingLength  = input.int(5, \"Smoothing Length\", minval=1, group=\"Risk Metric\")\r\n\r\n// === 3COMMAS CREDENTIALS ===\r\nbot_uuid = input.string(\"\", \"3Commas Bot UUID\", group=\"3Commas\", tooltip=\"Get this from your Signal Bot settings\")\r\nsecret_token = input.string(\"\", \"3Commas Secret Token\", group=\"3Commas\", tooltip=\"Get this from your Signal Bot settings\")\r\nuse_3commas = input.bool(false, \"Enable 3Commas Alerts\", group=\"3Commas\")\r\n// === BUY THRESHOLDS & AMOUNTS ===\r\nbuyL1_thresh = input.float(70.0, \"Buy L1 Threshold\", group=\"Buy Settings\")\r\nbuyL2_thresh = input.float(50.0, \"Buy L2 Threshold\", group=\"Buy Settings\")\r\nbuyL3_thresh = input.float(30.0, \"Buy L3 Threshold\", group=\"Buy Settings\")\r\nbuyL1_amt = input.float(5.0, \"Buy L1 $ Amount\", group=\"Buy Settings\")\r\nbuyL2_amt = input.float(6.0, \"Buy L2 $ Amount\", group=\"Buy Settings\")\r\nbuyL3_amt = input.float(7.0, \"Buy L3 $ Amount\", group=\"Buy Settings\")\r\n\r\n// === SELL THRESHOLDS & PERCENTAGES ===\r\nsellL1_thresh = input.float(70.0, \"Sell L1 Threshold\", group=\"Sell Settings\")\r\nsellL2_thresh = input.float(85.0, \"Sell L2 Threshold\", group=\"Sell Settings\")\r\nsellL3_thresh = input.float(100.0, \"Sell L3 Threshold\", group=\"Sell Settings\")\r\nsellL1_pct = input.float(25.0, \"Sell L1 %\", group=\"Sell Settings\")\r\nsellL2_pct = input.float(35.0, \"Sell L2 %\", group=\"Sell Settings\")\r\nsellL3_pct = input.float(40.0, \"Sell L3 %\", group=\"Sell Settings\")\r\n\r\n// === FUNCTION TO CALCULATE MACD, RSI, DEVIATION ===\r\nf_get_fixed_data() =>\r\n    fastMA   = ta.ema(close, signalFastLength)\r\n    slowMA   = ta.ema(close, signalSlowLength)\r\n    macdLine = fastMA - slowMA\r\n    rsiVal   = ta.rsi(close, rsiLength)\r\n    longMA   = ta.sma(close, longTermLength)\r\n    deviation = (close - longMA) / longMA\r\n    [macdLine, rsiVal, deviation]\r\n\r\n// === FETCH WEEKLY DATA ===\r\n[macdLine_W, rsi_W, dev_W] = request.security(CRYPTO_BTC_TICKER, \"W\", f_get_fixed_data(), barmerge.gaps_off)\r\n\r\n// === NORMALIZE MACD ===\r\nmacdMax = ta.highest(macdLine_W, 500)\r\nmacdMin = ta.lowest(macdLine_W, 500)\r\nmacdRange = macdMax != macdMin ? (macdLine_W - macdMin) / (macdMax - macdMin) * 100 : 50\r\nnormalizedMacd = macdRange < 0 ? 0 : macdRange > 100 ? 100 : macdRange\r\n\r\n// === CALCULATE RISK METRIC ===\r\nriskOsc = (normalizedMacd * 0.05) + (rsi_W * 0.60) + ((dev_W + 1) * 0.35 * 100)\r\nriskMetric = ta.ema(riskOsc, smoothingLength)\r\n\r\n// === STATE VARIABLES ===\r\nvar bool sellL1_done = false\r\nvar bool sellL2_done = false\r\nvar bool sellL3_done = false\r\n\r\n// === BUY LOGIC ===\r\nvar float buyAmount = 0.0\r\nbuyTier = \"NONE\"\r\n\r\nif riskMetric <= buyL3_thresh\r\n    buyAmount := buyL1_amt + buyL2_amt + buyL3_amt\r\n    buyTier := \"L3\"\r\nelse if riskMetric <= buyL2_thresh\r\n    buyAmount := buyL1_amt + buyL2_amt\r\n    buyTier := \"L2\"\r\nelse if riskMetric <= buyL1_thresh\r\n    buyAmount := buyL1_amt\r\n    buyTier := \"L1\"\r\nelse\r\n    buyAmount := 0\r\n    buyTier := \"NONE\"\r\n\r\nbuyTrigger = buyAmount > 0\r\n\r\n// === BUY EXECUTION ===\r\nif buyTrigger\r\n    strategy.entry(\"BUY\", strategy.long, qty=buyAmount/close, comment=\"BUY \" + buyTier)\r\n    label.new(bar_index, riskMetric, \"BUY \" + buyTier + \"\\n$\" + str.tostring(buyAmount), \r\n         style=label.style_label_up, color=color.green, textcolor=color.white, size=size.small)\r\n    \r\n    // Reset sell levels when new buy occurs\r\n    sellL1_done := false\r\n    sellL2_done := false\r\n    sellL3_done := false\r\n\r\n    // Send 3Commas buy alert\r\n    if use_3commas\r\n        buyJson = '{\"secret\":\"' + secret_token + '\",\"max_lag\":\"300\",\"timestamp\":\"' + str.tostring(timenow) + '\",\"trigger_price\":\"' + str.tostring(close) + '\",\"tv_exchange\":\"' + exchange + '\",\"tv_instrument\":\"' + CRYPTO_USD_TICKER + '\",\"action\":\"enter_long\",\"bot_uuid\":\"' + bot_uuid + '\",\"order\":{\"amount\":\"' + str.tostring(buyAmount) + '\",\"currency_type\":\"quote\",\"order_type\":\"market\"}}'\r\n        alert(buyJson, alert.freq_once_per_bar_close)\r\n    \r\n// === SELL LOGIC ===\r\nsell1Cond = strategy.position_size > 0 and riskMetric >= sellL1_thresh and not sellL1_done\r\nsell2Cond = strategy.position_size > 0 and riskMetric >= sellL2_thresh and sellL1_done and not sellL2_done\r\nsell3Cond = strategy.position_size > 0 and riskMetric >= sellL3_thresh and sellL2_done and not sellL3_done\r\n\r\nif sell1Cond\r\n    strategy.close(\"BUY\", qty_percent=sellL1_pct, comment=\"SELL L1\")\r\n    label.new(bar_index, riskMetric, \"SELL L1\\n\" + str.tostring(sellL1_pct) + \"%\", \r\n         style=label.style_label_down, color=color.orange, textcolor=color.white, size=size.small)\r\n    sellL1_done := true\r\n    \r\n    if use_3commas\r\n        sellJson = '{\"secret\":\"' + secret_token + '\",\"max_lag\":\"300\",\"timestamp\":\"' + str.tostring(timenow) + '\",\"trigger_price\":\"' + str.tostring(close) + '\",\"tv_exchange\":\"' + exchange + '\",\"tv_instrument\":\"' + CRYPTO_USD_TICKER + '\",\"action\":\"exit_long\",\"bot_uuid\":\"' + bot_uuid + '\",\"order\":{\"amount\":\"' + str.tostring(sellL1_pct) + '\",\"currency_type\":\"position_percent\",\"order_type\":\"market\"}}'\r\n        alert(sellJson, alert.freq_once_per_bar_close)\r\n\r\nif sell2Cond\r\n    strategy.close(\"BUY\", qty_percent=sellL2_pct, comment=\"SELL L2\")\r\n    label.new(bar_index, riskMetric, \"SELL L2\\n\" + str.tostring(sellL2_pct) + \"%\", \r\n         style=label.style_label_down, color=color.red, textcolor=color.white, size=size.small)\r\n    sellL2_done := true\r\n    \r\n    if use_3commas\r\n        sellJson = '{\"secret\":\"' + secret_token + '\",\"max_lag\":\"300\",\"timestamp\":\"' + str.tostring(timenow) + '\",\"trigger_price\":\"' + str.tostring(close) + '\",\"tv_exchange\":\"' + exchange + '\",\"tv_instrument\":\"' + CRYPTO_USD_TICKER + '\",\"action\":\"exit_long\",\"bot_uuid\":\"' + bot_uuid + '\",\"order\":{\"amount\":\"' + str.tostring(sellL2_pct) + '\",\"currency_type\":\"position_percent\",\"order_type\":\"market\"}}'\r\n        alert(sellJson, alert.freq_once_per_bar_close)\r\n\r\nif sell3Cond\r\n    strategy.close(\"BUY\", qty_percent=sellL3_pct, comment=\"SELL L3\")\r\n    label.new(bar_index, riskMetric, \"SELL L3\\n\" + str.tostring(sellL3_pct) + \"%\", \r\n         style=label.style_label_down, color=color.maroon, textcolor=color.white, size=size.small)\r\n    sellL3_done := true\r\n    \r\n    if use_3commas\r\n        sellJson = '{\"secret\":\"' + secret_token + '\",\"max_lag\":\"300\",\"timestamp\":\"' + str.tostring(timenow) + '\",\"trigger_price\":\"' + str.tostring(close) + '\",\"tv_exchange\":\"' + exchange + '\",\"tv_instrument\":\"' + CRYPTO_USD_TICKER + '\",\"action\":\"exit_long\",\"bot_uuid\":\"' + bot_uuid + '\",\"order\":{\"amount\":\"' + str.tostring(sellL3_pct) + '\",\"currency_type\":\"position_percent\",\"order_type\":\"market\"}}'\r\n        alert(sellJson, alert.freq_once_per_bar_close)\r\n\r\n// === COLOR-CODED PLOTTING ===\r\nriskColor = (riskMetric <= buyL3_thresh ? color.green :\r\n             riskMetric <= buyL2_thresh ? color.lime :\r\n             riskMetric <= buyL1_thresh ? color.yellow :\r\n             riskMetric <= sellL1_thresh ? color.orange :\r\n             riskMetric <= sellL2_thresh ? color.red :\r\n             color.maroon)\r\n\r\nplot(riskMetric, title=\"Risk Metric\", color=riskColor, linewidth=2)\r\n\r\n// === HORIZONTAL THRESHOLDS ===\r\nhline(buyL3_thresh, \"Buy L3\", color=color.green, linewidth=2)\r\nhline(buyL2_thresh, \"Buy L2\", color=color.lime)\r\nhline(buyL1_thresh, \"Buy L1\", color=color.yellow, linestyle=hline.style_dashed)\r\nhline(sellL1_thresh, \"Sell L1\", color=color.orange, linestyle=hline.style_dashed)\r\nhline(sellL2_thresh, \"Sell L2\", color=color.red)\r\nhline(sellL3_thresh, \"Sell L3\", color=color.maroon, linewidth=2)"
  },
  {
    "url": "rGv72PnR-BTC-DCA-Risk-Metric-Strategy",
    "name": "BTC DCA Risk Metric Strategy",
    "description": "BTC DCA Risk Strategy - Automated Dollar Cost Averaging with 3Commas Integration\nOverview\nThis strategy combines the proven Oakley Wood Risk Metric with an intelligent tiered Dollar Cost Averaging (DCA) system, designed to help traders systematically accumulate Bitcoin during periods of low risk and take profits during high-risk conditions.\nKey Features\nðŸ“Š Multi-Component Risk Assessment\n\n4-Year SMA Deviation: Measures Bitcoin's distance from its long-term mean\n20-Week MA Analysis: Tracks medium-term momentum shifts\n50-Day/50-Week MA Ratio: Captures short-to-medium term trend strength\nAll metrics are normalized by time to account for Bitcoin's maturing market dynamics\n\nðŸ’° 3-Tier DCA Buy System\n\nLevel 1 (Low Risk): Conservative entry with base allocation\nLevel 2 (Lower Risk): Increased allocation as opportunity improves\nLevel 3 (Extreme Low Risk): Maximum allocation during rare buying opportunities\nBuys execute every bar while risk remains below thresholds, enabling true DCA accumulation\n\nðŸ“ˆ Progressive Profit Taking\n\nSell Level 1: Take initial profits as risk increases\nSell Level 2: Scale out further positions during elevated risk\nSell Level 3: Final exit during extreme market conditions\nSell levels automatically reset when new buy signals occur, allowing flexible re-entry\n\nðŸ¤– 3Commas Integration\n\nFully automated webhook alerts for Custom Signal Bots\nJSON payloads formatted per 3Commas API specifications\nSupports multiple exchanges (Binance, Coinbase, Kraken, Gemini, Bybit)\nConfigurable quote currency (USD, USDT, BUSD)\n\nHow It Works\nThe strategy calculates a composite risk metric (0-1 scale):\n\n0.0-0.2: Extreme buying opportunity (green zone)\n0.2-0.5: Favorable accumulation range (yellow zone)\n0.5-0.8: Neutral to cautious territory (orange zone)\n0.8-1.0+: High risk, profit-taking zone (red zone)\n\nBuy Logic: As risk decreases, position sizes increase automatically. If risk drops from L1 to L3 threshold, the strategy combines all three tier allocations for maximum exposure.\nSell Logic: Sequential profit-taking ensures you capture gains progressively. The system won't advance to Sell L2 until L1 completes, preventing premature full exits.\nConfiguration\nRisk Metric Parameters:\n\nAll calculations use Bitcoin price data (any BTC chart works)\nTime-normalized formulas adapt to market maturity\nNo manual parameter tuning required\n\nBuy Settings:\n\nSet risk thresholds for each tier (default: 0.20, 0.10, 0.00)\nDefine dollar amounts per tier (default: $10, $15, $20)\nFully customizable to your risk tolerance and capital\n\nSell Settings:\n\nConfigure risk thresholds for profit-taking (default: 1.00, 1.50, 2.00)\nSet percentage of position to sell at each level (default: 25%, 35%, 40%)\n\n3Commas Setup:\n\nCreate a Custom Signal Bot in 3Commas\nCopy Bot UUID and Secret Token into strategy inputs\nEnable 3Commas Alerts checkbox\nCreate TradingView alert: Condition â†’ \"alert() function calls only\", Webhook â†’ api.3commas.io\n\nBacktesting Results\nStrengths:\n\nSystematically buys dips without emotion\nAverages down during extended bear markets\nCaptures explosive bull run profits through tiered exits\nPyramiding (1000 max orders) allows true DCA behavior\n\nConsiderations:\n\nRequires sufficient capital for multiple buys during prolonged downtrends\nBacktest on Daily timeframe for most reliable signals\nPast performance does not guarantee future results\n\nVisual Design\nThe indicator pane displays:\n\nColor-coded risk metric line: Changes from whiteâ†’redâ†’orangeâ†’yellowâ†’green as risk decreases\nBackground zones: Green (buy), yellow (hold), red (sell) areas\nDashed threshold lines: Clear visual markers for each buy/sell level\nEntry/Exit labels: Green buy labels and orange/red sell labels mark all trades\n\nCredits\nOriginal Risk Metric: Oakley Wood\nStrategy Development & 3Commas Integration: Claude AI (Anthropic)\nModifications: pommesUNDwurst\nDisclaimer\nThis strategy is for educational and informational purposes only. Cryptocurrency trading carries substantial risk of loss. Always conduct your own research and never invest more than you can afford to lose. The authors are not financial advisors and assume no responsibility for trading decisions made using this tool.",
    "image_url": "rGv72PnR",
    "author": "nakphanan",
    "likes_count": 14,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-10",
    "updated": "2025-12-10",
    "source": "//@version=5\r\n// Risk Metric by Oakley Wood (modified by pommesUNDwurst)\r\n// DCA Strategy implementation with 3Commas integration\r\nstrategy(\"BTC DCA Risk Strategy\", \r\n     overlay=false, \r\n     initial_capital=10000, \r\n     default_qty_type=strategy.cash, \r\n     commission_type=strategy.commission.percent, \r\n     commission_value=0.1,\r\n     pyramiding=1000,\r\n     calc_on_order_fills=false,\r\n     calc_on_every_tick=false,\r\n     process_orders_on_close=true)\r\n\r\n// === EXCHANGE SELECTION ===\r\nexchange = input.string(\"KRAKEN\", \"Exchange\", options=[\"BINANCE\", \"COINBASE\", \"KRAKEN\", \"GEMINI\", \"BYBIT\"])\r\nquoteSymbol = input.string(\"USD\", \"Quote Currency\", options=[\"USD\", \"USDT\", \"BUSD\"])\r\n\r\n// Build tickers\r\nBTC_TICKER = syminfo.tickerid\r\nBTC_TRADE_TICKER = \"BTC\" + quoteSymbol\r\n\r\n// === 3COMMAS CREDENTIALS ===\r\nbot_uuid = input.string(\"\", \"3Commas Bot UUID\", group=\"3Commas\")\r\nsecret_token = input.string(\"\", \"3Commas Secret Token\", group=\"3Commas\")\r\nuse_3commas = input.bool(false, \"Enable 3Commas Alerts\", group=\"3Commas\")\r\n\r\n// === BUY THRESHOLDS & AMOUNTS ===\r\nbuyL1_thresh = input.float(0.20, \"Buy L1 Threshold\", group=\"Buy Settings\", tooltip=\"Risk metric threshold for first buy tier\")\r\nbuyL2_thresh = input.float(0.10, \"Buy L2 Threshold\", group=\"Buy Settings\")\r\nbuyL3_thresh = input.float(0.00, \"Buy L3 Threshold\", group=\"Buy Settings\")\r\nbuyL1_amt = input.float(10.0, \"Buy L1 $ Amount\", group=\"Buy Settings\")\r\nbuyL2_amt = input.float(15.0, \"Buy L2 $ Amount\", group=\"Buy Settings\")\r\nbuyL3_amt = input.float(20.0, \"Buy L3 $ Amount\", group=\"Buy Settings\")\r\n\r\n// === SELL THRESHOLDS & PERCENTAGES ===\r\nsellL1_thresh = input.float(1.00, \"Sell L1 Threshold\", group=\"Sell Settings\")\r\nsellL2_thresh = input.float(1.50, \"Sell L2 Threshold\", group=\"Sell Settings\")\r\nsellL3_thresh = input.float(2.00, \"Sell L3 Threshold\", group=\"Sell Settings\")\r\nsellL1_pct = input.float(25.0, \"Sell L1 %\", group=\"Sell Settings\")\r\nsellL2_pct = input.float(35.0, \"Sell L2 %\", group=\"Sell Settings\")\r\nsellL3_pct = input.float(40.0, \"Sell L3 %\", group=\"Sell Settings\")\r\n\r\n// === RISK METRIC CALCULATION (Oakley Wood) ===\r\n\r\n// METRIC 1: (BTC - 4 year SMA) / StdDev, normalized by time\r\nd1460_sma = request.security(BTC_TICKER, 'D', ta.sma(close, 1460)) \r\nstdev1 = request.security(BTC_TICKER, 'D', ta.stdev(close, 1460)) \r\nbtc = request.security(BTC_TICKER, 'D', close)\r\nmaxRiskOne = -38.12 * math.log(timenow) + 1078.5\r\nriskOne = ((btc - d1460_sma) / stdev1) / maxRiskOne\r\n\r\n// METRIC 2: ln(BTC / 20 week MA), normalized by time\r\nw20_sma = request.security(BTC_TICKER, \"W\", ta.sma(close, 20))\r\nminRiskTwo = -3.719 * math.log(timenow) + 105\r\nmaxRiskTwo = -6 * math.pow(10, -12) * timenow + 10.93\r\nriskTwo = (math.log(btc / w20_sma) + minRiskTwo) / maxRiskTwo\r\n\r\n// METRIC 3: 50D MA / 50W MA, normalized by time\r\nd50_sma = request.security(BTC_TICKER, 'D', ta.sma(close, 50))\r\nw50_sma = request.security(BTC_TICKER, 'W', ta.sma(close, 50))\r\nmaxRiskThree = -12.55 * math.log(timenow) + 355.15\r\nriskThree = (d50_sma / w50_sma) / maxRiskThree\r\n\r\n// COMPOUND RISK METRIC (0 = extreme buy, 1 = extreme sell)\r\nriskMetric = (nz(riskOne,0) + nz(riskTwo,0) + nz(riskThree,0)) / 3\r\n\r\n// === STATE VARIABLES ===\r\nvar bool sellL1_done = false\r\nvar bool sellL2_done = false\r\nvar bool sellL3_done = false\r\n\r\n// === BUY LOGIC ===\r\nvar float buyAmount = 0.0\r\nbuyTier = \"NONE\"\r\n\r\nif riskMetric <= buyL3_thresh\r\n    buyAmount := buyL1_amt + buyL2_amt + buyL3_amt\r\n    buyTier := \"L3\"\r\nelse if riskMetric <= buyL2_thresh\r\n    buyAmount := buyL1_amt + buyL2_amt\r\n    buyTier := \"L2\"\r\nelse if riskMetric <= buyL1_thresh\r\n    buyAmount := buyL1_amt\r\n    buyTier := \"L1\"\r\nelse\r\n    buyAmount := 0\r\n    buyTier := \"NONE\"\r\n\r\nbuyTrigger = buyAmount > 0\r\n\r\n// === BUY EXECUTION ===\r\nif buyTrigger\r\n    strategy.entry(\"BUY\", strategy.long, qty=buyAmount/close, comment=\"BUY \" + buyTier)\r\n    label.new(bar_index, riskMetric, \"BUY \" + buyTier + \"\\n$\" + str.tostring(buyAmount), \r\n         style=label.style_label_up, color=color.green, textcolor=color.white, size=size.small)\r\n    \r\n    sellL1_done := false\r\n    sellL2_done := false\r\n    sellL3_done := false\r\n    \r\n    if use_3commas\r\n        buyJson = '{\"secret\":\"' + secret_token + '\",\"max_lag\":\"300\",\"timestamp\":\"' + str.tostring(timenow) + '\",\"trigger_price\":\"' + str.tostring(close) + '\",\"tv_exchange\":\"' + exchange + '\",\"tv_instrument\":\"' + BTC_TRADE_TICKER + '\",\"action\":\"enter_long\",\"bot_uuid\":\"' + bot_uuid + '\",\"order\":{\"amount\":\"' + str.tostring(buyAmount) + '\",\"currency_type\":\"quote\",\"order_type\":\"market\"}}'\r\n        alert(buyJson, alert.freq_once_per_bar_close)\r\n\r\n// === SELL LOGIC ===\r\nsell1Cond = strategy.position_size > 0 and riskMetric >= sellL1_thresh and not sellL1_done\r\nsell2Cond = strategy.position_size > 0 and riskMetric >= sellL2_thresh and sellL1_done and not sellL2_done\r\nsell3Cond = strategy.position_size > 0 and riskMetric >= sellL3_thresh and sellL2_done and not sellL3_done\r\n\r\nif sell1Cond\r\n    strategy.close(\"BUY\", qty_percent=sellL1_pct, comment=\"SELL L1\")\r\n    label.new(bar_index, riskMetric, \"SELL L1\\n\" + str.tostring(sellL1_pct) + \"%\", \r\n         style=label.style_label_down, color=color.orange, textcolor=color.white, size=size.small)\r\n    sellL1_done := true\r\n    \r\n    if use_3commas\r\n        sellJson = '{\"secret\":\"' + secret_token + '\",\"max_lag\":\"300\",\"timestamp\":\"' + str.tostring(timenow) + '\",\"trigger_price\":\"' + str.tostring(close) + '\",\"tv_exchange\":\"' + exchange + '\",\"tv_instrument\":\"' + BTC_TRADE_TICKER + '\",\"action\":\"exit_long\",\"bot_uuid\":\"' + bot_uuid + '\",\"order\":{\"amount\":\"' + str.tostring(sellL1_pct) + '\",\"currency_type\":\"position_percent\",\"order_type\":\"market\"}}'\r\n        alert(sellJson, alert.freq_once_per_bar_close)\r\n\r\nif sell2Cond\r\n    strategy.close(\"BUY\", qty_percent=sellL2_pct, comment=\"SELL L2\")\r\n    label.new(bar_index, riskMetric, \"SELL L2\\n\" + str.tostring(sellL2_pct) + \"%\", \r\n         style=label.style_label_down, color=color.red, textcolor=color.white, size=size.small)\r\n    sellL2_done := true\r\n    \r\n    if use_3commas\r\n        sellJson = '{\"secret\":\"' + secret_token + '\",\"max_lag\":\"300\",\"timestamp\":\"' + str.tostring(timenow) + '\",\"trigger_price\":\"' + str.tostring(close) + '\",\"tv_exchange\":\"' + exchange + '\",\"tv_instrument\":\"' + BTC_TRADE_TICKER + '\",\"action\":\"exit_long\",\"bot_uuid\":\"' + bot_uuid + '\",\"order\":{\"amount\":\"' + str.tostring(sellL2_pct) + '\",\"currency_type\":\"position_percent\",\"order_type\":\"market\"}}'\r\n        alert(sellJson, alert.freq_once_per_bar_close)\r\n\r\nif sell3Cond\r\n    strategy.close(\"BUY\", qty_percent=sellL3_pct, comment=\"SELL L3\")\r\n    label.new(bar_index, riskMetric, \"SELL L3\\n\" + str.tostring(sellL3_pct) + \"%\", \r\n         style=label.style_label_down, color=color.maroon, textcolor=color.white, size=size.small)\r\n    sellL3_done := true\r\n    \r\n    if use_3commas\r\n        sellJson = '{\"secret\":\"' + secret_token + '\",\"max_lag\":\"300\",\"timestamp\":\"' + str.tostring(timenow) + '\",\"trigger_price\":\"' + str.tostring(close) + '\",\"tv_exchange\":\"' + exchange + '\",\"tv_instrument\":\"' + BTC_TRADE_TICKER + '\",\"action\":\"exit_long\",\"bot_uuid\":\"' + bot_uuid + '\",\"order\":{\"amount\":\"' + str.tostring(sellL3_pct) + '\",\"currency_type\":\"position_percent\",\"order_type\":\"market\"}}'\r\n        alert(sellJson, alert.freq_once_per_bar_close)\r\n\r\n// === COLOR-CODED PLOTTING (matching original) ===\r\nvar colorway = color.white\r\n\r\nif (riskMetric >= 0.8) \r\n    colorway := color.white\r\nelse if (riskMetric >= 0.65) \r\n    colorway := color.red\r\nelse if (riskMetric >= 0.5) \r\n    colorway := color.orange\r\nelse if (riskMetric >= 0.35) \r\n    colorway := color.yellow\r\nelse if (riskMetric >= 0.2) \r\n    colorway := color.rgb(21, 255, 0) \r\nelse if (riskMetric >= 0.0) \r\n    colorway := color.rgb(255, 255, 255)\r\n\r\nriskMetricPlot = plot(riskMetric, title=\"Risk Metric\", color=colorway, linewidth=1, display=display.all)\r\n\r\n// === HORIZONTAL THRESHOLD PLOTS (hidden by default) ===\r\ni_plot = plot(0.9, color=color.new(color.white, 100), linewidth=1, display=display.none)\r\nh_plot = plot(0.8, color=color.new(color.white, 100), linewidth=1, display=display.none)\r\ng_plot = plot(0.7, color=color.new(color.white, 100), linewidth=1, display=display.none)\r\nf_plot = plot(0.6, color=color.new(color.white, 100), linewidth=1, display=display.none)\r\nneutral_plot = plot(0.5, color=color.new(color.yellow, 100), linewidth=1, display=display.none)\r\nd_plot = plot(0.4, color=color.new(color.white, 100), linewidth=1, display=display.none)\r\nc_plot = plot(0.3, color=color.new(color.white, 100), linewidth=1, display=display.none)\r\nb_plot = plot(0.2, color=color.new(color.green, 100), linewidth=1, display=display.none)\r\na_plot = plot(0.1, color=color.new(color.white, 100), linewidth=1, display=display.none)\r\nsell_plot = plot(0.8, color=color.new(color.red, 100), linewidth=1, display=display.none)\r\nbuy_plot = plot(0.2, color=color.new(color.green, 100), linewidth=1, display=display.none)\r\n\r\n// === BACKGROUND FILLS (matching original) ===\r\nallinColor = riskMetric < 0.1 ? color.new(color.green, 0) : na\r\nbullColor = riskMetric < 0.2 ? color.new(color.green, 60) : na\r\nyellow = riskMetric > 0.2 ? color.new(color.yellow, 50) : na\r\norange = riskMetric < 0.8 ? color.new(color.orange, 50) : na\r\nbearColor = riskMetric > 0.8 ? color.new(color.red, 60) : na\r\nalloutColor = riskMetric > 0.9 ? color.new(color.red, 0) : na\r\n\r\nfill(riskMetricPlot, a_plot, color=allinColor)\r\nfill(riskMetricPlot, buy_plot, color=bullColor)\r\nfill(riskMetricPlot, sell_plot, color=bearColor)\r\nfill(riskMetricPlot, i_plot, color=alloutColor)\r\n\r\n// Custom buy/sell threshold lines (thinnest, dashed, 100% opacity)\r\nplot(buyL1_thresh, \"Buy L1\", color=color.new(color.yellow, 0), linewidth=1, style=plot.style_linebr)\r\nplot(buyL2_thresh, \"Buy L2\", color=color.new(color.lime, 0), linewidth=1, style=plot.style_linebr)\r\nplot(buyL3_thresh, \"Buy L3\", color=color.new(color.green, 0), linewidth=1, style=plot.style_linebr)\r\nplot(sellL1_thresh, \"Sell L1\", color=color.new(color.orange, 0), linewidth=1, style=plot.style_linebr)\r\nplot(sellL2_thresh, \"Sell L2\", color=color.new(color.red, 0), linewidth=1, style=plot.style_linebr)\r\nplot(sellL3_thresh, \"Sell L3\", color=color.new(color.maroon, 0), linewidth=1, style=plot.style_linebr)"
  },
  {
    "url": "r06oBNid",
    "name": "Estrategia Infalible Futuros Supertrend+RSI+EMAS+VWAP (30m) ",
    "description": "Estrategia para futuros especialmente enfocada en MBT",
    "image_url": "r06oBNid",
    "author": "jaimezura",
    "likes_count": 23,
    "comments_count": 3,
    "script_type": "strategy",
    "created": "2025-12-10",
    "updated": "2025-12-10",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\r\n// Â© jaimezura\r\n//2025-09-05 07:18\r\n//@version=5\r\nstrategy(\"VWAP+RSI+Supertrend+ADX - FINAL 50% TARGET (v2.0)\", overlay=true,\r\n     initial_capital = 100000,\r\n     default_qty_type = strategy.percent_of_equity,\r\n     pyramiding = 2,\r\n     commission_value = 0)\r\n\r\n// ... (INPUTS, INDICADORES, FILTROS Y CONDICIONES se mantienen iguales) ...\r\n// AsegÃºrate de copiar todo el bloque de INPUTS, INDICADORES (con ADX manual) y FILTROS/CONDICIONES del cÃ³digo anterior.\r\n\r\n// =========================\r\n// ------ INDICADORES (Bloque completo con ADX manual) -------\r\n// =========================\r\n\r\n// Detectar tipos de sÃ­mbolos\r\nsymbol = syminfo.ticker\r\n\r\nis_mbt   = symbol == \"MBT1!\"\r\nis_sil   = symbol == \"SIL1!\"\r\nis_gol   = symbol == \"MGC1!\"\r\nis_mnq   = symbol == \"MNQ1!\"\r\nis_mes   = symbol == \"MES1!\"\r\nis_6e    = symbol == \"6E1!\"\r\nis_6a    = symbol == \"6A1!\"\r\nis_6b    = symbol == \"6B1!\"\r\nis_mng   = symbol == \"MNG1!\"\r\nis_m2k   = symbol == \"M2K1!\"\r\n\r\nint rsiEntry=if is_mbt\r\n    input.int(53, \"RSI entry threshold (Giro)\")\r\nelse if is_sil\r\n    input.int(55, \"RSI entry threshold (Giro)\")\r\nelse if is_sil\r\n    input.int(55, \"RSI entry threshold (Giro)\") \r\nelse if is_gol\r\n    input.int(55, \"RSI entry threshold (Giro)\")\r\nelse if is_mnq\r\n    input.int(55, \"RSI entry threshold (Giro)\")\r\nelse if is_mes\r\n    input.int(55, \"RSI entry threshold (Giro)\")\r\nelse if is_6e\r\n    input.int(55, \"RSI entry threshold (Giro)\")\r\nelse if is_6a\r\n    input.int(55, \"RSI entry threshold (Giro)\")\r\nelse if is_6b\r\n    input.int(55, \"RSI entry threshold (Giro)\")\r\nelse if is_mng\r\n    input.int(58, \"RSI entry threshold (Giro)\")\r\nelse if is_m2k\r\n    input.int(55, \"RSI entry threshold (Giro)\")\r\nelse\r\n    input.int(55, \"RSI entry threshold (Giro)\")\r\n\r\nfloat stFactor=if is_mbt\r\n    input.float(1.2, \"Supertrend Factor (OPTIMIZADO: MÃ¡s lento para Cortos)\")\r\nelse if is_sil\r\n    input.float(1.2, \"Supertrend Factor (OPTIMIZADO: MÃ¡s lento para Cortos)\")\r\nelse if is_sil\r\n    input.float(1.2, \"Supertrend Factor (OPTIMIZADO: MÃ¡s lento para Cortos)\")\r\nelse if is_gol\r\n    input.float(1.2, \"Supertrend Factor (OPTIMIZADO: MÃ¡s lento para Cortos)\")\r\nelse if is_mnq\r\n    input.float(1.2, \"Supertrend Factor (OPTIMIZADO: MÃ¡s lento para Cortos)\")\r\nelse if is_mes\r\n    input.float(1.2, \"Supertrend Factor (OPTIMIZADO: MÃ¡s lento para Cortos)\")\r\nelse if is_6e\r\n    input.float(1.2, \"Supertrend Factor (OPTIMIZADO: MÃ¡s lento para Cortos)\")\r\nelse if is_6a\r\n    input.float(1.2, \"Supertrend Factor (OPTIMIZADO: MÃ¡s lento para Cortos)\")\r\nelse if is_6b\r\n    input.float(1.2, \"Supertrend Factor (OPTIMIZADO: MÃ¡s lento para Cortos)\")\r\nelse if is_mng\r\n    input.float(1.2, \"Supertrend Factor (OPTIMIZADO: MÃ¡s lento para Cortos)\")\r\nelse if is_m2k\r\n    input.float(1.2, \"Supertrend Factor (OPTIMIZADO: MÃ¡s lento para Cortos)\")\r\nelse\r\n    input.float(1.2, \"Supertrend Factor (OPTIMIZADO: MÃ¡s lento para Cortos)\")\r\n\r\natrPeriod = input.int(8, \"ATR Period\")\r\n//stFactor = input.float(1.2, \"Supertrend Factor (OPTIMIZADO: MÃ¡s lento para Cortos)\") // AJUSTE CLAVE\r\nrsiPeriod = input.int(14, \"RSI Period\")\r\nemaLen = input.int(9, \"EMA 9 length\")\r\nemaLenLong = input.int(18, \"EMA 18 length\")\r\nadxPeriod = input.int(10, \"ADX Period\")\r\n//int rsiEntry = input.int(53, \"RSI entry threshold (Giro)\")\r\nadxThreshold = input.float(19.89, \"ADX Min. Strength Threshold\")\r\nmaxVWAPDist = input.float(1.72, \"MÃ¡x. Dist. VWAP (%)\")\r\nminBarRange = input.float(0.141, \"MÃ­n. Bar Range (%)\")\r\nsessionStart = input.string(\"0000-2359\", \"Trading Session (02:00-22:00 UTC)\")\r\n\r\n// --- Variables y Filtros ---\r\ninSession = time(timeframe.period, sessionStart)\r\nvwapLine = ta.vwap\r\nrsi = ta.rsi(close, rsiPeriod)\r\n[stVal, stDir] = ta.supertrend(stFactor, atrPeriod)\r\natr = ta.atr(atrPeriod)\r\nemaFast = ta.ema(close, emaLen)\r\nemaLong = ta.ema(close, emaLenLong)\r\n\r\n// CÃLCULO MANUAL DEL ADX\r\nup = high - high[1]\r\ndown = low[1] - low\r\nplusDM = (up > down and up > 0) ? up : 0\r\nminusDM = (down > up and down > 0) ? down : 0\r\nplusDI = 109* ta.ema(plusDM, adxPeriod) / ta.ema(atr, adxPeriod)\r\nminusDI = 100 * ta.ema(minusDM, adxPeriod) / ta.ema(atr, adxPeriod)\r\nadxValue = ta.ema(math.abs(plusDI - minusDI) / (plusDI + minusDI == 0 ? 1 : plusDI + minusDI) * 100, adxPeriod)\r\n\r\n// CONDICIONES (Asumidas correctas)\r\ndistPerc = math.abs(close - vwapLine) / vwapLine * 100\r\ndistOK = distPerc <= maxVWAPDist \r\nbarRangePerc = (high - low) / close * 100\r\nrangeOK = barRangePerc >= minBarRange\r\natrRel = atr / close * 100\r\nminAtrRel = 0.05\r\nvolOK = atrRel >= minAtrRel\r\nrsiTurnUp = rsi[1] <= rsiEntry and rsi > rsiEntry \r\nrsiTurnDown = rsi[1] >= (100 - rsiEntry) and rsi < (100 - rsiEntry) \r\n\r\nlongCond = inSession and distOK and rangeOK and volOK and (adxValue > adxThreshold) and (close > vwapLine) and (stDir < 0) and rsiTurnUp and (close > emaFast) and (close > emaLong)\r\nshortCond = inSession and distOK and rangeOK and volOK and (adxValue > adxThreshold) and (close < vwapLine) and (stDir > 0) and rsiTurnDown and (close < emaFast) and (close < emaLong)\r\n\r\n\r\n// =========================\r\n// ----- GESTIÃ“N DE RIESGO DE DOS TIEMPOS (OPTIMIZADA) -------\r\n// =========================\r\n\r\nrisk_unit = atr * 0.97 // Stop Loss de 1.0x ATR (Riesgo base)\r\ntp1_mult = 1.6 // OPTIMIZADO: TP1 a 1.2x ATR (Salida RÃ¡pida para mÃ¡xima tasa de acierto)\r\ntp2_mult = 2.5 // OPTIMIZADO: TP2 a 2.5x ATR (Objetivo realista)\r\ntrail_points_mult = 0.1 // OPTIMIZADO: Trailing Stop muy ajustado\r\n\r\n// --- CÃLCULO de Precios ---\r\nlongSL = close - risk_unit\r\nlongTP1 = close + (atr * tp1_mult)*6\r\nlongTP2 = close + (atr * tp2_mult)*6\r\n\r\nshortSL = close + risk_unit\r\nshortTP1 = close - atr * tp1_mult*6\r\nshortTP2 = close - atr * tp2_mult*6\r\n\r\n// =========================\r\n// ----- ENTRADAS Y SALIDAS -------\r\n// =========================\r\nif (is_mbt)\r\n    if longCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"L1\", strategy.long, qty=10, stop=longSL)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"L2\", strategy.long, qty=10, stop=longSL)\r\n\r\n    if shortCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"S1\", strategy.short, qty=10, stop=shortSL)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"S2\", strategy.short, qty=10, stop=shortSL)\r\nif (is_gol)\r\n    if longCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"L12\", strategy.long, qty=10, stop=longSL)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"L2\", strategy.long, qty=10, stop=longSL)\r\n\r\n    if shortCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"S1\", strategy.short, qty=10, stop=shortSL*0.99)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"S2\", strategy.short, qty=10, stop=shortSL*0.99)\r\nif (is_sil)\r\n    if longCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"L12\", strategy.long, qty=10, stop=longSL)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"L2\", strategy.long, qty=10, stop=longSL)\r\n\r\n    if shortCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"S1\", strategy.short, qty=10, stop=shortSL*0.912)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"S2\", strategy.short, qty=10, stop=shortSL*0.9749)\r\nif (is_mnq)\r\n    if longCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"L12\", strategy.long, qty=5, stop=longSL)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"L2\", strategy.long, qty=5, stop=longSL)\r\n\r\n    if shortCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"S1\", strategy.short, qty=5, stop=shortSL*0.989)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"S2\", strategy.short, qty=5, stop=shortSL*0.989)\r\nif (is_mes)\r\n    if longCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"L12\", strategy.long, qty=5, stop=longSL)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"L2\", strategy.long, qty=5, stop=longSL)\r\n\r\n    if shortCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"S1\", strategy.short, qty=5, stop=shortSL*0.909)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"S2\", strategy.short, qty=5, stop=shortSL*0.909)\r\nif (is_6e)\r\n    if longCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"L12\", strategy.long, qty=5, stop=longSL)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"L2\", strategy.long, qty=5, stop=longSL)\r\n\r\n    if shortCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"S1\", strategy.short, qty=5, stop=shortSL*0.99)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"S2\", strategy.short, qty=5, stop=shortSL*0.99)\r\nif (is_6a)\r\n    if longCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"L12\", strategy.long, qty=5, stop=longSL*1.0009)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"L2\", strategy.long, qty=5, stop=longSL*1.0009)\r\n\r\n    if shortCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"S1\", strategy.short, qty=5, stop=shortSL*1)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"S2\", strategy.short, qty=5, stop=shortSL*1)\r\nif (is_6b)\r\n    if longCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"L12\", strategy.long, qty=5, stop=longSL*1)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"L2\", strategy.long, qty=5, stop=longSL*1)\r\n\r\n    if shortCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"S1\", strategy.short, qty=5, stop=shortSL*1)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"S2\", strategy.short, qty=5, stop=shortSL*1)\r\nif (is_mng)\r\n    if longCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"L12\", strategy.long, qty=20, stop=longSL*1)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"L2\", strategy.long, qty=20, stop=longSL*1)\r\n\r\n    if shortCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"S1\", strategy.short, qty=50, stop=shortSL*0.88)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"S2\", strategy.short, qty=50, stop=shortSL*1)\r\nif (is_m2k)\r\n    if longCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"L12\", strategy.long, qty=5, stop=longSL*1)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"L2\", strategy.long, qty=5, stop=longSL*1)\r\n\r\n    if shortCond\r\n        // Entrada 1 (para TP1) - Asigna 50% del riesgo total\r\n        strategy.entry(\"S1\", strategy.short, qty=5, stop=shortSL*0.982)\r\n        // Entrada 2 (para TP2) - Asigna 50% del riesgo restante\r\n        strategy.entry(\"S2\", strategy.short, qty=5, stop=shortSL*0.982)\r\n        \r\n// Entrada: Tomamos una posiciÃ³n completa con dos Ã³rdenes separadas\r\n\r\n// 1. GESTIÃ“N DE SALIDA RÃPIDA (TP1)\r\n// Cierra la mitad de la posiciÃ³n a 1.2x ATR (Asegura R:B > 1)\r\nstrategy.exit(\"TP1 Long\", from_entry=\"L1\", limit=longTP1, stop=longSL)\r\nstrategy.exit(\"TP1 Short\", from_entry=\"S1\", limit=shortTP1, stop=shortSL)\r\n\r\n\r\n// 2. GESTIÃ“N DE LA SEGUNDA PARTE (TP2, alto objetivo + Trailing Stop)\r\n// Esta orden gestiona el 50% restante con Trailing Stop ajustado.\r\nstrategy.exit(\"TP2/Trail Long\", from_entry=\"L2\", limit=longTP2, stop=longSL, trail_points=atr * trail_points_mult)\r\nstrategy.exit(\"TP2/Trail Short\", from_entry=\"S2\", limit=shortTP2, stop=shortSL, trail_points=atr * trail_points_mult)\r\n\r\n\r\n// 3. BREAK EVEN (ProtecciÃ³n de TP2 despuÃ©s de alcanzar TP1)\r\n// Usamos el estado de la posiciÃ³n reducida para saber si TP1 fue tocado.\r\nlongPosOpen = strategy.position_size > 0\r\nshortPosOpen = strategy.position_size < 0\r\n\r\n// Si la posiciÃ³n se redujo (TP1 tocado) y aÃºn hay posiciÃ³n abierta...\r\nif longPosOpen and strategy.position_size[1] > strategy.position_size \r\n    // Mover el SL de L2 (o lo que quede) al punto de entrada + buffer (0.10 ATR)\r\n    strategy.exit(\"BE L2\", from_entry=\"L2\", stop=strategy.position_avg_price + atr * 0.10)\r\n\r\nif shortPosOpen and strategy.position_size[1] < strategy.position_size\r\n    // Mover el SL de S2 (o lo que quede) al punto de entrada - buffer\r\n    strategy.exit(\"BE S2\", from_entry=\"S2\", stop=strategy.position_avg_price - atr * 0.10)\r\n\r\n\r\n// 4. Salida por cambio de Supertrend (Cierra todo lo que quede)\r\nif longPosOpen and stDir > 0\r\n    strategy.close_all(comment=\"ST Trend Rev\")\r\nif shortPosOpen and stDir < 0\r\n    strategy.close_all(comment=\"ST Trend Rev\")\r\n\r\n// ... (PLOTS & INFO se mantienen iguales) ...\r\n// =========================\r\n// ----- PLOTS & INFO -------\r\n// =========================\r\n//plot(vwapLine, title=\"VWAP\", color=color.blue, linewidth=2)\r\nstColor = stDir < 0 ? color.lime : color.red\r\nplot(stVal, title=\"Supertrend\", color = stColor, linewidth=2)\r\nplot(emaLen ? emaFast : na, title=\"EMA Trend Filter (20)\", color=color.orange, linewidth=1)\r\nplot(emaLenLong ? emaLong : na, title=\"EMA Trend Filter (200)\", color=color.white, linewidth=2)\r\n//plotshape(longCond, title=\"LongSignal\", style=shape.triangleup, location=location.belowbar, color=color.green, size=size.small)\r\n//plotshape(shortCond, title=\"ShortSignal\", style=shape.triangledown, location=location.abovebar, color=color.red, size=size.small)\r\n"
  },
  {
    "url": "yq0cDVGO-Hash-Ratings-Engine",
    "name": "Hash Ratings Engine",
    "description": "Hash Ratings Engine - Technical Consensus Strategy \nA systematic trading strategy that harnesses TradingView's Technical Ratings to generate high-conviction entries with institutional-grade risk management.\n\n What It Does \nThis strategy aggregates the consensus of 26+ technical indicators (RSI, MACD, Stochastics, multiple Moving Averages, etc.) into a single actionable signal. When enough indicators align bullish or bearish, the engine triggers an entry. Built-in trend filtering and ATR-based exits keep you on the right side of the market.\n\n Key Features \n Trend Filter  - Only takes longs in uptrends, shorts in downtrends. This single filter typically improves results by 20-40% by avoiding counter-trend trades.\n ATR-Based Risk Management  - Stop loss and trailing stops adapt to current market volatility. Tight stops in calm markets, wider stops in volatile conditions.\n Cooldown System  - After a losing trade, the strategy waits before re-entering. This prevents the consecutive loss streaks that destroy accounts.\n Clean Visuals  - Fluorescent entry/exit signals with price level references. See exactly where you got in and out.\n\n Settings Guide \n Indicator Timeframe:  Leave blank for current chart. Use higher timeframe for fewer, higher-quality signals.\n Rating Source:  \"All\" for balanced approach. \"MAs\" for trend-following. \"Oscillators\" for mean-reversion.\n\n Entry Thresholds \n Strong Signal Threshold:  Higher = fewer trades but better conviction. Start at 0.5, test 0.4-0.6.\n\n Risk Management \n ATR Period:  12 is responsive, 14 is standard, 20+ is smoother.\n Stop Loss:  2-3x ATR for tight stops, 3.5-4x for moderate, 5x+ for wide.\n Trail Activation:  How far price must move in profit before trailing begins.\n Trail Offset:  How closely the trail follows price.\n \nTrend Filter \n EMA Length:  150 works well on 4H charts. Use 100 for lower timeframes, 200 for daily.\n\n Trade Timing \n Cooldown:  Keep enabled. 5 bars is a good starting point.\n\n Best Practices \nStart with default settings and backtest on your preferred instrument. Adjust the Strong Signal Threshold first - this has the biggest impact on trade frequency. Then tune the EMA length to match your timeframe. Finally, optimize the ATR multipliers for your risk tolerance.\nWorks on any liquid market - crypto, forex, stocks, futures. Higher timeframes (4H, Daily) tend to produce cleaner signals than lower timeframes.\n\n Disclaimer \nPast performance does not guarantee future results. Always backtest thoroughly and use proper position sizing. This strategy is for educational purposes - trade at your own risk.\n",
    "image_url": "yq0cDVGO",
    "author": "Hash_Capital",
    "likes_count": 52,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-10",
    "updated": "2025-12-10",
    "source": "//@version=6\r\nstrategy(title=\"Hash Ratings Engine\", shorttitle=\"HRE\", default_qty_type=strategy.percent_of_equity, default_qty_value=5, overlay=true, pyramiding=0, calc_on_every_tick=false, initial_capital=100000, commission_type=strategy.commission.percent, commission_value=0.1)\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•  HASH CAPITAL RESEARCH  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// Hash Ratings Engine - Technical Consensus Strategy\r\n// Optimized for high profit factor, win rate, and reduced drawdown\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n\r\nimport TradingView/TechnicalRating/3 as rating\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// FLUORESCENT COLOR PALETTE\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\nvar color fluorescentGreen  = #00FF41\r\nvar color fluorescentRed    = #FF073A\r\nvar color fluorescentCyan   = #00FFFF\r\nvar color fluorescentCyan50 = color.new(#00FFFF, 50)\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// INPUT GROUPS\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\nstring grp_signal   = \"Signal Settings\"\r\nstring grp_entry    = \"Entry Thresholds\"\r\nstring grp_risk     = \"Risk Management\"\r\nstring grp_trend    = \"Trend Filter\"\r\nstring grp_timing   = \"Trade Timing\"\r\nstring grp_visual   = \"Visuals\"\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// SIGNAL SETTINGS\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\nstring tip_timeframe = \"Timeframe for rating calculation.\\n\\n\" +\r\n     \"TUNING:\\n\" +\r\n     \"â€¢ Blank = current chart timeframe\\n\" +\r\n     \"â€¢ Higher TF (e.g., 'D' on 4H chart) = fewer signals, higher conviction\\n\" +\r\n     \"â€¢ Lower TF = more signals, more noise\\n\\n\" +\r\n     \"RECOMMENDATION: Start with blank, then try 1 step higher if too many signals.\"\r\n\r\nstring tip_source = \"Which indicators to base signals on.\\n\\n\" +\r\n     \"TUNING:\\n\" +\r\n     \"â€¢ MAs = trend-following bias, better in trending markets\\n\" +\r\n     \"â€¢ Oscillators = mean-reversion bias, better in ranging markets\\n\" +\r\n     \"â€¢ All = balanced approach, works in most conditions\\n\\n\" +\r\n     \"RECOMMENDATION: Use 'All' for most cases. Use 'MAs' in strong trends.\"\r\n\r\nres = input.timeframe(\"\", title=\"Indicator Timeframe\", tooltip=tip_timeframe, group=grp_signal)\r\nratingSignal = input.string(defval=\"All\", title=\"Rating Source\", options=[\"MAs\", \"Oscillators\", \"All\"], tooltip=tip_source, group=grp_signal)\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// ENTRY THRESHOLDS\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\nstring tip_strong = \"Minimum rating to trigger entry. Rating ranges from -1 (strong sell) to +1 (strong buy).\\n\\n\" +\r\n     \"TUNING:\\n\" +\r\n     \"â€¢ 0.3 = more signals, lower conviction, higher win count but more losers\\n\" +\r\n     \"â€¢ 0.5 = balanced (default), good starting point\\n\" +\r\n     \"â€¢ 0.7 = fewer signals, higher conviction, better win rate but fewer trades\\n\\n\" +\r\n     \"OPTIMIZATION: Backtest 0.4, 0.5, 0.6 and compare profit factors.\"\r\n\r\nstring tip_weak = \"Secondary threshold for signal strength classification. Used for visual feedback only.\\n\\n\" +\r\n     \"Not currently used for trade logic but available for future enhancements.\"\r\n\r\nstrongBound = input.float(defval=0.5, title=\"Strong Signal Threshold\", minval=0.1, maxval=0.9, step=0.05, tooltip=tip_strong, group=grp_entry)\r\nweakBound   = input.float(defval=0.1, title=\"Weak Signal Threshold\", minval=0.0, maxval=0.5, step=0.05, tooltip=tip_weak, group=grp_entry)\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// RISK MANAGEMENT\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\nstring tip_atr = \"Lookback period for ATR (Average True Range) calculation.\\n\\n\" +\r\n     \"TUNING:\\n\" +\r\n     \"â€¢ 7-10 = more responsive to recent volatility, tighter stops\\n\" +\r\n     \"â€¢ 12 = slightly faster than standard (default)\\n\" +\r\n     \"â€¢ 20-30 = smoother, wider stops, less reactive\\n\\n\" +\r\n     \"RECOMMENDATION: 12-14 works well for most timeframes.\"\r\n\r\nstring tip_sl = \"Stop loss distance as multiple of ATR.\\n\\n\" +\r\n     \"TUNING:\\n\" +\r\n     \"â€¢ 1.5-2.0 = tight stops, more stops hit, smaller losses per trade\\n\" +\r\n     \"â€¢ 2.5-3.5 = moderate (default 3.5), good balance\\n\" +\r\n     \"â€¢ 4.0-5.0 = wide stops, fewer stops hit, larger losses when hit\\n\\n\" +\r\n     \"OPTIMIZATION: Tighter stops improve win rate but may reduce profit factor. Test 2.0, 3.0, 4.0.\"\r\n\r\nstring tip_trail = \"Profit distance before trailing stop activates (ATR multiple).\\n\\n\" +\r\n     \"TUNING:\\n\" +\r\n     \"â€¢ 3.0-4.0 = trail activates quickly, locks profit early, may exit winners too soon\\n\" +\r\n     \"â€¢ 5.0-6.0 = moderate (default 5.5), lets winners develop\\n\" +\r\n     \"â€¢ 7.0-10.0 = patient, lets big winners run, may give back more profit\\n\\n\" +\r\n     \"RECOMMENDATION: Should be larger than SL multiplier.\"\r\n\r\nstring tip_offset = \"How far behind price the trailing stop follows (ATR multiple).\\n\\n\" +\r\n     \"TUNING:\\n\" +\r\n     \"â€¢ 1.0-1.5 = tight trail, locks in more profit, may exit on normal pullbacks\\n\" +\r\n     \"â€¢ 2.0-3.0 = moderate (default 2.0), allows breathing room\\n\" +\r\n     \"â€¢ 3.5-5.0 = loose trail, rides trends longer, gives back more on reversals\\n\\n\" +\r\n     \"RECOMMENDATION: Typically 40-60% of trail activation value.\"\r\n\r\natrPeriod       = input.int(defval=12, title=\"ATR Period\", minval=5, maxval=50, tooltip=tip_atr, group=grp_risk)\r\nslMultiplier    = input.float(defval=3.5, title=\"Stop Loss (ATRÃ—)\", minval=0.5, maxval=10.0, step=0.5, tooltip=tip_sl, group=grp_risk)\r\ntrailMultiplier = input.float(defval=5.5, title=\"Trail Activation (ATRÃ—)\", minval=1.0, maxval=15.0, step=0.5, tooltip=tip_trail, group=grp_risk)\r\ntrailOffset     = input.float(defval=2.0, title=\"Trail Offset (ATRÃ—)\", minval=0.5, maxval=10.0, step=0.5, tooltip=tip_offset, group=grp_risk)\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// TREND FILTER\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\nstring tip_trend_enable = \"Filter trades by trend direction using EMA.\\n\\n\" +\r\n     \"TUNING:\\n\" +\r\n     \"â€¢ ON = only longs above EMA, only shorts below EMA\\n\" +\r\n     \"â€¢ OFF = take signals regardless of trend\\n\\n\" +\r\n     \"RECOMMENDATION: Keep ON. This single filter typically improves profit factor 20-40% by avoiding counter-trend trades.\"\r\n\r\nstring tip_trend_len = \"EMA length for trend determination.\\n\\n\" +\r\n     \"TUNING:\\n\" +\r\n     \"â€¢ 50-100 = shorter-term trend, more responsive, more trades\\n\" +\r\n     \"â€¢ 150 = balanced (default), good for 4H and daily\\n\" +\r\n     \"â€¢ 200-300 = institutional standard, very reliable but slower\\n\\n\" +\r\n     \"OPTIMIZATION: Test 100, 150, 200. Shorter works better on lower TFs.\"\r\n\r\nuseTrendFilter = input.bool(defval=true, title=\"Enable Trend Filter\", tooltip=tip_trend_enable, group=grp_trend)\r\ntrendEmaLength = input.int(defval=150, title=\"Trend EMA Length\", minval=20, maxval=500, step=10, tooltip=tip_trend_len, group=grp_trend)\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// TRADE TIMING\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\nstring tip_time_enable = \"Restrict trading to specific hours.\\n\\n\" +\r\n     \"TUNING:\\n\" +\r\n     \"â€¢ ON = only trade during specified hours (exchange time)\\n\" +\r\n     \"â€¢ OFF = trade 24/7\\n\\n\" +\r\n     \"USE CASE: Avoid Asian session on US equities, or avoid weekends on crypto.\"\r\n\r\nstring tip_cooldown_enable = \"Wait period after a losing trade before new entries.\\n\\n\" +\r\n     \"TUNING:\\n\" +\r\n     \"â€¢ ON = prevents rapid re-entry after stops, reduces consecutive losses\\n\" +\r\n     \"â€¢ OFF = can re-enter immediately\\n\\n\" +\r\n     \"RECOMMENDATION: Keep ON. Prevents the 'revenge trading' pattern where you get stopped, re-enter immediately, and get stopped again.\"\r\n\r\nstring tip_cooldown_bars = \"Number of bars to wait after a stop loss.\\n\\n\" +\r\n     \"TUNING:\\n\" +\r\n     \"â€¢ 3-5 = short cooldown, quick recovery\\n\" +\r\n     \"â€¢ 5-10 = moderate (default 5), lets dust settle\\n\" +\r\n     \"â€¢ 10-20 = conservative, waits for new setup to develop\\n\\n\" +\r\n     \"Scale with timeframe: use higher values on lower TFs.\"\r\n\r\nuseTimeFilter  = input.bool(defval=false, title=\"Enable Time Filter\", tooltip=tip_time_enable, group=grp_timing)\r\nsessionStart   = input.int(defval=9, title=\"Session Start Hour\", minval=0, maxval=23, group=grp_timing)\r\nsessionEnd     = input.int(defval=16, title=\"Session End Hour\", minval=0, maxval=23, group=grp_timing)\r\n\r\nuseCooldown    = input.bool(defval=true, title=\"Enable Cooldown After Stop\", tooltip=tip_cooldown_enable, group=grp_timing)\r\ncooldownBars   = input.int(defval=5, title=\"Cooldown Bars\", minval=1, maxval=25, tooltip=tip_cooldown_bars, group=grp_timing)\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// VISUAL SETTINGS\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\nshowTrendEma   = input.bool(defval=true, title=\"Show Trend EMA\", group=grp_visual)\r\nshowSignals    = input.bool(defval=true, title=\"Show Entry/Exit Signals\", group=grp_visual)\r\nshowLevels     = input.bool(defval=true, title=\"Show Entry/Exit Levels\", group=grp_visual)\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// CORE CALCULATIONS\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n\r\n// Fetch technical ratings\r\n[ratingTotal, ratingOther, ratingMA] = request.security(syminfo.tickerid, res, rating.calcRatingAll())\r\n\r\n// Select rating source\r\ngetSignal(float total, float oscillators, float mas) =>\r\n    switch ratingSignal\r\n        \"MAs\"         => mas\r\n        \"Oscillators\" => oscillators\r\n        => total\r\n\r\ntradeSignal = getSignal(ratingTotal, ratingOther, ratingMA)\r\n\r\n// Trend filter\r\ntrendEma = ta.ema(close, trendEmaLength)\r\naboveTrend = close > trendEma\r\nbelowTrend = close < trendEma\r\n\r\n// ATR for risk management\r\natrValue = ta.atr(atrPeriod)\r\n\r\n// Convert ATR to points\r\ndynSLpoints(float factor) => \r\n    atrValue * factor / syminfo.mintick\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// TIME FILTER\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\ncurrentHour = hour(time)\r\ninSession = useTimeFilter ? (currentHour >= sessionStart and currentHour < sessionEnd) : true\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// COOLDOWN LOGIC\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\nvar int barsSinceStop = 100\r\nvar int lastTradeCount = 0\r\n\r\nif strategy.closedtrades > lastTradeCount\r\n    lastTradeProfit = strategy.closedtrades.profit(strategy.closedtrades - 1)\r\n    if lastTradeProfit < 0\r\n        barsSinceStop := 0\r\n    lastTradeCount := strategy.closedtrades\r\n\r\nbarsSinceStop := barsSinceStop + 1\r\n\r\ncooldownActive = useCooldown and barsSinceStop <= cooldownBars\r\ncanTrade = not cooldownActive\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// ENTRY CONDITIONS\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n\r\nstrongLongSignal  = tradeSignal > strongBound\r\nstrongShortSignal = tradeSignal < -strongBound\r\n\r\ntrendLongOk  = useTrendFilter ? aboveTrend : true\r\ntrendShortOk = useTrendFilter ? belowTrend : true\r\n\r\nlongCondition  = strongLongSignal and trendLongOk and inSession and canTrade\r\nshortCondition = strongShortSignal and trendShortOk and inSession and canTrade\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// STRATEGY EXECUTION\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n\r\nif longCondition\r\n    strategy.entry(\"Long\", strategy.long)\r\n\r\nif shortCondition\r\n    strategy.entry(\"Short\", strategy.short)\r\n\r\nstrategy.exit(\"Long Exit\", from_entry=\"Long\", loss=dynSLpoints(slMultiplier), trail_points=dynSLpoints(trailMultiplier), trail_offset=dynSLpoints(trailOffset))\r\nstrategy.exit(\"Short Exit\", from_entry=\"Short\", loss=dynSLpoints(slMultiplier), trail_points=dynSLpoints(trailMultiplier), trail_offset=dynSLpoints(trailOffset))\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// POSITION TRACKING FOR VISUALS\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\nisLong  = strategy.position_size > 0\r\nisShort = strategy.position_size < 0\r\nisFlat  = strategy.position_size == 0\r\n\r\n// Entry tracking\r\nvar float entryPrice = na\r\nvar int entryBar = na\r\n\r\nif isLong and not isLong[1]\r\n    entryPrice := close\r\n    entryBar := bar_index\r\nif isShort and not isShort[1]\r\n    entryPrice := close\r\n    entryBar := bar_index\r\nif isFlat and not isFlat[1]\r\n    entryPrice := na\r\n    entryBar := na\r\n\r\n// Exit tracking with matching line length\r\nvar float exitPrice = na\r\nvar int exitBar = na\r\nvar int tradeDuration = na\r\n\r\nif isFlat and not isFlat[1]\r\n    exitPrice := close[1]\r\n    exitBar := bar_index\r\n    tradeDuration := nz(bar_index - entryBar[1], 5)\r\nelse if bar_index > exitBar + nz(tradeDuration, 5)\r\n    exitPrice := na\r\n    exitBar := na\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// VISUAL ELEMENTS\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n\r\n// Trend EMA\r\nplot(showTrendEma ? trendEma : na, title=\"Trend EMA\", color=close > trendEma ? fluorescentGreen : fluorescentRed, linewidth=2)\r\n\r\n// Entry signals\r\nlongEntry  = isLong and not isLong[1]\r\nshortEntry = isShort and not isShort[1]\r\n\r\nplotshape(showSignals and longEntry, title=\"Long Entry\", location=location.belowbar, style=shape.circle, size=size.tiny, color=fluorescentGreen)\r\nplotshape(showSignals and shortEntry, title=\"Short Entry\", location=location.abovebar, style=shape.circle, size=size.tiny, color=fluorescentRed)\r\n\r\n// Exit signals\r\nlongExit  = isFlat and isLong[1]\r\nshortExit = isFlat and isShort[1]\r\n\r\nplotshape(showSignals and longExit, title=\"Long Exit\", location=location.abovebar, style=shape.xcross, size=size.tiny, color=fluorescentCyan)\r\nplotshape(showSignals and shortExit, title=\"Short Exit\", location=location.belowbar, style=shape.xcross, size=size.tiny, color=fluorescentCyan)\r\n\r\n// Entry price line - shows during position\r\nplot(showLevels and (isLong or isShort) ? entryPrice : na, title=\"Entry Price\", color=color.gray, linewidth=1, style=plot.style_linebr)\r\n\r\n// Exit price line - matches trade duration length\r\nplot(showLevels and not na(exitPrice) ? exitPrice : na, title=\"Exit Price\", color=fluorescentCyan50, linewidth=1, style=plot.style_linebr)\r\n\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n// END OF SCRIPT\r\n// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\r\n"
  },
  {
    "url": "ixBY1TYg-MA-Strategy-Dual-Entry-Filter",
    "name": "MA Strategy: Dual Entry Filter",
    "description": "Configurable MA Dual-Filter Strategy\nThis strategy is an enhanced and highly configurable Moving Average (MA) Crossover system designed to mitigate false signals and align trades with the prevailing market trend. It is built to offer traders granular control over entry criteria, elevating it beyond basic, built-in MA crossover indicators.\n\nOriginality & Key Features\nThe script's originality and utility lie in the combination of its two primary, optional filtering mechanics:\n\nDual Entry Mode (Key Filter): Users can choose between two distinct methods for trade entry:\n\nCrossover (Classic): Immediate entry when the price crosses the main MA.\n\nFull Candle Confirmation (Unique Feature): This mode requires the entire candle body (open, high, low, and close) to be completely above or below the main MA after a crossover event to confirm the signal before entry. This strict confirmation helps to filter out weak crossovers, reducing whipsaws in choppy markets.\n\nOptional Trend Filter: A second, slower MA (Trend Filter MA) can be activated. Trades are only permitted when the faster main MA is aligned with the slower Trend MA (i.e., long only if main MA > Trend MA), ensuring trades are executed with the established higher-timeframe direction.\n\nHow to Use the Strategy\nThe strategy logic is built on simple MA principles but utilizes Pine Script's switch function to allow users to select from six different MA types for both the main signal and the trend filter: SMA, EMA, WMA, HMA, VWMA, and RMA.\n\nCore Logic:\n\nSignal: A cross of the price over the Main MA (filtered by the chosen Entry Mode).\n\nDirectional Filter: The Trend Filter must confirm the direction (if enabled).\n\nExit: Trades are exited on the opposite price crossover of the Main MA.\n\nCustomizable Settings Include:\n\nMain MA Type & Length (Default: 40 EMA): The primary signal generator.\n\nTrend Filter MA Type & Length (Default: 70 EMA): The optional, slower trend bias.\n\nEntry Mode: Switch between Crossover or Full Candle Confirmation.\n\nStrategy Results and High-Risk Disclaimer\nThe default setting for trade size is set to 40% of equity for backtesting demonstration purposes only. This high value is used to generate a large and diverse sample size of trades for historical review on the chart.\n\nThis 40% value is NOT a recommended setting for live trading. Per TradingView guidelines, traders are strongly advised to change this input to a sustainable risk level, typically 5% to 10% of equity per trade. Past performance is not a guarantee of future results.",
    "image_url": "ixBY1TYg",
    "author": "ravi_matrix",
    "likes_count": 14,
    "comments_count": 0,
    "script_type": "strategy",
    "created": "2025-12-09",
    "updated": "2025-12-09",
    "source": "// This Pine ScriptÂ® code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n\n// Â© ravi_matrix\n\n\n\n//@version=6\n\nstrategy('MA Strategy: Dual Entry Filter', shorttitle = 'MA Strategy', overlay = true, default_qty_type = strategy.percent_of_equity, default_qty_value = 40)\n\n\n\n// ==================== MAIN SETTINGS ====================\n\nma_type = input.string('EMA', 'Moving Average Type', options = ['SMA', 'EMA', 'WMA', 'HMA', 'VWMA', 'RMA'], group = 'MA Settings')\n\nma_length = input.int(40, 'MA Length', minval = 1, group = 'MA Settings')\n\n\n\n// ==================== TREND FILTER SETTINGS ====================\n\nuse_trend_filter = input.bool(false, 'Use Trend Filter MA', group = 'Trend Filter')\n\ntrend_ma_type = input.string('EMA', 'Trend MA Type', options = ['SMA', 'EMA', 'WMA', 'HMA', 'VWMA', 'RMA'], group = 'Trend Filter')\n\ntrend_ma_length = input.int(70, 'Trend MA Length', minval = 1, group = 'Trend Filter')\n\n\n\n// ==================== ENTRY SETTINGS ====================\n\nentry_mode = input.string('Crossover', 'Entry Mode', options = ['Crossover', 'Full Candle Confirmation'], group = 'Entry Settings')\n\nenable_long = input.bool(true, 'Enable Long Trades', group = 'Entry Settings')\n\nenable_short = input.bool(true, 'Enable Short Trades', group = 'Entry Settings')\n\n\n\n// ==================== MA CALCULATION FUNCTION ====================\n\nget_ma(source, length, ma_type) =>\n\n    switch ma_type\n\n        'SMA' => ta.sma(source, length)\n\n        'EMA' => ta.ema(source, length)\n\n        'WMA' => ta.wma(source, length)\n\n        'HMA' => ta.hma(source, length)\n\n        'VWMA' => ta.vwma(source, length)\n\n        'RMA' => ta.rma(source, length)\n\n        => ta.sma(source, length)\n\n\n\n// ==================== CALCULATE MA ====================\n\nma_value = get_ma(close, ma_length, ma_type)\n\n\n\n// Calculate Trend Filter MA\n\ntrend_ma_value = use_trend_filter ? get_ma(close, trend_ma_length, trend_ma_type) : na\n\n\n\n// Trend direction based on MA relationship\n\ntrend_is_bullish = use_trend_filter ? ma_value > trend_ma_value : true\n\ntrend_is_bearish = use_trend_filter ? ma_value < trend_ma_value : true\n\n\n\n// ==================== CROSSOVER SIGNALS ====================\n\nbullish_cross = ta.crossover(close, ma_value)\n\nbearish_cross = ta.crossunder(close, ma_value)\n\n\n\n// Price position relative to MA\n\nprice_above_ma = close > ma_value\n\nprice_below_ma = close < ma_value\n\n\n\n// ==================== FULL CANDLE CONFIRMATION ====================\n\n// Full candle above MA: open, high, low, close all above MA\n\nfull_candle_above = open > ma_value and high > ma_value and low > ma_value and close > ma_value\n\n\n\n// Full candle below MA: open, high, low, close all below MA\n\nfull_candle_below = open < ma_value and high < ma_value and low < ma_value and close < ma_value\n\n\n\n// Track if we had a crossover recently and haven't entered yet\n\nvar bool waiting_for_long = false\n\nvar bool waiting_for_short = false\n\n\n\n// Reset waiting flags if price crosses back OR if trend filter changes\n\nif bearish_cross\n\n    waiting_for_long := false\n\n    waiting_for_long\n\nif bullish_cross\n\n    waiting_for_short := false\n\n    waiting_for_short\n\n\n\n// Also reset waiting flags if trend filter condition is no longer valid\n\nif use_trend_filter\n\n    if not trend_is_bullish\n\n        waiting_for_long := false\n\n        waiting_for_long\n\n    if not trend_is_bearish\n\n        waiting_for_short := false\n\n        waiting_for_short\n\n\n\n// Entry conditions based on mode\n\nbool long_condition = false\n\nbool short_condition = false\n\n\n\nif entry_mode == 'Crossover'\n\n    long_condition := bullish_cross and enable_long and trend_is_bullish\n\n    short_condition := bearish_cross and enable_short and trend_is_bearish\n\n    short_condition\n\nelse if entry_mode == 'Full Candle Confirmation'\n\n    // Mark that we're waiting for confirmation after crossover (only if trend allows)\n\n    if bullish_cross and trend_is_bullish\n\n        waiting_for_long := true\n\n        waiting_for_long\n\n    if bearish_cross and trend_is_bearish\n\n        waiting_for_short := true\n\n        waiting_for_short\n\n\n\n    // Enter when we get a full candle above/below after crossover (and trend still valid)\n\n    long_condition := waiting_for_long and full_candle_above and enable_long and trend_is_bullish\n\n    short_condition := waiting_for_short and full_candle_below and enable_short and trend_is_bearish\n\n\n\n    // Reset flags after entry\n\n    if long_condition\n\n        waiting_for_long := false\n\n        waiting_for_long\n\n    if short_condition\n\n        waiting_for_short := false\n\n        waiting_for_short\n\n\n\n// ==================== DYNAMIC COLOR ====================\n\n// Green when price above MA, Red when price below MA\n\nma_color = price_above_ma ? color.new(#04b304, 25) : color.new(#d60303, 19)\n\n\n\n// Trend MA color - blue\n\ntrend_ma_color = color.new(#0066ff, 0)\n\n\n\n// ==================== PLOT MA ====================\n\nplot(ma_value, 'Moving Average', color = ma_color, linewidth = 1)\n\nplot(use_trend_filter ? trend_ma_value : na, 'Trend Filter MA', color = trend_ma_color, linewidth = 1)\n\n\n\n// ==================== STRATEGY EXECUTION ====================\n\n// Entry logic\n\nif long_condition\n\n    strategy.close('Short')\n\n    strategy.entry('Long', strategy.long)\n\n\n\nif short_condition\n\n    strategy.close('Long')\n\n    strategy.entry('Short', strategy.short)\n\n\n\n// Exit logic - close on opposite crossover\n\nif bearish_cross and strategy.position_size > 0\n\n    strategy.close('Long', comment = 'Exit on Crossunder')\n\n\n\nif bullish_cross and strategy.position_size < 0\n\n    strategy.close('Short', comment = 'Exit on Crossover')"
  }
]